<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Decision Tree]]></title>
    <url>%2F2019%2F11%2F23%2Fdecision-tree%2F</url>
    <content type="text"><![CDATA[ä»‹ç»å†³ç­–æ ‘çš„å®šä¹‰ã€ä¸‰ç§ä¸åŒçš„å†³ç­–æ ‘å’Œä¼˜åŠ£ç­‰ç›¸å…³åˆ†æžã€‚ ä»Žæ•°å­¦ä¸Šè®²ï¼Œå†³ç­–æ ‘æ˜¯ä¸€ä¸ªåˆ†æ®µå‡½æ•°ã€‚å†³ç­–æ ‘æ˜¯ä¸€ç§åŸºæœ¬çš„åˆ†ç±»å’Œå›žå½’æ–¹æ³•ã€‚å†³ç­–æ ‘çš„å­¦ä¹ é€šå¸¸åŒ…æ‹¬ä¸‰ä¸ªæ­¥éª¤ï¼š ç‰¹å¾é€‰æ‹©ã€å†³ç­–æ ‘çš„ç”Ÿæˆå’Œå†³ç­–æ ‘çš„ä¿®å»ºã€‚ä¸»è¦æœ‰ä¸‰ç§ç®—æ³•ï¼š ID3ã€C4.5ç”Ÿæˆç®—æ³•å’ŒCART ç®—æ³•ã€‚ A learned binary tree is actually a partitioning of the input space. You can think of each input variable as a dimension on a p-dimensional space. The decision tree split this up into rectangles (when p=2 input variables) or some kind of hyper-rectangles with more inputs. å½“å†³ç­–æ ‘è®­ç»ƒå®Œä¹‹åŽï¼Œå°±ç›¸å½“äºŽæŠŠ $p$ ç»´ç©ºé—´åˆ†æˆäº†è‹¥å¹²ä¸ªå­ç©ºé—´ï¼ˆæ•°é‡æ˜¯å’Œå¶å­èŠ‚ç‚¹æ•°é‡ç›¸åŒï¼‰ï¼Œç„¶åŽpredict çš„è¿‡ç¨‹å°±æ˜¯æŠŠæŸä¸ªæ ·æœ¬æ”¾åˆ°æŸä¸ªç©ºé—´çš„è¿‡ç¨‹ã€‚ å†³ç­–æ ‘çš„å®šä¹‰ä¸‰ç§ç®—æ³• As we move further down the tree, the level of impurity or uncertainty decreases, thus leading to a better classification or best split at every node. To decide the same, splitting measures such as Information Gain, Gini Index, etc. are used. å½“æ²¿ç€æ ‘çš„ç»“æž„å¾€ä¸‹èµ°çš„æ—¶å€™ï¼Œæ ·æœ¬çš„ä¸ç¡®å®šæ€§æˆ–è€…â€impurityâ€œåº”è¯¥æ˜¯ä¸‹é™çš„ã€‚è¡¡é‡çš„æŒ‡æ ‡æœ‰ Gini Indexæˆ–è€…Information Gainã€‚ CARTç®—æ³• CART algorithm can be used for building both Classification and Regression Decision Trees. The impurity (or purity) measure used in building decision tree in CART is Gini Index. The decision tree built by CART algorithm is always a binary decision tree (each node will have only two child nodes). æ—¢å¯ä»¥ä½¿ç”¨åœ¨åˆ†ç±»åœºæ™¯ä¹Ÿå¯ä»¥ä½¿ç”¨åœ¨å›žå½’åœºæ™¯ï¼ŒåŸºäºŽäºŒå‰æ ‘æž„å»ºã€‚ For regression predictive modeling problems the cost function that is minimized to choose split points is the sum squared error across all training samples that fall within the rectangle:$$sum(y- prediction) ^2$$For classification the Gini index function is used which provides an indication of how â€œpureâ€ the leaf nodes are (how mixed the training data assigned to each node is). ä»¥ greedy splitting ä¸ºä¾‹ï¼Œå½“ç„¶ä¹Ÿæœ‰åŸºäºŽè¿™ç§æ–¹å¼çš„ä¼˜åŒ–ï¼Œæ¯”å¦‚åœ¨xgboost ä¸­ä½¿ç”¨æ¡¶çš„æ–¹å¼è¿›è¡Œä¼˜åŒ–ã€‚greedy splittinig ç®€å•è¯´æ˜¯å¯¹äºŽæ ·æœ¬ä¸­çš„æ¯ä¸ªç‰¹å¾å’Œç‰¹å¾ä¸­çš„æ¯ä¸ªåˆ†è£‚ç‚¹è¿›è¡Œæžšä¸¾ã€‚å¯¹äºŽå›žå½’é—®é¢˜ï¼Œä½¿ç”¨å‡æ–¹å·®ä½œä¸ºloss functionï¼›å¯¹äºŽäºŒåˆ†ç±»é—®é¢˜ï¼Œä½¿ç”¨gini ç³»æ•°ä½œä¸ºloss functionã€‚ Each root node represents a single input variable (x) and a split point on that variable (assuming the variable is numeric). The leaf nodes of the tree contain an output variable (y) which is used to make a prediction. æ ‘çš„ç»“æž„ï¼šæ ¹èŠ‚ç‚¹æ˜¯æ•°æ®çš„è¾“å…¥ $x$ï¼ˆ$x$ æ˜¯å¯ä»¥åŒ…å«è‹¥å¹²ä¸ªç‰¹å¾çš„ï¼‰ï¼Œ å¶å­èŠ‚ç‚¹æ˜¯æ•°å€¼ç”¨äºŽ make a prediciton. CARTç®—æ³•åŸºäºŽGini ç³»æ•°ã€‚ä¸‹é¢ä»‹ç»å…³äºŽGIniç³»æ•°çš„å®šä¹‰ï¼Œè®¡ç®—çš„ä¾‹å­ã€‚ ç¬¬ä¸€ç§å®šä¹‰ Gini index or Gini impurity measures the degree or probability of a particular variable being wrongly classified when it is randomly chosen.Gini Index is a metric to measure how often a randomly chosen element would be incorrectly identified. åŸºå°¼ç³»æ•°æˆ–è€…åŸºå°¼ä¸çº¯ï¼š ä»»æ„é€‰æ‹©ä¸€ä¸ªæ ·æœ¬ï¼Œè¯¥æ ·æœ¬è¢«é”™è¯¯åˆ†ç±»çš„æ¦‚çŽ‡ã€‚è¡¨ç¤ºä¸ºä»¥ä¸‹çš„å½¢å¼ $$Gini =1-\sum _{i=1} ^{C}(p _{i}) ^{2}$$ å…¶ä¸­ $C$è¡¨ç¤ºç±»åˆ«çš„ä¸ªæ•°ã€‚åœ¨xgboost æˆ–è€…è¯´åœ¨ boosted tree ä¸­ä½¿ç”¨çš„æ˜¯è¯¥æŒ‡æ ‡ã€‚ It means an attribute with lower Gini index should be preferred. æ•°å€¼è¶Šå°ï¼Œé‚£ä¹ˆæœ€åŽçš„ç»“æžœæ˜¯è¶Šå¥½çš„ The algorithm works as$ 1 â€“ ( P(class1)^2 + P(class2)^2 + â€¦ + P(classN)^2)$ è¯¦ç»†æƒ…å†µçœ‹ä¸‹é¢çš„ä¾‹å­ã€‚å½“é€‰æ‹©ä¸€ä¸ªåˆ†è£‚ç‚¹ä¹‹åŽï¼Œè®¡ç®—æ¯ä¸ªä¸åŒç±»çš„æ¦‚çŽ‡è¿›è€Œè®¡ç®—Gini ç³»æ•°ã€‚ ç¬¬äºŒç§å®šä¹‰ Gini impurity is a measure of misclassification, which applies in a multiclass classifier context.Gini coefficient applies to binary classification and requires a classifier that can in some way rank examples according to the likelihood of being in a positive class. ç¬¬ä¸‰ç§å®šä¹‰ æ•°æ®é›†åˆ ð· çš„çº¯åº¦å¯ç”¨åŸºå°¼æŒ‡æ•°æ¥åº¦é‡ï¼š$$Gini ( D ) = \sum _ { k = 1 } ^ { | \mathcal { Y } | } \sum _ { k ^ { \prime } \neq k } p _ { k } p _ { k ^ { \prime } } = 1 - \sum _ { k = 1 } ^ { \mathcal { V } } p _ { k } ^ { 2 }$$ç›´è§‚æ¥çœ‹ï¼Œ$Gini(ð·) $ åæ˜ äº†ä»Žæ•°æ®é›† ð· ä¸­éšæœºæŠ½å–ä¸¤ä¸ªæ ·æœ¬ï¼Œå…¶ç±»åˆ«æ ‡è®°ä¸ä¸€è‡´çš„æ¦‚çŽ‡ã€‚å› æ­¤ï¼Œ$Gini(ð·) $ è¶Šå°ï¼Œåˆ™æ•°æ®é›† ð· çš„çº¯åº¦è¶Šé«˜ã€‚ å¯¹ç‰¹å®šå±žæ€§ ð‘Ž çš„åŸºå°¼æŒ‡æ•°å®šä¹‰å¦‚ä¸‹ï¼š$$Gini _{index}( D , a ) = \sum _ { v = 1 } ^ { V } \frac { | D _ { v } | } { | D | } \operatorname { Gini } ( D _ { v } )$$æˆ‘ä»¬åœ¨å€™é€‰å±žæ€§é›†åˆ ð´ ä¸­ï¼Œé€‰æ‹©é‚£ä¸ªä½¿å¾—åˆ’åˆ†åŽåŸºå°¼æŒ‡æ•°æœ€å°çš„å±žæ€§ä½œä¸ºæœ€ä¼˜åˆ’åˆ†å±žæ€§ï¼Œå³ï¼š $$a _ { * } = \arg \min _ { a \in A } Gini _{index } ( D , a )$$ é‡‡ç”¨åŸºå°¼æŒ‡æ•°ä½œä¸ºåˆ’åˆ†å±žæ€§çš„åˆ¤æ®çš„å†³ç­–æ ‘æ˜¯ä¸€ç§ CART å†³ç­–æ ‘ã€‚ ä¾‹å­ é€‰æ‹©æœ€ä¼˜åˆ†ç±»ç‚¹çš„æ•´ä½“æ€è·¯ï¼šé¦–å…ˆéåŽ†ç‰¹å¾ï¼Œåœ¨æ¯ä¸ªç‰¹å¾å†…éåŽ†å¯ä»¥åˆ†è£‚çš„ç‚¹ã€‚æ¯”å¦‚ Calculating Gini Index for Var A:Value &gt;= 5: 12Attribute A &gt;= 5 &amp; class = positive: $\frac{5}{12}$Attribute A &gt;= 5 &amp; class = negative: $\frac{7}{12} $$Gini(5, 7) = 1 â€“ [ ( \frac{5}{12} ) ^{2} + ( \frac{7}{12} ) ^{2} ] = 0.4860 $Value &lt; 5: 4Attribute A &lt; 5 &amp; class = positive: $\frac{3}{4} $Attribute A &lt; 5 &amp; class = negative: $\frac{1}{4} $$Gini(3, 1) = 1 â€“ [ ( \frac{3}{4} ) ^{2} + ( \frac{1}{4} ) ^{2} ] = 0.375 $By adding weight and sum each of the gini indices:$gini(Target, A) = ( \frac{12}{16} ) * (0.486) + ( \frac{4}{16} ) * (0.375) = 0.45825 $ æ‰€ä»¥å¯¹äºŽç‰¹å¾A é‚£ä¹ˆå¾—åˆ°çš„åŸºå°¼ç³»æ•°æ˜¯ 0.45825ã€‚ åŒç†å¯ä»¥è®¡ç®—è®¡ç®—ç‰¹å¾Bï¼ŒCâ€¦ H. ç„¶åŽé€‰æ‹©åŸºå°¼ç³»æ•°æœ€å°çš„ç‰¹å¾ä½œä¸ºå½“å‰çš„åˆ†ç±»ç»“ç‚¹ã€‚ å…³äºŽä¾‹å­ä»‹ç»æ›´åŠ è¯¦ç»†çš„å†…å®¹ï¼Œå‚çœ‹Decision Tree Introduction with example ID3ID3 ï¼ˆIterative Dichotomiser 3ï¼‰ åŸºäºŽä¿¡æ¯å¢žç›Šè®¡ç®—ã€‚ ä¿¡æ¯å¢žç›Šçš„å®šä¹‰ This algorithm uses Information Gain to decide which attribute is to be used classify the current subset of the data. For each level of the tree, information gain is calculated for the remaining data recursively. æ˜¯åŸºäºŽä¿¡æ¯å¢žç›Šä½œä¸ºè¡¡é‡çš„æŒ‡æ ‡ã€‚ç†µå…¬å¼è¡¨ç¤ºä¸ºï¼š$$E=\sum _{i=1} ^{C}-p _{i} * \log _{2}(p _{i})$$ ä¿¡æ¯å¢žç›Šçš„è¡¨ç¤ºä¸ºï¼š$$Gain(D, C_1) =H(D) - E _{C_1}$$å…¶ä¸­ $H(D)$ æ˜¯åˆ’åˆ†å‰çš„ä¿¡æ¯ç†µï¼Œ$E _{C_1}$ æ˜¯åˆ’åˆ†ä¹‹åŽçš„ä¿¡æ¯ç†µã€‚ ç†µï¼ˆentropyï¼‰ï¼š ç†µæŒ‡çš„æ˜¯ä½“ç³»çš„æ··ä¹±çš„ç¨‹åº¦ä¿¡æ¯å¢žç›Šï¼ˆinformation gainï¼‰ï¼š åœ¨åˆ’åˆ†æ•°æ®é›†å‰åŽä¿¡æ¯å‘ç”Ÿçš„å˜åŒ–ç§°ä¸ºä¿¡æ¯å¢žç›Šï¼Œä¿¡æ¯å¢žç›Šè¶Šå¤§ï¼Œç¡®å®šæ€§è¶Šå¼ºã€‚ å¯¹äºŽGini ç³»æ•°æ˜¯è¶Šå°è¶Šå¥½ï¼Œä½†æ˜¯å¯¹äºŽä¿¡æ¯å¢žç›Šæ¥è¯´æ˜¯è¶Šå¤§è¶Šå¥½ã€‚ è®¡ç®—ä¿¡æ¯å¢žç›Šçš„ä¾‹å­ 1234567891011121314151617181920åŽŸå§‹çš„æ•°æ®é›†ï¼šç¼–å· è‰²æ³½ æ ¹è’‚ æ•²å£° çº¹ç† è„éƒ¨ è§¦æ„Ÿ å¥½ç“œ1 é’ç»¿ èœ·ç¼© æµŠå“ æ¸…æ™° å‡¹é™· ç¡¬æ»‘ æ˜¯2 ä¹Œé»‘ èœ·ç¼© æ²‰é—· æ¸…æ™° å‡¹é™· ç¡¬æ»‘ æ˜¯3 ä¹Œé»‘ èœ·ç¼© æµŠå“ æ¸…æ™° å‡¹é™· ç¡¬æ»‘ æ˜¯4 é’ç»¿ èœ·ç¼© æ²‰é—· æ¸…æ™° å‡¹é™· ç¡¬æ»‘ æ˜¯5 æµ…ç™½ èœ·ç¼© æµŠå“ æ¸…æ™° å‡¹é™· ç¡¬æ»‘ æ˜¯6 é’ç»¿ ç¨èœ· æµŠå“ æ¸…æ™° ç¨å‡¹ è½¯ç²˜ æ˜¯7 ä¹Œé»‘ ç¨èœ· æµŠå“ ç¨ç³Š ç¨å‡¹ è½¯ç²˜ æ˜¯8 ä¹Œé»‘ ç¨èœ· æµŠå“ æ¸…æ™° ç¨å‡¹ ç¡¬æ»‘ æ˜¯9 ä¹Œé»‘ ç¨èœ· æ²‰é—· ç¨ç³Š ç¨å‡¹ ç¡¬æ»‘ å¦10 é’ç»¿ ç¡¬æŒº æ¸…è„† æ¸…æ™° å¹³å¦ è½¯ç²˜ å¦11 æµ…ç™½ ç¡¬æŒº æ¸…è„† æ¨¡ç³Š å¹³å¦ ç¡¬æ»‘ å¦12 æµ…ç™½ èœ·ç¼© æµŠå“ æ¨¡ç³Š å¹³å¦ è½¯ç²˜ å¦13 é’ç»¿ ç¨èœ· æµŠå“ ç¨ç³Š å‡¹é™· ç¡¬æ»‘ å¦14 æµ…ç™½ ç¨èœ· æ²‰é—· ç¨ç³Š å‡¹é™· ç¡¬æ»‘ å¦15 ä¹Œé»‘ ç¨èœ· æµŠå“ æ¸…æ™° ç¨å‡¹ è½¯ç²˜ å¦16 æµ…ç™½ èœ·ç¼© æµŠå“ æ¨¡ç³Š å¹³å¦ ç¡¬æ»‘ å¦17 é’ç»¿ èœ·ç¼© æ²‰é—· ç¨ç³Š ç¨å‡¹ ç¡¬æ»‘ å¦ ä½¿ç”¨ä¸Šé¢çš„æ•°æ®é›†è¿›è¡Œè¯´æ˜Žã€‚åœ¨å†³ç­–æ ‘å­¦ä¹ å¼€å§‹æ—¶ï¼Œæ ¹ç»“ç‚¹åŒ…å« ð· ä¸­æ‰€æœ‰æ ·ä¾‹ï¼Œæ­£ä¾‹å  $p _ { 1 } = \frac { 8 } { 17 }$ï¼Œåä¾‹å $ p_2=\frac{9}{17}$ã€‚æ ¹ç»“ç‚¹çš„ä¿¡æ¯ç†µï¼ˆä¸‹é¢æˆ‘ä»¬éƒ½ä»¥æ¯”ç‰¹ä¸ºå•ä½è®¡ç®—ï¼‰ä¸ºï¼š $$H ( D ) = - \sum _ { k = 1 } ^ { 2 } p ( k ) \log _ { 2 } p ( k ) = - ( \frac { 7 } { 17 } \log _ { 2 } \frac { 7 } { 17 } + \frac { 9 } { 17 } \log _ { 2 } \frac { 9 } { 17 } ) = 0.998$$ ç„¶åŽæˆ‘ä»¬è¦è®¡ç®—å‡ºä¸Žå½“å‰å±žæ€§é›†åˆ {è‰²æ³½ã€æ ¹è’‚ã€æ•²å£°ã€çº¹ç†ã€è„éƒ¨ã€è§¦æ„Ÿ}ä¸­æ¯ä¸ªå±žæ€§çš„ ä¿¡æ¯å¢žç›Šï¼Œä¹Ÿå°±æ˜¯å¯¹åº”çš„äº’ä¿¡æ¯ã€‚ä»¥å±žæ€§â€œè‰²æ³½â€ä¸ºä¾‹ï¼Œå®ƒæœ‰ 3 ä¸ªå¯èƒ½å–å€¼ï¼š{é’ç»¿ã€ä¹Œé»‘ã€æµ…ç™½}ã€‚ä»¥è¯¥å±žæ€§å¯¹æ•°æ®é›†è¿›è¡Œåˆ’åˆ†ï¼Œå¯ä»¥å¾—åˆ° 3 ä¸ªå­é›†ï¼Œåˆ†åˆ«ä¸ºï¼š$D_1(è‰²æ³½=é’ç»¿) $ã€$ D_2(è‰²æ³½=ä¹Œé»‘)$ ã€$D_3(è‰²æ³½=æµ…ç™½)$ã€‚ å¯¹å­é›†$ D_1$ æ¥è¯´ï¼ŒåŒ…å«äº†ç¼–å·ä¸º {1,4,6,10,13,17} çš„ 6 ä¸ªæ ·ä¾‹ï¼Œå…¶ä¸­æ­£ä¾‹ä¸º {1,4,6}ï¼Œå $ p_1=36$ ï¼›åä¾‹ä¸º {10,13,17}ï¼Œå  $p_1=36$ã€‚è®¡ç®—å…¶ç†µä¸ºï¼š$$H ( D _ { 1 } ) = - ( \frac { 3 } { 6 } \log _ { 2 } \frac { 3 } { 6 } + \frac { 3 } { 6 } \log _ { 2 } \frac { 3 } { 6 } ) = 1.000$$ ä¾æ¬¡å¯ä»¥è®¡ç®—å¦å¤–ä¸¤ä¸ªå­é›†çš„ä¿¡æ¯ç†µä¸ºï¼š$$H ( D _ { 2 } ) = 0.918$$$$H ( D _ { 3 } ) = 0.722$$æœ€ç»ˆå¯ä»¥è®¡ç®—æ•°æ®é›† $D$ çš„ç±»åˆ«ä¿¡æ¯åœ¨å±žæ€§â€œè‰²æ³½â€ç†µçš„ä¿¡æ¯å¢žç›Šï¼ˆä¹Ÿå¯ä»¥ç†è§£ä¸ºç±»åˆ«ä¸Žâ€œè‰²æ³½â€å±žæ€§ä¹‹é—´çš„äº’ä¿¡æ¯ï¼‰ä¸ºï¼š $$\begin{split}Gain(D, è‰²æ³½) &amp;= H ( D ) - \sum _ { v = 1 } ^ { 3 } p ( v ) H ( D _ { v } ) \\&amp;= 0.998 - ( \frac { 6 } { 17 } \times 1.000 + \frac { 6 } { 17 } \times 0.918 + \frac { 5 } { 17 } \times 0.722 ) \\&amp;= 0.109\end{split}$$é‡å¤ä¸Šè¿°çš„è®¡ç®—æ­¥éª¤ï¼Œæˆ‘ä»¬å¯ä»¥è®¡ç®—å‡ºå…¶ä»–å±žæ€§çš„ä¿¡æ¯å¢žç›Šï¼š $$\begin{split}Gain(ð·,æ ¹è’‚) &amp;=0.143 \\Gain(ð·,æ•²å£°) &amp;= 0.141 \\Gain(ð·,çº¹ç†) &amp;= 0.381\\Gain(ð·,è„éƒ¨) &amp;= 0.289 \\Gain(ð·,è§¦æ„Ÿ) &amp;=0.006\end{split}$$ ç»è¿‡æ¯”è¾ƒï¼Œå‘çŽ°é‡‡ç”¨â€œçº¹ç†â€è¿›è¡Œåˆ’åˆ†å¾—åˆ°çš„ä¿¡æ¯å¢žç›Šæœ€å¤§ï¼ŒäºŽæ˜¯å®ƒè¢«é€‰ä¸ºåˆ’åˆ†å±žæ€§ã€‚ä¸‹å›¾ç»™å‡ºäº†æ ¹æ®â€œçº¹ç†â€å±žæ€§åˆ’åˆ†ä¹‹åŽçš„æ•°æ®å­é›†ï¼š å¯¹æ¯ä¸€ä¸ªæ•°æ®å­é›†æŒ‰ç…§ä¸Šè¾¹çš„æ­¥éª¤ç»§ç»­åˆ’åˆ†ä¸‹åŽ»å°±èƒ½å¾—åˆ°æœ€ç»ˆçš„å†³ç­–æ ‘ï¼ˆéœ€è¦æ³¨æ„çš„æ˜¯æ¯æ¬¡æ ·ä¾‹å­é›†ä¸­çš„å±žæ€§ä¸åŒ…å«çˆ¶ç»“ç‚¹ä¸­åˆ’åˆ†æ‰€ä¾èµ–çš„å±žæ€§ï¼‰ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š C4.5 This algorithm is the successor of the ID3 algorithm. This algorithm uses either Information gain or Gain ratio to decide upon the classifying attribute. It is a direct improvement from the ID3 algorithm as it can handle both continuous and missing attribute values. æ˜¯åŸºäºŽID3çš„æ”¹è¿›ï¼ŒåŸºäºŽä¿¡æ¯å¢žç›ŠçŽ‡ï¼Œæ”¹è¿›ç‚¹åœ¨äºŽæ”¯æŒè¿žç»­æ€§å˜é‡å’Œç¼ºçœå€¼ã€‚ ä¸Šä¸€ç§æ–¹å¼ç¼ºç‚¹åœ¨äºŽå½“ä½¿ç”¨ä¿¡æ¯å¢žç›Šåˆ’åˆ†æ—¶å€™ï¼Œå½“æŸä¸€ä¸ªå±žæ€§çš„å–å€¼ç±»åˆ«éžå¸¸å¤šæ—¶ï¼Œå¯¹åº”çš„å±žæ€§çš„è‡ªå·±å°ï¼Œé‚£ä¹ˆåˆ†ç±»ä¿¡æ¯ç†µä¼šæ¯”è¾ƒå°ï¼Œæœ€åŽçš„ä¿¡æ¯å¢žç›Šä¼šæ¯”è¾ƒå¤§ã€‚ åŽŸå› ï¼šlog å‡½æ•°ä¸æ˜¯çº¿æ€§çš„ï¼Œ ä¿¡æ¯é‡å‡å°‘é€Ÿåº¦å¤§äºŽç±»åˆ«æ•°é‡å¢žåŠ çš„é€Ÿåº¦ã€‚ï¼ˆè™½ç„¶é¡¹æ•°å¤šäº†ï¼Œä½†æ˜¯æ¯é¡¹å‡å°‘çš„é€Ÿåº¦æ›´å¤§ï¼‰ ï¼ˆæœ€åŽçš„é€‰æ‹©ç­–ç•¥è¿˜æ˜¯æ¯”è¾ƒç‰›é€¼çš„ï¼Œå„ç§æƒ…å†µéƒ½æ˜¯å¯ä»¥è€ƒè™‘åˆ°çš„ï¼‰æ‰€ä»¥ç¬¬äºŒç§ç­–ç•¥é‡‡ç”¨ä¿¡æ¯å¢žç›ŠçŽ‡ï¼Œç®€å•æ¥è¯´å°±æ˜¯å½’ä¸€åŒ–ï¼Œå°†æ•°æ®é›†çš„å¤§å°è€ƒè™‘åœ¨å†…ã€‚æœ€åŽä¸€ç‚¹éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¢žç›ŠçŽ‡å‡†åˆ™è™½ç„¶å‡å°‘äº†å¯¹å–å€¼æ•°ç›®è¾ƒå¤šçš„å±žæ€§ä¾èµ–ï¼Œä½†æ˜¯å¢žåŠ äº†å¯¹å–å€¼æ•°ç›®è¾ƒå°‘çš„å±žæ€§åå¥½ã€‚å› æ­¤ï¼Œ C4.5 å¹¶æ²¡æœ‰ç›´æŽ¥é€‰æ‹©å¢žç›ŠçŽ‡æœ€å¤§çš„å€™é€‰åˆ’åˆ†å±žæ€§ï¼Œè€Œæ˜¯ä½¿ç”¨äº†ä¸€ä¸ªå¯å‘å¼ï¼šå…ˆä»Žå€™é€‰åˆ’åˆ†å±žæ€§ä¸­æ‰¾å‡º ä¿¡æ¯å¢žç›Š é«˜äºŽ å¹³å‡æ°´å¹³ çš„å±žæ€§ï¼Œå†ä»Žä¸­é€‰æ‹© å¢žç›ŠçŽ‡ æœ€é«˜çš„ã€‚ æ¯”è¾ƒ Gini Index, unlike information gain, isnâ€™t computationally intensive as it doesnâ€™t involve the logarithm function used to calculate entropy in information gain, which is why Gini Index is preferred over Information gain. Gini index çš„è®¡ç®—é‡ç›¸å¯¹äºŽä¿¡æ¯å¢žç›Šæ˜¯è¦å°ï¼Œå› ä¸ºåŽè€…æœ‰log è¿ç®—ã€‚ åˆ†æž æ ‘å½¢ç»“æž„ä¸ºä»€ä¹ˆä¸éœ€è¦å½’ä¸€åŒ–ï¼Ÿ æ•°å€¼ç¼©æ”¾ä¸å½±å“åˆ†è£‚ç‚¹ä½ç½®ï¼Œå¯¹æ ‘æ¨¡åž‹çš„ç»“æž„ä¸é€ æˆå½±å“ã€‚ æŒ‰ç…§ç‰¹å¾å€¼è¿›è¡ŒæŽ’åºçš„ï¼ŒæŽ’åºçš„é¡ºåºä¸å˜ï¼Œé‚£ä¹ˆæ‰€å±žçš„åˆ†æ”¯ä»¥åŠåˆ†è£‚ç‚¹å°±ä¸ä¼šæœ‰ä¸åŒã€‚ æ ‘æ¨¡åž‹æ˜¯ä¸èƒ½è¿›è¡Œæ¢¯åº¦ä¸‹é™çš„ï¼Œå› ä¸ºæž„å»ºæ ‘æ¨¡åž‹ï¼ˆå›žå½’æ ‘ï¼‰å¯»æ‰¾æœ€ä¼˜ç‚¹æ—¶æ˜¯é€šè¿‡å¯»æ‰¾æœ€ä¼˜åˆ†è£‚ç‚¹å®Œæˆçš„ï¼Œå› æ­¤æ ‘æ¨¡åž‹æ˜¯é˜¶è·ƒçš„ï¼Œé˜¶è·ƒç‚¹æ˜¯ä¸å¯å¯¼çš„ï¼Œå¹¶ä¸”æ±‚å¯¼æ²¡æ„ä¹‰ï¼Œä¹Ÿå°±ä¸éœ€è¦å½’ä¸€åŒ–ã€‚ å†³ç­–æ ‘å¦‚ä½•è¿›è¡Œå‰ªæž? åŸºæœ¬ä¸Šæœ‰é¢„å‰ªæžå’ŒåŽå‰ªæžä¸¤ç§ç­–ç•¥ã€‚ The most common stopping procedure is to use a minimum count on the number of training instances assigned to each leaf node. If the count is less than some minimum then the split is not accepted and the node is taken as a final leaf node. é¢„å‰ªæžï¼Œåœ¨è®­ç»ƒè¿‡ç¨‹ä¸­ï¼Œä½¿ç”¨éªŒè¯æ•°æ®é›†éªŒè¯ï¼Œå¦‚æžœåˆ’åˆ†èƒ½å¤Ÿæé«˜åˆ’åˆ†çš„å‡†ç¡®æ€§ï¼Œé˜¿ä¹ˆå°±åˆ’åˆ†ï¼Œå¦åˆ™å°±æ ‡è®°ä¸ºå¶å­èŠ‚ç‚¹ã€‚ The fastest and simplest pruning method is to work through each leaf node in the tree and evaluate the effect of removing it using a hold-out test set. Leaf nodes are removed only if it results in a drop in the overall cost function on the entire test set. You stop removing nodes when no further improvements can be made. åŽå‰ªæžï¼Œå½“è®­ç»ƒå®Œæˆä¹‹åŽï¼Œè‡ªåº•å‘ä¸Šå¯¹å¶å­èŠ‚ç‚¹è¿›è¡Œæ£€æŸ¥ï¼Œå¦‚æžœåŽ»æŽ‰ä¸å½±å“åœ¨ æµ‹è¯•é›†ä¸Šçš„lossï¼Œé‚£ä¹ˆå°±åŽ»æŽ‰ ä¼˜ç¼ºç‚¹ ä¼˜ç‚¹ï¼š å†³ç­–æ ‘æ˜“äºŽç†è§£ï¼ˆèƒ½å¤Ÿå†™å‡ºåˆ¤æ–­çš„è·¯å¾„ï¼Œé€»è¾‘è¡¨è¾¾å¼ï¼‰å’Œå®žçŽ°ï¼Œ äººä»¬çŸ¥é“è¯¥å¦‚ä½•åŽ»ä¼˜åŒ–ã€‚ å¯ä»¥å¤„ç†ç¼ºçœæ•°æ®ï¼Œæ„å‘³ç€æ•°æ®çš„å‡†å¤‡å·¥ä½œæ˜¯æ¯”è¾ƒç®€å•çš„ã€‚ç›¸å¯¹æ¯”å…¶ä»–çš„æŠ€æœ¯ï¼Œå¾€å¾€éœ€è¦ä¸€èˆ¬åŒ–ä¹‹ç±»çš„æ“ä½œã€‚ èƒ½å¤Ÿå¤„ç†æ•°å€¼åž‹å’Œå¸¸è§„æ€§å±žæ€§ã€‚ å¯ä»¥å­¦ä¹ åˆ°ç‰¹å¾çš„ç»„åˆ ç¼ºç‚¹ï¼š å®¹æ˜“è¿‡æ‹Ÿåˆ å¯¹äºŽå„ä¸ªç±»åˆ«ä¸ä¸€è‡´çš„æ•°æ®ï¼Œå†³ç­–æ ‘å½“ä¸­ä¿¡æ¯å¢žç›Šçš„ç»“æžœåå‘äºŽé‚£äº›å…·æœ‰æ›´å¤šæ•°å€¼çš„ç‰¹å¾ã€‚]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>decision_tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[optimizer]]></title>
    <url>%2F2019%2F11%2F17%2Foptimizer%2F</url>
    <content type="text"><![CDATA[æ·±åº¦å­¦ä¹ ä¸­ä¼˜åŒ–å™¨ ï¼ˆoptimizerï¼‰è®²è§£ã€‚æ ¹æ®å­¦ä¹ çŽ‡çš„æƒ…å†µåˆ†æˆä¸‰ä¸ªé˜¶æ®µï¼ŒåŸºç¡€ç‰ˆæœ¬Gradient Descentï¼Œç„¶åŽæ˜¯äººå·¥è®¾ç½®å­¦ä¹ çŽ‡é˜¶æ®µå’Œè‡ªé€‚åº”å­¦ä¹ çŽ‡é˜¶æ®µã€‚ vanilla Gradient Descent é’ˆå¯¹æ•´ä¸ªæ•°æ®é›† $$\theta = \theta - \eta \cdot \nabla _ { \theta } J ( \theta )$$ç‰¹ç‚¹ï¼š ä½¿ç”¨æ•´ä¸ªæ•°æ®é›†è®¡ç®—æ¢¯åº¦ï¼Œè®¡ç®—èµ·æ¥éžå¸¸æ…¢ èƒ½å¤Ÿæ‰¾åˆ°å…¨å±€æœ€ä¼˜ç‚¹ Stochastic Gradient Descent (SGD) SGD åˆèµ°å…¥äº†å¦å¤–ä¸€ä¸ªæžç«¯ï¼ŒSGD æ‹¿åˆ°ä¸€ä¸ªæ•°æ®ä¹‹åŽï¼Œé©¬ä¸Šè®¡ç®—æ¢¯åº¦ï¼Œç„¶åŽå¯¹å‚æ•°è¿›è¡Œæ›´æ–°. $$\theta = \theta - \eta \cdot J \left( \theta ; x ^ { ( i ) } , y ^ { ( i ) } \right)$$ ç‰¹ç‚¹ï¼š æ— æ³•ä½¿ç”¨çŸ©é˜µåŠ é€Ÿè¿ç®— æ”¶æ•›é€Ÿåº¦å¿« Mini-Batch Gradient Descent ï¼ˆMBGDï¼‰ Mini-batch çš„æ–¹æ³•æ˜¯åœ¨ä¸Šè¿°ä¸¤ä¸ªæ–¹æ³•ä¸­å–äº†ä¸ªæŠ˜è¡·ï¼Œæ¯æ¬¡ä»Žå…¨éƒ¨çš„ç†Ÿç»ƒæ•°æ®ä¸­å–ä¸€ä¸ª mini-batch çš„æ•°æ®è®¡ç®—ã€‚ $$\theta = \theta - \eta \cdot J \left( \theta ; x ^ { ( i : i + n ) } , y ^ { ( i : i + n ) } \right)$$ batch size çš„é€‰æ‹© nï¼š ä¸€èˆ¬å–å€¼åœ¨ 50ï½ž256 ç›®å‰ï¼Œmini-batch çš„æ–¹æ³•æ˜¯æ·±åº¦å­¦ä¹ ä¸­ä¸»æµæ–¹æ³•ï¼Œå„ç§æ·±åº¦å­¦ä¹ å·¥å…·é»˜è®¤ä¹Ÿæ˜¯è¿™ç§æ–¹æ³•ã€‚ä¹Ÿå¯ä»¥æŠŠä¸Šè¿°ä¸¤ç§æ–¹æ³•çœ‹æˆæ˜¯ mini-batch çš„ç‰¹ä¾‹ï¼ŒBatch çš„æ–¹æ³•ï¼Œå°±æ˜¯ mini-batch size æ˜¯æ•´ä¸ªæ•°æ®é›†ï¼ŒSGD æ–¹æ³•å°±æ˜¯ min-batch=1 çš„æƒ…å†µ. ç›®å‰é‡åˆ°çš„é—®é¢˜ learning rate å¦‚ä½•è¿›è¡Œè‡ªåŠ¨è°ƒæ•´ å¦‚ä½•è·³å‡ºé©¬éžç‚¹ äººå·¥è®¾ç½®å­¦ä¹ çŽ‡ Momentum (heavy-ball method) $$x_{t+1}=x_{t}-\alpha \nabla f\left(x_{t}\right)+\mu\left(x_{t}-x_{t-1}\right), \quad \mu \in[0,1], \alpha&gt;0$$ å…¶ä¸­ $\mu$ æ˜¯åŠ¨é‡å› å­ï¼Œå–å€¼ 0.9 å·¦å³ã€‚ ä¼˜ç‚¹ï¼š å¯ä»¥åŠ é€Ÿ SGDï¼Œ å¹¶ä¸”æŠ‘åˆ¶éœ‡è¡ç¼ºç‚¹ï¼š Lessard et al. å‘çŽ°å¯¹äºŽç®€å•çš„å‡¸å‡½æ•° $f(x)$ ï¼Œmomentum ä¸èƒ½æ”¶æ•›ï¼Œè¯¾ä»¶é‡Œç»™å‡ºäº†ä¸€ä¸ªbad case Nesterov Accelerated Gradient å¯¹äºŽä¸Šé¢ momentumå‡ºçŽ°çš„bad caseï¼Œ Nesterov æ¥èƒŒé”…ã€‚ $$x_{t+1}=x_{t}+\mu\left(x_{t}-x_{t-1}\right)-\gamma \nabla f\left(x_{t}+\mu\left(x_{t}-x_{t-1}\right)\right)$$å…¶ä¸­å­¦ä¹ çŽ‡$\gamma$, momentumç³»æ•°$\mu$ å’Œå‚æ•°çš„åˆå§‹åŒ–$x_0$ï¼ˆå…¬å¼ä¸­æ²¡æœ‰æ˜¾ç¤ºå‡ºæ¥ï¼‰ ä¸¤è€…çš„åŒºåˆ«ï¼Œä¸€åˆ‡å°½åœ¨å›¾ä¸­ã€‚ï¼ˆç›¸åŒçš„é¢œè‰²è¡¨ç¤ºç›¸åŒå«ä¹‰ï¼‰ Nesterov Accelerated Gradientçš„å…³é”®åœ¨äºŽè®¡ç®—æ¢¯åº¦ä¹‹å‰åŠ ä¸Šäº†ä¹‹å‰ç§¯ç´¯çš„æ¢¯åº¦ã€‚Notice how the gradient step with Polyakâ€™s momentum is always perpendicular to the level set. taken from here ä¸¤ç§çš„ç›¸åŒç‚¹ï¼šéƒ½æ˜¯åŸºäºŽmomentumçš„ optimï¼Œéƒ½æ˜¯é’ˆå¯¹å‡¸ä¼˜åŒ–å‡½æ•°ï¼›ä¸åŒç‚¹ï¼šmomentum å¯¹äºŽç®€å•å¼ºå‡¸ä¼˜åŒ–å‡½æ•°ï¼Œæ¯”å¦‚å¯¼æ•°æ˜¯äºŒæ¬¡æ–¹çš„å‡½æ•°ï¼Œå¯èƒ½å‡ºçŽ°bad caseï¼›ç›¸å¯¹äºŽè€Œè¨€ï¼ŒNesterov Accelerated Gradientåœ¨å‡¸ä¼˜åŒ–å‡½æ•°ä¸­é€‚ç”¨æ€§æ›´å¹¿ã€‚ è‡ªé€‚åº”å­¦ä¹ çŽ‡æ–¹æ³• Adagrad ï¼ˆAdaptive gradient algorithmï¼‰ intuitionï¼šè‡ªåŠ¨è°ƒèŠ‚å­¦ä¹ çŽ‡ã€‚ $$\begin{split}n_{t} &amp;=n_{t-1}+g_{t}^{2} \\\Delta \theta_{t} &amp;=-\frac{\eta}{\sqrt{n_{t}+\epsilon}} * g_{t}\end{split}$$ å…¶ä¸­ $n_t$è¡¨ç¤ºä»Ž1åˆ°$t$ å½¢æˆçš„ä¸€ä¸ªé€’æŽ¨é¡¹ï¼Œä½œä¸ºä¸€ä¸ªçº¦æŸé¡¹ï¼Œ $\epsilon$ ç”¨æ¥ä¿è¯åˆ†æ¯éž0ï¼Œä¸€èˆ¬å– $1e-8$.å®žéªŒè¡¨æ˜Žï¼Œå¦‚æžœæ²¡æœ‰è¿›è¡Œå¹³æ–¹æ ¹æ“ä½œï¼Œé‚£ä¹ˆæ•ˆæžœå¾ˆå·®ã€‚ ç‰¹ç‚¹ï¼š ä¸ç”¨äººå·¥åŽ»tune å­¦ä¹ çŽ‡ï¼Œä½†æ˜¯ä»ç„¶éœ€è¦åœ¨å¼€å§‹æ—¶å€™ï¼Œç»™å®šä¸€ä¸ªå­¦ä¹ çŽ‡ï¼ˆä¾èµ–å…¨å±€åˆå§‹åŒ–å­¦ä¹ çŽ‡ï¼‰ æ¯æ¬¡å¢žåŠ çš„å—¾ä½¿ä¸€ä¸ªæ­£æ•°ï¼ˆå¹³æ–¹å’Œï¼‰ï¼Œæ‰€ä»¥è®­ç»ƒçš„ä¸­åŽæœŸï¼Œå­¦ä¹ çŽ‡æœ‰å¯èƒ½å˜å¾—éžå¸¸å° å®žé™…çš„ä½¿ç”¨æ•ˆæžœï¼šå¯¹äºŽå‡ºçŽ°é¢‘çŽ‡æ¯”è¾ƒé«˜çš„ç‰¹å¾çš„å‚æ•°ï¼Œé‚£ä¹ˆä½¿ç”¨è¾ƒå°çš„å­¦ä¹ çŽ‡ï¼›å¯¹äºŽå‡ºçŽ°é¢‘çŽ‡æ¯”è¾ƒä½Žçš„ç‰¹å¾çš„å‚æ•°ï¼Œä½¿ç”¨è¾ƒå¤§çš„å­¦ä¹ çŽ‡ã€‚å¯¹äºŽç¨€ç–æ•°æ®é›†ï¼Œæ•ˆæžœå¾ˆå¥½ã€‚æ¯”å¦‚è¯´åœ¨RNN ä¸­è®­ç»ƒè¯å‘é‡çš„è¿‡ç¨‹ï¼Œç»å¸¸ä½¿ç”¨åˆ°ã€‚ Adadelta intuitionï¼š è§£å†³ä½¿ç”¨Adagradè®­ç»ƒä¸­åŽæœŸï¼Œæ¢¯åº¦å¯èƒ½ä¸º0 çš„é—®é¢˜ ä¸ä¾èµ–äºŽåˆå§‹åŒ–çš„learning rate é¦–å…ˆå¤„ç†ç¬¬ä¸€ä¸ªé—®é¢˜ï¼šæ¢¯åº¦ä¸º0. ä¸ä½¿ç”¨ä¹‹å‰å…¨éƒ¨çš„æ¢¯åº¦å¹³æ–¹å’Œï¼Œä½¿ç”¨éƒ¨åˆ†ã€‚è¿™ä¸ªæ—¶å€™ä¸€ç§æ˜¯æš´åŠ›çš„æ»‘åŠ¨çª—å£çš„ç›¸åï¼Œä½†æ˜¯ä½œè€…ä½¿ç”¨å¦ä¸€ç§æ–¹æ³•ï¼š decayingã€‚$$E[g ^2] _t=\gamma E[ g ^2] _{t-1}+(1-\gamma) g _t ^2$$å…¶ä¸­ $\gamma$ æ˜¯ç±»ä¼¼momentumä¸­çš„è¶…å‚æ•°ï¼Œå¤§æ¦‚åœ¨ 0.9å·¦å³ã€‚ ç¬¬äºŒä¸ªé—®é¢˜æ˜¯åˆå§‹åŒ–å­¦ä¹ çŽ‡é—®é¢˜ã€‚å®šä¹‰äº†å¦ä¸€ä¸ªdecay ç³»æ•°ï¼Œåªä¸è¿‡è¿™ä¸ªæ˜¯åº”ç”¨åœ¨å‚æ•° $\theta$ ä¸Šçš„ï¼Œè€Œä¸æ˜¯ä¸Šé¢çš„ $g_t$ä¸Šã€‚ $$E[\Delta \theta ^2] _t=\gamma E[\Delta \theta ^2 ] _{t-1}+(1-\gamma) \Delta \theta _t ^2$$ ç„¶åŽæ˜¯å¸¸ç”¨çš„å¹³æ–¹æ ¹æ“ä½œï¼š$$R M S[\Delta \theta] _t=\sqrt{E [\Delta \theta ^2 ] _t+\epsilon}$$ æ‰€ä»¥å°†ä¸Šè¿°ä¸¤ä¸ªæ–¹é¢çš„æ›´æ–°æ•´åˆèµ·æ¥ï¼š$$\begin{split}\Delta \theta _t &amp;=-\frac{R M S[\Delta \theta] _{t-1}}{R M S[g] _{t}} g _t \\\theta _{t+1} &amp;=\theta _{t}+\Delta \theta _t\end{split}$$ ç‰¹ç‚¹ï¼šä¸ç”¨è®¾ç½®å…¨å±€çš„å­¦ä¹ çŽ‡ï¼Œå­¦ä¹ çŽ‡æ˜¯éšç€è¿­ä»£æ¬¡æ•°å˜åŒ–çš„ RMSprop RMSpropæ˜¯ Geoff Hinton åœ¨å…¶è¯¾ç¨‹ä¸­è®²åˆ°çš„ä¸€ç§æ–¹æ³•ã€‚intuition ä¹Ÿæ˜¯ä¸ºäº†è§£å†³ Adagrad ä¸­çš„å‡ºçŽ°çš„æ¢¯åº¦ä¸º0. å®žé™…ä¸Š RMSprop å°±æ˜¯ Adadelta ä¸­çš„ç¬¬ä¸€ä¸ªæ–¹é¢çš„å…¬å¼ã€‚ $$\begin{split}E[g ^2] _t &amp;=\gamma E[ g ^2] _{t-1}+(1-\gamma) g _t ^2 \\\theta _{t+1} &amp;= \theta _t-\frac{\eta}{\sqrt{E\left[g^{2}\right] _{t}+\epsilon}} g _{t}\end{split}$$å…¶ä¸­ HintonæŽ¨èè¶…å‚æ•° $\gamma =0.9$ï¼Œ $\epsilon =0.001$ã€‚ï¼ˆps RMSprop å’Œ Adadeltaè§£å†³çš„æ–¹æ¡ˆå«åšï¼š exponentially decaying average of past squared gradientsï¼‰ ç‰¹ç‚¹ï¼šè§£å†³äº† Adagrad ä¸­å‡ºçŽ°çš„æ¢¯åº¦ä¸º0çš„æƒ…å†µ Adamï¼šAdaptive Moment Estimation % è¿™ä¸ªæœ€å¤§çš„æ•™è®­å°±æ˜¯ï¼Œå½“åªå«æœ‰ _t ^t è¿™ç§ç¬¦å·çš„æ—¶å€™ï¼Œå°±ä¸è¦ä½¿ç”¨ {} ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹æ˜¯ä¸æ”¯æŒçš„ intuitionï¼šå¦‚æžœæ˜¯momentumæœºåˆ¶ç±»ä¼¼ä¸€ä¸ª ball running down a slope, é‚£ä¹ˆ Adam behaves a heavy ball with frictionã€‚ è¿™ç§æ€§è´¨æ˜¯æœ‰åˆ©äºŽå¤„ç†éžå‡¸ä¼˜åŒ–é—®é¢˜ï¼Œå¯èƒ½ä¸­é—´å‡ºçŽ°äº†ä¸€äº›å¹³æ»‘çš„å±€éƒ¨æœ€ä¼˜è§£ã€‚å¦‚åŒAdadelta å’Œ RMSpropï¼Œä½¿ç”¨äº†æ¢¯åº¦çš„äºŒé˜¶å¯¼æ•°ï¼Œå¦‚åŒmomentumï¼Œä½¿ç”¨äº†æ¢¯åº¦çš„ä¸€é˜¶å¯¼æ•°ï¼ŒæŠŠè¿™ä¸¤è€…ä¿¡æ¯ç»“åˆèµ·æ¥ï¼Œå°±æ˜¯momentumã€‚ In addition to storing an exponentially decaying average of past squared gradients $v_t$, like Adadelta and RMSprop, Adam also keeps an exponentially decaying average of past gradients $m_t$, similar to momentum. $$\begin{split}m _{t} &amp;=\beta _{1} m _{t-1}+(1-\beta _{1}) g _{t} \\v _{t} &amp;=\beta _{2} v _{t-1}+(1-\beta _{2}) g _{t} ^{2}\end{split}$$ å…¶ä¸­ $m_t$å’Œ $v_t$ åˆ†åˆ«æ˜¯å¯¹æ¢¯åº¦çš„ä¸€é˜¶çŸ©ä¼°è®¡ ï¼ˆfirst moment ï¼Œthe meanï¼‰ å’ŒäºŒé˜¶çŸ©ä¼°è®¡ï¼ˆthe second moment ï¼Œthe uncentered varianceï¼‰ï¼Œè¿™ä¸ªæ˜¯ Adamåå­—çš„ç”±æ¥ã€‚å®žéªŒä¸­å‘çŽ°ä¸Šè¿°å…¬å¼åœ¨åˆå§‹åŒ–é˜¶æ®µï¼Œ$m_t$ å’Œ$v_t$éƒ½æ˜¯è¶‹å‘äºŽ0ï¼Œå°¤å…¶æ˜¯å½“ $\beta_1$ å’Œ$\beta_2$ è§£å†³1çš„æ—¶å€™ã€‚ äºŽæ˜¯è¿›è¡Œäº† bias-corrected$$\begin{split}\hat{m} _{t} &amp;=\frac{m _{t}}{1-\beta _{1} ^{t}} \\\hat{v} _{t} &amp;=\frac{v _{t}}{1-\beta _{2} ^{t}}\end{split}$$æœ€åŽè¿›è¡Œäº†æ¢¯åº¦çš„æ›´æ–°ï¼š$$\theta _{t+1}=\theta _{t}-\frac{\eta}{\sqrt{\hat{v} _{t}}+\epsilon} \hat{m} _{t}$$ä½œè€…æŽ¨èçš„è¶…å‚æ•° $\beta_1 =0.9$ï¼Œ $\beta_2 =0.999$, $\epsilon =10 ^{-8}$ ç‰¹ç‚¹ï¼šä»Žå®žè·µçš„è§’åº¦ï¼ŒAdamæ˜¯ä¼˜äºŽä¸Šè¿°å‡ ç§çš„ã€‚æ‰€ä»¥å°±ä¸ç”¨é€‰æ‹©äº†ã€‚ å›¾ä¾‹å¦‚æžœç©ºé—´ä¸­å­˜åœ¨éžç‚¹ï¼š å¦‚æžœç©ºé—´ä¸­å­˜åœ¨è‹¥å¹²å’Œå±€éƒ¨æœ€ä¼˜ç‚¹ï¼š å¦‚æžœâ€¦ å‚è€ƒæ–‡çŒ® æ·±åº¦å­¦ä¹ æœ€å…¨ä¼˜åŒ–æ–¹æ³•æ€»ç»“æ¯”è¾ƒï¼ˆSGDï¼ŒAdagradï¼ŒAdadeltaï¼ŒAdamï¼ŒAdamaxï¼ŒNadamï¼‰An overview of gradient descent optimization algorithms]]></content>
      <categories>
        <category>Deep learning</category>
      </categories>
      <tags>
        <tag>optimizer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python learning å­¦ä¹ ç¬”è®°3]]></title>
    <url>%2F2019%2F11%2F04%2Fpython-learning3%2F</url>
    <content type="text"><![CDATA[python å­¦ä¹ ç¬”è®°ï¼Œä¹‹å‰æœ‰ä¸¤ç¯‡ç¬”è®°ï¼Œå› ä¸ºå¤ªå¤šäº†ï¼Œæ‰€ä»¥æ–°å¼€ä¸€ç¯‡ã€‚ python ä¸­å¸¸è§çš„åˆ¤åˆ«å‡½æ•° isinstance() åˆ¤æ–­ä¸€ä¸ªitem æ˜¯å¦æ˜¯list or tuple12345678def myextend(alist): blist = [] for item in alist: if isinstance(item, (list, tuple)): blist.extend(myextend(item)) else: blist.append(item) return blist åŸºæœ¬ç±»åž‹å¯¹äºŽ classinfo å¯ä»¥æ˜¯1intï¼Œfloatï¼Œboolï¼Œcomplexï¼Œstr(å­—ç¬¦ä¸²)ï¼Œlistï¼Œdict(å­—å…¸)ï¼Œsetï¼Œtuple isinstance() ä¸Ž type() åŒºåˆ«ï¼š type() ä¸ä¼šè®¤ä¸ºå­ç±»æ˜¯ä¸€ç§çˆ¶ç±»ç±»åž‹ï¼Œä¸è€ƒè™‘ç»§æ‰¿å…³ç³»ã€‚ isinstance() ä¼šè®¤ä¸ºå­ç±»æ˜¯ä¸€ç§çˆ¶ç±»ç±»åž‹ï¼Œè€ƒè™‘ç»§æ‰¿å…³ç³»ã€‚å¦‚æžœè¦åˆ¤æ–­ä¸¤ä¸ªç±»åž‹æ˜¯å¦ç›¸åŒæŽ¨èä½¿ç”¨ isinstance()ã€‚12345678910class A: pass class B(A): pass isinstance(A(), A) # returns Truetype(A()) == A # returns Trueisinstance(B(), A) # returns Truetype(B()) == A # returns False é’ˆå¯¹å­—ç¬¦ä¸²çš„åˆ¤åˆ«å‡½æ•° 1234567s.isalnum() æ‰€æœ‰å­—ç¬¦éƒ½æ˜¯æ•°å­—æˆ–è€…å­—æ¯s.isalpha() æ‰€æœ‰å­—ç¬¦éƒ½æ˜¯å­—æ¯s.isdigit() æ‰€æœ‰å­—ç¬¦éƒ½æ˜¯æ•°å­—s.islower() æ‰€æœ‰å­—ç¬¦éƒ½æ˜¯å°å†™s.isupper() æ‰€æœ‰å­—ç¬¦éƒ½æ˜¯å¤§å†™s.istitle() æ‰€æœ‰å•è¯éƒ½æ˜¯é¦–å­—æ¯å¤§å†™ï¼Œåƒæ ‡é¢˜s.isspace() æ‰€æœ‰å­—ç¬¦éƒ½æ˜¯ç©ºç™½å­—ç¬¦ã€\tã€\nã€\r å¯¹äºŽæ•°å­—çš„åˆ¤åˆ« 1234567891011121314isdigit()True: Unicodeæ•°å­—ï¼Œbyteæ•°å­—ï¼ˆå•å­—èŠ‚ï¼‰ï¼Œå…¨è§’æ•°å­—ï¼ˆåŒå­—èŠ‚ï¼‰ï¼Œç½—é©¬æ•°å­—False: æ±‰å­—æ•°å­—Error: æ— isdecimal()True: Unicodeæ•°å­—ï¼Œï¼Œå…¨è§’æ•°å­—ï¼ˆåŒå­—èŠ‚ï¼‰False: ç½—é©¬æ•°å­—ï¼Œæ±‰å­—æ•°å­—Error: byteæ•°å­—ï¼ˆå•å­—èŠ‚ï¼‰isnumeric()True: Unicodeæ•°å­—ï¼Œå…¨è§’æ•°å­—ï¼ˆåŒå­—èŠ‚ï¼‰ï¼Œç½—é©¬æ•°å­—ï¼Œæ±‰å­—æ•°å­—False: æ— Error: byteæ•°å­—ï¼ˆå•å­—èŠ‚ï¼‰ å…·ä½“å®žä¾‹å¯ä»¥çœ‹è¿™é‡Œ å­—ç¬¦ä¸²çš„æ‹¼æŽ¥ åœ¨python å¼€å‘ä¸­ï¼Œå¾ˆå¤šæ—¶å€™éœ€è¦ä½¿ç”¨åˆ°å­—ç¬¦ä¸²æ‹¼æŽ¥ï¼Œpython å­—ç¬¦ä¸²æ‹¼æŽ¥æœ‰å¾ˆå¤šï¼Œè¿™é‡Œå°±æ€»ç»“ä¸€ä¸‹ï¼š 123æ ¼å¼åŒ–ç±»ï¼š%ã€format()ã€templateæ‹¼æŽ¥ç±»ï¼š+ã€()ã€join()æ’å€¼ç±»ï¼šf-string ä½¿ç”¨+ æ‹¼æŽ¥ ä½¿ç”¨ % æ‹¼æŽ¥ ä½¿ç”¨ join() æ–¹æ³•æ‹¼æŽ¥ ä½¿ç”¨ format() æ–¹æ³•æ‹¼æŽ¥ ä½¿ç”¨ f-string æ‹¼æŽ¥ ä½¿ç”¨+ æ‹¼æŽ¥ è¿™ä¸ªé€‚åˆæ•°æ®é‡æ¯”ä»·å°çš„æ—¶å€™ï¼Œå½“æ€»é•¿åº¦å°äºŽ 20 çš„æ—¶å€™ï¼Œå¯ä»¥ä½¿ç”¨ ä½¿ç”¨ % æ‹¼æŽ¥ å€Ÿé‰´äº†Cè¯­è¨€ä¸­ printf å‡½æ•°çš„åŠŸèƒ½ï¼Œå¦‚æžœä½ æœ‰Cè¯­è¨€åŸºç¡€ï¼Œçœ‹ä¸‹æ–‡æ¡£å°±çŸ¥é“äº†ã€‚è¿™ç§æ–¹å¼ç”¨ç¬¦å·â€œ%â€è¿žæŽ¥ä¸€ä¸ªå­—ç¬¦ä¸²å’Œä¸€ç»„å˜é‡ï¼Œå­—ç¬¦ä¸²ä¸­çš„ç‰¹æ®Šæ ‡è®°ä¼šè¢«è‡ªåŠ¨ç”¨å³è¾¹å˜é‡ç»„ä¸­çš„å˜é‡æ›¿æ¢ï¼š1print '%s %s'%('Python', 'Tab') ä½¿ç”¨ join() æ–¹æ³•æ‹¼æŽ¥å¦‚æžœä½ æƒ³è¦åˆå¹¶çš„å­—ç¬¦ä¸²æ˜¯åœ¨ä¸€ä¸ªåºåˆ—æˆ–è€… iterable ä¸­ï¼Œé‚£ä¹ˆæœ€å¿«çš„æ–¹å¼å°±æ˜¯ä½¿ç”¨ join() æ–¹æ³•ã€‚æ¯”å¦‚ï¼š1234567&gt;&gt;&gt; parts = ['Is', 'Chicago', 'Not', 'Chicago?']&gt;&gt;&gt; ' '.join(parts)'Is Chicago Not Chicago?'&gt;&gt;&gt; ','.join(parts)'Is,Chicago,Not,Chicago?'&gt;&gt;&gt; ''.join(parts)'IsChicagoNotChicago?' ä½¿ç”¨ format() æ–¹æ³•æ‹¼æŽ¥ 12str = 'There are &#123;&#125;, &#123;&#125;, &#123;&#125; on the table'str.format(fruit1,fruit2,fruit3) è¿˜å¯ä»¥æŒ‡å®šå‚æ•°å¯¹åº”ä½ç½®ï¼š12str = 'There are &#123;2&#125;, &#123;1&#125;, &#123;0&#125; on the table'str.format(fruit1,fruit2,fruit3) #fruit1å‡ºçŽ°åœ¨0çš„ä½ç½® æœ€é‡è¦çš„éœ€è¦å¼•èµ·æ³¨æ„çš„æ˜¯ï¼Œå½“æˆ‘ä»¬ä½¿ç”¨åŠ å·(+)æ“ä½œç¬¦åŽ»è¿žæŽ¥å¤§é‡çš„å­—ç¬¦ä¸²çš„æ—¶å€™æ˜¯éžå¸¸ä½Žæ•ˆçŽ‡çš„ï¼Œ å› ä¸ºåŠ å·è¿žæŽ¥ä¼šå¼•èµ·å†…å­˜å¤åˆ¶ä»¥åŠåžƒåœ¾å›žæ”¶æ“ä½œã€‚ ç‰¹åˆ«çš„ï¼Œä½ æ°¸è¿œéƒ½ä¸åº”åƒä¸‹é¢è¿™æ ·å†™å­—ç¬¦ä¸²è¿žæŽ¥ä»£ç ï¼š 123s = ''for p in parts: s += p åŒæ ·è¿˜å¾—æ³¨æ„ä¸å¿…è¦çš„å­—ç¬¦ä¸²è¿žæŽ¥æ“ä½œã€‚æœ‰æ—¶å€™ç¨‹åºå‘˜åœ¨æ²¡æœ‰å¿…è¦åšè¿žæŽ¥æ“ä½œçš„æ—¶å€™ä»ç„¶å¤šæ­¤ä¸€ä¸¾ã€‚æ¯”å¦‚åœ¨æ‰“å°çš„æ—¶å€™ï¼š123print(a + ':' + b + ':' + c) # Uglyprint(':'.join([a, b, c])) # Still uglyprint(a, b, c, sep=':') # Better å½“æ··åˆä½¿ç”¨I/Oæ“ä½œå’Œå­—ç¬¦ä¸²è¿žæŽ¥æ“ä½œçš„æ—¶å€™ï¼Œæœ‰æ—¶å€™éœ€è¦ä»”ç»†ç ”ç©¶ä½ çš„ç¨‹åºã€‚ æ¯”å¦‚ï¼Œè€ƒè™‘ä¸‹é¢çš„ä¸¤ç«¯ä»£ç ç‰‡æ®µï¼š123456# Version 1 (string concatenation)f.write(chunk1 + chunk2)# Version 2 (separate I/O operations)f.write(chunk1)f.write(chunk2) å¦‚æžœä¸¤ä¸ªå­—ç¬¦ä¸²å¾ˆå°ï¼Œé‚£ä¹ˆç¬¬ä¸€ä¸ªç‰ˆæœ¬æ€§èƒ½ä¼šæ›´å¥½äº›ï¼Œå› ä¸ºI/Oç³»ç»Ÿè°ƒç”¨å¤©ç”Ÿå°±æ…¢ã€‚ å¦å¤–ä¸€æ–¹é¢ï¼Œå¦‚æžœä¸¤ä¸ªå­—ç¬¦ä¸²å¾ˆå¤§ï¼Œé‚£ä¹ˆç¬¬äºŒä¸ªç‰ˆæœ¬å¯èƒ½ä¼šæ›´åŠ é«˜æ•ˆï¼Œ å› ä¸ºå®ƒé¿å…äº†åˆ›å»ºä¸€ä¸ªå¾ˆå¤§çš„ä¸´æ—¶ç»“æžœå¹¶ä¸”è¦å¤åˆ¶å¤§é‡çš„å†…å­˜å—æ•°æ®ã€‚ è¿˜æ˜¯é‚£å¥è¯ï¼Œæœ‰æ—¶å€™æ˜¯éœ€è¦æ ¹æ®ä½ çš„åº”ç”¨ç¨‹åºç‰¹ç‚¹æ¥å†³å®šåº”è¯¥ä½¿ç”¨å“ªç§æ–¹æ¡ˆã€‚ è¿™ç§æ–¹å¼ä¹Ÿ1print('python', 'tab' ,'i', sep =',') ä½¿ç”¨ f-string æ‹¼æŽ¥ ä»ŽPython3.6ç‰ˆæœ¬å¼•å…¥ã€‚è¿™ç§æ–¹å¼åœ¨å¯è¯»æ€§ä¸Šç§’æ€format()æ–¹å¼ï¼Œå¤„ç†é•¿å­—ç¬¦ä¸²çš„æ‹¼æŽ¥æ—¶ï¼Œé€Ÿåº¦ä¸Žjoin()æ–¹æ³•ç›¸å½“ã€‚12345name = 'world'myname = 'python_cat'words = f'Hello &#123;name&#125;. My name is &#123;myname&#125;.'print(words)&gt;&gt;&gt; Hello world. My name is python_cat. æ€»ç»“ï¼š å½“è¦å¤„ç†å­—ç¬¦ä¸²åˆ—è¡¨ç­‰åºåˆ—ç»“æž„æ—¶ï¼Œé‡‡ç”¨join()æ–¹å¼ï¼›æ‹¼æŽ¥é•¿åº¦ä¸è¶…è¿‡20æ—¶ï¼Œé€‰ç”¨+å·æ“ä½œç¬¦æ–¹å¼ï¼›é•¿åº¦è¶…è¿‡20çš„æƒ…å†µï¼Œé«˜ç‰ˆæœ¬é€‰ç”¨f-stringï¼Œä½Žç‰ˆæœ¬æ—¶çœ‹æƒ…å†µä½¿ç”¨format()æˆ–join()æ–¹å¼ã€‚ pythonä¸­strip()ï¼Œlstrip()ï¼Œrstrip()å‡½æ•° æƒ³è¦åŽ»æŽ‰ä»€ä¹ˆå­—ç¬¦ï¼Œé‚£ä¹ˆå°±ä¼ å…¥ä»€ä¹ˆå­—ç¬¦ï¼Œé»˜è®¤æ˜¯ç©ºæ ¼ã€‚å¦‚æžœæ²¡æœ‰è¾“å…¥ï¼Œé‚£ä¹ˆå°±æ˜¯åˆ é™¤é¦–å°¾ç©ºæ ¼çš„æ„æ€ï¼š strip() åˆ é™¤å‰å¯¼å’ŒåŽç¼€å­—ç¬¦ ä½†æ˜¯å½“æœ‰äº†å‚æ•°ï¼ˆä¼ å…¥çš„æ˜¯ä¸€ä¸ªå­—ç¬¦æ•°ç»„ï¼‰é‚£ä¹ˆå°±ä¼šåˆ é™¤æ‰€æœ‰å­—ç¬¦æ•°ç»„ä¸­çš„æ‰€æœ‰æ•°ç»„ã€‚æ¯”å¦‚è¯´ï¼š 12345678910theString = 'saaaay yes no yaaaass'print theString.strip('say') print theString.strip('say ') #sayåŽé¢æœ‰ç©ºæ ¼ print theString.lstrip('say') print theString.rstrip('say') # è¾“å‡ºç»“æžœæ˜¯yes no es no yes no yaaaass saaaay yes no Python ä¸­çš„ is å’Œ == is is the identity comparison. #æ¯”è¾ƒå¼•ç”¨æ˜¯å¦ç›¸åŒ == is the equality comparison. #æ¯”è¾ƒå†…å®¹æ˜¯å¦ç›¸åŒ 1The operator a is b returns True if a and b are bound to the same object, otherwise False. When you create two empty lists you get two different objects, so is returns False (and therefore is notreturns True)]]></content>
      <categories>
        <category>CSåŸºç¡€</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Dynamic Programming]]></title>
    <url>%2F2019%2F08%2F29%2Fdynamic-programming%2F</url>
    <content type="text"><![CDATA[å…ˆä»‹ç»äº†åŠ¨æ€è§„åˆ’çš„æ¦‚å¿µï¼Œä½¿ç”¨çš„å¿…è¦æ¡ä»¶ï¼Œå’Œå…¶ä»–ç±»ä¼¼ç®—æ³•çš„åŒºåˆ«å’Œè”ç³»ã€‚ç„¶åŽæ˜¯å®žæˆ˜ï¼Œcodingéƒ¨åˆ†ã€‚ æ¦‚å¿µ Dynamic programming (DP) is as hard as it is counterintuitive. dp ä¸å¤ªå¥½æƒ³å‡ºæ¥ï¼Œæ‰€ä»¥æ˜¯ counterintuitiveï¼Œä½†å¦‚æžœæƒ³å‡ºæ¥ï¼Œé‚£ä¹ˆç¨‹åºæ—¶é—´æ•ˆçŽ‡ä¸Šä¼šå¾ˆé«˜ã€‚ å®šä¹‰ï¼š Dynamic programming amounts to breaking down an optimization problem into simpler sub-problems, and storing the solution to each sub-problem so that each sub-problem is only solved once. ä½¿ç”¨dp çš„ä¸¤ä¸ªå¿…è¦æ¡ä»¶ï¼š has an optimal substructure. has overlapping subproblems. æœ€ä¼˜å­ç»“æž„æœ€ä¼˜å­ç»“æž„ï¼Œå¦‚æžœç®€å•ç†è§£ï¼Œé‚£ä¹ˆå¯ä»¥ç­‰åŒäºŽé€’å½’ã€‚å¦‚æžœä¸€ä¸ªé—®é¢˜èƒ½å¤Ÿä½¿ç”¨é€’å½’è§£å†³ï¼Œé‚£ä¹ˆå°±å…·æœ‰æœ€ä¼˜å­ç»“æž„ã€‚ Optimal substructure simply means that you can find the optimal solution to a problem by considering the optimal solution to its subproblems. å¯¹äºŽä¸€ä¸ªå­é—®é¢˜çš„æœ€ä¼˜è§£ï¼Œé‚£ä¹ˆä¹Ÿæ˜¯åŽŸæ¥é—®é¢˜çš„æœ€ä¼˜è§£ã€‚ ä¸¾ä¾‹è¯´æ˜Žä¸€ä¸ªä¸æ˜¯æœ€ä¼˜å­ç»“æž„çš„é—®é¢˜. according to wikipedida: â€œUsing online flight search, we will frequently find that the cheapest flight from airport A to airport B involves a single connection through airport C, but the cheapest flight from airport A to airport C involves a connection through some other airport D.â€ é‡å¤çš„å­é—®é¢˜ æ­£å› ä¸ºæœ‰äº† overlapping subproblemsï¼Œé‚£ä¹ˆæ‰æ˜¯éœ€è¦ memoryï¼Œæ‰æ˜¯éœ€è¦cacheã€‚ä½¿ç”¨ Fibonacci problem ä¸¾ä¾‹è¯´æ˜Žï¼š å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œè®¡ç®— fib(4) å’Œè®¡ç®— fib(3) éƒ½æ˜¯éœ€è¦è®¡ç®—fib(1) å’Œfib(2)ã€‚ é‚£ä¹ˆè¿™ä¸ªæ—¶å€™å°±æ˜¯æœ‰é‡å¤çš„å­é—®é¢˜ã€‚ æ—¶é—´å¤æ‚åº¦åˆ†æž In programming, Dynamic Programming is a powerful technique that allows one to solve different types of problems in time $O(n^2)$ or $O(n^3)$ for which a naive approach would take exponential time. ä½¿ç”¨ $O(n^2) $æˆ–è€… $O(n^3)$çš„æ—¶é—´å¤æ‚åº¦ä»Žè€Œé¿å…æŒ‡æ•°çº§è¿ç®—ã€‚æ‰€ä»¥æœ‰ä¸‹é¢çš„é¢è¡¨ç¤ºæ–¹å¼ï¼š One can think of dynamic programming as a table-filling algorithm: you know the calculations you have to do, so you pick the best order to do them in and ignore the ones you donâ€™t have to fill in.Tabulation is an approach where you solve a dynamic programming problem by first filling up a table, and then compute the solution to the original problem based on the results in this table. è¡¨æ ¼å®žçŽ°äº†memoryæœºåˆ¶ï¼Œä¼˜åŒ–äº†æ—¶é—´æ•ˆçŽ‡ã€‚memory å°±ç­‰åŒäºŽ cacheï¼Œè¿™ä¸ªåŸºæœ¬å‡è®¾æ˜¯æœ‰å¤šæ¬¡ç›¸åŒçš„é—®é¢˜éœ€è¦è¢«è§£å†³ï¼Œå¦‚æžœæ²¡æœ‰é‡å¤çš„é—®é¢˜ï¼Œé‚£ä¹ˆä¹Ÿæ˜¯æ²¡æœ‰å¿…è¦ä½¿ç”¨memory è¿›è¡Œæ—¶é—´ä¸Šçš„ä¼˜åŒ–çš„ã€‚ ä¸¤ç§ä¸åŒçš„æ€è€ƒæ–¹å¼ï¼š Top-Down : Start solving the given problem by breaking it down. If you see that the problem has been solved already, then just return the saved answer. If it has not been solved, solve it and save the answer. This is usually easy to think of and very intuitive. This is referred to as Memoization. Bottom-Up : Analyze the problem and see the order in which the sub-problems are solved and start solving from the trivial subproblem, up towards the given problem. In this process, it is guaranteed that the subproblems are solved before solving the problem. This is referred to as Dynamic Programming. ç¬¬ä¸€ç§ç±»ä¼¼å¸¦æœ‰memoryæœºåˆ¶çš„é€’å½’ã€‚memoryæœºåˆ¶å°±æ˜¯ä¸€ç§å…¸åž‹çš„ç©ºé—´æ¢å–æ—¶é—´çš„æ–¹å¼ã€‚ dp å’Œå…¶ä»–ç®—æ³•çš„ä¸åŒ Divide and conquer is slightly a different technique. In that, we divide the problem in to non-overlapping subproblems and solve them independently, like in merge sort and quick sort. Greedy Algorithms which make a decision once and for all every time they need to make a choice, in such a way that it leads to a near-optimal solution. Dynamic programming is basically, recursion plus using memory. The intuition behind dynamic programming is that we trade space for time. å¤§å¤šæ•°dp é—®é¢˜éƒ½å¯ä»¥å½’ç»“ä¸ºè¿™ä¸¤ç±»ï¼š Optimization problems. Combinatorial problems.The optimization problems expect you to select a feasible solution, so that the value of the required function is minimized or maximized. Combinatorial problems expect you to figure out the number of ways to do something, or the probability of some event happening. æœ€ä¼˜è§£å¾—åˆ°æ˜¯æœ€å¤§å€¼æˆ–è€…æœ€å°å€¼ï¼›ç»„åˆé—®é¢˜å¾—åˆ°æ˜¯è§£çš„ä¸ªæ•°ã€‚ å®žä¾‹è§£é¢˜æ­¥éª¤ Define subproblems Write down the recurrence that relates subproblems Recognize and solve the base cases å¯¹é—®é¢˜çš„å®šä¹‰ï¼ˆä¸€èˆ¬æ˜¯ä¸€ç»´ã€äºŒç»´è¡¨æ ¼ï¼‰ æ‰¾åˆ°å½“å‰é—®é¢˜å’Œå­é—®é¢˜çš„è½¬æ¢å…³ç³» åˆå§‹åŒ– 1-dimensional DP Exampleé—®é¢˜ä¸€ï¼š Problem: given n, find the number of different ways to write n as the sum of 1, 3, 4Example: for n = 5, the answer is 6 12345675= 1+1+1+1+1= 1+1+3 = 1+3+1= 3+1+1= 1+4= 4+1 è§£é¢˜æ­¥éª¤ å¯¹é—®é¢˜çš„å®šä¹‰ Let $D_n$ be the number of ways to write the sum of 1, 3, 4 è½¬æ¢å…³ç³» $D_n = D_{nâˆ’1} + D_{nâˆ’3} + D_{nâˆ’4}$ åˆå§‹åŒ– $D_0 =D_1 =D_2 =1$, and $D_3 =2$ c++ ä»£ç å®žçŽ° ç‰ˆæœ¬ä¸€ï¼šå°±æ˜¯ä¸€ç§dfs çš„æ€è·¯1234567int dfs(int n)&#123; // è¿™ä¸ªè¯´æ˜¯dp ä½†æ˜¯æ›´åƒæ˜¯dfsï¼Œåªä¸è¿‡ if (n ==0 || n ==1 ||n ==2) return 1; if(n ==3) return 2; return dfs(n-1) +dfs(n-3)+dfs(n-4);&#125; ç©ºé—´å¤æ‚åº¦æ˜¯ $O(n)$ï¼Œæ—¶é—´æ˜¯ $O(n)$ï¼Œ ç©ºé—´æ¢å–æ—¶é—´ã€‚12345678910111213unordered_map&lt;int, int&gt; cache;int dfs(int n)&#123; // è¿™ä¸ªè¯´æ˜¯dp ä½†æ˜¯æ›´åƒæ˜¯dfsï¼Œåªä¸è¿‡ if (n ==0 || n ==1 ||n ==2) return 1; if(n ==3) return 2; if (cache.count(n)) return cache[n]; else &#123; cache[n] =dfs(n-1) +dfs(n-3)+dfs(n-4); return cache[n]; &#125;&#125; python å®žçŽ°ï¼Œæ—¶é—´å¤æ‚åº¦ $O(n)$ ç©ºé—´å¤æ‚åº¦ $O(n)$ 12345678910cache =&#123;&#125;def dp(n): if n==0 or n ==1 or n==2: return 1 if n ==3: return 2 if n in cache: return cache[n] else: cache[n] =dp(n-1) +dp(n-3) +dp(n -4) return cache[n]print(dp(5)) é—®é¢˜äºŒï¼š Tri Tiling ï¼ˆè¿™é‡Œæ˜¯éœ€è¦è¡¥å……çš„ï¼‰ Given n, find the number of ways to fill a 3Ã—n board with dominoes c++ ä»£ç ï¼Œå…³é”®æ˜¯åŠ¨æ€è½¬ç§»æ–¹ç¨‹ã€‚$$\begin{split}A_n &amp;= A_{n-2} +B_{n-1} + C_{n-1} \\B_n &amp;= A_{n-1} + B_{n-2}\end{split}$$ è®²è§£ 12345678910111213141516171819int fun(int n , vector&lt;int&gt; &amp; a, vector&lt;int&gt;&amp; b)&#123; a[0] =1, a[1] =0; b[0] =1, b[1] =1; for(int i =2; i&lt;=n; i++) &#123; a[i] =a[i-2] +2*b[i-1]; b[i] =a[i-1] +b[i-2]; &#125; return a[n];&#125;int main()&#123; int n; cin &gt;&gt;n; vector&lt;int&gt; a1(n+1), b1(n+1); cout &lt;&lt; fun(n, a1, b1)&lt;&lt; endl; return 0;&#125; è¿˜æœ‰ä¸€ä¸ªæ¯”è¾ƒç®€å•çš„é¢˜ç›®ï¼Œ Given n, find the number of ways to fill a 2*n board with dominoes åŠ¨æ€è½¬ç§»æ–¹ç¨‹ï¼ˆè¿™ä¸ªç›¸å¯¹ä¸Šä¸€ä¸ªè€ƒè™‘çš„æƒ…å†µå°‘ä¸€äº›ï¼‰$$\begin{split}A_n &amp;=n if n ==1 || n ==2 \\A_n &amp; = A_{n-1} +A_{n -2} else\\\end{split}$$ 123456789101112131415int fun(int n , vector&lt;int&gt; &amp; a)&#123; a[1] =1, a[2] =2; for(int i =3 ; i&lt;=n; i++) a[i] =a[i-1] + a[i-2]; return a[n];&#125;int main()&#123; int n; cin &gt;&gt;n; vector&lt;int&gt; a(n+1); cout &lt;&lt; fun(n, a)&lt;&lt; endl; return 0;&#125; 2-dimensional DP Exampleé—®é¢˜ä¸€ï¼šæœ€é•¿å­åºåˆ— Problem: given two strings x and y, find the longest common subsequence (LCS) and print its length è§£é¢˜æ­¥éª¤ï¼š å¯¹é—®é¢˜çš„å®šä¹‰$D_{ij}$ è¡¨ç¤º $x_{1, â€¦, i}$ å’Œ$y_{1, â€¦, j}$ çš„LCS çš„é•¿åº¦ è½¬æ¢å…³ç³»ï¼ˆå›žæ–‡ä¸²å°±æ˜¯å‰åŽç¼€é—®é¢˜ï¼‰ $D_{ij} =D_{i-1, j-1} +1$ if $x_i =y_j$ï¼Œ å› ä¸ºboth of them contribute to the LCS $D_{ij} =max{D_{i-1, j}, D_{i, j-1}} $ å¦åˆ™çš„è¯ åˆå§‹åŒ–(å°±æ˜¯è§£å†³æœ€å°çš„é—®é¢˜ï¼Œå°±æ˜¯å½“ $i-1 ==0$ çš„æ—¶å€™ï¼Œ æˆ–è€…bad case æ˜¯å¦‚ä½•è¿›è¡Œå¤„ç†)$D_{i0} =D_{0j} =0$ pythonä»£ç å®žçŽ° 12 c++ ä»£ç å®žçŽ°1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;const int MAXV =10;int n,m;int lcs(char * str1, char * str2)&#123; vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(m+1, 0)); for(int i =1; i&lt;= n; i++) for(int j =1; j&lt;=m; j++) &#123; if(str1[i] ==str2[j]) dp[i][j] =dp[i-1][j-1] +1; else dp[i][j] =max(dp[i][j-1], dp[i-1][j]); &#125; return dp[n][m];&#125;int main()&#123; char s1[MAXV], s2[MAXV]; cin &gt;&gt;n&gt;&gt;m; cin &gt;&gt;s1+1&gt;&gt; s2+1; cout &lt;&lt; lcs(s1, s2)&lt;&lt; endl; return 0;&#125; pythonå®žçŽ°ã€‚åœ¨ç”³è¯·ç©ºé—´çš„æ—¶å€™ï¼Œå¤šç”³è¯·ä¸€åœˆçš„ç©ºé—´ã€‚å¹¶ä¸”åœ¨åˆ¤æ–­çš„æ—¶å€™ï¼Œä½¿ç”¨ str1[i-1] ==str2[j-1] æ¥å¤„ç†è¶Šç•Œçš„é—®é¢˜ã€‚ 123456789101112131415# è¾¹ç•Œæ¡ä»¶æ˜¯æ ¹æ®å®žé™…æ„ä¹‰å‡ºå‘str1 ="abcd"str2 ="bad"def lcs(str1, str2): n, m =len(str1), len(str2) dp =[ [0]*(m+1) for _ in range(n+1)] for i in range(1, n+1): for j in range(1, m +1): if(str1[i-1] ==str2[j-1]): dp[i][j] =dp[i-1][j-1] +1 else: dp[i][j] =max(dp[i-1][j], dp[i][j-1]) return dp[n][m]print(lcs(str1, str2)) How can we now find the sequence? To find the sequence, we just walk backwards through matrix starting the lower-right corner. If either the cell directly above or directly to the right contains a value equal to the value in the current cell, then move to that cell (if both to, then chose either one). If both such cells have values strictly less than the value in the current cell, then move diagonally up-left (this corresponts to applying Case 2), and output the associated character. This will output the characters in the LCS in reverse order. For instance, running on the matrix above, this outputs DABA. ä¸Šé¢çš„æ˜¯ä»Žåº•åˆ°ä¸Šæ€è·¯ï¼ˆè¿­ä»£ï¼‰ ç„¶åŽçœ‹ç¬¬äºŒç§æ€è·¯ï¼ˆä»Žä¸Šåˆ°ä¸‹ï¼‰ï¼Œé‚£ä¹ˆå°±é€’å½’+ memory 12345678LCS(S,n,T,m)&#123;if (n==0 || m==0) return 0;if (arr[n][m] != unknown) return arr[n][m]; // &lt;- added this line (*) if (S[n] == T[m]) result = 1 + LCS(S,n-1,T,m-1);else result = max( LCS(S,n-1,T,m), LCS(S,n,T,m-1) );arr[n][m] = result;return result;&#125; æ‰©å±•é¢˜ç›® More about LCS: Discussion and Extensions. An equivalent problem to LCS is the â€œmini- mum edit distanceâ€ problem, where the legal operations are insert and delete. è½¬ç§»æ–¹ç¨‹$$ dp[i][j] = \begin{cases}1 +min{dp[i][j-1], dp[i-1][j], dp[i-1][j-1]} +1&amp; x_i \neq x_j \\dp[i-1][j-1]&amp; x_i = x_j\end{cases}$$ c++ å®žçŽ°ã€‚1234567891011121314151617int minDistance(string word1, string word2) &#123; int n =word1.size(), m =word2.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(m+1, 0)); // åˆå§‹åŒ– for(int i =0; i&lt;=m ; i++) dp[i][0] =i; for(int i =0; i&lt;=n ; i++) dp[0][i] =i; for(int i =1; i&lt;=n ; i++) for(int j =1; j&lt;=m; j++ ) &#123; if(str1[i-1] ==str2[j-1]) dp[i][j] =dp[i-1][j-1] ; else dp[i][j] =min(dp[i-1][j-1], min(dp[i][j-1], dp[i-1][j])) +1; &#125; return dp[n][m];&#125; python å®žçŽ° 12345678910111213141516def edit_distance(str1, str2): n, m =len(str1), len(str2) dp =[ [0] *(m+1) for _ in range(n+1)] # åˆå§‹åŒ– for i in range(n+1): dp[i][0] =i for i in range(m +1): dp[0][i] =i for i in range(1, n+1): for j in range(1, m+1): if str1[i-1] ==str2[j-1]: dp[i][j] =dp[i-1][j-1] else: dp[i][j] =min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) +1 return dp[n][m]str1 ="horse"str2 ="ros"print(edit_distance(str1, str2)) Interval DP (é—´éš”æˆ–åŒºé—´dp) Problem: given a string $x = x_{1â€¦n} $, find the minimum number of characters that need to be inserted to make it a palindrome è§£é¢˜æ€è·¯ é—®é¢˜çš„å®šä¹‰Let $D_{ij}$ be the minimum number of characters that need to be inserted to make $x_{iâ€¦j}$ into a palindrome è½¬æ¢å…³ç³»$$ dp[i][j] = \begin{cases}1 + min(dp[i+1][j], dp[i][j-1]) &amp; x_i \neq x_j \\dp[i+1][j-1]&amp; x_i \eq x_j\end{cases}$$ åˆå§‹åŒ– Find and solve the base cases: $D_{ii} = D_i, iâˆ’1 = 0 $ for all $ i$The entries of D must be filled in increasing order of $j âˆ’ i$ An alternate solution Reverse $x $to get $x^R$ The answer is $nâˆ’L $, where $ L $is the length of the LCS of $ x$ and $x^R$ å¡«å……è¡¨æ ¼çš„è¿‡ç¨‹æ˜¯æŒ‰ç…§ä¸»å¯¹è§’çº¿è¿›è¡Œå¡«å……çš„ï¼Œæœ€åŽå¡«å……çš„ç‚¹æ˜¯ dp[0][n-1]ã€‚ç¬¬ä¸€å±‚å¾ªçŽ¯æ˜¯ä¸€ä¸ªgap çš„å¾ªçŽ¯ï¼Œæ˜¯æŒ‰ç…§ä¸»å¯¹è§’çº¿è¿›è¡ŒéåŽ†çš„ã€‚\\ è¿™æ ·éåŽ†ï¼Œéžå¸¸nice çš„ä»£ç ã€‚ ä»£ç å®žçŽ°éƒ¨åˆ†ï¼ˆæŒ‰ç…§é“ç†æ˜¯åªéœ€è¦åˆå§‹åŒ–ä¸»å¯¹è§’çº¿å°±è¡Œï¼Œä½†æ˜¯ä¸‹é¢çš„ä»£ç æŠŠæ‰€æœ‰çš„å€¼åˆå§‹åŒ–ä¸º0ï¼‰ c++ ä»£ç å®žçŽ°éƒ¨åˆ† 1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int n ; string str1; cin &gt;&gt;n; cin &gt;&gt; str1; vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0)); for(int gap =1; gap&lt;n; gap++) // è¿™ä¸ªæ˜¯ä¸€ç§å…¨æ–°çš„éåŽ†æ–¹å¼ for(int i =0, j =gap +i; j&lt;n; i++, j++) &#123; if(str1[i] ==str1[j]) dp[i][j]= dp[i+1][j-1]; else dp[i][j] =min(dp[i+1][j], dp[i][j-1] ) +1; &#125; cout &lt;&lt; dp[0][n-1]&lt;&lt; endl; return 0;&#125; python å®žçŽ° 1234567891011121314def dp(str1): n =len(str1) # åˆå§‹åŒ– dp =[[0]*n for _ in range(n)] for gap in range(1, n): i =0 j =i +gap while j&lt;n: dp[i][j] = dp[i+1][j-1] if str1[i] ==str1[j] else min(dp[i+1][j], dp[i][j-1]) +1 i += 1 j += 1 return dp[0][n-1]str1 ="abcd"print(dp(str1)) The Knapsack Problem èƒŒåŒ…é—®é¢˜ä¹Ÿæ˜¯å¯ä»¥çº³å…¥åˆ° dpç³»åˆ—ä¸­In the knapsack problem we are given a set of n items, where each item i is specified by a size si and a value vi. We are also given a size bound S (the size of our knapsack). The goal is to find the subset of items of maximum total value such that sum of their sizes is at most S (they all fit into the knapsack). matrix product parenthesization problem.å‚è€ƒæ–‡çŒ®standford Dynamic Programmingdp-cmu è¯¾ä»¶Demystifying Dynamic ProgrammingThe Ultimate Guide to Dynamic ProgrammingDynamic programming [step-by-step example]Introduction to Dynamic Programming 1Tutorial For Dynamic Programming ä¹‹å‰çš„åŠ¨æ€è§„åˆ’çš„æ±‚è§£éœ€è¦è€ƒè™‘ä¸‰ä¸ªé—®é¢˜ï¼š çŠ¶æ€æ€Žä¹ˆè¡¨ç¤º æ€Žä¹ˆè®¡ç®—æ¯ä¸ªçŠ¶æ€ æ€Žä¹ˆåˆå§‹åŒ– Unique Paths II åŽŸé¢˜è¿žæŽ¥ å¯¹äºŽåŠ¨æ€è§„åˆ’ï¼Œéœ€è¦è€ƒè™‘ä¸‰ä¸ªé—®é¢˜ï¼š çŠ¶æ€æ€Žä¹ˆè¡¨ç¤ºï¼š f[i][j] è¡¨ç¤ºæ˜¯(i, j) è¿™ç‚¹çš„æ–¹æ¡ˆæ•° æ€Žä¹ˆè®¡ç®—ä¸‹ä¸€æ­¥ï¼š f[i][j] åªæœ‰ä¸¤ä¸ªæ¥æºï¼Œä¸€ç§æ˜¯ä»Žä¸Šé¢èµ°ä¸‹æ¥ï¼Œä¸€ç§æ˜¯ä»Žå·¦è¾¹èµ°ä¸‹æ¥ æ€Žä¹ˆåˆå§‹åŒ–ï¼š dpå¾ˆé‡è¦çš„ä¸€ç‚¹ï¼š ä½¿ç”¨åˆ°çš„çŠ¶æ€ä¹‹å‰éƒ½å·²ç»è®¡ç®—è¿‡ã€‚é’ˆå¯¹è¿™é“é¢˜ç›®ï¼Œæ±‚è§£æ–¹æ¡ˆæ•°ï¼Œæœ‰å¯èƒ½æœ€åŽçš„ç»“æžœè¶…è¿‡äº†int çš„èŒƒå›´ï¼Œæ‰€ä»¥ä½¿ç”¨long longåº”è¯¥æ˜¯æ¯”è¾ƒå¥½çš„ã€‚ 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: // f[i][j] è¡¨ç¤º(i, j) è¿™ä¸ªç‚¹è·¯å¾„çš„ä¸ªæ•° // è½¬ç§» f[i][j] =f[i-1][j] or f[i][j-1] è¿™æ ·çš„æ–¹å¼ // åˆå§‹åŒ–, 0 if nums[i][j] ==1 , else 1 int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; if(!nums.size() || !nums[0].size()) return 0; int n =nums.size(), m =nums[0].size(); if (nums[0][0]) return 0; vector&lt;vector&lt;long long&gt;&gt; f(n, vector&lt;long long&gt;(m)); // é»˜è®¤åˆå§‹ä¸º0ï¼Œ å› ä¸ºè¿™ä¸ªæ˜¯åœ¨ public ä¸­ f[0][0] =1;// è¿™ä¸ªæ˜¯ä»Žå·¦ä¸Šè§’å¼€å§‹çš„, å› ä¸ºä¸Šæ–‡å·²ç»åˆ¤æ–­caseï¼Œæ‰€ä»¥å¯ä»¥ç›´æŽ¥è¿›è¡Œåˆå§‹åŒ– for(int i =0; i&lt; n; i++) &#123; for(int j =0; j&lt;m; j++) &#123; if(i || j) f[i][j] =0;// åªæœ‰åœ¨ éž if(!nums[i][j]) &#123; if(i) f[i][j] += f[i-1][j] ; if(j) f[i][j] += f[i][j-1]; &#125; &#125; &#125; return f[n-1][m-1]; &#125;&#125;; triangle LeetCode ç‰ˆæœ¬ 12345678910111213141516171819202122class Solution &#123;public: // å®žçŽ°çš„æ—¶å€™ï¼Œå¦‚ä½•è¿›è¡ŒéåŽ†æ˜¯ï¼Œæˆ‘çš„å¼±ç‚¹ã€‚ // è¿™ç§ä¸‰è§’å½¢åœ¨(i, j) ä¸Šæ˜¯æœ‰ç‰¹ç‚¹çš„ï¼Œå› ä¸ºç±»ä¼¼ä¸€ç§ç›´è§’ä¸‰è§’å½¢ int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; int n =triangle.size(); // æ»šåŠ¨æ•°ç»„ vector&lt;int&gt; f(triangle[n-1].begin(), triangle[n-1].end()), g(n);// f()æ˜¯æ‹·è´ï¼Œ gæ˜¯åˆå§‹åŒ– // cpp è¯­æ³•ï¼Œè¿™é‡Œæ˜¯æ²¡æœ‰ triangle[-1] è¡¨ç¤ºçš„ï¼Œä¸æ˜¯python ä¸­çš„ for(int i =n-2; i&gt;=0; i--) &#123; for(int j =0; j&lt;=i; j++) // ç›´è§’ä¸‰è§’å½¢çš„ç‰¹ç‚¹ &#123; g[j] =min(f[j], f[j+1]) +triangle[i][j]; &#125; f =g; &#125; return f[0]; &#125;&#125;; å•æœºç‰ˆ 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int n; cin &gt;&gt;n; vector&lt;vector&lt;int&gt;&gt; arr(n, vector&lt;int&gt;(n)); for(int i =0;i&lt;n; i++) for(int j =0; j&lt;=i; j++) cin&gt;&gt; arr[i][j]; vector&lt;int&gt; f(arr[n-1].begin(), arr[n-1].end()), g(n);// å¦‚ä½•åŽ»ç†è§£ g(n) ä½œä¸ºä¸€ç§å¤‡èƒŽï¼Œæ»šåŠ¨æ•°ç»„ for(int i =n-2; i&gt;=0; i--) &#123; for(int j =0; j&lt;=i; j++) &#123; g[j] =min(f[j], f[j+1])+ arr[i][j]; // è¿™æ­¥éª¤å¾ˆé‡è¦ &#125; f =g; &#125; cout&lt;&lt; f[0] &lt;&lt;endl; return 0;&#125; 354. Russian Doll Envelopes åŽŸé¢˜é“¾æŽ¥ ä¸€å…±æœ‰ä¸¤ç§è§£æ³•ã€‚å…ˆè¿›è¡ŒæŽ’åºï¼Œç„¶åŽè½¬æ¢æˆæœ€é•¿è¿žç»­é€’å¢žå­åºåˆ—,ã€‚æ—¶é—´å¤æ‚åº¦åˆ†æžï¼š æŽ’åºæœ€å¿«æ˜¯ $nlogn$ï¼Œ å¦‚æžœä½¿ç”¨dpï¼Œé‚£ä¹ˆæ€»çš„æ˜¯$n^2$; å¦‚æžœä½¿ç”¨äºŒåˆ†æ€»çš„æ˜¯$nlogn$ã€‚ä¸‹é¢æ˜¯ç¬¬ä¸€ç§è§£æ³•ï¼Œä½¿ç”¨dp çš„æ€æƒ³ã€‚ 1234567891011121314151617181920212223242526class Solution &#123;public: int maxEnvelopes(vector&lt;vector&lt;int&gt;&gt;&amp; envelopes) &#123; int n =envelopes.size(); vector&lt;int&gt; dp(n,0); dp[0] =1; int result =1; sort(envelopes.begin(), envelopes.end()); for(int i =0; i&lt;n; i++) &#123; for(int j =0;j&lt;i ;j++)// éåŽ†å‰é¢æ‰€æœ‰çš„çŠ¶æ€çš„ &#123; if(envelopes[i][0]&gt; envelopes[j][0] &amp;&amp; envelopes[i][1]&gt; envelopes[j][1] ) dp[i] =max(dp[i], dp[j]+1); &#125; result =max(result, dp[i]); &#125; return result; &#125;&#125;; å•æœºç‰ˆ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;// sort ç„¶åŽæœ€é•¿é€’å¢žå­åºåˆ—å§// dp[i] è¡¨ç¤ºé•¿åº¦ä¸ºi çš„æœ€é•¿é€’å¢ž, è½¬ç§»æ–¹ç¨‹ dp[i] =max(dp[i], dp[j]+1) j&lt;i, åˆå§‹åŒ– dp[0] =0int maxEnvelopes(vector&lt;vector&lt;int&gt;&gt;&amp; arr)&#123; if(arr.empty()) return 0; int result =1; int n =arr.size(); vector&lt;int&gt; dp(n); sort(arr.begin(), arr.end());// é»˜è®¤æŒ‰ç…§ç¬¬ä¸€ä¸ªå…ƒç´ è¿›è¡Œé€’å¢žæŽ’åº for(int i =0; i&lt;n ;i++) &#123; for(int j=0; j&lt;i; j++) &#123; dp[i] =max(dp[i], dp[j] +1); &#125; result =max(result, dp[i]); &#125; return result;&#125;int main()&#123; int n ; cin &gt;&gt;n; vector&lt;vector&lt;int&gt;&gt; arr(n, vector&lt;int&gt;(2)); for(int i =0; i&lt;n;i++) &#123; for(int j =0; j&lt;2;j++) cin &gt;&gt;arr[i][j]; &#125; cout &lt;&lt; maxEnvelopes(arr) &lt;&lt;endl; return 0;&#125; ç¬¬äºŒç§è§£æ³•ï¼Œä½¿ç”¨äºŒåˆ†çš„æ€æƒ³è¿›è¡Œæ£€ç´¢ï¼Œæ€»çš„æ—¶é—´å¤æ‚åº¦èƒ½å¤Ÿè¾¾åˆ° $O(nlog n)$.ä½¿ç”¨python å®žçŽ°ã€‚ leetcode ç‰ˆæœ¬ 12345678910111213141516171819202122232425262728293031323334class Solution(object): def maxEnvelopes(self, envelopes): """ :type envelopes: List[List[int]] :rtype: int """ if not envelopes: return 0; envelopes.sort(key =lambda x:(x[0], -x[1])) # æŒ‰ç…§ç¬¬ä¸€ä¸ªå…ƒç´ å‡åºï¼Œç„¶åŽç¬¬äºŒä¸ªå…ƒç´ é™åº # äºŒåˆ†æŸ¥æ‰¾ ç¬¬äºŒä¸ªå…ƒç´ çš„ä½ç½®ï¼Œå½“ç¬¬ä¸€ä¸ªå…ƒç´ ç›¸åŒçš„æ—¶å€™ #print(envelopes) lst =[] for fir, sec in envelopes: y =sec if lst ==[] or y&gt; lst[-1]: lst.append(y) else: # äºŒåˆ†æŸ¥æ‰¾y åˆé€‚çš„ä½ç½® left, right =0, len(lst) while left&lt;right: mid =(left +right)//2 if y&lt;= lst[mid]: right =mid else: left =mid +1 lst[left] =y return len(lst) å•æœºç‰ˆæœ¬(c++ ä¸­åœ¨main æˆ–è€… æ™®é€šfunction ä¸­å¯¹vector ç”³è¯·ç©ºé—´ä¹‹åŽï¼Œéƒ½æ˜¯æœ‰é»˜è®¤çš„åˆå§‹åŒ–çš„ã€‚æ¯”å¦‚å¯¹äºŽ vector ï¼Œé‚£ä¹ˆéƒ½æ˜¯åˆå§‹åŒ–æˆ0)python ä¸­sort() å‡½æ•°ä¸­çš„è‡ªå®šä¹‰sort æ˜¯éžå¸¸nice çš„ä¸€å®šå†™æ³•ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445# å…ˆæŽ’åºï¼Œç„¶åŽå°±æ˜¯ æœ€é•¿é€’å¢žå­åºåˆ—çš„é—®é¢˜, è€Œè¯¥é—®é¢˜ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾è¿›è¡Œè§£å†³def maxEnvelopes(arr): if not arr: return 0 arr.sort(key =lambda x: (x[0], -x[1])) lst =[] #print(arr) for _, b in arr: import ipdb #ipdb.set_trace() y =b if lst==[] or y&gt; lst[-1]: lst.append(y) else: # äºŒåˆ†æŸ¥æ‰¾ left, right =0, len(lst)-1 while left &lt;right: mid =(left+ right)//2 if( y&lt; lst[mid]): right =mid else: left =mid+1 lst[left] =y return len(lst)if __name__ =="__main__": n =int(input()) arr =[[0]*2] *n for i in range(n): arr[i] =input().split(" ") arr[i] =[int(a) for a in arr[i]] print(arr) print(maxEnvelopes(arr)) 338. Counting Bits åŽŸé¢˜ æ€æƒ³ï¼š äºŒè¿›åˆ¶çš„æ€æƒ³ã€‚ä½¿ç”¨dp çš„æ—¶å€™ï¼Œå¾€å¾€åˆå§‹åŒ– f[0] ç„¶åŽåœ¨éåŽ†å¾ªçŽ¯çš„æ—¶å€™ï¼Œå°±ä»Ži =1 çš„æ—¶å€™è¿›è¡Œå¾ªçŽ¯ã€‚ 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; f(num+1); f[0] =0; for(int i =1; i&lt;=num; i++) &#123; f[i] =f[i/2] + i&amp;1; // è¡¨ç¤ºi çš„ä¸ªä½æ˜¯ä¸æ˜¯1 &#125; return f; &#125;&#125;; å•æœºç‰ˆæœ¬ 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int n; cin&gt;&gt; n; vector&lt;int&gt; f(n+1); f[0] =0; for(int i =1; i&lt;=n; i++) &#123; f[i] =f[i &gt;&gt;1] + i&amp;1;// å¯ä»¥å†™å¾—æ›´åŠ ç®€å•ä¸€ç‚¹ &#125; for(auto u : f) cout &lt;&lt; u&lt;&lt; " "; cout&lt;&lt;endl; return 0;&#125; 329. Longest Increasing Path in a Matrix åŽŸé¢˜ leetcode ç‰ˆæœ¬ æœ¬é¢˜çš„ç‰¹ç‚¹ï¼Œæ²¡æœ‰ä¸€ä¸ªéžå¸¸æ˜Žç¡®çš„è½¬ç§»é¡ºåºï¼ˆæžšä¸¾é¡ºåºï¼‰ã€‚å› ä¸ºæ˜¯å¯ä»¥æœ‰å››ä¸ªæ–¹å‘è¿›è¡Œé€‰æ‹©çš„ï¼Œè¿™ä¸ªæžšä¸¾é¡ºåºæ˜¯ä¸å¥½å†™çš„ã€‚æ‰€ä»¥å¯ä»¥å­¦ä¹ ä»¥ä¸‹ä¸‹é¢çš„ä»£ç ã€‚å†™çš„æ¯”è¾ƒniceã€‚ è¿™ä¸ªé¢˜ç›®å¾ˆå®¹æ˜“ä½¿ç”¨f[i][j] è¡¨ç¤ºç‚¹ (i,j) ä½ç½®çš„æœ€é•¿çš„è·¯å¾„ï¼Œä½†æ˜¯æ€Žä¹ˆè½¬ç§»ï¼Ÿ è¿™ä¸ªæ˜¯æ²¡æœ‰å›ºå®šçš„è¯´æ˜¯æŒ‰ç…§è¡Œæžšä¸¾è¿˜æ˜¯æŒ‰ç…§åˆ—è¿›è¡Œæžšä¸¾çš„ã€‚æ‰€ä»¥è¿™ä¸ªè½¬ç§»æ–¹ç¨‹æ˜¯ä¸å¤ªå¥½äº›çš„ï¼Œæ‰€ä»¥è¿™é‡Œç”¨åˆ°ä¸€ç§æ–¹æ³•ï¼Œå«åšè®°å¿†åŒ–æœç´¢. è¿™ç§ä½¿ç”¨ dx, dy çš„æ–¹å¼ï¼Œç„¶åŽå¾—åˆ°æ–°çš„åæ ‡(a, b)ã€‚è¿™ç§æ–¹å¼æ˜¯æ¯”è¾ƒé€šç”¨çš„ã€‚ 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int n, m; vector&lt;vector&lt;int&gt;&gt; f, g; int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;; int dp(int x, int y) &#123; if (f[x][y] != -1) return f[x][y]; f[x][y] = 1; for (int i = 0; i &lt; 4; i ++ ) &#123; int a = x + dx[i], b = y + dy[i]; if (a &gt;= 0 &amp;&amp; a &lt; n &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; m &amp;&amp; g[a][b] &lt; g[x][y]) f[x][y] = max(f[x][y], dp(a, b) + 1); &#125; return f[x][y]; &#125; int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) return 0; g = matrix; n = g.size(), m = g[0].size(); f = vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(m, -1)); int res = 0; for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; m; j ++ ) res = max(res, dp(i, j)); return res; &#125;&#125;; å•æœºç‰ˆ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int n, m;vector&lt;vector&lt;int&gt;&gt; f, arr;int dx[4] =&#123;-1, 0, 1, 0&#125;, dy[4] =&#123;0, 1, 0, -1&#125;;int dp(int i, int j)&#123; if(f[i][j] != -1) return f[i][j]; f[i][j] =1; for(int k =0; k&lt;4 ;k++) &#123; int a = i+dx[k], b =j+dy[k]; if(a &gt;=0 &amp;&amp; a&lt; n &amp;&amp; b&gt;= 0 &amp;&amp; b&lt;m &amp;&amp; arr[a][b] &gt; arr[i][j]) f[i][j] =max(f[i][j], dp(a, b)+1); &#125; return f[i][j];&#125;int main()&#123; cin&gt;&gt; n&gt;&gt;m; arr =vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(m)); for(int i =0; i&lt;n; i++) for(int j =0; j&lt;m ;j++) cin &gt;&gt; arr[i][j]; // åˆå§‹åŒ– f =vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(m, -1)); int res =0; for(int i =0; i&lt;n; i++) for(int j =0; j&lt;m; j++) &#123; res =max(res, dp(i, j)); &#125; cout&lt;&lt; res&lt;&lt;endl; return 0;&#125; Coin change åŽŸé¢˜é“¾æŽ¥ ä½¿ç”¨ç¡¬å¸ç»„æˆç»™å®šçš„é’±æ•°ï¼Œç¡¬å¸å¯ä»¥æ— é™ä½¿ç”¨ï¼Œé’±çš„æ€»æ•°æ˜¯ä¸€å®šçš„ï¼Œè¦æ±‚å°½å¯èƒ½ä½¿ç”¨å°‘çš„ç¡¬å¸ã€‚ æ˜¯ä¸€ç§å®Œå…¨èƒŒåŒ…é—®é¢˜ï¼Œä»Žå°åˆ°å¤§è¿›è¡Œæžšä¸¾ã€‚(å¤šé‡èƒŒåŒ…é—®é¢˜æ˜¯å¯¹äºŽå®Œå…¨èƒŒåŒ…é—®é¢˜çš„ä¸€ç§çº¦æŸï¼ŒåŽè€…æ˜¯ç‰©å“å¯ä»¥æ— é™çš„é€‰ï¼Œå‰è€…æ˜¯å¯¹äºŽç‰©å“çš„æ•°é‡æœ‰é™åˆ¶ã€‚ä¹Ÿå°±æ˜¯è¯´å¤šé‡èƒŒåŒ…ä¸­ï¼ŒæŸä»¶ç‰©å“åªèƒ½é€‰æ‹©å‡ ä¸ª) f[i] è¡¨ç¤ºé’±æ•°æ˜¯i éœ€è¦ä½¿ç”¨æœ€å°‘çš„ç¡¬å¸æ•°é‡ã€‚ f[i] =min(f[i], f[i-c]+1) åˆ†æˆé€‰å’Œä¸é€‰ä¸¤ç§æ–¹æ¡ˆã€‚åˆå§‹åŒ– f[0] =0 ï¼ˆæ ¹æ®å®žé™…é—®é¢˜å«ä¹‰è¿›è¡Œåˆå§‹åŒ–ï¼‰ã€‚èƒŒåŒ…é—®é¢˜æ˜¯å°±æ˜¯å…ˆæžšä¸¾ç‰©å“ï¼Œç„¶åŽå†æžšä¸¾ä½“ç§¯ï¼ˆè¿™é‡Œ æ˜¯é‡‘é’±ï¼‰çš„åšæ³•ã€‚ LeetCodeç‰ˆæœ¬ 123456789101112131415161718class Solution &#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; vector&lt;int&gt; f(amount+1, INT_MAX/2); f[0] =0; for(auto c : coins) for(int i =c ; i&lt;= amount; i++) &#123; f[i] =min(f[i], f[i-c]+1); &#125; if(f[amount] == INT_MAX/2) return -1; else return f[amount]; &#125;&#125;; å•æœºç‰ˆ 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; vector&lt;int&gt; coins(n); int amount ; cin &gt;&gt;amount; vector&lt;int&gt; f(amount+1, INT_MAX/2); // è¿™ä¸ªåœ¨cpp ä¸­çš„å¸¸æ•°è¿˜æ˜¯ç»å¸¸ä½¿ç”¨çš„å“¦ f[0] =0; for(int i =0; i&lt;n ; i++) &#123; int c; cin &gt;&gt;c; for(int j =c; j&lt;= amount; j++) f[j] =min(f[j], f[j-c]+1); &#125; if(f[amount] ==INT_MAX/2) cout &lt;&lt; -1 &lt;&lt;endl; else cout &lt;&lt; f[amount] &lt;&lt;endl; return 0;&#125; Maximal Square é¢˜ç›®ï¼š æœ€å¤§çš„åŒ…å«å…¨éƒ¨éƒ½æ˜¯1 çš„æ­£æ–¹å½¢ã€‚f[i][j] è¡¨ç¤ºå³ä¸‹è§’ä½ç½®æ˜¯ (i, j) çš„æ­£æ–¹å½¢çš„è¾¹é•¿ã€‚è¿™ä¸ªè½¬ç§»å’Œä¸Šé¢increasing path æ˜¯ä¸€æ ·çš„ï¼Œéƒ½æ˜¯æ²¡æœ‰å›ºå®šçš„æžšä¸¾æ–¹å¼ï¼Œæ‰€ä»¥ä½¿ç”¨ dx dy å¾—åˆ°ä¸‹ä¸€ä¸ªæ–°çš„åæ ‡ã€‚æ ¹æ®ä¸Šæ–¹ï¼Œå·¦è¾¹å’Œå·¦ä¸Šè§’è¿›è¡Œæ±‚è§£æœ€å°çš„è¾¹é•¿ã€‚ åŽŸé¢˜é“¾æŽ¥LeetCodeç‰ˆæœ¬ 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: // å¦‚ä½•è¡¨ç¤ºï¼Œdp[i][j] è¡¨ç¤ºä»¥ä½ç½®(i,j)ä¸ºå³ä¸‹è§’çš„æ­£æ–¹å½¢çš„å…¨éƒ¨éƒ½æ˜¯1çš„é¢ç§¯ã€‚ // å¦‚ä½•è®¡ç®— dp[i][j] =min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) è¿™ä¸ªæ˜¯è½¬ç§»æ–¹ç¨‹ // åˆå§‹åŒ–, dp =&#123;0&#125; int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if(!matrix.size() || !matrix[0].size()) return 0; int n =matrix.size(), m =matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(m, 0)); int res =0; for(int i =0; i&lt;n; i++) &#123; for(int j =0; j&lt;m; j++) &#123; //if (!i || !j) dp[i][j] =0; if(matrix[i][j] =='0') dp[i][j] =0; else &#123; dp[i][j] =1; if(i &gt;=1 &amp;&amp; j&gt;=1) &#123; // é‚£ä¹ˆè¿™ä¸ªå°±ååˆ†çš„é€šé¡ºï¼Œè®¡ç®—çš„å°±æ˜¯æœ€å°çš„è¾¹é•¿ dp[i][j] += min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) ; &#125; res =max(res, dp[i][j]); &#125; &#125; &#125; return res*res;// dp å¾—åˆ°çš„æ˜¯è¾¹é•¿ï¼Œä¸æ˜¯é¢ç§¯ &#125;&#125;; å•æœºç‰ˆä¸­array çš„è¾“å…¥æ˜¯ int ç±»åž‹ï¼Œæ‰€ä»¥åœ¨è¿›è¡Œ array[i][j] ==â€™1â€™ åˆ¤æ–­å°±æ˜¯é”™è¯¯çš„ï¼Œ å› ä¸º int ç±»åž‹çš„ 1 å’Œ char ç±»åž‹çš„ â€˜1â€™ è¿™ä¸ªæ˜¯ä¸ä¸€æ ·çš„ã€‚æ‰€ä»¥åœ¨ c++ æˆ–è€… c ä¸­ä¸€å®šè¦æ³¨æ„è¿™ä¸ªå°çš„åŒºåˆ«ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;int n, m;vector&lt;vector&lt;int&gt;&gt; arr, dp;int main()&#123; cin&gt;&gt;n&gt;&gt;m; // éœ€è¦ç”³è¯·ç©ºé—´çš„ï¼Œå³ä½¿æ˜¯æ²¡æœ‰åˆå§‹åŒ–æˆç‰¹å®šçš„å€¼ /* arr =vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(m)); for(int i =0; i&lt;n; i++) for(int j =0; j&lt;m; j++) cin&gt;&gt;arr[i][j]; */ arr =&#123;&#123;1, 0 , 1, 0, 0&#125;, &#123;1, 0, 1, 1, 1&#125;, &#123;1, 1, 1, 1,1&#125;, &#123;1, 0, 0, 1, 0&#125;&#125;; // è¿™ç§å…ˆæ˜¯å®šä¹‰ï¼Œç„¶åŽå†ç”³è¯·ç©ºé—´ï¼Œä¹Ÿæ˜¯æ˜Œå‰niceçš„e dp =vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(m, 0)); int res =0; for(int i =0;i&lt;n; i++) for(int j =0; j&lt;m; j++) &#123; if(arr[i][j] =='0') dp[i][j] =0; else &#123; dp[i][j] =1; // è¿™ä¸ªæ¡ä»¶å¾ˆé‡è¦ï¼Œå› ä¸ºå½“ arr[i][j] ==1 çš„æ—¶å€™ï¼Œè¯¥ä½ç½®å°±ç»„æˆäº†dp[][] ==1 if(i&gt;=1 &amp;&amp; j&gt;=1) dp[i][j] += min(dp[i-1][j-1], min(dp[i][j-1],dp[i-1][j]) ); res =max(res, dp[i][j]); &#125; &#125; cout&lt;&lt; res*res &lt;&lt;endl; return 0;&#125; Out of boundary paths(åˆ°è¿™é‡Œäº†) leetcode ç‰ˆæœ¬ åŽŸé¢˜ f[i][j][k] è¡¨ç¤ºä½ç½®åœ¨(i, j) å¹¶ä¸”è¿˜å‰©ä¸‹k æ­¥ï¼Œèµ°å‡ºè¾¹ç•Œçš„æ–¹æ¡ˆæ•°ã€‚åŒæ ·ä½¿ç”¨åˆ°äº†è®°å¿†åŒ–æœç´¢ï¼Œå½“è®¡ç®—è¿‡çš„æ—¶å€™ï¼Œç›´æŽ¥è¿”å›žç»“æžœã€‚ 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: // è¿™ä¸ªåº”è¯¥æ˜¯æœ€ä¸ºå¤æ‚çš„dp äº†å§ã€‚dp[i][j][k] è¡¨ç¤º (i,j) åŒæ—¶è¿˜æœ‰k æ­¥çš„æ—¶å€™ï¼Œèµ°å‡ºè¾¹ç•Œçš„æ–¹æ¡ˆæ•° vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; f; int dx[4] =&#123;-1, 0, 1, 0&#125;, dy[4] =&#123;0, 1, 0, -1&#125;; int mod =1000000007 int findPaths(int m, int n, int N, int i, int j) &#123; f =vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;(m, vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(N+1, -1))); return dp(m, n, N, i, j); &#125; int dp(int m, int n, int k, int x, int y) &#123; int &amp;v =f[x][y][k]; if(v !=-1) return v; v =0; if(!k) return v; for(int i =0; i&lt;4; i++) &#123; int a =x +dx[i], b = y+dy[i]; if(a &lt;0 || a ==m || b&lt;0 || b ==n) v++; else v += dp(m, n, k -1, a, b); v %= mod; &#125; return v; &#125;&#125;; å•æœºç‰ˆ1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;// dp[i][j][k] è¡¨ç¤º(i, j) ä½ç½®åŒæ—¶è¿˜å‰©ä¸‹k æ­¥ï¼Œèµ°å‡ºè¾¹ç•Œçš„æ–¹æ¡ˆä¹¦// è½¬ç§» dp[i][j][k] +=1 if èµ°å‡ºäº†è¾¹ç•Œ else += dp[a][b][k-1]// dp[i][j][k] =0vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; f;int MOD =1000000007;int dx[4] =&#123;-1, 0, 1, 0&#125;, dy[4] =&#123;0, 1, 0, -1&#125;;int dp(int m, int n, int k, int x, int y)&#123; int &amp;v =f[x][y][k]; // è®°å¿†åŒ–æœç´¢ if (v !=-1) return v; v =0; if (!k ) return v; // æžšä¸¾å››ä¸ªæ–¹å‘ for(int i =0; i&lt;4; i++) &#123; int a =x+dx[i], b =y+dy[i]; if(a &lt;0 || a==m || b&lt;0 || b ==n ) v ++; else v +=dp(m,n, k-1, a, b); v %=MOD; &#125; return v;&#125;int main()&#123; int m, n, N, i,j; // ç®€å•çš„å…ˆé€šè¿‡case å†è¯´ m=1, n =3, N =3, i =0, j=1; // è¿™ä¸ªæœ€åŽä¸ºä»€ä¹ˆæ‰‹æœº N+1, æµ‹è¯•ä¸€ä¸‹è¾¹ç•Œ f= vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;(m, vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(N+1, -1))); cout&lt;&lt; dp(m, n, N, i, j)&lt;&lt; endl; return 0;&#125; Decode Ways å­˜åœ¨ä¸€ä¸ªè‹±æ–‡å­—æ¯åˆ°æ•°å­—çš„æ˜ å°„è¡¨ï¼Œç»™å®šæ•°å­—ï¼Œé—®æœ‰å‡ ç§ decode æ–¹å¼ã€‚ f[i] è¡¨ç¤ºå‰ iä¸ªæ•°å­—ä¸€å…±çš„è§£ç æ–¹å¼ã€‚å¯ä»¥åˆ†ä¸ºä¸¤ç§æƒ…å†µï¼Œä¸€ç§æ–¹æ¡ˆæ˜¯å½“å‰çš„æ•°å­—å¯ä»¥æ˜ å°„åˆ°ä¸€ä¸ªå­—æ¯ï¼Œå¦ä¸€ç§æ–¹æ¡ˆæ˜¯å½“å‰æ•°å­—å’Œä¸Šä¸€ä¸ªæ•°å­—æ˜ å°„åˆ°ä¸€ä¸ªå­—æ¯ã€‚f[i] += f[i-1] ï¼ˆè¿™ç§å…³ç³»è¡¨ç¤ºä¸€ç§ç´¯åŠ ï¼Œç»§æ‰¿çš„æ„æ€ï¼‰ã€‚ ï¼ˆä¸ºä»€ä¹ˆåˆ†æˆäº†ä¸¤ç§æƒ…å†µï¼Œæ˜ å°„è¡¨ä¸­æ˜¯1 åˆ°26ï¼Œæ•°å­—ä½¿ç”¨ä¸¤ä½å°±å¯ä»¥ç›´æŽ¥è¡¨ç¤ºï¼‰ ç½‘ç«™é“¾æŽ¥ LeetCode ç‰ˆæœ¬ 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: // dp çš„æ€è·¯ï¼Œ dp[i] è¡¨ç¤ºå‰i ä¸ªå­—ç¬¦ä¸²çš„æ€»çš„æ–¹æ¡ˆä¹¦ // è½¬ç§» dp[i] += dp[i-1] if s[i-1] !='0' , += dp[i-2] if 10&lt;= int(s[i-2: i-1]) &lt;=26 // dp ä¸€å®šæ˜¯è¦è¿›è¡Œåˆå§‹åŒ–çš„ // å§æ§½å…³äºŽæ•°æ®ç±»åž‹ï¼Œè¿™ä¸ªæ˜¯ç¬¬äºŒéäº†å§ï¼Œ 0 å’Œ '0' ä¸æ˜¯ä¸€ä¸ªæ•°æ®ç±»åž‹ int numDecodings(string s) &#123; int n =s.size(); vector&lt;int&gt; f(n+1); s =' '+s; f[0] =1; for(int i =1; i&lt;=n ;i++) &#123; f[i]=0; if(s[i] !='0') f[i] +=f[i-1]; if(i &gt;1) &#123; int t =(s[i-1] -'0')*10 +s[i] -'0'; if (t &gt;=10 &amp;&amp; t&lt;= 26) f[i] += f[i-2]; &#125; &#125; //for(auto u : f) cout&lt;&lt; u&lt;&lt; " "; return f[n]; &#125;&#125;; å•æœºç‰ˆ 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;/** é¦–å…ˆæ˜¯ f[i] è¡¨ç¤ºå‰ i ä¸ªå¯ä»¥è§£ç çš„æ€»æ•° è½¬ç§»æ–¹ç¨‹ f[i] += f[i-1] if s[i-1] !='0' f[i] += f[i-2] if 10&lt;=int(s[i-2,i])&lt;=26 åˆå§‹åŒ– f[i] =0 &amp;&amp; f[0] =1 **/int main()&#123; string s; cin&gt;&gt; s; int n =s.size(); vector&lt;int&gt; f(n+1); // è¾¹ç•Œé—®é¢˜ s = ' '+s; f[0] =1; for(int i =1 ; i&lt;=n; i++) &#123; f[i] =0; if(s[i] !='0') f[i] += f[i-1]; if(i&gt;1) &#123; int t =(s[i-1]-'0')*10 + s[i] -'0'; if( t&lt;=26 &amp;&amp; t&gt;= 10) f[i] += f[i-2]; &#125; &#125; cout&lt;&lt; f[n]&lt;&lt;endl; return 0;&#125; ugly number leetcode ç‰ˆæœ¬åŽŸé¢˜é“¾æŽ¥ vector.back() è®¿é—®è¿”å›žæœ€åŽä¸€ä¸ªå…ƒç´ ã€‚ 123456789101112131415161718192021222324class Solution &#123;public: // ä½¿ç”¨ä¸‰ä¸ªæŒ‡é’ˆï¼Œä¹‹å‰ä½¿ç”¨python ä½¿ç”¨è¿‡ç±»ä¼¼çš„ç®—æ³•æ‰å¯¹ int nthUglyNumber(int n) &#123; vector&lt;int&gt; q; q.push_back(1); int i =0, j=0,k =0; while( --n) &#123; int t =min(q[i]*2, min(q[j]*3, q[k]*5)); q.push_back(t); // è¿™ä¸ªæ˜¯å¹¶åˆ—çš„if if( t == q[i]*2) i++; if(t ==q[j] *3) j++; if(t == q[k] *5) k++; &#125; return q.back(); &#125;&#125;; å•æœºç‰ˆ 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int n; cin &gt;&gt;n; //vector&lt;int&gt; arr(n+1); vector&lt;int&gt; q; //for(int i =0; i&lt;n; i++) cin &gt;&gt;arr[i]; q.push_back(1); int i =0,j =0, k =0; while( --n) &#123; int t =min(q[i] *2, min(q[j]*3, q[k]*5)); q.push_back(t); if(q[i]*2 == t) i++; if(q[j] *3 ==t) j++; if(q[k] *5 ==t) k++; &#125; cout&lt;&lt; q.back()&lt;&lt;endl; // vector.back() æ˜¯è®¿é—®æœ€åŽä¸€ä¸ªæ•°å­— // vector.front() æ˜¯è®¿é—®ç¬¬ä¸€ä¸ªæ•°å­— return 0;&#125; Distinct Subsequences LeetCode ç‰ˆæœ¬é“¾æŽ¥ æ€è·¯ï¼š ä½¿ç”¨dpã€‚å«ä¹‰ï¼šf[i][j] è¡¨ç¤ºsource ä¸ºi ï¼Œdest ä¸ºj çš„æƒ…å†µä¸‹ï¼Œæœ€å¤§çš„æ–¹æ¡ˆæ•°è½¬æ¢ï¼š f[i][ j] = f[i-1][j] ä¸ç®¡ä»€ä¹ˆæƒ…å†µä¸‹ï¼Œå¯¹äºŽsource ä¸­çš„i éƒ½å¯ä»¥ä¸é€‰f[i][j] å¯¹äºŽ s[i] ==d[j] çš„æƒ…å†µä¸‹ï¼Œ f[i][j] += f[i-1][j-1] ï¼Œ å½“ä¸¤ä¸ªç›¸åŒçš„æ—¶å€™ï¼Œè¿™ä¸ªæ˜¯å¯ä»¥é€‰æ‹©çš„ã€‚ï¼ˆä¸é€‰å°±æ²¡æœ‰ç´¯åŠ çš„æ–¹æ¡ˆæ•°ï¼Œé€‰æ‹©å°±æ˜¯ç´¯åŠ çš„æ–¹æ¡ˆæ•°ï¼‰ å­åºåˆ—å’Œå­ä¸²æ˜¯ä¸åŒçš„æ¦‚å¿µï¼Œ å­åºåˆ—è¦æ±‚çš„ä¸è¿žç»­çš„indexï¼Œå­ä¸²è¦æ±‚çš„æ˜¯è¿žç»­çš„indexã€‚æœ€åŽæ±‚çš„æ˜¯s èƒ½å¤Ÿæ‹¼å‡‘æˆ tçš„æ–¹æ¡ˆæ•°ã€‚ 1234567891011121314151617181920212223class Solution &#123;public: // f[i][j] = f[i-1][j] æˆ–è€… =f[i-1][j-1] if(s[i] ==t[j]) long long numDistinct(string s, string t) &#123; int m =s.size(), n =t.size(); vector&lt;vector&lt;long long&gt;&gt; f(m+1, vector&lt;long long&gt;(n+1)); // åˆå§‹åŒ– for(int i =0; i&lt;=m; i++) f[i][0] =1; for(int i =1; i&lt;=m; i++) for(int j =1; j&lt;=n ; j++) &#123; f[i][j] = f[i-1][j]; if(s[i-1] ==t[j-1]) f[i][j]+= f[i-1][j-1];// è¿™ä¸ªç´¯åŠ çš„æ˜¯ä¸é€‰çš„æ–¹æ¡ˆï¼Œç„¶åŽå¦‚æžœç›¸åŒï¼Œé‚£ä¹ˆå°±å†ç´¯åŠ ä¸€ä¸‹ã€‚ &#125; return f[m][n]; &#125;&#125;; å•æœºç‰ˆ 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;int main()&#123; string S; string T; cin&gt;&gt; S; cin&gt;&gt; T; int n =S.size(), m =T.size(); vector&lt;vector&lt;long long&gt;&gt; f(n+1, vector&lt;long long&gt;(m+1)); for(int i =0;i&lt;n; i++) f[i][0] =1; for(int i =1; i&lt;=n; i++) for(int j =1; j&lt;=m ; j++) &#123; f[i][j] = f[i-1][j]; if(S[i-1] == T[j-1]) f[i][j] += f[i-1][j-1]; &#125; cout&lt;&lt; f[n][m] &lt;&lt;endl; return 0; &#125; Palindrome Partitioning II åŽŸé¢˜é“¾æŽ¥ è¿™é“é¢˜ä½¿ç”¨ä¸¤æ¬¡ dpã€‚ ç¬¬ä¸€æ¬¡ï¼š dp[i:j]æ–¹ä¾¿çš„åˆ¤æ–­ä»»æ„ä¸¤ä¸ªåŒºé—´ç»„æˆçš„å­—ç¬¦ä¸²æ˜¯å¦æ˜¯å›žæ–‡æ•°ã€‚ç¬¬äºŒæ¬¡ï¼š dp[i] å‰i ä¸ªå­—ç¬¦ä¸²ä¸­æœ€å°‘æœ‰å¤šå°‘ä¸ªå›žæ–‡æ•°(é¢˜ç›®è¦æ±‚æ˜¯æœ€å°‘çš„ partitionçš„æ•°é‡) ä¸¤ä¸ªfor å¾ªçŽ¯ï¼Œä¿è¯äº†æ¯æ¬¡æžšä¸¾çš„æ˜¯ i( 1-n) çš„left and rightï¼ŒäºŒéƒ¨ä»…ä»…æ˜¯ 1-n çš„left and rightã€‚ å¯¹äºŽdp çš„debugï¼Œä¸€èˆ¬å…ˆä»Žé€»è¾‘ä¸Šï¼ˆçœ‹ä»£ç ï¼‰è¿›è¡Œæ‰¾é”™ï¼›å®žåœ¨ä¸è¡Œæ‰æ˜¯æ¯è¡Œè¾“å‡ºã€‚å› ä¸ºdp å½“æ•°æ®é‡æ¯”è¾ƒå¤§çš„æ—¶å€™ï¼Œè¿™ä¸ªæ˜¯ä¸å®¹æ˜“è¾“å‡ºçš„ã€‚ leetCode-132 95:17 è®²è§£è¿žæŽ¥ https://www.bilibili.com/video/av35161871/?p=1 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: // f[i] è¡¨ç¤ºå‰i ä¸ªå­—æ¯æ˜¯å¤šå°‘ä¸ªå›žæ–‡ä¸²ï¼Œ æ•°é‡çš„å›žæ–‡ä¸² -1 å°±æ˜¯ éœ€è¦å¤šå°‘ åˆ€ // åˆ†æˆå¤šå°‘ä¸ª palindrome partitioningï¼Œ // ä½¿ç”¨åŠ¨è§„ è¿›è¡Œåˆå§‹åŒ–ï¼Œç„¶åŽ int minCut(string s) &#123; int n =s.size(); vector&lt;vector&lt;bool&gt;&gt; c(n, vector&lt;bool&gt;(n, false)); // è¿™ä¸ªc è¡¨ç¤ºä»Ž [j][i] è¿™ä¸ªå­ä¸²æ˜¯ä¸æ˜¯å›žæ–‡ä¸², è¿™ä¸ªæ“ä½œå¾ˆç¥žå¥‡ for(int i =1;i&lt;=n ; i++) for(int j =0; j+i-1 &lt;n; j++) &#123; int l =j, r =j+i-1; c[l][r] = s[l] ==s[r] &amp;&amp; (l+1 &gt; r-1 || c[l+1][r-1] ); &#125; for(auto u : c) &#123; for(auto v : u) cout &lt;&lt; v&lt;&lt; " "; cout &lt;&lt;endl; &#125; vector&lt;int&gt; f(n+1); f[0] =0; for(int i =1; i&lt;=n ;i++) &#123; f[i] =INT_MAX; for(int j =1; j&lt;=i; j++) if(c[j-1][i-1]) // ä¸ºç”šè¿™ä¸ªæ˜¯å›žæ–‡ä¸²ï¼Œä¹‹åŽï¼Œç„¶åŽæ‰èƒ½+1 f[i] =min(f[i], f[j-1]+1); &#125; return f[n]-1; &#125; &#125;; è¿™ä¸ªæ˜¯å•æœºç‰ˆæœ¬ 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;int main()&#123; string s; cin &gt;&gt;s; int n =s.size(); vector&lt;vector&lt;bool&gt;&gt; c(n, vector&lt;bool&gt;(n, false)); for(int i =1; i&lt;=n; i++) &#123; for(int j =0; j+i-1&lt;n; j++) &#123; int l =j, r =j+i -1; c[l][r] = s[l] ==s[r] &amp;&amp;(l+1 &gt; r-1 || c[l+1][r-1]); &#125; &#125; vector&lt;int&gt; f(n+1); f[0]= 0; for(int i =1; i&lt;=n; i++) &#123; f[i] =INT_MAX; for(int j =1; j&lt;=i; j++) if(c[j-1][i-1]) f[i] =min(f[i], f[j-1] +1); &#125; cout&lt;&lt; f[n]-1&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Depth-first Search]]></title>
    <url>%2F2019%2F08%2F29%2Fdepth-first-search%2F</url>
    <content type="text"><![CDATA[æ·±åº¦ä¼˜å…ˆæœç´¢ä¸“é¢˜ï¼Œé¢˜ç›®æ¥æºäºŽLeetCodeã€‚å¤§å¤šæ•°é¢˜ç›®ä½¿ç”¨c++ å®žçŽ°ï¼Œå°‘é‡ä½¿ç”¨python å®žçŽ°ã€‚ æ·±åº¦ä¼˜å…ˆæœç´¢ vs. å®½åº¦ä¼˜å…ˆæœç´¢ï¼šdfsï¼š å½“æ•°é‡éžå¸¸åºžå¤§ï¼Œä½†æ˜¯è§£çš„æ•°é‡éžå¸¸å°‘çš„æ—¶å€™ï¼Œæ±‚è§£è¿™ä¸€ç»„è§£çš„æ—¶å€™ï¼Œä½¿ç”¨æ·±æœæ¥åšã€‚bfs å¯ä»¥ç”¨æ¥æ±‚è§£æœ€çŸ­çš„è·ç¦»ï¼Œæœ€å°çš„æ•°ï¼Œä½¿ç”¨ä¸€ä¸ªé˜Ÿåˆ—è¿›è¡Œç»´æŠ¤ ä½¿ç”¨åœºæ™¯ï¼šå½“çŠ¶æ€æ•°é‡éžå¸¸åºžå¤§çš„æ—¶å€™ï¼Œè§£çš„ä¸ªæ•°éžå¸¸å°‘çš„æ—¶å€™ï¼Œé€‚åˆä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢ã€‚ä½†æœç´¢ä¸ç­‰äºŽæ·±åº¦ä¼˜å…ˆæœç´¢ã€‚æœç´¢æ˜¯ä¸€ç§ç®—æ³•ï¼Œæ·±æœæ˜¯ä¸€ç§å®žçŽ°æ–¹å¼ï¼Œå¯ä»¥ä½¿ç”¨å¾ªçŽ¯æ¥å®žçŽ°ã€‚ letter combinations of a phone number åŽŸé¢˜é“¾æŽ¥å…¶ä¸­çš„ state å°±æ˜¯æœ€åŽçš„ç»“æžœï¼Œ now æ˜¯å½“å‰çš„ç»“æžœï¼Œä¹Ÿæ˜¯æœ‰ç‚¹æ»šåŠ¨æ•°ç»„çš„æ„æ€ã€‚ æœ‰ç‚¹ä¸æ–­çš„æ›´æ–°å‰ç¼€å’ŒåŽç¼€çš„æ„æ€ã€‚ c++ è¯­æ³•ï¼Œç›®å‰ç†è§£å¦‚æžœæ˜¯å¸¸é‡stringï¼Œé‚£ä¹ˆä½¿ç”¨ string dict[[] è¿™æ ·å½¢å¼ï¼Œå¦‚æžœæ˜¯å¯å˜çš„string é‚£ä¹ˆä½¿ç”¨ vector è¿™ç§å½¢å¼ 1234567891011121314151617181920212223242526class Solution &#123;public: // æ˜¾ç¤ºæžšä¸¾æ•°å­—ï¼Œ ç„¶åŽæžšä¸¾çŠ¶æ€ï¼Œå†æžšä¸¾å­—æ¯ string dict[8] =&#123;"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"&#125;; vector&lt;string&gt; letterCombinations(string digits) &#123; if (digits.empty()) return vector&lt;string&gt;(); vector&lt;string&gt; state(1, "");// ä¸å¿…å›ºå®šåˆå§‹åŒ–ï¼Œå› ä¸ºä½ ä¹Ÿæ˜¯ä¸çŸ¥é“æœ€åŽçš„size() for (auto digit: digits) &#123; vector&lt;string&gt; now; for(auto s : state) &#123; for(auto c: dict[digit-'2']) now.push_back(s+c); &#125; state=now; &#125; return state; &#125;&#125;; å•æœºç‰ˆæœ¬123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;vector&lt;string&gt; dict =&#123;"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"&#125;;// æ·±åº¦ä¼˜å…ˆæœç´¢, å…³é”®æ ‘é¡ºåºï¼ŒæŒ‰ç…§digit ä¸€ä¸ªä¸ªè¿›è¡Œæžšä¸¾ï¼Œæ¯ä¸ªdigit å¯¹åº”çš„å­—æ¯éƒ½å¯ä»¥å†æ¬¡è¿›è¡Œæžšä¸¾int main()&#123; string digits; cin &gt;&gt; digits; vector&lt;string&gt; res(1, ""); //vector&lt;string&gt; now; for(auto digit: digits ) &#123; vector&lt;string&gt; now ; for(auto u: dict[digit-'2']) &#123; for(auto v : res) now.push_back(v+u); &#125; res =now; &#125; for(auto u: res) cout &lt;&lt;u&lt;&lt;" "; cout&lt;&lt;endl; return 0;&#125; Word Search åŽŸé¢˜é“¾æŽ¥ dfs çš„æ€è·¯åº”ç”¨åˆ°è¯¥é¢˜ç›®çš„åšé¢˜æ€è·¯ï¼š æžšä¸¾èµ·ç‚¹ ä»Žèµ·ç‚¹å¼€å§‹ï¼Œä¾æ¬¡æœç´¢ä¸‹ä¸€ä¸ªç‚¹çš„ä½ç½® åœ¨æžšä¸¾çš„è¿‡ç¨‹ä¸­ï¼Œéœ€è¦å®žæ—¶åˆ¤æ–­ï¼ˆè¦ä¿è¯å’Œç›®æ ‡å•è¯åŒ¹é…ï¼‰ æ—¶é—´å¤æ‚åº¦åˆ†æž$ n \times m \times 3^k$ æ£‹ç›˜ç±»çš„é¢˜ç›®ï¼Œä¸€èˆ¬éƒ½æ˜¯éœ€è¦ç”¨åˆ°æœç´¢å’ŒåŠ¨æ€è§„åˆ’ã€‚å½“æ•°æ®æ¯”è¾ƒå°çš„æ—¶å€™ä½¿ç”¨æœç´¢ï¼ˆæš´æœï¼‰ï¼Œå½“æ•°æ®æ¯”è¾ƒå¤§çš„æ—¶å€™ï¼Œä½¿ç”¨åŠ¨æ€è§„åˆ’ã€‚ æ‰€è°“å›žæº¯ï¼Œå°±æ˜¯éœ€è¦æ¢å¤çŽ°åœºçš„ã€‚ LeetCode ç‰ˆæœ¬ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: // ä½¿ç”¨dfs è¿›è¡Œè§£å†³ int n_words, n, m; bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; n =board.size(); m =board[0].size(); n_words =word.size(); // åˆ—ä¸¾æ¯ä¸ªèµ·ç‚¹ bool flag =false; for(int i =0; i&lt;n ;i++) for(int j =0; j&lt;m ;j++) if( dfs(board, i, j, word, 0)) &#123; return true; &#125; return flag; &#125; // è¡¨ç¤º board[x][y] å’Œ str[u] æ˜¯å¦ç›¸åŒ // dfs ä¸­çš„è·³å‡ºçš„æ¡ä»¶ int dx[4]=&#123;-1, 0, 1, 0&#125;, dy[4]=&#123;0, 1, 0, -1&#125;; bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y, string&amp; str, int u) &#123; if(board[x][y] != str[u]) return false; if(u ==n_words-1) return true; board[x][y] ='.'; // è¿™ä¸ªä¹Ÿæ˜¯æ¯”è¾ƒç‰›é€¼ for(int i =0; i&lt;4; i++) &#123; int a =x+dx[i], b =y +dy[i]; if(a &gt;=0 &amp;&amp; a&lt;n &amp;&amp; b&gt;= 0 &amp;&amp; b&lt;m) if(dfs(board, a, b, str, u+1)) return true; // è¿™ä¸ªæ˜¯å¦‚ä½•åŽ»ç†è§£ï¼Œå¦‚æžœä¸‹ä¸€ä¸ªå­—èŠ‚u ä¹Ÿèƒ½å¤Ÿèµ°é€šï¼Œé‚£ä¹ˆå°±å¯ä»¥è¿”å›ž true &#125; board[x][y] =str[u]; return false; &#125;&#125;; è¿™ä¸ªæ˜¯å•æœºç‰ˆã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;#define LEN 10int n, m;int dx[4] =&#123;-1, 0, 1, 0&#125;, dy[4] =&#123;0, 1, 0, -1&#125;;// word æ˜¯ä¸€ä¸ªstring ç±»åž‹ï¼Œä½†æ˜¯word.size() ä¾ç„¶æ˜¯å¯ä»¥è¿™æ ·ç”¨çš„e// æ³¨æ„è¿™ä¸ªæŒ‡é’ˆçš„ç¬¦å·bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y, string&amp; word, int u)&#123; //è¾¹ç•Œæ¡ä»¶ if (board[x][y] != word[u]) return false; if(u ==word.size() -1) return true; board[x][y] ='.'; // å¯»æ‰¾ä¸‹ä¸€æ­¥ for(int i =0; i&lt;4 ; i++) &#123; int a =x +dx[i], b =y+dy[i]; if(a &gt;=0 &amp;&amp; a&lt;n &amp;&amp; b&gt;=0 &amp;&amp; b&lt;m) if(dfs(board, a, b, word, u+1)) return true; &#125; board[x][y] =word[u]; return false; &#125;int main()&#123; cin &gt;&gt; n&gt;&gt;m; vector&lt;vector&lt;char&gt;&gt; board(n, vector&lt;char&gt;(m)); //vector&lt;string&gt; word(LEN); string word; for(int i =0; i&lt;n; i++) &#123; for(int j =0; j&lt;m; j++) cin &gt;&gt; board[i][j]; &#125; cin &gt;&gt; word; if(n ==0 || m ==0) return false; bool flag ; // åˆ—ä¸¾èµ·ç‚¹ for(int i=0; i&lt;n; i++) for(int j =0; j&lt;m; j++) &#123; if(dfs(board, i, j, word, 0 )) flag =true; &#125; flag =false; cout &lt;&lt; flag; return 0;&#125; leetcode 46: permutations æœ‰ä¸¤ç§æ€è·¯ï¼š æžšä¸¾æ¯ä¸ªä½ç½®æ”¾å“ªä¸ªæ•°å­—ï¼› æžšä¸¾æ¯ä¸ªæ•°æ”¾å“ªäº›ä½ç½®ã€‚ è¿™é“é¢˜ç›®æ˜¯æžšä¸¾æ•°å­—çš„æ€è·¯æ±‚è§£ï¼Œä¸‹ä¸€é“é¢˜æ˜¯æžšä¸¾ä½ç½®ã€‚ LeetCodeç‰ˆæœ¬ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: // å…¨æŽ’åˆ—çš„é—®é¢˜ï¼Œæœ‰ä¸¤ç§æ€è·¯ï¼Œä¸€ç§æ˜¯ç»™å®šæ•°å­—ç„¶åŽé€‰æ‹©ä½ç½®ï¼› ä¸€ç§æ˜¯ç»™å®šä½ç½®é€‰æ‹©æ•°å­—ã€‚è¿™é‡Œæ˜¯ç»™å®šæ•°å­—ç„¶åŽé€‰æ‹©ä½ç½® // å¯¹äºŽ dfs åœ¨é€’å½’çš„è¿‡ç¨‹ä¸­éœ€è¦ä¼ é€’å¤§é‡çš„å˜é‡ï¼Œè¿™ä¸ªæ—¶å€™è®¾ç½®æˆå…¨å±€å˜é‡æ›´åŠ åˆç† int n; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;bool&gt; flag; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return vector&lt;vector&lt;int&gt;&gt;(); n =nums.size(); // å¯¹äºŽflag çš„åˆå§‹åŒ– flag =vector&lt;bool&gt;(n); dfs(nums, 0); return ans; &#125; void dfs(vector&lt;int&gt;&amp; nums, int u) &#123; if(u ==n) &#123; ans.push_back(path); return; &#125; for(int i =0; i&lt;n; i++) &#123; if(!flag[i]) &#123; flag[i] =true; path.push_back(nums[i]); dfs(nums, u+1); // æ˜¯åœ¨åŽŸæ¥çš„åŸºç¡€ä¸Šï¼Œè¿›è¡Œçš„ u+1 ï¼Œ path.pop_back(); // è¿™ä¸ªæ˜¯å›žå¤çŽ°åœºçš„æ“ä½œï¼Œæ‰€ä»¥path ä¸­åªä¼šæœ‰ä¸€ä¸ªè§£ flag[i] =false; &#125; &#125; &#125;&#125;; ä¸ªäººå•æœºç‰ˆ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;// permutations#define LEN 10int n;vector&lt;int&gt; path;vector&lt;vector&lt;int&gt;&gt; ans;vector&lt;bool&gt; flag;void dfs(vector&lt;int&gt;&amp; arr, int u)&#123; if( u==n) &#123; ans.push_back(path); return; &#125; for(int i =0; i&lt;n;i++) &#123; if(!flag[i]) &#123; flag[i] =true; path.push_back(arr[i]); dfs(arr, u+1); path.pop_back(); flag[i] =false; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; arr(LEN); cin &gt;&gt;n; for(int i =0; i&lt;n ;i++) cin&gt;&gt;arr[i]; flag =vector&lt;bool&gt;(n); dfs(arr, 0); for(auto u: ans) &#123; for(int i =0; i&lt; u.size(); i++) cout&lt;&lt; u[i] &lt;&lt;" "; cout &lt;&lt;endl; &#125; return 0;&#125; Permutations II LeetCode ç‰ˆæœ¬ æžšä¸¾ä½ç½®ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: // è¿™ä¸ªé¢˜ç›®å’Œä¸Šä¸€ä¸ªé¢˜ç›®çš„ä¸åŒç‚¹åœ¨äºŽæœ‰äº†é‡å¤çš„æ•°å­—ï¼Œ // å¦‚æžœé¿å…ç»“æžœçš„é‡å¤å‘¢ï¼Ÿ å°±æ˜¯ç›¸åŒçš„æ•°å­—çš„ç›¸å¯¹é¡ºåºä¿æŒä¸å˜ï¼Œè¿™æ ·å°±ä¸ä¼šå‘ç”Ÿç»“æžœçš„é‡å¤ã€‚ // ä¸Šä¸€æ­¥åŸºäºŽä¸€ä¸ªç®€å•çš„å‡è®¾ï¼Œç›¸åŒçš„æ•°å­—æ˜¯åœ¨ä¸€å—çš„ï¼Œå¦‚ä½•å®žçŽ°è¯¥å‡è®¾ï¼Œä½¿ç”¨æŽ’åºå°±å¯ä»¥è½»æ¾çš„å®žçŽ° // è¿™ä¸ªåªæ˜¯å˜é‡çš„å®šä¹‰ï¼Œå¹¶æ²¡æœ‰å¼€è¾Ÿç©ºé—´ // int n; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; path; vector&lt;bool&gt; st; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; // ä¸‹é¢æ˜¯å¼€è¾Ÿäº†ç©ºé—´ n =nums.size(); st =vector&lt;bool&gt;(n); path =vector&lt;int&gt;(n); sort(nums.begin(), nums.end()); // è¿™ç§æ˜¯å¯¹äºŽ nums éžå¸¸ç®€å•çš„å®žçŽ°äº† dfs(nums, 0, 0); return ans; &#125; void dfs(vector&lt;int&gt; &amp;nums, int u, int start) &#123; if(u ==n) &#123; ans.push_back(path); return ; &#125; for(int i =start; i&lt;n; i++) &#123; if(!st[i]) &#123; st[i] =true; path[i] =nums[u]; // æžšä¸¾ä¸åŒçš„ä½ç½® dfs(nums, u+1, u+1&lt; n &amp;&amp; nums[u+1] ==nums[u] ? i+1:0); st[i] =false; &#125; &#125; &#125; &#125;; ä¸ªäººç‰ˆ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;int n;vector&lt;vector&lt;int&gt;&gt; ans;vector&lt;int&gt; path;vector&lt;bool&gt; flag;void dfs(vector&lt;int&gt;&amp; arr, int u, int start )&#123; if(u ==n) &#123; ans.push_back(path); return; &#125; for(int i =start; i&lt;n; i++) &#123; if(! flag[i]) &#123; flag[i] =true; path[i] =arr[u]; dfs(arr, u+1, u+1&lt;n &amp;&amp; arr[u+1] ==arr[u] ? i+1: 0); flag[i] =false; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; arr; cin &gt;&gt;n; //åˆå§‹åŒ– path =vector&lt;int&gt;(n); flag =vector&lt;bool&gt;(n); arr =vector&lt;int&gt;(n); for(auto u: flag) cout&lt;&lt; u&lt;&lt;" "; for(int i =0;i&lt;n;i++) cin &gt;&gt; arr[i]; sort(arr.begin(), arr.end()); dfs(arr, 0, 0); for(auto u : ans) &#123; for(int i =0; i&lt;u.size(); i++) cout &lt;&lt;u[i] &lt;&lt;" "; cout &lt;&lt;endl; &#125; return 0;&#125; ä¸Šé¢æ˜¯æŽ’åˆ—çš„é—®é¢˜ï¼Œä¸‹é¢æ˜¯ç»„åˆçš„é—®é¢˜ã€‚ Subsets LeetCode ç‰ˆæœ¬ 123456789101112131415161718192021222324class Solution &#123;public: // ä½¿ç”¨å¾ªçŽ¯çš„æ–¹å¼è§£é¢˜ï¼šæ•°å­—çš„äºŒè¿›åˆ¶è¡¨ç¤ºç”¨æ¥è¡¨ç¤ºè¯¥ä½ç½®æ˜¯å¦å‡ºçŽ°è¿‡ï¼Œ // æ•°å­—i çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­ç¬¬ jä½æ˜¯å¦ä¸º1 : i&gt;&gt;j &amp;1 è¿™æ ·è¿›è¡Œåˆ¤æ–­ vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; //vector&lt;int&gt; now; for(int i =0; i&lt; 1&lt;&lt; nums.size(); i++) &#123; vector&lt;int&gt; now; for(int j =0; j&lt; nums.size(); j++) if(i &gt;&gt;j &amp;1) &#123; now.push_back(nums[j]); &#125; res.push_back(now); &#125; return res; &#125;&#125;; å•æœºç‰ˆ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; fun(vector&lt;int&gt;&amp; arr)&#123; cout&lt;&lt; "he"&lt;&lt;endl; vector&lt;vector&lt;int&gt;&gt; res; int n =arr.size(); for(int i =0; i&lt; 1&lt;&lt;n; i++) &#123; vector&lt;int&gt; path; for(int j =0; j&lt;n; j++) &#123; if(i &gt;&gt;j &amp;1) path.push_back(arr[j]); &#125; res.push_back(path); &#125; return res; &#125;int main()&#123; int n; cin&gt;&gt;n; vector&lt;int&gt; arr(n); for(int i =0;i&lt;n;i++) cin&gt;&gt;arr[i]; for(int i =0;i&lt;n;i++) cout&lt;&lt; arr[i] &lt;&lt;" "; //fun(arr); vector&lt;vector&lt;int&gt;&gt; res =fun(arr); for(auto u : res) &#123; for(int i =0;i&lt; u.size(); i++) cout &lt;&lt; u[i] &lt;&lt;" "; cout &lt;&lt;endl; &#125; return 0;&#125; 90. Subsets IIè¿™ä¸ªæ˜¯ä¸Šä¸€é“é¢˜ç›®çš„æ‰©å±•https://leetcode.com/problems/subsets-ii/ LeetCodeç‰ˆæœ¬12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; path; // ä¸ºäº†ä¿è¯ä¸äº§ç”Ÿé‡å¤çš„ï¼Œå…ˆæ˜¯è¿›è¡ŒæŽ’åºï¼Œç„¶åŽå¯¹äºŽç›¸åŒçš„æ•°å­—ï¼Œæžšä¸¾çš„ä¸ªæ•°æ˜¯å’Œæ•°å­—çš„æ¬¡æ•°ç›¸å…³ vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); dfs(nums, 0); return ans; &#125; void dfs(vector&lt;int&gt;&amp; nums, int u) &#123; if( u ==nums.size()) &#123; ans.push_back(path); return; &#125; // uè¡¨ç¤ºå½“å‰çš„æ•°å­—ï¼Œç„¶åŽk è¡¨ç¤ºå½“å‰æ•°å­—é‡å¤çš„ä¸ªæ•° int k =0; while( u+k &lt;nums.size() &amp;&amp; nums[u+k] == nums[u]) k++; // é‡å¤çš„æ•°å­—å¯ä»¥é€‰æ‹© 0~k ä¸ªè¿™æ ·çš„æ•°å­— for(int i =0; i&lt;=k ;i++) &#123; dfs(nums, u+k); path.push_back(nums[u]); &#125; for(int i =0; i&lt;=k ;i++) path.pop_back(); &#125; &#125;; å•æœºç‰ˆ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;#define LEN 10vector&lt;vector&lt;int&gt;&gt; res;vector&lt;int&gt; path;void dfs(vector&lt;int&gt;&amp; arr, int u)&#123; if(u == arr.size()) &#123; res.push_back(path); return; &#125; // æ•°å­—å‡ºçŽ°çš„k æ¬¡æ•° int k =0; while (k+u&lt; arr.size() &amp;&amp; arr[k+u] ==arr[u]) &#123; k ++; &#125; for(int i=0; i&lt;=k; i++) &#123; dfs(arr, u+k); path.push_back(arr[u]); &#125; // å›žæº¯ for(int i =0; i&lt;=k ; i++) &#123; path.pop_back(); &#125;&#125;int main()&#123; int n; //vector&lt;int&gt; arr(LEN); cin&gt;&gt;n; vector&lt;int&gt; arr(n); for(int i =0; i&lt;n; i++) cin&gt;&gt;arr[i]; //for(int i =0; i&lt;n; i++) cout &lt;&lt; arr[i]&lt;&lt; " "; sort(arr.begin(), arr.end()); dfs(arr, 0); for(auto u: res) &#123; for(int i =0; i&lt;u.size(); i++) &#123; cout &lt;&lt;arr[i]&lt;&lt; " "; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 216. Combination Sum III åŽŸé¢˜é“¾æŽ¥ Leetcode ç‰ˆæœ¬12345678910111213141516171819202122232425262728class Solution &#123;public: //dfs(æžšä¸¾æ•°å­—çš„ä¸ªæ•°, å½“å‰æžšä¸¾çš„æ•°å­—, æ•°å­—çš„æ€»å’Œ) vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; dfs(k, 1, n); return ans; &#125; void dfs(int k, int start, int n) &#123; if(!k) &#123; if(!n) ans.push_back(path); return ; &#125; for(int i =start; i&lt;=9; i++) &#123; path.push_back(i);// è¿™ä¸ªè¿˜æ˜¯æœ¬ç¨‹åºçš„æ­¥éª¤ dfs(k -1, i +1, n-i);// è¿™ä¸ªæ˜¯çŠ¶æ€çš„è½¬ç§»ï¼Œæ˜¯ä¸‹ä¸€ä¸ªæ­¥éª¤ path.pop_back(); &#125; &#125; &#125;; å•æœºç‰ˆ1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; ans;vector&lt;int&gt; path;void dfs(int k, int start, int n)&#123; if(!k) &#123; if(!n) ans.push_back(path); return; &#125; for(int i =start; i&lt;=9; i++) &#123; path.push_back(i); dfs(k -1, i+1, n-i); path.pop_back(); &#125;&#125;int main()&#123; int k,n; cin &gt;&gt;k&gt;&gt;n; dfs(k, 1, n); for(auto u: ans) &#123; for(int i=0;i&lt;u.size(); i++) cout&lt;&lt; u[i]&lt;&lt;" "; cout &lt;&lt;endl; &#125; return 0;&#125; 52. N-Queens II è§†é¢‘è®²è§£ å…³é”®æ˜¯æŒ‰ç…§è¡Œè¿›è¡Œdfs(), ç„¶åŽä½¿ç”¨ col å¯¹åˆ—è¿›è¡Œåˆ¤æ–­ï¼Œä½¿ç”¨ d,nd å¯¹äºŽå¯¹è§’çº¿å’Œæ–œå¯¹è§’çº¿è¿›è¡Œåˆ¤æ–­ã€‚ é’ˆå¯¹å¯¹è§’çº¿å’Œæ–œå¯¹è§’çº¿ï¼Œ æ˜¯ x+y å’Œ x-y+n è¿™æ ·çš„å½¢å¼è¿›è¡Œåˆ¤æ–­çš„ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: int ans =0, n; vector&lt;bool&gt; col, d, nd; int totalNQueens(int _n) &#123; n =_n; // åˆå§‹åŒ–çš„æ—¶å€™ï¼Œä½¿ç”¨è¿™æ ·çš„è¯­å¥ col =vector&lt;bool&gt;(n); d =nd =vector&lt;bool&gt;(n*2); dfs(0); return ans; &#125; void dfs(int row) &#123; if(row ==n) &#123; ans +=1; return ; &#125; for(int i =0; i&lt; n; i++) &#123; if(!col[i] &amp;&amp; !d[row+i] &amp;&amp; !nd[row-i +n]) &#123; col[i] =d[row+i] =nd[row-i +n] =true; dfs(row+1); col[i] =d[row+i] =nd[row-i +n] =false; &#125; &#125; &#125;&#125;; å•æœºç‰ˆ12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int ans =0, n;vector&lt;bool&gt; col, d, nd;void dfs(int row)&#123; if(row ==n) &#123; ans ++; return; &#125; for(int i =0; i&lt; n; i++) &#123; if( !col[i] &amp;&amp; !d[row+i] &amp;&amp; !nd[row-i+n]) &#123; col[i] =d[row+i] =nd[row-i+n] =true; dfs(row+1); col[i] =d[row+i]=nd[row-i+n] =false; &#125; &#125; &#125;int main()&#123; cin &gt;&gt;n; col =vector&lt;bool&gt;(n); d =nd =vector&lt;bool&gt;(2*n); dfs(0); cout &lt;&lt; ans&lt;&lt;endl; return 0;&#125; leetcode è®²è§£ç‰ˆ473. Matchsticks to Square åŽŸé¢˜è¿žæŽ¥ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123;public: /** (nums, å½“å‰çš„ç¬¬å‡ æ¡è¾¹ï¼Œå½“æœŸçš„è¾¹çš„é•¿åº¦ï¼Œè¾¹çš„æ€»é•¿åº¦) å‰ªæžï¼š 1. ä»Žå¤§åˆ°å°æžšä¸¾ï¼ˆå…ˆæ˜¯æžšä¸¾åˆ†æ”¯å°‘çš„ï¼Œå› ä¸ºè¿™æ ·ï¼Œå¦‚æžœå‘ç”Ÿäº†å‰ªæžï¼Œé‚£ä¹ˆæ•ˆæžœæ›´åŠ æ˜Žæ˜¾ï¼‰ 2. å¦‚æžœdfs() å¤±è´¥ï¼Œä¸”å½“å‰è¾¹æ˜¯ç¬¬ä¸€æ¡ï¼Œé‚£ä¹ˆå‰ªæž 3. å¦‚æžœdfs() å¤±è´¥ï¼Œä¸”å½“æœŸè¾¹æ˜¯æœ€åŽä¸€å¤©ï¼Œé‚£ä¹ˆå‰ªæž 4. å¦‚æžœå½“å‰çš„è¾¹å¤±è´¥ï¼Œé‚£ä¹ˆä¹‹åŽå’Œå…¶ç›¸åŒçš„è¾¹ä¹Ÿæ˜¯ä¼šå¤±è´¥çš„ */ // å‰ªæžæ˜¯åœ¨å†…å­˜å’Œæ—¶é—´ä¸Šçš„ä¼˜åŒ–ï¼Œå³ä½¿æ²¡æœ‰å‰ªæžï¼Œç»™äº†è¶³å¤Ÿçš„æ—¶é—´å’Œç©ºé—´ï¼Œé‚£ä¹ˆæœ€åŽä¹Ÿæ˜¯èƒ½å¤Ÿå¾—åˆ°ç»“æžœã€ vector&lt;bool&gt; st; bool makesquare(vector&lt;int&gt;&amp; nums) &#123; int length =0; for(auto u : nums) length += u; if( !length || length %4) return false; // æŽ’åº è¿™æ˜¯å‰ªæžçš„æ“ä½œ ï¼Œæ—¶é—´çš„ä¸Šçš„æ“ä½œ sort(nums.begin(), nums.end()); reverse(nums.begin(), nums.end()); st= vector&lt;bool&gt;(nums.size()); return dfs(nums, 0, 0, length/4); &#125; bool dfs(vector&lt;int&gt;&amp; nums, int u, int cur, int sum) &#123; if(cur ==sum) cur =0, u+=1; if( u ==4) return true; for(int i =0; i&lt; nums.size(); i++) if(!st[i] &amp;&amp; cur+ nums[i] &lt;= sum) &#123; st[i] =true; // è¿™ä¸ªåˆ¤æ–­æ¡ä»¶æ˜¯æ¯”è¾ƒæ¸…å¥‡çš„ if(dfs(nums, u, cur+nums[i], sum)) return true; st[i] =false; //å¼€å§‹è¿›è¡Œå‰ªæž if(!cur) return false; if( cur+nums[i] ==sum ) return false; while(i+1 &lt;= nums.size() &amp;&amp; nums[i] ==nums[i+1]) i+=1; &#125; return false; &#125;&#125;; å•æœºç‰ˆ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;vector&lt;bool&gt; st;bool dfs(vector&lt;int&gt;&amp; arr, int u, int cur, int sum)&#123; if(cur ==sum ) cur =0, u +=1; if( u==4) return true; for(int i =0; i&lt; arr.size(); i++) if(!st[i] &amp;&amp; cur+arr[i] &lt;= sum) &#123; st[i] =true; if(dfs(arr, u, cur+ arr[i], sum )) return true; st[i] =false; //å¼€å§‹è¿›è¡Œå‰ªæž if(!cur) return false; if(arr[i] +cur ==sum ) return false; // å¦‚ä½•åŽ»è¡¨ç¤ºä¸€æ¡è¾¹çš„æœ€åŽä¸€ä¸ª while(i+1 &lt;= arr.size() &amp;&amp; arr[i+1] ==arr[i]) i++; &#125; return false;&#125;int main()&#123; int n; cin&gt;&gt;n; vector&lt;int&gt; arr(n); for(int i =0;i&lt;n; i++) cin&gt;&gt;arr[i]; int sum =0; for(auto u : arr) sum +=u; st =vector&lt;bool&gt;(n); if(!sum || sum %4) cout&lt;&lt; "false"&lt;&lt;endl; // ç¬¬ä¸€ä¸ªå‰ªæžæ“ä½œï¼Œä»Žå¤§åˆ°å°æžšä¸¾ sort(arr.begin(), arr.end()); reverse(arr.begin(), arr.end()); bool flag =dfs(arr, 0, 0, sum/4); cout &lt;&lt; flag&lt;&lt;endl; return 0;&#125; è¿™ä¸ªæ˜¯å¾ˆç®€å•çš„æ“ä½œï¼Œæ³¨æ„çœ‹æ³¨é‡Šï¼Œå¥½å¥½ç†è§£ä¸€ä¸‹ã€‚ Word Search 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123;public: // æ—¶é—´å¤æ‚åº¦åˆ†æžï¼Œ O(m *n *dfs()), æœ€å¤§æ˜¯ 3^k ,k è¡¨ç¤ºå¹³å‡çš„å­—ç¬¦ä¸²é•¿åº¦ // dfs ä¸€èˆ¬æ˜¯åœ¨å¾ˆå¤šç»„è§£ä¸­ï¼Œæ‰¾åˆ°å°‘é‡çš„ æˆ–è€…è¯´ä¸€ä¸ªè§£ï¼Œ // bfs ä¸€èˆ¬æ˜¯æ±‚è§£æœ€å°å€¼ çš„é—®é¢˜ï¼Œå› ä¸ºè¿™ä¸ªæ˜¯æ²¡æœ‰åŠžæ³•å¾—åˆ°æ‰€æœ‰çš„çŠ¶æ€è¡¨ç¤º // å½“æ•°æ®èŒƒå›´æ¯”è¾ƒå°çš„æ—¶å€™ï¼Œç”¨æœç´¢ï¼Œå½“æ•°æ®èŒƒå›´æ¯”è¾ƒå¤§çš„æ—¶å€™ï¼Œç”¨åŠ¨æ€è§„åˆ’ // å›žæº¯çš„æ„ä¹‰åœ¨äºŽæ¯ä¸€æ¬¡é‡æ–°å¼€å§‹ï¼ˆèµ·ç‚¹ï¼‰çš„æ—¶å€™ï¼Œå‘¨å›´çš„çŽ¯å¢ƒéƒ½æ˜¯ä¸€æ ·çš„å‘€ // ä¼ å¼•ç”¨å°±æ˜¯ä¼  æŒ‡é’ˆï¼Œè¿™ä¸ªæ˜¯å¾ˆå¿«çš„æ“ä½œï¼Œè€Œä¸ç”¨å¤åˆ¶æ•´ä¸ªarr int n, m; int dx[4] =&#123;-1, 0, 1, 0&#125;, dy[4] =&#123;0, 1, 0, -1&#125;; vector&lt;vector&lt;bool&gt;&gt; st; bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; if(board.empty() || board[0].empty()) return false; n =board.size(); m =board[0].size(); st =vector&lt;vector&lt;bool&gt;&gt;(n , vector&lt;bool&gt;(m, false)); for(int i =0; i&lt;n ; i++) &#123; for(int j =0; j&lt;m; j++) &#123; bool tmp =dfs(board, i, j, word, 0); cout&lt;&lt; tmp&lt;&lt;endl; if(tmp) return true; &#125; &#125; return false; &#125; bool dfs(vector&lt;vector&lt;char&gt;&gt; &amp; board, int a, int b, string &amp; word, int u) &#123; if(board[a][b] != word[u]) return false; if(u ==word.size()-1) return true; //st[a][b] =true; // è¿™ä¸ªå°±æ˜¯æ ‡è®°ä¸€ä¸‹è€Œå·² char t = board[a][b]; board[a][b] ='*'; for(int i =0; i&lt;4 ; i++) &#123; int x =a +dx[i], y =b +dy[i]; if(x &gt;= 0 &amp;&amp; x&lt;n &amp;&amp; y&gt;= 0 &amp;&amp; y&lt;m) if(dfs(board, x, y, word, u+1)) return true; &#125; //st[a][b] =false; board[a][b] =t; return false; &#125; &#125;; permutations è¿™ä¸ªé—®é¢˜å°±æ˜¯ä¸€ç§å…¨æŽ’åˆ—çš„é—®é¢˜ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123;public: // dfs ï¼Œæžšä¸¾ä½ç½® å’Œæžšä¸¾æ•°å­—ï¼Œä¸¤ç§æ–¹å¼ï¼Œæ³¨æ„è¿™é“é¢˜æ˜¯æ¯”è¾ƒå¥½åšåœ¨äºŽæ˜¯ distinct çš„æ•°å­— /* vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; dfs(nums, 0); return res; &#125; void dfs(vector&lt;int&gt;&amp; nums, int u) &#123; if( u ==nums.size() -1) &#123; tmp.push_back(nums[u]); res.push_back(tmp); tmp.clear(); return; &#125; tmp.push_back(nums[u]); if(u +1 &lt; nums.size()) dfs(nums, u+1); &#125; */ // å¯¹äºŽæ—¶é—´å¤æ‚åº¦çš„åˆ†æžï¼Œç”¨åˆ°é€’å½’æ ‘ï¼Œ åªéœ€è¦çœ‹æœ€åŽçš„å¶å­ç»“ç‚¹ n!(è¿™ä¸ªå¯ä»¥ä»Žè§£çš„ä¸ªæ•°ä¸Šæ¥è¿›è¡Œç†è§£ï¼Œ æ¯”å¦‚è¯´æœ‰ 3ä¸ªæ•°å­—ï¼Œæœ€åŽäº§ç”Ÿäº†6ç»„è§£ï¼Œæ‰€ä»¥æ˜¯ n!,) // ä¸€ç»„è§£ æ‰€éœ€è¦çš„æ—¶é—´æ˜¯O(n)ï¼Œ æ‰€ä»¥æ€»çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(n * n!) è¿™ä¸ªæ ·å­ vector&lt;bool&gt; st; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt; &amp; nums) &#123; st =vector&lt;bool&gt;(nums.size()); dfs(nums, 0); return ans; &#125; void dfs(vector&lt;int&gt; &amp;nums, int u) &#123; if( u == nums.size()) &#123; // è¿™é‡Œæ˜¯æ¯”è¾ƒç®€æ´çš„ï¼Œä¸éœ€è¦å†æ¬¡è¿›è¡Œæ·»åŠ åˆ°path é‡Œé¢äº† ans.push_back(path); return ; &#125; // æˆ‘åªæ˜¯æ‰¾åˆ°äº†ä¸€ä¸ªè§£ï¼Œæ˜¯éœ€è¦è¿›è¡Œæžšä¸¾ä¸åŒçš„ä½ç½®çš„ for(int i =0; i&lt; nums.size(); i++) &#123; if(!st[i]) &#123; st[i] =true; path.push_back(nums[i]); dfs(nums, u+1); st[i] =false; path.pop_back(); // vector() ä¸­çš„clear() å’Œpop_back() æœ‰ä»€ä¹ˆåŒºåˆ«? &#125; &#125; &#125; // vector&lt;int&gt; ä¸­ pop_back() æ˜¯å’Œpush_back() ç›¸å¯¹åº”çš„ï¼Œéƒ½æ˜¯åœ¨å°¾éƒ¨è¿›è¡Œæ“ä½œ // erase() , Removes from the vector either a single element (position) or a range of elements ([first,last)). åŒ…æ‹¬firstï¼Œä¸åŒ…æ‹¬lastã€‚ // æ¯”å¦‚è¯´è¿™ä¸ªæ ·ä¾‹ï¼Œ vec.erase(vec.begin()+5);//erase the 6th element &#125;; Permutations II æ—¶é—´å¤æ‚åº¦åŒä¸Š$(n! * n)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: // è¿™ä¸ªåœ¨äºŽå…ƒç´ å¯èƒ½æ˜¯é‡å¤çš„ã€‚è§£å†³æ–¹æ¡ˆï¼Œå…ˆè¿›è¡ŒæŽ’åºï¼Œç„¶åŽå†é€‰æ‹©çš„æ—¶å€™ï¼Œä¸é€‰ç›¸åŒçš„å…ƒç´  // dfs() çš„æ—¶å€™å¤šä¸€ä¸ªèµ·å§‹ç‚¹ // æ˜¯å¦å¤–ä¸€ç§æ€è·¯ï¼Œä¸Šä¸€é“é¢˜æ˜¯æžšä¸¾çš„æ•°å­—ï¼Œè¿™ä¸ªæ˜¯æžšä¸¾çš„å‘ä½ // æ•°å­—æ˜¯é‡å¤çš„ï¼Œä½†æ˜¯å‘ä½æ˜¯ä¸é‡å¤çš„å‘€ï¼Œæ‰€ä»¥å¯ä»¥æžšä¸¾å‘ä½ vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;bool&gt; st; int n ; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; n =nums.size(); st= vector&lt;bool&gt;(n, false); path= vector&lt;int&gt;(n); sort(nums.begin(), nums.end()); dfs(nums, 0, 0); return res; &#125; void dfs(vector&lt;int&gt;&amp; nums, int u, int beg) &#123; if(u ==n) &#123; res.push_back(path); return ; &#125; // å¼€å§‹è¿›è¡Œæžšä¸¾ for(int i= beg ; i&lt;n; i++) &#123; if(!st[i]) &#123; st[i] =true; path[i] =nums[u]; // è¿™é‡Œä½“çŽ°çš„æ˜¯æžšä¸¾çš„ path[i] è¡¨ç¤ºçš„ä½ç½®, if(u+1 &lt; n&amp;&amp; nums[u+1] != nums[u]) dfs(nums, u+1, 0); // è¿™ä¸ªæ³¨æ„ä¸ºä»€ä¹ˆä»Ž 0å¼€å§‹ else dfs(nums, u+1, i+1); st[i] =false; &#125; &#125; &#125;&#125;; Subsets å¯¹äºŽäºŒç»´çš„dfsï¼Œç»å¸¸å‡ºçŽ°çš„åˆ¤æ–­æ¡ä»¶æ˜¯æ˜¯å¦è®¿é—®è¿‡ï¼Œç„¶åŽæ ‡è®°ä¸€ä¸‹ã€‚å¯¹äºŽä¸€ç»´çš„æ•°å­—ï¼Œæ›´å¤šæ˜¯å›žæº¯ï¼Œå¦‚æžœå‘çŽ°ä¸æ˜¯æœ€ä¼˜è§£ï¼Œé‚£ä¹ˆæ˜¯å›žæ»šåˆ°ä¹‹å‰çš„çŠ¶æ€ã€‚ 12345678910111213141516171819202122232425class Solution &#123;public: // è¿­ä»£çš„å†™æ³•ï¼Œä½¿ç”¨äºŒè¿›åˆ¶çš„æ€æƒ³æ±‚è§£ // å¦‚æžœæœ‰ä¸‰ä½æ•°ï¼Œé‚£ä¹ˆ 000 001 010 è¿™æ ·è¡¨ç¤º, å¦‚æžœæŸä¸€ä½æ˜¯1 é‚£ä¹ˆå°±è¡¨ç¤ºé€‰æ‹©ï¼Œå¦åˆ™è¡¨ç¤ºæ²¡æœ‰é€‰æ‹© // å¦‚æžœçŸ¥é“äº†æ—¶é—´å¤æ‚åº¦ O(2^n *n)ï¼Œ å¯¹äºŽè¿­ä»£æ¥è¯´ï¼Œè¿™ä¸ªæ˜¯ä¸æ˜¯ä¹Ÿæ˜¯åŸºæœ¬ä¸Šå°±çŸ¥é“äº† vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; int n =nums.size(); for(int i =0; i&lt; (1&lt;&lt;n); i++) &#123; vector&lt;int&gt; tmp; for(int j =0 ; j&lt;n ;j++) &#123; if( i&gt;&gt; j &amp;1) tmp.push_back(nums[j]); &#125; res.push_back(tmp); &#125; return res; &#125;&#125;; å¦‚æžœæœ‰é‡å¤çš„æ•°å­—ï¼Œé‚£ä¹ˆåº”è¯¥ä»Žé‡å¤çš„æ•°å­—é€‰æ‹©å‡ æ¬¡ï¼Œè¿™ä¸ªè§’åº¦è¿›è¡Œè€ƒè™‘ã€è¿™ä¸ªæ—¶é—´å¤æ‚åº¦å’Œä¸Šé¢çš„æ˜¯ä¸€æ ·çš„ï¼ˆå› ä¸ºä¸€èˆ¬æ¥è¯´ æ—¶é—´å¤æ‚åº¦å°±æ˜¯æŒ‡çš„æœ€åçš„æƒ…å†µä¸‹ï¼Œé™¤éžåƒä¸€äº›æŽ’åºç®—æ³•ï¼Œæ¯”å¦‚è¯´ä¸€èˆ¬è¯´æ—¶é—´å¤æ‚åº¦æ˜¯$O(nlogn)$ï¼Œ å› ä¸º $O(n^2)$ è¿™ä¸ªå¤æ‚åº¦è¾¾åˆ°çš„æ¦‚çŽ‡æ˜¯æžå°çš„ã€‚ï¼‰ 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: // è¿™ä¸ªé¢˜ç›®æ˜¯æœ‰é‡å¤çš„æ•°å­—ï¼Œä¸Šä¸€é“é¢˜ç›®æ˜¯æ¯ä¸ªæ•°å­—åªæœ‰ 0 1 ä¸¤ç§é€‰æ‹© // è¿™ä¸ªé¢˜ç›® æ¯ä¸ªæ•°å­—æ˜¯æœ‰ 0 1 2 ... k ï¼ˆå…¶ä¸­k è¡¨ç¤ºæ•°å­—åœ¨array ä¸­å‡ºçŽ°çš„æ¬¡æ•°ï¼‰ // å¯¹äºŽé‡å¤çš„ï¼Œå…ˆè¿›è¡Œåˆ†ç±»æˆ–è€…è¯´åˆ†å—ï¼ˆè€Œè¿™ä¸ªåˆ†ç±»æ˜¯å¯ä»¥ä½¿ç”¨æŽ’åºå®žçŽ°çš„ï¼‰ vector&lt;vector&lt;int&gt;&gt; res; int n; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; n= nums.size(); sort(nums.begin(), nums.end()); dfs(nums, 0);// dfs(nums, u) uè¡¨ç¤ºé€‰æ‹©çš„ç¬¬ å‡ ä¸ªæ•°å­— return res; &#125; void dfs(vector&lt;int&gt; &amp; nums, int u) &#123; if(u ==n) &#123; res.push_back(path); return ; &#125; // æ‰¾å‡ºk çš„ä¸ªæ•° æ¬¡æ•° int k=0; while(k +u&lt; n&amp;&amp; nums[u+k] ==nums[u] ) k++; // å¼€å§‹è¿›è¡Œæžšä¸¾ k æ¬¡ for(int i =0; i&lt;=k ;i++) &#123; dfs(nums, u+k); path.push_back(nums[u]); &#125; // æ¢å¤çŽ°åœº for(int i =0; i&lt;=k ; i++) path.pop_back(); &#125; &#125;; Combination Sum III 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: // dfs(int k, int n, int start) // å› ä¸ºä¸èƒ½å‡ºçŽ°é‡å¤çš„é›†åˆï¼Œæ‰€ä»¥å¯ä»¥äººä¸ºçš„è§„å®šæžšä¸¾çš„é¡ºåº(ä»Žå°åˆ°å¤§æžšä¸¾) // æ—¶é—´å¤æ‚åº¦åˆ†æž c(k,9) *kï¼Œ å‘çŽ°æ²¡æœ‰ï¼Œå°±æ˜¯ç»“æžœæ•° // é€‰æ‹©çš„k ä¸ªæ•°å­—ä¸­æ˜¯æ²¡æœ‰é‡å¤çš„ï¼Œå› ä¸ºè¿™ä¸ªæ˜¯comnbination vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; // è¿™ä¸ªåˆå§‹åŒ–è¯æ˜¯ä»Ž1 å¼€å§‹çš„ dfs(k, n, 1); return res; &#125; void dfs(int k, int n, int begin) &#123; // æ˜¯è¿™é‡Œæœ‰äº†è¾¹ç•Œï¼Œ ç„¶åŽå† æžšä¸¾çš„è¿‡ç¨‹ä¸­å°±ä¸éœ€è¦è¾¹ç•Œï¼Œå› ä¸ºè¿™ä¸ªæ˜¯å¯ä»¥returnçš„ if(!k) &#123; if(!n) &#123; //for(auto u: path) cout&lt;&lt; u&lt;&lt;" "; res.push_back(path); &#125; return; &#125; // çŸ¥é“è¿™é‡Œk éœ€è¦åšä¸€ä¸‹é™åˆ¶ï¼Œæˆ–è€…è¯´k &lt;0 çš„æ—¶å€™ï¼Œæ˜¯éœ€è¦ return for(int i =begin; i&lt;=9; i++) &#123; path.push_back(i); dfs(k-1, n -i, i+1); path.pop_back(); &#125; &#125;&#125;; çŸ©é˜µä¸­çš„è·¯å¾„ è¯·è®¾è®¡ä¸€ä¸ªå‡½æ•°ï¼Œç”¨æ¥åˆ¤æ–­åœ¨ä¸€ä¸ªçŸ©é˜µä¸­æ˜¯å¦å­˜åœ¨ä¸€æ¡åŒ…å«æŸå­—ç¬¦ä¸²æ‰€æœ‰å­—ç¬¦çš„è·¯å¾„ã€‚ æ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ $O(n^23^k)$ï¼Œ æžšä¸¾ $n^2$ ä¸ªèµ·ç‚¹ï¼Œæ¯ä¸ªèµ·ç‚¹æ˜¯æœ‰ä¸‰ä¸ªé€‰æ‹©ï¼ˆä¸èµ°é‡å¤çš„è·¯ï¼‰ï¼Œç„¶åŽ $k$ æ˜¯å­—ç¬¦ä¸²çš„å¹³å‡é•¿åº¦ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: // å¯»æ‰¾æ˜¯å¦å­˜åœ¨æŸä¸ªå­—ç¬¦ä¸²çš„è·¯å¾„ã€‚å…ˆæ˜¯æžšä¸¾èµ·ç‚¹ï¼Œç„¶åŽdfs å¯»æ‰¾è·¯å¾„ int n, m; int dx[4] =&#123;-1, 0, 1, 0&#125;, dy[4] =&#123;0, 1, 0, -1&#125;; bool hasPath(vector&lt;vector&lt;char&gt;&gt;&amp; matrix, string str) &#123; if( !matrix.size()) return false; // case matrix =[] n =matrix.size() , m =matrix[0].size(); for(int i =0; i&lt; n; i++) &#123; for(int j =0; j&lt; m; j++) &#123; if(dfs(matrix, str, 0, i, j)) return true; &#125; &#125; return false; &#125; bool dfs(vector&lt;vector&lt;char&gt;&gt; &amp; matrix, string &amp; str, int u, int x, int y) &#123; if(str[u] != matrix[x][y]) return false; if(u ==str.size()-1) return true;// è¿™ä¸ªä¸»æ„æ˜¯ size() -1 char tmp =matrix[x][y]; matrix[x][y] ='#'; for(int i =0; i&lt; 4; i++) &#123; int a =dx[i] +x, b =dy[i] +y; if(a&gt;= 0 &amp;&amp; a&lt;n &amp;&amp; b&gt;=0 &amp;&amp; b&lt; m) &#123; if(dfs(matrix, str, u+1, a, b)) return true; &#125; &#125; matrix[x][y] =tmp; return false; &#125;&#125;; 24. æœºå™¨äººçš„è¿åŠ¨èŒƒå›´ è¿™ä¸ªæ˜¯ bfs çš„é¢˜ç›®ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ $O(mn)$ 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: // è¿™ä¸ªå…¶å®žéƒ½ä¸å¿…ä½¿ç”¨ dfs or bfsçš„æ€æƒ³ï¼Œå› ä¸ºè¿™ä¸ªæ˜¯è¿žç»­çš„ï¼Œæ‰€ä»¥å¿…ç„¶æ˜¯æŸä¸€ä¸ªåŒºåŸŸæ˜¯èƒ½å¤Ÿè®¿é—® // æŸä¸€ä¸ªåŒºåŸŸæ˜¯ä¸èƒ½è®¿é—® // å®½åº¦ä¼˜å…ˆæœç´¢ï¼Œæ—¶é—´å¤æ‚ O(mn) æ¯ä¸ªç‚¹åªå­˜åœ¨éåŽ†ä¸€éï¼Œä¸å­˜åœ¨å›žæº¯çš„æƒ…å†µï¼Œ åªæ˜¯æ ‡è®°ä¸€ä¸‹ int get_single(int x) &#123; int sum =0; while(x) sum += x%10, x /=10; return sum; &#125; int get_sum(pair&lt;int, int&gt; p) &#123; return get_single(p.first) +get_single(p.second); &#125; int movingCount(int threshold, int rows, int cols) &#123; queue&lt;pair&lt;int, int&gt;&gt; q; int res =0; vector&lt;vector&lt;bool&gt;&gt; st(rows, vector&lt;bool&gt;(cols)); q.push(&#123;0,0&#125;); int dx[4] =&#123;-1, 0, 1, 0&#125;, dy[4]=&#123;0, 1, 0, -1&#125;; while(q.size()) &#123; pair&lt;int, int&gt; t =q.front(); q.pop(); int x =t.first, y =t.second; if(st[x][y] || get_sum(t) &gt; threshold) continue; st[x][y] =true; res +=1; for(int i =0; i&lt; 4; i++) &#123; int a = x+dx[i], b =y +dy[i]; if(a&gt;= 0 &amp;&amp; a&lt; rows &amp;&amp; b &gt;=0 &amp;&amp; b&lt; cols) q.push(&#123;a, b&#125;); &#125; &#125; return res; &#125;&#125;; 51. æ•°å­—æŽ’åˆ— æ—¶é—´å¤æ‚åº¦åˆ†æžï¼šæœç´¢æ ‘ä¸­æœ€åŽä¸€å±‚å…± $n!$ ä¸ªèŠ‚ç‚¹ï¼Œå‰é¢æ‰€æœ‰å±‚åŠ ä¸€å—çš„èŠ‚ç‚¹æ•°é‡ç›¸æ¯”äºŽæœ€åŽä¸€å±‚èŠ‚ç‚¹æ•°æ˜¯æ— ç©·å°é‡ï¼Œå¯ä»¥å¿½ç•¥ã€‚ä¸”æœ€åŽä¸€å±‚èŠ‚ç‚¹è®°å½•æ–¹æ¡ˆçš„è®¡ç®—é‡æ˜¯ $O(n)$ï¼Œæ‰€ä»¥æ€»æ—¶é—´å¤æ‚åº¦æ˜¯ $O(nÃ—n!)$ã€‚ è¿™ä¸ªæ˜¯æŽ’åˆ—é—®é¢˜ï¼Œ $n! $ æ˜¯æ²¡æœ‰æ¯›ç—…çš„ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution &#123;public: // å…ˆæŽ’åºï¼Œç„¶åŽæ ¹æ®æ˜¯å¦é‡å¤é€‰æ‹©ä¸‹ä¸€ä¸ªæžšä¸¾çš„èµ·ç‚¹ï¼Œ ä½¿ç”¨st è¡¨ç¤ºæ˜¯å¦æžšä¸¾è¿‡ int n; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; permutation(vector&lt;int&gt;&amp; nums) &#123; n =nums.size(); // è¿™ä¸ªæ˜¯ä¸èƒ½é‡å¤çš„int n path.resize(n);// ç¥žä¸€æ ·çš„æ“ä½œ sort(nums.begin(), nums.end()); dfs(nums, 0, 0, 0); return res; &#125; void dfs(vector&lt;int&gt; &amp; nums, int u, int be, int st) &#123; if(u ==n) &#123; res.push_back(path); return ; &#125; // ä¸€æ¬¡dfs åˆ¤æ–­ä¸€æ¬¡å°±okäº† if(!u || nums[u] !=nums[u -1]) be =0; for(int i =be; i&lt; n; i++) &#123; if(!(st &gt;&gt; i &amp;1)) &#123; path[i] =nums[u]; dfs(nums, u +1, i +1, st +(1&lt;&lt; i)); &#125; &#125; &#125;&#125;;2. [784. Letter Case Permutation](https://leetcode.com/problems/letter-case-permutation/submissions/)æ—¶é—´å¤æ‚åº¦æ¯ä¸ªå­—æ¯æœ‰ä¸¤ç§é€‰æ‹© $2^n$, ç„¶åŽæœ€åŽ res çš„æ—¶å€™æ˜¯ $O(n)$ï¼Œ æ‰€ä»¥æ€»çš„æ—¶é—´å¤æ‚æ˜¯$O(n2^n)$```c++class Solution &#123;public: // ç®€å•çš„dfs vector&lt;string&gt; res; vector&lt;string&gt; letterCasePermutation(string S) &#123; dfs(S, 0); return res; &#125; void dfs(string &amp; S, int u) &#123; if( u ==S.size()) &#123; res.push_back(S); return ; &#125; dfs(S, u +1); if(S[u] &gt;=&apos;A&apos;) &#123; S[u] ^= 32; // è‹±æ–‡å¤§å°å†™å­—æ¯è½¬æ¢çš„å°çš„tips dfs(S, u +1); &#125; &#125;&#125;; 77. Combinations æ—¶é—´å¤æ‚åº¦æ˜¯$O(C^k_n)$, æ˜¯ä¸€ä¸ªç»„åˆé¢˜ç›®ã€‚ 12345678910111213141516171819202122232425262728class Solution &#123;public: // ä½¿ç”¨dfs æœ€é‡è¦çš„æ˜¯æžšä¸¾çš„é¡ºåºï¼Œè¿™ä¸ªæ˜Žæ˜¾æ˜¯ä¸€ä¸ªç»„åˆé—®é¢˜ï¼Œæ²¡æœ‰é¡ºåºï¼Œæ‰€æœ‰æ˜¯éœ€è¦äººä¸ºçš„æ ¹æ®æ ·ä¾‹å¾—åˆ°ä¸€ä¸ªä¹¦åº // å‡å®šè¿™ä¸ªæ˜¯é€’å¢žçš„ï¼Œæ‰€ä»¥åœ¨dfsä¸­éœ€è¦è§„å®šä¸€ä¸ªä¸‹ä¸€ä¸ªçš„èµ·ç‚¹ vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; path.resize(k); dfs(0, 1, n, k); return res; &#125; // å›žæº¯çš„æ€æƒ³æ˜¯éœ€è¦æœ‰çš„ï¼Œä½†æ˜¯æœ‰ä¸åŒçš„å®žçŽ°æ–¹æ³•ã€‚ä¸€ç§æ˜¯ path[u] =i è¿™ç§å°±æ˜¯ç›´æŽ¥å¤åˆ¶è¦†ç›– // å¦å¤–ä¸€ç§ path.push_back(i) , path.pop_back() è¿™ç§ä¹Ÿæ˜¯ä¸€ç§å›žæº¯ void dfs(int u, int be, int n, int k) &#123; if(u == k) &#123; res.push_back(path); return; &#125; // æžšä¸¾é¡ºåº for(int i =be; i&lt;=n ; i++) &#123; path[u] =i; dfs(u +1, i+1, n, k); &#125; &#125;&#125;; LeetCode 216. Combination Sum III æ—¶é—´å¤æ‚åº¦åˆ†æžï¼šä»Ž9ä¸ªæ•°ä¸­é€‰ k ä¸ªæ€»å…±æœ‰ $C_k^9$ ä¸ªæ–¹æ¡ˆï¼Œå°†æ¯ä¸ªæ–¹æ¡ˆè®°å½•ä¸‹æ¥éœ€è¦ $O(k)$çš„æ—¶é—´ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦æ˜¯ $O(C_k^9Ã—k) $ã€‚ 123456789101112131415161718192021222324252627282930class Solution &#123;public: // è¿™ä¸ªåšçš„æ˜¯å‡æ³•ï¼Œé‚£ä¹ˆæœ‰å¾ˆå¤šè¾¹ç•Œæ¡ä»¶æ˜¯å¯ä»¥ä¼˜åŒ–çš„ vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; dfs(k, n, 1); return res; &#125; // k è¡¨ç¤ºèƒ½å¤Ÿæžšä¸¾çš„ä¸ªæ•°ï¼Œ nè¡¨ç¤ºèƒ½å¤Ÿæžšä¸¾æ•°å­—çš„å’Œï¼Œ be è¡¨ç¤ºä¸‹ä¸€ä¸ªçš„èµ·ç‚¹ä½ç½®ï¼Œéœ€è¦äººå·¥çš„æŒ‡å®šé¡ºåº void dfs(int k, int n, int be) &#123; if(!k) &#123; //è¿™é‡Œä¸ªæ•°æžšä¸¾å®Œäº†ï¼Œä½†æ˜¯ä¸ä¸€å®šæ˜¯ ç¬¦åˆè¦æ±‚çš„ï¼Œæ‰€æœ‰æœ‰ä¸¤ä¸ªé™åˆ¶æ¡ä»¶ if(!n) &#123; res.push_back(path); &#125; return ; &#125; for(int i =be; i&lt;=9; i++) &#123; if(i&gt;n) continue; path.push_back(i); dfs(k -1, n -i, i+1); path.pop_back(); &#125; &#125;&#125;; 79. Word Search æˆ‘ä¹Ÿå¯ä»¥è¿›è¡Œdebugçš„ï¼Œè¿™é‡Œå¯ä»¥ä½¿ç”¨ ä¿®æ”¹ board[x][y] ä¸­çš„å€¼æ¥è¾¾åˆ°è®°å½•çŠ¶æ€çš„æ•ˆæžœï¼Œå¹¶ä¸”ä»Žå†…å­˜å’Œè¿è¡Œæ—¶é—´ä¸Šéƒ½æ˜¯ä¼˜äºŽé‡æ–°å®šä¹‰ä¸€ä¸ªæ•°ç»„çš„ã€‚æ—¶é—´å¤æ‚åº¦åˆ†æžï¼Œ èµ·ç‚¹æ˜¯ $n^2$ï¼Œæ¯ä¸ªå•è¯é™¤äº†é¦–å­—æ¯å¤–éƒ½æ˜¯åªèƒ½æœ‰ä¸‰ç§é€‰æ‹©ï¼ˆä¸èƒ½èµ°é‡å¤çš„è·¯ï¼‰ï¼Œæ‰€ä»¥ $3^k$ï¼ˆk è¡¨ç¤ºå­—ç¬¦ä¸²çš„å¹³å‡é•¿åº¦ï¼‰ã€‚æ‰€ä»¥æ€»å…±çš„æ—¶é—´å¤æ‚åº¦æ˜¯$n^23^k$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: // è¿™ç§æ€è·¯å¾ˆå¸¸è§ï¼Œå…ˆæ˜¯æžšä¸¾èµ·ç‚¹ï¼Œç„¶åŽå†æœç´¢è·¯å¾„ã€‚æœç´¢çš„æ—¶å€™ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘è¿›è¡ŒéåŽ† // éœ€è¦ä¸€ä¸ªst æ ‡å¿—æ˜¯å¦éåŽ†è¿‡ vector&lt;vector&lt;bool&gt;&gt; st; int n , m; bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; n = board.size(), m =board[0].size(); st =vector&lt;vector&lt;bool&gt;&gt;(n, vector&lt;bool&gt;(m , false)); for(int i =0; i&lt; n; i++) &#123; for(int j =0; j&lt; m;j ++) &#123; if(dfs(board, i, j , word, 0)) return true; &#125; &#125; return false; &#125; int dx[4] =&#123;-1, 0, 1, 0&#125;, dy[4] =&#123;0, 1, 0, -1&#125;; bool dfs(vector&lt;vector&lt;char&gt;&gt; &amp; board, int x, int y, string &amp; str, int u) &#123; if(board[x][y] != str[u]) return false; if(u ==str.size()-1) // è¿™ä¸ªåªæœ‰åœ¨debug çš„æ—¶å€™æ‰éš¾å¾—åˆ° &#123; return true; &#125; //cout &lt;&lt; x &lt;&lt;" "&lt;&lt; y&lt;&lt; endl; char tmp =board[x][y]; board[x][y] ='#'; //st[x][y] =true; for(int i=0; i&lt; 4; i++) &#123; int a =x +dx[i], b =y +dy[i]; if(a &gt;=0 &amp;&amp; a&lt; board.size() &amp;&amp; b &gt;=0 &amp;&amp; b &lt; board[0].size() &amp;&amp; !st[a][b]) &#123; if(dfs(board, a, b, str, u+1)) return true; &#125; &#125; board[x][y] =tmp; //st[x][y] =false; return false; &#125;&#125;; 105. Construct Binary Tree from Preorder and Inorder Traversal dfs é€’å½’è§£å†³ï¼Œ ä½¿ç”¨hash å­˜å‚¨inorder ä¸­çš„value å’Œindex çš„å…³ç³»ï¼Œæ–¹ä¾¿ä¹‹åŽçš„æŸ¥æ‰¾, åœ¨ $O(1)$ çš„æ—¶é—´å†…æŸ¥æ‰¾åˆ°äº†ã€‚æœ€ç»ˆçš„æ—¶é—´å¤æ‚æ˜¯ $O(n)$.ï¼Œ å› ä¸ºæ¯ä¸ªèŠ‚ç‚¹åªæ˜¯éåŽ†äº†ä¸€éã€‚æ²¡æœ‰é‡å¤çš„æ•°å­—ï¼Œå¾ˆå…³é”®çš„ã€‚ 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // dfs é€’å½’è§£å†³ï¼Œ ä½¿ç”¨hash å­˜å‚¨inorder ä¸­çš„value å’Œindex çš„å…³ç³»ï¼Œæ–¹ä¾¿ä¹‹åŽçš„æŸ¥æ‰¾ã€‚æœ€ç»ˆçš„æ—¶é—´å¤æ‚æ˜¯ O(n) unordered_map&lt;int, int&gt; hash; TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; int n =preorder.size(); for(int i =0; i&lt; n; i++) &#123; hash[inorder[i]] =i; &#125; return dfs(preorder, inorder, 0, n -1, 0, n -1); &#125; TreeNode * dfs(vector&lt;int&gt; preorder, vector&lt;int&gt; inorder, int pl, int pr, int il, int ir) &#123; if(pl &gt; pr) return NULL; int val =preorder[pl]; int index =hash[val]; int len =index -il; TreeNode* root =new TreeNode(val); root -&gt;left = dfs(preorder, inorder, pl +1, pl +len, il, index -1); root -&gt; right =dfs(preorder, inorder, pl +len+1, pr, index +1, ir); return root; &#125;&#125;; 101. Symmetric Tree éœ€è¦æ»¡è¶³ä¸¤ä¸ªæ¡ä»¶ï¼š ä¸¤ä¸ªå­æ ‘æ ¹èŠ‚ç‚¹å€¼ç›¸åŒ å·¦å­æ ‘çš„å·¦å­©å­å’Œå³å­æ ‘çš„å³å­©å­æ˜¯é•œåƒï¼Œ å·¦å­æ ‘çš„å³å­©å­å’Œå³å­æ ‘çš„å·¦å­©å­æ˜¯é•œåƒ å› ä¸ºæ¯ä¸ªèŠ‚ç‚¹åªæ˜¯è¢«éåŽ†ä¸€æ¬¡ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n)$ã€‚ å¯ä»¥ä»Žè¿™ä¸ªè§’åº¦ç†è§£ï¼š æ·±åº¦ä¼˜å…ˆéåŽ†æ•´ä¸ªå­æ ‘ï¼Œæ¯ä¸ªå­æ ‘åªæ˜¯è¢«éåŽ†ä¸€éï¼Œæ‰€ä»¥æ˜¯ $O(n)$ã€‚ 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // å¯¹äºŽdfs ä¸è¦æƒ³ é‚£ä¹ˆå¤šï¼Œåªè¦æƒ³æ¸…æ¥šä¸€å±‚å°± okäº†ï¼Œå¦åˆ™æ˜¯å®¹æ˜“æ··ä¹±çš„ bool isSymmetric(TreeNode* root) &#123; if (!root) return true; return dfs(root -&gt; left, root -&gt; right); &#125; bool dfs(TreeNode* left, TreeNode * right) &#123; if(! left || ! right) return !left&amp;&amp; ! right; // è¿™ç§å†™æ³•æ˜¯éžå¸¸commonçš„ï¼Œåªæœ‰ä¸¤ä¸ªéƒ½ä¸ºç©ºï¼Œé‚£ä¹ˆæ‰è¿”å›ž true if(left-&gt;val != right -&gt; val) return false; return dfs(left-&gt; left, right -&gt; right) &amp;&amp; dfs(left-&gt; right, right-&gt; left); &#125; &#125;; 98. Validate Binary Search Tree æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n)$ï¼Œå› ä¸ºæ¯ä¸ªèŠ‚ç‚¹åªæ˜¯ä¼šè¢«éåŽ†ä¸€æ¬¡ã€‚æ‰€ä»¥å¯¹äºŽè¿™ç±»åˆ¤åˆ«é¢˜ï¼Œæ—¶é—´å¤æ‚åº¦æ²¡æœ‰é‚£ä¹ˆé«˜ã€‚ 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // è¿™é‡Œæœ‰å¾ˆå¤šç»†èŠ‚ï¼Œæ¯”å¦‚è¯´äºŒå‰æœç´ æ ‘çš„å·¦å­æ ‘ä¸¥æ ¼å°äºŽæ ¹èŠ‚ç‚¹ï¼Œå³å­æ ‘ä¸¥æ ¼å¤§äºŽæ ¹èŠ‚ç‚¹ // éœ€è¦æ»¡è¶³ä¸‰ä¸ªæ¡ä»¶ï¼Œ 1. å·¦å­æ ‘å°äºŽæ ¹èŠ‚ç‚¹ï¼Œ2ã€‚å³å­æ ‘å¤§äºŽæ ¹èŠ‚ç‚¹ï¼Œ3.å·¦å³å­æ ‘ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ã€‚ // ä½¿ç”¨åŒºé—´çš„æ¦‚å¿µï¼Œå½“å‰ç»“ç‚¹åœ¨æŸä¸ªåŒºé—´ï¼Œ bool isValidBST(TreeNode* root) &#123; return dfs(root, INT_MIN, INT_MAX); &#125; bool dfs(TreeNode * root, long long min_v, long long max_v) &#123; // å¦‚æžœæ˜¯ç©ºï¼Œé‚£ä¹ˆæ˜¯æ»¡è¶³äºŒå‰æœç´ æ ‘çš„å®šä¹‰çš„ if(! root) return true; if(root-&gt;val &lt; min_v || root -&gt;val &gt;max_v) return false; return dfs(root -&gt;left, min_v, root-&gt;val -1ll) &amp;&amp; dfs(root-&gt;right, root-&gt;val +1ll, max_v); &#125;&#125;; 130. Surrounded Regions æ¯ä¸ªç»“ç‚¹åªæ˜¯è¢«éåŽ†ä¸€æ¬¡ï¼ˆ æœ‰st[a][b] å’Œ board[a][b] è¿›è¡Œè”åˆåˆ¤æ–­ï¼‰ æ‰€ä»¥æ€»çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(mn)$ ã€‚ è¿™ä¸ªä¸€ç§å«åš â€œ(Flood Fill, æ·±åº¦ä¼˜å…ˆéåŽ†) â€œçš„é¢˜ç›® 123456789101112131415161718192021222324252627282930313233343536373839404142 class Solution &#123;public: vector&lt;vector&lt;bool&gt;&gt; st; int n, m ; void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; if(board.empty()) return ; n =board.size(), m =board[0].size(); st =vector&lt;vector&lt;bool&gt;&gt;(n, vector&lt;bool&gt;(m, false)); //cout &lt;&lt; n&lt;&lt; m; // éåŽ†å››å‘¨ for (int i = 0; i &lt; n; i ++ ) &#123; if (board[i][0] == 'O') dfs(i, 0, board); if (board[i][m - 1] == 'O') dfs(i, m - 1, board); &#125; for(int i =0; i&lt; m; i++) &#123; if(board[0][i] =='O') dfs(0, i, board); if(board[n-1][i] =='O') dfs(n-1, i, board); &#125; // æœ€åŽçš„åˆ¤æ–­ for(int i =0; i&lt;n ; i++) &#123; for(int j =0; j&lt; m; j++) &#123; if(!st[i][j]) board[i][j] ='X'; &#125; &#125; &#125; int dx[4] =&#123;-1, 0, 1, 0&#125;, dy[4] =&#123;0, 1, 0, -1&#125;; //è¿™ä¸ªç±»åž‹ä¹Ÿæ˜¯å¾ˆé‡è¦çš„ void dfs(int x, int y, vector&lt;vector&lt;char&gt;&gt; &amp; board) &#123; st[x][y] =true; for(int i =0; i&lt; 4; i++) &#123; int a =x +dx[i], b =y +dy[i]; if(a &gt;=0 &amp;&amp; a&lt;n &amp;&amp; b&gt;=0 &amp;&amp; b&lt;m &amp;&amp; !st[a][b] &amp;&amp; board[a][b] =='O') dfs(a, b, board); &#125; &#125;&#125;; å®½åº¦ä¼˜å…ˆéåŽ† 24. æœºå™¨äººçš„è¿åŠ¨èŒƒå›´ æ—¶é—´åˆ†æž $O(mn)$ï¼Œ æ¯ä¸ªç»“ç‚¹åªæ˜¯å‡ºæ ˆå’Œå…¥æ ˆä¸€æ¬¡ï¼Œæ‰€ä»¥åªéœ€è¦éåŽ†ä¸€æ¬¡ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦å°±æ˜¯ $O(mn)$ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142 class Solution &#123;public: // å®½åº¦ä¼˜å…ˆæœç´¢ï¼Œ bfs()ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ O(mn) å› ä¸ºæ¯ä¸ªæ ¼å­åªæ˜¯éåŽ†ä¸€æ¬¡ // ä½¿ç”¨é˜Ÿåˆ—æ¥ç»´æŠ¤éåŽ†çš„è¿‡ç¨‹ int get_single(int a) &#123; int sum =0; while(a) sum += a%10, a /=10; return sum; &#125; int get_sum(pair&lt;int, int&gt; p) &#123; return get_single(p.first) + get_single(p.second); &#125; int movingCount(int threshold, int rows, int cols) &#123; if( !rows || !cols) return 0; queue&lt;pair&lt;int, int&gt;&gt; q; q.push(&#123;0, 0&#125;); int res =0; vector&lt;vector&lt;bool&gt;&gt; st(rows, vector&lt;bool&gt;(cols, false)); st[0][0] =true; while(q.size()) &#123; auto t =q.front(); q.pop(); if(get_sum(t) &gt; threshold ) continue; res +=1; for(int i =0; i&lt; 4; i++) &#123; int dx[4] =&#123;-1, 0, 1, 0&#125;, dy[4] =&#123;0, 1, 0, -1&#125;; int a = t.first +dx[i], b = t.second+dy[i]; if(a &gt;=0 &amp;&amp; a&lt; rows &amp;&amp; b &gt;=0 &amp;&amp; b &lt; cols &amp;&amp; !st[a][b]) &#123; q.push(&#123;a, b&#125;); st[a][b] =true; &#125; &#125; &#125; return res; &#125;&#125;; ä¸åˆ†è¡Œä»Žä¸Šå¾€ä¸‹æ‰“å°äºŒå‰æ ‘ 123456789101112131415161718192021222324252627282930 /** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // ä¸åˆ†è¡Œæ‰“å°ï¼Œè¿™ä¸ªæ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œåªæ˜¯éœ€è¦ä¸€ä¸ªvector&lt;int&gt; å­˜å‚¨ vector&lt;int&gt; res; // å¯¹äºŽæ ‘æ¥è¯´ï¼Œåªæ˜¯å±‚æ¬¡éåŽ†ï¼Œæ‰€ä»¥ä½¿ç”¨ä¸€ä¸ªé˜Ÿåˆ—å°± ok vector&lt;int&gt; printFromTopToBottom(TreeNode* root) &#123; if( !root) return vector&lt;int&gt;(); queue&lt;TreeNode *&gt; q; q.push(root); while(q.size()) &#123; auto t =q.front(); q.pop(); res.push_back(t-&gt;val); if(t-&gt;left) q.push(t-&gt; left); if(t-&gt; right) q.push(t-&gt; right); &#125; return res; &#125;&#125;; åˆ†è¡Œä»Žä¸Šå¾€ä¸‹æ‰“å°äºŒå‰æ ‘ æ—¶é—´å¤æ‚åº¦æ˜¯ç»“ç‚¹çš„ä¸ªæ•° $O(n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // ä½¿ç”¨ nullptr æ¥æ ‡è®°æŸä¸€è¡Œçš„ç»“æŸ, åŠ å…¥çš„æ—¶å€™ä¹Ÿæ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œå¦‚æžœä¸æ˜¯null é‚£ä¹ˆå°±å’Œä¸Šä¸€é“é¢˜ç›®ä¸€æ · // å¦‚æžœæ˜¯nullptr é‚£ä¹ˆåŠ å…¥çš„è¿˜æ˜¯nullptr vector&lt;vector&lt;int&gt;&gt; printFromTopToBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(! root) return res; // è¿™ä¸ªæ˜¯ä¸´æ—¶å­˜å‚¨ç»“æžœçš„ vector&lt;int&gt; level; queue&lt;TreeNode*&gt; q; q.push(root); q.push(nullptr); while(q.size()) &#123; auto t =q.front(); q.pop(); if(t) &#123; level.push_back(t-&gt; val); if(t-&gt;left) q.push(t-&gt; left); if(t-&gt; right) q.push(t-&gt; right); &#125; else &#123; if(level.empty()) break; // è¿™ä¸ªæ¡ä»¶å¾ˆé‡è¦ï¼Œå› ä¸ºæœ‰ç©ºæŒ‡é’ˆï¼Œç„¶åŽè¿™ä¸ªä¼šé™·å…¥æ­»å¾ªçŽ¯ res.push_back(level); level.clear(); q.push(nullptr); &#125; &#125; return res; &#125;&#125;; ä¹‹å­—å½¢æ‰“å°äºŒå‰æ ‘ 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // åœ¨åˆ†å±‚éåŽ†çš„åŸºç¡€ä¸Šï¼ŒåŠ å…¥ä¸€ä¸ªflag è¡¨ç¤ºå¥‡æ•°å±‚å’Œå¶æ•°å±‚ vector&lt;vector&lt;int&gt;&gt; printFromTopToBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(! root) return res; vector&lt;int&gt; level; queue&lt;TreeNode *&gt; q; q.push(root); q.push(nullptr); bool st =false; while(q.size()) &#123; auto t =q.front(); q.pop(); if(t) &#123; level.push_back(t-&gt; val); if(t-&gt; left) q.push(t-&gt;left); if(t-&gt; right) q.push(t-&gt;right); &#125; else &#123; if(level.empty()) break; if(st) reverse(level.begin(), level.end()); st =! st; res.push_back(level); level.clear(); q.push(nullptr); &#125; &#125; return res; &#125;&#125;; Binary Tree Level Order Traversal II 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: //å…ˆæ˜¯ åˆ†å±‚çš„å±‚åºéåŽ†ï¼Œç„¶åŽæ˜¯reverseä¸€ä¸‹, å¦‚æžœæ˜¯ äºŒç»´æ•°ç»„ï¼Œé‚£ä¹ˆreverse() æ˜¯å¯¹ è¡Œè¿›è¡Œçš„reverse() ï¼Œæ˜¯æ¯”è¾ƒç®€å•çš„ã€‚ vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(!root) return res; vector&lt;int&gt; level; queue&lt;TreeNode *&gt; q; q.push(root); q.push(nullptr); while(q.size()) &#123; auto t =q.front(); q.pop(); if(t) &#123; level.push_back(t-&gt; val); if(t-&gt; left) q.push(t-&gt;left); if(t-&gt; right) q.push(t-&gt;right); &#125; else &#123; if(level.empty()) break; res.push_back(level); level.clear(); q.push(nullptr); &#125; &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;; Populating Next Right Pointers in Each æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n)$ï¼Œn è¡¨ç¤ºç»“ç‚¹çš„ä¸ªæ•°ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041/*// Definition for a Node.class Node &#123;public: int val; Node* left; Node* right; Node* next; Node() &#123;&#125; Node(int _val, Node* _left, Node* _right, Node* _next) &#123; val = _val; left = _left; right = _right; next = _next; &#125;&#125;;*/class Solution &#123;public: // è¿™ä¸ªæ˜¯ perfect äºŒå‰æ ‘, å±‚ä¸Žå±‚ä¹‹é—´çš„éåŽ†æ˜¯ root-&gt;left, // ä¸€å±‚ä¹‹é—´çš„éåŽ†æ˜¯ root = root-&gt;next ï¼Œè¿™æ ·è¿›è¡ŒéåŽ† Node* connect(Node* root) &#123; Node* p= root, *cur; // éåŽ†åˆ°éžå¶å­ç»“ç‚¹ while(p) &#123; cur =p; // åªæ˜¯åœ¨ä¸€å±‚ä¸Šè¿›è¡ŒéåŽ† while(cur &amp;&amp; cur-&gt;left) &#123; cur-&gt;left-&gt;next =cur-&gt;right; if(cur-&gt;next) cur-&gt;right -&gt;next =cur-&gt;next -&gt;left; cur =cur -&gt;next; // ä¸æ–­çš„å¾€ä¸‹èµ° &#125; p =p-&gt;left; &#125; return root; &#125;&#125;; è§£æ³•äºŒï¼šä½¿ç”¨ä¸€ä¸ªé˜Ÿåˆ— 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*// Definition for a Node.class Node &#123;public: int val; Node* left; Node* right; Node* next; Node() &#123;&#125; Node(int _val, Node* _left, Node* _right, Node* _next) &#123; val = _val; left = _left; right = _right; next = _next; &#125;&#125;;*/class Solution &#123;public: Node* connect(Node* root) &#123; if(! root) return root; queue&lt;Node *&gt; q; q.push(root); q.push(nullptr); while(q.size()) &#123; auto t =q.front(); q.pop(); if(t) &#123; t-&gt;next =q.front(); if(t-&gt;left) q.push(t-&gt;left); if(t-&gt;right) q.push(t-&gt;right); &#125; else &#123; if(q.size() &gt;0) q.push(nullptr); &#125; &#125; return root; &#125;&#125;; Populating Next Right Pointers in Each Node II æ—¶é—´å¤æ‚ æ˜¯$O(n)$ ï¼Œä½†æ˜¯å’Œä¸Šä¸€é“é¢˜ç›®ä¸ä¸€æ ·çš„æ˜¯ï¼Œè¿™ä¸ªæ˜¯éž Perfect treeï¼Œæ‰€ä»¥ä¸‡èƒ½çš„å±‚åºéåŽ†ã€‚è¿™ä¸ªæ˜¯å¯ä»¥ä½œä¸ºä¸€ä¸ªæ¨¡æ¿çš„ã€‚è¿™ä¸ªæ¨¡æ¿æ˜¯å¤„ç†åˆ†è¡Œçš„å±‚æ¬¡éåŽ†ã€‚ä½¿ç”¨$O(n)$ çš„æ—¶é—´å¤æ‚åº¦ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243/*// Definition for a Node.class Node &#123;public: int val; Node* left; Node* right; Node* next; Node() &#123;&#125; Node(int _val, Node* _left, Node* _right, Node* _next) &#123; val = _val; left = _left; right = _right; next = _next; &#125;&#125;;*/class Solution &#123;public: Node* connect(Node* root) &#123; if(!root) return root; queue&lt;Node *&gt; q; q.push(root); q.push(nullptr); while(q.size()) &#123; auto t =q.front(); q.pop(); if(t) &#123; t-&gt;next =q.front(); if(t-&gt;left) q.push(t-&gt;left); if(t-&gt;right) q.push(t-&gt;right); &#125; else&#123; if(q.size()&gt; 0) q.push(nullptr); &#125; &#125; return root; &#125;&#125;; çŸ©é˜µè·ç¦» æ—¶é—´å¤æ‚åº¦çš„åˆ†æžï¼Œæ˜¯$O(n^2)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int N =1010;int n,m;char a[N][N];int d[N][N];typedef pair&lt;int, int&gt; PAIR;void dfs()&#123; memset(d, -1, sizeof d); queue&lt;PAIR&gt; q; for(int i =0 ; i&lt; n; i++) for(int j =0; j&lt; m; j++) if(a[i][j] =='1') &#123; d[i][j] =0; q.push(&#123;i, j&#125;); &#125; while(q.size()) &#123; auto t =q.front(); q.pop(); int dx[4]=&#123;-1, 0, 1, 0&#125;, dy[4] =&#123;0, 1, 0, -1&#125;; int x =t.first, y =t.second; for(int i =0; i&lt; 4; i++) &#123; int a =x +dx[i], b =y +dy[i]; if( a&gt;=0 &amp;&amp; a&lt; n &amp;&amp; b&gt;=0 &amp;&amp; b &lt; m &amp;&amp; d[a][b] == -1) &#123; q.push(&#123;a, b&#125;); d[a][b] = d[x][ y] +1; // è¿™ä¸ªèƒ½ä½“çŽ°å±‚æ¬¡éåŽ†çš„è¿‡ç¨‹ &#125; &#125; &#125;&#125;int main()&#123; // è¿™ä¸ªè¯»å…¥çš„æ—¶å€™ç«Ÿç„¶æ²¡æœ‰ç©ºæ ¼ï¼Œæ‰€ä»¥éœ€è¦ä½¿ç”¨å­—ç¬¦ä¸²è¿›è¡Œå…¥ scanf("%d %d", &amp;n, &amp;m); for(int i =0; i&lt; n; i++) scanf("%s", a[i]); dfs(); for(int i =0; i&lt; n; i++) &#123; for(int j =0; j&lt; m; j++) printf("%d ", d[i][j]); puts(""); &#125; return 0;&#125; Dijkstra ç®—æ³• æ±‚è§£æœ€çŸ­è·¯å¾„çš„ä¸€ç±»ç®—æ³•ã€‚ç¨ å¯†å›¾ï¼ˆè¾¹å¾ˆå¤šï¼‰ï¼Œç¨€ç–å›¾ï¼ˆè¾¹å¾ˆå°‘ï¼‰ã€‚æœ‰å‘å›¾å’Œæ— å‘å›¾ã€‚ç”¨åˆ°è´ªå¿ƒçš„ç­–ç•¥ï¼Œä»Žä¸€ç‚¹åˆ°å…¶ä»–ç‚¹çš„è·ç¦»ã€‚ å¯ä»¥å¤„ç†æœ‰å‘å›¾å’Œæ— çº¿å›¾ æƒå€¼ä¸èƒ½ä¸ºè´Ÿæ•°]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[write down now]]></title>
    <url>%2F2019%2F08%2F17%2FwriteDownNow%2F</url>
    <content type="text"><![CDATA[ä¸´æ—¶æ–‡ä»¶å¤¹ï¼Œå­˜æ”¾æœªæˆç³»ç»Ÿçš„çŸ¥è¯†ç‚¹ã€‚ å¿«é€Ÿå‚…é‡Œå¶å˜æ¢ï¼ˆFast Fourier Transformï¼‰åœ¨ç®—æ³•ç«žèµ›ä¸­çš„è¿ç”¨ä¸»è¦æ˜¯ç”¨æ¥åŠ é€Ÿå¤šé¡¹å¼çš„ä¹˜æ³•ã€‚å¿«é€Ÿå‚…é‡Œå¶å˜æ¢ï¼ˆFast Fourier Transformï¼ŒFFTï¼‰æ˜¯ä¸€ç§å¯åœ¨ $O(nlogn)$æ—¶é—´å†…å®Œæˆçš„ç¦»æ•£å‚…é‡Œå¶å˜æ¢ï¼ˆDiscrete Fourier transformï¼ŒDFTï¼‰ç®—æ³•ã€‚ å¤šé¡¹å¼è¡¨ç¤ºçš„ä¸¤ç§æ–¹æ³• ç³»æ•°è¡¨è¾¾æ³•$$f(x)=a_{0}+a_{1} x^{1}+a_{2} x^{2}+\ldots+a_{n} x^{n}$$ ç‚¹å€¼è¡¨è¾¾æ³• $$f(x) ={(x_{0}, y_{0}),(x_{1}, y_{1}),(x_{2}, y_{2}), \ldots,(x_{n-1}, y_{n-1})}$$ FFT ä¸­çš„æ­¥éª¤ï¼Œé¦–å…ˆæ˜¯ç‚¹å€¼è¡¨è¾¾æ³•ç›¸ä¹˜( ç®—æ³•å¤æ‚åº¦æ˜¯ $O(n) $)ï¼Œç„¶åŽæ˜¯ç³»æ•°è¡¨è¾¾æ³• å’Œ ç‚¹å€¼è¡¨è¾¾æ³•çš„è½¬æ¢ï¼Œæ™®é€šçš„æ–¹æ³•æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n^2)$ ä½†æ˜¯FFTæ˜¯å¯ä»¥ä¼˜åŒ–æˆ $nlogn$ HMMé¢‘çŽ‡æ´¾-&gt; ç»Ÿè®¡æœºå™¨å­¦ä¹  -&gt; ä¼˜åŒ–é—®é¢˜ (model strategy algorirthm) è´å¶æ–¯æ´¾ -&gt; æ¦‚çŽ‡å›¾æ¨¡åž‹ -&gt; åŽéªŒæ¦‚çŽ‡-&gt; ç§¯åˆ†é—®é¢˜ éšé©¬å°”ç§‘å¤«æ¨¡åž‹æ·±åº¦å­¦ä¹ æ²¡æœ‰ç«èµ·æ¥ä¹‹å‰ï¼Œ åœ¨NLP é¢†åŸŸéžå¸¸æµè¡Œçš„ä¸€ä¸ªæ¨¡åž‹ã€‚æ•ˆæžœæ˜¯ä¸é”™çš„ï¼Œä½†æ˜¯æ—¶é—´å¤æ‚åº¦æ˜¯ O(n^3), é€‚åˆå­¦ä¹ çš„ï¼Œä½†æ˜¯ä¸é€‚åˆå¤„ç†æµ·é‡çš„æ•°æ®ã€‚ dynamic model æ˜¯ æ—¶é—´åºåˆ—ï¼Œæ ·æœ¬ä¸æ˜¯ç‹¬ç«‹åŒåˆ†å¸ƒï¼Œé«˜æ–¯æ··åˆæ¨¡åž‹æ˜¯ç‹¬ç«‹åŒåˆ†å¸ƒçš„ å¢žé‡å­¦ä¹  å¢žé‡å­¦ä¹ (Incremental Learning)æ˜¯æŒ‡ä¸€ä¸ªå­¦ä¹ ç³»ç»Ÿèƒ½ä¸æ–­åœ°ä»Žæ–°æ ·æœ¬ä¸­å­¦ä¹ æ–°çš„çŸ¥è¯†ï¼Œå¹¶èƒ½ä¿å­˜å¤§éƒ¨åˆ†ä»¥å‰å·²ç»å­¦ä¹ åˆ°çš„çŸ¥è¯†ã€‚å¢žé‡å­¦ä¹ éžå¸¸ç±»ä¼¼äºŽäººç±»è‡ªèº«çš„å­¦ä¹ æ¨¡å¼ã€‚ ä½¿ç”¨çš„åœºæ™¯ï¼š æ•°æ®åº“éžå¸¸å¤§çš„æƒ…å½¢,ä¾‹å¦‚Webæ—¥å¿—è®°å½• æµæ•°æ®,å› ä¸ºè¿™äº›æ•°æ®éšç€æ—¶é—´åœ¨ä¸æ–­çš„å˜åŒ–,ä¾‹å¦‚è‚¡ç¥¨äº¤æ˜“æ•°æ®. çŽ°æœ‰çš„å¢žé‡å­¦ä¹ ç®—æ³•å¤§å¤šé‡‡ç”¨å†³ç­–æ ‘å’Œç¥žç»ç½‘ç»œç®—æ³•å®žçŽ°çš„ äº¤å‰éªŒè¯ï¼Œé€‰æ‹©ä¸€å®šæ•°é‡ï¼ˆ10ä¸ªï¼‰çš„æ ·æœ¬ä½œä¸º test æ•°æ®é›†ï¼Œç„¶åŽå†è®­ç»ƒæ•°æ®é›†ä¸­ä¸å‡ºçŽ°ï¼Œä½œä¸ºä¸€æ¬¡æ¨¡åž‹çš„è®­ç»ƒã€‚ ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ä¹Ÿæ˜¯å¯ä»¥åˆ‡åˆ†å¥å­ï¼Œç„¶åŽå½¢æˆåˆ†è¯çš„ï¼ˆè¿™ä¸ªåœ¨è‹±æ–‡ä¸­æ›´åŠ æ˜Žæ˜¾ï¼‰ ç¬”è¯•é¢˜å›¾åƒé¢†åŸŸä¸­çš„æ•°æ®å¢žå¼º? ä¸€ç§æ˜¯æ”¶é›†æ›´å¤šçš„æ•°æ®ï¼Œä¸€ç§æ˜¯æ ¹æ®çŽ°æœ‰çš„æ•°æ®è¿›è¡Œå¢žå¼ºã€‚æ•°æ®å¢žå¼ºï¼Œå¸¸ç”¨çš„æ–¹å¼ï¼Œå°±æ˜¯æ—‹è½¬å›¾åƒï¼Œå‰ªåˆ‡å›¾åƒï¼Œæ”¹å˜å›¾åƒè‰²å·®,æ‰­æ›²å›¾åƒç‰¹å¾ï¼Œæ”¹å˜å›¾åƒå°ºå¯¸å¤§å°ï¼Œå¢žå¼ºå›¾åƒå™ªéŸ³ï¼ˆä¸€èˆ¬ä½¿ç”¨é«˜æ–¯å™ªéŸ³ï¼Œç›æ¤’å™ªéŸ³ï¼‰ç­‰. é€»è¾‘å›žå½’çš„ç›®æ ‡å‡½æ•°ï¼šlog ä¼¼ç„¶å‡½æ•°$ p(y)$ï¼Œ å…ˆéªŒæ¦‚çŽ‡ï¼šä¸€ä¸ªäº‹ä»¶å‘ç”Ÿçš„æ¦‚çŽ‡$ p(y|x) $ï¼ŒåŽéªŒæ¦‚çŽ‡ï¼šä¸€ä¸ªäº‹ä»¶åœ¨å¦ä¸€ä¸ªäº‹ä»¶å‘ç”Ÿæ¡ä»¶ä¸‹çš„æ¡ä»¶æ¦‚çŽ‡ è®¡ç®—ä¸‰ä¸ªç¨ å¯†çŸ©é˜µ Aã€Bã€C çš„ä¹˜ç§¯ ABCï¼Œå‡å®šä¸‰ä¸ªçŸ©é˜µçš„å°ºå¯¸åˆ†åˆ«ä¸º $m \times n $, $n \times p $, $p \times q$ï¼Œä¸” $m&lt;n&lt;p&lt;q $,ä»¥ä¸‹è®¡ç®—æ•ˆçŽ‡æœ€é«˜çš„æ˜¯è§£é‡Šï¼š$a \times b$ çŸ©é˜µå’Œ$ b \times c $çŸ©é˜µç›¸ä¹˜ï¼Œæ¯æ¬¡è¡Œä¹˜åˆ—è¿ç®—éœ€è¦ b æ¬¡ä¹˜æ³•å’Œ b-1 æ¬¡åŠ æ³•ï¼Œå³æ€»å…±éœ€è¦ $(2b-1) \times a \times c $ æ¬¡è¿ç®—ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º$ O(a \times b \times c) $1.AB çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(m \times n \times p)$ ï¼Œæ­¤æ—¶å½¢æˆ $m \times p$ çš„æ–°çŸ©é˜µ2.(AB)C çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(m \times p \times q) $ ç»“è®ºï¼šé¦–å…ˆä½¿è¾ƒå°çš„çŸ©é˜µç›¸ä¹˜ï¼Œæœ€åŽä¹˜è¾ƒå¤§çš„çŸ©é˜µå¯ä»¥å‡å°‘è¿ç®—é‡ã€‚ ä¸‹åˆ—å“ªäº›é¡¹æ‰€æè¿°çš„ç›¸å…³æŠ€æœ¯æ˜¯å¯¹çš„ï¼ŸA AdaGradå’ŒL-BFGSä½¿ç”¨çš„éƒ½æ˜¯ä¸€é˜¶å·®åˆ†B AdaGradå’ŒL-BFGSä½¿ç”¨çš„éƒ½æ˜¯äºŒé˜¶å·®åˆ†C Adagradä½¿ç”¨çš„æ˜¯ä¸€é˜¶å·®åˆ†ï¼ŒL-BFGSä½¿ç”¨çš„æ˜¯äºŒé˜¶å·®åˆ†D Adagradä½¿ç”¨çš„æ˜¯äºŒé˜¶å·®åˆ†ï¼ŒL-BFGSä½¿ç”¨çš„æ˜¯ä¸€é˜¶å·®åˆ†ç­”æ¡ˆï¼š C ç‰›é¡¿æ³•ä¸ä»…ä½¿ç”¨äº†ä¸€é˜¶å¯¼ä¿¡æ¯ï¼ŒåŒæ—¶è¿˜åˆ©ç”¨äº†äºŒé˜¶å¯¼æ¥æ›´æ–°å‚æ•°,L-BFGSç®—æ³•æ˜¯ä¸€ç§åœ¨ç‰›é¡¿æ³•åŸºç¡€ä¸Šæå‡ºçš„ä¸€ç§æ±‚è§£å‡½æ•°æ ¹çš„ç®—æ³• å¯¹äºŽä¸€ä¸ªåˆ†ç±»ä»»åŠ¡ï¼Œå¦‚æžœå¼€å§‹æ—¶ç¥žç»ç½‘ç»œçš„æƒé‡ä¸æ˜¯éšæœºèµ‹å€¼çš„ï¼ŒäºŒæ˜¯éƒ½è®¾æˆ0ï¼Œä¸‹é¢å“ªä¸ªå™è¿°æ˜¯æ­£ç¡®çš„ï¼Ÿï¼ˆCï¼‰C ç¥žç»ç½‘ç»œå¯ä»¥è®­ç»ƒï¼Œä½†æ˜¯æ‰€æœ‰çš„ç¥žç»å…ƒæœ€åŽéƒ½ä¼šå˜æˆè¯†åˆ«åŒæ ·çš„ä¸œè¥¿ä»¤æ‰€æœ‰æƒé‡éƒ½åˆå§‹åŒ–ä¸º0è¿™ä¸ªä¸€ä¸ªå¬èµ·æ¥è¿˜è›®åˆç†çš„æƒ³æ³•ä¹Ÿè®¸æ˜¯ä¸€ä¸ªæˆ‘ä»¬å‡è®¾ä¸­æœ€å¥½çš„ä¸€ä¸ªå‡è®¾äº†, ä½†ç»“æžœæ˜¯é”™è¯¯çš„ï¼Œå› ä¸ºå¦‚æžœç¥žç»ç½‘ç»œè®¡ç®—å‡ºæ¥çš„è¾“å‡ºå€¼éƒ½ä¸€ä¸ªæ ·ï¼Œé‚£ä¹ˆåå‘ä¼ æ’­ç®—æ³•è®¡ç®—å‡ºæ¥çš„æ¢¯åº¦å€¼ä¸€æ ·ï¼Œå¹¶ä¸”å‚æ•°æ›´æ–°å€¼ä¹Ÿä¸€æ ·( $w=wâˆ’Î±âˆ—dw $)ã€‚æ›´ä¸€èˆ¬åœ°è¯´ï¼Œå¦‚æžœæƒé‡åˆå§‹åŒ–ä¸ºåŒä¸€ä¸ªå€¼ï¼Œç½‘ç»œå³æ˜¯å¯¹ç§°çš„, æœ€ç»ˆæ‰€æœ‰çš„ç¥žç»å…ƒæœ€åŽéƒ½ä¼šå˜æˆè¯†åˆ«åŒæ ·çš„ä¸œè¥¿ã€‚ pca ä¹‹å‰æ˜¯éœ€è¦è¿›è¡Œæ­£åˆ™åŒ–ï¼Œç„¶åŽæ±‚è§£ baggingï¼ˆrandom forest æ˜¯å…¶çš„ä¸€ç§ç‰¹ä¾‹ï¼Œé˜²æ­¢è¿‡æ‹Ÿåˆçš„æ‰‹æ®µï¼‰bagging ä¸­çš„bag æ˜¯è¢‹å­çš„æ„æ€ï¼Œæœ‰ç‚¹é€šè¿‡ random ç„¶åŽå¾—åˆ°ä¸€å †ä¸œè¥¿ï¼Œè¿™ä¸ªæ˜¯å¯ä»¥é˜²æ­¢è¿‡æ‹Ÿåˆçš„stacking (stack æ˜¯å † çš„æ„æ€)ï¼Œè¿™é‡Œä»¥è®ºæ–‡å®¡ç¨¿ä¸ºä¾‹ï¼Œé¦–å…ˆæ˜¯ä¸‰ä¸ªå®¡ç¨¿äººåˆ†åˆ«å¯¹è®ºæ–‡è¿›è¡Œå®¡ç¨¿ï¼Œç„¶åŽåˆ†åˆ«è¿”å›žå®¡ç¨¿æ„è§ç»™æ€»ç¼–è¾‘ï¼Œæ€»ç¼–è¾‘ä¼šç»“åˆå®¡ç¨¿äººçš„æ„è§ç»™å‡ºæœ€ç»ˆçš„åˆ¤æ–­ï¼Œå³æ˜¯å¦å½•ç”¨ã€‚å¯¹åº”äºŽstackingï¼Œè¿™é‡Œçš„ä¸‰ä¸ªå®¡ç¨¿äººå°±æ˜¯ç¬¬ä¸€å±‚çš„æ¨¡åž‹ï¼Œå…¶è¾“å‡ºï¼ˆå®¡ç¨¿äººæ„è§ï¼‰ä¼šä½œä¸ºç¬¬äºŒå±‚æ¨¡åž‹ï¼ˆæ€»ç¼–è¾‘ï¼‰çš„è¾“å…¥ï¼Œç„¶åŽç¬¬äºŒå±‚æ¨¡åž‹ä¼šç»™å‡ºæœ€ç»ˆçš„ç»“æžœã€‚boosting ç®—æ³•ï¼ˆgbdtã€adaboost å’Œ xgboostï¼‰ BN ç®—æ³•ï¼šåœ¨å°†æ‰€æœ‰çš„è¾“å…¥ä¼ é€’åˆ°ä¸‹ä¸€å±‚ä¹‹å‰å¯¹å…¶è¿›è¡Œå½’ä¸€åŒ–ï¼ˆæ›´æ”¹ï¼‰ ä»¥ä¸‹()å±žäºŽçº¿æ€§åˆ†ç±»å™¨æœ€ä½³å‡†åˆ™ï¼Ÿæœºå™¨å­¦ä¹  MLæ¨¡åž‹ æ˜“A.æ„ŸçŸ¥å‡†åˆ™å‡½æ•°B.è´å¶æ–¯åˆ†ç±»C.æ”¯æŒå‘é‡æœºD.Fisherå‡†åˆ™æ­£ç¡®ç­”æ¡ˆï¼šACDçº¿æ€§åˆ†ç±»å™¨æœ‰ä¸‰å¤§ç±»ï¼šæ„ŸçŸ¥å™¨å‡†åˆ™å‡½æ•°ã€SVMã€Fisherå‡†åˆ™ï¼Œè€Œè´å¶æ–¯åˆ†ç±»å™¨ä¸æ˜¯çº¿æ€§åˆ†ç±»å™¨ã€‚ æ„ŸçŸ¥å‡†åˆ™å‡½æ•° ï¼šå‡†åˆ™å‡½æ•°ä»¥ä½¿é”™åˆ†ç±»æ ·æœ¬åˆ°åˆ†ç•Œé¢è·ç¦»ä¹‹å’Œæœ€å°ä¸ºåŽŸåˆ™ã€‚å…¶ä¼˜ç‚¹æ˜¯é€šè¿‡é”™åˆ†ç±»æ ·æœ¬æä¾›çš„ä¿¡æ¯å¯¹åˆ†ç±»å™¨å‡½æ•°è¿›è¡Œä¿®æ­£ï¼Œè¿™ç§å‡†åˆ™æ˜¯äººå·¥ç¥žç»å…ƒç½‘ç»œå¤šå±‚æ„ŸçŸ¥å™¨çš„åŸºç¡€ã€‚ æ”¯æŒå‘é‡æœº ï¼šåŸºæœ¬æ€æƒ³æ˜¯åœ¨ä¸¤ç±»çº¿æ€§å¯åˆ†æ¡ä»¶ä¸‹ï¼Œæ‰€è®¾è®¡çš„åˆ†ç±»å™¨ç•Œé¢ä½¿ä¸¤ç±»ä¹‹é—´çš„é—´éš”ä¸ºæœ€å¤§ï¼Œå®ƒçš„åŸºæœ¬å‡ºå‘ç‚¹æ˜¯ä½¿æœŸæœ›æ³›åŒ–é£Žé™©å°½å¯èƒ½å°ã€‚ï¼ˆä½¿ç”¨æ ¸å‡½æ•°å¯è§£å†³éžçº¿æ€§é—®é¢˜ï¼‰ Fisher å‡†åˆ™ ï¼šæ›´å¹¿æ³›çš„ç§°å‘¼æ˜¯çº¿æ€§åˆ¤åˆ«åˆ†æžï¼ˆLDAï¼‰ï¼Œå°†æ‰€æœ‰æ ·æœ¬æŠ•å½±åˆ°ä¸€æ¡è¿œç‚¹å‡ºå‘çš„ç›´çº¿ï¼Œä½¿å¾—åŒç±»æ ·æœ¬è·ç¦»å°½å¯èƒ½å°ï¼Œä¸åŒç±»æ ·æœ¬è·ç¦»å°½å¯èƒ½å¤§ï¼Œå…·ä½“ä¸ºæœ€å¤§åŒ–â€œå¹¿ä¹‰ç‘žåˆ©å•†â€ã€‚æ ¹æ®ä¸¤ç±»æ ·æœ¬ä¸€èˆ¬ç±»å†…å¯†é›†ï¼Œç±»é—´åˆ†ç¦»çš„ç‰¹ç‚¹ï¼Œå¯»æ‰¾çº¿æ€§åˆ†ç±»å™¨æœ€ä½³çš„æ³•çº¿å‘é‡æ–¹å‘ï¼Œä½¿ä¸¤ç±»æ ·æœ¬åœ¨è¯¥æ–¹å‘ä¸Šçš„æŠ•å½±æ»¡è¶³ç±»å†…å°½å¯èƒ½å¯†é›†ï¼Œç±»é—´å°½å¯èƒ½åˆ†å¼€ã€‚è¿™ç§åº¦é‡é€šè¿‡ç±»å†…ç¦»æ•£çŸ©é˜µ Sw å’Œç±»é—´ç¦»æ•£çŸ©é˜µ Sb å®žçŽ°ã€‚ ä»¥ä¸‹è¯´æ³•ä¸­æ­£ç¡®çš„æ˜¯() æœºå™¨å­¦ä¹  MLæ¨¡åž‹ ä¸­A.SVMå¯¹å™ªå£°(å¦‚æ¥è‡ªå…¶ä»–åˆ†å¸ƒçš„å™ªå£°æ ·æœ¬)é²æ£’B.åœ¨AdaBoostç®—æ³•ä¸­,æ‰€æœ‰è¢«åˆ†é”™çš„æ ·æœ¬çš„æƒé‡æ›´æ–°æ¯”ä¾‹ç›¸åŒC.Boostingå’ŒBaggingéƒ½æ˜¯ç»„åˆå¤šä¸ªåˆ†ç±»å™¨æŠ•ç¥¨çš„æ–¹æ³•,äºŒéƒ½æ˜¯æ ¹æ®å•ä¸ªåˆ†ç±»å™¨çš„æ­£ç¡®çŽ‡å†³å®šå…¶æƒé‡D.ç»™å®šnä¸ªæ•°æ®ç‚¹,å¦‚æžœå…¶ä¸­ä¸€åŠç”¨äºŽè®­ç»ƒ,ä¸€èˆ¬ç”¨äºŽæµ‹è¯•,åˆ™è®­ç»ƒè¯¯å·®å’Œæµ‹è¯•è¯¯å·®ä¹‹é—´çš„å·®åˆ«ä¼šéšç€nçš„å¢žåŠ è€Œå‡å°‘è§£é‡Šï¼šA. SVMè§£å†³çš„æ˜¯ç»“æž„é£Žé™©æœ€å°, ç»éªŒé£Žé™©å¤„ç†è¾ƒå¼±, æ‰€ä»¥å¯¹æ•°æ®å™ªå£°æ•æ„Ÿ. (åŸºäºŽæ ‘çš„ç»“æž„gbdt å¯¹äºŽå™ªå£°æ˜¯å…·æœ‰é²æ£’æ€§çš„ï¼ŒSVM åœ¨æ²¡æœ‰å™ªå£°çš„æ•°æ®ä¸‹æ•ˆæžœæ›´å¥½) B. AdaBoostç®—æ³•ä¸­, æ¯ä¸ªè¿­ä»£è®­ç»ƒä¸€ä¸ªå­¦ä¹ å™¨å¹¶æŒ‰å…¶è¯¯åˆ†ç±»çŽ‡å¾—åˆ°è¯¥å­¦ä¹ å™¨çš„æƒé‡alpha, è¿™ä¸ªå­¦ä¹ å™¨çš„æƒé‡ç®—å‡ºä¸¤ä¸ªæ›´æ–°æ¯”ä¾‹åŽ»ä¿®æ­£å…¨éƒ¨æ ·æœ¬çš„æƒé‡: æ­£æ ·æœ¬æ˜¯exp(-alpha), è´Ÿæ ·æœ¬æ˜¯exp(alpha). æ‰€ä»¥æ‰€æœ‰è¢«åˆ†é”™çš„æ ·æœ¬çš„æƒé‡æ›´æ–°æ¯”ä¾‹ç›¸åŒ. C. baggingçš„å­¦ä¹ å™¨ä¹‹é—´æ— æƒé‡ä¸åŒ, ç®€å•å–æŠ•ç¥¨ç»“æžœ; Boostingçš„adaboostæ ¹æ®è¯¯åˆ†ç±»çŽ‡å†³å®šæƒé‡, boostingçš„gbdtåˆ™æ˜¯å›ºå®šå°æƒé‡(ä¹Ÿç§°å­¦ä¹ çŽ‡), ç”¨é€¼è¿‘ä¼ªæ®‹å·®å‡½æ•°æœ¬èº«ä»£æ›¿æƒé‡. D: æ ¹æ®ä¸­å¿ƒæžé™å®šå¾‹, éšç€nçš„å¢žåŠ , è®­ç»ƒè¯¯å·®å’Œæµ‹è¯•è¯¯å·®ä¹‹é—´çš„å·®åˆ«å¿…ç„¶å‡å°‘ â€“ è¿™å°±æ˜¯å¤§æ•°æ®è®­ç»ƒçš„ç”±æ¥ å…³äºŽæ”¯æŒå‘é‡æœºSVM,ä¸‹åˆ—è¯´æ³•é”™è¯¯çš„æ˜¯ï¼ˆï¼‰A.L2æ­£åˆ™é¡¹ï¼Œä½œç”¨æ˜¯æœ€å¤§åŒ–åˆ†ç±»é—´éš”ï¼Œä½¿å¾—åˆ†ç±»å™¨æ‹¥æœ‰æ›´å¼ºçš„æ³›åŒ–èƒ½åŠ›B.Hinge æŸå¤±å‡½æ•°ï¼Œä½œç”¨æ˜¯æœ€å°åŒ–ç»éªŒåˆ†ç±»é”™è¯¯C.åˆ†ç±»é—´éš”ä¸º1/||w||ï¼Œ||w||ä»£è¡¨å‘é‡çš„æ¨¡D.å½“å‚æ•°Cè¶Šå°æ—¶ï¼Œåˆ†ç±»é—´éš”è¶Šå¤§ï¼Œåˆ†ç±»é”™è¯¯è¶Šå¤šï¼Œè¶‹äºŽæ¬ å­¦ä¹  Cé”™è¯¯ã€‚é—´éš”åº”è¯¥æ˜¯2/||w||æ‰å¯¹ï¼ŒåŽåŠå¥åº”è¯¥æ²¡é”™ï¼Œå‘é‡çš„æ¨¡é€šå¸¸æŒ‡çš„å°±æ˜¯å…¶äºŒèŒƒæ•°ã€‚ï¼ˆæ ¹æ®ä¸¤ä¾§çš„è·ç¦»ï¼‰ SVM åˆ†ç±»å’Œæ·±åº¦å­¦ä¹ é€»è¾‘å›žå½’åˆ†ç±»çš„åŒºåˆ«é€»è¾‘å›žå½’æ˜¯çº¿æ€§åˆ†ç±»ï¼ŒSVM å¯ä»¥åº”ç”¨äºŽçº¿æ€§åˆ†ç±»å’Œéžçº¿æ€§åˆ†ç±»é—®é¢˜ï¼Œå–å†³äºŽæ ¸å‡½æ•°çš„é€‰å–ã€‚ SVM æ˜¯å‡¸é—®é¢˜ï¼Œæ·±åº¦å­¦ä¹ éƒ½æ˜¯éžå‡¸é—®é¢˜æ­£ç¡®ï¼Œæ·±åº¦å­¦ä¹ ç®—æ³•çš„ç›®æ ‡å‡½æ•°ï¼Œå‡ ä¹Žå…¨éƒ½æ˜¯éžå‡¸çš„ã€‚ ç¬”è¯•é¢è¯•ä¸­çš„é—®é¢˜æ€»ç»“ ä¸‹åˆ—å“ªä¸€ç§åç§»ï¼Œæ˜¯æˆ‘ä»¬åœ¨æœ€å°äºŒä¹˜ç›´çº¿æ‹Ÿåˆçš„æƒ…å†µä¸‹ä½¿ç”¨çš„ï¼Ÿå›¾ä¸­æ¨ªåæ ‡æ˜¯è¾“å…¥ Xï¼Œçºµåæ ‡æ˜¯è¾“å‡º Yã€‚ çº¿æ€§å›žå½’æ¨¡åž‹è®¡ç®—æŸå¤±å‡½æ•°ï¼Œä¾‹å¦‚å‡æ–¹å·®æŸå¤±å‡½æ•°æ—¶ï¼Œä½¿ç”¨çš„éƒ½æ˜¯ vertical offsetsã€‚perpendicular offsets ä¸€èˆ¬ç”¨äºŽä¸»æˆåˆ†åˆ†æžï¼ˆPCAï¼‰ä¸­ã€‚ fork() å‡½æ•°fork()å‡½æ•°æ˜¯Linuxç³»ç»Ÿä¸­å”¯ä¸€å¯ä»¥åˆ›å»ºä¸€ä¸ªæ–°è¿›ç¨‹çš„æ–¹æ³•ã€‚å…¶æ–°åˆ›å»ºçš„è¿›ç¨‹ç§°ä¸ºå­è¿›ç¨‹ï¼ŒåŽŸè¿›ç¨‹ç§°ä¸ºçˆ¶è¿›ç¨‹ã€‚å­è¿›ç¨‹å°†ä»Žçˆ¶è¿›ç¨‹å¤„ç»§æ‰¿äº†æ•´ä¸ªçˆ¶è¿›ç¨‹çš„åœ°å€ç©ºé—´ï¼ˆåŒ…æ‹¬è¿›ç¨‹ä¸Šä¸‹æ–‡ã€ä»£ç æ®µã€è¿›ç¨‹å †æ ˆã€å†…å­˜ä¿¡æ¯ã€æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦ã€è¿›ç¨‹ä¼˜å…ˆçº§ã€è¿›ç¨‹ç»„å·ç­‰ï¼‰ã€‚ç”±äºŽfork()å‡½æ•°æ‰€äº§ç”Ÿçš„å­è¿›ç¨‹æ˜¯å®Œå…¨å¤åˆ¶çš„çˆ¶è¿›ç¨‹ï¼Œå› æ­¤å®ƒä»¬ä¼šè¿è¡ŒåŒä¸€ä¸ªç¨‹åºï¼Œçˆ¶è¿›ç¨‹çš„ä»£ç ä»Žfork()å‡½æ•°çš„è¿”å›žå€¼å¼€å§‹åˆ†åˆ«åœ¨ä¸¤ä¸ªåœ°å€ç©ºé—´ä¸­åŒæ—¶è¿è¡Œï¼Œä»Žè€Œæ—¶ä¸¤ä¸ªè¿›ç¨‹åˆ†åˆ«èŽ·å¾—å…¶å„è‡ªçš„fork()å‡½æ•°è¿”å›žå€¼ï¼Œçˆ¶è¿›ç¨‹è¿”å›žå€¼ä¸ºå­è¿›ç¨‹çš„è¿›ç¨‹å·ï¼Œå­è¿›ç¨‹çš„è¿”å›žå€¼ä¸º0ï¼Œæ‰€ä»¥å¯ä»¥é€šè¿‡åˆ¤æ–­fork()å‡½æ•°çš„è¿”å›žå€¼æ¥ç¡®å®šè¯¥è¿›ç¨‹ä¸ºçˆ¶è¿›ç¨‹è¿˜æ˜¯å­è¿›ç¨‹ã€‚ å¯¹10TBçš„æ•°æ®æ–‡ä»¶è¿›è¡ŒæŽ’åºï¼Œåº”ä½¿ç”¨çš„æ–¹æ³•æ˜¯ï¼ˆè¿™ä¸ªä¸»è¦è€ƒå¯Ÿçš„æ˜¯å†…å­˜é—®é¢˜ï¼Œè€Œä¸æ˜¯æ•°æ®é‡å¤§é€ æˆçš„é€Ÿåº¦å¿«æ…¢é—®é¢˜ï¼Œ æ˜¯å†…å­˜ä¸­æ”¾ä¸ä¸‹çš„é—®é¢˜ï¼‰å¯¹äºŽ10TBçš„æµ·é‡æ•°æ®ï¼Œæ•°æ®ä¸å¯èƒ½ä¸€æ¬¡å…¨éƒ¨è½½å…¥å†…å­˜ï¼Œä¼ ç»Ÿçš„æŽ’åºæ–¹æ³•å°±ä¸é€‚ç”¨äº†ï¼Œéœ€è¦ç”¨åˆ°å¤–æŽ’åºçš„æ–¹æ³•ã€‚å¤–æŽ’åºé‡‡ç”¨åˆ†æ²»æ€æƒ³ï¼Œå³å…ˆå¯¹æ•°æ®åˆ†å—ï¼Œå¯¹å—å†…æ•°æ®è¿›è¡ŒæŽ’åºï¼Œç„¶åŽé‡‡ç”¨å½’å¹¶æŽ’åºçš„æ€æƒ³è¿›è¡ŒæŽ’åºï¼Œå¾—åˆ°æ•°æ®çš„ä¸€ä¸ªæœ‰åºåºåˆ—ã€‚ è¯·é—®ç»è¿‡è¡¨è¾¾å¼a = 5 ? 0 : 1çš„è¿ç®—,å˜é‡açš„æœ€ç»ˆå€¼æ˜¯? -&gt; 0è¡¨è¾¾å¼ä¸­çš„a æ˜¯ä¸€ç§æŽ¥æ”¶å˜é‡ï¼Œæ˜¯bool ç±»åž‹çš„ã€‚ å‡è®¾ä½ æœ‰ä»¥ä¸‹æ•°æ®ï¼šè¾“å…¥å’Œè¾“å‡ºéƒ½åªæœ‰ä¸€ä¸ªå˜é‡ã€‚ä½¿ç”¨çº¿æ€§å›žå½’æ¨¡åž‹ï¼ˆy=wx+bï¼‰æ¥æ‹Ÿåˆæ•°æ®ã€‚é‚£ä¹ˆä½¿ç”¨ç•™ä¸€æ³•ï¼ˆLeave-One Outï¼‰äº¤å‰éªŒè¯å¾—åˆ°çš„å‡æ–¹è¯¯å·®æ˜¯å¤šå°‘ï¼Ÿç•™ä¸€æ³•ï¼Œç®€å•æ¥è¯´å°±æ˜¯å‡è®¾æœ‰ N ä¸ªæ ·æœ¬ï¼Œå°†æ¯ä¸€ä¸ªæ ·æœ¬ä½œä¸ºæµ‹è¯•æ ·æœ¬ï¼Œå…¶å®ƒ N-1 ä¸ªæ ·æœ¬ä½œä¸ºè®­ç»ƒæ ·æœ¬ã€‚è¿™æ ·å¾—åˆ° N ä¸ªåˆ†ç±»å™¨ï¼ŒN ä¸ªæµ‹è¯•ç»“æžœã€‚ç”¨è¿™ Nä¸ªç»“æžœçš„å¹³å‡å€¼æ¥è¡¡é‡æ¨¡åž‹çš„æ€§èƒ½ã€‚é¢˜ç›®å¯ä»¥å‚è€ƒè¿™é‡Œ é’ˆå¯¹L1 åœ¨0ç‚¹å¯¼æ•°ä¸º0çš„æƒ…å†µå¦‚ä½•å¤„ç†ï¼Ÿ è§£å†³æ–¹æ³•ä¹‹ä¸€æ˜¯é€šè¿‡å‘¨å›´çš„loss çš„å€¼æˆ–è€…å‡å€¼æ¥æ›¿æ¢è¯¥ç‚¹ä¸º0 çš„æƒ…å†µã€‚æ¯”å¦‚ä¸‹é¢çš„æ–¹å¼ï¼š $$ Smooth_{L_1}(x ) = \begin{cases}0.5x^2 &amp; |x |&lt;1 \\|x |-0.5 &amp; otherwise\end{cases}$$]]></content>
  </entry>
  <entry>
    <title><![CDATA[Model Selection]]></title>
    <url>%2F2019%2F08%2F12%2Fmodel-selection%2F</url>
    <content type="text"><![CDATA[ä»‹ç»æ¨¡åž‹é€‰æ‹©çš„ä¸¤ç§æ–¹æ³•ï¼šäº¤å‰æ£€éªŒå’Œæ­£åˆ™åŒ–ã€‚ä½¿ç”¨äº¤å‰æ£€éªŒï¼ˆK-fold cross validationï¼‰è¿›è¡Œé€‰æ‹©æ¨¡åž‹å¹¶ä¸éš¾ç†è§£ï¼Œä½†æ­£åˆ™åŒ–å’Œæ¨¡åž‹é€‰æ‹©çš„å…³ç³»ï¼Œä¸€å¼€å§‹è¿˜ä¸æ˜¯å¾ˆç†è§£ï¼Œæ‰€ä»¥é€šè¿‡æ•´ç†ï¼Œå¸Œæœ›èƒ½å¸¦æ¥ä¸€äº›å¯å‘ã€‚ æ¨¡åž‹é€‰æ‹©æ¨¡åž‹é€‰æ‹©æœ‰ä¸¤ç§æ–¹å¼ï¼Œä¸€ç§æ˜¯äº¤å‰éªŒè¯ï¼Œä¸€ç§æ˜¯æ­£åˆ™åŒ–ã€‚å¯¹äºŽå‰è€…æ˜¯å¸¸è§„çš„åšæ³•ï¼Œå¯¹äºŽåŽè€…æ˜¯ä»Žæ¨¡åž‹çš„å¤æ‚åº¦è§’åº¦åŽ»ç†è§£ã€‚ ä¸ºä»€ä¹ˆè¦ k-fold æ¨¡åž‹é€‰æ‹©ï¼Ÿ åœ¨æœºå™¨å­¦ä¹ å»ºæ¨¡è¿‡ç¨‹ä¸­ï¼Œé€šè¡Œçš„åšæ³•é€šå¸¸æ˜¯å°†æ•°æ®åˆ†ä¸ºè®­ç»ƒé›†å’Œæµ‹è¯•é›†ã€‚æµ‹è¯•é›†æ˜¯ä¸Žè®­ç»ƒç‹¬ç«‹çš„æ•°æ®ï¼Œå®Œå…¨ä¸å‚ä¸Žè®­ç»ƒï¼Œç”¨äºŽæœ€ç»ˆæ¨¡åž‹çš„è¯„ä¼°ã€‚åœ¨è®­ç»ƒè¿‡ç¨‹ä¸­ï¼Œç»å¸¸ä¼šå‡ºçŽ°è¿‡æ‹Ÿåˆçš„é—®é¢˜ï¼Œå°±æ˜¯æ¨¡åž‹å¯ä»¥å¾ˆå¥½çš„åŒ¹é…è®­ç»ƒæ•°æ®ï¼Œå´ä¸èƒ½å¾ˆå¥½åœ¨é¢„æµ‹è®­ç»ƒé›†å¤–çš„æ•°æ®ã€‚å¦‚æžœæ­¤æ—¶å°±ä½¿ç”¨æµ‹è¯•æ•°æ®æ¥è°ƒæ•´æ¨¡åž‹å‚æ•°ï¼Œå°±ç›¸å½“äºŽåœ¨è®­ç»ƒæ—¶å·²çŸ¥éƒ¨åˆ†æµ‹è¯•æ•°æ®çš„ä¿¡æ¯ï¼Œä¼šå½±å“æœ€ç»ˆè¯„ä¼°ç»“æžœçš„å‡†ç¡®æ€§ã€‚é€šå¸¸çš„åšæ³•æ˜¯åœ¨è®­ç»ƒæ•°æ®å†ä¸­åˆ†å‡ºä¸€éƒ¨åˆ†åšä¸ºéªŒè¯(Validation)æ•°æ®ï¼Œç”¨æ¥è¯„ä¼°æ¨¡åž‹çš„è®­ç»ƒæ•ˆæžœã€‚(æ‰€ä»¥ k-fold ä»Žè®­ç»ƒè¿‡ç¨‹ä¸Šæ˜¯å¯ä»¥ ç¼“è§£è¿‡æ‹Ÿåˆçš„ï¼Œ æ˜¯æŠŠè®­ç»ƒé›†è¿›è¡Œäº†è¿›ä¸€æ­¥çš„åˆ’åˆ†) å¦‚ä½•åšçš„å‘¢ï¼Ÿ éªŒè¯æ•°æ®å–è‡ªè®­ç»ƒæ•°æ®ï¼Œä½†ä¸å‚ä¸Žè®­ç»ƒï¼Œè¿™æ ·å¯ä»¥ç›¸å¯¹å®¢è§‚çš„è¯„ä¼°æ¨¡åž‹å¯¹äºŽè®­ç»ƒé›†ä¹‹å¤–æ•°æ®çš„åŒ¹é…ç¨‹åº¦ã€‚æ¨¡åž‹åœ¨éªŒè¯æ•°æ®ä¸­çš„è¯„ä¼°å¸¸ç”¨çš„æ˜¯äº¤å‰éªŒè¯ï¼Œåˆç§°å¾ªçŽ¯éªŒè¯ã€‚å®ƒå°†åŽŸå§‹æ•°æ®åˆ†æˆKç»„(K-Fold)ï¼Œå°†æ¯ä¸ªå­é›†æ•°æ®åˆ†åˆ«åšä¸€æ¬¡éªŒè¯é›†ï¼Œå…¶ä½™çš„K-1ç»„å­é›†æ•°æ®ä½œä¸ºè®­ç»ƒé›†ï¼Œè¿™æ ·ä¼šå¾—åˆ°Kä¸ªæ¨¡åž‹ã€‚è¿™Kä¸ªæ¨¡åž‹åˆ†åˆ«åœ¨éªŒè¯é›†ä¸­è¯„ä¼°ç»“æžœï¼Œæœ€åŽçš„è¯¯å·®MSE(Mean Squared Error)åŠ å’Œå¹³å‡å°±å¾—åˆ°äº¤å‰éªŒè¯è¯¯å·®ã€‚äº¤å‰éªŒè¯æœ‰æ•ˆåˆ©ç”¨äº†æœ‰é™çš„æ•°æ®ï¼Œå¹¶ä¸”è¯„ä¼°ç»“æžœèƒ½å¤Ÿå°½å¯èƒ½æŽ¥è¿‘æ¨¡åž‹åœ¨æµ‹è¯•é›†ä¸Šçš„è¡¨çŽ°ï¼Œå¯ä»¥åšä¸ºæ¨¡åž‹ä¼˜åŒ–çš„æŒ‡æ ‡ä½¿ç”¨ã€‚ï¼ˆä»Žå¦ä¸€ä¸ªè§’åº¦è®²ï¼Œè¿™ä¸ªä¹Ÿæ˜¯å‚æ•°é€‰æ‹©çš„è¿‡ç¨‹ï¼Œå› ä¸ºæŸä¸€ä¸ªk æ˜¯å¯¹åº”ç€æŸä¸€ç»„æ¨¡åž‹å‚æ•°çš„ï¼‰ å…³äºŽk å€¼çš„é€‰æ‹© Kè¶Šå¤§ï¼Œæ¯æ¬¡æŠ•å…¥çš„è®­ç»ƒé›†çš„æ•°æ®è¶Šå¤šï¼Œæ¨¡åž‹çš„Biasè¶Šå°ã€‚ä½†æ˜¯Kè¶Šå¤§ï¼Œåˆæ„å‘³ç€æ¯ä¸€æ¬¡é€‰å–çš„è®­ç»ƒé›†ä¹‹å‰çš„ç›¸å…³æ€§è¶Šå¤§ï¼ˆè€ƒè™‘æœ€æžç«¯çš„ä¾‹å­ï¼Œå½“k=Nï¼Œä¹Ÿå°±æ˜¯åœ¨LOOCVï¼ˆå«åšç•™ä¸€æ³•ï¼‰é‡Œï¼Œæ¯æ¬¡éƒ½è®­ç»ƒæ•°æ®å‡ ä¹Žæ˜¯ä¸€æ ·çš„ï¼‰ã€‚è€Œè¿™ç§å¤§ç›¸å…³æ€§ä¼šå¯¼è‡´æœ€ç»ˆçš„test errorå…·æœ‰æ›´å¤§çš„Varianceã€‚ ä¸€èˆ¬æ¥è¯´ï¼Œæ ¹æ®ç»éªŒæˆ‘ä»¬ä¸€èˆ¬é€‰æ‹©k=5æˆ–10ã€‚ K-fold cross validationäº¤å‰æ£€éªŒé€šå¸¸è¢«ç”¨ä½œè¯„ä¼°ä¸€ä¸ªæœºå™¨å­¦ä¹ æ¨¡åž‹çš„è¡¨çŽ°ï¼Œå¯ä»¥ç”¨äºŽè¿›è¡Œæ¨¡åž‹çš„é€‰æ‹©ã€‚è€ŒKæŠ˜äº¤å‰éªŒè¯(K-fold cross validation)æŒ‡çš„æ˜¯æŠŠè®­ç»ƒæ•°æ®D åˆ†ä¸º Kä»½ï¼Œç”¨å…¶ä¸­çš„(K-1)ä»½è®­ç»ƒæ¨¡åž‹ï¼ŒæŠŠå‰©ä½™çš„1ä»½æ•°æ®ç”¨äºŽè¯„ä¼°æ¨¡åž‹çš„è´¨é‡ã€‚å°†è¿™ä¸ªè¿‡ç¨‹åœ¨Kä»½æ•°æ®ä¸Šä¾æ¬¡å¾ªçŽ¯ï¼Œå¹¶å¯¹å¾—åˆ°çš„Kä¸ªè¯„ä¼°ç»“æžœè¿›è¡Œåˆå¹¶ï¼Œå¦‚æ±‚å¹³å‡æˆ–æŠ•ç¥¨ã€‚ å…·ä½“çš„æ­¥éª¤å¦‚ä¸‹ï¼š ç¬¬ä¸€æ­¥ï¼Œä¸é‡å¤æŠ½æ ·å°†åŽŸå§‹æ•°æ®éšæœºåˆ†ä¸º k ä»½ã€‚ ç¬¬äºŒæ­¥ï¼Œæ¯ä¸€æ¬¡æŒ‘é€‰å…¶ä¸­ 1 ä»½ä½œä¸ºæµ‹è¯•é›†ï¼Œå‰©ä½™ k-1 ä»½ä½œä¸ºè®­ç»ƒé›†ç”¨äºŽæ¨¡åž‹è®­ç»ƒã€‚ ç¬¬ä¸‰æ­¥ï¼Œé‡å¤ç¬¬äºŒæ­¥ k æ¬¡ï¼Œè¿™æ ·æ¯ä¸ªå­é›†éƒ½æœ‰ä¸€æ¬¡æœºä¼šä½œä¸ºæµ‹è¯•é›†ï¼Œå…¶ä½™æœºä¼šä½œä¸ºè®­ç»ƒé›†ã€‚ åœ¨æ¯ä¸ªè®­ç»ƒé›†ä¸Šè®­ç»ƒåŽå¾—åˆ°ä¸€ä¸ªæ¨¡åž‹ï¼Œ ç”¨è¿™ä¸ªæ¨¡åž‹åœ¨ç›¸åº”çš„æµ‹è¯•é›†ä¸Šæµ‹è¯•ï¼Œè®¡ç®—å¹¶ä¿å­˜æ¨¡åž‹çš„è¯„ä¼°æŒ‡æ ‡ï¼Œ ç¬¬å››æ­¥ï¼Œè®¡ç®— k ç»„æµ‹è¯•ç»“æžœçš„å¹³å‡å€¼ä½œä¸ºæ¨¡åž‹ç²¾åº¦çš„ä¼°è®¡ï¼Œå¹¶ä½œä¸ºå½“å‰ k æŠ˜äº¤å‰éªŒè¯ä¸‹æ¨¡åž‹çš„æ€§èƒ½æŒ‡æ ‡ã€‚ å½“ K =10 çš„æ—¶å€™ ï¼Œè®­ç»ƒæ•°æ®Dè¢«åˆ†ä¸ºäº†10 ä»½ï¼Œæ¯æ¬¡å–å…¶ä¸­9ä»½æ•°æ®ä½œä¸ºè®­ç»ƒé›†ï¼Œ1ä»½ä½œä¸ºæµ‹è¯•é›†ï¼Œæœ€ç»ˆå°†å¾ªçŽ¯åŽæ‰€æœ‰çš„è¯„ä¼°ç»“æžœå–å¹³å‡ã€‚ äº¤å‰éªŒè¯çš„åˆ†ç±» å½“ç„¶æœ‰ä¸¤ç§æ¯”è¾ƒæžç«¯çš„ K çš„å–å€¼ï¼Œå½“k =1ï¼Œå…¨éƒ¨çš„æ•°æ®è¢«ç”¨äºŽè®­ç»ƒï¼Œç›¸å½“äºŽåªæœ‰è®­ç»ƒæ•°æ®é›†ï¼›å½“k =n çš„æ—¶å€™ï¼Œä¹Ÿè¢«ç§°ä¸ºç•™ä¸€æ³•ã€‚ç•™ä¸€æ³•äº¤å‰éªŒè¯ï¼šå‡è®¾æœ‰Nä¸ªæ ·æœ¬ï¼Œå°†æ¯ä¸€ä¸ªæ ·æœ¬ä½œä¸ºæµ‹è¯•æ ·æœ¬ï¼Œå…¶å®ƒN-1ä¸ªæ ·æœ¬ä½œä¸ºè®­ç»ƒæ ·æœ¬ã€‚è¿™æ ·å¾—åˆ°Nä¸ªåˆ†ç±»å™¨ï¼ŒNä¸ªæµ‹è¯•ç»“æžœã€‚ç”¨è¿™Nä¸ªç»“æžœçš„å¹³å‡å€¼æ¥è¡¡é‡æ¨¡åž‹çš„æ€§èƒ½ã€‚ å¦‚ä½•åŽ»ç†è§£äº¤å‰éªŒè¯å‘¢ï¼Ÿ ç®€å•çš„è¯´æ˜¯å¯ä»¥ä»Žæ–¹å·®å’Œåå·®çš„è§’åº¦è¿›è¡Œåˆ†æžã€‚å½“k =1ï¼Œå…¨éƒ¨çš„æ•°æ®è¢«ç”¨äºŽè®­ç»ƒï¼Œå®¹æ˜“å‡ºçŽ°è¿‡æ‹Ÿåˆï¼Œå®¹æ˜“å‡ºçŽ°ä½Žåå·®ã€é«˜æ–¹å·®çš„ï¼›å½“k =nï¼Œä¹Ÿè¢«ç§°ä¸ºç•™ä¸€æ³•ï¼Œåå·®å‡é«˜äº†è€Œæ–¹å·®æ˜¯å‡å°‘äº†ã€‚æ‰€ä»¥è¯´å–å€¼èŒƒå›´çš„å˜åŒ–å¯ä»¥çœ‹åšæ˜¯åå·®å’Œæ–¹å·®ç›¸äº’å¦¥åçš„è¿‡ç¨‹ã€‚ å¦‚ä½•é€‰æ‹©K çš„å€¼ ç»éªŒä¸Šçš„é€‰æ‹©ï¼Œä¸€èˆ¬k =10ã€‚å½“æ•°æ®é‡æ¯”è¾ƒå¤§çš„æ—¶å€™ï¼Œk å¯ä»¥å°ç‚¹ï¼›å½“æ•°æ®é‡æ¯”è¾ƒå°çš„æ—¶å€™ï¼Œk å¯ä»¥å°ç‚¹ã€‚åŸºæœ¬çš„åŽŸåˆ™æ˜¯ä¿è¯ æœ‰è¶³å¤Ÿçš„è®­ç»ƒæ ·æœ¬ç”¨äºŽè®­ç»ƒã€‚ æ­£åˆ™åŒ–è§’åº¦æ¨¡åž‹è®­ç»ƒè¿‡ç¨‹ä¸­å¾ˆå®¹æ˜“å‡ºçŽ°è¿‡æ‹Ÿåˆï¼Œæ ¹æœ¬åŽŸå› æ˜¯æ¨¡åž‹çš„å¤æ‚åº¦è¿œå°äºŽæ•°æ®é‡ï¼Œæ¨¡åž‹çš„å¤æ‚åº¦å’Œè®­ç»ƒè¯¯å·®äºŽæµ‹è¯•è¯¯å·®çš„å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ ä»Žå›¾ä¸­å¯ä»¥çœ‹åˆ°ï¼Œ éšç€æ¨¡åž‹å¤æ‚åº¦çš„æé«˜ï¼Œè®­ç»ƒè¯¯å·®æ˜¯ä¸æ–­ä¸‹é™çš„ï¼Œä½†æµ‹è¯•è¯¯å·®æ˜¯å…ˆä¸‹é™åŽä¸Šå‡çš„ã€‚æ¨¡åž‹é€‰æ‹© çš„ç»å…¸æ–¹æ³•æ˜¯æ­£åˆ™åŒ–ã€‚æ­£åˆ™åŒ–çš„ä½œç”¨æ˜¯é€‰æ‹©ç»éªŒé£Žé™©äºŽæ¨¡åž‹å¤æ‚åº¦åŒæ—¶è¾ƒå°çš„æ¨¡åž‹ã€‚ä¹Ÿå¯ä»¥è¯´ï¼Œåœ¨æ‰€æœ‰å¯ä»¥é€‰æ‹©çš„æ¨¡åž‹ä¸­ï¼Œèƒ½å¤Ÿå¾ˆå¥½çš„è§£é‡Šæ•°æ®å¹¶ä¸”ååˆ†ç®€å•çš„æ‰æ˜¯å¥½æ¨¡åž‹ã€‚ å­¦ä¹ æ–¹æ³•çš„æ³›åŒ–èƒ½åŠ›æ˜¯æŒ‡ç”±è¯¥æ–¹æ³•å­¦ä¹ åˆ°çš„æ¨¡åž‹å¯¹æœªçŸ¥æ•°æ®çš„é¢„æµ‹èƒ½åŠ›ï¼Œæ˜¯å­¦ä¹ æ–¹æ³•æœ¬è´¨ä¸Šé‡è¦çš„æ€§è´¨ã€‚çŽ°å®žä¸­é‡‡ç”¨æœ€å¤šçš„æ–¹æ³•æ˜¯é€šè¿‡æµ‹è¯•è¯¯å·®æ¥è¯„ä»·å­¦ä¹ æ–¹æ³•çš„æ³›åŒ–èƒ½åŠ›ã€‚ ç»“æž„åŒ–é£Žé™©è¦åŒºåˆ†è¿™ä¸‰ä¸ªæ¦‚å¿µï¼Œé¦–å…ˆè¦å¼•å…¥ä¸€ä¸ªæŸå¤±å‡½æ•°çš„æ¦‚å¿µã€‚æŸå¤±å‡½æ•°æ˜¯æœŸæœ›é£Žé™©ã€ç»éªŒé£Žé™©å’Œç»“æž„é£Žé™©çš„åŸºç¡€ã€‚ æŸå¤±å‡½æ•°æ˜¯é’ˆå¯¹å•ä¸ªå…·ä½“çš„æ ·æœ¬è€Œè¨€çš„ã€‚è¡¨ç¤ºçš„æ˜¯æ¨¡åž‹é¢„æµ‹çš„å€¼ä¸Žæ ·æœ¬çœŸå®žå€¼ä¹‹é—´çš„å·®è·ã€‚æ¯”å¦‚å¯¹äºŽæŸä¸ªæ ·æœ¬$(x_i, y_i)$ï¼Œå…¶çœŸå®žçš„å€¼ä¸ºYi,è€Œæˆ‘ä»¬çš„æ¨¡åž‹é€‰æ‹©å†³ç­–å‡½æ•°ä¸º $f $,é‚£ä¹ˆé€šè¿‡æ¨¡åž‹é¢„æµ‹çš„å€¼ä¸º$ f(x_i)$;æŸå¤±å‡½æ•°å°±æ˜¯ç”¨æ¥è¡¨ç¤º$y_i$ä¸Ž$ f(x_i)$ä¹‹é—´çš„å·®è·çš„ï¼Œæˆ‘ä»¬ç”¨å‡½æ•° $L(f(x_),y_i) $æ¥è¡¡é‡ã€‚æˆ‘ä»¬å¸Œæœ›çš„æ˜¯è¿™ä¸ªLå‡½æ•°æœ€å°åŒ–ã€‚ç†æƒ³çš„æƒ…å†µæ˜¯æˆ‘ä»¬çš„æ¨¡åž‹å†³ç­–å‡½æ•°é¢„æµ‹å€¼$fï¼ˆx_iï¼‰$åˆšå¥½ç­‰äºŽè¯¥æ ·æœ¬çš„çœŸå€¼ $y_i$ã€‚å¸¸è§çš„æŸå¤±å‡½æ•°æœ‰ï¼š å¹³æ–¹æŸå¤±å‡½æ•°ã€ç»å¯¹å€¼æŸå¤±å‡½æ•°å’Œå¯¹æ•°æŸå¤±å‡½æ•°ã€‚ é€šè¿‡æŸå¤±å‡½æ•°æˆ‘ä»¬åªèƒ½çŸ¥é“æ¨¡åž‹å†³ç­–å‡½æ•° $f(x) $å¯¹äºŽå•ä¸ªæ ·æœ¬ç‚¹çš„é¢„æµ‹èƒ½åŠ›ï¼ˆå€Ÿç”¨æŸå¤±å‡½æ•° $L(y ,f(x)) $ï¼ŒæŸå¤±å‡½æ•°è¶Šå°ï¼Œè¯´æ˜Žæ¨¡åž‹å¯¹äºŽè¯¥æ ·æœ¬é¢„æµ‹è¶Šå‡†ç¡®ã€‚ï¼‰ï¼Œé‚£ä¹ˆå¦‚æžœæƒ³çŸ¥é“æ¨¡åž‹ $f(x) $å¯¹è®­ç»ƒæ ·æœ¬ä¸­æ‰€æœ‰çš„æ ·æœ¬çš„é¢„æµ‹èƒ½åŠ›åº”è¯¥æ€Žä¹ˆåŠžå‘¢ï¼Ÿæ˜¾ç„¶åªéœ€æ‰€æœ‰çš„æ ·æœ¬ç‚¹éƒ½æ±‚ä¸€æ¬¡æŸå¤±å‡½æ•°ç„¶åŽè¿›è¡Œç´¯åŠ å°±å¥½äº†ã€‚å¦‚ä¸‹å¼ $$ (R_{exp}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right))$$ è¿™å°±ç»éªŒé£Žé™©ï¼Œæ‰€è°“çš„ç»éªŒé£Žé™©æœ€å°åŒ–ä¾¿æ˜¯è®©è¿™ä¸ªå¼å­æœ€å°åŒ–ï¼Œæ³¨æ„è¿™ä¸ªå¼å­ä¸­ç´¯åŠ å’Œçš„ä¸Šæ ‡Nè¡¨ç¤ºçš„æ˜¯è®­ç»ƒæ ·ä¾‹é›†ä¸­æ ·æœ¬çš„æ•°ç›®ã€‚ ç»éªŒé£Žé™©æ˜¯å¯¹è®­ç»ƒé›†ä¸­çš„æ‰€æœ‰æ ·æœ¬ç‚¹æŸå¤±å‡½æ•°çš„å¹³å‡æœ€å°åŒ–ã€‚ç»éªŒé£Žé™©è¶Šå°è¯´æ˜Žæ¨¡åž‹f(X)å¯¹è®­ç»ƒé›†çš„æ‹Ÿåˆç¨‹åº¦è¶Šå¥½ï¼Œä½†æ˜¯å¯¹äºŽæœªçŸ¥çš„æ ·æœ¬æ•ˆæžœæ€Žä¹ˆæ ·å‘¢ï¼Ÿæˆ‘ä»¬çŸ¥é“æœªçŸ¥çš„æ ·æœ¬æ•°æ®$ï¼ˆx, yï¼‰$çš„æ•°é‡æ˜¯ä¸å®¹æ˜“ç¡®å®šçš„ï¼Œæ‰€ä»¥å°±æ²¡æœ‰åŠžæ³•ç”¨æ‰€æœ‰æ ·æœ¬æŸå¤±å‡½æ•°çš„å¹³å‡å€¼çš„æœ€å°åŒ–è¿™ä¸ªæ–¹æ³•ï¼Œé‚£ä¹ˆæ€Žä¹ˆæ¥è¡¡é‡è¿™ä¸ªæ¨¡åž‹å¯¹æ‰€æœ‰çš„æ ·æœ¬ï¼ˆåŒ…å«æœªçŸ¥çš„æ ·æœ¬å’Œå·²çŸ¥çš„è®­ç»ƒæ ·æœ¬ï¼‰é¢„æµ‹èƒ½åŠ›å‘¢ï¼Ÿç†Ÿæ‚‰æ¦‚çŽ‡è®ºçš„å¾ˆå®¹æ˜“å°±æƒ³åˆ°äº†ç”¨æœŸæœ›ã€‚å³å‡è®¾ $x $å’Œ $y $æœä»Žè”åˆåˆ†å¸ƒ $P(x ,y) $.é‚£ä¹ˆæœŸæœ›é£Žé™©å°±å¯ä»¥è¡¨ç¤ºä¸ºï¼š $$R_{exp}(f)=E_{P}[L(Y, f(X))]=\int_{\mathrm{x \times y}} L(y, f(x)) P(x, y) d x d y$$ è¿™å°±æ˜¯æœŸæœ›é£Žé™©ï¼ŒæœŸæœ›é£Žé™©è¡¨ç¤ºçš„æ˜¯å…¨å±€çš„æ¦‚å¿µï¼Œè¡¨ç¤ºçš„æ˜¯å†³ç­–å‡½æ•°å¯¹æ‰€æœ‰çš„æ ·æœ¬ $x,y $é¢„æµ‹èƒ½åŠ›çš„å¤§å°ï¼Œè€Œç»éªŒé£Žé™©åˆ™æ˜¯å±€éƒ¨çš„æ¦‚å¿µï¼Œä»…ä»…è¡¨ç¤ºå†³ç­–å‡½æ•°å¯¹è®­ç»ƒæ•°æ®é›†é‡Œæ ·æœ¬çš„é¢„æµ‹èƒ½åŠ›ã€‚ç†æƒ³çš„æ¨¡åž‹ï¼ˆå†³ç­–ï¼‰å‡½æ•°åº”è¯¥æ˜¯è®©æ‰€æœ‰çš„æ ·æœ¬çš„æŸå¤±å‡½æ•°æœ€å°çš„ï¼ˆä¹Ÿå³æœŸæœ›é£Žé™©æœ€å°åŒ–ï¼‰ï¼Œä½†æ˜¯æœŸæœ›é£Žé™©å‡½æ•°å¾€å¾€æ˜¯ä¸å¯å¾—åˆ°çš„ï¼Œå³ä¸Šå¼ä¸­ï¼Œ $x $ä¸Ž $ y $çš„è”åˆåˆ†å¸ƒå‡½æ•°ä¸å®¹æ˜“å¾—åˆ°ã€‚çŽ°åœ¨æˆ‘ä»¬å·²ç»æ¸…æ¥šäº†æœŸæœ›é£Žé™©æ˜¯å…¨å±€çš„ï¼Œç†æƒ³æƒ…å†µä¸‹åº”è¯¥æ˜¯è®©æœŸæœ›é£Žé™©æœ€å°åŒ–ï¼Œä½†æ˜¯å‘¢ï¼ŒæœŸæœ›é£Žé™©å‡½æ•°åˆä¸æ˜¯é‚£ä¹ˆå®¹æ˜“å¾—åˆ°çš„ã€‚æ€Žä¹ˆåŠžå‘¢ï¼Ÿé‚£å°±ç”¨å±€éƒ¨æœ€ä¼˜çš„ä»£æ›¿å…¨å±€æœ€ä¼˜è¿™ä¸ªæ€æƒ³å§ã€‚è¿™å°±æ˜¯ç»éªŒé£Žé™©æœ€å°åŒ–çš„ç†è®ºåŸºç¡€ã€‚ é€šè¿‡ä¸Šé¢çš„åˆ†æžå¯ä»¥çŸ¥é“ï¼Œç»éªŒé£Žé™©ä¸ŽæœŸæœ›é£Žé™©ä¹‹é—´çš„è”ç³»ä¸ŽåŒºåˆ«ã€‚çŽ°åœ¨åœ¨æ€»ç»“ä¸€ä¸‹ï¼š ç»éªŒé£Žé™©æ˜¯å±€éƒ¨çš„ï¼ŒåŸºäºŽè®­ç»ƒé›†æ‰€æœ‰æ ·æœ¬ç‚¹æŸå¤±å‡½æ•°æœ€å°åŒ–çš„ã€‚ æœŸæœ›é£Žé™©æ˜¯å…¨å±€çš„ï¼Œæ˜¯åŸºäºŽæ‰€æœ‰æ ·æœ¬ç‚¹çš„æŸå¤±å‡½æ•°æœ€å°åŒ–çš„ã€‚ ç»éªŒé£Žé™©å‡½æ•°æ˜¯çŽ°å®žçš„ï¼Œå¯æ±‚çš„ï¼› æœŸæœ›é£Žé™©å‡½æ•°æ˜¯ç†æƒ³åŒ–çš„ï¼Œä¸å¯æ±‚çš„ï¼› åªè€ƒè™‘ç»éªŒé£Žé™©çš„è¯ï¼Œä¼šå‡ºçŽ°è¿‡æ‹Ÿåˆçš„çŽ°è±¡ï¼Œè¿‡æ‹Ÿåˆçš„æžç«¯æƒ…å†µä¾¿æ˜¯æ¨¡åž‹f(x)å¯¹è®­ç»ƒé›†ä¸­æ‰€æœ‰çš„æ ·æœ¬ç‚¹éƒ½æœ‰æœ€å¥½çš„é¢„æµ‹èƒ½åŠ›ï¼Œä½†æ˜¯å¯¹äºŽéžè®­ç»ƒé›†ä¸­çš„æ ·æœ¬æ•°æ®ï¼Œæ¨¡åž‹çš„é¢„æµ‹èƒ½åŠ›éžå¸¸ä¸å¥½ã€‚æ€Žä¹ˆåŠžå‘¢ï¼Ÿè¿™ä¸ªæ—¶å€™å°±å¼•å‡ºäº†ç»“æž„é£Žé™©ã€‚ç»“æž„é£Žé™©æ˜¯å¯¹ç»éªŒé£Žé™©å’ŒæœŸæœ›é£Žé™©çš„æŠ˜ä¸­ã€‚åœ¨ç»éªŒé£Žé™©å‡½æ•°åŽé¢åŠ ä¸€ä¸ªæ­£åˆ™åŒ–é¡¹ï¼ˆæƒ©ç½šé¡¹ï¼‰ä¾¿æ˜¯ç»“æž„é£Žé™©äº†ã€‚å¦‚ä¸‹å¼ï¼š $$R_{\mathrm{em}}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)$$ ç›¸æ¯”äºŽç»éªŒé£Žé™©ï¼Œç»“æž„é£Žé™©å¤šäº†ä¸€ä¸ªæƒ©ç½šé¡¹ï¼Œå…¶ä¸­æ˜¯ä¸€ä¸ª $\lambda $æ˜¯ä¸€ä¸ªå¤§äºŽ0çš„ç³»æ•°ã€‚$J(f) $è¡¨ç¤ºçš„æ˜¯æ˜¯æ¨¡åž‹fçš„å¤æ‚åº¦ã€‚ç»“æž„é£Žé™©å¯ä»¥è¿™ä¹ˆç†è§£ï¼š ç»éªŒé£Žé™©è¶Šå°ï¼Œæ¨¡åž‹å†³ç­–å‡½æ•°è¶Šå¤æ‚ï¼Œå…¶åŒ…å«çš„å‚æ•°è¶Šå¤šï¼Œå½“ç»éªŒé£Žé™©å‡½æ•°å°åˆ°ä¸€å®šç¨‹åº¦å°±å‡ºçŽ°äº†è¿‡æ‹ŸåˆçŽ°è±¡ã€‚ä¹Ÿå¯ä»¥ç†è§£ä¸ºæ¨¡åž‹å†³ç­–å‡½æ•°çš„å¤æ‚ç¨‹åº¦æ˜¯è¿‡æ‹Ÿåˆçš„å¿…è¦æ¡ä»¶ï¼Œé‚£ä¹ˆæˆ‘ä»¬è¦æƒ³é˜²æ­¢è¿‡æ‹ŸåˆçŽ°è±¡çš„æ–¹å¼ï¼Œå°±è¦ç ´åè¿™ä¸ªå¿…è¦æ¡ä»¶ï¼Œå³é™ä½Žå†³ç­–å‡½æ•°çš„å¤æ‚åº¦ã€‚ä¹Ÿå³ï¼Œè®©æƒ©ç½šé¡¹ $J(f) $æœ€å°åŒ–ï¼ŒçŽ°åœ¨å‡ºçŽ°ä¸¤ä¸ªéœ€è¦æœ€å°åŒ–çš„å‡½æ•°äº†ã€‚æˆ‘ä»¬éœ€è¦åŒæ—¶ä¿è¯ç»éªŒé£Žé™©å‡½æ•°å’Œæ¨¡åž‹å†³ç­–å‡½æ•°çš„å¤æ‚åº¦éƒ½è¾¾åˆ°æœ€å°åŒ–ï¼Œä¸€ä¸ªç®€å•çš„åŠžæ³•æŠŠä¸¤ä¸ªå¼å­èžåˆæˆä¸€ä¸ªå¼å­å¾—åˆ°ç»“æž„é£Žé™©å‡½æ•°ç„¶åŽå¯¹è¿™ä¸ªç»“æž„é£Žé™©å‡½æ•°è¿›è¡Œæœ€å°åŒ–ã€‚ å¸¸è§çš„è¯´æ³•ï¼š æžå¤§ä¼¼ç„¶ä¼°è®¡æ˜¯ç»éªŒé£Žé™©æœ€å°åŒ–çš„ä¸€ä¸ªä¾‹å­ï¼Œå½“æ¨¡åž‹æ˜¯æ¡ä»¶æ¦‚çŽ‡åˆ†å¸ƒï¼ŒæŸå¤±å‡½æ•°æ˜¯å¯¹æ•°æŸå¤±å‡½æ•°æ—¶ï¼Œç»éªŒé£Žé™©æœ€å°åŒ–å°±ç­‰äºŽæžå¤§ä¼¼ç„¶ä¼°è®¡ã€‚ï¼ˆä½†æ˜¯ï¼Œå½“æ ·æœ¬é‡å¾ˆå°æ—¶ï¼Œç»éªŒé£Žé™©æœ€å°åŒ–å­¦ä¹ çš„æ•ˆæžœæœªå¿…å¾ˆå¥½ï¼Œä¼šäº§ç”ŸåŽé¢å™è¿°çš„â€œè¿‡æ‹Ÿåˆâ€çŽ°è±¡ã€‚ï¼‰ ç»“æž„é£Žé™©æœ€å°åŒ–æ˜¯ä¸ºäº†é˜²æ­¢è¿‡æ‹Ÿåˆè€Œæå‡ºæ¥çš„ ç­–ç•¥ã€‚ç»“æž„é£Žé™©æœ€å°åŒ–ç­‰ä»·äºŽæ­£åˆ™é¡¹æˆ–ç½šé¡¹ã€‚ è´å¶æ–¯ä¼°è®¡ä¸­çš„æœ€å¤§åŽéªŒæ¦‚çŽ‡ä¼°è®¡ï¼ˆMAP,maximum posterior probability estimationï¼‰å°±æ˜¯ç»“æž„é£Žé™©æœ€å°åŒ–çš„ä¸€ä¸ªä¾‹å­ã€‚å½“æ¨¡åž‹æ˜¯æ¡ä»¶æ¦‚çŽ‡åˆ†å¸ƒã€æŸå¤±å‡½æ•°æ˜¯å¯¹æ•°æŸå¤±å‡½æ•°ã€æ¨¡åž‹å¤æ‚åº¦ç”±æ¨¡åž‹çš„å…ˆéªŒæ¦‚çŽ‡è¡¨ç¤ºæ—¶ï¼Œç»“æž„é£Žé™©æœ€å°åŒ–å°±ç­‰ä»·äºŽæœ€å¤§åŽéªŒæ¦‚çŽ‡ä¼°è®¡ã€‚ å¤ä¹ ç¬”è®° ç»éªŒé£Žé™©å’ŒæœŸæœ›é£Žé™©ï¼Œå‰è€…æ˜¯é’ˆå¯¹è®­ç»ƒé›†ï¼Œå¯ä»¥è®¡ç®—ï¼›åŽè€…æ˜¯å¯¹äºŽå…¨éƒ¨è®­ç»ƒæ•°æ®ï¼Œä¸å¯è®¡ç®—ã€‚ç»“æž„åŒ–é£Žé™©æ˜¯ä¸¤è€…çš„æŠ˜ä¸­ï¼Œåœ¨ç»éªŒé£Žé™©åŽé¢åŠ ä¸Šä¸€ä¸ªæ­£åˆ™é¡¹ï¼Œå¯¹ç»éªŒé£Žé™©è¿›è¡Œäº†æƒ©æˆ’ã€‚]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>k-fold</tag>
        <tag>ç»“æž„åŒ–é£Žé™©</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Union-Find (å¹¶æŸ¥é›†ç®—æ³•)]]></title>
    <url>%2F2019%2F08%2F05%2Funion-find%2F</url>
    <content type="text"><![CDATA[å¹¶æŸ¥é›†æ˜¯ä¸€ç§æ ‘åž‹æ•°æ®ç»“æž„ï¼Œç”¨äºŽå¤„ç†ä¸ç›¸äº¤ (Disjoint Sets) çš„åˆå¹¶åŠæŸ¥è¯¢é—®é¢˜ã€‚ å®šä¹‰å¹¶æŸ¥é›†ï¼Œåœ¨ä¸€äº›æœ‰Nä¸ªå…ƒç´ çš„é›†åˆåº”ç”¨é—®é¢˜ä¸­ï¼Œæˆ‘ä»¬é€šå¸¸æ˜¯åœ¨å¼€å§‹æ—¶è®©æ¯ä¸ªå…ƒç´ æž„æˆä¸€ä¸ªå•å…ƒç´ çš„é›†åˆï¼Œç„¶åŽæŒ‰ä¸€å®šé¡ºåºå°†å±žäºŽåŒä¸€ç»„çš„å…ƒç´ æ‰€åœ¨çš„é›†åˆåˆå¹¶ï¼Œå…¶é—´è¦åå¤æŸ¥æ‰¾ä¸€ä¸ªå…ƒç´ åœ¨å“ªä¸ªé›†åˆä¸­ã€‚ å¹¶æŸ¥é›†å±žäºŽä¸€ç§æ•°æ®ç»“æž„ç®—æ³•ï¼Œä¸€èˆ¬æ¥è¯´æœ‰åŠç¡®å®šçš„æ¨¡å—åŠŸèƒ½ï¼š åˆå§‹åŒ–æ“ä½œ åˆå¹¶æ“ä½œ ï¼ˆèƒ½å¤Ÿä½“çŽ°å±‚çº§å…³ç³»çš„ï¼Œæ•°é‡å°‘çš„é›†åˆæ˜¯éœ€è¦å¹¶å…¥åˆ°æ•°é‡å¤§çš„é›†åˆä¸­åŽ»ï¼‰ è·¯å¾„åŽ‹ç¼© ï¼ˆåœ¨æŸ¥è¯¢çš„è¿‡ç¨‹ä¸­ï¼Œç”¨è¿›è¡Œè·¯å¾„åŽ‹ç¼©ï¼‰ å¯¹äºŽæŸ¥æ‰¾æ“ä½œï¼Œå‡è®¾éœ€è¦ç¡®å®šxæ‰€åœ¨çš„çš„é›†åˆï¼Œä¹Ÿå°±æ˜¯ç¡®å®šé›†åˆçš„ä»£è¡¨å…ƒã€‚åˆ¤æ–­ä¸¤ä¸ªå…ƒç´ æ˜¯å¦å±žäºŽåŒä¸€é›†åˆï¼Œåªéœ€è¦çœ‹ä»–ä»¬çš„ä»£è¡¨å…ƒæ˜¯å¦ç›¸åŒå³å¯ã€‚å¹¶æŸ¥é›†ä¸ºäº†é¿å…æ—¶é—´å’Œç©ºé—´ä¸Šçš„æŸè€—ï¼Œåœ¨æ¯ä¸€è½®çš„æŸ¥æ‰¾æ—¶ï¼Œéƒ½è¦è¿›è¡Œä¸€æ¬¡è·¯å¾„åŽ‹ç¼©ä¼˜åŒ–ã€‚ è·¯å¾„åŽ‹ç¼© ï¼š åœ¨é€’å½’æ‰¾åˆ°æ ¹èŠ‚ç‚¹çš„æ—¶å€™ï¼ŒæŠŠå½“å‰èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹é—´æ‰€æœ‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹éƒ½è®¾ç½®ä¸ºæ ¹èŠ‚ç‚¹ã€‚ æˆ‘ä»¬æ¥çœ‹ä¸‹å›¾ï¼Œé¦–å…ˆæˆ‘ä»¬æœ‰ä¸ªè¿™æ ·çš„ä¸€æ£µæ ‘ï¼ŒçŽ°åœ¨è¦æ‰¾åˆ°å…ƒç´ 9æ‰€åœ¨æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œåœ¨æ‰¾æ ¹èŠ‚ç‚¹çš„è¿‡ç¨‹ä¸­ä½¿ç”¨è·¯å¾„åŽ‹ç¼©ï¼Œä¹Ÿå°±æ˜¯è¯´9åˆ°æ ¹çš„è·¯å¾„ä¸Šçš„èŠ‚ç‚¹9ï¼Œ6ï¼Œ3ï¼Œ1çš„çˆ¶èŠ‚ç‚¹éƒ½è®¾ç½®æˆä¸ºæ ¹èŠ‚ç‚¹0ï¼Œæ‰€ä»¥å‘¢ï¼Œåœ¨FIND-SET(9)ä¹‹åŽï¼Œæ ‘çš„å½¢æ€å°±å˜æˆäº†ä¸‹é¢çš„æ ·å­ æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ç»è¿‡è·¯å¾„åŽ‹ç¼©çš„èŠ‚ç‚¹åŠå…¶å­æ ‘åˆ°æ ¹èŠ‚ç‚¹çš„æ·±åº¦å‡å°äº†å¾ˆå¤šï¼Œæ‰€ä»¥åœ¨ä»¥åŽçš„æ“ä½œä¸­ï¼ŒæŸ¥æ‰¾æ ¹èŠ‚ç‚¹çš„é€Ÿåº¦ä¼šå¿«å¾ˆå¤š è¿™æ ·å¯ä»¥å°†æŸ¥è¯¢ä¸€ä¸ªç»“ç‚¹çš„æ ¹èŠ‚ç‚¹çš„æ—¶é—´å¤æ‚åº¦ä»Ž O(log N) é™åˆ° O(1) è¿˜æœ‰ä¸€ä¸ªæ¯”è¾ƒæœ‰è¶£çš„å›¾è§£å¯ä»¥è¯´æ˜Žè¿™ä¸ªä¼˜åŒ–ï¼š å¹¶æŸ¥é›†ä¸­çš„ä¸¤ä¸ªæ“ä½œæ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ $O(1)$ åˆå¹¶ä¸¤ä¸ªé›†åˆ åˆ¤æ–­ä¸¤ä¸ªç‚¹æ˜¯å¦åœ¨åŒä¸€ä¸ªé›†åˆä¸­ å¹¶æŸ¥é›†ä¸­æœ‰ä¸¤ä¸ªä¼˜åŒ–ï¼šè·¯å¾„åŽ‹ç¼© å’ŒæŒ‰ç§©åˆå¹¶ã€‚åŠ ä¸Šç¬¬ä¸€ä¸ªä¼˜åŒ–ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦æ˜¯ $log n$ï¼Œå¦‚æžœåŠ ä¸Šç¬¬äºŒä¸ªä¼˜åŒ–ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦æ˜¯ $log log n$ åŸºäºŽCè¯­è¨€çš„ä¸¤ç§å®žçŽ°åŸºäºŽæ•°ç»„å’Œç»“æž„ä½“çš„ä¸¤ç§å®žçŽ°ï¼ˆC è¯­è¨€ï¼‰ï¼Œä¸€èˆ¬æ¥è¯´ç®€å•é—®é¢˜ä½¿ç”¨æ•°ç»„ï¼Œå¤æ‚é—®é¢˜ä½¿ç”¨ç»“æž„ä½“ã€‚ æ•°ç»„ åˆå§‹åŒ– 123456789101112#define MAX 10000int set[max];//é›†åˆindexçš„ç±»åˆ«ï¼Œæˆ–è€…ç”¨parentè¡¨ç¤ºint rank[max];//é›†åˆindexçš„å±‚æ¬¡ï¼Œé€šå¸¸åˆå§‹åŒ–ä¸º0int data[max];//é›†åˆindexçš„æ•°æ®ç±»åž‹//åˆå§‹åŒ–é›†åˆvoid Make_Set(int i)&#123; set[i]=i;//åˆå§‹åŒ–çš„æ—¶å€™ï¼Œä¸€ä¸ªé›†åˆçš„parentéƒ½æ˜¯è¿™ä¸ªé›†åˆè‡ªå·±çš„æ ‡å·ã€‚æ²¡æœ‰è·Ÿå®ƒåŒç±»çš„é›†åˆï¼Œé‚£ä¹ˆè¿™ä¸ªé›†åˆçš„æºå¤´åªèƒ½æ˜¯è‡ªå·±äº†ã€‚ rank[i]=0;&#125; æŸ¥æ‰¾å‡½æ•° 123456789//æŸ¥æ‰¾é›†åˆiï¼ˆä¸€ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªé›†åˆï¼‰çš„æºå¤´ï¼ˆé€’å½’å®žçŽ°ï¼‰int Find_Set(int i)&#123; //å¦‚æžœé›†åˆiçš„çˆ¶äº²æ˜¯è‡ªå·±ï¼Œè¯´æ˜Žè‡ªå·±å°±æ˜¯æºå¤´ï¼Œè¿”å›žè‡ªå·±çš„æ ‡å· if(set[i]==i) return set[i]; //å¦åˆ™æŸ¥æ‰¾é›†åˆiçš„çˆ¶äº²çš„æºå¤´ return Find_Set(set[i]); &#125; åˆå¹¶å‡½æ•° 123456789101112void Union(int i,int j)&#123; i=Find_Set(i); j=Find_Set(j); if(i==j) return ; if(rank[i]&gt;rank[j]) set[j]=i; else &#123; if(rank[i]==rank[j]) rank[j]++; set[i]=j; &#125;&#125; ç»“æž„ä½“å®žçŽ° åˆå§‹åŒ– 123456struct Node&#123; int data; int rank; int parent; &#125;node[MAX]; æŸ¥æ‰¾å‡½æ•° 1234567891011/***æŸ¥æ‰¾é›†åˆiï¼ˆä¸€ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªé›†åˆï¼‰çš„æºå¤´ï¼ˆé€’å½’å®žçŽ°ï¼‰ã€‚ å¦‚æžœé›†åˆiçš„çˆ¶äº²æ˜¯è‡ªå·±ï¼Œè¯´æ˜Žè‡ªå·±å°±æ˜¯æºå¤´ï¼Œè¿”å›žè‡ªå·±çš„æ ‡å·ï¼› å¦åˆ™æŸ¥æ‰¾é›†åˆiçš„çˆ¶äº²çš„æºå¤´ã€‚**/int get_parent(int x)&#123; if(node[x].parent==x) return x; return get_parent(node[x].parent);&#125; åˆå¹¶å‡½æ•° 12345678910111213void Union(int a,int b)&#123; a=get_parent(a); b=get_parent(b); if(node[a].rank&gt;node[b].rank) node[b].parent=a; else &#123; node[a].parent=b; if(node[a].rank==node[b].rank) node[b].rank++; &#125;&#125; åº”è¯¥æ˜¯æœ‰ä¸‰ä¸ªç‰ˆæœ¬çš„ union-find ç®—æ³•çš„ï¼š find() union() æ€»çš„æ—¶é—´å¤æ‚åº¦ quick-find O(1) O(N) O(M*N) quick-union O(logN ~ N) O(1) O(M*N) æžç«¯ WeightedUF O(log N) O(N) O(M *log N) è¿™é‡Œæœ‰ä¸‰ä¸ªç‰ˆæœ¬çš„å®žçŽ° åº”ç”¨1ã€ç»´æŠ¤æ— å‘å›¾çš„è¿žé€šæ€§ã€‚æ”¯æŒåˆ¤æ–­ä¸¤ä¸ªç‚¹æ˜¯å¦åœ¨åŒä¸€è¿žé€šå—å†…ï¼Œå’Œåˆ¤æ–­å¢žåŠ ä¸€æ¡è¾¹æ˜¯å¦ä¼šäº§ç”ŸçŽ¯ã€‚2ã€åª’ä½“ç¤¾äº¤ï¼ˆæ¯”å¦‚ï¼šå‘é€šä¸€ä¸ªç¤¾äº¤åœˆçš„æœ‹å‹æŽ¨èå•†å“ï¼‰3ã€æ•°å­¦é›†åˆï¼ˆæ¯”å¦‚ï¼šåˆ¤æ–­å…ƒç´ p,qä¹‹åŽé€‰æ‹©æ˜¯å¦è¿›è¡Œé›†åˆåˆå¹¶ï¼‰ å¸¸è§çš„ä¸€ä¸ªç®—æ³•é¢˜ï¼Œ ç»™å‡º10W æ¡ä»»ä½•äººä¹‹é—´çš„æœ‹å‹å…³ç³»ï¼Œæ±‚è¿™äº›æœ‹å‹å…³ç³»ä¸­æœ‰å¤šå°‘ä¸ªæœ‹å‹åœˆï¼Œå¹¶ä¸”ç»™å‡ºç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ã€‚æ ·ä¾‹ï¼šA-B, B -C, D-E, E-F è¿™ å››å¯¹å…³ç³»ä¸­å­˜åœ¨ç€ä¸¤ä¸ªæœ‹å‹åœˆ ä¾‹é¢˜æ¨¡æ¿æœ‰ä¸‰ä¸ªã€‚ç¬¬ä¸€ä¸ªå’Œç¬¬äºŒä¸ªå·²ç»ç»ƒä¹ è¿‡ï¼Œä½†æ˜¯ç¬¬ä¸‰ä¸ªæ²¡æœ‰ç»ƒä¹ è¿‡ã€‚1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768691)æœ´ç´ å¹¶æŸ¥é›†ï¼š int p[N]; //å­˜å‚¨æ¯ä¸ªç‚¹çš„ç¥–å®—èŠ‚ç‚¹ // è¿”å›žxçš„ç¥–å®—èŠ‚ç‚¹ int find(int x) &#123; if (p[x] != x) p[x] = find(p[x]); return p[x]; &#125; // åˆå§‹åŒ–ï¼Œå‡å®šèŠ‚ç‚¹ç¼–å·æ˜¯1~n for (int i = 1; i &lt;= n; i ++ ) p[i] = i; // åˆå¹¶aå’Œbæ‰€åœ¨çš„ä¸¤ä¸ªé›†åˆï¼š p[find(a)] = find(b);(2)ç»´æŠ¤sizeçš„å¹¶æŸ¥é›†ï¼š int p[N], size[N]; //p[]å­˜å‚¨æ¯ä¸ªç‚¹çš„ç¥–å®—èŠ‚ç‚¹, size[]åªæœ‰ç¥–å®—èŠ‚ç‚¹çš„æœ‰æ„ä¹‰ï¼Œè¡¨ç¤ºç¥–å®—èŠ‚ç‚¹æ‰€åœ¨é›†åˆä¸­çš„ç‚¹çš„æ•°é‡ // è¿”å›žxçš„ç¥–å®—èŠ‚ç‚¹ int find(int x) &#123; if (p[x] != x) p[x] = find(p[x]); return p[x]; &#125; // åˆå§‹åŒ–ï¼Œå‡å®šèŠ‚ç‚¹ç¼–å·æ˜¯1~n for (int i = 1; i &lt;= n; i ++ ) &#123; p[i] = i; size[i] = 1; &#125; // åˆå¹¶aå’Œbæ‰€åœ¨çš„ä¸¤ä¸ªé›†åˆï¼š p[find(a)] = find(b); size[b] += size[a];(3)ç»´æŠ¤åˆ°ç¥–å®—èŠ‚ç‚¹è·ç¦»çš„å¹¶æŸ¥é›†ï¼š int p[N], d[N]; //p[]å­˜å‚¨æ¯ä¸ªç‚¹çš„ç¥–å®—èŠ‚ç‚¹, d[x]å­˜å‚¨xåˆ°p[x]çš„è·ç¦» // è¿”å›žxçš„ç¥–å®—èŠ‚ç‚¹ int find(int x) &#123; if (p[x] != x) &#123; int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; &#125; return p[x]; &#125; // åˆå§‹åŒ–ï¼Œå‡å®šèŠ‚ç‚¹ç¼–å·æ˜¯1~n for (int i = 1; i &lt;= n; i ++ ) &#123; p[i] = i; d[I] = 0; &#125; // åˆå¹¶aå’Œbæ‰€åœ¨çš„ä¸¤ä¸ªé›†åˆï¼š p[find(a)] = find(b); d[find(a)] = distance; // æ ¹æ®å…·ä½“é—®é¢˜ï¼Œåˆå§‹åŒ–find(a)çš„åç§»é‡ 547. Friend Circles p[x] è¡¨ç¤ºç»“ç‚¹ x çš„ç¥–å…ˆç»“ç‚¹ï¼Œåœ¨è¿›è¡Œfind ä¹‹åŽï¼Œæ‰¾åˆ°è¯¥èŠ‚ç‚¹çš„ç¥–å…ˆç»“ç‚¹ï¼Œè¿™ä¸ªè¿‡ç¨‹ä¸­åº”ç”¨äº†è·¯å¾„åŽ‹ç¼©ã€‚ä½¿ç”¨äº†é€’å½’çš„æ€æƒ³ã€‚ 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: // è¿™ä¸ªæ˜¯å¹¶æŸ¥é›†ä¸­çš„è£¸é¢˜ vector&lt;int&gt; p; // æ‰¾çˆ¶èŠ‚ç‚¹çš„ä¸€ä¸ªåŸºæœ¬æ“ä½œ int find(int x) &#123; // æ ¹æ®é€šé¡¹å…¬å¼ï¼ˆå‡è®¾ï¼‰ï¼Œ p[x] çš„ç¥–å…ˆç»“ç‚¹å·²çŸ¥ if(p[x] != x) p[x] =find(p[x]); //è·¯å¾„åŽ‹ç¼© return p[x]; &#125; int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; int n =M.size(); // åˆå§‹åŒ–ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½æ˜¯è‡ªå·±çš„çˆ¶èŠ‚ç‚¹ for(int i =0; i&lt;n; i++) p.push_back(i); int res =n; for(int i =0; i&lt; n; i++) &#123; for(int j =0; j&lt; i; j++) &#123; if(M[i][j] ==0) continue; if(find(i) !=find(j)) &#123; p[find(i)] =find(j); res -=1; &#125; &#125; &#125; return res; &#125;&#125;; åˆå¹¶é›†åˆ 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; p;int find(int x)&#123; if( x!= p[x]) p[x] =find(p[x]); return p[x];&#125;int main()&#123; int n, m; cin &gt;&gt;n&gt;&gt;m; for(int i =0; i&lt;n; i++) p.push_back(i); while(m --) &#123; string s; int a, b; cin &gt;&gt; s &gt;&gt;a&gt;&gt; b; if(s =="M") p[find(a)] =p[find(b)]; if(s =="Q") &#123; if(find(a) ==find(b)) cout &lt;&lt;"Yes"&lt;&lt;endl; else cout&lt;&lt; "No" &lt;&lt;endl; &#125; &#125; return 0;&#125; è¿žé€šå—ä¸­ç‚¹çš„æ•°é‡ é‡ç‚¹æ˜¯éœ€è¦ç»´æŠ¤ä¸€ä¸ª size çš„æ•°ç»„ï¼Œè¿™æ ·çš„è¯å°±èƒ½å¾—çŸ¥ æ¯ä¸€ä¸ªè¿žé€šå›¾çš„å¤§å°ã€‚æ—¶ç©ºåˆ†æžï¼š æ€»çš„æ—¶é—´å¤æ‚åº¦ $O(m +n)$æ€»çš„ç©ºé—´å¤æ‚åº¦$O(n)$ init çš„å‡½æ•° : $O(n) $find å‡½æ•° $O(logn )$ å¯ä»¥è¿‘ä¼¼è®¤ä¸ºæ˜¯ $O(1)$merge å‡½æ•° $O(1)$size å‡½æ•° $O(1)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N =1e5+11;int m, n;vector&lt;int&gt; p;vector&lt;int&gt; size;void init()&#123; for(int i =0; i&lt;n; i++) &#123; p.push_back(i); size.push_back(1); &#125;&#125;int find(int x)&#123; if(x != p[x]) p[x] =find(p[x]); return p[x];&#125;void merge(int x, int y)&#123; int t1, t2; t1 =find(x); t2 =find(y); if(t1 != t2) &#123; // è§„å®šä¸€å¾‹å‘ x åˆå¹¶ p[t2] =t1; size[t1] += size[t2]; &#125;&#125;int main()&#123; cin &gt;&gt;n &gt;&gt;m; init(); while( m--) &#123; string op; int a, b; cin &gt;&gt; op; if(op =="C") &#123; cin &gt;&gt;a&gt;&gt;b; merge(a, b); &#125; else if(op =="Q1") &#123; cin &gt;&gt;a&gt;&gt;b; if(find(a) == find(b) ) puts("Yes"); else puts("No"); &#125; else &#123; // å°±æ˜¯åº”è¯¥å•ç‹¬å†™ï¼Œè¿™ä¸ªæ¡ä»¶ä¸‹åªæœ‰ä¸€ä¸ªè¾“å…¥ cin &gt;&gt;a; cout &lt;&lt; size[find(a)] &lt;&lt;endl; &#125; &#125; return 0;&#125; 684. Redundant Connection å¹¶æŸ¥é›†çš„æ“ä½œæ˜¯ $O(1)$ éœ€è¦éåŽ†ä¸€éæ•°ç»„ï¼Œæ‰€ä»¥æ€»çš„æ—¶é—´æ˜¯$O(n)$ã€‚å…¶ä¸­æœ‰ä¸€ç‚¹ï¼Œä¸ºä»€ä¹ˆå¤šç”³è¯·äº†ä¸€ä¸ªç©ºé—´ï¼Œè¿™ä¸ªæ˜¯æ²¡æœ‰å¾ˆæ˜Žç™½çš„ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: vector&lt;int&gt; p; void init(int n) &#123; for(int i =0; i&lt; n; i++) p.push_back(i); &#125; int find(int x) &#123; if(x != p[x]) p[x] =find(p[x]); return p[x]; &#125; bool is_union(int x, int y) &#123; int t1 =find(x); int t2 =find(y); if( t1 ==t2) return true; else &#123; p[t1] =p[t2]; return false; &#125; &#125; vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; int n =edges.size() ; init(n+1);// è¿™é‡Œä¸ºä»€ä¹ˆè¦å¤šç”³è¯·ä¸€ä¸ªç©ºé—´ cout &lt;&lt; n&lt;&lt;endl; vector&lt;int&gt; res(2, 0); for(int i =0; i&lt; n; i++) &#123; int x =edges[i][0]; int y =edges[i][1]; //cout &lt;&lt; x&lt;&lt;" "&lt;&lt; y&lt;&lt; " "&lt;&lt; endl; if(is_union(x, y)) &#123; res[0] =x; res[1] =y; &#125; &#125; return res; &#125;&#125;; (784. å¼ºç›—å›¢ä¼™)[https://www.acwing.com/problem/content/description/786/] é¢˜è§£ ç®€å•çš„é¢˜è§£ï¼š æ­¤é¢˜çš„æœ‹å‹çš„æœ‹å‹æ˜¯å¾ˆå¥½ç†è§£çš„ï¼Œåªè¦æ˜¯æˆ‘çš„æœ‹å‹ï¼Œæˆ‘ä»¬å°±æ˜¯ä¸€ä¸ªteamï¼Œè¿›è¡ŒUnionæ“ä½œã€‚ä½†æ˜¯æ•Œäººçš„æ•Œäººä¹Ÿæ˜¯æˆ‘ä»¬çš„æœ‹å‹ï¼Œæ€Žä¹ˆè€ƒé‡å‘¢ï¼Ÿæˆ‘ä»¬éœ€è¦ä¸ºæ­¤å¢žåŠ ä¸€ä¸ªfæ•°ç»„ï¼Œå­˜å‚¨æˆ‘çš„æ•Œäººçš„å¤§å“¥ï¼Œå¾ˆå¥½ç†è§£ï¼Œaå’Œbæ˜¯æ•Œäººçš„è¯ï¼Œbå’Œcæ˜¯æ•Œäººçš„è¯ï¼Œé‚£ä¹ˆaå’Œcåº”è¯¥æ˜¯ä¸€ä¸ªteamçš„ï¼Œæ­¤å¤„éœ€è¦å¯¹aå’Œcè¿›è¡ŒUnionæ“ä½œï¼Œæˆ‘ä»¬ç¬¬ä¸€æ¬¡å­˜å‚¨çš„æ•Œäººæ˜¯ä¸€ä¸ªå‚è€ƒï¼Œåˆ¤æ–­å“ªäº›äººåº”è¯¥åˆå¹¶ã€‚ æ—¶é—´å¤æ‚åˆ†æžï¼Œ sort() å‡½æ•°æ˜¯ $O(mlog m)$ ï¼Œç„¶åŽéœ€è¦éåŽ†ä¸€éè¾¹ $O(m)$, å¹¶æŸ¥é›†æ“ä½œä¸€èˆ¬è®¤ä¸ºæ˜¯ $O(1)$ï¼Œæ‰€ä»¥æœ€åŽæ˜¯ $O(mlog m)$ ï¼Œm è¡¨ç¤ºè¾¹çš„æ•°é‡ã€‚kruskal ç®—æ³•æ±‚è§£æœ€å°ç”Ÿæˆæ ‘é¢˜è§£ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N =1e5+11, M =2e5+11, INF =0x3f3f3f3f;int n, m;int p[N];struct Edge&#123; int a, b, w;&#125;edges[M];int find(int x)&#123; // è¿™ä¸ªæ˜¯é€’å½’çš„å®šä¹‰ï¼Œåªéœ€è¦ä¸€æ¬¡if å°±è¡Œï¼Œä¸è¦ä½¿ç”¨ while if(p[x] != x) p[x] =find(p[x ]); return p[x];&#125;bool cmp(Edge a, Edge b)&#123; return a.w&lt; b.w;&#125;int kruskal()&#123; sort(edges, edges +m, cmp); for(int i =1; i&lt;=n; i++) p[i] =i; int res =0, cnt =0; for(int i =0; i&lt;m ;i++) &#123; int a =edges[i].a, b =edges[i].b, w =edges[i].w; a =find(a), b =find(b); if(a !=b) &#123; p[a]=b; res +=w; cnt ++; &#125; &#125; if (cnt !=n -1) return INF; return res;&#125;int main()&#123; cin &gt;&gt; n&gt;&gt;m; for(int i =0; i&lt;m; i++) &#123; int a, b, w; cin &gt;&gt;a&gt;&gt;b&gt;&gt;w; edges[i] =&#123;a, b, w&#125;; &#125; int t =kruskal(); if(t ==INF) puts("impossible"); else cout&lt;&lt;t&lt;&lt;endl;&#125; å‚è€ƒæ–‡çŒ® https://www.cnblogs.com/SeaSky0606/p/4752941.html]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>union-find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm Practice(1)]]></title>
    <url>%2F2019%2F07%2F30%2Falgorithm-practice%2F</url>
    <content type="text"><![CDATA[åˆ·é¢˜æ•´ç†ç¬”è®°ã€‚ æœ€å°ç¼–è¾‘è·ç¦» é“¾æŽ¥åœ°å€ leetcode ç‰ˆæœ¬123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class Solution &#123;public: int minDistance(string word1, string word2) &#123; int rows = word1.length(); int cols = word2.length(); vector&lt;vector&lt;int&gt; &gt; dp(rows+1, vector&lt;int&gt;(cols+1, 0)); for(int i=1; i&lt;=rows; ++i) dp[i][0] = i; for(int j=1; j&lt;=cols; ++j) dp[0][j] = j; for(int i=1; i&lt;=rows; ++i)&#123; for(int j=1; j&lt;=cols; ++j)&#123; if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1]; else dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1; &#125; &#125; return dp[rows][cols]; &#125;&#125;;int main()&#123; Solution solution; string str1 ="hello"; string str2 ="hello1"; cout &lt;&lt; solution.minDistance(str1, str2) &lt;&lt; endl; return 0;&#125; å•æœºç‰ˆæœ¬12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;/**ä½¿ç”¨dp çš„æ€æƒ³ï¼Œ f[i][j] è¡¨ç¤ºstring1ä¸­ç¬¬i ä¸ªä½ç½®å’Œ string2 ä¸­ç¬¬j ä½ç½®ä¹‹é—´çš„æœ€å°ç¼–è¾‘è·ç¦» è½¬ç§»: f[i][j] =f[i-1][j-1] if string1[i] ==string2[j] = min(f[i-1][j], f[i][j-1] ) å¯¹åº”çš„æ˜¯ä¿®æ”¹ åˆå§‹åŒ–: f[0][0] =1, ç„¶åŽf[i][0] å’Œ f[0][j] éƒ½æ˜¯0ï¼Œ æœ€åŽçš„f[m][n] å°±æ˜¯æœ€åŽçš„ç»“æžœ **/int main()&#123; string str1, str2; cin &gt;&gt; str1&gt;&gt; str2; int n,m; n =str1.size(), m =str2.size(); vector&lt;vector&lt;int&gt;&gt; f(n+1, vector&lt;int&gt;(m+1)); // åˆå§‹åŒ–éœ€è¦æ ¹æ®å®žé™…æ„ä¹‰è¿›è¡Œ f[0][0] =0; for(int i =1; i&lt;=n; i++) f[i][0] =i; for(int j =1; j&lt;=m ;j++) f[0][j] =j; for(int i =1; i&lt;=n; i++) &#123; for(int j =1; j&lt;=m; j++) &#123; //if(!i ||!j) f[i][j] =0; if(str1[i] ==str2[j]) f[i][j] =f[i-1][j-1]; else &#123; f[i][j] =min(f[i-1][j-1], min(f[i-1][j], f[i][j-1]))+1; &#125; &#125; &#125; cout&lt;&lt;f[n][m]&lt;&lt;endl; return 0;&#125; python è¯­è¨€å®žçŽ° æ³¨æ„ä¸¤ç§åˆå§‹åŒ–çš„åŒºåˆ«ï¼š12dp =[(cols+1)*[0]]*(rows+1) # è¿™ç§æ˜¯ä¸ work çš„dp =[ [0] *(cols+1) for _ in range(rows+1)] # è¿™ç§æ˜¯ work çš„ 123456789101112131415161718192021222324252627282930def minDistance(string1, string2): if not string1 or not string2 : return rows, cols =len(string1), len(string2) if rows ==0: return cols; elif cols ==0: return rows; #dp =[(cols+1)*[0]]*(rows+1) dp =[ [0] *(cols+1) for _ in range(rows+1)] for i in range(1, rows+1): dp[i][0] =i for j in range(1, cols+1): dp[0][j] =j #ipdb.set_trace() for i in range(1, rows+1): for j in range(1, cols+1): if string1[i-1] ==string2[j-1]: dp[i][j] =dp[i-1][j-1] else: dp[i][j] =1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) return dp[-1][-1]print(minDistance("string1", "string")) ä»Žæ— å¤´å•é“¾è¡¨ä¸­åˆ é™¤èŠ‚ç‚¹ åˆ é™¤èŠ‚ç‚¹çš„é€šå¸¸åšæ³•æ˜¯æ‰¾åˆ°è¯¥ç»“ç‚¹çš„å‰ä¸€ä¸ªç»“ç‚¹ï¼ˆå¤´ç»“ç‚¹ï¼‰ï¼Œç„¶åŽ head.next =head.next.nextè¿™ä¸ªé¢˜ç›®è¯´æ²¡æœ‰å¤´ç»“ç‚¹ï¼Œç›´æŽ¥ç»™å‡ºçš„å°±æ˜¯åº”è¯¥åˆ é™¤çš„ç»“ç‚¹å‡è®¾è¿™ä¸ªæ˜¯å¤´ç»“ç‚¹ï¼Œé‚£ä¹ˆä¸‹ä¸€ä¸ªæ˜¯å¾…åˆ é™¤çš„ç»“ç‚¹ï¼Œæ‰€ä»¥ current.next =current.next.next ï¼Œä½†æ˜¯éœ€è¦æŠŠcurrent.next.value èµ‹å€¼ç»™ current.value 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;assert.h&gt;typedef struct node&#123; int data; node *next;&#125;Node;void delete_node(Node *current)&#123; assert(current !=NULL); Node *next =current-&gt;next; if (next !=NULL) &#123; current-&gt;next =next-&gt;next current-&gt; data =next-&gt; data; &#125;&#125;int main()&#123; return 0;&#125; Best Time to Buy and Sell Stock Say you have an array for which the ith element is the price of a given stock on day i.If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Tips: è®°å½•ä¸€ä¸ªæœ€å°å€¼ å’Œæœ€å¤§çš„max differences 1234567891011121314151617181920class Solution: def maxProfit(self, prices): if not prices or len(prices) ==1: return 0 low, maxDiff =prices[0], 0 for i in range(1, len(prices)): if prices[i] &lt; low: low =prices[i] else: diff =prices[i] -low if diff&gt; maxDiff: maxDiff =diff return maxDiff Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Tipsï¼š è¿™ä¸ªæ˜¯å¯ä»¥è¿›è¡Œå¤šæ¬¡ä¹°å–ï¼Œå¦‚åŒå¯»æ‰¾å¢žåºåˆ— 1234567891011class Solution: def maxProfit(self, prices): total =0 for i in range(1, len(prices)): if prices[i] &gt;= prices[i-1]: total += prices[i]-prices[i-1] return total æœ€å¤šè¿›è¡Œä¸¤æ¬¡äº¤æ˜“ã€‚ è¿™ä¸ªè¿”å›žçš„æœ€åŽæ˜¯æœ€å¤§å€¼ maximum profitã€‚å¥½å¥½ç†è§£ä¸€ä¸‹å§ 1234567891011121314151617class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ one_buy = two_buy = sys.maxsize one_profit = two_profit = 0 for p in prices: one_buy = min(one_buy, p) one_profit = max(one_profit, p - one_buy) two_buy = min(two_buy, p - one_profit) # ä¸ºä»€ä¹ˆå’Œ one_profit è¿›è¡Œæ¯”è¾ƒå‘¢ two_profit = max(two_profit, p - two_buy) return two_profit Design an algorithm to find the maximum profit. You may complete at most k transactions. æœ€å¤šè¿›è¡Œ k æ¬¡äº¤æ˜“ https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/273435/Python-1-D-DP 123456789def maxProfit(k, prices): if k &gt; len(prices) &gt;&gt; 1: return sum(prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]&gt;prices[i]) cash, asset = [float('-inf')] * (k+1), [0] * (k+1) for price in prices: for i in range(1,k+1): cash[i] = max(cash[i], asset[i-1]-price) asset[i] = max(asset[i], cash[i]+price) return asset[k] è¿™ä¸ªæ˜¯æ¯”è¾ƒå¥½ç†è§£ä¸€äº›çš„https://blog.csdn.net/xx_123_1_rj/article/details/80857144 12345678910111213141516171819202122class Solution: def maxProfit(self, k, prices): n, res = len(prices), 0 if n &lt; 2: return 0 if k &gt; n //2: # çŽ°åœ¨è¿™ä¸ªæƒ…å†µï¼Œå°±ç›¸å½“äºŽé¢˜ç›®2 for i in range(1, n): if prices[i] &gt; prices[i-1]: res += prices[i] - prices[i-1] return res hold, sold = [float('-inf')] * (k + 1), [0] * (k + 1) for price in prices: for j in range(1, k+1): hold[j] = max(hold[j], sold[j-1]-price) # hold-&gt;hold, sold-&gt;hold sold[j] = max(sold[j], hold[j]+price) # sold-&gt;sold, hold-&gt;sold return sold[k] if __name__ == '__main__': prices, k = [7, 1, 5, 3, 6, 4], 4 solu = Solution() print(solu.maxProfit(k, prices)) 38. Count and Say https://leetcode.com/problems/count-and-say/ leetcode ç‰ˆæœ¬ 1234567891011121314151617181920212223class Solution &#123;public: string countAndSay(int n) &#123; string s ="1"; for(int i =0; i&lt;n -1; i++) &#123; string ns; for(int j =0; j&lt; s.size();j++ ) &#123; int k =j; while(s[k] ==s[j]) k++; ns += to_string(k-j)+ s[j]; j =k -1; &#125; s =ns; &#125; return s; &#125;&#125;; å•æœºç‰ˆæœ¬ 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;string count_say(int n)&#123; string s ="1"; for(int i =0; i&lt;n-1; i++) &#123; string ns; for(int j =0; j&lt;s.size(); j++) &#123; int k =j; while( s[k] ==s[j]) k++; ns += to_string(k-j)+s[j]; j = k-1; &#125; s =ns; &#125; return s;&#125;int main()&#123; int n; cin &gt;&gt;n; cout&lt;&lt; count_say(n)&lt;&lt;endl; return 0;&#125; 1234567891011121314151617181920212223242526class Solution &#123;public: // å•è¯ä¸åŒç»„åˆçš„æœ¬è´¨ï¼Œç„¶åŽä½¿ç”¨dictionary è¿›è¡Œå­˜å‚¨ vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; unordered_map&lt;string, vector&lt;string&gt;&gt; hash; for(auto str: strs) &#123; string tmp =str; sort(tmp.begin(), tmp.end()); hash[tmp].push_back(str); &#125; // æœ¬è´¨ -&gt; çŽ°è±¡ //for(auto item: hash) cout&lt;&lt;item&lt;&lt;endl; vector&lt;vector&lt;string&gt;&gt; res; for(auto item: hash) res.push_back(item.second); return res; &#125;&#125;; https://leetcode.com/problems/group-anagrams/submissions/ vectorä¸­push_back ç±»ä¼¼ python ä¸­list çš„append æ“ä½œ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;unordered_map&gt;using namespace std;// å•è¯æ‰“é”™äº†ï¼Œä¹Ÿæ˜¯ä¸é€šè¿‡çš„vector&lt;vector&lt;string&gt;&gt; group(vector&lt;string&gt;&amp; input)&#123; // è¿˜åŽŸæœ¬è´¨, unordered_map&lt;string, vector&lt;string&gt;&gt; dict; // map çš„åº•å±‚å®žçŽ°æ˜¯å¹³è¡¡æ ‘ï¼Œæ“ä½œçš„æ—¶é—´å¤æ‚åº¦æ˜¯lognï¼Œ æ‰€ä»¥æ…¢ï¼Œè€Œunordered_map(hashè¡¨) æ˜¯å¸¸æ•° for(auto str : input) &#123; string tmp =str; sort(tmp.begin(), tmp.end()); dict[tmp].push_back(str); &#125; // ç»“æžœ vector&lt;vector&lt;string&gt;&gt; res; for(auto key: dict) res.push_back(key.second); return res;&#125;int main()&#123; int n ; cin&gt;&gt;n; vector&lt;string&gt; input; for(int i =0; i&lt;n;i++) &#123; string tmp ; cin &gt;&gt;tmp; input.push_back(tmp); &#125; vector&lt;vector&lt;string&gt;&gt; res =group(input); for(auto u: res) &#123; for(auto v: u) cout&lt;&lt; v&lt;&lt;" "; cout&lt;&lt;endl; &#125; return 0;&#125; Two sum ç³»åˆ—å¥—é¢˜ æœ‰å¤šå¯¹è§£ï¼Œè¾“å‡ºä¸€å¯¹è§£å°±å¯ä»¥ã€‚æœ€ç®€å•çš„ä¸€ç§æƒ…å†µã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;unordered_set&gt;#include "vector"using namespace std;#define LEN 100vector&lt;int&gt; nums(LEN);vector&lt;int&gt; find_sum(vector&lt;int&gt; &amp; nums, int target)&#123; unordered_set&lt;int&gt; hash; for(int i =0; i&lt;nums.size(); i++) &#123; if(hash.count(target -nums[i] )) return vector&lt;int&gt;&#123;target-nums[i], nums[i]&#125;; hash.insert(nums[i]); &#125; return vector&lt;int&gt;(); &#125;int main()&#123; int n , target; cin &gt;&gt;n &gt;&gt; target; for(int i =0; i&lt;n; i++) cin&gt;&gt; nums[i]; vector&lt;int&gt; res =find_sum(nums, target); for(int i =0; i&lt;res.size(); i++) cout&lt;&lt; res[i]&lt;&lt;" "; cout&lt;&lt;endl; return 0;&#125; è¿™ä¸ªè¿”å›žçš„æ˜¯indexï¼Œ è€Œä¸æ˜¯æ•°å€¼ã€‚ 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;unordered_set&gt;#include "vector"#include "unordered_map"using namespace std;#define LEN 100vector&lt;int&gt; nums(LEN);int main()&#123; vector&lt;int&gt; nums =&#123;1, 2, 3, 4&#125;; int target =7; unordered_map&lt;int, int&gt; hash; for(int i =0; i&lt;nums.size(); i++) &#123; auto it =hash.find(target- nums[i]); if(it != hash.end()) cout &lt;&lt;vector&lt;int&gt;&#123;i, it-&gt;second&#125;[0]&lt;&lt; " "&lt;&lt; vector&lt;int&gt;&#123;i, it-&gt;second&#125;[1]&lt;&lt;endl; hash[nums[i]] =i; &#125; return 0;&#125; é€†åºå¯¹ æš´åŠ›æ±‚è§£ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯$O(N^2)$123456789101112131415class Solution &#123;public: int InversePairs(vector&lt;int&gt; data) &#123; int n =data.size(); // å…ˆæ˜¯æš´åŠ›æ±‚è§£ ç†è§£ä¸€ä¸‹é¢˜æ„ int res =0; for(int i =0; i&lt;n; i++) &#123; for(int j =i+1; j&lt;n; j++) if(data[i] &gt;data[j]) res +=1; &#125; return res; &#125;&#125;; è¿™ä¸ªåœ¨ç‰›å®¢ç½‘ä¸Šï¼Œä½¿ç”¨å½’å¹¶çš„æ–¹å¼ï¼Œä¹Ÿæ˜¯æ²¡æœ‰åŠžæ³•å®Œå…¨é€šè¿‡ï¼Œåªèƒ½ä¿è¯æ˜¯ 50% çš„caseã€‚ 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: // å½’å¹¶æŽ’åº æ—¶é—´å¤æ‚åº¦ O(nlogn), å¯¹äºŽå½“å‰çš„åŒºé—´åˆ†æˆå·¦åŒºé—´çš„ç»“æžœï¼Œå³åŒºé—´çš„ç»“æžœå’Œä¸¤ä¸ªåŒºé—´ä¹‹é—´çš„ç»“æžœ // é€’å½’çš„æ€æƒ³å°±æ˜¯è¦é€’å½’è·³å‡ºçš„æ¡ä»¶ int merge(vector&lt;int&gt;&amp; data, int l, int r) &#123; if(l &gt;=r) return 0; int mid =l +r &gt;&gt;1; int res= merge(data, l, mid) +merge(data, mid+1, r); int i =l, j =mid+1; vector&lt;int&gt; temp; while( i&lt;=mid &amp;&amp; j&lt;=r) &#123; if(data[i]&lt; data[j]) temp.push_back(data[i++]); else &#123; res += mid -i+1; temp.push_back(data[j++]); &#125; &#125; while(i&lt;=mid) temp.push_back(data[i++]); while(j &lt;=r) temp.push_back(data[j++]); // è¿™ä¸ªæ˜¯å½“å‰åŒºé—´çš„èµ·ç‚¹ i =l; for(auto u: temp) data[i++] =u; return res % 1000000007; &#125; int InversePairs(vector&lt;int&gt; data) &#123; return merge(data, 0, data.size()-1); &#125;&#125;;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Transfer Learning]]></title>
    <url>%2F2019%2F07%2F29%2Ftransfer-learning%2F</url>
    <content type="text"><![CDATA[ä»‹ç»è¿ç§»å­¦ä¹  å’Œå¤šä»»åŠ¡å­¦ä¹ ã€‚ è¿ç§»å­¦ä¹ å®šä¹‰ï¼š æ¶‰åŠä¸€ä¸ªæºé¢†åŸŸsource domainå’Œä¸€ä¸ªç›®æ ‡é¢†åŸŸï¼ˆtarget domainï¼‰ï¼Œåœ¨source domainå­¦ä¹ ï¼Œå¹¶æŠŠå­¦ä¹ åˆ°çš„çŸ¥è¯†è¿ç§»åˆ°target domainï¼Œæå‡target domainçš„å­¦ä¹ æ•ˆæžœï¼ˆperformanceï¼‰ã€‚èµ·æºï¼š åœ¨ä¸€äº›æ–°çš„é¢†åŸŸï¼Œæ ‡æ³¨æ•°æ®å¾ˆéš¾èŽ·å¾—ï¼›ç›®æ ‡ï¼šä»Žä¸€ä¸ªçŽ¯å¢ƒä¸­å­¦ä¹ åˆ°çš„çŸ¥è¯†å¸®åŠ©æ–°çŽ¯å¢ƒçš„å­¦ä¹ ä»»åŠ¡ã€‚å’Œä¼ ç»Ÿæœºå™¨å­¦ä¹ çš„ç†è®ºåŒºåˆ«ï¼šä¼ ç»Ÿçš„æœºå™¨å­¦ä¹ å‡è®¾è®­ç»ƒæ•°æ®ä¸Žæµ‹è¯•æ•°æ®æœä»Žç›¸åŒçš„æ•°æ®åˆ†å¸ƒï¼Œè¿ç§»å­¦ä¹ ä¸ä¼šåƒä¼ ç»Ÿæœºå™¨å­¦ä¹ é‚£æ ·ä½œåŒåˆ†å¸ƒå‡è®¾ã€‚è¿ç§»å­¦ä¹ æ˜¯æŒ‡ä¸€ä¸ªå­¦ä¹ ç®—æ³•å¯ä»¥åˆ©ç”¨ä¸åŒå­¦ä¹ ä»»åŠ¡ä¹‹é—´çš„å…±æ€§æ¥å…±äº«ç»Ÿè®¡çš„ä¼˜ç‚¹å’Œåœ¨ä»»åŠ¡é—´è¿ç§»çŸ¥è¯†ã€‚ åŸºæœ¬ä¸Šï¼Œç¥žç»ç½‘ç»œè¿ç§»å­¦ä¹ ä¸»è¦æœ‰ä¸¤ä¸ªåº”ç”¨åœºæ™¯ï¼šç‰¹å¾æå–ï¼ˆFeature Extractionï¼‰å’Œå¾®è°ƒï¼ˆFine Tuningï¼‰ã€‚ç¬¬ä¸€ç§ï¼š ç‰¹å¾æå–ï¼šåœ¨ç‰¹å¾æå–ä¸­ï¼Œå¯ä»¥åœ¨é¢„å…ˆè®­ç»ƒå¥½çš„ç½‘ç»œç»“æž„åŽæ·»åŠ ä¸€ä¸ªç®€å•çš„åˆ†ç±»å™¨ï¼Œå°†æºä»»åŠ¡ä¸Šçš„é¢„å…ˆè®­ç»ƒå¥½çš„ç½‘ç»œä½œä¸ºå¦ä¸€ä¸ªç›®æ ‡ä»»åŠ¡çš„ç‰¹å¾æå–å™¨ï¼Œåªå¯¹æœ€åŽå¢žåŠ çš„åˆ†ç±»å™¨å‚æ•°è¿›è¡Œé‡æ–°å­¦ä¹ ï¼Œè€Œé¢„å…ˆè®­ç»ƒå¥½çš„ç½‘ç»œå‚æ•°ä¸è¢«ä¿®æ”¹ã€‚è¿™ä½¿å¾—æ–°ä»»åŠ¡çš„ç‰¹å¾æå–æ—¶ä½¿ç”¨çš„æ˜¯æºä»»åŠ¡ä¸­å­¦ä¹ åˆ°çš„å‚æ•°ï¼Œè€Œä¸ç”¨é‡æ–°å­¦ä¹ æ‰€æœ‰å‚æ•°ã€‚é€‚ç”¨åœºæ™¯ï¼šæºä»»åŠ¡ å’Œç›®æ ‡ä»»åŠ¡ä¿æŒåŒä¸€åˆ†å¸ƒæœ€å¥½ï¼Œå› ä¸ºç½‘ç»œå‚æ•°æ˜¯æ›´åŠ é€‚åˆçš„ã€‚ç¬¬äºŒç§ï¼šå¾®è°ƒå›ºå®šåº•å±‚çš„å‚æ•°ï¼Œè°ƒæ•´ä¸€äº›é¡¶å±‚çš„å‚æ•°ã€‚è¿™æ ·åšçš„å¥½å¤„å¯ä»¥å‡å°‘è®­ç»ƒå‚æ•°çš„æ•°é‡ï¼ŒåŒæ—¶ä¹Ÿæœ‰åŠ©äºŽå…‹æœè¿‡æ‹ŸåˆçŽ°è±¡çš„å‘ç”Ÿï¼Œå°¤å…¶æ˜¯å½“ç›®æ ‡ä»»åŠ¡çš„æ•°æ®é‡ä¸è¶³å¤Ÿå¤§çš„æ—¶å€™ï¼Œè¯¥æ–¹æ³•å®žè·µèµ·æ¥å¾ˆæœ‰æ•ˆæžœã€‚å®žé™…ä¸Šï¼Œå¾®è°ƒè¦ä¼˜äºŽç‰¹å¾æå–ï¼Œå› ä¸ºå®ƒèƒ½å¤Ÿå¯¹è¿ç§»è¿‡æ¥çš„é¢„è®­ç»ƒç½‘ç»œå‚æ•°è¿›è¡Œä¼˜åŒ–ï¼Œä½¿å…¶æ›´åŠ é€‚åˆæ–°çš„ä»»åŠ¡ã€‚ å¤šä»»åŠ¡å­¦ä¹ æ˜¯è¿ç§»ç®—æ³•çš„ä¸€ç§ã€‚ å¤šä»»åŠ¡å­¦ä¹ å®šä¹‰ï¼šåŸºäºŽå…±äº«è¡¨ç¤ºï¼ŒæŠŠå¤šä¸ªç›¸å…³çš„ä»»åŠ¡æ”¾åˆ°ä¸€èµ·è¿›è¡Œå­¦ä¹ çš„ä¸€ç§æœºå™¨å­¦ä¹ æ–¹æ³•ã€‚å¤šä»»åŠ¡å­¦ä¹ æ˜¯ç›¸å¯¹äºŽå•ä»»åŠ¡å­¦ä¹ çš„ä¸€ç§æœºå™¨å­¦ä¹ çš„æ–¹æ³•ã€‚ ä¾‹å­ï¼šæˆ‘ä»¬å¸Œæœ›æœ‰ä¸€ä¸ªç½‘ç»œæ¨¡åž‹å¯ä»¥å°†è¾“å…¥çš„äººè„¸å›¾åƒåˆ†ç±»ä¸ºç”·æ€§æˆ–å¥³æ€§ï¼ŒåŒæ—¶è¿˜èƒ½å¤Ÿé¢„æµ‹å…¶å¹´é¾„ã€‚è¿™ä¸ªæ¡ˆä¾‹ä¸­æœ‰ä¸¤ä¸ªç›¸å…³çš„ä»»åŠ¡ï¼šä¸€ä¸ªæ˜¯äºŒå…ƒåˆ†ç±»ä»»åŠ¡ï¼Œå¦ä¸€ä¸ªæ˜¯å›žå½’ä»»åŠ¡ã€‚æ˜¾è€Œæ˜“è§ï¼Œè¿™ä¸¤ä¸ªä»»åŠ¡æ˜¯ç›¸å…³çš„ï¼Œå­¦ä¹ å…¶ä¸­ä¸€ä¸ªä»»åŠ¡çš„åŒæ—¶åº”è¯¥å¢žå¼ºå¯¹å¦ä¸€ä¸ªä»»åŠ¡çš„ç†è§£ã€‚ å…±äº«éƒ¨åˆ†å­¦ä¹ åˆ°çš„æ˜¯å¤šä¸ªä»»åŠ¡çš„å…±äº«è¡¨ç¤ºï¼Œå…±äº«è¡¨ç¤ºå…·æœ‰è¾ƒå¼ºçš„æŠ½è±¡èƒ½åŠ›ï¼Œèƒ½å¤Ÿé€‚åº”å¤šä¸ªä¸åŒä½†ç›¸å…³çš„ç›®æ ‡ä»»åŠ¡ï¼Œé€šå¸¸ä½¿å¾—å¤šä»»åŠ¡ä¸­çš„ä¸»ä»»åŠ¡èŽ·å¾—æ›´å¥½çš„æ³›åŒ–èƒ½åŠ›ã€‚å¦ä¸€æ–¹é¢ï¼Œé’ˆå¯¹æ¯ä¸ªä¸åŒçš„ä»»åŠ¡éƒ½ä¼šè®¾è®¡å…·ä½“çš„é¡¶å±‚ç½‘ç»œç»“æž„ï¼ˆå¤´ï¼‰ï¼Œé¡¶å±‚ç½‘ç»œç»“æž„ç”¨æ¥å­¦ä¹ å¦‚ä½•ä½¿ç”¨å…±äº«è¡¨ç¤ºæ¥å®Œæˆæ¯ä¸ªç‰¹å®šçš„ä»»åŠ¡ã€‚ å•ä»»åŠ¡å­¦ä¹  vs å¤šä»»åŠ¡å­¦ä¹ ï¼š å•ä»»åŠ¡å­¦ä¹ ï¼šä¸€æ¬¡åªå­¦ä¹ ä¸€ä¸ªä»»åŠ¡ï¼ˆtaskï¼‰ï¼Œå¤§éƒ¨åˆ†çš„æœºå™¨å­¦ä¹ ä»»åŠ¡éƒ½å±žäºŽå•ä»»åŠ¡å­¦ä¹ ã€‚å¤šä»»åŠ¡å­¦ä¹ ï¼šæŠŠå¤šä¸ªç›¸å…³ï¼ˆrelatedï¼‰çš„ä»»åŠ¡æ”¾åœ¨ä¸€èµ·å­¦ä¹ ï¼ŒåŒæ—¶å­¦ä¹ å¤šä¸ªä»»åŠ¡ã€‚ ä»Žå›¾ä¸­å¯ä»¥å‘çŽ°ï¼Œå•ä»»åŠ¡å­¦ä¹ æ—¶ï¼Œå„ä¸ªtaskä»»åŠ¡çš„å­¦ä¹ æ˜¯ç›¸äº’ç‹¬ç«‹çš„ï¼Œå¤šä»»åŠ¡å­¦ä¹ æ—¶ï¼Œå¤šä¸ªä»»åŠ¡ä¹‹é—´çš„æµ…å±‚è¡¨ç¤ºå…±äº«ï¼ˆshared representationï¼‰ åˆ†ç±»ï¼š ä¸€æ˜¯ä¸åŒä»»åŠ¡ä¹‹é—´å…±äº«ç›¸åŒçš„å‚æ•°ï¼ˆcommon parameterï¼‰ï¼ŒäºŒæ˜¯æŒ–æŽ˜ä¸åŒä»»åŠ¡ä¹‹é—´éšè—çš„å…±æœ‰æ•°æ®ç‰¹å¾ï¼ˆlatent featureï¼‰ å¤šä»»åŠ¡å­¦ä¹ æœ‰æ•ˆæ€§çš„åŽŸå› ï¼šï¼ˆ1ï¼‰å¤šäººç›¸å…³ä»»åŠ¡æ”¾åœ¨ä¸€èµ·å­¦ä¹ ï¼Œæœ‰ç›¸å…³çš„éƒ¨åˆ†ï¼Œä½†ä¹Ÿæœ‰ä¸ç›¸å…³çš„éƒ¨åˆ†ã€‚å½“å­¦ä¹ ä¸€ä¸ªä»»åŠ¡ï¼ˆMain taskï¼‰æ—¶ï¼Œä¸Žè¯¥ä»»åŠ¡ä¸ç›¸å…³çš„éƒ¨åˆ†ï¼Œåœ¨å­¦ä¹ è¿‡ç¨‹ä¸­ç›¸å½“äºŽæ˜¯å™ªå£°ï¼Œå› æ­¤ï¼Œå¼•å…¥å™ªå£°å¯ä»¥æé«˜å­¦ä¹ çš„æ³›åŒ–ï¼ˆgeneralizationï¼‰æ•ˆæžœã€‚ï¼ˆ2ï¼‰å¤šä¸ªä»»åŠ¡åœ¨æµ…å±‚å…±äº«è¡¨ç¤ºï¼Œå¯èƒ½å‰Šå¼±äº†ç½‘ç»œçš„èƒ½åŠ›ï¼Œé™ä½Žç½‘ç»œè¿‡æ‹Ÿåˆï¼Œæå‡äº†æ³›åŒ–æ•ˆæžœã€‚]]></content>
      <categories>
        <category>Deep learning</category>
      </categories>
      <tags>
        <tag>transfer_learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python advanced skills]]></title>
    <url>%2F2019%2F07%2F27%2Fpython-learning2%2F</url>
    <content type="text"><![CDATA[ä»‹ç» python advanced skillã€‚ Advanced FeaturesLetâ€™s move on to advanced features. Lambda functionsA Lambda Function is a small, anonymous function â€” anonymous in the sense that it doesnâ€™t actually have a name. A lambda function can take any number of arguments, but must always have only one expression: lambda å‡½æ•°æ˜¯ä¸€ç§ å†…è”å‡½æ•° inline functionï¼Œè°ƒç”¨æˆæœ¬å°ï¼Œæ—¶ç©ºå¼€é”€å¾ˆå°ã€‚ 1234x = lambda a, b : a * b print(x(5, 6)) # prints '30' # åŒ¿åå‡½æ•°ä¹Ÿæ˜¯å‡½æ•°ï¼Œè°ƒç”¨çš„æ—¶å€™ä½¿ç”¨è¿™æ ·çš„æ–¹å¼ x = lambda a : a*3 + 3 print(x(3)) # prints '12' lambdaè¡¨è¾¾å¼çš„åŸºæœ¬è¯­æ³•å¦‚ä¸‹ï¼š lambda arg1,arg2,arg3â€¦ :&lt;è¡¨è¾¾å¼&gt;arg1/arg2/arg3ä¸ºå‡½æ•°çš„å‚æ•°ï¼ˆå‡½æ•°è¾“å…¥ï¼‰ï¼Œè¡¨è¾¾å¼ç›¸å½“äºŽå‡½æ•°ä½“ï¼Œè¿ç®—ç»“æžœæ˜¯è¡¨è¾¾å¼çš„è¿ç®—ç»“æžœã€‚ Python ä¸­å®šä¹‰å‡½æ•°æœ‰ä¸¤ç§æ–¹æ³•ï¼Œä¸€ç§æ˜¯ç”¨å¸¸è§„æ–¹å¼ def å®šä¹‰ï¼Œå‡½æ•°è¦æŒ‡å®šåå­—ï¼Œç¬¬äºŒç§æ˜¯ç”¨ lambda å®šä¹‰ï¼Œä¸éœ€è¦æŒ‡å®šåå­—ï¼Œç§°ä¸º Lambda å‡½æ•°ã€‚lambda å‡½æ•°çš„ä½¿ç”¨åœºæ™¯ï¼šå½“é€»è¾‘æ¯”è¾ƒç®€å•çš„æ—¶å€™ï¼Œæ²¡æœ‰å¿…è¦èµ·ä¸ªåå­—æˆ–è€…è¯´å–ä¸€ä¸ªä¼˜é›…çš„åå­—æ˜¯å¾ˆè´¹åŠ²çš„äº‹æƒ…ã€‚ ä¸‹é¢ä¸¤ç§å®šä¹‰æ˜¯ç­‰ä»·çš„ã€‚ 1234567def add1(x, y): return x+yprint(add1(1, 2))add2 = lambda x, y: x+yprint(add2(1,2)) å¦‚æžœæ˜¯ä½¿ç”¨ åŒ¿åå‡½æ•°ï¼ˆlambda è¡¨è¾¾å¼ï¼‰ï¼Œè¿˜æœ‰æœ‰ä¸€ä¸ªåå­—ï¼ˆå¦‚ä¸Šæ‰€ç¤ºï¼‰ï¼Œæœ‰ç‚¹ç”»è›‡æ·»è¶³ã€‚é€šå¸¸æ˜¯ç›´æŽ¥ä½¿ç”¨ lambda è¡¨è¾¾å¼çš„ã€‚ mapmap()ä¼ å…¥çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯fï¼Œå³å‡½æ•°å¯¹è±¡æœ¬èº«ã€‚ç”±äºŽç»“æžœræ˜¯ä¸€ä¸ªIteratorï¼ŒIteratoræ˜¯æƒ°æ€§åºåˆ—ï¼Œå› æ­¤é€šè¿‡list()å‡½æ•°è®©å®ƒæŠŠæ•´ä¸ªåºåˆ—éƒ½è®¡ç®—å‡ºæ¥å¹¶è¿”å›žä¸€ä¸ªlistã€‚ 12r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])list(r) reduceï¼ˆæ‰¾æ‰¾è¿™ç§ reduceçš„æ„Ÿè§‰ï¼‰reduceæŠŠä¸€ä¸ªå‡½æ•°ä½œç”¨åœ¨ä¸€ä¸ªåºåˆ—[x1, x2, x3, â€¦]ä¸Šï¼Œè¿™ä¸ªå‡½æ•°å¿…é¡»æŽ¥æ”¶ä¸¤ä¸ªå‚æ•°ï¼ŒreduceæŠŠç»“æžœç»§ç»­å’Œåºåˆ—çš„ä¸‹ä¸€ä¸ªå…ƒç´ åšç´¯ç§¯è®¡ç®—ï¼Œå…¶æ•ˆæžœå°±æ˜¯ï¼š 1reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) å¦‚æžœè¦æŠŠåºåˆ—[1, 3, 5, 7, 9]å˜æ¢æˆæ•´æ•°13579ï¼Œreduceå°±å¯ä»¥æ´¾ä¸Šç”¨åœºï¼š 123def fn(x, y): return x*10 +yreduce(fn, [1, 3, 5, 7, 9]) # è¾“å‡ºæ˜¯ 13579 filterå’Œmap()ç±»ä¼¼ï¼Œfilter()ä¹ŸæŽ¥æ”¶ä¸€ä¸ªå‡½æ•°å’Œä¸€ä¸ªåºåˆ—ã€‚å’Œmap()ä¸åŒçš„æ˜¯ï¼Œfilter()æŠŠä¼ å…¥çš„å‡½æ•°ä¾æ¬¡ä½œç”¨äºŽæ¯ä¸ªå…ƒç´ ï¼Œç„¶åŽæ ¹æ®è¿”å›žå€¼æ˜¯Trueè¿˜æ˜¯Falseå†³å®šä¿ç•™è¿˜æ˜¯ä¸¢å¼ƒè¯¥å…ƒç´ ã€‚ 1234def is_odd(n): return n % 2 == 1list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))# ç»“æžœ: [1, 5, 9, 15] å‡½æ•°å¼ç¼–ç¨‹ å‡½æ•°å¼ç¼–ç¨‹ï¼ˆFunctional Programmingï¼‰æ˜¯ä¸€ç§ç¼–ç¨‹èŒƒå¼ï¼Œå’Œé¢å‘è¿‡ç¨‹ï¼Œé¢å‘å¯¹è±¡ç¼–ç¨‹ç›¸åŒç±»åˆ«çš„ã€‚ åœ¨è®¡ç®—æœºçš„å±‚æ¬¡ä¸Šï¼ŒCPUæ‰§è¡Œçš„æ˜¯åŠ å‡ä¹˜é™¤çš„æŒ‡ä»¤ä»£ç ï¼Œä»¥åŠå„ç§æ¡ä»¶åˆ¤æ–­å’Œè·³è½¬æŒ‡ä»¤ï¼Œæ‰€ä»¥ï¼Œæ±‡ç¼–è¯­è¨€æ˜¯æœ€è´´è¿‘è®¡ç®—æœºçš„è¯­è¨€ã€‚è€Œè®¡ç®—åˆ™æŒ‡æ•°å­¦æ„ä¹‰ä¸Šçš„è®¡ç®—ï¼Œè¶Šæ˜¯æŠ½è±¡çš„è®¡ç®—ï¼Œç¦»è®¡ç®—æœºç¡¬ä»¶è¶Šè¿œã€‚å¯¹åº”åˆ°ç¼–ç¨‹è¯­è¨€ï¼Œå°±æ˜¯è¶Šä½Žçº§çš„è¯­è¨€ï¼Œè¶Šè´´è¿‘è®¡ç®—æœºï¼ŒæŠ½è±¡ç¨‹åº¦ä½Žï¼Œæ‰§è¡Œæ•ˆçŽ‡é«˜ï¼Œæ¯”å¦‚Cè¯­è¨€ï¼›è¶Šé«˜çº§çš„è¯­è¨€ï¼Œè¶Šè´´è¿‘è®¡ç®—ï¼ŒæŠ½è±¡ç¨‹åº¦é«˜ï¼Œæ‰§è¡Œæ•ˆçŽ‡ä½Žï¼Œæ¯”å¦‚Lispè¯­è¨€ã€‚ å‡½æ•°å¼ç¼–ç¨‹ç‰¹ç‚¹ å‡½æ•°å¼ç¼–ç¨‹å°±æ˜¯ä¸€ç§æŠ½è±¡ç¨‹åº¦å¾ˆé«˜çš„ç¼–ç¨‹èŒƒå¼ï¼Œçº¯ç²¹çš„å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ç¼–å†™çš„å‡½æ•°æ²¡æœ‰å˜é‡ï¼Œå› æ­¤ï¼Œä»»æ„ä¸€ä¸ªå‡½æ•°ï¼Œåªè¦è¾“å…¥æ˜¯ç¡®å®šçš„ï¼Œè¾“å‡ºå°±æ˜¯ç¡®å®šçš„ï¼Œè¿™ç§çº¯å‡½æ•°æˆ‘ä»¬ç§°ä¹‹ä¸ºæ²¡æœ‰å‰¯ä½œç”¨ã€‚è€Œå…è®¸ä½¿ç”¨å˜é‡çš„ç¨‹åºè®¾è®¡è¯­è¨€ï¼Œç”±äºŽå‡½æ•°å†…éƒ¨çš„å˜é‡çŠ¶æ€ä¸ç¡®å®šï¼ŒåŒæ ·çš„è¾“å…¥ï¼Œå¯èƒ½å¾—åˆ°ä¸åŒçš„è¾“å‡ºï¼Œå› æ­¤ï¼Œè¿™ç§å‡½æ•°æ˜¯æœ‰å‰¯ä½œç”¨çš„ã€‚ å‡½æ•°å¼ç¼–ç¨‹çš„ä¸€ä¸ªç‰¹ç‚¹å°±æ˜¯ï¼Œå…è®¸æŠŠå‡½æ•°æœ¬èº«ä½œä¸ºå‚æ•°ä¼ å…¥å¦ä¸€ä¸ªå‡½æ•°ï¼Œè¿˜å…è®¸è¿”å›žä¸€ä¸ªå‡½æ•°ï¼ æ‰€è°“â€å‰¯ä½œç”¨â€ï¼ˆside effectï¼‰ï¼ŒæŒ‡çš„æ˜¯å‡½æ•°å†…éƒ¨ä¸Žå¤–éƒ¨äº’åŠ¨ï¼ˆæœ€å…¸åž‹çš„æƒ…å†µï¼Œå°±æ˜¯ä¿®æ”¹å…¨å±€å˜é‡çš„å€¼ï¼‰ï¼Œäº§ç”Ÿè¿ç®—ä»¥å¤–çš„å…¶ä»–ç»“æžœã€‚å‡½æ•°å¼ç¼–ç¨‹å¼ºè°ƒæ²¡æœ‰â€å‰¯ä½œç”¨â€ï¼Œæ„å‘³ç€å‡½æ•°è¦ä¿æŒç‹¬ç«‹ï¼Œæ‰€æœ‰åŠŸèƒ½å°±æ˜¯è¿”å›žä¸€ä¸ªæ–°çš„å€¼ï¼Œæ²¡æœ‰å…¶ä»–è¡Œä¸ºï¼Œå°¤å…¶æ˜¯ä¸å¾—ä¿®æ”¹å¤–éƒ¨å˜é‡çš„å€¼ã€‚ å¼•ç”¨é€æ˜Žï¼ˆReferential transparencyï¼‰ï¼ŒæŒ‡çš„æ˜¯å‡½æ•°çš„è¿è¡Œä¸ä¾èµ–äºŽå¤–éƒ¨å˜é‡æˆ–â€çŠ¶æ€â€ï¼Œåªä¾èµ–äºŽè¾“å…¥çš„å‚æ•°ï¼Œä»»ä½•æ—¶å€™åªè¦å‚æ•°ç›¸åŒï¼Œå¼•ç”¨å‡½æ•°æ‰€å¾—åˆ°çš„è¿”å›žå€¼æ€»æ˜¯ç›¸åŒçš„ã€‚æœ‰äº†å‰é¢çš„ç¬¬ä¸‰ç‚¹å’Œç¬¬å››ç‚¹ï¼Œè¿™ç‚¹æ˜¯å¾ˆæ˜¾ç„¶çš„ã€‚å…¶ä»–ç±»åž‹çš„è¯­è¨€ï¼Œå‡½æ•°çš„è¿”å›žå€¼å¾€å¾€ä¸Žç³»ç»ŸçŠ¶æ€æœ‰å…³ï¼Œä¸åŒçš„çŠ¶æ€ä¹‹ä¸‹ï¼Œè¿”å›žå€¼æ˜¯ä¸ä¸€æ ·çš„ã€‚è¿™å°±å«â€å¼•ç”¨ä¸é€æ˜Žâ€ï¼Œå¾ˆä¸åˆ©äºŽè§‚å¯Ÿå’Œç†è§£ç¨‹åºçš„è¡Œä¸ºã€‚ å‡½æ•°å¼ç¼–ç¨‹çš„å‡ ä¸ªæŠ€æœ¯ map &amp; reduce ï¼šè¿™ä¸ªæŠ€æœ¯ä¸ç”¨å¤šè¯´äº†ï¼Œå‡½æ•°å¼ç¼–ç¨‹æœ€å¸¸è§çš„æŠ€æœ¯å°±æ˜¯å¯¹ä¸€ä¸ªé›†åˆåšMapå’ŒReduceæ“ä½œã€‚ pipelineï¼šè¿™ä¸ªæŠ€æœ¯çš„æ„æ€æ˜¯ï¼ŒæŠŠå‡½æ•°å®žä¾‹æˆä¸€ä¸ªä¸€ä¸ªçš„actionï¼Œç„¶åŽï¼ŒæŠŠä¸€ç»„actionæ”¾åˆ°ä¸€ä¸ªæ•°ç»„æˆ–æ˜¯åˆ—è¡¨ä¸­ï¼Œç„¶åŽæŠŠæ•°æ®ä¼ ç»™è¿™ä¸ªaction listï¼Œæ•°æ®å°±åƒä¸€ä¸ªpipelineä¸€æ ·é¡ºåºåœ°è¢«å„ä¸ªå‡½æ•°æ‰€æ“ä½œï¼Œæœ€ç»ˆå¾—åˆ°æˆ‘ä»¬æƒ³è¦çš„ç»“æžœã€‚ é€’å½’æœ€å¤§çš„å¥½å¤„å°±ç®€åŒ–ä»£ç ï¼Œä»–å¯ä»¥æŠŠä¸€ä¸ªå¤æ‚çš„é—®é¢˜ç”¨å¾ˆç®€å•çš„ä»£ç æè¿°å‡ºæ¥ã€‚æ³¨æ„ï¼šé€’å½’çš„ç²¾é«“æ˜¯æè¿°é—®é¢˜ï¼Œè€Œè¿™æ­£æ˜¯å‡½æ•°å¼ç¼–ç¨‹çš„ç²¾é«“ã€‚ å‡½æ•°å¼ç¼–ç¨‹çš„ä¸€äº›å…¶ä»–å¥½å¤„ lazy evaluation æƒ°æ€§æ±‚å€¼ã€‚è¿™ä¸ªéœ€è¦ç¼–è¯‘å™¨çš„æ”¯æŒã€‚è¡¨è¾¾å¼ä¸åœ¨å®ƒè¢«ç»‘å®šåˆ°å˜é‡ä¹‹åŽå°±ç«‹å³æ±‚å€¼ï¼Œè€Œæ˜¯åœ¨è¯¥å€¼è¢«å–ç”¨çš„æ—¶å€™æ±‚å€¼ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œè¯­å¥å¦‚x:=expression determinism ç¡®å®šæ€§.æ‰€è°“ç¡®å®šæ€§çš„æ„æ€å°±æ˜¯åƒæ•°å­¦é‚£æ · f(x) = y ï¼Œè¿™ä¸ªå‡½æ•°æ— è®ºåœ¨ä»€ä¹ˆåœºæ™¯ä¸‹ï¼Œéƒ½ä¼šå¾—åˆ°åŒæ ·çš„ç»“æžœï¼Œè¿™ä¸ªæˆ‘ä»¬ç§°ä¹‹ä¸ºå‡½æ•°çš„ç¡®å®šæ€§ã€‚ å‡½æ•°å¼ç¼–ç¨‹çš„ç‰¹ç‚¹ä¸€ï¼šä¸ä¾èµ–äºŽå¤–éƒ¨çš„æ•°æ®ï¼Œè€Œä¸”ä¹Ÿä¸æ”¹å˜å¤–éƒ¨æ•°æ®çš„å€¼ï¼Œè€Œæ˜¯è¿”å›žä¸€ä¸ªæ–°çš„å€¼ç»™ä½ ã€‚ä½¿ç”¨ä¸‹é¢çš„ä¾‹å­ éžå‡½æ•°å¼çš„ä¾‹å­ï¼š1234int cnt;void increment()&#123; cnt++;&#125; å‡½æ•°å¼çš„ä¾‹å­ï¼š123int increment(int cnt)&#123; return cnt+1;&#125; ç‰¹ç‚¹äºŒï¼šæŠŠå‡½æ•°å½“æˆå˜é‡æ¥ç”¨ï¼Œå…³æ³¨äºŽæè¿°é—®é¢˜è€Œä¸æ˜¯æ€Žä¹ˆå®žçŽ°ï¼Œè¿™æ ·å¯ä»¥è®©ä»£ç æ›´æ˜“è¯»ã€‚ 123name_len = map(len, ["hao", "chen", "coolshell"])print name_len# è¾“å‡º [3, 4, 9] Pythonå¯¹å‡½æ•°å¼ç¼–ç¨‹æä¾›éƒ¨åˆ†æ”¯æŒã€‚ç”±äºŽPythonå…è®¸ä½¿ç”¨å˜é‡ï¼Œå› æ­¤ï¼ŒPythonä¸æ˜¯çº¯å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ã€‚ å°½ç®¡ Python ç®—ä¸ä¸Šæ˜¯ä¸€é—¨çº¯å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ï¼Œä½†å®ƒæœ¬èº«æä¾›äº†å¾ˆå¤šå‡½æ•°å¼ç¼–ç¨‹çš„ç‰¹æ€§ï¼Œåƒ mapã€reduceã€filterã€sorted è¿™äº›å‡½æ•°éƒ½æ”¯æŒå‡½æ•°ä½œä¸ºå‚æ•°ï¼Œlambda å‡½æ•°å°±å¯ä»¥åº”ç”¨åœ¨å‡½æ•°å¼ç¼–ç¨‹ä¸­ã€‚ä»¥ sorted() å‡½æ•°ä¸ºä¾‹ï¼š 123list1 =[3, 4, -4, -1, 0, -2, -6]list1.sort(key =lambda x: abs(x))print(list1) ä¹Ÿæ˜¯å¯ä»¥ä½¿ç”¨ä¼ ç»Ÿçš„æ–¹å¼è¿›è¡Œä¹¦å†™ï¼Œ åªæ˜¯çœ‹èµ·æ¥ä¸å¤Ÿ pythonic è€Œå·²123456def my_add(n): return lambda x: x-nadd_3 =my_add(3) # add_3 æ˜¯ä¸€ç§ lambda å‡½æ•°print(add_3) # å®šä¹‰çš„æ—¶å€™æŠŠ nåˆå§‹åŒ–ä¸ºäº†3print("*****")print(add_3(4)) # 4å¯¹åº”ç€x è¾“å‡ºæ˜¯1ï¼Œ 1234def my_add(n): return lambda x: x+nadd_3 =my_add(3) # add_3 æ˜¯ä¸€ç§ lambda å‡½æ•°print(add_3(4)) # 4å¯¹åº”ç€n å¯ä»¥æ¢æˆå¸¸è§„çš„å‡½æ•°è¡¨ç¤º è¿™ç§å‡½æ•°çš„åµŒå¥—ä¹Ÿæ˜¯å¯ä»¥é€šè¿‡è£…é¥°å™¨å®žçŽ°çš„ã€‚ 1234567def my_add(n): def wrapper(x): return x +n return wrapperadd_5 =my_add(5)print(add_5(2)) ä½†æ˜¯åœ¨å¤„ç†æ¯”è¾ƒå¤æ‚çš„é€»è¾‘æ—¶å€™ï¼Œä¸å»ºè®®ä½¿ç”¨ lambda è¡¨è¾¾å¼ã€‚ é¡ºä¾¿åŠ ä¸Š list comprehension çš„ç†è§£ã€‚å‡½æ•°å¼ç¼–ç¨‹ï¼Œ å¸¸ç”¨çš„è¡¨è¾¾æ˜¯ filter, map ä¹‹ç±»çš„å‡½æ•°ã€‚ä¸‹é¢çš„å¼å­æ˜¯ç­‰ä»·çš„ã€‚ 12odds =map(lambda n : n*2, filter(lambda n: n %2 ==1, numbers))odds =[ n*2 for n in numbers if n %2 ==1] Nested Loops ï¼ˆäºŒé‡å¾ªçŽ¯çš„æ”¯æŒï¼‰ 123456flattened =[]for row in matrix: for n in row: flattened.append(n)# æ³¨æ„éåŽ†çš„é¡ºåºï¼Œ åªæ˜¯æŠŠäºŒé‡å¾ªçŽ¯ flatten çš„å†™æ³•, not readable ä½†æ˜¯å¾—ç†è§£flattened =[n for row in matrix for n in row] # å¦‚æžœåªæ˜¯éåŽ†è¿™æ ·çš„ç®€å•çš„æ“ä½œï¼Œé‚£ä¹ˆè¿™ç§å†™æ³•æ˜¯éžå¸¸é«˜æ•ˆçš„ å¯¹äºŽ set å’Œ dictionary çš„æ”¯æŒ123456789101112# å¯¹äºŽ set çš„æ”¯æŒletters =set()for w in words: letters.add(w[0])letters =&#123; w[0] for w in words&#125;#å¯¹äºŽdictionary çš„æ”¯æŒ ï¼ˆè¿™ä¸ªæ˜¯éžå¸¸ç®€å•çš„æ“ä½œï¼Œ key value å€’ç½®çš„æ“ä½œï¼‰dict1 =&#123;'a':1, 'b':2, 'c':3&#125;#å¯¹äºŽdictionary çš„æ”¯æŒflipped =&#123; value: key for key,value in dict1.items()&#125;print(flipped) é—­åŒ…çš„æ¦‚å¿µ é—­åŒ…(closure)æ˜¯å‡½æ•°å¼ç¼–ç¨‹çš„é‡è¦çš„è¯­æ³•ç»“æž„ã€‚å‡½æ•°å¼ç¼–ç¨‹æ˜¯ä¸€ç§ç¼–ç¨‹èŒƒå¼ (è€Œé¢å‘è¿‡ç¨‹ç¼–ç¨‹å’Œé¢å‘å¯¹è±¡ç¼–ç¨‹ä¹Ÿéƒ½æ˜¯ç¼–ç¨‹èŒƒå¼)ã€‚åœ¨é¢å‘è¿‡ç¨‹ç¼–ç¨‹ä¸­ï¼Œæˆ‘ä»¬è§åˆ°è¿‡å‡½æ•°(function)ï¼›åœ¨é¢å‘å¯¹è±¡ç¼–ç¨‹ä¸­ï¼Œæˆ‘ä»¬è§è¿‡å¯¹è±¡(object)ã€‚å‡½æ•°å’Œå¯¹è±¡çš„æ ¹æœ¬ç›®çš„æ˜¯ä»¥æŸç§é€»è¾‘æ–¹å¼ç»„ç»‡ä»£ç ï¼Œå¹¶æé«˜ä»£ç çš„å¯é‡å¤ä½¿ç”¨æ€§(reusability)ã€‚é—­åŒ…ä¹Ÿæ˜¯ä¸€ç§ç»„ç»‡ä»£ç çš„ç»“æž„ï¼Œå®ƒåŒæ ·æé«˜äº†ä»£ç çš„å¯é‡å¤ä½¿ç”¨æ€§ã€‚å¯ä»¥æŠŠé—­åŒ…ç†è§£æˆè½»é‡çº§çš„æŽ¥å£å°è£…ã€‚ åœ¨è®¡ç®—æœºç§‘å­¦ä¸­ï¼Œé—­åŒ…ï¼ˆClosureï¼‰æ˜¯è¯æ³•é—­åŒ…ï¼ˆLexical Closureï¼‰çš„ç®€ç§°ï¼Œæ˜¯å¼•ç”¨äº†è‡ªç”±å˜é‡çš„å‡½æ•°ã€‚è¿™ä¸ªè¢«å¼•ç”¨çš„è‡ªç”±å˜é‡å°†å’Œè¿™ä¸ªå‡½æ•°ä¸€åŒå­˜åœ¨ï¼Œå³ä½¿å·²ç»ç¦»å¼€äº†åˆ›é€ å®ƒçš„çŽ¯å¢ƒä¹Ÿä¸ä¾‹å¤–ã€‚ å‡½æ•°å†…çš„å‡½æ•°ä»¥åŠå…¶è‡ªç”±å˜é‡å½¢æˆé—­åŒ…ã€‚ä¹Ÿå³é—­åŒ…æ˜¯ä¸€ç§ä¿ç•™å®šä¹‰å‡½æ•°æ—¶å­˜åœ¨çš„è‡ªç”±å˜é‡çš„ç»‘å®šçš„å‡½æ•°ï½žè¿™æ ·åœ¨è°ƒç”¨å‡½æ•°æ—¶ï¼Œç»‘å®šçš„è‡ªç”±å˜é‡ä¾æ—§å¯ç”¨ã€‚ è¦å½¢æˆé—­åŒ…ï¼Œé¦–å…ˆå¾—æœ‰ä¸€ä¸ªåµŒå¥—çš„å‡½æ•°ï¼Œå³å‡½æ•°ä¸­å®šä¹‰äº†å¦ä¸€ä¸ªå‡½æ•°ï¼Œé—­åŒ…åˆ™æ˜¯ä¸€ä¸ªé›†åˆï¼Œå®ƒåŒ…æ‹¬äº†å¤–éƒ¨å‡½æ•°çš„å±€éƒ¨å˜é‡ï¼Œè¿™äº›å±€éƒ¨å˜é‡åœ¨å¤–éƒ¨å‡½æ•°è¿”å›žåŽä¹Ÿç»§ç»­å­˜åœ¨ï¼Œå¹¶èƒ½è¢«å†…éƒ¨å‡½æ•°å¼•ç”¨ã€‚ æŒ‰å˜é‡çš„ä½œç”¨åŸŸè¿›è¡Œåˆ†ç±»ï¼ŒPython ä¸­çš„å˜é‡å¯åˆ†ä¸ºã€Œå…¨å±€å˜é‡ã€ã€ã€Œå±€éƒ¨å˜é‡ã€ä»¥åŠã€Œè‡ªç”±å˜é‡ã€ã€‚ä¸€èˆ¬è€Œè¨€ï¼ŒPython ä¸­ä½¿ç”¨å˜é‡å‰ä¸éœ€è¦å£°æ˜Žå˜é‡ï¼Œä½†å‡å®šåœ¨å‡½æ•°ä½“ä¸­èµ‹å€¼çš„å˜é‡ä¸ºå±€éƒ¨å˜é‡ï½žé™¤éžæ˜¾ç¤ºä½¿ç”¨ global å°†åœ¨å‡½æ•°ä¸­èµ‹å€¼çš„å˜é‡å£°æ˜Žä¸ºå…¨å±€å˜é‡ï¼ è€Œè‡ªç”±å˜é‡åˆ™æ˜¯å­˜åœ¨äºŽåµŒå¥—å‡½æ•°ä¸­çš„ä¸€ä¸ªæ¦‚å¿µï½žå®šä¹‰åœ¨å…¶ä»–å‡½æ•°å†…éƒ¨çš„å‡½æ•°è¢«ç§°ä¹‹ä¸ºåµŒå¥—å‡½æ•° nested function ï¼ŒåµŒå¥—å‡½æ•°å¯ä»¥è®¿é—®å°é—­èŒƒå›´å†…ï¼ˆå¤–éƒ¨å‡½æ•°ï¼‰çš„å˜é‡ã€‚åµŒå¥—å‡½æ•°ä¸å¯ä»¥åœ¨å‡½æ•°å¤–ç›´æŽ¥è®¿é—®ã€‚ åœ¨ Python ä¸­ï¼Œéžæœ¬åœ°å˜é‡é»˜è®¤ä»…å¯è¯»å–ï¼Œåœ¨ä¿®æ”¹æ—¶å¿…é¡»æ˜¾å¼æŒ‡å‡ºå…¶ä¸ºéžæœ¬åœ°å˜é‡ï½žè‡ªç”±å˜é‡ nonlocalï¼Œå…¨å±€å˜é‡ globalã€‚ 1234567def line_conf(): b = 15 def line(x): return 2*x-b return line # return a function objectmy_line = line_conf()print(my_line(10)) åœ¨ Python 3 ä¸­å¼•å…¥äº†ä¸€ä¸ªå…³é”®è¯ nonlocal è§£å†³äº†è¿™ä¸€ä¸ªé—®é¢˜ï¼š 123456789101112something =0 # è¿™ä¸ªæ˜¯å‡½æ•°å¤–éƒ¨çš„å˜é‡def get_avg(): scores = 0 # å°†å¤–éƒ¨ä¸´æ—¶å˜é‡ç”± list æ”¹ä¸ºä¸€ä¸ª æ•´åž‹æ•°å€¼ count = 0 # åŒæ—¶æ–°å¢žä¸€ä¸ªå˜é‡ï¼Œè®°å½•ä¸ªæ•° def inner_count_avg(val): # å†…éƒ¨å‡½æ•°ï¼Œç”¨äºŽè®¡ç®—å¹³å‡å€¼ nonlocal count, scores # è¿™ä¸ªè¡¨ç¤ºæƒ³è¦ä¿®æ”¹å¤–é¢å‡½æ•°å¤–é¢çš„å€¼ scores += val # ä½¿ç”¨å¤–éƒ¨å‡½æ•°çš„ä¸´æ—¶å˜é‡ count += 1 return scores / count # è¿”å›žè®¡ç®—å‡ºçš„å¹³å‡å€¼ return inner_count_avg # å¤–éƒ¨å‡½æ•°è¿”å›žå†…éƒ¨å‡½æ•°å¼•ç”¨avg = get_avg()print(avg(10)) # æŠ¥é”™ æµ…æ˜¾ç†è§£ Python é—­åŒ… ç»™å‡ºäº†ä¸€ä¸ªä¾‹å­è¯´æ˜Ž å½“ä»Žå‘½åç©ºé—´åˆ é™¤å‡½æ•°åä¹‹åŽï¼Œä»ç„¶æ˜¯å¯ä»¥è®¿é—®å…¶å˜é‡ã€‚ ä½¿ç”¨é—­åŒ…æ³¨æ„çš„åœ°æ–¹ é—­åŒ…åªèƒ½è®¿é—®ï¼Œæ— æ³•ä¿®æ”¹å¤–éƒ¨å‡½æ•°çš„å±€éƒ¨å˜é‡ é—­åŒ…å’Œè£…é¥°å™¨ äº‹å®žä¸Šï¼Œè£…é¥°å™¨å°±æ˜¯ä¸€ç§çš„é—­åŒ…çš„åº”ç”¨ï¼Œåªä¸è¿‡å…¶ä¼ é€’çš„æ˜¯å‡½æ•°ã€‚ é—­åŒ…çš„ä½œç”¨ï¼š ï¼ˆä»Žè¿™ä¸ªè§’åº¦ä¸Šçœ‹é—­åŒ…æ›´åƒæ˜¯ä¸€ç§å°åž‹çš„ç±»ï¼Œå®žçŽ°äº†å˜é‡å’Œæ–¹æ³•çš„ç»‘å®šï¼‰é—­åŒ…çš„æœ€å¤§ç‰¹ç‚¹æ˜¯å¯ä»¥å°†çˆ¶å‡½æ•°çš„å˜é‡ä¸Žå†…éƒ¨å‡½æ•°ç»‘å®šï¼Œå¹¶è¿”å›žç»‘å®šå˜é‡åŽçš„å‡½æ•°ï¼ˆä¹Ÿå³é—­åŒ…ï¼‰ï¼Œæ­¤æ—¶å³ä¾¿ç”Ÿæˆé—­åŒ…çš„çŽ¯å¢ƒï¼ˆçˆ¶å‡½æ•°ï¼‰å·²ç»é‡Šæ”¾ï¼Œé—­åŒ…ä»ç„¶å­˜åœ¨ï¼Œè¿™ä¸ªè¿‡ç¨‹å¾ˆåƒç±»ï¼ˆçˆ¶å‡½æ•°ï¼‰ç”Ÿæˆå®žä¾‹ï¼ˆé—­åŒ…ï¼‰ï¼Œä¸åŒçš„æ˜¯çˆ¶å‡½æ•°åªåœ¨è°ƒç”¨æ—¶æ‰§è¡Œï¼Œæ‰§è¡Œå®Œæ¯•åŽå…¶çŽ¯å¢ƒå°±ä¼šé‡Šæ”¾ï¼Œè€Œç±»åˆ™åœ¨æ–‡ä»¶æ‰§è¡Œæ—¶åˆ›å»ºï¼Œä¸€èˆ¬ç¨‹åºæ‰§è¡Œå®Œæ¯•åŽä½œç”¨åŸŸæ‰é‡Šæ”¾ï¼Œå› æ­¤å¯¹ä¸€äº›éœ€è¦é‡ç”¨çš„åŠŸèƒ½ä¸”ä¸è¶³ä»¥å®šä¹‰ä¸ºç±»çš„è¡Œä¸ºï¼Œä½¿ç”¨é—­åŒ…ä¼šæ¯”ä½¿ç”¨ç±»å ç”¨æ›´å°‘çš„èµ„æºï¼Œä¸”æ›´è½»å·§çµæ´»ã€‚ å½“ç„¶ï¼Œé—­åŒ…åœ¨çˆ¬è™«ä»¥åŠwebåº”ç”¨ä¸­éƒ½æœ‰å¾ˆå¹¿æ³›çš„åº”ç”¨ï¼Œå¹¶ä¸”é—­åŒ…ä¹Ÿæ˜¯è£…é¥°å™¨çš„åŸºç¡€ã€‚ MapsMap() is a built-in Python function used to apply a function to a sequence of elements like a list or dictionary. Itâ€™s a very clean and most importantly readable way to perform such an operation.ç›¸å¯¹äºŽ lambda, map ä½¿ç”¨çš„é¢‘çŽ‡æ›´å°‘äº†ã€‚ æœ€åŽè¿”å›žçš„æ˜¯ä¸€ä¸ªlistã€‚ è¿™ä¸ªå‡½æ•°çš„å¼ºå¤§ä¹‹å¤„åœ¨äºŽï¼Œå¯¹äºŽæ¯ä¸€ä¸ªå˜é‡éƒ½æ˜¯åº”ç”¨è¿™ä¸ªfunctionçš„ï¼Œ å±žäºŽelement-wise çš„æ“ä½œã€‚ 1234567891011def square_it_func(a): return a * ax = map(square_it_func, [1, 4, 7])print(x) # prints '[1, 16, 49]'def multiplier_func(a, b): return a * bx = map(multiplier_func, [1, 4, 7], [2, 5, 8])print(x) # prints '[2, 20, 56]' FilteringThe Filter built-in function is quite similar to the Map function in that it applies a function to a sequence (list, tuple, dictionary). The key difference is that filter() will only return the elements which the applied function returned as True. åªæ˜¯è¿”å›žç¬¦åˆæŸç§æ¡ä»¶çš„element 1234567891011 # Our numbersnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]# Function that filters out all numbers which are odddef filter_odd_numbers(num): if num % 2 == 0: return True else: return Falsefiltered_numbers = filter(filter_odd_numbers, numbers)print(filtered_numbers)# filtered_numbers = [2, 4, 6, 8, 10, 12, 14] 123456from itertools import *def check_for_drop(x): print ('Checking: ', x) return (x &gt; 5)for i in dropwhile(check_for_drop, [2, 4, 6, 8, 10, 12]): print ('Result: ', i) Itertoolszip æ˜¯å°†ä¸¤ä¸ªlist åˆå¹¶åˆ°ä¸€å—è¿›è¡Œè®¿é—®ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from itertools import *# zip å°±æ˜¯ä¸€å—è®¿é—®çš„é‚£ç§å½¢å¼ï¼Œè¿”å›žçš„æ˜¯ä¸€ä¸ªtuple æ•°æ®ç±»åž‹# zip ,joing two lists into a list of tuples# Easy joining of two lists into a list of tuplesfor i in zip([1, 2, 3], ['a', 'b', 'c']): print (i)# ('a', 1)# ('b', 2)# ('c', 3)# å°±æ˜¯ä¸€ä¸ªcount() è®¡æ•°åŠŸèƒ½, count() å…ƒç´ åœ¨åˆ—è¡¨ä¸­å‡ºçŽ°çš„æ¬¡æ•° # The count() function returns an interator that # produces consecutive integers, forever. This # one is great for adding indices next to your list # elements for readability and convenience# in python3, no need to import izip, use zip directly# è¿™ä¸ª count() åªæœ‰åœ¨è¿™é‡Œæ‰æœ‰æ„ä¹‰ï¼Œå¦‚æžœåªæ˜¯å•ç‹¬è°ƒç”¨ï¼Œæ²¡æœ‰æ„Ÿè§‰æœ‰å¤šå¤§çš„æ„ä¹‰for i in zip(count(1), ['Bob', 'Emily', 'Joe']): print (i)# (1, 'Bob')# (2, 'Emily')# (3, 'Joe') # check ï¼Œ becomes false for the first time è¿™ä¸ªæ¡ä»¶å¾ˆå…³é”®, å¯ä»¥ç†è§£æˆåªæ˜¯æ‰¾åˆ°ç¬¬ä¸€ä¸ªfalse çš„æ¡ä»¶ï¼Œç„¶åŽå°±ä¸å†æ‰§è¡Œè¯¥å‡½æ•°# The dropwhile() function returns an iterator that returns # all the elements of the input which come after a certain # condition becomes false for the first time. def check_for_drop(x): print 'Checking: ', x return (x &gt; 5)for i in dropwhile(check_for_drop, [2, 4, 6, 8, 10, 12]): print 'Result: ', i# æ³¨æ„ç†è§£è¿™ä¸ªè¾“å‡º# Checking: 2# Result: 2# Result: 4# Result: 6# Result: 8# Result: 10# Result: 12# æˆ‘çš„ç†è§£è¿™ä¸ª groupby å°±å’Œæ•°æ®åº“ä¸­çš„groupby æ˜¯ç›¸åŒçš„æ•ˆæžœ# The groupby() function is great for retrieving bunches# of iterator elements which are the same or have similar # propertiesfrom itertools import groupbythings = [("animal", "bear"), ("animal", "duck"), ("plant", "cactus"), ("vehicle", "speed boat"), ("vehicle", "school bus")]for key, group in groupby(things, lambda x: x[0]): for thing in group: print ("A %s is a %s." % (thing[1], key))#A bear is a animal.#A duck is a animal.#A cactus is a plant.#A speed boat is a vehicle.#A school bus is a vehicle. GeneratorGenerator functions allow you to declare a function that behaves like an iterator, i.e. it can be used in a for loop. This greatly simplifies your code and is much more memory efficient than a simple for loop. 12345678910111213141516numbers = list()# range()for i in range(1000): numbers.append(i + 1)total = sum(numbers)# (2) Using a generatordef generate_numbers(n): num = 0 while num &lt; n: yield num # è¿™ä¸ªyield ä¹‹åŽï¼Œå‡½æ•°å¹¶æ²¡æœ‰ç»“æŸï¼Œä¸åƒ return é‚£ç§å‡½æ•° num += 1total = sum(generate_numbers(1000))print(total)total = sum(range(1000 + 1))print(total) 123456789101112131415161718192021222324252627282930313233# generator çš„ç¬¬ä¸€ç§å®žçŽ° ()g =(x*x for x in range(10))print(next(g))print(next(g))# å®žçŽ°ä¸€ä¸ª image loader# generatorçš„ç¬¬äºŒç§å®žçŽ° yield å…³é”®å­—å®žçŽ°ï¼Œdef read_data(file1): f =open(file1) x =[] y =[] while True: line =f.readline() if not line: break line =line.split() x =line[:-1] y =line[-1] y =map(float, y) data.append(line) return datadef train_data(file1, batch_size): train_x, train_y =read_data(file1) num_batch =len(datas) //batch_size for i in range(num_batch): x = train_x[batch_size*i: batch_size*(i+1)] y =train_y[batch_size*i: batch_size*(i+1)] yield np.array(x), np.array(y)next(train_data(file1, batch_size)) Decoratorç®€å•åœ°è¯´ï¼Œdecoratorå°±åƒä¸€ä¸ªwrapperä¸€æ ·ï¼Œåœ¨å‡½æ•°æ‰§è¡Œä¹‹å‰æˆ–è€…ä¹‹åŽä¿®æ”¹è¯¥å‡½æ•°çš„è¡Œä¸ºï¼Œè€Œæ— éœ€ä¿®æ”¹å‡½æ•°æœ¬èº«çš„ä»£ç ï¼Œè¿™ä¹Ÿæ˜¯ä¿®é¥°å™¨åç§°çš„æ¥ç”±ã€‚æ€»çš„æ¥è¯´ï¼Œdecoratoråœ¨ä½ å¸Œæœ›åœ¨ä¸ä¿®æ”¹å‡½æ•°æœ¬èº«ä»£ç çš„å‰æä¸‹æ‰©å±•å‡½æ•°çš„åŠŸèƒ½æ—¶éžå¸¸æœ‰ç”¨ã€‚ ï¼ˆdecorator å°±ç±»ä¼¼ä¸€ç§åµŒå¥—å‡½æ•°ï¼Œ æ‰§è¡Œçš„æ—¶å€™å…ˆæ˜¯æ‰§è¡Œé‡Œé¢ï¼ŒåŽæ‰§è¡Œå¤–é¢ï¼‰ python ä¸­å‡½æ•°çš„â€äººè®¾â€œ, function ä¹Ÿæ˜¯ä¸€ç§å¯¹è±¡ï¼Œå†…éƒ¨å‡½æ•°å¯ä»¥è®¿é—®å¤–éƒ¨çš„ functionçš„å˜é‡ï¼Œä½†æ˜¯æƒé™æ˜¯â€åªè¯»â€œã€‚ä¸€ä¸ªå‡½æ•°å¯ä»¥è¾“å…¥ä¸€ä¸ªå‡½æ•°ä¹Ÿå¯ä»¥è¿”å›žä¸€ä¸ªå‡½æ•°ã€‚è£…é¥°å™¨ä½¿å¾—ä»£ç å¯ä»¥å¤ç”¨ã€‚åœ¨è°ƒç”¨çš„ä½¿ç”¨ï¼Œå…ˆè°ƒç”¨è£…é¥°å™¨ï¼Œç„¶åŽè°ƒç”¨å‡½æ•°æœ¬èº«ã€‚ ä¸Šé¢çš„è¿‡ç¨‹å¯ä»¥ç®€åŒ–ä¸ºï¼š 1234567891011def get_text(name): return "lorem ipsum, &#123;0&#125; dolor sit amet".format(name)def p_decorate(func): def func_wrapper(name): return "&lt;p&gt;&#123;0&#125;&lt;/p&gt;".format(func(name)) return func_wrappermy_get_text = p_decorate(get_text)print(my_get_text("John")) è¾“å‡ºï¼š1&lt;p&gt;Outputs lorem ipsum, John dolor sit amet \&lt;/p&gt; è¿™å°±æ˜¯æˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªä¿®é¥°å™¨ã€‚ä¸€ä¸ªå‡½æ•°æŽ¥æ”¶å¦ä¸€ä¸ªå‡½æ•°ä½œä¸ºå‚æ•°ï¼Œå¹¶ä¸”äº§ç”Ÿä¸€ä¸ªæ–°çš„å‡½æ•°ï¼Œæ³¨æ„è§‚å¯Ÿæ˜¯å¦‚ä½•è°ƒç”¨å’Œ è°ƒç”¨çš„é¡ºåºï¼Œä½“ä¼š decorator äº§ç”Ÿçš„èƒŒæ™¯ï¼Œæ˜¯å¯ä»¥ç®€åŒ–è¿™ä¸ªè°ƒç”¨è¿‡ç¨‹çš„ã€‚ ä¸‹é¢ä»£ç å’Œä¸Šé¢æ˜¯ç›¸åŒçš„åŠŸèƒ½ï¼Œp_decorate å°±åƒæ˜¯ function get_text() çš„ä¸€ä¸ªå¤–å¥—ï¼Œ å…¶ä½œä¸ºä¸€ç§è¾“å…¥åˆ° p_decorate() ä¸­ã€‚è£…é¥°å™¨é¦–å…ˆæ‰§è¡Œçš„æ˜¯è£…é¥°å™¨éƒ¨åˆ†ï¼Œæœ¬å‡½æ•°ä½œä¸ºä¸€ä¸ªå˜é‡ä½¿ç”¨ï¼Œæœ€åŽè¿”å›žçš„æ˜¯ç»“æžœã€‚ 12345678910def p_decorate(func): def func_wrapper(name): return "&lt;p&gt;&#123;0&#125;&lt;/p&gt;".format(func(name)) return func_wrapper@p_decoratedef get_text(name): return "lorem ipsum, &#123;0&#125; dolor sit amet".format(name)print (get_text("John")) è¾“å‡ºç»“æžœï¼š 1&lt;p&gt;lorem ipsum, John dolor sit amet&lt;/p&gt; åœ¨ç»™ä¸ªä¾‹å­ï¼Œç†è§£è°ƒç”¨è¿‡ç¨‹ã€‚ 123456789def hello_decorator(original_fn): def decorator_fn(): print("Hello from new") original_fn() # original function must be invoked return decorator_fn@hello_decoratordef hello(): print("Hello from original") è¾“å‡ºç»“æžœï¼š12Hello from newHello from original å¦å¤–ï¼Œä¸€ä¸ªå‡½æ•°æ˜¯å¯ä»¥æ·»åŠ å¤šä¸ª ä¿®é¥°å™¨çš„ï¼Œå¹¶ä¸”ä¿®é¥°å™¨çš„é¡ºåºä¹Ÿæ˜¯æœ‰å…³ç³»çš„ã€‚ä¸€ä¸ªå‡½æ•°è¿˜å¯ä»¥åŒæ—¶å®šä¹‰å¤šä¸ªè£…é¥°å™¨ï¼Œæ¯”å¦‚ï¼š 12345@a@b@cdef f (): pass å®ƒçš„æ‰§è¡Œé¡ºåºæ˜¯ä»Žé‡Œåˆ°å¤–ï¼Œæœ€å…ˆè°ƒç”¨æœ€é‡Œå±‚çš„è£…é¥°å™¨ï¼Œæœ€åŽè°ƒç”¨æœ€å¤–å±‚çš„è£…é¥°å™¨ï¼Œå®ƒç­‰æ•ˆäºŽ1f = a(b(c(f))) æ‰§è¡Œé¡ºåºæ˜¯å…ˆæ‰§è¡Œé‡Œé¢çš„ï¼Œä½†æ˜¯é‡Œé¢çš„func ä½œä¸ºä¸€ç§è¾“å…¥åˆ°ä¸‹ä¸€ä¸ªå‡½æ•°ä¸­ï¼Œæ‰€ä»¥æœ€åŽå…ˆæ‰§è¡Œçš„è¿˜æ˜¯â€œå¤–é¢â€å‡½æ•°ã€‚ç±»ä¼¼ä¸æ–­çš„é€’å½’è¿›åŽ»çš„æ„Ÿè§‰ã€‚ æ„Ÿè§‰è£…é¥°å™¨å¾ˆéš¾çš„åŽŸå› åœ¨äºŽæ²¡æœ‰ç†æ¸…å®ƒçš„é€»è¾‘å…³ç³»ï¼Œæœ¬è´¨ä¸Šè£…é¥°å™¨ä¹Ÿæ˜¯å‡½æ•°ï¼Œä½†å®ƒæ˜¯å¯¹æ ¸å¿ƒç¨‹åºçš„é—­åŒ…å°è£…ï¼Œåœ¨åŽŸæœ‰çš„åŸºç¡€ä¸Šå¢žåŠ æ›´å¤šçš„åŠŸèƒ½ã€‚ç»†ç»†å›žé¡¾å‡ éä¸Šé¢çš„ä¾‹å­èƒ½å¤ŸåŠ æ·±å¯¹è£…é¥°å™¨çš„ç†è§£ã€‚ ä½¿ç”¨ä¿®é¥°å™¨å®žçŽ°å•ä¾‹æ¨¡å¼ è®¾è®¡æ¨¡å¼åˆ†æˆå•ä¾‹æ¨¡å¼å’Œå¤šä¾‹æ¨¡å¼ï¼Œå¯¹äºŽå•ä¾‹æ¨¡å¼å¯¹äºŽä¸€ä¸ªç±»åªèƒ½å®žçŽ°ä¸€ä¸ªå®žä¾‹ï¼›å¤šä¾‹æ¨¡å¼å¯ä»¥å®žçŽ°å¤šä¸ªå®žä¾‹ã€‚å•ä¾‹æ˜¯ä¸€ç§è®¾è®¡æ¨¡å¼ï¼Œåº”ç”¨è¯¥æ¨¡å¼çš„ç±»åªä¼šç”Ÿæˆä¸€ä¸ªå®žä¾‹ã€‚è¿™ç§æ–¹å¼æ˜¯å¯ä»¥ä»£æ›¿å…¨å±€å˜é‡çš„ã€‚æ¯”å¦‚ä¸€äº›é…ç½®ã€æ—¥å¿—ç­‰åªéœ€è¦åˆå§‹åŒ–ä¸€æ¬¡çš„æ–‡ä»¶ï¼Œå°±å¯ä»¥ä½¿ç”¨è¿™ç§æ–¹å¼ã€‚ 1234567891011121314151617# å‡½æ•°ä¿®é¥°å™¨å®žçŽ°å•ä¾‹def singleton(cls): _instance =&#123;&#125; def inner(): if cls not in _instance: _instance[cls] =cls return _instance[cls] # å‡½æ•°è°ƒç”¨ return inner@singletonclass Cls(object): def __init__(self): passcls1 =Cls()cls2 =Cls()print(id(cls1) ==id(cls2)) å¸¸è§çš„è‡ªå¸¦çš„ä¿®é¥°å™¨ã€‚ Pythonä¸­ çš„ @classmethod å’Œ @staticmethod åœ¨å¯¹è±¡çš„å®žä¾‹æ–¹æ³•ä¸­ï¼Œself å‚æ•°æ˜¯ç±»å®žä¾‹å¯¹è±¡æœ¬èº«ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥å¯¹å®žä¾‹æ•°æ®è¿›è¡Œä¸€äº›æ“ä½œã€‚@classmethod æ–¹æ³•ä¹Ÿæœ‰ä¸€ä¸ªå¼ºåˆ¶æ€§çš„ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œå®ƒè¡¨ç¤ºçš„æ˜¯æœªå®žä¾‹åŒ–çš„ç±»æœ¬èº«ï¼Œè€Œéžç±»çš„å®žä¾‹ã€‚ 1234567class Student(object): @classmethod def from_string(cls, name_str): first_name, last_name = map(str, name_str.split(' ')) student = cls(first_name, last_name) return studentscott = Student.from_string('Scott Robinson') @staticmethod è£…é¥°å™¨ @staticmethod è£…é¥°ç±»ä¼¼äºŽ@classmethod ï¼Œå®ƒèƒ½å¤Ÿä»Žä¸€ä¸ªéžå®žä¾‹ç±»å¯¹è±¡è¢«è°ƒç”¨ï¼Œä½†æ˜¯æ²¡æœ‰ä¼ é€’ cls å‚æ•°ã€‚ 1234567class Student(object): @staticmethod def is_full_name(name_str): names = name_str.split(' ') return len(names) &gt; 1Student.is_full_name('Scott Robinson') # True Student.is_full_name('Scott') # False ç”±äºŽæ²¡æœ‰ self ä¼ é€’ä»»ä½•å¯¹è±¡ï¼Œè¿™æ„å‘³ç€æ­¤è£…é¥°å™¨æ–¹æ³•æ— æ³•è®¿é—®ä»»ä½•å®žä¾‹æ•°æ®ï¼Œå¹¶ä¸”ä¹Ÿæ— æ³•åœ¨å®žä¾‹åŒ–å¯¹è±¡ä¸Šè°ƒç”¨æ­¤æ–¹æ³•ã€‚è¿™äº›ç±»åž‹çš„æ–¹æ³•é€šå¸¸ä¸æ˜¯ä¸ºäº†åˆ›å»º/å®žä¾‹åŒ–å¯¹è±¡ï¼Œå®ƒä»¬æ˜¯ä¸ºäº†å¤„ç†ä¸€äº›ä¸Žç±»æœ¬èº«æœ‰å…³çš„é€»è¾‘ã€‚ List Comprehensionå¸¸è§çš„å‡ ç§å½¢å¼ï¼š(An iterable is something you can loop over) list comprehensions vs loops: list comprehensions are more efficient both computationally and coding space Every list comprehension can be rewritten as a for loop, but not every for loop can be rewritten as a list comprehension. ä»Žä¼˜åŒ–çš„è§’åº¦ list comprehensionsæ˜¯ä¼˜äºŽ for loop ä¸­çš„if else æ“ä½œçš„ã€‚å› ä¸ºå‰è€…æ˜¯ predicatable pattern æ˜¯å¯ä»¥é¢„æµ‹çš„ã€‚However, keep in mind that list comprehensions are faster because they are optimized for the Python interpreter to spot a predictable pattern during looping. a small code demo:åœ¨äºŽä½¿ç”¨åŠŸèƒ½ timeit libary è¿›è¡Œå‡½æ•°çš„è®¡æ—¶æ¯”è¾ƒã€‚12345678910111213import timeitdef squares(size): result = [] for number in range(size): result.append(number * number) return resultdef squares_comprehension(size): return [number * number for number in range(size)] print(timeit.timeit("squares(50)", "from __main__ import squares", number=1_000_000))print(timeit.timeit("squares_comprehension(50)", "from __main__ import squares_comprehension", number=1_000_000)) more complex list comprehensions: è¿™ç§if çš„å†™æ³• æ˜¯ä¸¤ä¸ªè¿›è¡Œå¹¶åˆ—çš„ã€‚å…¶å®žå¯ä»¥å†™æˆ 123456numbers = [1, 2, 3, 4, 5, 6, 18, 20]squares = [number for number in numbers if number % 2 == 0 if number % 3 == 0]# orsquares = [number for number in numbers if number % 2 == 0 and number % 3 == 0]print(squares)# output: [6, 18] åœ¨ output expression ä¸­ï¼Œä¹Ÿæ˜¯å¯ä»¥ä½¿ç”¨ if else è¿›è¡Œè¿›ä¸€æ­¥è¾“å‡ºç­›é€‰ã€‚12345numbers = [1, 2, 3, 4, 5, 6, 18, 20] squares = ["small" if number &lt; 10 else "big" for number in numbers if number % 2 == 0 if number % 3 == 0] print(squares)ouput: ['small', 'big'] converting nested loops into list comprehensionä»£ç åŠŸèƒ½ï¼š éƒ½æ˜¯æŠŠäºŒç»´çš„ matrix è½¬æˆäº†ä¸€ä¸ª list ï¼ˆflattenedï¼‰123456matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]flattened = []for row in matrix: for item in row: flattened.append(item)print(flattened) æ³¨æ„è¿™ä¸ªé¡ºåºï¼Œå…ˆæ˜¯row in matrix ç„¶åŽæ˜¯ item in row.ï¼ˆå¯¹äºŽè¿™ä¸ªé¡ºåºçš„ç†è§£ï¼Œå…¶å®žæ˜¯å¯ä»¥çœ‹æˆäºŒé‡å¾ªçŽ¯çš„ï¼‰ 123matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]flattened = [item for row in matrix for item in row] print(flattened) ouput matric from nested list comprehensions:12matrix = [[item for item in range(5)] for row in range(3)]print(matrix) å¯¹äºŽ dictionary çš„æ”¯æŒï¼š ä¸»è¦æ˜¯ dict1.items() å’Œ key, value çš„ä½¿ç”¨ã€‚è¿˜æœ‰ä¸€ç§å®žçŽ°æ–¹å¼ zip(list1, list2)123prices = &#123;"beer": 2, "fish": 5, "apple": 1&#125;float_prices = &#123;key:float(value) for key, value in prices.items()&#125;print(float_prices) ä»Žä»£ç çš„è§’åº¦ï¼Œå¯ä»¥çœ‹å‡ºï¼Œæ“ä½œå’Œæœ€åŽçš„è¿”å›žçš„å½¢å¼æ˜¯æ²¡æœ‰å¾ˆå¤§çš„å…³ç³»ï¼Œä¸Šé¢æ˜¯ [], è¿™ä¸ªæ˜¯ {}, åˆ†åˆ«å¯¹åº”çš„æ˜¯ list å’Œ set ä¸¤ç§ä¸åŒçš„æ ¼å¼ã€‚123numbers = [10, 10, 20, 30, 12, -20, 0, 1]unique_squares = &#123;number**2 for number in numbers&#125;print(unique_squares) ContainersPython includes several built-in container types: lists, dictionaries, sets, and tuples. lists A list is the Python equivalent of an array, but is resizeable and can contain elements of different types: 12x = xs.pop() # Remove and return the last element of the listprint x, xs In addition to accessing list elements one at a time, Python provides concise syntax to access sublists; this is known as slicing: 123456789nums = range(5) # range is a built-in function that creates a list of integersprint nums # Prints "[0, 1, 2, 3, 4]"print nums[2:4] # Get a slice from index 2 to 4 (exclusive); prints "[2, 3]"print nums[2:] # Get a slice from index 2 to the end; prints "[2, 3, 4]"print nums[:2] # Get a slice from the start to index 2 (exclusive); prints "[0, 1]"print nums[:] # Get a slice of the whole list; prints ["0, 1, 2, 3, 4]"print nums[:-1] # Slice indices can be negative; prints ["0, 1, 2, 3]"nums[2:4] = [8, 9] # Assign a new sublist to a sliceprint nums # Prints "[0, 1, 8, 9, 4]" dictionary A dictionary stores (key, value) pairs, similar to a Map in Java or an object in Javascript. You can use it like this: 123d = &#123;'cat': 'cute', 'dog': 'furry'&#125; # Create a new dictionary with some dataprint d.get('monkey', 'N/A') # Get an element with a default; prints "N/A"print d.get('fish', 'N/A') # Get an element with a default; prints "wet" sets A set is an unordered collection of distinct elements. As a simple example, consider the following: 123456789101112animals = &#123;'cat', 'dog'&#125;animals.add('fish') # Add an element to a setprint len(animals) # Number of elements in a set;animals.remove('cat') # Remove an element from a setprint len(animals)animals = &#123;'cat', 'dog', 'fish'&#125;for idx, animal in enumerate(animals): print '#%d: %s' % (idx + 1, animal)# Prints "#1: fish", "#2: dog", "#3: cat" tuples A tuple is an (immutable) ordered list of values. A tuple is in many ways similar to a list; one of the most important differences is that tuples can be used as keys in dictionaries and as elements of sets, while lists cannot. Here is a trivial example: 12345d = &#123;(x, x + 1): x for x in range(10)&#125; # Create a dictionary with tuple keyst = (5, 6) # Create a tupleprint type(t)print d[t] print d[(1, 2)] å…ƒç»„ç±»ä¼¼äºŽåˆ—è¡¨ï¼Œæ˜¯ä¸€ä¸ªåŸºäºŽä½ç½®çš„æœ‰åºå¯¹è±¡é›†åˆï¼Œä½†æ˜¯å…ƒç»„ä¸€æ—¦åˆ›å»ºä¹‹åŽå°±ä¸èƒ½æ›´æ”¹ï¼Œå› æ­¤åˆ—è¡¨ä¸­ä¿®æ”¹å…ƒç´ çš„æ“ä½œå¯¹äºŽå…ƒç»„éƒ½ä¸é€‚ç”¨ã€‚ å…ƒç»„å’Œå…¶ä»–ä¸å¯å˜é‡ç±»ä¼¼äºŽå…¶ä»–è¯­è¨€ä¸­â€œå¸¸é‡â€çš„å£°æ˜Žï¼Œå®ƒçš„ä¸å¯å˜æ€§æä¾›äº†æŸç§ä¸€è‡´æ€§ï¼Œè¿™æ ·å¯ä»¥ç¡®ä¿å…ƒç»„åœ¨ç¨‹åºä¸­ä¸ä¼šè¢«å¦ä¸€ä¸ªå¼•ç”¨ä¿®æ”¹ã€‚Mark Lutzâ€”â€”ã€ŠLearning Pythonã€‹ä¸­æ–‡ç‰ˆ æ³¨æ„ï¼Œdictå†…éƒ¨å­˜æ”¾çš„é¡ºåºå’Œkeyæ”¾å…¥çš„é¡ºåºæ˜¯æ²¡æœ‰å…³ç³»çš„ã€‚å’Œlistæ¯”è¾ƒï¼Œdictæœ‰ä»¥ä¸‹å‡ ä¸ªç‰¹ç‚¹ï¼š æŸ¥æ‰¾å’Œæ’å…¥çš„é€Ÿåº¦æžå¿«ï¼Œä¸ä¼šéšç€keyçš„å¢žåŠ è€Œå¢žåŠ ï¼› éœ€è¦å ç”¨å¤§é‡çš„å†…å­˜ï¼Œå†…å­˜æµªè´¹å¤šã€‚è€Œlistç›¸åï¼š æŸ¥æ‰¾å’Œæ’å…¥çš„æ—¶é—´éšç€å…ƒç´ çš„å¢žåŠ è€Œå¢žåŠ ï¼› å ç”¨ç©ºé—´å°ï¼Œæµªè´¹å†…å­˜å¾ˆå°‘ã€‚æ‰€ä»¥ï¼Œdictæ˜¯ç”¨ç©ºé—´æ¥æ¢å–æ—¶é—´çš„ä¸€ç§æ–¹æ³•ã€‚ dictå¯ä»¥ç”¨åœ¨éœ€è¦é«˜é€ŸæŸ¥æ‰¾çš„å¾ˆå¤šåœ°æ–¹ï¼Œåœ¨Pythonä»£ç ä¸­å‡ ä¹Žæ— å¤„ä¸åœ¨ï¼Œæ­£ç¡®ä½¿ç”¨dictéžå¸¸é‡è¦ï¼Œéœ€è¦ç‰¢è®°çš„ç¬¬ä¸€æ¡å°±æ˜¯dictçš„keyå¿…é¡»æ˜¯ä¸å¯å˜å¯¹è±¡ã€‚è¿™æ˜¯å› ä¸ºdictæ ¹æ®keyæ¥è®¡ç®—valueçš„å­˜å‚¨ä½ç½®ï¼Œå¦‚æžœæ¯æ¬¡è®¡ç®—ç›¸åŒçš„keyå¾—å‡ºçš„ç»“æžœä¸åŒï¼Œé‚£dictå†…éƒ¨å°±å®Œå…¨æ··ä¹±äº†ã€‚è¿™ä¸ªé€šè¿‡keyè®¡ç®—ä½ç½®çš„ç®—æ³•ç§°ä¸ºå“ˆå¸Œç®—æ³•ï¼ˆHashï¼‰ã€‚è¦ä¿è¯hashçš„æ­£ç¡®æ€§ï¼Œä½œä¸ºkeyçš„å¯¹è±¡å°±ä¸èƒ½å˜ã€‚åœ¨Pythonä¸­ï¼Œå­—ç¬¦ä¸²ã€æ•´æ•°ç­‰éƒ½æ˜¯ä¸å¯å˜çš„ï¼Œå› æ­¤ï¼Œå¯ä»¥æ”¾å¿ƒåœ°ä½œä¸ºkeyã€‚è€Œlistæ˜¯å¯å˜çš„ï¼Œå°±ä¸èƒ½ä½œä¸ºkeyã€‚ ä½¿ç”¨zipå‡½æ•°, æŠŠkeyå’Œvalueçš„listç»„åˆåœ¨ä¸€èµ·, å†è½¬æˆå­—å…¸(dict). 1234keys = ['a', 'b', 'c']values = [1, 2, 3]dictionary = dict(zip(keys, values))print dictionary åˆ›å»ºåŒæ ·å¤§å°çš„listå’Œtupleï¼Œå¯ä»¥çœ‹åˆ°listçš„æ—¶é—´å¼€é”€å‡ ä¹Žæ˜¯tupleçš„10å€ã€‚å¯¹ä¸¤ä¸ªå¤§è¡¨è¿›è¡ŒéåŽ†ï¼Œtupleä¸Žlisté€Ÿåº¦ç›¸ä¼¼ã€‚å‚¨å­˜åŒæ ·å…ƒç´ çš„listå’Œtupleï¼Œ listæœ‰æ›´å¤šç©ºé—´å¼€é”€ã€‚tupleæ˜¯ immutable, æ‰€ä»¥å®ƒæ˜¯å¯å“ˆå¸Œçš„(hashable)çš„ã€‚è¿™ä½¿å¾—tupleå¯ä»¥ä½œä¸ºdictçš„keyï¼Œæˆ–è€…æ‰”è¿›seté‡Œï¼Œliståˆ™ä¸è¡Œã€‚ åœ¨Pythonä¸­ï¼šlistã€setå’Œdictionary éƒ½æ˜¯å¯æ”¹å˜çš„ï¼Œæ¯”å¦‚å¯ä»¥é€šè¿‡list.append()ï¼Œset.remove()ï¼Œdict[â€˜keyâ€™] = valueå¯¹å…¶è¿›è¡Œä¿®æ”¹ï¼Œæ‰€ä»¥å®ƒä»¬éƒ½æ˜¯ä¸å¯å“ˆå¸Œçš„ï¼›è€Œtupleå’Œstringæ˜¯ä¸å¯å˜çš„ï¼Œåªå¯ä»¥åšå¤åˆ¶æˆ–è€…åˆ‡ç‰‡ç­‰æ“ä½œï¼Œæ‰€ä»¥å®ƒä»¬å°±æ˜¯å¯å“ˆå¸Œçš„ã€‚ å› ä¸ºlist ä¸­æ²¡æœ‰ __hash__ è¿™ä¸ªå‡½æ•°ï¼Œæ‰€ä»¥ä¸æ˜¯hashableçš„ï¼Œä½†æ˜¯ä¸ºä»€ä¹ˆå‘¢ï¼Ÿè¿™ä¸ªè§£é‡Šå¯èƒ½æ›´åŠ æœ¬è´¨æ·±å…¥ä¸€äº›ï¼šPython ä¸ºä»€ä¹ˆlistä¸èƒ½ä½œä¸ºå­—å…¸çš„keyï¼Ÿ namedtuple tupleæ˜¯ä¸å¯å˜åºåˆ—ï¼Œå½“ä½ ä¸å¸Œæœ›å¤–ç•Œå¯ä»¥éšæ„çš„æ”¹å˜ä½ çš„å‡½æ•°è¿”å›žå€¼çš„æ—¶å€™ï¼Œä¸å¦¨å°†ä½ çš„è¿”å›žå€¼ä»¥tupleçš„å½¢å¼è¿”å›žï¼Œtupleè¿˜å¯ä»¥åšä¸ºå­—å…¸çš„keyï¼Œè¿™äº›éƒ½æ˜¯tupleçš„ç‹¬åˆ°ä¹‹å¤„ï¼Œæ­¤å¤–ï¼Œç”±äºŽå­˜å‚¨çš„æ–¹å¼ä¸åŒï¼Œç›¸åŒå…ƒç´ çš„tuple è¦æ¯”listæ›´å¿«ï¼Œä½¿ç”¨çš„å†…å­˜æ›´å°‘ã€‚tupleè™½ç„¶æœ‰è¿™ä¹ˆå¤šä¼˜ç‚¹ï¼Œä½†æ˜¯å‘¢ï¼Œåœ¨ä½¿ç”¨çš„æ—¶å€™ï¼Œä½ ä¸å¾—ä¸ç”¨ä¸‹è§’æ ‡æ¥è®¿é—®å®ƒçš„å…ƒç´ ï¼Œè¿™æ ·å¯¹äºŽä»£ç çš„å¯è¯»æ€§æ¥è¯´æ˜¯ä¸€ç§æŠ˜æŸã€‚namedtupleå¼¥è¡¥äº†tupleçš„è¿™ä¸€ç¼ºé™·ï¼Œä½¿å¾—ä½ å¯ä»¥åƒä½¿ç”¨å¯¹è±¡å±žæ€§é‚£æ ·åŽ»è®¿é—®æ•°æ®. namedtupleèƒ½å¤Ÿç”¨æ¥åˆ›å»ºç±»ä¼¼äºŽå…ƒç¥–çš„æ•°æ®ç±»åž‹ï¼Œé™¤äº†èƒ½å¤Ÿç”¨ç´¢å¼•æ¥è®¿é—®æ•°æ®ï¼Œèƒ½å¤Ÿè¿­ä»£ï¼Œæ›´èƒ½å¤Ÿæ–¹ä¾¿çš„é€šè¿‡å±žæ€§åæ¥è®¿é—®æ•°æ®ã€‚è¿™ä¸ªç›¸å½“äºŽæ˜¯ tuple å’Œdictionary çš„ç»¼åˆä½“ã€‚ä¸»è¦è¿™ä¸ªå€¼æ˜¯åªè¯»çš„ï¼Œä¸èƒ½ä¿®æ”¹ã€‚ 12345from collections import namedtupleAnimals =nametuple('Animal', 'name age type')big_yellow =Animals(name ='big_yellow', age=3, type=â€˜dogâ€™)// è®¿é—®çš„è¯ä½¿ç”¨ big_yellow.name numpyArrays A numpy array is a grid of values, all of the same type, and is indexed by a tuple of nonnegative integers. 1234a = np.array([1, 2, 3]) # Create a rank 1 arrayprint type(a), a.shape, a[0], a[1], a[2]a[0] = 5 # Change an element of the arrayprint a 1234567891011121314a = np.zeros((2,2)) # Create an array of all zerosprint ab = np.ones((1,2)) # Create an array of all onesprint bc = np.full((2,2), 7) # Create a constant arrayprint cd = np.eye(2) # Create a 2x2 identity matrixprint de = np.random.random((2,2)) # Create an array filled with random valuesprint e Boolean array indexing: Boolean array indexing lets you pick out arbitrary elements of an array. Frequently this type of indexing is used to select the elements of an array that satisfy some condition. Here is an example: 12345678910import numpy as npa = np.array([[1,2], [3, 4], [5, 6]])bool_idx = (a &gt; 2) # Find the elements of a that are bigger than 2; # this returns a numpy array of Booleans of the same # shape as a, where each slot of bool_idx tells # whether that element of a is &gt; 2.print bool_idx Array math Basic mathematical functions operate elementwise on arrays, and are available both as operator overloads and as functions in the numpy module: 12345678910111213141516171819202122232425262728x = np.array([[1,2],[3,4]], dtype=np.float64)y = np.array([[5,6],[7,8]], dtype=np.float64)# Elementwise sum; both produce the arrayprint x + yprint np.add(x, y)# Elementwise difference; both produce the arrayprint x - yprint np.subtract(x, y)# Elementwise product; both produce the arrayprint x * yprint np.multiply(x, y)# Elementwise division; both produce the array# [[ 0.2 0.33333333]# [ 0.42857143 0.5 ]]print x / yprint np.divide(x, y)# Elementwise square root; produces the array# [[ 1. 1.41421356]# [ 1.73205081 2. ]]print np.sqrt(x) Note that unlike MATLAB, * is elementwise multiplication, not matrix multiplication. We instead use the dot function to compute inner products of vectors, to multiply a vector by a matrix, and to multiply matrices. dot is available both as a function in the numpy module and as an instance method of array objects: 1234567891011121314151617x = np.array([[1,2],[3,4]])y = np.array([[5,6],[7,8]])v = np.array([9,10])w = np.array([11, 12])# Inner product of vectors; both produce 219print v.dot(w)print np.dot(v, w)x = np.array([[1,2],[3,4]])print np.sum(x) # Compute sum of all elements; prints "10"print np.sum(x, axis=0) # Compute sum of each column; prints "[4 6]"print np.sum(x, axis=1) # Compute sum of each row; prints "[3 7]"print xprint x.T Broadcasting Broadcasting is a powerful mechanism that allows numpy to work with arrays of different shapes when performing arithmetic operations. Frequently we have a smaller array and a larger array, and we want to use the smaller array multiple times to perform some operation on the larger array. For example, suppose that we want to add a constant vector to each row of a matrix. We could do it like this: 12345678import numpy as np# We will add the vector v to each row of the matrix x,# storing the result in the matrix yx = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])v = np.array([1, 0, 1])y = x + v # Add v to each row of x using broadcastingprint y 12345678# Compute outer product of vectorsv = np.array([1,2,3]) # v has shape (3,)w = np.array([4,5]) # w has shape (2,)# To compute an outer product, we first reshape v to be a column# vector of shape (3, 1); we can then broadcast it against w to yield# an output of shape (3, 2), which is the outer product of v and w:print np.reshape(v, (3, 1)) * w (å¯¹äºŽç¬¬ 4 ç‚¹è¿˜æ˜¯æŒºæœ‰è¶£çš„ï¼Œ å¤šçœ‹çœ‹ï¼Œå…¶å®žä¸æ˜¯å¾ˆæ‡‚)Broadcasting two arrays together follows these rules: If the arrays do not have the same rank, prepend the shape of the lower rank array with 1s until both shapes have the same length. The two arrays are said to be compatible in a dimension if they have the same size in the dimension, or if one of the arrays has size 1 in that dimension. The arrays can be broadcast together if they are compatible in all dimensions. After broadcasting, each array behaves as if it had shape equal to the elementwise maximum of shapes of the two input arrays. In any dimension where one array had size 1 and the other array had size greater than 1, the first array behaves as if it were copied along that dimension å¥½å¥½ç†è§£è¿™å‡ ä¸ªä¾‹å­ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142# Compute outer product of vectorsv = np.array([1,2,3]) # v has shape (3,)w = np.array([4,5]) # w has shape (2,)# To compute an outer product, we first reshape v to be a column# vector of shape (3, 1); we can then broadcast it against w to yield# an output of shape (3, 2), which is the outer product of v and w:print np.reshape(v, (3, 1)) * w# Add a vector to each row of a matrixx = np.array([[1,2,3], [4,5,6]])# x has shape (2, 3) and v has shape (3,) so they broadcast to (2, 3),# giving the following matrix:print x + v# Add a vector to each column of a matrix# x has shape (2, 3) and w has shape (2,).# If we transpose x then it has shape (3, 2) and can be broadcast# against w to yield a result of shape (3, 2); transposing this result# yields the final result of shape (2, 3) which is the matrix x with# the vector w added to each column. Gives the following matrix:print (x.T + w).T# Another solution is to reshape w to be a row vector of shape (2, 1);# we can then broadcast it directly against x to produce the same# output.print x + np.reshape(w, (2, 1)):# Multiply a matrix by a constant:# x has shape (2, 3). Numpy treats scalars as arrays of shape ();# these can be broadcast together to shape (2, 3), producing the# following array:print x * 2 Matplotlib 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import matplotlib.pyplot as plt# Compute the x and y coordinates for points on a sine curvex = np.arange(0, 3 * np.pi, 0.1)y = np.sin(x)# Plot the points using matplotlibplt.plot(x, y)# æœ‰ x y è½´çš„y_cos = np.cos(x)# Plot the points using matplotlibplt.plot(x, y_sin)plt.plot(x, y_cos)plt.xlabel('x axis label')plt.ylabel('y axis label')plt.title('Sine and Cosine')plt.legend(['Sine', 'Cosine'])# subplots çš„å›¾åƒ# Compute the x and y coordinates for points on sine and cosine curvesx = np.arange(0, 3 * np.pi, 0.1)y_sin = np.sin(x)y_cos = np.cos(x)# Set up a subplot grid that has height 2 and width 1,# and set the first such subplot as active.plt.subplot(2, 1, 1)# Make the first plotplt.plot(x, y_sin)plt.title('Sine')# Set the second subplot as active, and make the second plot.plt.subplot(2, 1, 2)plt.plot(x, y_cos)plt.title('Cosine')# Show the figure.plt.show()]]></content>
      <categories>
        <category>CSåŸºç¡€</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Naive Bayes Classifier]]></title>
    <url>%2F2019%2F07%2F22%2Fnaive-bayes%2F</url>
    <content type="text"><![CDATA[ä»Žè´å¶æ–¯å®šç†åˆ° naive bayes åˆ†ç±»å™¨ï¼Œæœ€åŽè¯´æ˜Žä¸€ä¸‹å…¶åº”ç”¨å’Œä¼˜ç¼ºç‚¹ã€‚ åœ¨æ‰€æœ‰çš„æœºå™¨å­¦ä¹ åˆ†ç±»ç®—æ³•ä¸­ï¼Œæœ´ç´ è´å¶æ–¯å’Œå…¶ä»–ç»å¤§å¤šæ•°çš„åˆ†ç±»ç®—æ³•éƒ½ä¸åŒã€‚å¯¹äºŽå¤§å¤šæ•°çš„åˆ†ç±»ç®—æ³•ï¼Œæ¯”å¦‚å†³ç­–æ ‘,KNN,é€»è¾‘å›žå½’ï¼Œæ”¯æŒå‘é‡æœºç­‰ï¼Œä»–ä»¬éƒ½æ˜¯åˆ¤åˆ«æ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯ç›´æŽ¥å­¦ä¹ å‡ºç‰¹å¾è¾“å‡º$ Y$å’Œç‰¹å¾ $X $ä¹‹é—´çš„å…³ç³»ï¼Œè¦ä¹ˆæ˜¯å†³ç­–å‡½æ•° $ð‘Œ=ð‘“(ð‘‹) $ï¼ˆæ¯”å¦‚æ”¯æŒå‘é‡æœºï¼‰,è¦ä¹ˆæ˜¯æ¡ä»¶åˆ†å¸ƒ $ð‘ƒ(ð‘Œ|ð‘‹) $ï¼ˆæ¯”å¦‚é€»è¾‘å›žå½’ï¼‰ã€‚ä½†æ˜¯æœ´ç´ è´å¶æ–¯å´æ˜¯ç”Ÿæˆæ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯ç›´æŽ¥æ‰¾å‡ºç‰¹å¾è¾“å‡º $Y $å’Œç‰¹å¾ $X $çš„è”åˆåˆ†å¸ƒ $ð‘ƒ(ð‘‹,ð‘Œ) $,ç„¶åŽç”¨ $ð‘ƒ(ð‘Œ|ð‘‹)= \frac{ð‘ƒ(ð‘‹,ð‘Œ)}{ð‘ƒ(ð‘‹) }$å¾—å‡ºã€‚ æœ´ç´ è´å¶æ–¯è´å¶æ–¯å­¦æ´¾çš„æ€æƒ³å¯ä»¥æ¦‚æ‹¬ä¸ºå…ˆéªŒæ¦‚çŽ‡+æ•°æ®=åŽéªŒæ¦‚çŽ‡ã€‚ä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬åœ¨å®žé™…é—®é¢˜ä¸­éœ€è¦å¾—åˆ°çš„åŽéªŒæ¦‚çŽ‡ï¼Œå¯ä»¥é€šè¿‡å…ˆéªŒæ¦‚çŽ‡å’Œæ•°æ®ä¸€èµ·ç»¼åˆå¾—åˆ°ã€‚å…ˆéªŒæ¦‚çŽ‡å°±æ˜¯æˆ‘ä»¬å¯¹äºŽæ•°æ®æ‰€åœ¨é¢†åŸŸçš„åŽ†å²ç»éªŒï¼Œä½†æ˜¯è¿™ä¸ªç»éªŒå¸¸å¸¸éš¾ä»¥é‡åŒ–æˆ–è€…æ¨¡åž‹åŒ–ï¼ŒäºŽæ˜¯è´å¶æ–¯å­¦æ´¾å¤§èƒ†çš„å‡è®¾å…ˆéªŒåˆ†å¸ƒçš„æ¨¡åž‹ï¼Œæ¯”å¦‚æ­£æ€åˆ†å¸ƒï¼Œbetaåˆ†å¸ƒç­‰ã€‚ï¼ˆå› ä¸ºåœ¨æ²¡æœ‰è®¡ç®—ä¹‹å‰å°±è®¤ä¸ºæ•°æ®æœä»ŽæŸä¸ªåˆ†å¸ƒï¼Œæ‰€ä»¥è¢«ç§°ä¸ºå…ˆéªŒæ¦‚çŽ‡ï¼‰ è´å¶æ–¯å…¬å¼ï¼š $$P(Y | X)=\frac{P(X | Y) P(Y)}{P(X)}$$ å…ˆéªŒæ¦‚çŽ‡ $P(X) $ï¼šå…ˆéªŒæ¦‚çŽ‡æ˜¯æŒ‡æ ¹æ®ä»¥å¾€ç»éªŒå’Œåˆ†æžå¾—åˆ°çš„æ¦‚çŽ‡ã€‚ åŽéªŒæ¦‚çŽ‡ $P(Y|X) $ï¼šäº‹æƒ…å·²ç»å‘ç”Ÿï¼Œè¦æ±‚è¿™ä»¶äº‹æƒ…å‘ç”Ÿçš„åŽŸå› æ˜¯ç”±æŸä¸ªå› ç´ å¼•èµ·çš„å¯èƒ½æ€§çš„å¤§å°ï¼ŒåŽéªŒåˆ†å¸ƒ $P(Y|X) $è¡¨ç¤ºäº‹ä»¶ $X $å·²ç»å‘ç”Ÿçš„å‰æä¸‹ï¼Œäº‹ä»¶ $Y $å‘ç”Ÿçš„æ¦‚çŽ‡ï¼Œå«åšäº‹ä»¶ $X $å‘ç”Ÿä¸‹äº‹ä»¶ $Y $çš„æ¡ä»¶æ¦‚çŽ‡ã€‚ï¼ˆæ‰§æžœç´¢å› ï¼‰ åŽéªŒæ¦‚çŽ‡ $P(X|Y) $ï¼šåœ¨å·²çŸ¥Yå‘ç”ŸåŽXçš„æ¡ä»¶æ¦‚çŽ‡ï¼Œä¹Ÿç”±äºŽçŸ¥é“ $Y $çš„å–å€¼è€Œè¢«ç§°ä¸º $X $çš„åŽéªŒæ¦‚çŽ‡ æœ´ç´ ï¼šæœ´ç´ è´å¶æ–¯ç®—æ³•æ˜¯å‡è®¾å„ä¸ªç‰¹å¾ä¹‹é—´ç›¸äº’ç‹¬ç«‹ï¼Œä¹Ÿæ˜¯æœ´ç´ è¿™è¯çš„æ„æ€é‚£ä¹ˆè´å¶æ–¯å…¬å¼ä¸­çš„ $P(X|Y) $å¯å†™æˆï¼š $$P(X | Y)=P\left(x_{1} | Y\right) P\left(x_{2} | Y\right) \cdots P\left(x_{n} | Y\right)$$ å…¨æ¦‚çŽ‡å…¬å¼ï¼š$$P(X)=\sum_{k} P\left(X | Y=Y_{k}\right)$$å…¶ä¸­ $\sum_{k} P(Y_k) =1$ æ‰€ä»¥ï¼Œå°†ä¸Šé¢çš„å¼å­æ•´åˆèµ·æ¥ï¼Œå¾—åˆ°æœ´ç´ è´å¶æ–¯å…¬å¼ï¼š $$P(Y | X)=\frac{P(X | Y_k) P(Y_k)}{\sum_{k} P(X | Y=Y_{k})}$$ ä¸‰ç§å¸¸è§çš„è´å¶æ–¯æ¨¡åž‹ä¸Šæ–‡æåˆ°äº†å…ˆéªŒæ¦‚çŽ‡æ¨¡åž‹ï¼Œè¿™é‡Œä¸»è¦ä»‹ç»å¤šé¡¹å¼æ¨¡åž‹ï¼ˆMultinomialNBï¼‰ã€é«˜æ–¯æ¨¡åž‹ï¼ˆGaussianNBï¼‰å’Œä¼¯åŠªåˆ©æ¨¡åž‹ï¼ˆBernoulliNBï¼‰ã€‚ å¤šé¡¹å¼æ¨¡åž‹ï¼ˆMultinomialNBï¼‰ å¤šé¡¹å¼æœ´ç´ è´å¶æ–¯å¸¸ç”¨è¯­æ–‡æœ¬åˆ†ç±»ï¼Œç‰¹å¾æ˜¯å•è¯ï¼Œå€¼æ—¶å•è¯å‡ºçŽ°çš„æ¬¡æ•°ã€‚å¤šé¡¹å¼æ¨¡åž‹åœ¨è®¡ç®—å…ˆéªŒæ¦‚çŽ‡ $P(Y_k) $å’Œå’Œæ¡ä»¶æ¦‚çŽ‡ $P(X_i|Y_k) $æ—¶ï¼Œä¼šåšå‡ºä¸€äº›å¹³æ»‘å¤„ç†ï¼ˆæ‹‰æ™®æ‹‰æ–¯å¹³æ»‘ï¼‰ï¼Œå…·ä½“å…¬å¼ä¸ºï¼š$$P\left(Y_{k}\right)=\frac{N_{Y_{k}}+\alpha}{N+K \alpha}$$ $N$ï¼šæ ·æœ¬æ•° $N_{Y_k} $ï¼šç±»åˆ«ä¸º$Y_k$çš„æ ·æœ¬æ•° $K$ï¼šæ€»çš„ç±»åˆ«ä¸ªæ•° $\alpha$ï¼šå¹³æ»‘å€¼ $$P\left(x_{i} | Y_{k}\right)=\frac{N_{Y_{k}, x_{i}}+\alpha}{N_{Y_{k}}+n \alpha}$$ $N_{Y_{k}, x_{i}}$ï¼šç±»åˆ«ä¸º$Y_k $ï¼Œä¸”ç‰¹å¾ä¸º$X_i$çš„æ ·æœ¬æ•° $n$ï¼šç‰¹å¾$X_i $å¯ä»¥é€‰æ‹©çš„æ•°é‡ é«˜æ–¯æ¨¡åž‹ï¼ˆGaussianNBï¼‰ å½“ç‰¹å¾æ˜¯è¿žç»­å˜é‡çš„æ—¶å€™ï¼Œå‡è®¾ç‰¹å¾åˆ†å¸ƒä¸ºæ­£æ€åˆ†å¸ƒï¼Œæ ¹æ®æ ·æœ¬ç®—å‡ºå‡å€¼å’Œæ–¹å·®ï¼Œå†æ±‚å¾—æ¦‚çŽ‡ã€‚ å¯ä»¥å‚è€ƒè¿™é‡Œ. ä¼¯åŠªåˆ©æ¨¡åž‹ï¼ˆBernoulliNBï¼‰ä¼¯åŠªåˆ©æ¨¡åž‹é€‚ç”¨äºŽç¦»æ•£ç‰¹å¾çš„æƒ…å†µï¼Œä¼¯åŠªåˆ©æ¨¡åž‹ä¸­æ¯ä¸ªç‰¹å¾çš„å–å€¼åªèƒ½æ˜¯1å’Œ0ã€‚ å¯ä»¥å‚è€ƒè¿™é‡Œ æœ´ç´ è´å¶æ–¯åˆ†ç±»çš„åŽŸç†å’Œæµç¨‹æ€»ä½“çš„å…¬å¼ï¼š$$ p(ç±»åˆ« | ç‰¹å¾) = \frac {p(ç±»åˆ«) * pç‰¹å¾|ç±»åˆ«ï¼‰}{p(ç‰¹å¾)}$$ è®¾ç‰¹å¾ $x = { a _ { 1 } , a _ { 2 } , \ldots , a _ { m } }$ï¼Œ å…¶ä¸­ x æ˜¯ä¸€æ¡æ•°æ®ï¼Œ $a_i$ æ˜¯ä¸€ä¸ªç‰¹å¾å±žæ€§ã€‚ æœ‰ç±»åˆ«ä¿¡æ¯ $C = { y _ { 1 } , y _ { 2 } , \ldots , y _ { n } }$ è®¡ç®— $P ( y _ { 1 } | x ) , P ( y _ { 2 } | x ) , \ldots , P ( y _ { n } | x )$ å¦‚æžœ $P ( y _ { k } | x ) = \max { P ( y _ { 1 } | x ) , P ( y _ { 2 } | x ) , \ldots , P ( y _ { n } | x ) }$ï¼Œ é‚£ä¹ˆ $x \in y _ { k }$. æ‰€ä»¥çŽ°åœ¨çš„å…³é”®æ­¥éª¤æ˜¯å¦‚ä½•è®¡ç®—ç¬¬ 3 æ­¥éª¤ä¸­çš„å„ä¸ªæ¡ä»¶æ¦‚çŽ‡ã€‚å¯ä»¥è¿™æ ·åšï¼Œ æ‰¾åˆ°ä¸€ä¸ªå·²çŸ¥åˆ†ç±»çš„å¾…åˆ†ç±»é¡¹é›†åˆï¼Œè¿™ä¸ªé›†åˆå«åšè®­ç»ƒæ ·æœ¬é›†ã€‚ ç»Ÿè®¡å¾—åˆ°åœ¨å„ç±»åˆ«ä¸‹å„ä¸ªç‰¹å¾å±žæ€§çš„æ¡ä»¶æ¦‚çŽ‡ä¼°è®¡ $P \left( a _ { 1 } | y _ { 1 } \right) , P \left( a _ { 2 } | y _ { 1 } \right) , \ldots , P \left( a _ { m } | y _ { 1 } \right) ;P \left( a _ { 1 } | y _ { 2 } \right) , P \left( a _ { 2 } | y _ { 2 } \right) , \ldots , P \left( a _ { m } | y _ { 2 } \right) ;\ldots ; P \left( a _ { 1 } | y _ { n } \right) , P \left( a _ { 2 } | y _ { n } \right) , \ldots , P \left( a _ { m } | y _ { n } \right)$ å¦‚æžœå„ä¸ªç‰¹å¾å±žæ€§æ˜¯æ¡ä»¶ç‹¬ç«‹çš„ï¼Œåˆ™æ ¹æ®è´å¶æ–¯å®šç†æœ‰å¦‚ä¸‹æŽ¨å¯¼ $$P \left( y _ { i } | x \right) = \frac { P \left( x | y _ { i } \right) P \left( y _ { i } \right) } { P ( x ) }$$ å› ä¸ºåˆ†æ¯å¯¹äºŽæ‰€æœ‰ç±»åˆ«ä¸ºå¸¸æ•°ï¼Œå› ä¸ºæˆ‘ä»¬åªè¦å°†åˆ†å­æœ€å¤§åŒ–çš†å¯ã€‚åˆå› ä¸ºå„ç‰¹å¾å±žæ€§æ˜¯æ¡ä»¶ç‹¬ç«‹çš„ï¼Œæ‰€ä»¥æœ‰ï¼š$$P \left( x | y _ { i } \right) P \left( y _ { i } \right) = P \left( a _ { 1 } | y _ { i } \right) P \left( a _ { 2 } | y _ { i } \right) \ldots P \left( a _ { m } | y _ { i } \right) P \left( y _ { i } \right) = P \left( y _ { i } \right) \prod _ { j = 1 } ^ { m } P \left( a _ { j } | y _ { i } \right)$$ å¦‚æžœå†è®¡ç®—è¿‡ç¨‹ä¸­æŸä¸ªæ¦‚çŽ‡å€¼ä¸º0ï¼Œé‚£ä¹ˆæ˜¯å¯ä»¥è€ƒè™‘æ‹‰æ™®æ‹‰æ–¯å¹³æ»‘ã€‚ä¸¤ä¸ªæ¦‚çŽ‡è®¡ç®—å…¬å¼ï¼Œåˆ†å­å’Œåˆ†æ¯éƒ½åˆ†åˆ«åŠ ä¸Šä¸€ä¸ªå¸¸æ•°ï¼Œå°±å¯ä»¥é¿å…è¿™ä¸ªé—®é¢˜ã€‚ åº”ç”¨æœ´ç´ è´å¶æ–¯çš„æ€æƒ³åŸºç¡€æ˜¯è¿™æ ·çš„ï¼šå¯¹äºŽç»™å‡ºçš„å¾…åˆ†ç±»é¡¹ï¼Œæ±‚è§£åœ¨æ­¤é¡¹å‡ºçŽ°çš„æ¡ä»¶ä¸‹å„ä¸ªç±»åˆ«å‡ºçŽ°çš„æ¦‚çŽ‡ï¼Œå“ªä¸ªæœ€å¤§ï¼Œå³è®¤ä¸ºæ­¤å¾…åˆ†ç±»é¡¹å±žäºŽå“ªä¸ªç±»åˆ«ã€‚é€‚ç”¨åœºæ™¯ï¼š ç®—æ³•æ¯”è¾ƒç®€å•ï¼Œåœ¨å¤§æ ·æœ¬ä¸‹ä¼šæœ‰æ¯”è¾ƒå¥½çš„è¡¨çŽ° å¯¹ç¼ºçœæ•°æ®ä¸å¤ªæ•æ„Ÿ å…·æœ‰æ”¯æŒå¢žé‡å¼è®­ç»ƒçš„èƒ½åŠ›ï¼ˆä¸å€ŸåŠ©äºŽæ—§æœ‰è®­ç»ƒæ•°æ®ï¼Œæ¯ä¸€ç»„æ–°çš„è®­ç»ƒæ•°æ®éƒ½æœ‰å¯èƒ½å¼•èµ·æ¦‚çŽ‡å€¼çš„å˜åŒ–ï¼Œè€Œå¦‚å†³ç­–æ ‘å’Œæ”¯æŒå‘é‡æœºï¼Œåˆ™éœ€è¦æˆ‘ä»¬ä¸€æ¬¡æ€§å°†æ•´ä¸ªæ•°æ®é›†éƒ½ä¼ ç»™å®ƒä»¬ã€‚ï¼‰å¯¹äºŽä¸€ä¸ªå¦‚åžƒåœ¾é‚®ä»¶è¿‡æ»¤è¿™æ ·çš„åº”ç”¨ç¨‹åºè€Œè¨€ï¼Œæ”¯æŒå¢žé‡å¼è®­ç»ƒçš„èƒ½åŠ›æ˜¯éžå¸¸é‡è¦çš„ï¼Œå› ä¸ºè¿‡æ»¤ç¨‹åºæ—¶å¸¸è¦å¯¹æ–°åˆ°çš„é‚®ä»¶è¿›è¡Œè®­ç»ƒï¼Œç„¶åŽå¿…é¡»å³å¯è¿›è¡Œç›¸åº”çš„è°ƒæ•´ï¼›æ›´ä½•å†µï¼Œè¿‡æ»¤ç¨‹åºä¹Ÿæœªå¿…æœ‰æƒé™è®¿é—®å·²ç»æ”¶åˆ°çš„æ‰€æœ‰é‚®ä»¶ä¿¡æ¯ã€‚ ç¼ºç‚¹ï¼š ä¸é€‚åˆè¾“å…¥çš„å‘é‡æœ‰å¾ˆå¼ºçš„ç‰¹å¾å…³è”çš„åœºæ™¯ æ— æ³•å¤„ç†åŸºäºŽç‰¹å¾å€¼ç»„åˆæ‰€äº§ç”Ÿçš„å˜åŒ–ç»“æžœã€‚ä¾‹å¦‚ï¼šâ€œåœ¨çº¿â€å’Œâ€œè¯åº—â€åˆ†å¼€å‡ºçŽ°æ—¶ä¸€èˆ¬å‡ºçŽ°åœ¨æ­£å¸¸é‚®ä»¶ä¸­ï¼Œä½†å½“ç»„åˆèµ·æ¥æ—¶â€œåœ¨çº¿è¯åº—â€å´ä¸€èˆ¬å‡ºçŽ°åœ¨åžƒåœ¾é‚®ä»¶ä¸­ï¼Œè´å¶æ–¯åˆ†ç±»å™¨æ— æ³•ç†è§£è¿™ç§ç‰¹å¾ç»„åˆã€‚ å®ƒç»å¸¸è¢«ç”¨äºŽæ–‡æœ¬åˆ†ç±»ä¸­ï¼ŒåŒ…æ‹¬äº’è”ç½‘æ–°é—»çš„åˆ†ç±»ï¼Œåžƒåœ¾é‚®ä»¶çš„ç­›é€‰ã€‚]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>naive bayes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown å’Œlatex å¸¸è§çš„å‘½ä»¤]]></title>
    <url>%2F2019%2F07%2F21%2Fmarkdown-latex%2F</url>
    <content type="text"><![CDATA[ä¸»è¦è®°å½•æ€»ç»“ latex åœ¨markdown ä¸­çš„ä½¿ç”¨ï¼Œé˜²ä¸¢å¤±ã€‚ latex å•ç‹¬ä½¿ç”¨å’Œ åœ¨markdown ä¸­çš„ä½¿ç”¨è¿˜æ˜¯ä¸å¤ªä¸€æ ·çš„ï¼Œæ‰€ä»¥è®°ä¸‹å¸¸ç”¨çš„å‡ ä¸ªã€‚ å¤šè¡Œå…¬å¼å¯¹é½ æºç ï¼š 1234567$$\begin&#123;split&#125;a &amp;= b \\\\c &amp;= d \\\\e &amp;= f \end&#123;split&#125;\tag&#123;1.3&#125;$$ æ•ˆæžœå¦‚ä¸‹ï¼š$$\begin{split}a &amp;= b \\c &amp;= d \\e &amp;= f\end{split}\tag{1.1}$$ åˆ†æ®µå‡½æ•° æºç ï¼š 1234$$ BP = \begin&#123;cases&#125;1 &amp; c &gt;r \\\\e ^ &#123; ( 1 - r / c ) &#125; &amp; c &lt;= r\end&#123;cases&#125;$$ æ•ˆæžœå¦‚ä¸‹ï¼š$$ BP = \begin{cases}1 &amp; c &gt;r \\e ^ { ( 1 - r / c ) } &amp; c &lt;= r\end{cases}\tag{1.2}$$ markdown é¡µå†…è·³è½¬ æºç 123&lt;center&gt; &lt;span id=&apos;jump&apos;&gt; å›¾ 1 &lt;/span&gt;&lt;/center&gt; å¦‚[å›¾ 1](#jump) ï¼Œå½“ test error å¢žåŠ çš„æ—¶å€™ï¼Œé‚£ä¹ˆæ¨¡åž‹å°±åº”è¯¥åœæ­¢äº†ã€‚ è¡¨æ ¼ tableæºç ï¼š12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | æ•ˆæžœå¦‚ä¸‹ï¼š Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 markdown ä¸­çš„å›¾ç‰‡å¤§å°çš„è®¾å®š æºç ï¼š 12&lt;img src=&quot;https://upload.cc/i1/2019/08/09/ApFiTC.png&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt; çŸ©é˜µä¹¦å†™ $${\left[ \begin{matrix} v_{1}^{T} \ v_{2}^{T} \end{matrix} \right] \cdotv_{1} =\left[ \begin{matrix} v_{1}^{T} \cdot v_{1} \ v_{2}^{T} \cdot v_{1} \end{matrix} \right] =\left[ \begin{matrix} 1 \ 0 \end{matrix} \right] \quad\left[ \begin{matrix} v_{1}^{T} \ v_{2}^{T} \end{matrix} \right] \cdotv_{2} =\left[ \begin{matrix} v_{1}^{T} \cdot v_{2} \ v_{2}^{T} \cdot v_{2} \end{matrix} \right] =\left[ \begin{matrix} 0 \ 1 \end{matrix} \right]}$$å¯¹åº”çš„æºç ï¼š 12345678910$$&#123;\left[ \begin&#123;matrix&#125; v_&#123;1&#125;^&#123;T&#125; \\ v_&#123;2&#125;^&#123;T&#125; \end&#123;matrix&#125; \right] \cdot v_&#123;1&#125; = \left[ \begin&#123;matrix&#125; v_&#123;1&#125;^&#123;T&#125; \cdot v_&#123;1&#125; \\ v_&#123;2&#125;^&#123;T&#125; \cdot v_&#123;1&#125; \end&#123;matrix&#125; \right] =\left[ \begin&#123;matrix&#125; 1 \\ 0 \end&#123;matrix&#125; \right] \quad\left[ \begin&#123;matrix&#125; v_&#123;1&#125;^&#123;T&#125; \\ v_&#123;2&#125;^&#123;T&#125; \end&#123;matrix&#125; \right] \cdot v_&#123;2&#125; = \left[ \begin&#123;matrix&#125; v_&#123;1&#125;^&#123;T&#125; \cdot v_&#123;2&#125; \\ v_&#123;2&#125;^&#123;T&#125; \cdot v_&#123;2&#125; \end&#123;matrix&#125; \right] =\left[ \begin&#123;matrix&#125; 0 \\ 1 \end&#123;matrix&#125; \right]&#125;$$ å…³äºŽçŸ©é˜µä¹¦å†™æ›´å¤šçš„æ ·å¼å‚è€ƒè¿™é‡Œã€‚æºç åœ¨æœ¬åœ°ã€‚ å›¾ç‰‡çš„åŽ‹ç¼©ï¼Œhexo ä¸­æä¾›äº†å¯¹äºŽ img æ ‡ç­¾çš„æ”¯æŒï¼Œæ‰€ä»¥å¯ä»¥è¿™æ ·å†™1&lt;img src=&quot;&quot; width=&quot;80%&quot; height=&quot;80%&quot;&gt;` æ•ˆæžœæ˜¯è¿™æ ·çš„ï¼š]]></content>
      <categories>
        <category>NOT_FOR_YOU</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Recursive & Recursion]]></title>
    <url>%2F2019%2F07%2F17%2Frecursive-recursion%2F</url>
    <content type="text"><![CDATA[é€’å½’å®žçŽ°æŒ‡æ•°åž‹æžšä¸¾ ä»Ž 1~n è¿™ n ä¸ªæ•´æ•°ä¸­éšæœºé€‰å–ä»»æ„å¤šä¸ªï¼Œè¾“å‡ºæ‰€æœ‰å¯èƒ½çš„é€‰æ‹©æ–¹æ¡ˆã€‚ åŽŸé¢˜è¿žæŽ¥ é€’æŽ¨ï¼š ç¬¦åˆäººçš„æ€è·¯ï¼Œæ¯”å¦‚ç”±å‰ä¸¤é¡¹è®¡ç®—ç¬¬ä¸‰é¡¹ï¼Œæ±‚è§£æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼Œé€’å½’ï¼šä»ŽåŽå¾€å‰ç®—ï¼ŒæŠŠä¸€ä¸ªå¤§çš„é—®é¢˜åˆ†è§£æˆå°çš„é—®é¢˜ï¼Œç„¶åŽè®¡ç®—å°çš„é—®é¢˜ï¼Œæœ€åŽæŠŠæ‰€æœ‰çš„ç»“æžœæ•´åˆèµ·æ¥ã€‚ä»Žé€’å½’è½¬æˆéžé€’å½’ï¼Œè¿™ä¸ªæœ‰æ—¶å€™æ¯”è¾ƒéº»çƒ¦ï¼Œä½†æ˜¯æœ‰æ—¶å€™å¿…é¡»è¿™ä¹ˆåšï¼Œå› ä¸ºå¯èƒ½é€’å½’çš„å½¢å¼å¯èƒ½é€ æˆæ ˆæº¢å‡ºã€‚ dfs å°±æ˜¯ç±»ä¼¼ä¸€ç§æ ‘çš„ç»“æž„ï¼Œæ¯æ¬¡åˆ†æ”¯éƒ½ç±»ä¼¼ä¸¤ç§é€‰æ‹©ï¼Œæœ€åŽçš„å¶å­èŠ‚ç‚¹å°±æ˜¯æ–¹æ¡ˆä»Žç¬¬0ä¸ªæ•°å­—å¼€å§‹æžšä¸¾ï¼Œ state è¡¨ç¤ºçŠ¶æ€ä½ç½®ï¼Œä½¿ç”¨äºŒè¿›åˆ¶è¡¨ç¤ºï¼Œå¦‚æžœæ˜¯äºŒè¿›åˆ¶æ˜¯1 é‚£ä¹ˆè¡¨ç¤ºå½“å‰çš„æ•°å­—æ˜¯å­˜åœ¨çš„å¦‚æžœæ˜¯0 åˆ™è¡¨ç¤ºä¸å­˜åœ¨çš„ 1234567891011121314151617181920212223242526272829// å› ä¸ºæ•°æ®é‡æ¯”è¾ƒå° 2^15 å°±ç®—æ˜¯ä¸‰ä¸‡å§, æ‰€ä»¥ç›´æŽ¥dfs()#include&lt;iostream&gt;using namespace std;int n; // å®šä¹‰å…¨å±€å˜é‡æ˜¯ä¸ç”¨åœ¨é€’å½’ä¸­ä¼ ä¸‹åŽ»äº†void dfs(int u, int state )&#123; // è¾¹ç•Œæ¡ä»¶ if (u ==n) &#123; for(int i =0; i&lt;n ;i++) if( state &gt;&gt; i &amp;1) cout &lt;&lt; i+1 &lt;&lt;" "; cout &lt;&lt; endl; return ; &#125; dfs(u+1, state); dfs(u+1, state | 1 &lt;&lt;u);&#125;int main()&#123; cin &gt;&gt;n; // æžšä¸¾çš„å½“å‰çš„æ•°å­— å’ŒçŠ¶æ€è¡¨ç¤ºï¼ˆè¿™ä¸ªçŠ¶æ€æ˜¯å¯ä»¥ä½¿ç”¨ æ•°ç»„æ¥è¡¨ç¤ºï¼Œä½†æ˜¯è¿™é‡ŒäºŒè¿›åˆ¶æ¥è¡¨ç¤ºï¼‰ dfs(0 , 0); return 0;&#125; é€’å½’å®žçŽ°ç»„åˆåž‹æžšä¸¾ ä»Ž 1~n è¿™ n ä¸ªæ•´æ•°ä¸­éšæœºé€‰å‡º m ä¸ªï¼Œè¾“å‡ºæ‰€æœ‰å¯èƒ½çš„é€‰æ‹©æ–¹æ¡ˆã€‚ è¾“å‡ºæ ¼å¼ æŒ‰ç…§ä»Žå°åˆ°å¤§çš„é¡ºåºè¾“å‡ºã€‚ ç¬¬ä¸€ä¸ªå‚æ•°è¡¨ç¤ºå½“å‰æžšä¸¾åˆ°äº†å“ªä¸ªæ•°å­—ï¼Œç¬¬äºŒä¸ªå‚æ•°è¡¨ç¤ºé€‰äº†å¤šå°‘ä¸ªæ•°å­—ï¼Œç¬¬ä¸‰ä¸ªå‚æ•°è¡¨ç¤ºé€‰æ‹©äº†å“ªäº›æ•°å­—ï¼ˆäºŒè¿›åˆ¶æ•°ï¼Œæ˜¯0 è¡¨ç¤ºæ²¡æœ‰é€‰ï¼Œæ˜¯ 1è¡¨ç¤ºé€‰æ‹©äº†ï¼‰ã€‚ 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;int n, m;void dfs(int v, int sum, int state)&#123; //è¾¹ç•Œæ¡ä»¶ if (sum + n-v &lt; m) return ; // ä¸€ç§æ–¹æ¡ˆæ•° if (sum ==m) &#123; for (int i =0; i&lt;n ;i++) //è¿™ä¸ªæ˜¯éåŽ†æ€»æ•°ä¸ªçš„ï¼Œå› ä¸ºå…¶ä¸­æœ‰çš„æ˜¯é€‰æ‹©æœ‰çš„æ˜¯ä¸é€‰æ‹©çš„ if (state &gt;&gt;i &amp;1 ) cout &lt;&lt; i+1 &lt;&lt;" "; cout &lt;&lt;endl; return ; &#125; // ä»Žå°åˆ°å¤§æŽ’åºï¼Œæ‰€ä»¥å°½å¯èƒ½çš„é€‰æ‹©ï¼Œè¿™æ ·å‰é¢çš„æ˜¯æ¯”è¾ƒå°çš„ dfs(v +1, sum +1, state | 1 &lt;&lt;v); dfs(v +1, sum , state); &#125;int main()&#123; cin &gt;&gt; n&gt;&gt; m; dfs(0, 0, 0); // åˆå§‹åŒ– return 0;&#125; æŽ’åˆ—ä¸Žç»„åˆçš„å…±åŒç‚¹æ˜¯ä»Ž n ä¸ªä¸åŒçš„å…ƒç´ ä¸­ï¼Œä»»å– m ä¸ªå…ƒç´ ï¼Œä¸åŒç‚¹åœ¨äºŽæŽ’åˆ—æ˜¯æŒ‰ç…§ä¸€å®šçš„é¡ºåºæŽ’æˆä¸€åˆ—ï¼Œç»„åˆæ˜¯æ— è®ºæ€Žæ ·çš„é¡ºåºå¹¶æˆä¸€ç»„ã€‚å› æ­¤ï¼Œâ€œæœ‰åºâ€ å’Œâ€œæ— åºâ€ æ˜¯åŒºåˆ†æŽ’åˆ—å’Œç»„åˆçš„é‡è¦æ ‡å¿—ã€‚ é€’å½’å®žçŽ°æŽ’åˆ—åž‹æžšä¸¾ æŠŠ 1~n è¿™ nä¸ªæ•´æ•°æŽ’æˆä¸€è¡ŒåŽéšæœºæ‰“ä¹±é¡ºåºï¼Œè¾“å‡ºæ‰€æœ‰å¯èƒ½çš„æ¬¡åºã€‚ è¿™ä¸ªæ˜¯æœ‰åºçš„ï¼Œæ‰€ä»¥ä¸èƒ½åªæ˜¯ä¸€ä¸ª äºŒè¿›åˆ¶æ•°è¿›è¡Œåˆ¤æ–­ï¼Œåº”è¯¥ä½¿ç”¨æ•°ç»„è¿›è¡Œä¿å­˜ç»“æžœã€‚ 123456789101112131415161718192021222324252627282930313233343536// å› ä¸ºæ˜¯æœ‰é¡ºåºçš„ï¼Œæ‰€ä»¥ä½¿ç”¨path è¿›è¡Œä¿å­˜ç»“æžœï¼Œ// è¿˜æ˜¯ä½¿ç”¨ä¸€ä¸ª äºŒè¿›åˆ¶æ•°å­— è¡¨ç¤ºæ˜¯å¦é€‰æ‹©è¿‡#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int n;vector&lt;int&gt; path;void dfs(int u, int state)&#123; //è·³å‡ºæ¡ä»¶ if (u ==n) &#123; for(auto x : path) cout &lt;&lt; x&lt;&lt; " "; cout &lt;&lt;endl; return; &#125; for(int i =0 ; i&lt;n ;i++) &#123; if ( !( state &gt;&gt; i &amp;1)) // å¦‚æžœæ²¡æœ‰éåŽ†è¿‡ï¼Œé‚£ä¹ˆå°±è®¿é—® &#123; path.push_back(i+1); // åŠ å…¥åˆ°path ä¸­ dfs(u+1, state | 1 &lt;&lt;i); path.pop_back(); // è¿”å›žåˆ°çŽ°åœº &#125; &#125;&#125;int main()&#123; cin &gt;&gt;n; dfs(0, 0); //ä»Ž 0å¼€å§‹æžšä¸¾ï¼Œä½¿ç”¨äºŒè¿›åˆ¶æ•°å­—è¿›è¡Œæ ‡è®°æ˜¯å¦å‡ºçŽ°è¿‡ return 0;&#125; è´¹è§£çš„å¼€å…³ åŽŸé¢˜è¿™ä¸ªé¢˜ç›®æœ‰ç‚¹éš¾äº† 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int INF = 1000000;char g[10][10];// ä¸Šä¸€è¡Œçš„æŸä¸€ä¸ªä½ç½®ä¸º0 é‚£ä¹ˆä¸‹ä¸€è¡Œçš„å¯¹åº”çš„ä½ç½®å°±è¦ç½®ä¸º1ï¼Œå¦åˆ™ä¸Šä¸€è¡Œå°±ä¸èƒ½å˜äº†ã€‚// æ‰€ä»¥åŸºæœ¬çš„æ€è·¯å°±æ˜¯å›ºå®šå‰4è¡Œï¼Œåˆ¤æ–­ç¬¬5 è¡Œå¦‚æžœå…¨éƒ¨æ˜¯1 é‚£ä¹ˆå°±æ˜¯èƒ½å¤Ÿå˜æˆ1ï¼Œå¦åˆ™è¯¥æ–¹æ¡ˆå°±ä¸æˆç«‹ã€‚// å¯¹äºŽturn çš„å°çš„æŠ€å·§// ä¸­é—´ï¼Œ ä¸Š å³è¾¹ ä¸‹é¢ï¼Œå·¦è¾¹// ä¸­é—´ ä¸Šé¢ å³è¾¹ ä¸‹é¢ å·¦è¾¹// è¿™ä¸ªåªè¦ä¿è¯å½“å‰çš„ä¸å˜ï¼Œint dx[5] =&#123; 0, 1, 0, -1, 0&#125;, dy[5] =&#123;0, 0, -1, 0, 1&#125;;void turn(int x, int y)&#123; for(int i =0; i &lt;5; i++) &#123; int a =x +dx[i], b = y+ dy[i]; if( a&gt;= 0 &amp;&amp; a&lt; 5 &amp;&amp; b&gt;=0 &amp;&amp; b&lt;5) g[a][b] ^=1; //å¯¹äºŽ01 ç›¸äº’è½¬æ¢ï¼Œè¿™ç§æ“ä½œæ˜¯å¯è¡Œçš„ &#125;&#125;int work()&#123; int ans =INF; for (int k =0; k&lt; 1&lt;&lt;5; k++) &#123; int res =0; char backup[10][10]; memcpy(backup, g, sizeof(g)); // å¤‡ä»½ g åˆ° backup for(int j =0; j&lt; 5 ; j++) if (k &gt;&gt; j &amp;1) &#123; res ++; turn(0, j); &#125; for(int i =0; i&lt;4; i++) &#123; for(int j =0; j&lt;5 ;j++) if(g[i][j] =='0') &#123; res ++; turn(i+1, j); &#125; &#125; bool is_successful =true; for(int j =0; j&lt;5 ;j++) if( g[4][j]== '0') &#123; is_successful =false; break; &#125; if(is_successful) ans =min(ans, res); memcpy(g, backup, sizeof(g)); &#125; if (ans &gt;6) ans =-1; return ans; &#125;int main()&#123; int T; cin &gt;&gt; T; while( T --) &#123; for(int i =0; i &lt;5; i++) cin &gt;&gt; g[i]; // ç±»ä¼¼è¡Œå‘é‡çš„æ„Ÿè§‰,g æ˜¯ä¸€ä¸ªäºŒç»´çš„å‘é‡ cout &lt;&lt; work() &lt;&lt;endl; &#125; return 0;&#125; ä»£ç æ˜¯é”™è¯¯çš„ï¼Œä½†æ˜¯ä¸Šé¢çš„æ³¨é‡Šæ˜¯æ­£ç¡®çš„ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int INF =100000;char g[10][10];// ä¸­é—´ï¼Œ ä¸Š å³è¾¹ ä¸‹é¢ï¼Œå·¦è¾¹// ä¸­é—´ ä¸Šé¢ å³è¾¹ ä¸‹é¢ å·¦è¾¹int dx[5] =&#123;0, 1, 0, -1, 0&#125;, dy[5] =&#123;0, 0, -1, 0, 1&#125;;void turn(int x, int y)&#123; for(int i =0; i&lt;5 ;i++) &#123; int a =x +dx[i], b =y+dy[i]; if(a &gt;=0 &amp;&amp; a&lt;5 &amp;&amp; b&gt;=0 &amp;&amp; b&lt;5 ) g[a][b] ^=1; &#125; &#125;int work()&#123; int ans =INF; for(int k =0; k&lt; 1&lt;&lt;5; k++) &#123; int res =0; // å½“å‰æ–¹æ¡ˆçš„æ“ä½œæ•° char backup[10][10]; // å¦‚æžœä½ backup ä¸€å®šæ˜¯åœ¨æŸä¸ªæ—¶é—´ç‚¹æ˜¯ç”¨äºŽæ¢å¤çš„ memcpy(backup, g, sizeof(g)); // å…ˆæŠŠç¬¬ä¸€è¡Œæžšä¸¾æ“ä½œå®Œï¼Œç„¶åŽå›ºå®šç¬¬ä¸€è¡Œ for(int j =0; j&lt;5; j++) &#123; res ++; if(k &gt;&gt;j &amp;1) turn(0,j); // ä¸ºä»€ä¹ˆæ˜¯1çš„æ—¶å€™ï¼Œéœ€è¦turn ä¸€ä¸‹ï¼Œä¸æ˜¯0å—ï¼Ÿ &#125; // å›ºå®šäº†ç¬¬ä¸€è¡Œï¼Œç„¶åŽéåŽ†å‰4 è¡Œ for(int i =0; i&lt;4; i++) &#123; for(int j =0; j&lt;5; j++) if( g[i][j] =='0') &#123; res ++; turn(i +1, j); &#125; &#125; bool is_successful =true; for(int j =0; j&lt;5; j++) if( g[4][j] =='0') &#123; is_successful =false; break; &#125; if( is_successful) ans =min(ans, res); memcpy(g, backup, sizeof(g)); &#125; if (ans&gt;6) ans =-1; return ans; &#125;int main()&#123; int T; cin &gt;&gt; T; // æ˜¯æ¯ç»„æ¯ç»„è¿›è¡Œåˆ¤æ–­çš„é¢ while( T--) &#123; for (int i =0; i&lt;5; i++) cin&gt;&gt; g[i]; cout &lt;&lt; work() &lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-Others]]></title>
    <url>%2F2019%2F07%2F16%2Fleetcode-others%2F</url>
    <content type="text"><![CDATA[LeetCode åˆ·é¢˜æ€»ç»“ï¼ˆå››ï¼‰ï¼Œä½¿ç”¨Python å®žçŽ°ã€‚è¯¥ç¯‡é¢˜ç›®ç±»åž‹ä¸»è¦åŒ…å«æ— æ³•å½’ç±»åˆ°ä¸Šè¿°ä¸‰ç¯‡çš„é¢˜ç›®ã€‚ Reverse Integer Given a 32-bit signed integer, reverse digits of an integer. Input: 120 Output: 21 Input: 123 Output: 321 https://leetcode.com/problems/reverse-integer/ Tipsï¼š è¿™ä¸ªåªæ˜¯reverse æ“ä½œï¼Œæ³¨æ„ä¸€äº›ç»†èŠ‚æ¯”å¦‚è´Ÿå·å’Œæ•°å­— 0çš„å¤„ç†ã€‚å¯¹äºŽæœ€å¤§æ•°çš„è¡¨ç¤º pow(2, 31)ã€‚ é€šè¿‡ % æ±‚ä½™èŽ·å¾—æœ€å°ä½ã€‚ 12345678910111213141516class Solution(object): def reverse(self, x): """ :type x: int :rtype: int """ result = 0 if x &lt; 0: symbol = -1 x = -x else: symbol = 1 while x: result = result * 10 + x % 10 x /= 10 return 0 if result &gt; pow(2, 31) else result * symbol String to Integer (atoi) Implement atoi which converts a string to an integer. Tips: æ¶‰åŠåˆ°bit çº§åˆ«æ•°å­—å¤„ç†çš„ä¸€èˆ¬éƒ½ä¼šç”¨åˆ° res =res 10 + something è¿™æ ·çš„ä¸œè¥¿ã€‚å¯¹äºŽèƒ½å¤Ÿè¡¨ç¤ºçš„æ•°å­—çš„åˆ¤æ–­ max(-pow(2, 31), min(ressign, pow(2, 31) -1)) è¿™ä¸ªè¿˜æ˜¯æŒºç»å…¸çš„ä»£ç çš„ã€‚ https://leetcode.com/problems/string-to-integer-atoi/ 1234567891011121314151617181920212223class Solution(object): def myAtoi(self, str): """ :type str: str :rtype: int """ ls =list(str.strip()) if len(ls) == 0: return 0 sign = -1 if ls[0] == '-' else 1 index=0 # æœ‰ä¸€ä¸ªindex æ˜¯è´¯ç©¿å§‹ç»ˆçš„ res =0 if ls[index] in ['-', '+']: index +=1 for i in range(index, len(ls)): if ls[i].isdigit(): res =res *10 + ord(ls[i]) -ord('0') else: # case "words and 987" æ˜¯ä¸èƒ½æœ‰ å­—æ¯çš„ break return max(-pow(2, 31), min(sign*res, pow(2,31) -1)) Palindrome Number Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Tipsï¼š å›žæ–‡æ•°ã€‚ä»£ç å†™çš„å¾ˆå·§å¦™ï¼Œæ•´ä½“ä¸Šè¯´æ˜¯é€šè¿‡ / å’Œ % èŽ·å¾—æ•°å­—çš„å¤´å’Œå°¾ï¼Œåœ¨å®žçŽ°çš„æ—¶å€™æœ‰è‹¥å¹²ç»†èŠ‚ã€‚ 1234567891011121314151617181920class Solution(object): def isPalindrome(self, x): """ :type x: int :rtype: bool """ if x &lt; 0: return False ranger = 1 while x / ranger &gt;= 10: ranger *= 10 while x: left = x / ranger right = x % 10 if left != right: return False x = (x % ranger) / 10 ranger /= 100 return True Integer to Roman Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Tipsï¼š åŸºäºŽroman æ•°å­—è§„åˆ™çš„è½¬æ¢ã€‚ä»£ç å®žçŽ°è§’åº¦ tupleéƒ½æ˜¯è¦å¥½äºŽ list ï¼ˆå†…å­˜å’Œé€Ÿåº¦æ–¹é¢éƒ½æ˜¯ï¼‰ï¼Œå¦‚æžœä½ æƒ³è¦å­˜å‚¨çš„æ˜¯é™æ€çš„å¯ä»¥éåŽ†çš„æ•°æ®ï¼Œä¸éœ€è¦æ¯æ¬¡è¿›è¡Œä¿®æ”¹çš„è¯ï¼Œwhy not 123456789101112131415161718class Solution(object): def intToRoman(self, num): if num &lt;= 0: return "" digits = &#123; "I":1, "V":5, "X":10, "L":50, "C":100, "D":500, "M":1000 &#125; nums = (1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1) chs = ("M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I") len = 13 s = "" while num &gt; 0: for i in range(0, len): if num &gt;= nums[i]: num -= nums[i] s += chs[i] break return s Roman to Integer Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Tipsï¼š å’Œä¸Šä¸€é“é¢˜ç›®ç›¸ä¼¼ã€‚ 1234567891011121314151617181920class Solution(object): def romanToInt(self, s): """ è¿™ä¸ªæ˜¯è¾“å…¥æ—¶ stringï¼Œæ‰€ä»¥æ˜¯ index éåŽ†çš„åœ¨ dict ä¸­è¿›è¡Œè®¿é—®ï¼Œä½†æ˜¯ä¸Šä¸€ä¸ªé¢˜ç›®æ˜¯æ€»çš„ numberï¼Œæ˜¯æ²¡æœ‰åŠžæ³•çš„ """ digits = &#123; "I":1, "V":5, "X":10, "L":50, "C":100, "D":500, "M":1000 &#125; len_s = len(s) num = 0 # è¿™ä¸ªå°‘éåŽ†äº†ä¸€ä¸ª ï¼Œå› ä¸ºå…¶ä¸­æœ‰ i+1 çš„å­˜åœ¨ for i in range(0, len_s - 1): cur = digits[s[i]] next_s = digits[s[i + 1]] if cur &gt;= next_s: num += cur else: num -= cur # å¤„ç†çš„æ˜¯æœ€åŽä¸€ä¸ª num += digits[s[len_s - 1]] return num Letter Combinations of a Phone Number Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Input: &quot;23&quot; Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. Tipsï¼šä½¿ç”¨å¾ªçŽ¯çš„æ–¹å¼è¡¨ç¤ºå±‚çº§çš„å…³ç³»ï¼ˆä½¿ç”¨äºŒå±‚å¾ªçŽ¯ï¼Œç¬¬ä¸€å±‚è¡¨ç¤ºå¤–å›´aï¼Œ ç¬¬äºŒå±‚è¡¨ç¤º def ç­‰ï¼‰ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def letterCombinations(self, digits): """ :type digits: str :rtype: List[str] """ if not digits or digits == "": return [] # å‘½åå¾ˆåˆ°ä½ maps =&#123; '1': (), '0': (), '2': ('a', 'b', 'c'), '3': ('d', 'e', 'f'), '4': ('g', 'h', 'i'), '5': ('j', 'k', 'l'), '6': ('m', 'n', 'o'), '7': ('p', 'q', 'r', 's'), '8': ('t', 'u', 'v'), '9': ('w', 'x', 'y', 'z') &#125; results = [""] for digit in digits: tuple1 = maps[digit] tmp =[] if len(tuple1) == 0: continue # äºŒé‡å¾ªçŽ¯ for prefix in results: for suffix in tuple1: tmp.append(prefix + suffix) results = tmp return results Divide Two Integers Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.Return the quotient after dividing dividend by divisor.The integer division should truncate toward zero. Tipsï¼š ä¸è®©ä½¿ç”¨ä¹˜é™¤å’Œ mod æ“ä½œï¼Œåªèƒ½ä½¿ç”¨ä½è¿ç®—ç¬¦äº†ã€‚åœ¨python ä¸­0 == False è¿™ä¸ªåœ¨é€»è¾‘åˆ¤æ–­ä¸­æ˜¯ç­‰ä»·çš„ï¼ˆ1 ==Trueï¼‰ã€‚è®¡ç®—çš„æ—¶å€™ä½¿ç”¨ &lt;&lt; ï¼ˆä¸æ–­çš„*2ï¼‰, ,maybe æ˜¯äºŒåˆ† 12345678910111213141516171819202122class Solution(object): def divide(self, divident, divisor): sign =-1 if divident* divisor&lt;0 else 1 divident, divisor =abs(divident), abs(divisor) ans =0 while divisor &lt;= divident: div =divisor tmp =1 while (div &lt;&lt;1) &lt;= divident: div &lt;&lt;= 1 tmp &lt;&lt;= 1 divident -= div ans += tmp return max(-pow(2, 31), min(ans*sign, pow(2, 31) -1)) Pow(x, n) Implement pow(x, n), which calculates x raised to the power n (xn) Tipsï¼š ç®€å•çš„é€’å½’ã€‚ 1234567891011121314151617181920class Solution(object): # é€’å½’å†™èµ·æ¥æ¯”è¾ƒå¥½äº›ï¼Œä½†æ˜¯æœ‰æ—¶å€™æ¯”è¾ƒéš¾ç†è§£è¿™ä¸ªè¿è¡Œçš„è¿‡ç¨‹ def myPow(self, x,n): """ :type x: float :type n: int :rtype: float """ if n ==0: return 1 # æ±‚è§£pow() éƒ½æ˜¯æ­£æ•°ï¼Œå¦‚æžœn &lt;0,é‚£ä¹ˆéœ€è¦åšçš„æ˜¯ å–å¯¼æ•° elif n &lt;0: return 1.0/self.myPow(x, -n) else: half =self.myPow(x, n&gt;&gt;1) if n%2 ==0: return half *half else: return x *half*half N-Queens The n-queens puzzle is the problem of placing n queens on an nÃ—n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle.Each solution contains a distinct board configuration of the n-queensâ€™ placement, where â€˜Qâ€™ and â€˜.â€™ both indicate a queen and an empty space respectively. Input: 4Output: [ [â€œ.Q..â€, // Solution 1 â€œâ€¦Qâ€, â€œQâ€¦â€, â€œ..Q.â€], [â€œ..Q.â€, // Solution 2 â€œQâ€¦â€, â€œâ€¦Qâ€, â€œ.Q..â€]]Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above. Tipsï¼š N-çš‡åŽï¼Œè¡Œåˆ—å¯¹è§’çº¿æ˜¯ä¸èƒ½å‡ºçŽ°é‡å¤ã€‚ä¸­è§„ä¸­çŸ©çš„é€’å½’è§£æ³•ï¼Œboard æ˜¯ä½¿ç”¨çš„ä¸€ç»´å‘é‡ï¼Œ è¿™æ ·åŽ»ç†è§£ æ¯”å¦‚board=[1, 3, 0, 2]ï¼Œè¿™æ˜¯4çš‡åŽé—®é¢˜çš„ä¸€ä¸ªè§£ï¼Œæ„æ€æ˜¯ï¼šåœ¨ç¬¬0è¡Œï¼Œçš‡åŽæ”¾åœ¨ç¬¬1åˆ—ï¼›åœ¨ç¬¬1è¡Œï¼Œçš‡åŽæ”¾åœ¨ç¬¬3åˆ—ã€‚ checkå‡½æ•°è¡¨ç¤º ç¬¬k ä¸ª çš‡åŽæ˜¯å¦èƒ½å¤Ÿæ”¾åœ¨ç¬¬j ä¸ªä½ç½®ã€‚ 123456789101112131415161718192021222324252627class Solution(object): def __init__(self): self.board =[] def check(self, k,j): for i in range(k): # å¦‚æžœä¹‹å‰çš„çš‡åŽå·²ç»æ”¾åˆ°äº†è¿™ä¸ªä½ç½®ï¼Œæˆ–è€…ä¸¤è€…åœ¨ä¸€æ¡ç›´çº¿ä¸Šï¼Œè¿™ä¸ªabs ç”¨çš„æ¯”è¾ƒç‰›é€¼ if self.board[i] ==j or abs(k -i) ==abs(self.board[i] -j): return False return True def dfs(self, depth, valuelist, n, res): if depth ==n: res.append(valuelist) return for i in range(n): if self.check(depth, i): self.board[depth] =i s ='.'*n self.dfs(depth +1, valuelist+[s[:i] +'Q'+s[i+1:]], n,res) def solveNQueens(self, n): self.board =[-1 for i in range(n)] res =[] self.dfs(0, [], n, res) return res N-Queens II The n-queens puzzle is the problem of placing n queens on an nÃ—n chessboard such that no two queens attack each other. Tips: è¿™ä¸ªç›¸å¯¹äºŽä¸Šä¸€ä¸ªè¦ç®€å•ä¸€äº›ï¼Œå› ä¸ºæœ€åŽçš„ç»“æžœè¦çš„æ˜¯ counts è€Œä¸æ˜¯ list of pathã€‚æŒ‰ç…§é“ç†è®²æ˜¯ä¸ç”¨è®°å½•path çš„ã€‚ 123456789101112131415161718192021222324252627282930313233class Solution(object): def __init__(self): self.board =[] self.count =0 def check(self, k,j): """ check if the kth queen can be put in column j :param k: :param j: :return: """ for i in range(k): if self.board[i] ==j or abs(k -i) ==abs(self.board[i] -j): return False return True def dfs(self, depth, valuelist, n, res): if depth ==n: #res.append(valuelist) self.count +=1 return for i in range(n): if self.check(depth, i): self.board[depth] =i s ='.'*n self.dfs(depth +1, valuelist+[s[:i] +'Q'+s[i+1:]], n,res) def totalNQueens(self, n): self.board =[-1 for i in range(n)] res =[] self.dfs(0, [], n, res) return self.count Add Binary Given two binary strings, return their sum (also a binary string).The input strings are both non-empty and contains only characters 1 or 0. Tipsï¼šäºŒçº§åˆ¶ç›¸åŠ ï¼Œä»ŽåŽå¾€å‰èµ°ï¼Œä½¿ç”¨ carry ä½ç½®è®°å½•è¿›ä½æ•°ã€‚ 12345678910111213141516171819202122class Solution(object): def addBinary(self, a, b): """ :type a: str :type b: str :rtype: str """ i, j, carry, res =len(a) -1, len(b) -1, 0, '' while i&gt;=0 or j &gt;=0 or carry: if i &gt;=0: carry += int(a[i]) i -=1 if j&gt;=0: carry += int(b[j]) j -=1 res =str(carry%2) +res carry //=2 return res Max Points on a Line Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. Tipsï¼šå½“ä½¿ç”¨é™¤æ³•çš„æ—¶å€™ï¼Œå› ä¸ºç²¾åº¦é—®é¢˜é€ æˆçš„è¯¯å·®ï¼Œæ‰€ä»¥è¿™é‡Œä½¿ç”¨æœ€å¤§çš„å…¬çº¦æ•°è¿›è¡ŒåŒ–ç®€ã€‚ä½¿ç”¨ä»¥ä¸‹ä¸‰ç§æ–¹å¼å¤„ç†ã€‚ Map from (a,b,c,d) representing y=(a/b)x+(c/d) to set of indices of points that are on that line. a/b and c/d are reduced, i.e. a and b are divided by their GCD and so are c and d. Vertical lines are represented by a tuple with 1 element, the x-axis value Single points are represented by a 2-tuple (x, y). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import collectionsimport mathdef fraction(x, y): if x &lt; 0: x, y = -x, -y gcd = math.gcd(x, y) return x // gcd, y // gcd class Solution: def maxPoints(self, points): if not points: return 0 if len(points) == 1: return 1 aligned_points = collections.defaultdict(set) duplicates = collections.defaultdict(set) for i, p in enumerate(points): for j, q in enumerate(points[i + 1:], start=i + 1): # x æ˜¯å¦ç›¸åŒ if q[0] == p[0]: if q[1] == p[1]: duplicates[i].add(j) key = tuple(p) else: key = (q[0],) else: a, b = fraction(q[1] - p[1], q[0] - p[0]) # kæ–œçŽ‡ c, d = fraction(p[1] * q[0] - q[1] * p[0], q[0] - p[0]) # b ä½ç§» key = (a, b, c, d) #aligned_points[key] = aligned_points[key] or &#123;i, j&#125; # å› ä¸ºä¹‹å‰å®šä¹‰çš„æ˜¯set aligned_points[key] |= &#123;i, j&#125; for p, dups in duplicates.items(): for key in aligned_points: if p in aligned_points[key]: #aligned_points[key] = aligned_points[key] or dups # è¿™ä¸ªor ä¸æ˜¯é€‰æ‹©çš„æ„æ€ï¼Œæ˜¯ä¸¤è€…éƒ½è¦çš„æ„æ€ aligned_points[key] |= dups max_points = 0 for aliged in aligned_points.values(): max_points = max(max_points, len(aliged)) return max_points Happy Number Write an algorithm to determine if a number is â€œhappyâ€.A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Input: 19Output: trueExplanation:12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 Tips: ä½¿ç”¨set çš„æ€è·¯ï¼Œæ²¡æœ‰é‡å¤ä¹‹å‰å°±ä¸€ç›´éåŽ†ï¼›å¯¹äºŽæ•°å­—è½¬æˆ string é€ä¸ªè¿›è¡Œå¤„ç†ã€‚ 1234567891011121314class Solution(object): def isHappy(self, n): """ :type n: int :rtype: bool """ visited =set() # è¿™ä¸ªset æ¯æ¬¡add éƒ½æ˜¯add åˆ°æœ€å‰é¢ä¸€ä¸ªï¼Œæ˜¯è§„å¾‹å§ while n not in visited: visited.add(n) n =sum((int(x) **2 for x in str(n)))# () è¦æ¯” [] ä½¿ç”¨è¾ƒå°‘çš„å†…å­˜ return n ==1 Sum of Two Integers Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. Input: a = 1, b = 2Output: 3 Tips: ä¸‹é¢çš„add()å‡½æ•°åªæ˜¯åœ¨ä»¥ä¸‹åœºæ™¯ä¸­ work: a*b&gt;=0 , or the negative number has a larger absolute value( a &lt; 0 and abs(a) &gt; b &gt; 0 , or b &lt; 0 and abs(b) &gt; a &gt; 0) 123456789101112131415161718192021class Solution(object): def getSum(self, a, b): """ :type a: int :type b: int :rtype: int """ def add(a, b): if not a or not b: return a or b # # ^ get different bits and &amp; gets double 1s, &lt;&lt; moves carry ï¼Œ è¿™ä¸ªå¯èƒ½æ˜¯åŠ æ³•å§ï¼Œ return add(a^b, (a&amp;b) &lt;&lt; 1) if a*b &lt; 0: # assume a &lt; 0, b &gt; 0 if a &gt; 0: return self.getSum(b, a) if -a == b: return 0 if -a &lt; b: return -add(-a, -b) return add(a, b) Fizz Buzz * Write a program that outputs the string representation of numbers from 1 to n. n = 15,Return:[ â€œ1â€, â€œ2â€, â€œFizzâ€, â€œ4â€, â€œBuzzâ€, â€œFizzâ€, â€œ7â€, â€œ8â€, â€œFizzâ€, â€œBuzzâ€, â€œ11â€, â€œFizzâ€, â€œ13â€, â€œ14â€, â€œFizzBuzzâ€] Tips: è¿™æ˜¯ä¸€ä¸ª for å¾ªçŽ¯å°±å¯ä»¥è§£å†³çš„é—®é¢˜ 12345678910111213141516171819class Solution(object): def fizzBuzz(self, n): """ :type n: int :rtype: List[str] """ # ä½¿ç”¨ä¸€ä¸ª result appendä¸€ä¸‹ result = [] for i in xrange(1, n + 1): if i % 3 != 0 and i % 5 != 0: result.append(str(i)) elif i % 3 == 0 and i % 5 != 0: result.append("Fizz") elif i % 3 != 0 and i % 5 == 0: result.append("Buzz") else: result.append("FizzBuzz") return result Find Median from Data Stream Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example,[2,3,4], the median is 3[2,3], the median is (2 + 3) / 2 = 2.5 Tips: ä¸»è¦éš¾ç‚¹åœ¨äºŽæ•°æ®æµï¼Œéš¾åœ¨æ•°æ®ç»“æž„ï¼Œä½¿ç”¨æœ€å°æ ¹å †å®žçŽ°ã€‚è¿™ä¸ªæ˜¯éœ€è¦å¯»æ‰¾ median ï¼ˆä¸­ä½æ•°ï¼‰ï¼Œä½¿ç”¨å¤§å°æ ¹å †ï¼Œåˆ†åˆ«å­˜å‚¨è¾ƒå°çš„ä¸€åŠ å’Œ è¾ƒå¤§çš„ä¸€åŠã€‚é‚£ä¹ˆå¤§æ ¹å †çš„å †é¡¶å°±å¯¹åº”ç€è¾ƒå°ä¸€åŠçš„æœ€å¤§å€¼ï¼Œå°æ ¹å †å¯¹åº”ç€è¾ƒå¤§éƒ¨åˆ†çš„æœ€å°å€¼ã€‚æ‰€ä»¥ä¸­ä½æ•°å°±å¯ä»¥ å¿«é€Ÿçš„ä»Žä¸¤ä¸ªå †é¡¶å…ƒç´ ä¸­èŽ·å¾—ã€‚ https://leetcode.com/problems/find-median-from-data-stream/ ç®€å•è¯´ä¸€ä¸‹åœ¨python ä¸­heapq -å°æ ¹å †çš„å®žçŽ°ã€‚å°†æ•°å€¼è½¬æˆè´Ÿæ•°ï¼Œé‚£ä¹ˆå°±å¯ä»¥ä½¿ç”¨å°æ ¹å †æ¥mimic å¤§æ ¹å †ï¼Œå› ä¸ºå †é¡¶æ˜¯è´Ÿæ•°æœ€å°çš„ã€‚ï¼ˆå¯¹åº”æ­£æ•°æœ€å¤§çš„ï¼‰ heap.heappush(heap, item), æŠŠä¸€ä¸ªitem æ·»åŠ åˆ°heapä¸­ heap.heappushpop(heap, item), å…ˆæŠŠitem æ”¾å…¥åˆ°å †ä¸­ï¼Œç„¶åŽå†pop() , è¿™æ ·æ¯” heappush() ç„¶åŽå†heappop() å¿«ä¸€äº› push item on the heap, then pop and return the smallest item from the heap. The combined action runs more efficiently than heappush followed by a separate call to heappop() Note that the heapq in python is a min heap, thus we need to invert the values in the smaller half to mimic a &apos;max heap&apos; the add operation is O(nlogn), the find operation is O(1) 123456789101112131415161718from heapq import *class MedianFinder(object): def __init__(self): self.small =[] # max heap (the smaller half of the list), å¤§æ ¹å †å­˜æ”¾çš„æ˜¯å°å€¼ï¼Œç„¶åŽæ ¹å­˜æ”¾çš„å°±æ˜¯æœ€å¤§å€¼, è¿™ä¸ªè½¬æˆ-num å½“ç„¶å°±æ˜¯ smaller part self.large =[] # min heap (the larger half of the list), å°æ ¹å †å­˜æ”¾çš„æ˜¯å¤§å€¼ï¼Œç„¶åŽæ ¹å°±æ˜¯å­˜æ”¾çš„æœ€å°å€¼ def addNum(self, num): if len(self.small) ==len(self.large): heappush(self.large, -heappushpop(self.small, -num)) else: heappush(self.small, -heappushpop(self.large, num)) def findMedian(self): if len(self.small) ==len(self.large): return float(self.large[0] -self.small[0])/2.0 else: return float(self.large[0]) Flatten Nested List Iterator Given a nested list of integers, implement an iterator to flatten it.Each element is either an integer, or a list â€“ whose elements may also be integers or other lists. Tips: è¿­ä»£å™¨å’Œ generator æ„Ÿè§‰éƒ½æ˜¯å·®ä¸å¤šçš„æ“ä½œï¼Œäº§ç”Ÿä¸€ä¸ªæ•°å­—ã€‚è¿™ä¸ªçœ‹æ‡‚ API æ›´é‡è¦ã€‚åªè¦æ•°å­—å†…å®¹ï¼Œä¸è¦åµŒå¥—çš„å…³ç³»ã€‚yield å…³é”®å­—ï¼Œè°ƒç”¨å®Œä¹‹åŽï¼Œç¨‹åºä¸ç»“æŸã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# """# This is the interface that allows for creating nested lists.# You should not implement it, or speculate about its implementation# """#class NestedInteger(object):# def isInteger(self):# """# @return True if this NestedInteger holds a single integer, rather than a nested list.# :rtype bool# """## def getInteger(self):# """# @return the single integer that this NestedInteger holds, if it holds a single integer# Return None if this NestedInteger holds a nested list# :rtype int# """## def getList(self):# """# @return the nested list that this NestedInteger holds, if it holds a nested list# Return None if this NestedInteger holds a single integer# :rtype List[NestedInteger]# """class NestedIterator(object): def __init__(self, nestedList): def gen(nestedList): for x in nestedList: if x.isInteger(): yield x.getInteger() else: for y in gen(x.getList()): yield y self.gen = gen(nestedList) def next(self): return self.value def hasNext(self): try: self.value = next(self.gen) return True except StopIteration: return False# Your NestedIterator object will be instantiated and called as such:# i, v = NestedIterator(nestedList), []# while i.hasNext(): v.append(i.next()) Insert Delete GetRandom O(1) Design a data structure that supports all following operations in average O(1) time. insert(val): Inserts an item val to the set if not already present. remove(val): Removes an item val from the set if present. getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class RandomizedSet(object): # å°±æ˜¯ä¸€ä¸ªç»´æŒlist çš„ä¸œè¥¿ def __init__(self): """ Initialize your data structure here. """ self.list =[] def insert(self, val): """ Inserts a value to the set. Returns true if the set did not already contain the specified element. :type val: int :rtype: bool """ if val not in self.list: self.list.append(val) return True return False def remove(self, val): """ Removes a value from the set. Returns true if the set contained the specified element. :type val: int :rtype: bool """ if val in self.list: self.list.remove(val) return True return False def getRandom(self): """ Get a random element from the set. :rtype: int """ length =len(self.list) import random index =random.randint(0,length-1) return self.list[index] # Your RandomizedSet object will be instantiated and called as such:# obj = RandomizedSet()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom() Perfect Squares Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, â€¦) which sum to n. Tips: å†æ¬¡ç†è§£ä¸€ä¸‹äºŒé‡å¾ªçŽ¯ï¼Œå¦‚æžœç¬¬äºŒå±‚ä¸­çš„éåŽ†æ¬¡æ•°å’Œ ç¬¬ä¸€å±‚æ˜¯æœ‰å…³ç³»çš„ï¼Œå¾€å¾€æ˜¯ O(N*N/2) çš„å¤æ‚åº¦ï¼ˆè¿™ç§è®°æ³•æ˜¯é”™è¯¯çš„ï¼‰ï¼Œç”¨äºŽéåŽ†å‰ i ä¸ªå…ƒç´ ã€‚ Â·Â·Â·pythonclass Solution(object): # dp[i] çš„å®šä¹‰è¡¨ç¤º i è¿™ä¸ªæ•°å­—æœ€å°‘ä½¿ç”¨çš„ squares æ•°é‡ def numSquares(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; dp = [float(&apos;inf&apos;)]*(n+1) dp[0]=0 count = 2 for i in range(1,n+1): if i&gt;=count*count: count += 1 for j in range(1,count): dp[i] = min(dp[i],dp[i-j*j]+1) return dp[n] &quot;&quot;&quot; # è¿™æ ·åšæ˜¯ä¸å¯è¡Œçš„ï¼Œåœ¨äºŽå¯èƒ½é‡å¤ä½¿ç”¨ä¸€ä¸ªï¼Œå¦‚æžœæ²¡æœ‰æœ€å¤§çš„åˆé€‚çš„è¯ square =[pow(num, 2) for num in range(1, int(math.sqrt(n) +1))] square =square[::-1] count =0 for sq in square: if n-sq &gt;0: n -= sq count +=1 return count &quot;&quot;&quot; 123456789101112131415161718192021222324** Factorial Trailing Zeroes**&gt; Given an integer n, return the number of trailing zeroes in n!.Tips: æ•°å­¦é—®é¢˜Â·Â·Â·pythonclass Solution(object): # è¿™é‡Œçš„ += n/div å·²ç»å°±è¡¨ç¤ºäº† 5çš„ä¸ªæ•°ï¼Œ è¿™æ ·æ˜¯å¯ä»¥åŠ å¿«è¿ç®—çš„ def trailingZeroes(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; div =5 res =0 while div &lt;=n: res += n/div div =div *5 return res Count Primes Count the number of prime numbers less than a non-negative number, n. Tips: ä¸»è¦æ˜¯è´¨æ•°å€æ•°çš„ä¼˜åŒ–ï¼Œå¦åˆ™æ˜¯time out 123456789101112131415161718192021class Solution(object): # prime è´¨æ•°ï¼Œ 1 æ—¢ä¸æ˜¯è´¨æ•°ä¹Ÿä¸æ˜¯ åˆæ•° # å½“å‰æ•°ä¸ºè´¨æ•°æ—¶ï¼ŒæŽ’é™¤æŽ‰å‰©ä¸‹çš„æ•°ä¸­è¯¥æ•°çš„æ•´å€æ•°ã€‚éåŽ†è¿‡æ‰€æœ‰çš„æ•°ä¹‹åŽå‰©ä¸‹çš„æ•°å…¨æ˜¯è´¨æ•°ã€‚æå‡æ•ˆçŽ‡çš„æ–¹æ³•æ˜¯å‡å°‘éåŽ†çš„é•¿åº¦ã€‚ # è¿˜æœ‰ä¸€ä¸ªä¼˜åŒ–ç‚¹ï¼Œå¯ä»¥ä¸å¿…ä»Ž2~m-1ï¼Œåªéœ€éåŽ†2 ~ âˆšm.å› ä¸ºå¦‚æžœmèƒ½è¢«2 ~ m-1ä¹‹é—´ä»»ä¸€æ•´æ•°æ•´é™¤ï¼Œå…¶äºŒä¸ªå› å­å¿…å®šæœ‰ä¸€ä¸ªå°äºŽæˆ–ç­‰äºŽâˆšmï¼Œå¦ä¸€ä¸ªå¤§äºŽæˆ–ç­‰äºŽâˆšmã€‚ä¾‹å¦‚16èƒ½è¢«2,4,8æ•´é™¤ # è´¨æ•°å®šä¹‰ä¸ºåœ¨å¤§äºŽ1çš„è‡ªç„¶æ•°ä¸­ï¼Œé™¤äº†1å’Œå®ƒæœ¬èº«ä»¥å¤–ä¸å†æœ‰å…¶ä»–å› æ•°ã€‚ # æœ€åŽ return çš„æ˜¯ counterï¼Œä¸ªæ•° è€Œä¸æ˜¯å…·ä½“çš„æ•°å­— def countPrimes(self, n): """ :type n: int :rtype: int """ if n &lt;= 2: return 0 prime = [True] * n prime[:2] = [False, False] for base in range(2, int((n ) ** 0.5) + 1): # æ—¶é—´ä¸Šæ˜¯ [2, sqrt(m)] ï¼Œä½†æ˜¯åœ¨python ä¸­å®žçŽ°æ˜¯è¿™æ ·çš„ if prime[base]: prime[base ** 2::base] = [False] * len(prime[base ** 2::base]) return sum(prime) Missing Number Given an array containing n distinct numbers taken from 0, 1, 2, â€¦, n, find the one that is missing from the array. Tips: ä½¿ç”¨å…¬å¼ index å’Œå‰ næ•°çš„é—®é¢˜ã€‚ 1234567891011class Solution(object): # å¦‚æžœæ²¡æœ‰é™åˆ¶å†…å­˜ï¼Œé‚£ä¹ˆæ˜¯å¯ä»¥ä½¿ç”¨dictï¼Œç„¶åŽæ ¹æ®index å’Œvalue è¿›è¡Œåˆ¤æ–­çš„ # å‡¡æ˜¯å’Œå¯¹åº”çš„index å‘ç”Ÿå…³ç³»ï¼Œé‚£ä¹ˆè¿™ä¸ªå°±æœ‰ä¼˜åŒ–çš„å¯èƒ½ï¼Œå°±å˜å¾—æ¯”è¾ƒæœ‰æ„æ€ def missingNumber(self, nums): """ :type nums: List[int] :rtype: int """ n =len(nums) return n*(n+1)/2 -sum(nums) Power of Three Given an integer, write a function to determine if it is a power of three. Tips: æ±‚ä½™ and /= ç›¸ç»“åˆçš„å¸¸è§æ‰‹æ³• 12345678910111213141516171819class Solution(object): # è¿™ä¸ªæ˜¯åœ¨è€ƒå¯Ÿé™¤æ³•çš„è¿ç®—è¿‡ç¨‹ def isPowerOfThree(self, n): """ :type n: int :rtype: bool """ if n &lt;=0: return False if n ==1: return True while n &gt;1: if n %3 !=0: return False n /= 3 return True Implement Trie (Prefix Tree) Implement a trie with insert, search, and startsWith methods. Tips: è¿™ä¸ªæ•°æ®ç»“æž„å¾ˆæœ‰ç”¨ï¼Œå­—å…¸æ ‘ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445class TrieNode: # Initialize your data structure here. # https://www.cnblogs.com/beiyeqingteng/p/5625540.htmlï¼Œè¿™é‡Œé¢æœ‰ä¸ªå›¾ # è¿˜æ˜¯æŒºå½¢è±¡çš„ def __init__(self): # è¿™ä¸ªæ˜¯ä»€ä¹ˆæ•°æ®ç»“æž„å‘€ self.children = collections.defaultdict(TrieNode) # è¿™ç§è®¾ç½®è¿˜æ˜¯ç†è§£ä¸å¤Ÿæ·±åˆ» self.is_word = False# è€ƒå¯Ÿçš„æ˜¯å­—å…¸æ ‘ï¼Œè¿™ç§æ•°æ®ç»“æž„# ä¿å­˜å­—æ¯çš„è¯ï¼Œæ˜¯ 26å‰æ ‘ï¼Œä¿å­˜æ•°å­—çš„è¯10 å‰æ ‘class Trie(object): def __init__(self): self.root =TrieNode() def insert(self, word): current =self.root for letter in word: current =current.children[letter] current.is_word =True def search(self, word): current =self.root for letter in word: current =current.children.get(letter) if not current: return False return current.is_word def startsWith(self, prefix): current =self.root for letter in prefix: current =current.children.get(letter) # dictionary æ“ä½œï¼Œå¾—åˆ°çš„æ˜¯å€¼ if not current: return False return True# Your Trie object will be instantiated and called as such:# obj = Trie()# obj.insert(word)# param_2 = obj.search(word)# param_3 = obj.startsWith(prefix)]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Knapsack]]></title>
    <url>%2F2019%2F07%2F15%2Fknapsack%2F</url>
    <content type="text"><![CDATA[01èƒŒåŒ… æœ‰$ N $ä»¶ç‰©å“å’Œä¸€ä¸ªå®¹é‡æ˜¯ $V $çš„èƒŒåŒ…ã€‚æ¯ä»¶ç‰©å“åªèƒ½ä½¿ç”¨ä¸€æ¬¡ã€‚ç¬¬ $i$ ä»¶ç‰©å“çš„ä½“ç§¯æ˜¯ $v_i$ï¼Œä»·å€¼æ˜¯ $w_i$ã€‚æ±‚è§£å°†å“ªäº›ç‰©å“è£…å…¥èƒŒåŒ…ï¼Œå¯ä½¿è¿™äº›ç‰©å“çš„æ€»ä½“ç§¯ä¸è¶…è¿‡èƒŒåŒ…å®¹é‡ï¼Œä¸”æ€»ä»·å€¼æœ€å¤§ã€‚è¾“å‡ºæœ€å¤§ä»·å€¼ã€‚ Tips: è¿™ä¸ªæ˜¯æœ€åŸºç¡€çš„èƒŒåŒ…é—®é¢˜ã€‚ èƒŒåŒ…é—®é¢˜å±žäºŽåŠ¨æ€è§„åˆ’çš„ä¸€ç§ï¼Œ $f[i] $è¡¨ç¤ºä½“ç§¯ä¸º $i $èƒŒåŒ…çš„æœ€å¤§çš„ä»·å€¼ã€‚é‚£ä¹ˆè½¬ç§»æ–¹ç¨‹å°±æ¯”è¾ƒç®€å•äº†ï¼Œå¯¹äºŽç‰©å“(v, w) æœ‰é€‰å’Œä¸é€‰ä¸¤ç§æ–¹æ¡ˆã€‚$ f[i] =max( f[i], f[i-v] +w) $ è¿™æ ·çš„å¼å­å°±æ˜¯æ¯”è¾ƒniceçš„é€‰æ‹©ã€‚ 01 èƒŒåŒ…é—®é¢˜çš„ä½“ç§¯æ˜¯ä»Žå¤§åˆ°å°è¿›è¡Œæžšä¸¾çš„ã€‚ 12345678910111213141516171819202122232425262728// 01 èƒŒåŒ…é—®é¢˜ï¼Œ f[i] =max(f[i], f[i -w]+ v)#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N= 1010;int f[N];int v[N], w[N];int n, m;int main()&#123; cin&gt;&gt; n&gt;&gt; m; for(int i =0; i&lt; n; i++) &#123; int v, w; cin &gt;&gt; v&gt;&gt; w; for (int j =m ; j&gt;=v; j--) f[j] =max(f[j], f[j -v]+w ); &#125; cout &lt;&lt; f[m]&lt;&lt;endl; return 0;&#125; å®Œå…¨èƒŒåŒ…é—®é¢˜ æœ‰$ N $ä»¶ç‰©å“å’Œä¸€ä¸ªå®¹é‡æ˜¯ $V $çš„èƒŒåŒ…ã€‚æ¯ä»¶ç‰©å“éƒ½æœ‰æ— é™ä»¶å¯ç”¨ã€‚ç¬¬ $i$ ä»¶ç‰©å“çš„ä½“ç§¯æ˜¯ $v_i$ï¼Œä»·å€¼æ˜¯ $w_i$ã€‚æ±‚è§£å°†å“ªäº›ç‰©å“è£…å…¥èƒŒåŒ…ï¼Œå¯ä½¿è¿™äº›ç‰©å“çš„æ€»ä½“ç§¯ä¸è¶…è¿‡èƒŒåŒ…å®¹é‡ï¼Œä¸”æ€»ä»·å€¼æœ€å¤§ã€‚è¾“å‡ºæœ€å¤§ä»·å€¼ã€‚ Tipsï¼š è¿™ä¸ªè·Ÿä¸Šé¢çš„ä¸åŒç‚¹åœ¨äºŽï¼Œç‰©å“æ˜¯æ— é™ä»¶å¯ç”¨ï¼Œ01 èƒŒåŒ…æ˜¯åªèƒ½ç”¨ä¸€ä¸ªã€‚ä»Žä»£ç å®žçŽ°ä¸Šçœ‹ï¼Œ 01èƒŒåŒ…é—®é¢˜çš„ ä½“ç§¯æ˜¯ä»Žå¤§åˆ°å°éåŽ†çš„ï¼Œç„¶åŽå®Œå…¨èƒŒåŒ…é—®é¢˜æ˜¯ä»Žå°åˆ°å¤§éåŽ†çš„ã€‚ 01 èƒŒåŒ…é—®é¢˜å’Œ å®Œå…¨èƒŒåŒ…é—®é¢˜çš„åŒºåˆ«åœ¨äºŽå‰è€…ç‰©å“åªæœ‰é€‰æ‹©ä¸Žå¦ä¸¤ç§æ–¹æ¡ˆã€‚è€Œå®Œå…¨èƒŒåŒ…å¯¹äºŽæ¯ä»¶ç‰©å“æœ‰æ— é™ä»¶å¯ä»¥é€‰æ‹©ã€‚å¯¹äºŽä½“ç§¯v æ˜¯ä»Žå°åˆ°å¤§è¿›è¡Œæžšä¸¾çš„ã€‚ 1234567891011121314151617181920212223242526272829// è½¬ç§»æ–¹ç¨‹ f[i] =max(f[i], f[i -v]+w) æ²¡æœ‰å˜ï¼Œå®žçŽ°çš„æ—¶å€™æœ‰å·®åˆ«#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N =1010;int f[N];int n, m;int main()&#123; cin &gt;&gt; n&gt;&gt;m; for(int i =0; i&lt; n ;i++) &#123; int v, w; cin &gt;&gt; v&gt;&gt;w; for(int j =v; j&lt;=m ;j++) // æ³¨æ„è¿™ä¸ªæ˜¯ &lt;= å·; è¿™ä¸ªèµ·å§‹ç‚¹æ˜¯å‡è®¾æ”¾å…¥äº†ä½“ç§¯ä¸ºv çš„ç‰©å“ f[j] =max(f[j], f[j -v]+w); &#125; cout&lt;&lt; f[m]&lt;&lt;endl; return 0;&#125; å¤šé‡èƒŒåŒ…é—®é¢˜ 1 æœ‰$ N $ä»¶ç‰©å“å’Œä¸€ä¸ªå®¹é‡æ˜¯ $V $çš„èƒŒåŒ…ã€‚æ¯ä»¶ç‰©å“éƒ½æœ‰æ— é™ä»¶å¯ç”¨ã€‚ç¬¬ $i$ ä»¶ç‰©å“æœ€å¤šæœ‰ $s_i$ ä»¶, æ¯ä»¶ä½“ç§¯æ˜¯ $v_i$ï¼Œä»·å€¼æ˜¯ $w_i$ã€‚æ±‚è§£å°†å“ªäº›ç‰©å“è£…å…¥èƒŒåŒ…ï¼Œå¯ä½¿è¿™äº›ç‰©å“çš„æ€»ä½“ç§¯ä¸è¶…è¿‡èƒŒåŒ…å®¹é‡ï¼Œä¸”æ€»ä»·å€¼æœ€å¤§ã€‚è¾“å‡ºæœ€å¤§ä»·å€¼ã€‚ $$\begin{split}0&lt; &amp; N \leq 100 \\0&lt; &amp; V \leq 100 \\0&lt; &amp; v_{i}, w_{i}, s_{i} \leq 100\end{split}$$ Tipsï¼š å¤šé‡èƒŒåŒ…é—®é¢˜æ˜¯è½¬æ¢æˆ 01 èƒŒåŒ…é—®é¢˜è¿›è¡Œè§£å†³çš„ï¼Œè¿™ä¸ªå¤§çš„æ€è·¯æ˜¯æ²¡æœ‰é—®é¢˜çš„ã€‚åªæ˜¯å¯¹äºŽä¸åŒçš„æ•°æ®è§„æ¨¡æœ‰ä¸¤ç§ä¸åŒçš„å®žçŽ°æ‰‹æ®µã€‚å½“æ•°æ®è§„æ¨¡æ¯”è¾ƒå°çš„æ—¶å€™ï¼Œä¸‰é‡å¾ªçŽ¯å°±æžå®šäº†ï¼›å½“æ•°æ®è§„æ¨¡æ¯”è¾ƒå¤§çš„æ—¶å€™ï¼Œéœ€è¦ä½¿ç”¨ä¸€ä¸ªç»“æž„ä½“è¿›è¡Œæ“ä½œã€‚ ï¼ˆå¤šé‡èƒŒåŒ…é—®é¢˜å¯¹ç‰©å“çš„ä¸ªæ•°è¿›è¡Œäº†é™åˆ¶ï¼Œä¸æ˜¯æ— é™ä¸ªï¼Œè½¬æ¢æˆ01 èƒŒåŒ…é—®é¢˜ï¼Œä½“ç§¯æ˜¯ä»Žå¤§åˆ°å°è¿›è¡Œæžšä¸¾ï¼‰ 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N =110;int n,m;int f[N];int main()&#123; cin &gt;&gt;n&gt;&gt;m; for(int i =0;i&lt; n;i++) &#123; int v, w, s; cin &gt;&gt;v &gt;&gt;w&gt;&gt;s; for (int j =m; j&gt;=0; j--) for(int k =1; k&lt;=s &amp;&amp; k*v &lt;=j ; k++) f[j] =max(f[j], f[j -k*v] +k*w); &#125; cout &lt;&lt;f[m]&lt;&lt; endl; return 0;&#125; å¤šé‡èƒŒåŒ…é—®é¢˜ 2 æœ‰$ N $ä»¶ç‰©å“å’Œä¸€ä¸ªå®¹é‡æ˜¯ $V $çš„èƒŒåŒ…ã€‚æ¯ä»¶ç‰©å“éƒ½æœ‰æ— é™ä»¶å¯ç”¨ã€‚ç¬¬ $i$ ä»¶ç‰©å“æœ€å¤šæœ‰ $s_i$ ä»¶, æ¯ä»¶ä½“ç§¯æ˜¯ $v_i$ï¼Œä»·å€¼æ˜¯ $w_i$ã€‚æ±‚è§£å°†å“ªäº›ç‰©å“è£…å…¥èƒŒåŒ…ï¼Œå¯ä½¿è¿™äº›ç‰©å“çš„æ€»ä½“ç§¯ä¸è¶…è¿‡èƒŒåŒ…å®¹é‡ï¼Œä¸”æ€»ä»·å€¼æœ€å¤§ã€‚è¾“å‡ºæœ€å¤§ä»·å€¼ã€‚ æ•°æ®èŒƒå›´: $$\begin{split}0&lt; &amp; N \leq 1000 \\0&lt; &amp; V \leq 2000 \\0&lt; &amp; v_{i}, w_{i}, s_{i} \leq 2000\end{split}$$ Tips: ä¸»è¦åŒºåˆ«åœ¨äºŽæ•°æ®çš„ç»´åº¦ã€‚ è¿™ä¸ªæ˜¯è½¬æ¢æˆ æˆ 01 èƒŒåŒ…é—®é¢˜ï¼Œä¸Šä¸€é“é¢˜ç›®æ˜¯åœ¨ 01 èƒŒåŒ…é—®é¢˜çš„åŸºç¡€ä¸Šï¼ˆæ¡†æž¶ä¸Šï¼‰è¿›è¡Œä¿®æ”¹ã€‚ è¿™ä¸ªä»Žæ—¶é—´å¤æ‚åº¦ä¸Šçš„ä¼˜åŒ–ï¼š$1000 \times 2000 \times 2000$ -&gt; $1000 \times 2000 \times \log(2000) $ ã€‚ç»è¿‡ä¼˜åŒ– åŸºæœ¬ä¸Šåœ¨ $ 10^7 $ï¼Œæ‰€ä»¥è¿™ä¸ªé€Ÿåº¦æ˜¯å¯ä»¥æŽ¥å—çš„ã€‚ c++ åœ¨ 1s ä¸­å°±æ˜¯å¯ä»¥è®¡ç®— $10^7 $ è¿™æ ·è¿ç®—ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int N =2010 ; // è¿™ä¸ªæ•°é‡æ˜¯ vçš„æœ€å¤§å€¼int f[N];int n, m;struct Good&#123; int v, w; &#125;;vector&lt;Good&gt; goods;int main()&#123; cin &gt;&gt; n&gt;&gt;m; for(int i =0; i&lt;n ; i++) &#123; int v, w, s; cin &gt;&gt; v&gt;&gt; w&gt;&gt;s; for (int k =1; k&lt;=s; k *=2) &#123; s -=k; goods.push_back(&#123;v*k, w*k&#125;); &#125; if(s &gt;0) goods.push_back(&#123;v*s, w*s&#125;); &#125; // 01 hnapsack // goods çš„é•¿åº¦ä¸ä¸€å®šæ˜¯ nï¼Œ æ‰€ä»¥ä¸èƒ½è¿™æ ·è¿›è¡ŒéåŽ† /* for(int i =0; i&lt;n; i++)// è¿™ä¸ª for(int j =m ; j&gt;= goods[i].v; j--) &#123; f[j] =max(f[j], f[j -goods[i].v] +goods[i].w); &#125; */ for(auto good : goods) for(int j =m ; j&gt;= good.v; j--) f[j] =max(f[j], f[j -good.v]+ good.w); cout &lt;&lt; f[m]&lt;&lt; endl; return 0;&#125; æ··åˆèƒŒåŒ…é—®é¢˜ æœ‰ $ N$ç§ç‰©å“å’Œä¸€ä¸ªå®¹é‡æ˜¯ $V$çš„èƒŒåŒ…ã€‚ ç‰©å“ä¸€å…±æœ‰ä¸‰ç±»ï¼š ç¬¬ä¸€ç±»ç‰©å“åªèƒ½ç”¨1æ¬¡ï¼ˆ01èƒŒåŒ…ï¼‰ï¼› ç¬¬äºŒç±»ç‰©å“å¯ä»¥ç”¨æ— é™æ¬¡ï¼ˆå®Œå…¨èƒŒåŒ…ï¼‰ï¼› ç¬¬ä¸‰ç±»ç‰©å“æœ€å¤šåªèƒ½ç”¨ $s_i $æ¬¡ï¼ˆå¤šé‡èƒŒåŒ…ï¼‰ï¼› æ¯ç§ä½“ç§¯æ˜¯ $v_i$ï¼Œä»·å€¼æ˜¯ $w_i$ã€‚æ±‚è§£å°†å“ªäº›ç‰©å“è£…å…¥èƒŒåŒ…ï¼Œå¯ä½¿ç‰©å“ä½“ç§¯æ€»å’Œä¸è¶…è¿‡èƒŒåŒ…å®¹é‡ï¼Œä¸”ä»·å€¼æ€»å’Œæœ€å¤§ã€‚è¾“å‡ºæœ€å¤§ä»·å€¼ã€‚ Tipsï¼š åˆ†ç±»è®¨è®ºï¼Œå¤šé‡èƒŒåŒ…é—®é¢˜è½¬æˆ 01èƒŒåŒ…é—®é¢˜ï¼Œæ‰€ä»¥æœ€åŽæ˜¯æœ‰ä¸¤ç±»ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;/*åˆ†æˆä¸¤ç±»ï¼š 01 èƒŒåŒ…é—®é¢˜å’Œå®Œå…¨èƒŒåŒ…é—®é¢˜ï¼›å¯¹äºŽå¤šé‡èƒŒåŒ…é—®é¢˜ä½¿ç”¨ äºŒè¿›åˆ¶è¿›è¡Œä¼˜åŒ–ï¼Œå¾—åˆ°01 èƒŒåŒ…é—®é¢˜ã€‚æ‰€ä»¥éœ€è¦ä¸€ä¸ªæ–°çš„ç»“æž„ä½“ 01 èƒŒåŒ…é—®é¢˜åªæœ‰ä¸¤ä¸ªå¾ªçŽ¯ï¼Œä¸€ä¸ªæ˜¯ç‰©å“çš„å¾ªçŽ¯ï¼Œä¸€ä¸ªæ˜¯å•†å“çš„å¾ªçŽ¯*/const int N =1010;int f[N];int n, m;struct Thing&#123; int v, w, s;&#125;;vector&lt;Thing&gt; things;int main()&#123; cin &gt;&gt;n&gt;&gt;m; for(int i =0; i&lt;n ;i++) &#123; int v, w, s; cin &gt;&gt; v&gt;&gt; w&gt;&gt;s; if(s ==-1) things.push_back(&#123;v, w, -1&#125;); else if (s ==0) things.push_back(&#123;v, w, 0&#125;); else &#123; for(int k =1; k&lt;=s; k *=2) &#123; s -=k; things.push_back(&#123;v*k, w*k, -1&#125;); &#125; if (s &gt;0) things.push_back(&#123;v*s, w*s, -1&#125;); &#125; &#125; // 01 èƒŒåŒ…é—®é¢˜ for(auto thing: things) &#123; if(thing.s ==-1) &#123; for( int j =m ; j&gt;= thing.v; j--) f[j] =max(f[j], f[j -thing.v]+ thing.w); &#125; else &#123; for(int j =thing.v ; j&lt;= m; j++) f[j] =max(f[j], f[j -thing.v] +thing.w); &#125; &#125; cout &lt;&lt; f[m]&lt;&lt;endl; return 0;&#125; äºŒç»´è´¹ç”¨çš„èƒŒåŒ…é—®é¢˜ æœ‰ N ä»¶ç‰©å“å’Œä¸€ä¸ªå®¹é‡æ˜¯ V çš„èƒŒåŒ…ï¼ŒèƒŒåŒ…èƒ½æ‰¿å—çš„æœ€å¤§é‡é‡æ˜¯ Mã€‚æ¯ä»¶ç‰©å“åªèƒ½ç”¨ä¸€æ¬¡ã€‚ä½“ç§¯æ˜¯$ v_i$ï¼Œ é‡é‡æ˜¯ $m_i$ï¼Œä»·å€¼æ˜¯$ w_i$ã€‚æ±‚è§£å°†å“ªäº›ç‰©å“è£…å…¥èƒŒåŒ…ï¼Œå¯ä½¿ç‰©å“æ€»ä½“ç§¯ä¸è¶…è¿‡èƒŒåŒ…å®¹é‡ï¼Œæ€»é‡é‡ä¸è¶…è¿‡èƒŒåŒ…å¯æ‰¿å—çš„æœ€å¤§é‡é‡ï¼Œä¸”ä»·å€¼æ€»å’Œæœ€å¤§ã€‚è¾“å‡ºæœ€å¤§ä»·å€¼ã€‚ Tips: ä¸€èˆ¬æ¥è¯´èƒŒåŒ…é—®é¢˜åªæœ‰ä¸€ä¸ªé™åˆ¶æ¡ä»¶ï¼šVã€‚ä½†æ˜¯è¿™ç§æ˜¯å¯ä»¥æ‰©å±•åˆ°å¤šç»´ï¼Œå³æœ‰å¤šä¸ªé™åˆ¶æ¡ä»¶ï¼Œæ¯”å¦‚é‡é‡ã€‚å¾ˆç®€å•çš„æ‰©å±•æ˜¯åŠ ä¸Šä¸€ä¸ªå¾ªçŽ¯ã€‚åŒç† f è¿™æ ·çš„å‡½æ•°æ˜¯å¯ä»¥æ‰©å±•æˆäºŒç»´çš„ã€‚ 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N =1010;int f[N][N];int n,v, m;int main()&#123; cin &gt;&gt; n&gt;&gt; v&gt;&gt;m; for (int i =0 ; i&lt; n; i++) &#123; int a, b, c; cin &gt;&gt; a&gt;&gt; b&gt;&gt;c; for(int j =v ;j&gt;=a ; j--) for(int k =m ; k&gt;= b; k--) &#123; f[j][k] =max(f[j][k], f[j- a][k -b] +c); &#125; &#125; cout &lt;&lt; f[v][m]&lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>èƒŒåŒ…</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[All you need to know about seq2seq]]></title>
    <url>%2F2019%2F07%2F12%2Fseq2seq-theory%2F</url>
    <content type="text"><![CDATA[ä»‹ç» sequence to sequence çš„å®šä¹‰ã€ä¸¤ç§ä¸åŒçš„ç»“æž„ã€è®­ç»ƒè¿‡ç¨‹ã€æ³¨æ„åŠ›æœºåˆ¶å’Œå¸¸è§çš„ä¸€äº›é—®é¢˜ã€‚æœ¬ç¯‡ä¸»è¦æ˜¯ç†è®ºï¼Œä»£ç demo å¯ä»¥å‚è€ƒå¦ä¸€ç¯‡ã€‚ å®šä¹‰å’Œç»“æž„ å®šä¹‰ è¯­è¨€æ¨¡åž‹ï¼šå¯¹äºŽä»»æ„çš„è¯åºåˆ—ï¼Œå®ƒèƒ½å¤Ÿè®¡ç®—å‡ºè¿™ä¸ªåºåˆ—æ˜¯ä¸€å¥è¯çš„æ¦‚çŽ‡ã€‚ Sequence-to-sequence (seq2seq) æ¨¡åž‹ï¼Œé¡¾åæ€ä¹‰ï¼Œå…¶è¾“å…¥æ˜¯ä¸€ä¸ªåºåˆ—ï¼Œè¾“å‡ºä¹Ÿæ˜¯ä¸€ä¸ªåºåˆ—. ç›®å‰æ¥è¯´ï¼Œå¯¹äºŽSeq2Seqç”Ÿæˆæ¨¡åž‹æ¥è¯´ï¼Œä¸»è¦çš„æ€è·¯æ˜¯å°†è¯¥é—®é¢˜ä½œä¸ºæ¡ä»¶è¯­è¨€æ¨¡åž‹ï¼Œåœ¨å·²çŸ¥è¾“å…¥åºåˆ—å’Œå‰åºç”Ÿæˆåºåˆ—çš„æ¡ä»¶ä¸‹,æœ€å¤§åŒ–ä¸‹ä¸€ç›®æ ‡è¯çš„æ¦‚çŽ‡ï¼Œè€Œæœ€ç»ˆå¸Œæœ›å¾—åˆ°çš„æ˜¯æ•´ä¸ªè¾“å‡ºåºåˆ—çš„ç”Ÿæˆå‡ºçŽ°çš„æ¦‚çŽ‡æœ€å¤§ï¼š$$P ( Y | X ) = \sum _ { t = 1 } ^ { T } \log P \left( y _ { t } | y _ { 1 : t - 1 } , X \right)$$ seq2seq å¯ä»¥ç”¨åœ¨å¾ˆå¤šæ–¹é¢ï¼šæœºå™¨ç¿»è¯‘ã€QA ç³»ç»Ÿã€æ–‡æ¡£æ‘˜è¦ç”Ÿæˆã€Image Captioning (å›¾ç‰‡æè¿°ç”Ÿæˆå™¨)ã€‚ Figure 1 ä»‹ç»äº†ä¸€ä¸ªæ ‡å‡†çš„seq2seqæ¨¡åž‹ã€‚ å…¶ä¸­çº¢è‰²çš„æ˜¯encoder RNN, ç»¿è‰²çš„æ˜¯decoder RNN. ä»–ä»¬ä¹‹é—´ æœ‰ä¸€ä¸ªè¿žçº¿ï¼Œ ä¹Ÿå°±æ˜¯encoder states ä¼ ç»™decoder RNNï¼Œå½“åšinitial stateã€‚ ä¸¤ç§ä¸åŒçš„ç»“æž„ ç¬¬ä¸€ç§ï¼Œ seq2seq æ¨¡åž‹å¯ç®€å•ç†è§£ä¸ºç”±ä¸‰éƒ¨åˆ†ç»„æˆï¼šEncoderã€Decoder å’Œè¿žæŽ¥ä¸¤è€…çš„ State Vector (ä¸­é—´çŠ¶æ€å‘é‡) C ã€‚ ç¬¬äºŒç§ç»“æž„æ˜¯æœ€ç®€å•çš„ç»“æž„ï¼Œå’Œç¬¬ä¸€ç§ç»“æž„ç›¸ä¼¼ï¼Œåªæ˜¯ Decoder çš„ç¬¬ä¸€ä¸ªæ—¶åˆ»åªç”¨åˆ°äº† Encoder æœ€åŽè¾“å‡ºçš„ä¸­é—´çŠ¶æ€å˜é‡ ï¼š åœ¨ä¸¤ç§ä¸åŒçš„ç»“æž„æ—¶å€™ï¼Œä¸¤è€…çš„åŒºåˆ«åœ¨ C (context) å‘é‡æ˜¯å¦å¤šæ¬¡ä½¿ç”¨ï¼Œå‰ä¸€ç§åœ¨ç”Ÿæˆæ¯ä¸ªwordçš„æ—¶å€™ï¼Œéƒ½ä½¿ç”¨åˆ°äº† contextï¼Œè€ŒåŽè€…åˆ™æ²¡æœ‰ã€‚ è®­ç»ƒè¿‡ç¨‹ encoder æ¿€æ´»å‡½æ•°: softmax() 1234crossent = tf.nn.spase_softmax_cross_entropy_with_logits( labels=decoder_outputs, logits=logits)train_loss = (tf.reduce_sum(crossent * target_weights) / batch_size) loss è®¡ç®—: äº¤å‰ç†µæ˜¯æŸå¤±å‡½æ•°ï¼Œé’ˆå¯¹å•ä¸ªæ ·æœ¬ï¼›ç›®æ ‡å‡½æ•°æ˜¯é’ˆå¯¹æ•´ä¸ªæ•°æ®é›†çš„æŸå¤±å‡½æ•°+ æ­£åˆ™é¡¹ã€‚ decoder å½“ä½ è®­ç»ƒä½ çš„ NMT æ¨¡åž‹æ—¶ï¼ˆå¹¶ä¸”ä¸€æ—¦ä½ å·²ç»è®­ç»ƒäº†æ¨¡åž‹ï¼‰ï¼Œå¯ä»¥åœ¨ç»™å®šä¹‹å‰ä¸å¯è§çš„æºè¯­å¥çš„æƒ…å†µä¸‹èŽ·å¾—ç¿»è¯‘ã€‚è¿™ä¸€è¿‡ç¨‹è¢«ç§°ä½œæŽ¨ç†ã€‚è®­ç»ƒä¸ŽæŽ¨ç†ä¹‹é—´æœ‰ä¸€ä¸ªæ˜Žç¡®çš„åŒºåˆ†ï¼ˆæµ‹è¯•ï¼‰ï¼šåœ¨æŽ¨ç†æ—¶ï¼Œæˆ‘ä»¬åªè®¿é—®æºè¯­å¥ï¼Œå³ encoder_inputsã€‚è§£ç çš„æ–¹å¼æœ‰å¾ˆå¤šç§ï¼Œå¸¸è§çš„æœ‰greedy è§£ç å’ŒæŸæœç´¢è§£ç ï¼ˆbeam-searchï¼‰ã€‚ æˆ‘ä»¬çŸ¥é“åœ¨Seq2Seqæ¨¡åž‹çš„æœ€ç»ˆç›®çš„æ˜¯å¸Œæœ›ç”Ÿæˆçš„åºåˆ—å‘ç”Ÿçš„æ¦‚çŽ‡æœ€å¤§ï¼Œä¹Ÿå°±æ˜¯ç”Ÿæˆåºåˆ—çš„è”åˆæ¦‚çŽ‡æœ€å¤§ã€‚ å®žé™…åšçš„æ—¶å€™æœ‰ä¸¤ç§ç®—æ³•è¿›è¡Œ decoderã€‚ greedy decodingï¼šï¼ˆè´ªå¿ƒç®—æ³•æ€ç»´ï¼Œå¾—åˆ°æ˜¯ä¸€ç§å±€éƒ¨æœ€ä¼˜è§£ï¼‰ Fig 1 æè¿°çš„æ˜¯Inference çš„çŠ¶æ€ï¼Œ decode è¾“å‡ºæ¥çš„æ¯ä¸€ä¸ªå•è¯éƒ½ä¼šå½“åšä¸‹ä¸€ä¸ªæ—¶åˆ»çš„è¾“å…¥ï¼Œæ¥è¿›è¡Œç¿»è¯‘ã€‚ è€Œåœ¨è®­ç»ƒè¿‡ç¨‹ä¸­ï¼Œ å› ä¸ºçŸ¥é“ç¿»è¯‘å‡ºæ¥çš„å•è¯æ˜¯ä»€ä¹ˆï¼Œå°±ä¼šæŠŠè¿™ä¸ªå•è¯å½“åšè¾“å…¥è¿›è¡Œè®­ç»ƒã€‚ å›¾ä¸­ inferenceçš„è¿‡ç¨‹ä¸­ç”¨åˆ°äº†argmax, è¿™ä¸ªå‡½æ•°ï¼Œä¹Ÿå°±æ˜¯æ¯æ¬¡éƒ½é€‰æ‹©æ¦‚çŽ‡æœ€å¤§çš„é‚£ä¸ªå•è¯å½“åšç¿»è¯‘ã€‚ è¿™ä¸ªå«åšgreedy decoding. è¿™ä¸ªä¸æ˜¯optimal solutionã€‚ è´ªå¿ƒæœç´¢åªé€‰æ‹©äº†æ¦‚çŽ‡æœ€å¤§çš„ä¸€ä¸ªï¼Œè€Œé›†æŸæœç´¢ (beam search)åˆ™é€‰æ‹©äº†æ¦‚çŽ‡æœ€å¤§çš„å‰kä¸ªã€‚è¿™ä¸ªkå€¼ä¹Ÿå«åšé›†æŸå®½åº¦ï¼ˆBeam Widthï¼‰ï¼Œç®—æ³•å¤æ‚åº¦æ˜¯O(nKv), v æ˜¯å­—å…¸çš„å¤§å°ï¼Œ n æ˜¯è¾“å‡ºåºåˆ—çš„é•¿åº¦, k è¡¨ç¤ºä¿ç•™çš„è§£çš„ä¸ªæ•°ã€‚ Beam search decodingï¼š è¿™ä¸ªæ–¹æ³•åœ¨æ¯ä¸ªç¿»è¯‘çš„æ­¥éª¤ éƒ½ä¿å­˜k ä¸ªæœ€å¯èƒ½çš„é€‰æ‹©ï¼Œ k å°±æ˜¯beam size, è¿™ä¸ªæ–¹æ³•è™½ç„¶ä¸èƒ½ä¿è¯æœ€ä¼˜è§£ï¼Œ ä½†æ˜¯æ•ˆçŽ‡é«˜äº†å¾ˆå¤šã€‚ k ä¸€èˆ¬å°±æ˜¯5-10. ä¸Šå›¾å°±æ˜¯ä¸€ä¸ª beam size =2 çš„ä¾‹å­ã€‚ åœ¨T=0 çš„æ—¶å€™ï¼Œé€‰æ‹©æ¦‚çŽ‡æœ€å¤§çš„ä¸¤ä¸ªã€‚ åœ¨T =1 çš„æ—¶å€™ï¼Œåˆ†åˆ«å°† the å’Œ a è¾“å…¥å¾—åˆ°ä¸¤ä¸ªæ¦‚çŽ‡æ¨¡åž‹ï¼Œç„¶åŽé€‰æ‹©æ¦‚çŽ‡å’Œæœ€å¤§çš„ä¸¤ä¸ªåºåˆ—ã€‚ä»¥æ­¤ç±»æŽ¨ï¼Œæœ€ç»ˆå¾—åˆ°ä¸¤ä¸ªåºåˆ—ã€‚ç„¶åŽå‰è€…çš„æ¦‚çŽ‡å’Œå¤§äºŽåŽè€…ï¼Œæ‰€ä»¥å°±é€‰æ‹©çš„ä¸Šé¢çš„é‚£ä¸ªï¼Œå…¶ä»–çš„è·¯å¾„å°±å¯ä»¥ä¸¢æŽ‰äº†ã€‚ æ³¨æ„åŠ›æœºåˆ¶Encoder-Decoder æ¨¡åž‹çš„å±€é™æ€§ï¼ˆæœ‰ä¸¤ç‚¹ï¼‰ ä¸­é—´è¯­ä¹‰å‘é‡æ— æ³•å®Œå…¨è¡¨è¾¾æ•´ä¸ªè¾“å…¥åºåˆ—çš„ä¿¡æ¯ã€‚ éšç€è¾“å…¥ä¿¡æ¯é•¿åº¦çš„å¢žåŠ ï¼Œç”±äºŽå‘é‡é•¿åº¦å›ºå®šï¼Œå…ˆå‰ç¼–ç å¥½çš„ä¿¡æ¯ä¼šè¢«åŽæ¥çš„ä¿¡æ¯è¦†ç›–ï¼Œä¸¢å¤±å¾ˆå¤šä¿¡æ¯ã€‚ Attention æ¨¡åž‹çš„ç‰¹ç‚¹æ˜¯ Decoder ä¸å†å°†æ•´ä¸ªè¾“å…¥åºåˆ—ç¼–ç ä¸ºå›ºå®šé•¿åº¦çš„ä¸­é—´è¯­ä¹‰å‘é‡ ï¼£ ï¼Œè€Œæ˜¯æ ¹æ®å½“å‰ç”Ÿæˆçš„æ–°å•è¯è®¡ç®—æ–°çš„ $C_{i}$ ï¼Œä½¿å¾—æ¯ä¸ªæ—¶åˆ»è¾“å…¥ä¸åŒçš„ ï¼£ï¼Œè¿™æ ·å°±è§£å†³äº†å•è¯ä¿¡æ¯ä¸¢å¤±çš„é—®é¢˜ã€‚å¼•å…¥äº† Attention çš„ Encoder-Decoder æ¨¡åž‹å¦‚ä¸‹å›¾ï¼š åº”ç”¨åœ¨è‹±æ–‡ç¿»è¯‘ä¸­ï¼Œå°†è‹±æ–‡è¾“å…¥åˆ° Encoder ä¸­ï¼ŒDecoder è¾“å‡ºä¸­æ–‡ã€‚åœ¨å›¾åƒæ ‡æ³¨ä¸­ï¼Œå°†å›¾åƒç‰¹å¾è¾“å…¥åˆ° Encoder ä¸­ï¼ŒDecoder è¾“å‡ºä¸€æ®µæ–‡å­—å¯¹å›¾åƒçš„æè¿°ã€‚åœ¨ QA ç³»ç»Ÿä¸­ï¼Œå°†æå‡ºçš„é—®é¢˜è¾“å…¥ Encoder ä¸­ï¼ŒDecoder è¾“å‡ºå¯¹äºŽé—®é¢˜çš„å›žç­”ã€‚ å¸¸è§é—®é¢˜ Exposure Biasï¼š é—®é¢˜æè¿°ï¼šSeq2Seqæ¨¡åž‹è®­ç»ƒçš„è¿‡ç¨‹ä¸­ï¼Œç¼–ç éƒ¨åˆ†çš„ä¸‹ä¸€ä¸ªæ—¶åˆ»çš„è¾“å‡ºï¼Œæ˜¯éœ€è¦æ ¹æ®ä¸Šä¸€ä¸ªæ—¶åˆ»çš„è¾“å‡ºå’Œä¸Šä¸€ä¸ªæ—¶åˆ»çš„éšè—çŠ¶æ€å’Œè¯­ä¹‰å˜é‡Ci.æ­¤æ—¶ä¸Šä¸€ä¸ªæ—¶åˆ»çš„è¾“å‡ºä½¿ç”¨çš„æ˜¯çœŸå®žçš„tokenã€‚è€Œåœ¨éªŒè¯Seq2Seqæ¨¡åž‹çš„æ—¶å€™ï¼Œç”±äºŽä¸çŸ¥é“ä¸Šä¸€ä¸ªæ—¶åˆ»çš„çœŸå®žtokenï¼Œä¸Šä¸€ä¸ªæ—¶åˆ»çš„è¾“å‡ºä½¿ç”¨çš„æ˜¯ä¸Šä¸Šä¸ªæ—¶åˆ»çš„é¢„æµ‹çš„è¾“å‡ºtokenã€‚è¿™å°†å¼•å‘Exposure Bias(æ›å…‰åå·®é—®é¢˜)ã€‚ ä½¿ç”¨çœŸå®ž token æœ¬èº«çš„è¡Œä¸ºå«åš teacher forcingã€‚ ä¸€ç§è§£å†³æ€è·¯ï¼šä½¿ç”¨Beam Searchçš„Encoderçš„æ–¹å¼ä¹Ÿèƒ½ä¸€å®šç¨‹åº¦ä¸Šé™ä½ŽExposure Biasé—®é¢˜ ï¼ˆè¯¥é—®é¢˜å¯ä»¥ç†è§£ä¸ºè¿‡åˆ†çš„ä¾èµ–ä¸Šä¸€ä¸ªçœŸå®žçš„ token æˆ–è€…è¯´æ ‡ç­¾ï¼‰ï¼Œå› ä¸ºå…¶è€ƒè™‘äº†å…¨å±€è§£ç æ¦‚çŽ‡ï¼Œè€Œä¸ä»…ä»…ä¾èµ–ä¸Žå‰ä¸€ä¸ªè¯çš„è¾“å‡ºï¼Œæ‰€ä»¥æ¨¡åž‹å‰ä¸€ä¸ªé¢„æµ‹é”™è¯¯è€Œå¸¦æ¥çš„è¯¯å·®ä¼ é€’çš„å¯èƒ½æ€§å°±é™ä½Žäº† exposure bias çš„å®šä¹‰ï¼šRNN åœ¨ training æ—¶æŽ¥å— ground truth inputï¼Œä½† testing æ—¶å´æŽ¥å—è‡ªå·±ä¹‹å‰çš„ outputï¼Œè¿™ä¸¤ä¸ª settingä¸ä¸€è‡´ä¼šå¯¼è‡´ error accumulateè§£å†³æ€è·¯ï¼šä¸ºäº†è§£å†³ exposure bias é—®é¢˜ï¼Œæå‡ºäº† scheduled samplingï¼Œå³åœ¨å…ˆå‰çš„ GroundTrue å•è¯å’Œå…ˆå‰äº§ç”Ÿçš„å•è¯ä¹‹é—´éšæœºé€‰æ‹©ï¼Œå·²ç»æˆä¸ºé€‚åˆåŸºäºŽRNNçš„æ¨¡åž‹çš„å½“å‰ä¸»è¦è®­ç»ƒç¨‹åºã€‚ ç„¶è€Œï¼Œå®ƒåªèƒ½å‡è½» exposure biasï¼Œä½†ä¸èƒ½å¾ˆå¤§ç¨‹åº¦ä¸Šè§£å†³å®ƒã€‚ OOV å’Œä½Žé¢‘è¯ é—®é¢˜æè¿°ï¼šOOVè¡¨ç¤ºçš„æ˜¯è¯æ±‡è¡¨å¤–çš„æœªç™»å½•è¯ï¼Œä½Žé¢‘è¯åˆ™æ˜¯è¯æ±‡è¡¨ä¸­çš„å‡ºçŽ°æ¬¡æ•°è¾ƒä½Žçš„è¯ã€‚åœ¨Decoderé˜¶æ®µæ—¶é¢„æµ‹çš„è¯æ¥è‡ªäºŽè¯æ±‡è¡¨ï¼Œè¿™å°±é€ æˆäº†æœªç™»å½•è¯éš¾ä»¥ç”Ÿæˆï¼Œä½Žé¢‘è¯ä¹Ÿæ¯”è¾ƒå°çš„æ¦‚çŽ‡è¢«é¢„æµ‹ç”Ÿæˆã€‚ ä¸€ç§è§£å†³æ€è·¯ï¼šå¦‚æžœ focus åœ¨æ–‡æœ¬æ‘˜å½•é¢†åŸŸï¼Œç”±äºŽå…¶ä»»åŠ¡çš„ç‰¹ç‚¹ï¼Œå¾ˆå¤šOOV æˆ–è€…ä¸å¸¸è§çš„çš„è¯å…¶å®žå¯ä»¥ä»Žè¾“å…¥åºåˆ—ä¸­æ‰¾åˆ°ï¼Œå› æ­¤ä¸€ä¸ªå¾ˆè‡ªç„¶çš„æƒ³æ³•å°±æ˜¯åŽ»é¢„æµ‹ä¸€ä¸ªå¼€å…³ï¼ˆswitchï¼‰çš„æ¦‚çŽ‡ $P(si=1)=f(hi,yi-1,ci) $ï¼Œå¦‚æžœå¼€å…³æ‰“å¼€äº†ï¼Œå°±æ˜¯æ­£å¸¸åœ°é¢„æµ‹è¯è¡¨ï¼›å¦‚æžœå¼€å…³å…³ä¸Šäº†ï¼Œå°±éœ€è¦åŽ»åŽŸæ–‡ä¸­æŒ‡å‘ä¸€ä¸ªä½ç½®ä½œä¸ºè¾“å‡ºã€‚ è¿žç»­ç”Ÿæˆé‡å¤è¯çš„é—®é¢˜ é—®é¢˜éœ€è¦ä»Žæœ¬è´¨ä¸Šè¿›è¡Œç†è§£ï¼Œä¸ºä»€ä¹ˆç”Ÿæˆäº†é‡å¤å¤çš„è¯è¯­ï¼Œå°±æ˜¯åœ¨ç›®å‰ç”Ÿæˆçš„è¯è¯­ä¸Šï¼Œä¸‹ä¸€ä¸ªè¯è¯­å‘çŽ°æŸä¸ªè¯ä¸€ç›´æ˜¯æ¦‚çŽ‡æœ€å¤§çš„ã€‚æ‰€ä»¥ä¸€ç§æ–¹å¼æ˜¯é€šè¿‡ beam searchï¼Œç»™å‡ºäº†å¤šç§ä¸åŒçš„å€™é€‰è¯æ±‡ï¼Œç„¶åŽè®¡ç®—æ•´ä½“çš„å¥å­çš„æ¦‚çŽ‡ã€‚ ä¸€ç§æ–¹å¼æ˜¯åˆ¤æ–­ç„¶åŽæƒ©æˆ’ï¼Œå‘çŽ°ç”Ÿæˆäº†å’Œä¸Šä¸€ä¸ªè¯è¯­ç›¸åŒçš„è¯è¯­ï¼Œé‚£ä¹ˆæ‹’ç»è¿™ä¸ªè¯è¯­ã€‚ teaching forcingå…¶å®žRNNå­˜åœ¨ç€ä¸¤ç§è®­ç»ƒæ¨¡å¼(mode): free-running mode: å°±æ˜¯å¤§å®¶å¸¸è§çš„é‚£ç§è®­ç»ƒç½‘ç»œçš„æ–¹å¼: ä¸Šä¸€ä¸ªstateçš„è¾“å‡ºä½œä¸ºä¸‹ä¸€ä¸ªstateçš„è¾“å…¥ã€‚é—®é¢˜ï¼š å¦‚æžœä¸€ä¸ªunit å‡ºçŽ°äº†garbage ï¼Œé‚£ä¹ˆå¿…å®šæ˜¯ä¼šå½±å“åŽé¢ä¸€ç‰‡ unit çš„å­¦ä¹ æ•ˆæžœï¼›é€ æˆäº†ä¸æ”¶æ•› teacher-forcing mode: ä½¿ç”¨ç›®æ ‡è¯­è¨€ä¸­çš„å®žé™…è¾“å‡ºä½œä¸º decoder çš„è¾“å…¥ã€‚ä¼˜ç‚¹ï¼š è®­ç»ƒå˜å¾—ç¨³å®šï¼Œå¿«é€Ÿçš„æ”¶æ•›ç¼ºç‚¹ï¼šæ•ˆæžœå¹¶ä¸æ˜¯é‚£ä¹ˆå¥½ï¼Œå› ä¸ºåœ¨ test çš„æ—¶å€™ï¼Œæ˜¯æ²¡æœ‰ground true çš„æ”¯æŒï¼Œæ‰€ä»¥æ¨¡åž‹å°±æ•ˆæžœå¾ˆå·®ã€‚ å¸¸è§çš„å‡ ç§å¤„ç†æ‰‹æ®µï¼šé›†æŸæœç´¢ï¼ˆbeam searchï¼‰ï¼šäº§ç”Ÿå¤šä¸ªå€™é€‰è¯ï¼Œä¼˜åŒ–è¾“å‡ºåºåˆ—ã€‚å®žé™…ä¸Šæ˜¯ä¸€ç§å‰ªæžåŽçš„æ·±åº¦ä¼˜å…ˆæœç´¢ç®—æ³•ã€‚è®¡åˆ’å­¦ä¹ ï¼ˆcurriculum learningï¼‰ï¼šæ€»çš„æ€æƒ³ï¼Œè®­ç»ƒå¼€å§‹æ˜¯ teacher forcing modeï¼Œç„¶åŽéšç€è®­ç»ƒçš„è¿‡ç¨‹ï¼Œæ…¢æ…¢é™ä½Ž ground trueçš„é¢‘çŽ‡ã€‚ å®šæœŸé‡‡æ ·Scheduled Samplingï¼šï¼ˆè¿™ä¸ªåˆæ˜¯ä¸€ç§ä¸­å’Œç­–ç•¥ï¼Œéœ€è¦è°ƒå‚ï¼‰ éšæœºçš„ä½¿ç”¨ç›®æ ‡è¯­è¨€çš„è¾“å‡ºå’Œ decoder é¢„æµ‹çš„è¾“å‡ºã€‚ ç›¸å¯¹äºŽ beam searchè€Œè¨€ï¼Œæ¯ä¸ªæ—¶åˆ»åªæ˜¯é€‰æ‹© top1çš„é‚£ç§ï¼Œç±»ä¼¼ä¸€ç§æ±‚è§£å±€éƒ¨æœ€ä¼˜è§£ï¼Œå®žé™…ä¸Šæ˜¯ä¸€ç§è´ªå¿ƒç®—æ³•ã€‚ å¤ä¹  æœ‰ä¸¤ç§encoder-decoder ç»“æž„ï¼ŒåŒºåˆ«åœ¨äºŽä¸­é—´çŠ¶æ€ä¿¡æ¯(context) æ˜¯å¦è¢«ä½¿ç”¨å¤šæ¬¡ã€‚ä¸€ç§æ˜¯åœ¨ç”Ÿæˆæ¯ä¸ªè¯è¯­çš„æ—¶å€™éƒ½ç”¨åˆ°äº† context ä¿¡æ¯ï¼Œä¸€ç§æ˜¯åªæœ‰åœ¨decoder ç¬¬ä¸€ä¸ªword çš„æ—¶å€™ä½¿ç”¨contextä¿¡æ¯ã€‚ æŸå¤±å‡½æ•°ã€ä»£ä»·å‡½æ•°å’Œç›®æ ‡å‡½æ•°çš„åŒºåˆ«ã€‚æŸå¤±å‡½æ•°æ˜¯é’ˆå¯¹å•ä¸ªæ ·æœ¬ï¼Œ ä»£ä»·å‡½æ•°æ˜¯é’ˆå¯¹æ•´ä¸ªæ•°æ®é›†ï¼Œç›®æ ‡å‡½æ•°æ˜¯ä»£ä»·å‡½æ•°+ æ­£åˆ™é¡¹ã€‚ç›®æ ‡å‡½æ•°æ˜¯å¯ä»¥æœ€å¤§åŒ–æˆ–è€…æœ€å°åŒ–ï¼Œä½†æ˜¯ä»£ä»·å‡½æ•°æ˜¯éœ€è¦æœ€å°åŒ–çš„å‡½æ•°ã€‚ åœ¨encoder-decoder çš„æ¨¡åž‹ä¸­å¸Œæœ›ç”Ÿæˆåºåˆ—å‘ç”Ÿçš„æ¦‚çŽ‡æœ€å¤§ï¼Œä¹Ÿå°±æ˜¯ç”Ÿæˆåºåˆ—çš„è”åˆæ¦‚çŽ‡æœ€å¤§ã€‚æœ‰ä¸¤ç§ç®—æ³•æ¥è®°æ€§decoderï¼Œä¸€ç§æ˜¯è´ªå¿ƒæœç´¢ï¼Œå¾—åˆ°çš„æ˜¯å±€éƒ¨æœ€ä¼˜è§£ï¼›ä¸€ç§æ˜¯ beam searchã€‚å‰è€…æ˜¯æ ¹æ®æ¨¡åž‹å’Œæ•°æ®æ¯æ¬¡é€‰æ‹©æ¦‚çŽ‡æœ€å¤§çš„ä¸€ä¸ªï¼›åŽè€…æ˜¯é€‰æ‹©æ¦‚çŽ‡æœ€å¤§çš„å‰K ä¸ªï¼Œè¿™ä¸ªå‚æ•°ç§°ä¸º beam widthã€‚ç®—æ³•å¤æ‚åº¦ç›¸å¯¹å‰è€…æ˜¯K å€çš„ã€‚ exposure bias æ˜¯æŒ‡åœ¨è®­ç»ƒå’Œpredict è¿‡ç¨‹ä¸­æ¨¡åž‹è¾“å…¥ä¸ä¸€è‡´è€Œå¯¼è‡´çš„é—®é¢˜ã€‚æ¯”å¦‚è¯´ï¼Œåœ¨è®­ç»ƒè¿‡ç¨‹ä¸­ï¼Œä½¿ç”¨ä¸Šä¸€ä¸ªçœŸå®žçš„è¯è¾“å…¥ï¼ˆä½¿ç”¨çœŸå®žtoken æœ¬èº«çš„è¡Œä¸ºå«åšteacher forcingï¼‰åˆ°ä¸‹ä¸€ä¸ªé¢„æµ‹çš„ç¥žç»å…ƒä¸­ï¼Œè€Œåœ¨é¢„æµ‹çš„æ—¶å€™æ˜¯æ²¡æœ‰çœŸå®žè¯çš„è¾“å…¥ã€‚è¿™ä¼šå¯¼è‡´é”™è¯¯çš„ç´¯è®¡ã€‚è§£å†³æ€è·¯ï¼š(1) ä½¿ç”¨ scheduled samplingï¼Œåœ¨è®­ç»ƒçš„æ—¶å€™ çœŸå®žå•è¯å’Œä¹‹å‰äº§ç”Ÿçš„å•è¯éšæœºé€‰æ‹©ï¼Œä½¿å¾—æ¨¡åž‹ä¸è¿‡åˆ†ä¾èµ–çœŸå®žå•è¯ã€‚(2): ä½¿ç”¨beam search çš„æ€æƒ³ï¼Œé€šè¿‡å¤šæ¡è·¯å¾„è€Œéžå•ä¸€è·¯å¾„ç¼“è§£ã€‚ è¿žç»­ç”Ÿæˆé‡å¤è¯è¯­é—®é¢˜çš„è§£å†³æ€è·¯: (1) beam search çš„æ€è·¯ï¼Œç»™å‡ºå¤šä¸ªä¸åŒçš„å€™é€‰è¯ (2) åˆ¤æ–­æƒ©æˆ’ï¼Œå¦‚æžœç”Ÿæˆäº†ç›¸åŒçš„ä¸Šä¸€ä¸ªè¯è¯­ï¼Œé‚£ä¹ˆæ‹’ç»è¿™ä¸ªè¯è¯­ã€‚ å¯¹äºŽdecoder ä¸­ç¥žç»å…ƒçš„è¾“å…¥å­˜åœ¨ç€ä¸¤ç§æ¨¡å¼ï¼š(1) free-running modeï¼Œ ä½¿ç”¨ä¸Šä¸€ä¸ªçŠ¶æ€çš„è¾“å‡ºç»„å§”ä¸‹ä¸€ä¸ªçŠ¶æ€çš„è¾“å…¥ï¼›(2) teacher forcing: ä½¿ç”¨ çœŸå®žç»“æžœè¿›è¡ŒæŒ‡å¯¼ï¼Œè¿™æ ·ä½¿å¾—è®­ç»ƒå˜å¾—ç¨³å®šï¼Œå¿«é€Ÿçš„æ”¶æ•›ã€‚]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>teacher_forcing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A Gentle Introduction of GBDT]]></title>
    <url>%2F2019%2F07%2F12%2Fgbdt%2F</url>
    <content type="text"><![CDATA[ä»‹ç»GBDT çš„å®šä¹‰ã€è®­ç»ƒè¿‡ç¨‹ã€ä¼˜ç¼ºç‚¹å’Œå¸¸è§çš„é—®é¢˜ã€‚ Boostingã€baggingå’Œstackingæ˜¯é›†æˆå­¦ä¹ çš„ä¸‰ç§ä¸»è¦æ–¹æ³•ã€‚ä¸åŒäºŽbaggingæ–¹æ³•ï¼Œboostingæ–¹æ³•é€šè¿‡åˆ†æ­¥è¿­ä»£ï¼ˆstage-wiseï¼‰çš„æ–¹å¼æ¥æž„å»ºæ¨¡åž‹ï¼Œåœ¨è¿­ä»£çš„æ¯ä¸€æ­¥æž„å»ºçš„å¼±å­¦ä¹ å™¨éƒ½æ˜¯ä¸ºäº†å¼¥è¡¥å·²æœ‰æ¨¡åž‹çš„ä¸è¶³ï¼Œé€šè¿‡å¼±å­¦ä¹ å™¨æå‡ä¸º å¼ºå­¦ä¹ å™¨çš„ç®—æ³•ã€‚Boostingæ—ç®—æ³•çš„è‘—åä»£è¡¨æ˜¯AdaBoost å’ŒGBDTã€‚ å®šä¹‰ç”±äºŽGBDTçš„å­¦ä¹ è¿‡ç¨‹æ˜¯é€šè¿‡å¤šè½®è¿­ä»£ï¼Œæ¯æ¬¡éƒ½åœ¨ä¸Šä¸€è½®è®­ç»ƒç»“æžœçš„æ®‹å·®ï¼ˆå¦‚æžœæ˜¯å›žå½’é—®é¢˜ï¼Œä½¿ç”¨å¹³æ–¹è¯¯å·®ä½œä¸ºloss functionï¼‰çš„åŸºç¡€ä¸Šè¿›è¡Œå­¦ä¹ ï¼ˆåŸºå‡½æ•°çš„çº¿æ€§ç»„åˆï¼‰ï¼Œæ¥å¯¹æ•°æ®è¿›è¡Œåˆ†ç±»æˆ–è€…å›žå½’ã€‚è®­ç»ƒçš„è¿‡ç¨‹æ˜¯é€šè¿‡ä¸æ–­é™ä½Žåå·®æ¥æé«˜æœ€åŽåˆ†ç±»å™¨çš„ç²¾åº¦ã€‚ ç†è§£GBDTè¦åˆ†ä¸ºä¸¤æ­¥ï¼Œç¬¬ä¸€æ­¥æ˜¯ç†è§£ä»€ä¹ˆå«åšç”¨å†³ç­–æ ‘åŽ»æ‹Ÿåˆå½“å‰æ¨¡åž‹çš„æ®‹å·®ï¼Œç¬¬äºŒæ­¥æ˜¯ç†è§£ä¸ºä»€ä¹ˆä»¥åŠå¦‚ä½•ç”¨æŸå¤±å‡½æ•°çš„è´Ÿæ¢¯åº¦åŽ»æ›¿ä»£å½“å‰æ¨¡åž‹çš„æ®‹å·®ã€‚ GDBT å¤„ç†åˆ†ç±»é—®é¢˜GBDTåœ¨è§£å†³åˆ†ç±»é—®é¢˜æ—¶æœ‰ä¸¤ç§åŠžæ³•ï¼Œä¸€ä¸ªæ˜¯é€‰æ‹©æŒ‡æ•°æŸå¤±å‡½æ•°ä½œä¸ºæŸå¤±å‡½æ•°ï¼Œæ­¤æ—¶GBDTé€€åŒ–ä¸ºAdaBoostç®—æ³•ï¼Œå¦ä¸€ä¸ªæ˜¯é€‰æ‹©ç±»ä¼¼äºŽé€»è¾‘å›žå½’çš„å¯¹æ•°ä¼¼ç„¶æŸå¤±å‡½æ•°ã€‚ï¼ˆé€»è¾‘å›žå½’ä½¿ç”¨çš„æ˜¯å¯¹æ•°ä¼¼ç„¶å‡½æ•°ï¼‰ å½“æŸå¤±å‡½æ•°å–å¹³æ–¹è¯¯å·®æŸå¤±å‡½æ•°å’ŒæŒ‡æ•°æŸå¤±å‡½æ•°æ—¶ï¼Œæ¯ä¸€æ­¥çš„ä¼˜åŒ–è¿˜ç®—ç®€å•ï¼Œå¯æ˜¯å¦‚æžœæŸå¤±å‡½æ•°æ˜¯å…¶ä»–ä¸€èˆ¬æŸå¤±å‡½æ•°æ—¶ï¼Œé‚£å¯å°±éš¾äº†ã€‚ç±»ä¼¼é€»è¾‘å›žå½’ä¸­çš„æ±‚è§£è¿‡ç¨‹ï¼Œä½¿ç”¨æ¢¯åº¦ä¸‹é™çš„æ–¹å¼ç®€åŒ–äº†ä¼˜åŒ–è¿‡ç¨‹ï¼Œå­¦è€…ä½¿ç”¨æ¢¯åº¦ä¸Šå‡çš„æ–¹å¼è¿‘ä¼¼æ±‚è§£æå‡æ ‘çš„ä¼˜åŒ–è¿‡ç¨‹ã€‚GBDTè¿™ä¸ªç®—æ³•ä¸­æœ€å…³é”®çš„ä¸€ç‚¹å°±æ˜¯ç”¨æŸå¤±å‡½æ•°åœ¨å½“å‰æ¨¡åž‹ä¸­çš„è´Ÿæ¢¯åº¦å€¼ï¼Œå³ï¼š ä½¿ç”¨å¹³æ–¹æŸå¤±å‡½æ•°æ—¶å€™ï¼ŒGBDTç®—æ³•çš„æ¯ä¸€æ­¥åœ¨ç”Ÿæˆå†³ç­–æ ‘åªæ˜¯æ‹Ÿåˆå‰é¢æ¨¡åž‹çš„æ®‹å·®ï¼Œï¼ˆy- y^ï¼‰æ®‹å·®æ˜¯æ¢¯åº¦çš„ä¸€ä¸ªç‰¹ä¾‹ã€‚è€Œå½“æŸå¤±å‡½æ•°æ˜¯å…¶ä»–çš„å½¢å¼æ—¶å€™ï¼Œä¸‹ä¸€æ¬¡è¿­ä»£æ˜¯ä½¿ç”¨çš„è´Ÿæ¢¯åº¦å€¼ã€‚ å¯¹äºŽä¸€èˆ¬æŸå¤±å‡½æ•°ï¼Œä¸ºäº†ä½¿å…¶å–å¾—æœ€å°å€¼ï¼Œé€šè¿‡æ¢¯åº¦ä¸‹é™ç®—æ³•ï¼Œæ¯æ¬¡æœç€æŸå¤±å‡½æ•°çš„è´Ÿæ¢¯åº¦æ–¹å‘é€æ­¥ç§»åŠ¨ï¼Œæœ€ç»ˆä½¿å¾—æŸå¤±å‡½æ•°æžå°çš„æ–¹æ³•ï¼ˆæ­¤æ–¹æ³•è¦æ±‚æŸå¤±å‡½æ•°å¯å¯¼ï¼‰ã€‚ æ€»çš„æ¥è¯´ï¼Œç¬¬ä¸€é¢—æ ‘æ˜¯ç”±åŸºå°¼ç³»æ•°å†³å®š? ï¼Œä¹‹åŽæ‰€æœ‰çš„æ ‘çš„å†³ç­–å…¨æ˜¯ç”±æ®‹å·®æ¥å†³å®šã€‚ GBDTçš„æ€æƒ³å¯ä»¥ç”¨ä¸€ä¸ªé€šä¿—çš„ä¾‹å­è§£é‡Šï¼Œå‡å¦‚æœ‰ä¸ªäºº30å²ï¼Œæˆ‘ä»¬é¦–å…ˆç”¨20å²åŽ»æ‹Ÿåˆï¼Œå‘çŽ°æŸå¤±æœ‰10å²ï¼Œè¿™æ—¶æˆ‘ä»¬ç”¨6å²åŽ»æ‹Ÿåˆå‰©ä¸‹çš„æŸå¤±ï¼Œå‘çŽ°å·®è·è¿˜æœ‰4å²ï¼Œç¬¬ä¸‰è½®æˆ‘ä»¬ç”¨3å²æ‹Ÿåˆå‰©ä¸‹çš„å·®è·ï¼Œå·®è·å°±åªæœ‰ä¸€å²äº†ã€‚å¦‚æžœæˆ‘ä»¬çš„è¿­ä»£è½®æ•°è¿˜æ²¡æœ‰å®Œï¼Œå¯ä»¥ç»§ç»­è¿­ä»£ä¸‹é¢ï¼Œæ¯ä¸€è½®è¿­ä»£ï¼Œæ‹Ÿåˆçš„å²æ•°è¯¯å·®éƒ½ä¼šå‡å°ã€‚ è®­ç»ƒè¿‡ç¨‹How Gradient Boosting WorksGradient boosting involves three elements: A loss function to be optimized. A weak learner to make predictions. An additive model to add weak learners to minimize the loss function. loss functionThe loss function used depends on the type of problem being solved.It must be differentiable, but many standard loss functions are supported and you can define your own.For example, regression may use a squared error and classification may use logarithmic loss.A benefit of the gradient boosting framework is that a new boosting algorithm does not have to be derived for each loss function that may want to be used, instead, it is a generic enough framework that any differentiable loss function can be used. log lossä¸»è¦ç”¨æ¥è¡¡é‡äºŒåˆ†ç±»ï¼Œcross entroyä¸»è¦ç”¨æ¥è¡¡é‡å¤šåˆ†ç±»ï¼Œå‰è€…æ˜¯åŽè€…åœ¨äºŒåˆ†ç±»ä¸‹çš„ç‰¹ä¾‹äº¤å‰ç†µå…¬å¼ (cross entroy) $- \sum _ { i = 1 } ^ { K } p _ { i } \log q _ { i }$ å…¶ä¸­ $p_i$ è¡¨ç¤ºçœŸå®žçš„åˆ†å¸ƒï¼Œ $q_i$ è¡¨ç¤ºé¢„æµ‹åˆ†å¸ƒ, $K$ è¡¨ç¤ºåˆ†ç±»æ•°; å½“ $K =2$ äº¤å‰ç†µé€€åŒ–æˆ log loss: $- [ y \log \hat { y } + (1-y)log(1 -\hat{y}) ]$ cross entroyä¸Žloglossä¸»è¦ç”¨æ¥è¡¡é‡åˆ†ç±»ç®—æ³•æ€§èƒ½ï¼Œå› ä¸ºcross entroyæ„ä¹‰æ˜¯è¡¡é‡çœŸå®žåˆ†å¸ƒpå’Œé¢„æµ‹åˆ†å¸ƒqçš„åˆ†å¸ƒå·®å¼‚ç¨‹åº¦ï¼›mseä¸»è¦ç”¨æ¥è¡¡é‡å›žå½’ç®—æ³•æ€§èƒ½ï¼› weak learnerå¼±åˆ†ç±»å™¨ä¸€èˆ¬é€‰æ‹© CART ï¼ˆåˆ†ç±»å›žå½’æ ‘ï¼‰ Classification And Regression Tree(CART)æ˜¯å†³ç­–æ ‘çš„ä¸€ç§ï¼Œå¹¶ä¸”æ˜¯éžå¸¸é‡è¦çš„å†³ç­–æ ‘ï¼Œ Decision trees are used as the weak learner in gradient boosting.Specifically regression trees are used that output real values for splits and whose output can be added together, allowing subsequent models outputs to be added and â€œcorrectâ€ the residuals in the predictions. It is common to constrain the weak learners in specific ways, such as a maximum number of layers, nodes, splits or leaf nodes.This is to ensure that the learners remain weak, but can still be constructed in a greedy manner. additive modelTrees are added one at a time, and existing trees in the model are not changed.A gradient descent procedure is used to minimize the loss when adding trees. Traditionally, gradient descent is used to minimize a set of parameters, such as the coefficients in a regression equation or weights in a neural network. After calculating error or loss, the weights are updated to minimize that error.Instead of parameters, we have weak learner sub-models or more specifically decision trees. After calculating the loss, to perform the gradient descent procedure, we must add a tree to the model that reduces the loss (i.e. follow the gradient). We do this by parameterizing the tree, then modify the parameters of the tree and move in the right direction by (reducing the residual loss.Generally this approach is called functional gradient descent or gradient descent with functions. GBDTå­¦ä¹ è¿‡ç¨‹ï¼šå…ˆä½¿ç”¨ä¸€ä¸ªåˆå§‹å€¼æ¥å­¦ä¹ ä¸€ä¸ªå†³ç­–æ ‘ï¼Œå¶å­å¯ä»¥å¾—åˆ°é¢„æµ‹çš„å€¼ï¼Œä»¥åŠæ®‹å·®ï¼Œç„¶åŽåŽé¢çš„å†³ç­–æ ‘æ˜¯åŸºäºŽå‰é¢çš„å†³ç­–æ ‘çš„æ®‹å·®è¿›è¡Œå­¦ä¹ ï¼Œç›´åˆ°æ®‹å·®ä¸º0.å¯¹äºŽæµ‹è¯•æ ·æœ¬çš„é¢„æµ‹å€¼ï¼Œå°±æ˜¯è®¸å¤šå†³ç­–æ ‘é¢„æµ‹å€¼çš„ç´¯åŠ ã€‚ GBDTé€šè¿‡å¤šè½®è¿­ä»£,æ¯è½®è¿­ä»£äº§ç”Ÿä¸€ä¸ªå¼±åˆ†ç±»å™¨ï¼Œæ¯ä¸ªåˆ†ç±»å™¨åœ¨ä¸Šä¸€è½®åˆ†ç±»å™¨çš„æ®‹å·®åŸºç¡€ä¸Šè¿›è¡Œè®­ç»ƒã€‚å¯¹å¼±åˆ†ç±»å™¨çš„è¦æ±‚ä¸€èˆ¬æ˜¯è¶³å¤Ÿç®€å•ï¼Œå¹¶ä¸”æ˜¯ä½Žæ–¹å·®å’Œé«˜åå·®çš„ã€‚å› ä¸ºè®­ç»ƒçš„è¿‡ç¨‹æ˜¯é€šè¿‡é™ä½Žåå·®æ¥ä¸æ–­æé«˜æœ€ç»ˆåˆ†ç±»å™¨çš„ç²¾åº¦ã€‚ æŸå¤±å‡½æ•°ï¼šäºŒåˆ† log loss ï¼Œå¤šåˆ† äº¤å‰ç†µlossï¼Œå›žå½’ å¹³æ–¹æŸå¤±å¼±å­¦ä¹ å™¨ï¼ˆweak learnerï¼‰ï¼šåŠ æ³•æ¨¡åž‹ï¼š ä½¿ç”¨æ¢¯åº¦ä¸‹é™çš„æ–¹å¼åŽ»å‡å°‘lossï¼Œ å½“å¢žåŠ ä¸€ä¸ªæ–°çš„æ ‘A gradient descent procedure is used to minimize the loss when adding trees. å…·ä½“è¯´è¿™ä¸ªå¼±å­¦ä¹ å™¨ï¼ŒGBDT é€‰æ‹©ç‰¹å¾çš„è¿‡ç¨‹å°±æ˜¯ CART (åˆ†ç±»å›žå½’æ ‘)é€‰æ‹©ç‰¹å¾çš„è¿‡ç¨‹ã€‚é€‰æ‹©ç‰¹å¾æ˜¯ï¼šéåŽ†æ¯ä¸ªç‰¹å¾å’Œæ¯ä¸ªç‰¹å¾çš„æ‰€æœ‰åˆ‡åˆ†ç‚¹ï¼Œæ‰¾åˆ°æœ€ä¼˜çš„ç‰¹å¾å’Œæœ€ä¼˜çš„åˆ‡åˆ†ç‚¹ã€‚å¤šä¸ªCART TREE ç”Ÿæˆè¿‡ç¨‹ä¸­ï¼Œé€‰æ‹©æœ€ä¼˜ç‰¹å¾åˆ‡åˆ†è¾ƒå¤šçš„ç‰¹å¾å°±æ˜¯é‡è¦çš„ç‰¹å¾ã€‚ ç›®å‰GBDT çš„ç®—æ³•æ¯”è¾ƒå¥½çš„åº“æ˜¯ xgboost ä¼˜ç¼ºç‚¹ä¼˜ç‚¹ï¼ˆç›¸å¯¹äºŽ LR or SVMï¼‰ï¼š å¯ä»¥çµæ´»çš„å¤„ç†å„ç§ç±»åž‹çš„æ•°æ®ï¼ŒåŒ…æ‹¬è¿žç»­åž‹å’Œç¦»æ•£åž‹ï¼Œå¤„ç†åˆ†ç±»å’Œå›žå½’é—®é¢˜ ç»§æ‰¿äº†æ ‘æ¨¡åž‹çš„ä¼˜ç‚¹ï¼š å¯¹å¼‚å¸¸å€¼é²æ£’ï¼Œå¤„ç†ç¼ºçœå€¼ å³ä½¿æ˜¯å¤§é‡æ•°æ®ï¼Œä¹Ÿå¯ä»¥æ–¹ä¾¿çš„å¤„ç†ï¼Œç›¸å¯¹æ¯”SVM æ¥è¯´ã€‚ ç¼ºç‚¹ï¼š æ— æ³•å¹¶è¡Œ åœ¨ä¸å¸¦å™ªå£°çš„æ•°æ®ä¸Šï¼Œåˆ†ç±»æ•ˆæžœä¸å¦‚LRæˆ–è€… SVM å¸¸è§çš„é—®é¢˜ ä¸ºä»€ä¹ˆGBDTè¦æŠŠCARTå›žå½’æ ‘æ ‘åˆ†æˆmæ£µäºŒå‰æ ‘åŽ»æ±‚ï¼ˆæ¯æ£µæ ‘åªæœ‰ä¸¤ä¸ªå¶å­èŠ‚ç‚¹ï¼‰ï¼Œè€Œä¸æ˜¯æ±‚ä¸€æ£µäºŒå‰æ ‘ï¼Œè¿™æ£µæ ‘æœ‰m+1ï¼ˆæœ€å¤šæœ‰2mä¸ªå¶å­èŠ‚ç‚¹ï¼‰å±‚å‘¢ï¼Ÿ è¿™æ˜¯ä¸ºäº†è§£å†³è¿‡æ‹Ÿåˆé—®é¢˜ï¼ŒåŸºå­¦ä¹ å™¨è¦å…·æœ‰ç®€å•ã€é«˜åå·®å’Œä½Žæ–¹å·®çš„ç‰¹ç‚¹ï¼Œå› æ­¤æ¯æ£µCARTå›žå½’æ ‘çš„æ·±åº¦ä¸ä¼šå¾ˆæ·±ã€‚ ä¸ºä»€ä¹ˆç¬¬mæ¬¡å­¦ä¹ çš„ç›®æ ‡ï¼Œæ˜¯å‰m-1æ£µæ ‘é¢„æµ‹å€¼çš„ç´¯åŠ å’Œçš„æ®‹å·®ï¼Ÿ ä¸€æ–¹é¢é€šè¿‡åˆ†æ­¥æ±‚è§£ï¼Œä¸€æ­¥æ­¥é€¼è¿‘ç›®æ ‡å€¼ï¼Œæ¯”ä¸€æ­¥åˆ°ä½è¦ç®€å•ï¼›å¦ä¸€æ–¹é¢æ¯ä¸€æ­¥çš„æ®‹å·®è®¡ç®—å…¶å®žå˜ç›¸åœ°å¢žå¤§äº†è¢«åˆ†é”™çš„å®žä¾‹çš„æƒé‡ï¼Œå› ä¸ºè¢«åˆ†é”™çš„å®žä¾‹å…¶æ®‹å·®è¾ƒå¤§ï¼Œè€Œå·²ç»åˆ†å¯¹çš„å®žä¾‹çš„æ®‹å·®è¶‹è¿‘äºŽ0ã€‚è¿™æ ·åŽé¢çš„æ ‘å°±èƒ½è¶Šæ¥è¶Šä¸“æ³¨äºŽå‰é¢è¢«åˆ†é”™çš„å®žä¾‹äº†ã€‚æå‡æ ‘æ˜¯è¿­ä»£å¤šæ£µå›žå½’æ ‘æ¥å…±åŒå†³ç­–ã€‚å½“é‡‡ç”¨å¹³æ–¹è¯¯å·®æŸå¤±å‡½æ•°æ—¶ï¼Œæ¯ä¸€æ£µå›žå½’æ ‘å­¦ä¹ çš„æ˜¯ä¹‹å‰æ‰€æœ‰æ ‘çš„ç»“è®ºå’Œæ®‹å·®ï¼Œæ‹Ÿåˆå¾—åˆ°ä¸€ä¸ªå½“å‰çš„æ®‹å·®å›žå½’æ ‘ï¼Œæ®‹å·®çš„æ„ä¹‰å¦‚å…¬å¼ï¼šæ®‹å·® = çœŸå®žå€¼ - é¢„æµ‹å€¼ ã€‚æå‡æ ‘å³æ˜¯æ•´ä¸ªè¿­ä»£è¿‡ç¨‹ç”Ÿæˆçš„å›žå½’æ ‘çš„ç´¯åŠ ã€‚ AdaBoost ç®—æ³•å’Œ GBDT ç®—æ³•çš„åŒºåˆ« Boostingæ—ç®—æ³•çš„è‘—åä»£è¡¨æ˜¯AdaBoostï¼ŒAdaBoostç®—æ³•é€šè¿‡ç»™å·²æœ‰æ¨¡åž‹é¢„æµ‹é”™è¯¯çš„æ ·æœ¬æ›´é«˜çš„æƒé‡ï¼Œä½¿å¾—å…ˆå‰çš„å­¦ä¹ å™¨åšé”™çš„è®­ç»ƒæ ·æœ¬åœ¨åŽç»­å—åˆ°æ›´å¤šçš„å…³æ³¨çš„æ–¹å¼æ¥å¼¥è¡¥å·²æœ‰æ¨¡åž‹çš„ä¸è¶³ã€‚ä¸ŽAdaBoostç®—æ³•ä¸åŒï¼Œæ¢¯åº¦æå‡æ–¹æ³•åœ¨è¿­ä»£çš„æ¯ä¸€æ­¥æž„å»ºä¸€ä¸ªèƒ½å¤Ÿæ²¿ç€æ¢¯åº¦æœ€é™¡çš„æ–¹å‘é™ä½ŽæŸå¤±ï¼ˆsteepest-descentï¼‰çš„å­¦ä¹ å™¨æ¥å¼¥è¡¥å·²æœ‰æ¨¡åž‹çš„ä¸è¶³ã€‚ç»å…¸çš„AdaBoostç®—æ³•åªèƒ½å¤„ç†é‡‡ç”¨æŒ‡æ•°æŸå¤±å‡½æ•°çš„äºŒåˆ†ç±»å­¦ä¹ ä»»åŠ¡2ï¼Œè€Œæ¢¯åº¦æå‡æ–¹æ³•é€šè¿‡è®¾ç½®ä¸åŒçš„å¯å¾®æŸå¤±å‡½æ•°å¯ä»¥å¤„ç†å„ç±»å­¦ä¹ ä»»åŠ¡ï¼ˆå¤šåˆ†ç±»ã€å›žå½’ã€Rankingç­‰ï¼‰ï¼Œåº”ç”¨èŒƒå›´å¤§å¤§æ‰©å±•ã€‚å¦ä¸€æ–¹é¢ï¼ŒAdaBoostç®—æ³•å¯¹å¼‚å¸¸ç‚¹ï¼ˆoutlierï¼‰æ¯”è¾ƒæ•æ„Ÿï¼Œè€Œæ¢¯åº¦æå‡ç®—æ³•é€šè¿‡å¼•å…¥baggingæ€æƒ³ã€åŠ å…¥æ­£åˆ™é¡¹ç­‰æ–¹æ³•èƒ½å¤Ÿæœ‰æ•ˆåœ°æŠµå¾¡è®­ç»ƒæ•°æ®ä¸­çš„å™ªéŸ³ï¼Œå…·æœ‰æ›´å¥½çš„å¥å£®æ€§ã€‚è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆæ¢¯åº¦æå‡ç®—æ³•ï¼ˆå°¤å…¶æ˜¯é‡‡ç”¨å†³ç­–æ ‘ä½œä¸ºå¼±å­¦ä¹ å™¨çš„GBDTç®—æ³•ï¼‰å¦‚æ­¤æµè¡Œçš„åŽŸå› ï¼Œæœ‰ç§è§‚ç‚¹è®¤ä¸ºGBDTæ˜¯æ€§èƒ½æœ€å¥½çš„æœºå™¨å­¦ä¹ ç®—æ³•ï¼Œè¿™å½“ç„¶æœ‰ç‚¹è¿‡äºŽæ¿€è¿›åˆå›ºæ­¥è‡ªå°çš„å‘³é“ï¼Œä½†é€šå¸¸å„ç±»æœºå™¨å­¦ä¹ ç®—æ³•æ¯”èµ›çš„èµ¢å®¶ä»¬éƒ½éžå¸¸é’çGBDTç®—æ³•ï¼Œç”±æ­¤å¯è§è¯¥ç®—æ³•çš„å®žåŠ›ä¸å¯å°è§‘ã€‚ æŸå¤±å‡½æ•°ï¼šadaboost ä½¿ç”¨çš„æ˜¯æŒ‡æ•°æŸå¤±å‡½æ•°çš„ç®—æ³•ï¼Œè€Œgbdt å¯ä»¥ä½¿ç”¨ä¸åŒçš„å¯å¾®çš„æŸå¤±å‡½æ•°è¿›è¡Œåˆ†ç±»å’Œå›žå½’é—®é¢˜ adaboost ä¸€èˆ¬æ˜¯ç”¨äºŽåˆ†ç±»ï¼Œgbt ä¸€èˆ¬ç”¨äºŽå›žå½’ã€‚ ä¸ºä»€ä¹ˆæ˜¯ä½Žæ–¹å·®ï¼Ÿgbdté€šè¿‡å¤šè½®è¿­ä»£,æ¯è½®è¿­ä»£äº§ç”Ÿä¸€ä¸ªå¼±åˆ†ç±»å™¨ï¼Œæ¯ä¸ªåˆ†ç±»å™¨åœ¨ä¸Šä¸€è½®åˆ†ç±»å™¨çš„æ®‹å·®åŸºç¡€ä¸Šè¿›è¡Œè®­ç»ƒã€‚å¯¹å¼±åˆ†ç±»å™¨çš„è¦æ±‚ä¸€èˆ¬æ˜¯è¶³å¤Ÿç®€å•ï¼Œå¹¶ä¸”æ˜¯ä½Žæ–¹å·®å’Œé«˜åå·®çš„ã€‚å› ä¸ºè®­ç»ƒçš„è¿‡ç¨‹æ˜¯é€šè¿‡é™ä½Žåå·®æ¥ä¸æ–­æé«˜æœ€ç»ˆåˆ†ç±»å™¨çš„ç²¾åº¦ï¼Œï¼ˆæ­¤å¤„æ˜¯å¯ä»¥è¯æ˜Žçš„ï¼‰ã€‚é€šä¿—çš„ç†è§£ï¼Œæ–¹å·®æ¯”è¾ƒä½Žå°±æ˜¯æ¨¡åž‹è¡¨çŽ°çš„ç¨³å®šä¸Žå¦ã€‚ ä»€ä¹ˆæ˜¯NP é—®é¢˜?NPé—®é¢˜æ˜¯æŒ‡å¯ä»¥åœ¨å¤šé¡¹å¼çš„æ—¶é—´é‡ŒéªŒè¯ä¸€ä¸ªè§£çš„é—®é¢˜ã€‚NPé—®é¢˜çš„å¦ä¸€ä¸ªå®šä¹‰æ˜¯ï¼Œå¯ä»¥åœ¨å¤šé¡¹å¼çš„æ—¶é—´é‡ŒçŒœå‡ºä¸€ä¸ªè§£çš„é—®é¢˜ã€‚ Bagging ç®—æ³•? Baggingç®—æ³•æ˜¯è¿™æ ·åšçš„ï¼šæ¯ä¸ªåˆ†ç±»å™¨éƒ½éšæœºä»ŽåŽŸæ ·æœ¬ä¸­åšæœ‰æ”¾å›žçš„é‡‡æ ·ï¼Œç„¶åŽåˆ†åˆ«åœ¨è¿™äº›é‡‡æ ·åŽçš„æ ·æœ¬ä¸Šè®­ç»ƒåˆ†ç±»å™¨ï¼Œç„¶åŽå†æŠŠè¿™äº›åˆ†ç±»å™¨ç»„åˆèµ·æ¥ã€‚ç®€å•çš„å¤šæ•°æŠ•ç¥¨ä¸€èˆ¬å°±å¯ä»¥ã€‚å…¶ä»£è¡¨ç®—æ³•æ˜¯éšæœºæ£®æž— AdaBoostAdaBoostï¼Œæ˜¯è‹±æ–‡â€Adaptive Boostingâ€ï¼ˆè‡ªé€‚åº”å¢žå¼ºï¼‰çš„ç¼©å†™ã€‚å®ƒçš„è‡ªé€‚åº”åœ¨äºŽï¼šå‰ä¸€ä¸ªåŸºæœ¬åˆ†ç±»å™¨åˆ†é”™çš„æ ·æœ¬ä¼šå¾—åˆ°åŠ å¼ºï¼ŒåŠ æƒåŽçš„å…¨ä½“æ ·æœ¬å†æ¬¡è¢«ç”¨æ¥è®­ç»ƒä¸‹ä¸€ä¸ªåŸºæœ¬åˆ†ç±»å™¨ã€‚åŒæ—¶ï¼Œåœ¨æ¯ä¸€è½®ä¸­åŠ å…¥ä¸€ä¸ªæ–°çš„å¼±åˆ†ç±»å™¨ï¼Œç›´åˆ°è¾¾åˆ°æŸä¸ªé¢„å®šçš„è¶³å¤Ÿå°çš„é”™è¯¯çŽ‡æˆ–è¾¾åˆ°é¢„å…ˆæŒ‡å®šçš„æœ€å¤§è¿­ä»£æ¬¡æ•°ã€‚ å…·ä½“è¯´æ¥ï¼Œæ•´ä¸ªAdaboost è¿­ä»£ç®—æ³•å°±3æ­¥ï¼š åˆå§‹åŒ–è®­ç»ƒæ•°æ®çš„æƒå€¼åˆ†å¸ƒã€‚å¦‚æžœæœ‰Nä¸ªæ ·æœ¬ï¼Œåˆ™æ¯ä¸€ä¸ªè®­ç»ƒæ ·æœ¬æœ€å¼€å§‹æ—¶éƒ½è¢«èµ‹äºˆç›¸åŒçš„æƒå€¼ï¼š1/Nã€‚ è®­ç»ƒå¼±åˆ†ç±»å™¨ã€‚å…·ä½“è®­ç»ƒè¿‡ç¨‹ä¸­ï¼Œå¦‚æžœæŸä¸ªæ ·æœ¬ç‚¹å·²ç»è¢«å‡†ç¡®åœ°åˆ†ç±»ï¼Œé‚£ä¹ˆåœ¨æž„é€ ä¸‹ä¸€ä¸ªè®­ç»ƒé›†ä¸­ï¼Œå®ƒçš„æƒå€¼å°±è¢«é™ä½Žï¼›ç›¸åï¼Œå¦‚æžœæŸä¸ªæ ·æœ¬ç‚¹æ²¡æœ‰è¢«å‡†ç¡®åœ°åˆ†ç±»ï¼Œé‚£ä¹ˆå®ƒçš„æƒå€¼å°±å¾—åˆ°æé«˜ã€‚ç„¶åŽï¼Œæƒå€¼æ›´æ–°è¿‡çš„æ ·æœ¬é›†è¢«ç”¨äºŽè®­ç»ƒä¸‹ä¸€ä¸ªåˆ†ç±»å™¨ï¼Œæ•´ä¸ªè®­ç»ƒè¿‡ç¨‹å¦‚æ­¤è¿­ä»£åœ°è¿›è¡Œä¸‹åŽ»ã€‚ å°†å„ä¸ªè®­ç»ƒå¾—åˆ°çš„å¼±åˆ†ç±»å™¨ç»„åˆæˆå¼ºåˆ†ç±»å™¨ã€‚å„ä¸ªå¼±åˆ†ç±»å™¨çš„è®­ç»ƒè¿‡ç¨‹ç»“æŸåŽï¼ŒåŠ å¤§åˆ†ç±»è¯¯å·®çŽ‡å°çš„å¼±åˆ†ç±»å™¨çš„æƒé‡ï¼Œä½¿å…¶åœ¨æœ€ç»ˆçš„åˆ†ç±»å‡½æ•°ä¸­èµ·ç€è¾ƒå¤§çš„å†³å®šä½œç”¨ï¼Œè€Œé™ä½Žåˆ†ç±»è¯¯å·®çŽ‡å¤§çš„å¼±åˆ†ç±»å™¨çš„æƒé‡ï¼Œä½¿å…¶åœ¨æœ€ç»ˆçš„åˆ†ç±»å‡½æ•°ä¸­èµ·ç€è¾ƒå°çš„å†³å®šä½œç”¨ã€‚æ¢è¨€ä¹‹ï¼Œè¯¯å·®çŽ‡ä½Žçš„å¼±åˆ†ç±»å™¨åœ¨æœ€ç»ˆåˆ†ç±»å™¨ä¸­å çš„æƒé‡è¾ƒå¤§ï¼Œå¦åˆ™è¾ƒå°ã€‚ å¯¹äºŽå†³ç­–æ ‘ï¼ŒAdabooståˆ†ç±»ç”¨äº†CARTåˆ†ç±»æ ‘ï¼Œè€ŒAdaboostå›žå½’ç”¨äº†CARTå›žå½’æ ‘ã€‚ AdaBoost çš„ä¼˜ç‚¹ï¼š ä½œä¸ºåˆ†ç±»å™¨ï¼Œåˆ†ç±»ç²¾åº¦æ¯”è¾ƒé«˜ ç®€å•çš„äºŒå…ƒåˆ†ç±»å™¨ï¼Œæž„é€ ç®€å•ï¼Œç»“æžœå¯ç†è§£ ä¸å®¹æ˜“å‘ç”Ÿè¿‡æ‹Ÿåˆ ç¼ºç‚¹ï¼š å¯¹å¼‚å¸¸æ ·æœ¬æ•æ„Ÿï¼Œå¼‚å¸¸æ ·æœ¬åœ¨è¿­ä»£è¿‡ç¨‹ä¸­å¯èƒ½èŽ·å¾—è¾ƒé«˜çš„æƒé‡ï¼Œå½±å“æœ€ç»ˆçš„å¼ºå­¦ä¹ å™¨çš„é¢„æµ‹å‡†ç¡®çŽ‡ã€‚ å¤ä¹ æ€»ç»“ gbdt çš„ä¼˜ç‚¹a. å¯ä»¥çµæ´»çš„å¤„ç†å„ç±»æ•°æ®ï¼ˆè¿žç»­æ€§å’Œç¦»æ•£åž‹ï¼‰ï¼Œ ä½¿ç”¨ç¨ å¯†çš„æ•°æ®æ›´åŠ ï¼Œå¯¹äºŽç¨€ç–çš„æ•°æ®ï¼Œå¯èƒ½LR è¿™äº›æ¨¡åž‹æ›´åŠ å¥½ã€‚b. ç»§æ‰¿äº†æ ‘æ¨¡åž‹çš„ä¼˜ç‚¹ï¼š å¯¹äºŽå¼‚å¸¸å€¼å’Œç¼ºçœå€¼æœ‰å¾ˆå¥½çš„å¤„ç†çš„æ•ˆæžœã€‚å› ä¸ºæ˜¯åœ¨æ ‘èŠ‚ç‚¹åˆ†è£‚ï¼Œé‚£ä¹ˆå¼‚å¸¸å€¼çš„å½±å“æ˜¯æ¯”è¾ƒå°çš„ï¼›å•ç‹¬æŠŠç¼ºçœå€¼æ”¾åˆ°ä¸€è¾¹ï¼Œæœ€åŽå¤„ç†ï¼Œå¯ä»¥æ”¯æŒå¯¹ç¼ºçœå€¼çš„å¤„ç†c. å¤§é‡æ•°æ®ä¹Ÿå¯ä»¥æ–¹ä¾¿å¤„ç†ï¼ˆç›¸å¯¹äºŽ svm è€Œè¨€ï¼‰ï¼Œå¦‚æžœè¯´æ”¯æŒæ•°æ®é‡æœ€å¤§çš„ï¼Œè¿˜æ˜¯ LRç¼ºç‚¹ï¼ša. å¦‚æžœå™ªå£°å¾ˆå¤šï¼Œé‚£ä¹ˆæ˜¯å®¹æ˜“è¿‡æ‹Ÿåˆï¼› å¦‚æžœåœ¨ä¸å¸¦å™ªå£°çš„æ•°æ®é›†ä¸Šï¼Œåˆ†ç±»æ•ˆæžœä¸å¦‚LR æˆ–è€… SVMï¼›çŽ°å®žä¸­çš„æ•°æ®æ˜¯æœ‰ç‚¹å™ªå£°ï¼Œé‚£ä¹ˆä½¿ç”¨ GBDT è¿˜æ˜¯å¯ä»¥çš„ã€‚b. æ— æ³•å¹¶è¡Œï¼ˆä¸»è¦æ˜¯æŒ‡ å†³ç­–æ ‘çš„å»ºç«‹è¿‡ç¨‹ï¼‰ gbdt çš„æŸå¤±å‡½æ•°å¦‚æžœæ˜¯äºŒåˆ†ç±»ä¸€èˆ¬ä½¿ç”¨log lossï¼Œå¤šåˆ†ç±»ä½¿ç”¨äº¤å‰ç†µæŸå¤±å‡½æ•°ï¼Œå›žå½’ç®—æ³•ä½¿ç”¨å‡æ–¹è¯¯å·®æŸå¤±å‡½æ•°ã€‚ gbdt æ ¸å¿ƒçš„çŸ¥è¯†ç‚¹a. åŸºå­¦ä¹ å™¨éœ€è¦è¶³å¤Ÿçš„ç®€å•ï¼Œå…·æœ‰é«˜åå·®å’Œä½Žæ–¹å·®ï¼Œè¿™ä¸ªæ˜¯ä¸ºäº†ç¼“è§£è¿‡æ‹Ÿåˆçš„é—®é¢˜b. é€šè¿‡å¤šä¸ªåˆ†ç±»å™¨çš„çº¿æ€§ç´¯åŠ æ±‚æœ€åŽçš„é¢„æµ‹ç»“æžœï¼Œå˜ç›¸çš„å¢žåŠ äº†è¢«åˆ†é”™çš„æ ·æœ¬çš„æƒé‡ï¼ˆåˆ†å¯¹å®žä¾‹çš„æ®‹å·®æ˜¯0ï¼‰ adaboost å’Œgbdçš„åŒºåˆ«a. é¦–å…ˆä¸¤è€…éƒ½æ˜¯boostingæå‡ç®—æ³•ã€‚åŒºåˆ«åœ¨äºŽå®žçŽ°æ–¹å¼ï¼Œadaboost æ˜¯åˆ†é…æƒé‡ï¼Œadabooståœ¨ä¸‹ä¸€è½®çš„å¾ªçŽ¯ä¸­åˆ†é”™çš„æ ·æœ¬å¾—åˆ°åŠ å¼ºï¼Œåˆ†å¯¹çš„åˆ†ç±»å™¨å¾—åˆ°åŠ å¼ºï¼›gbdt æ˜¯é€šè¿‡æ¢¯åº¦ä¸‹é™çš„æ–¹å¼å®žçŽ°çš„ï¼Œå®šä¹‰ä¸€ä¸ªlossï¼Œç„¶åŽåˆ†é”™çš„loss æ˜¯æ¯”è¾ƒå¤§çš„ï¼Œç„¶åŽé€šè¿‡å‡å°‘lossé—´æŽ¥çš„é‡è§†åˆ†é”™çš„æ ·æœ¬ã€‚b. adaboost å¯¹äºŽå¼‚å¸¸å€¼æ¯”è¾ƒæ•æ„Ÿï¼Œgbdt æ¯ä¸€ä¸ªåˆ†ç±»å™¨éƒ½æ˜¯å¼±åˆ†ç±»å™¨ï¼Œå¹¶ä¸”å¯ä»¥åŠ ä¸Šæ­£åˆ™é¡¹ï¼ŒæŠµå¾¡æ•°æ®ä¸­å™ªå£°c. adaboost æŸå¤±å‡½æ•°åªèƒ½æ˜¯ æŒ‡æ•°æŸå¤±å‡½æ•°ï¼Œ gbdt å¯ä»¥é’ˆå¯¹ä¸åŒçš„é—®é¢˜ï¼Œé€‰æ‹©åˆé€‚çš„æŸå¤±å‡½æ•°d. adaboost ä¸€èˆ¬ç”¨äºŽåˆ†ç±»ï¼Œgbt ä¸€èˆ¬ç”¨äºŽå›žå½’]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>gbdt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Summary]]></title>
    <url>%2F2019%2F07%2F10%2Fsummary_resume%2F</url>
    <content type="text"><![CDATA[ç®€åŽ†ä¸Šçš„å®žä¹ é¡¹ç›®æ€»ç»“ã€‚ æ€»çš„å¤§çº² é¢è¯•çš„æ—¶å€™è¿˜æ˜¯å°½é‡æŽ§åˆ¶ä¸€ä¸‹ï¼Œæ”¾æ…¢è¯­é€Ÿï¼Œåˆ«ç€æ€¥ï¼Œæƒ³æ¸…æ¥šäº†å†å¥½å¥½è¯´ï¼›(å·²ç»æ‰¾ä¸ä¸Šå·¥ä½œäº†ï¼Œåˆ«æ…Œ) è¡¨çŽ°æ¬²è¦æŽ§åˆ¶å¥½ï¼Œä¸è¦å¾—æ„å¿˜å½¢ï¼Œç‚¹åˆ°ä¸ºæ­¢ï¼Œä¸ç„¶å®¹æ˜“æŒ–æ›´å¤šçš„å‘ã€‚ è¿™æ¬¡æœ‰ä¸€ç‚¹åŽ‹åŠ›é¢çš„ï¼Œé‡åˆ°è¿™ç§æƒ…å†µï¼Œå¿ƒæ€ç§¯æžå¼€æ”¾ä¸€äº›ï¼Œåæ­£æˆ‘æ˜¯å…¨ç¨‹ç¬‘å˜»å˜»ï¼Œè°¦è™šè¯·æ•™çš„æ€åº¦ï¼Œåšçš„ä¸å¥½å°±æ‰¿è®¤ï¼Œè™šå¿ƒæŽ¥å—ï¼Œè´¨ç–‘çš„åœ°æ–¹ä¹Ÿè¦æ•¢äºŽæ‹¿å®žåŠ›è¯æ˜Žï¼Œæ¯•ç«Ÿè¿˜å¹´è½»ï¼Œæœ‰å¾ˆå¤§çš„è¿›æ­¥ç©ºé—´ã€‚ï¼ˆå°±æ˜¯åœ¨å¿ƒæ€ä¸Šä¸€å®šè¦æ˜¯å¹³å’Œçš„ï¼Œä¸å‘ä¸äº¢ï¼‰ çˆ±å¥‡è‰ºå®žä¹ ç»åŽ†é¢è¯•å®˜å¥½ï¼Œæˆ‘å«è´¾ç»§å¾ï¼Œæ¥è‡ªåŒ—äº¬èˆªç©ºèˆªå¤©å¤§å­¦è®¡ç®—æœºå­¦é™¢ã€‚åœ¨ç ”ç©¶ç”ŸæœŸé—´â€¦æ€»çš„æ¥è¯´ä¹‹å‰åˆ†åˆ«åœ¨è…¾è®¯å’Œçˆ±å¥‡è‰ºå®žä¹ è¿‡ä¸€æ®µæ—¶é—´ï¼Œåˆ†åˆ«åšçŸ­æ–‡æœ¬ç›¸ä¼¼åº¦è®¡ç®—å’Œæ–‡æœ¬åˆ†ç±»ã€ç„¶åŽä»¥ç¬¬ä¸€ä½œè€…èº«ä»½åˆ†åˆ«å‘è¡¨äº†ä¸€ç¯‡C ç±»ä¼šè®®å’ŒEI ä¼šè®®ï¼Œä¸€ä¸ªæ¶‰åŠçš„nlp æ–‡æœ¬åˆ†ç±»é—®é¢˜ï¼Œä¸€ä¸ªæ˜¯æ·±åº¦å­¦ä¹ é¢†åŸŸä¸­çš„gan ç½‘ç»œã€‚åšè¿‡ä¸€äº›å…³äºŽæœºå™¨å­¦ä¹ é¡¹ç›®å’ŒNLPé¡¹ç›®ï¼Œnlp é¡¹ç›®ä¸»è¦æ˜¯å¤„ç†çŸ­æ–‡æœ¬ï¼Œå¥å­çš„ç›¸ä¼¼åº¦è®¡ç®—å’Œæ–‡ç« çš„åˆ¤é‡ï¼Œå®Œæˆäº†ä¸€ä¸ªç±»ä¼¼faker çš„å¼€æºå·¥å…·ã€‚ ä»ŽåŽå¾€å‰è¯´ï¼Œçˆ±å¥‡è‰ºå®žä¹ ç»åŽ†ï¼šå®žä¹ å†…å®¹çš„èƒŒæ™¯ä½¿ç”¨nlp å’Œæœºå™¨å­¦ä¹ çŸ¥è¯†å¯¹æŽ¨èä¸­queryçš„è¯†åˆ«ï¼Œå®žé™…ä¸Šåšåˆ°åŽæ¥ä¸åªæ˜¯æ˜¯ä½Žä¿—å†…å®¹çš„è¯†åˆ«ï¼Œä¸€å¼€å§‹æ˜¯ç”¨äºŽè½¯è‰²æƒ…çš„åˆ¤æ–­ï¼ŒåŽæ¥æ¨¡åž‹åŠ å¤§äº†è¯†åˆ«çš„èŒƒå›´ï¼Œå‡¡æ˜¯ä¸€åˆ‡ä¸é€‚åˆå‡ºçŽ°åœ¨æŽ¨èä¸­çš„queryï¼Œéƒ½éœ€è¦è¿›è¡Œåˆ¤æ–­ã€‚æ¯”å¦‚æš´åŠ›ï¼Œä¸ç¬¦åˆç§¯æžçš„æ­£é¢å®£ä¼ å†…å®¹éƒ½ä¼šè¿›è¡Œè¯†åˆ«ã€‚ å¦‚ä½•å®žçŽ°ï¼Ÿ è®­ç»ƒæ•°æ®é›†300ä¸‡ï¼Œæœ‰æ ‡æ³¨ï¼Œ åˆ†åˆ«ä½¿ç”¨ 1 0 è¡¨ç¤ºä½Žä¿—å’Œéžä½Žä¿—æ•°æ®ï¼Œäººå·¥æ ‡æ³¨ï¼Œèƒ½æœ‰95%çš„å‡†ç¡®çŽ‡ï¼›ä¸¤ä¸ªæµ‹è¯•æ•°æ®é›†åˆ†åˆ«æ˜¯1ä¸‡ï¼ˆä»Žä¸€ä¸ªæœˆä¸­çš„query æŠ½é€‰å‡ºæ¥çš„æ•°æ®ï¼Œä¸€ä¸ªæ˜¯åŽŸå§‹çš„æ•°æ®ï¼Œä¸€ä¸ªæ˜¯ç»è¿‡è§„åˆ™ç­›é€‰çš„æµ‹è¯•æ•°æ®é›†ï¼‰ ã€‚è®­ç»ƒæ•°æ®é›†ä¸­æ­£è´Ÿæ ·æœ¬1 ï¼š1.5ï¼Œä½†åœ¨æµ‹è¯•é›†ä¸­ä½¿ç”¨çš„æ˜¯ä¸€ä¸ªæœˆä¸­çš„æ•°æ®ï¼Œæ‰€ä»¥æ­£è´Ÿæ ·æœ¬æ¯”è¾ƒé«˜ï¼Œè¾¾åˆ°äº†18ï¼š1ã€‚æ­£å¸¸query æ˜¯ä½Žä¿—query çš„18å€ã€‚ æ¨¡åž‹æœ‰ä¸¤éƒ¨åˆ†ç»„æˆã€‚ä¸€éƒ¨åˆ†æ˜¯åŸºäºŽtransformer çš„è¯­ä¹‰æŠ½å–ï¼Œä¸€éƒ¨åˆ†æ˜¯åŸºäºŽxgboost è¿›è¡Œçš„ç‰¹å¾æå–ï¼Œè®­ç»ƒè¿‡ç¨‹ä¸­ä¼˜åŒ–ä¸¤ä¸ªlossã€‚ ä¸ºä»€ä¹ˆä½¿ç”¨ xgboost æœºå™¨å­¦ä¹ è¿›è¡Œç‰¹å¾æå–å‘¢ï¼Ÿå› ä¸ºè¿™é‡Œä½¿ç”¨åˆ°äº†å…¶ä»–ç»´åº¦çš„ä¿¡æ¯ï¼Œè€Œè¿™äº›ä¿¡æ¯æ˜¯æœ‰åŠ©äºŽå¯¹query è¿›è¡Œåˆ¤åˆ«çš„ã€‚åˆ†æˆä¸‰éƒ¨åˆ†ï¼šä½¿ç”¨ fasttext èŽ·å¾—query çš„n-gram ç‰¹å¾ï¼Œå¸¸è§„word embeddingquery å’Œchannel çš„ç‰¹å¾ï¼Œå¯¹äºŽè‰²æƒ…è¿™ä¸ªç»´åº¦ï¼Œå½±è§†channel å’ŒçŸ¥è¯†ç±» channelæ˜¯æœ‰ä¸åŒçš„å½±å“çš„ä½¿ç”¨DSSMï¼ˆèŽ·å¾—æ˜¯query å’Œitem ä¹‹é—´ç‚¹å‡»çš„ä¿¡æ¯ï¼Œå¾—åˆ°çš„æ¨¡åž‹ä¸­ä¹Ÿæ˜¯è®¡ç®—ç›¸ä¼¼åº¦çš„ï¼‰è¿™äº›ç‰¹å¾éƒ½æ˜¯ ä¸€ä¸ªtransformer æ²¡æœ‰åŠžæ³•èŽ·å¾—çš„ ç„¶åŽä½¿ç”¨xgboost +LR æ¨¡åž‹ä½œä¸ºè¿™ä¸€éƒ¨åˆ†çš„ç½‘ç»œç»“æž„ã€‚ å¦ä¸€éƒ¨åˆ†ç›¸å¯¹æ¥è¯´å°±æ¯”è¾ƒç®€å•ï¼Œä½¿ç”¨ transformerä½œä¸ºä¸€ä¸ªè¯­ä¹‰è¯†åˆ«çš„æ¨¡åž‹ã€‚ç„¶åŽå¾—åˆ°çš„ä¸¤ä¸ªlossï¼Œåœ¨è®­ç»ƒè¿‡ç¨‹ä¸­ä¸€å—è¿›è¡Œè®­ç»ƒã€‚ çº¿ä¸‹ç‰ˆæœ¬å› ä¸ºæ­£è´Ÿæ ·æœ¬æ¯”è¾ƒå‡åŒ€ï¼Œç›´æŽ¥ä½¿ç”¨AUC ä½œä¸ºè¯„ä»·æŒ‡æ ‡ï¼Œauc å¾ˆé«˜äº†ï¼Œèƒ½å¤Ÿè¾¾åˆ°0.95å·¦å³äº†ï¼Œæœ‰ç‚¹è¿‡æ‹Ÿåˆäº†ã€‚åœ¨æŸç§æ„ä¹‰ä¸Šå°±æ˜¯æƒ³è¦è¿‡æ‹Ÿåˆï¼Œè¿™å¯ä»¥å¾ˆå¥½çš„å¤„ç†ä¸€äº›case çš„é—®é¢˜ï¼Œä½†æ˜¯æ¨¡åž‹çš„ä¼˜åŒ–çš„ç›®æ ‡ä¸æ˜¯è¿™æ ·çš„ï¼Œæ˜¯å¸Œæœ›åœ¨æµ‹è¯•æ•°æ®é›†ä¸Šæ•ˆæžœå¥½çš„ã€‚AUCæ˜¯ 0.89ã€‚ çº¿ä¸Šå› ä¸ºæ­£è´Ÿæ ·æœ¬çš„é—®é¢˜ï¼Œä½¿ç”¨F1 ä½œä¸ºè¯„ä»·æŒ‡æ ‡ï¼Œä½¿ç”¨å­—å‘é‡å’Œæ‹¼éŸ³å‘é‡ä¹‹åŽåˆ 4%çš„æå‡ã€‚ï¼ˆ0.79-0.83 ï¼‰ éš¾ç‚¹å¯¹äºŽquery çš„ç†è§£åº”è¯¥ä»Žå­—é¢æ„æ€ã€å†…æ¶µå’Œæœç´¢æ„å›¾è¿›è¡Œå…¨æ–¹ä½çš„ç†è§£ã€‚å­—é¢å¯ä»¥ä½¿ç”¨è§„åˆ™è¿›è¡Œåˆ¤æ–­ï¼Œä½†æ˜¯ä¸€äº›è¯è¯­ï¼ˆæ¯”å¦‚éŸ©å›½åŠžå…¬å®¤æ²™å‘ï¼Œå…¬å…¬å’Œå„¿åª³å¦‡ï¼‰è¿™ç§å¾ˆéš¾ä½¿ç”¨å•ä¸€çš„è§„åˆ™è¿›è¡Œåˆ¤æ–­ã€‚åº”è¯¥æ ¹æ®è¯­ä¹‰ä¿¡æ¯è¿›è¡Œåˆ¤æ–­ã€‚query ä¸­è¿˜æœ‰ä¸€ç‚¹ï¼Œå¯èƒ½å‡ºçŽ°æ‹¼éŸ³æ··åˆæ±‰å­—ï¼Œé”™åˆ«å­—ç­‰çŽ°è±¡ã€‚è¿™ç§çŽ°è±¡çš„å­˜åœ¨æ„å‘³ç€ä¸èƒ½ä½¿ç”¨ä¼ ç»Ÿçš„åˆ†è¯å·¥å…·è¿›è¡Œå¤„ç†ï¼Œå› ä¸ºè¿™ä¸ªæ˜¯åˆ†ä¸å‡†çš„ã€‚æˆ‘ä»¬çš„å¤„ç†æ–¹æ¡ˆæ˜¯â€å­—å‘é‡â€œ+ â€æ‹¼éŸ³å‘é‡â€œç”¨æ¥è¡¥å……åŽŸæ¥çš„è¯å‘é‡ã€‚ çº¿ä¸Šç‰ˆæœ¬æ˜¯æœ‰è¦æ±‚çš„ï¼Œæ˜¯è¦ä¿è¯precisionåœ¨ 0.9ä¸ºåº•çº¿çš„æƒ…å†µä¸‹ï¼Œç„¶åŽåŽ»æé«˜recallï¼ŒæŠ±æœ‰çš„æ˜¯å®ç¼ºæ¯‹æ»¥çš„è§‚å¿µï¼Œç»å¯¹ä¸èƒ½æ˜¯æŽ¨èå‡ºæ¥ä¸å¥½çš„queryã€‚ å¯èƒ½å­˜åœ¨çš„é—®é¢˜ï¼šæ•°æ®æ ‡å‡† å®šçš„æ ‡å‡†æ˜¯95%ï¼Œè™½ç„¶äººå·¥æ ‡æ³¨è¿™ç§ç²¾åº¦å·²ç»å¾ˆé«˜ï¼Œä½†æ˜¯è¿˜æ˜¯æœ‰errorçš„ï¼Œå¹¶ä¸”è¿™ç§error åœ¨çŸ­æœŸå†…æ˜¯ä¸å¤ªå¯èƒ½æœ‰å¤§çš„æå‡çš„ã€‚çº¿ä¸Šå’Œçº¿ä¸‹æ­£è´Ÿæ ·æœ¬æ¯”ä¸ä¸€è‡´ï¼Œä¹Ÿæ˜¯è¯¯å·®æ¥æºä¹‹ä¸€æ¨¡åž‹ä¾èµ–äºŽåˆ«çš„å›¢é˜Ÿçš„channel embeddingå’ŒDSSM embeddingï¼Œä¹Ÿå¯èƒ½æ˜¯ä¸€ä¸ªè¯¯å·®çš„æ¥æºã€‚è‡ªå·±è®­ç»ƒçš„fasttext çš„word embeddingprecision (0.92)å¾ˆé«˜ï¼Œrecall(0.6~7) çš„æ ·å­ï¼Œè¯´æ˜Žæ­£æ ·æœ¬çš„ç‰¹å¾å¹¶ä¸æ˜Žæ˜¾ï¼Œå¯èƒ½çš„ä¸€ç§è§£é‡Šæ˜¯ä¸­æ€§è¯ï¼Œæ­§ä¹‰è¯ï¼Œå­˜åœ¨äºŒä¹‰çš„è¯è¯­æ¯”è¾ƒå¤šï¼ˆå½“ç„¶è¿™ç§å‡è®¾æ˜¯å¯ä»¥éªŒè¯çš„ï¼Œå¯ä»¥çœ‹ä¸€ä¸‹false positive rate ) é¢„æµ‹æˆäº†å‡çš„ï¼‰ã€‚æ‰€ä»¥å¯ä»¥è¿›ä¸€æ­¥åŽ»æŒ–æŽ˜æ­£æ ·æœ¬ï¼ˆä½Žä¿—è¯æ±‡ï¼‰çš„ç‰¹å¾ï¼›è¿™ç§ç‰¹å¾å°±æ˜¯ä¸Šé¢è¯´çš„å¯èƒ½æ˜¯query çš„è¯­ä¹‰å’Œæœç´¢æ„å›¾ï¼Œè€Œä¸å•å•æ˜¯quer æœ¬èº«çš„æ„æ€ã€‚åŽæœŸçš„æ”¹è¿›ï¼š åŽæœŸæ‰“ç®—ï¼ŒåŠ ä¸Šä¸‡èƒ½çš„bertï¼Œç„¶åŽä¸‰ä¸ªloss è¿›è¡Œä¸€å—è®­ç»ƒï¼Œåº”è¯¥æ˜¯ä¼šå¾—åˆ°æ›´å¥½çš„query çš„è¡¨ç¤ºã€‚bert æ˜¯ä¸€ä¸ªé¢„è®­ç»ƒæ¨¡åž‹ã€‚ æ­£è´Ÿæ ·æœ¬æ˜¯ä¸€ä¸ªç›¸å¯¹çš„æ¦‚å¿µï¼Œå¯¹äºŽè¯¥ç ”ç©¶é—®é¢˜ï¼Œé‚£ä¹ˆä½Žä¿—è¯æ±‡å°±æ˜¯æ­£æ ·æœ¬ï¼Œè´Ÿæ ·æœ¬å°±æ˜¯æ­£å¸¸çš„è¯æ±‡ã€‚ Bad case åˆ†æžï¼šä¸»è¦åˆ†æˆä¸‰ç±» æœ¬èº«label å°±æœ‰é—®é¢˜ï¼Œ æ¯”å¦‚case â€œçˆ±æ­»äº¡ä¸Žæœºå™¨äººâ€(è¿™ä¸ªåº”è¯¥æ˜¯ç”µå½±) è¢«æ‰“æˆ1ï¼Œç„¶è€Œé¢„æµ‹æ˜¯0ï¼›â€å£ç–®å’‹æ²»ç–—â€ è¢«label æˆ1ï¼Œç„¶è€Œé¢„æµ‹æ˜¯0. äºŒåˆ†ç±»é”™è¯¯ã€‚æ¯”å¦‚â€ â€æ­¦åˆ™å¤©ç”¨çš„ä»€ä¹ˆå®‰æ…°å™¨â€â€ è¢«label æˆ1ï¼Œç„¶è€Œé¢„æµ‹ä¸º0ï¼› Query æœ¬èº«ä¸å¤ªå¥½åˆ†ç±»çš„ã€‚æ¯”å¦‚â€ å¥³äººè…¿è‚¥æ€Žä¹ˆåŠžâ€ è¢«label æˆ0ï¼Œä½†æ˜¯é¢„æµ‹ä¸º1ï¼›â€åƒåäº†â€ è¢«label æˆ1ï¼Œä½†æ˜¯é¢„æµ‹ä¸º0. æˆ‘è§‰å¾—å¯ä»¥å¯¹bad caseå†è¿›è¡Œä¸€ä¸‹åˆ’åˆ†ï¼Œä¸æ˜¯æ‰€æœ‰çš„bad case éƒ½éœ€è¦å¤„ç†çš„ã€‚å…·ä½“è€Œè¨€ï¼Œç¬¬äºŒç§æƒ…å†µæ˜¯åº”è¯¥å¤„ç†çš„ã€‚ç¬¬ä¸€ç§æƒ…å†µæ˜¯æ‰“æ ‡ç­¾çš„å‡†ç¡®åº¦é—®é¢˜ï¼Œç¬¬ä¸‰ç§æƒ…å†µæ˜¯éœ€è¦çœ‹å…·ä½“è¯­å¢ƒäº†ï¼Œå¹¶ä¸æ˜¯ä¸€ç§å¾ˆæ˜Žæ˜¾åœ°å¯ä»¥åˆ’åˆ†ä¸ºä½Žä¿—ä¸Žå¦çš„é—®é¢˜ã€‚åº”è¯¥ç€é‡çš„çœ‹çœ‹ä¸€ä¸‹ç¬¬äºŒç§æƒ…å†µã€‚ æ”¹è¿›çš„åœ°æ–¹ï¼šæœ‰ä¸€äº›ä¸­æ€§è¯ï¼Œæ¯”å¦‚â€çˆ±æ­»äº¡ä¸Žæœºå™¨äººâ€œ æ˜¯ä¸€ä¸ªä¸­æ€§è¯ï¼Œä½†æ˜¯åœ¨label çš„æ—¶å€™å°±è¢«æ ‡è®°é”™è¯¯äº†ï¼Œæ‰€ä»¥å¯¹äºŽè¿™ç±»è¯è¯­åº”è¯¥æ€Žä¹ˆåŠžï¼Ÿ è…¾è®¯æ–°é—»çš„å®žä¹ ç»åŽ† ç»å¯¹æé«˜å’Œç›¸å¯¹æé«˜å‡å¦‚ä¹‹å‰çš„æ°´å¹³æ˜¯aï¼Œç„¶åŽä¹‹åŽçš„æ°´å¹³æ˜¯bï¼Œé‚£ä¹ˆç»å¯¹æé«˜å°±æ˜¯ (b -a); ç›¸å¯¹æé«˜ (b -a) /a *100% . CTRæœ€å¼€å§‹æ˜¯å¤šå°‘ï¼Ÿè¿™ä¸ªæ—¶é—´æœ‰ç‚¹é•¿äº†ï¼Œå…·ä½“å¿˜è®°äº†ï¼Œä½†å‰åŽæ¨¡åž‹æ˜¯æœ‰å¢žé•¿æ•ˆæžœçš„ã€‚ faiss çš„ä»‹ç»é¦–å…ˆä½¿ç”¨ indexå¯¹äºŽå‘é‡è¿›è¡Œé¢„å¤„ç†ï¼Œç„¶åŽé€‰æ‹©ä¸åŒçš„æ¨¡å¼. ä¸»è¦è®²çš„æ˜¯ä¸‰ç§æ¨¡å¼ï¼Œä¸€ä¸ªç»´åº¦æ˜¯ç®€å•æ¨¡å¼ï¼Œé€‚åˆåœ¨å°æ•°æ®ä¸Šè¿›è¡Œè®¡ç®— æ¬§æ°è·ç¦»ï¼›ä¸€ä¸ªç»´åº¦æ˜¯åŠ å¿«æ£€ç´¢é€Ÿåº¦ï¼Œè¿™ç§æ¨¡å¼ä¸‹æ˜¯éœ€è¦æå‰çš„trainï¼Œå…¶åŸºæœ¬çš„æ€è·¯å¯¹å‘é‡è¿›è¡Œèšç±»ï¼Œå½“ç„¶æ–‡ä¸­è¯´çš„æ˜¯ â€œç»†èƒžâ€ï¼Œå»ºç«‹å€’æŽ’ç´¢å¼•ï¼Œç„¶åŽæ£€ç´¢çš„æ—¶å€™ï¼Œæœç´¢è¿™ä¸ªâ€œç»†èƒžâ€å†… å’Œå‘¨å›´çš„â€œç»†èƒžâ€ çš„id çš„é›†åˆï¼Œå°±å¯ä»¥è¿”å›žå‰ K ä¸ªæœ€ç›¸è¿‘çš„ç»“æžœï¼›æœ€åŽä¸€ä¸ªç»´åº¦æ˜¯å‡å°‘å†…å­˜çš„ä½¿ç”¨ï¼Œä¸Šé¢ä¸¤ç§éƒ½æ˜¯ä½¿ç”¨çš„å®Œæ•´çš„å‘é‡ï¼Œè¿™ä¸ªæ¨¡å¼ä¸‹æ˜¯ä½¿ç”¨çš„åŽ‹ç¼©å‘é‡ï¼Œå¯ä»¥ä½¿ç”¨PCA è¿›è¡Œå®žçŽ°ï¼Œå½“ç„¶è¿™ä¸ªæ¨¡å¼ä¸‹å¾—åˆ°çš„ç»“æžœä¹Ÿæ˜¯è¿‘ä¼¼è§£ã€‚è¿˜æœ‰ä¸¤ç§è®¡ç®—çš„ä¸Šçš„ä¼˜åŒ–ï¼Œå¯¹äºŽå‘é‡è¿›è¡Œåˆ†æ®µè®¡ç®—ï¼Œè¿™ç§å¯ä»¥å®žçŽ°å¹¶è¡Œï¼Œå¹¶ä¸”æ”¯æŒä»»åŠ¡åœ¨GPU ä¸Šè¿›è¡Œè¿ç®—ã€‚ï¼ˆä¸€èˆ¬çš„æƒ…å†µæ˜¯æ–‡æ¡£id ä½œä¸ºç´¢å¼•ï¼Œæ–‡æ¡£çš„å†…å®¹ä½œä¸ºè®°å½•ï¼›å€’æŽ’ç´¢å¼•ï¼Œæ˜¯æ–‡ç« å†…å®¹å…³é”®å­—ä½œä¸ºç´¢å¼•ï¼Œæ–‡æ¡£idä½œä¸ºè®°å½•ï¼‰ ä»€ä¹ˆæ˜¯ AB test?AB test æµ‹è¯•å¼ºè°ƒçš„æ˜¯åœ¨åŒä¸€æ—¶é—´ç»´åº¦å¯¹ç›¸ä¼¼å±žæ€§åˆ†ç»„ç”¨æˆ·çš„æµ‹è¯•ï¼Œæ—¶é—´çš„ç»Ÿä¸€æ€§æœ‰æ•ˆçš„è§„é¿äº†å› ä¸ºæ—¶é—´ã€å­£èŠ‚å› ç´ å¸¦æ¥çš„å½±å“ï¼Œå±žæ€§çš„ç›¸ä¼¼æ€§ï¼ˆvvï¼‰åˆ™ä½¿å¾—åœ°åŸŸã€æ€§åˆ«ã€å¹´é¾„ç­‰å…¶ä»–å› ç´ å¯¹ç»Ÿè®¡çš„å½±å“é™ä¸ºæœ€ä½Žã€‚å¯¹äºŽæµ‹è¯•çš„æµé‡ä¸å®œå¤ªå¤§ï¼Œåº”è¯¥é€æ­¥å¢žå¤§æµé‡ï¼ŒåŒæ—¶å¦‚æžœå¤ªå°åˆæœ‰éšæœºæ€§çš„å¹²æ‰°ã€‚æ—¶é—´ä¸Šä¿è¯æ˜¯å®Œæ•´çš„ä¸€å‘¨ï¼ŒåŒ…æ‹¬å·¥ä½œæ—¥å’Œå‘¨æœ«ã€‚AB test ä¹Ÿæ˜¯ä¸€ä¸ªè¿­ä»£çš„è¿‡ç¨‹ã€‚AB test æœ‰ä¸¤ç§æƒ…å†µï¼Œä¸€ç§æ˜¯ç•Œé¢ UIçš„ä¿®æ”¹ï¼Œä¸€ç§æ˜¯åŽå°ç®—æ³•çš„ä¿®æ”¹ã€‚åœ¨å¯¹äº§å“è¿›è¡ŒA/Bæµ‹è¯•æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ä¸ºåŒä¸€ä¸ªä¼˜åŒ–ç›®æ ‡ï¼ˆä¾‹å¦‚ä¼˜åŒ–è´­ä¹°è½¬åŒ–çŽ‡ï¼‰åˆ¶å®šä¸¤ä¸ªæ–¹æ¡ˆï¼ˆæ¯”å¦‚ä¸¤ä¸ªé¡µé¢ï¼‰ï¼Œè®©ä¸€éƒ¨åˆ†ç”¨æˆ·ä½¿ç”¨A æ–¹æ¡ˆï¼ŒåŒæ—¶å¦ä¸€éƒ¨åˆ†ç”¨æˆ·ä½¿ç”¨ B æ–¹æ¡ˆï¼Œç»Ÿè®¡å¹¶å¯¹æ¯”ä¸åŒæ–¹æ¡ˆçš„è½¬åŒ–çŽ‡ã€ç‚¹å‡»é‡ã€ç•™å­˜çŽ‡ç­‰æŒ‡æ ‡ï¼Œä»¥åˆ¤æ–­ä¸åŒæ–¹æ¡ˆçš„ä¼˜åŠ£å¹¶è¿›è¡Œå†³ç­–ï¼Œä»Žè€Œæå‡è½¬åŒ–çŽ‡ã€‚ab test å­˜åœ¨ç¼ºç‚¹ï¼Œå¦‚æžœåªæ˜¯å•çº¯çš„é€‰æ‹©ç”¨æˆ·ï¼Œé‚£ä¹ˆå¯èƒ½å­˜åœ¨è§‚çœ‹è§†é¢‘ä¹ æƒ¯ä¸åŒå¯¹æœ€åŽç»“è®ºäº§ç”Ÿä¸åˆ©çš„å½±å“ã€‚æ‰€ä»¥è¦å°½å¯èƒ½çš„é€‰æ‹©å±žæ€§ç›¸åŒçš„ç”¨æˆ·ï¼ŒæŒ‘é€‰å‡ºæ´»è·ƒç”¨æˆ·ï¼ˆvvè¾¾åˆ°æŸä¸€ä¸ªå€¼çš„ç”¨æˆ·ï¼‰ã€‚åˆ†åˆ«æ–½ä»¥æ¨¡åž‹Aå’ŒBï¼Œæ‰èƒ½éªŒè¯æ¨¡åž‹Açš„æ•ˆæžœã€‚è¿˜è¦ä¸€ç§æ€è·¯ï¼Œå¦‚ä½•åœ¨ä¸åˆ†ç»„çš„æƒ…å†µä¸‹ï¼Œè¿›è¡Œæµ‹è¯•å‘¢ï¼Ÿç»™ç”¨æˆ·ä¸¤ä¸ªç®—æ³•å¬å›žçš„ç»“æžœï¼ˆç­‰æ¦‚çŽ‡å‡ºçŽ°ï¼‰ï¼Œç„¶åŽè®°å½•ç”¨æˆ·çš„è¡Œä¸ºæ•°æ®ï¼Œç„¶åŽåˆ¤æ–­a b ä¸¤ç§æ–¹æ¡ˆçš„ä¼˜åŠ£ã€‚è¿™ç§æ€è·¯å°±æŽ’é™¤äº†ç”¨æˆ·æœ¬èº«å¸¦æ¥çš„è¯¯å·®ã€‚summaryï¼šåŒä¸€ä¸ªæ—¶é—´ç»´åº¦æ˜¯å®¹æ˜“ä¿è¯çš„ï¼Œä½†æ˜¯å±žæ€§çš„ç›¸ä¼¼æ€§æ¯”è¾ƒéš¾ä¿è¯ã€‚è¿™é‡Œæœ‰ä¸¤ç§ç­–ç•¥ï¼Œä¸€ç§æ˜¯é€‰æ‹©å±žæ€§ç›¸åŒçš„ç”¨æˆ·ï¼Œæ¯”å¦‚è¯´æŒ‘é€‰å‡ºåŒ—äº¬æ˜¯ä¸­æ´»è·ƒçš„ç”¨æˆ·ï¼Œç„¶åŽåˆ†æˆä¸¤ç»„è¿›è¡Œæµ‹è¯•ï¼›ä¸€ç§æ˜¯åœ¨ä¸€ä¸ªåœ°åŒºçš„ç”¨æˆ·åˆ†åˆ«ç­‰æ¦‚çŽ‡çš„æä¾›ä¸¤ç§ç®—æ³•ï¼Œæœ€åŽçœ‹æ•ˆæžœï¼ˆæ¯”å¦‚è¯´ctr ï¼Œç•™å­˜ï¼Œç”¨æˆ·æ—¶é•¿ç­‰ï¼‰ã€‚ å¥å­å‘é‡çš„è®­ç»ƒè¿‡ç¨‹ï¼Ÿword embedding è¡¨ç¤ºçš„å¥å­çš„ç¼ºç‚¹ï¼šæ²¡æœ‰è¯åºï¼›æ²¡æœ‰ä¸Šä¸‹æ–‡ï¼›ä¾èµ–å‰æœŸçš„å¤„ç†SIF è¿™ç§å¥å­å‘é‡ ï¼ˆæ— ç›‘ç£ï¼Œéžç½‘ç»œç»“æž„ï¼‰ å¦‚ä½•è¿›è¡Œ sentence è®­ç»ƒ?æ— ç›‘ç£æ¨¡åž‹ï¼Œé€šè¿‡skip-though ä¸¾ä¾‹è¯´æ˜Žï¼šskip-gram æ ¹æ®ä¸­å¿ƒè¯æ±‡é¢„æµ‹ä¸Šä¸‹æ–‡skip-thought æ ¹æ®ä¸­å¿ƒå¥ é¢„æµ‹ä¸Šä¸‹å¥encoder -decoderencoder å°±æ˜¯ä¸€ä¸ª ç‰¹å¾æå–ï¼Œç„¶åŽåˆä¸¤ä¸ªdecoderï¼Œ æ˜¯è¯­è¨€æ¨¡åž‹ ï¼Œåˆ†åˆ«å¯¹åº”ç€ ä¸Šä¸€å¥å’Œä¸‹ä¸€å¥ç»Ÿè®¡è¯­è¨€æ¨¡åž‹æ˜¯ä¸€ä¸ªå•è¯åºåˆ—ä¸Šçš„æ¦‚çŽ‡åˆ†å¸ƒï¼Œå¯¹äºŽä¸€ä¸ªç»™å®šé•¿åº¦ä¸ºmçš„åºåˆ—ï¼Œå®ƒå¯ä»¥ä¸ºæ•´ä¸ªåºåˆ—äº§ç”Ÿä¸€ä¸ªæ¦‚çŽ‡ $P(w_1,w_2,â€¦,w_m) $ ã€‚ è¯æ±‡æ‰©å±•ä½¿ç”¨ word2vec å¾—åˆ°çš„è¯å‘é‡ æ¥è¡¥å…… encoder è¿‡ç¨‹ä¸­ è¯¥é—®é¢˜çš„è¯å‘é‡ï¼Œè¦æ±‚å‰è€…çš„è§„æ¨¡æ˜¯è¿œè¿œå¤§äºŽåŽè€…çš„ã€‚é€šè¿‡è¿™ç§æ–¹æ³•è¡¥å…… encoder è¿‡ç¨‹ä¸­çš„è¯æ±‡ã€‚ æ•°æ®é›†æ•°æ®é›†ä¸­çš„å¥å­æ˜¯æœ‰è¡”æŽ¥å…³ç³»çš„ï¼Œè®ºæ–‡ä¸­çš„æ•°æ®é›†æ˜¯ google news datasetã€‚è¦æ±‚æœ‰ä¸€å®šçš„é€»è¾‘çš„æ–‡ç« ã€‚ æœ‰ç›‘ç£æ¨¡åž‹ï¼šinfersent ç»¼è¿°ç±»åž‹ï¼Œæ‰¾åˆ°äº† nlp é¢†åŸŸçš„imagenet å’Œ inception networkã€‚ç½‘ç»œç»“æž„æ¨¡åž‹æ˜¯ ä½¿ç”¨ä¸€ä¸ªencoder å¾—åˆ°å‘é‡è¡¨ç¤ºï¼Œç„¶åŽè®°æ€§ u ç›¸åŠ  å’Œç‚¹ä¹˜ ä¸‰ç§æ“ä½œï¼Œå¾—åˆ° fully-connection æœ€åŽæ˜¯softmaxã€‚encoder æ˜¯ bi-lstm å¹¶ä¸”ä½¿ç”¨ max pooling è¿›è¡Œç½‘ç»œç»“æž„çš„ä¼˜åŒ–ã€‚æ•°æ®é›†æ˜¯ å¥å­å¯¹ç»„æˆçš„æ•°æ®é›†ï¼Œæ ‡æ³¨ä¿¡æ¯æ˜¯æ•°æ®é—´çš„å…³ç³»ï¼ˆè•´å«ï¼Œå¯¹ç«‹å’Œä¸­æ€§ï¼‰æ•°æ®é‡ 570kã€‚ å…·ä½“å®žéªŒå¯¹æ¯”çš„æ˜¯ RNN lstm gru ç„¶åŽæ­é…ç€ å•å‘or åŒå‘ max pooling or average pooling è¿›è¡Œåšçš„å®žéªŒã€‚ universal sentence encoder ä¸Šé¢é‚£ä¸ªæ˜¯ facebook å›¢é˜Ÿå‡ºçš„ï¼Œç„¶åŽè¿™ä¸ªæ˜¯ google å‡ºçš„ï¼Œä¸»è¦çš„åŒºåˆ«åœ¨äºŽä½¿ç”¨ transformer ä»£æ›¿bi-lstm ä½œä¸ºencoderã€‚ è®­ç»ƒçš„æ—¶å€™ï¼Œæ—¢è¿›è¡Œäº†æœ‰ç›‘ç£çš„å­¦ä¹ ï¼Œåˆè¿›è¡Œäº†æ— ç›‘ç£çš„è®­ç»ƒã€‚ å›¾åƒå¤„ç†å’Œnlp çš„å·®åˆ«ï¼šç¦»æ•£ or è¿žç»­ï¼› å®šé•¿ or éžå®šé•¿ï¼›ç¨ å¯† or ç¨€ç–ã€‚ å¯¹äºŽ bert transformer çš„ä»‹ç»ï¼Ÿbert æ˜¯é›†å¤§æˆè€…ï¼Œå‰é¢è¿˜æœ‰å¾ˆå¤šé‡è¦çš„ç ”ç©¶æˆæžœï¼Œæ¯”å¦‚attentionï¼Œself-attention å’Œtransformerã€‚ç›´æŽ¥ä»Ž transformer è¯´èµ·ï¼Œå¤§çš„ç»“æž„è¿˜æ˜¯ encoderã€decoder çš„ç»“æž„ã€‚encoder æ˜¯6 ä¸ªä¸¤å±‚ç»“æž„ï¼Œ decoder ä¹Ÿæ˜¯ 6ä¸ªä¸‰å±‚ç»“æž„ã€‚transformer ä¸­æœ‰å‡ ä¸ªæŠ€æœ¯ç‚¹æ˜¯éœ€è¦è®²è§£ï¼š layer normalization ï¼ˆä¸»è¦ vs batch normalizationï¼‰ã€position embedding ï¼ˆåœ¨encoder ä¸­æ˜¯ç»“åˆäº† word embedding ä¸€å—ä½œä¸ºè¾“å…¥çš„ï¼‰ã€masked attentionï¼ˆå½“predict t æ—¶åˆ»çš„wordçš„æ—¶å€™ï¼Œåªèƒ½çœ‹åˆ° t ä¹‹å‰çš„æƒ…å†µï¼Œå°† t ä¹‹åŽçš„word è¿›è¡Œäº† maskï¼‰ã€multi-head attentionï¼ˆç±»ä¼¼ å›¾åƒä¸­çš„å¤šä¸ª filter ï¼‰ã€self-attention å°±ä¸å¤šè¯´äº†ä»Ž transformer åˆ° bert åˆæ˜¯ä¸€ä¸ªæ¯”è¾ƒå¤æ‚çš„æ¨¡åž‹ç»„åˆçš„å·¥ä½œã€‚ 6.1 å…³äºŽbert å’Œlstm çš„æ¯”è¾ƒï¼ˆè§£ç­”è¿™ç§é—®é¢˜éœ€è¦æœ‰ä¸€ä¸ªåˆ‡å…¥ç‚¹ï¼Œé‚£ä¹ˆå°±æ˜¯ lstm çš„ç¼ºç‚¹ï¼‰lstm æ˜¯æ— æ³•è§£å†³é•¿ä¾èµ–çš„é—®é¢˜ï¼Œlstm ä½¿ç”¨è¾“å…¥é—¨ï¼Œé—å¿˜é—¨å’Œè¾“å‡ºé—¨å¯ä»¥ç¼“è§£ä¸€å®šç¨‹åº¦ä¸Šçš„é•¿ä¾èµ–çš„é—®é¢˜ï¼Œä½†æ˜¯å½“å¥å­æ›´é•¿çš„æ—¶å€™ï¼Œé‚£ä¹ˆä¹Ÿæ˜¯æ— èƒ½ä¸ºåŠ›çš„ã€‚ bert æ˜¯ä¸€ä¸ªé›†å¤§æˆè¿™ï¼Œå…¶ä¸­å¤§é‡ä½¿ç”¨äº† transformerçš„ç»“æž„ï¼Œè€Œtransformer ç»“æž„æ˜¯åŸºäºŽ attentionæœºåˆ¶ï¼Œæ‰€ä»¥å¯ä»¥è§£å†³é•¿ä¾èµ–çš„é—®é¢˜ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œbertæ˜¯å¯ä»¥åœ¨ GPU ä¸Šè¿›è¡Œfine tuneï¼Œé‚£ä¹ˆæ„å‘³ç€è®¡ç®—æ•ˆçŽ‡æ˜¯æ¯”è¾ƒé«˜çš„ï¼Œå¯ä»¥å¹¶è¡Œè¿ç®—ã€‚å½“ç„¶è¿˜æœ‰å…¶ä»–çš„ï¼Œæ¯”å¦‚ bert æ˜¯ä¸€ä¸ªé¢„è®­ç»ƒæ¨¡åž‹ï¼Œå¯ä»¥åœ¨ç‰¹å®šçš„ä»»åŠ¡ä¸Šè¿›è¡Œfine tune å¾—åˆ°æ¯”è¾ƒå¥½çš„ç»“æžœï¼Œæ¯”å¦‚æˆ‘è®ºæ–‡ä¸­çš„æ¨¡åž‹å°±æ˜¯åŸºäºŽ bert è¿›è¡Œfine tune ï¼Œç„¶åŽä¸éœ€è¦æ€Žä¹ˆè®­ç»ƒï¼Œæ•ˆæžœå°±å·²ç»å¾ˆå¥½äº†ã€‚ æ•ˆæžœå¥½å¹¶ä¸”é€Ÿåº¦æ¯”è¾ƒå¿«ï¼Œè¿™ä¸ªå¿«æ˜¯æŒ‡çš„ fine-tune çš„æ•ˆæžœï¼Œä¸æ˜¯ä»Žå¤´å¼€å§‹è®­ç»ƒçš„æ—¶é—´ã€‚ï¼ˆä¸€èˆ¬éƒ½æ˜¯ä»Ž é€Ÿåº¦ å’Œæ•ˆæžœä¸¤æ–¹é¢è¯„ä»·æ¨¡åž‹çš„å¥½åï¼‰æ•ˆæžœä¸»è¦ä½“çŽ°åœ¨è¡¨ç¤ºè¯­ä¹‰ï¼Œä¸Šä¸‹æ–‡ä¿¡æ¯ï¼›ç»™å®šit èƒ½å¤ŸçŸ¥é“æŒ‡ä»£çš„å…³ç³» (èƒ½å¤šè¯´ç‚¹å°±å¤šè¯´ç‚¹ï¼Œå› ä¸ºä¸€ä¸ªé¢è¯•å®˜çš„é¢è¯•æ—¶é—´æœ‰é™çš„ï¼Œé‚£ä¹ˆæ˜¯éœ€è¦å°½å¯èƒ½åœ¨è¿™ä¸ªæ—¶é—´æ®µé‡Œé¢è®©å…¶å°‘é—®é—®é¢˜ï¼Œè‡ªå·±å°½é‡æŠŠè¿™ä¸ªå……å®žèµ·æ¥) ä»‹ç»transformerçš„æ—¶å€™ï¼Œä½†æ˜¯åœ¨è¿™ä¸¤å±‚ä¸­é—´è¿˜æœ‰ä¸€å±‚attentionå±‚ï¼Œå¸®åŠ©å½“å‰èŠ‚ç‚¹èŽ·å–åˆ°å½“å‰éœ€è¦å…³æ³¨çš„é‡ç‚¹å†…å®¹ã€‚ æ­£å¼¦ä½™å¼¦å‡½æ•°ç”¨æ¥ç¼–ç ç»å¯¹çš„ä½ç½®ä¿¡æ¯ï¼Œä¹Ÿæ˜¯å¯ä»¥ç”¨æ¥è¡¨ç¤ºä½ç½®ä¹‹é—´çš„ç›¸å¯¹çš„è·ç¦»ã€‚ batch normalization layer normalization, instance normalization, group normalization ä¸¤ç§mask æŠ€æœ¯ï¼š padding maskï¼ˆè¾“å…¥æ•°æ®ï¼‰ å’Œsequence maskï¼ˆdecoderï¼‰ decoderæœ‰ä¸‰å±‚ç»“æž„ multi-head attention+ encoder-decoder attention å’Œå‰å‘ä¼ æ’­å…¬å¼éœ€è¦æŽŒæ¡ï¼š $$\text { Attention }(Q, K, V)=\operatorname{softmax}\left(\frac{Q K^{T}}{\sqrt{d_{k}}}\right) V$$ lstm ç›¸å¯¹äºŽ rnn æ˜¯èƒ½å¤Ÿå¤„ç†ä¸€éƒ¨åˆ†çš„é•¿ä¾èµ–çš„ï¼Œä½†æ˜¯å½“å¥å­æ›´åŠ çš„é•¿çš„æ—¶å€™ï¼Œæ•ˆæžœä¹Ÿæ˜¯ä¸å¤ªå¥½çš„ï¼›å¹¶ä¸”è®¡ç®—é‡æ¯”è¾ƒå¤§ã€‚ elmo ä¸­ä½¿ç”¨äº† n-gramï¼ˆsub-wordsï¼‰çš„æ€æƒ³ bert çš„ä¸¤ä¸ªè®­ç»ƒä»»åŠ¡ï¼Œä¸€ä¸ªæ˜¯éšæœºé®è”½æŽ‰ä¸€ä¸ªè¯ï¼Œåˆ©ç”¨ä¸Šä¸‹æ–‡è¿›è¡Œé¢„æµ‹ï¼›ä¸€ä¸ªæ˜¯é¢„æµ‹ä¸‹ä¸€ä¸ªå¥å­ã€‚å¤„ç†å¥å†…å…³ç³»å’Œå¥é—´å…³ç³»ã€‚ç¬¬ä¸€ä¸ªä»»åŠ¡ï¼šéšæœºé€‰æ‹©15%çš„tokenï¼Œå¤§å¤šæ•°çš„token æ˜¯è¢« mask ç‰¹æ®Šå­—ç¬¦å–ä»£ï¼›ä¸€éƒ¨åˆ†æ˜¯éšæœºè¢«å…¶ä»–å•è¯å–ä»£ï¼›ä¸€éƒ¨åˆ†æ˜¯ä¿ç•™åŽŸè¯ã€‚ç›®çš„æ˜¯ä¸ºäº†æ¨¡åž‹å¯¹ä¸Šä¸‹æ–‡è¿›è¡Œè¡¨ç¤ºï¼Œå‡å°‘è®­ç»ƒé›†å’Œtest é›†åˆä¸­çš„æ•°æ®åˆ†å¸ƒçš„ä¸ç»Ÿä¸€ã€‚ç¬¬äºŒä¸ªä»»åŠ¡ï¼šè¾“å…¥ä¸¤ä¸ªå¥å­Aå’ŒBï¼Œé¢„æµ‹B æ˜¯å¦ä¸ºA çš„ä¸‹ä¸€ä¸ªå¥å­ï¼Œ50% æ˜¯ä¸‹ä¸€ä¸ªå¥å­ï¼Œå‰©ä½™çš„éƒ½ä¸æ˜¯ã€‚ç›®æ ‡æ˜¯æœ€å°åŒ–ä¸¤ç§ç­–ç•¥çš„ç»„åˆå‡½æ•°ã€‚ è¾“å…¥ï¼š token embeddingè¯å‘é‡ï¼ˆè‚¯å®šæ˜¯subwordçš„ï¼Œè¿™ä¸ªéƒ½æ˜¯æ ‡é…ï¼‰+ segment embeddingåŒºåˆ†ä¸¤ä¸ªå¥å­ + position embeddingè¡¨ç¤ºä½ç½®ä¿¡æ¯ã€‚ æ›´å¤§çš„æ•°æ®é›†ï¼šä½¿ç”¨äº†bookcorpus å’Œç»´åŸºç™¾ç§‘ä¸­çš„æ•°æ® æ”¹è¿›çš„ç©ºé—´ï¼šä»Žå­—æ¨¡åž‹åˆ°è¯æ¨¡åž‹ï¼Œç§‘å¤§è®¯é£žå’Œå“ˆå·¥å¤§æœ‰åšè¿™æ–¹é¢çš„ç ”ç©¶probabilityè¿™ä¸ªè¯è¢«åˆ‡åˆ†æˆâ€proâ€ã€â€#babiâ€å’Œâ€#lityâ€3ä¸ªWordPieceã€‚æœ‰å¯èƒ½å‡ºçŽ°çš„ä¸€ç§éšæœºMaskæ˜¯æŠŠâ€#babiâ€ Maskä½ï¼Œä½†æ˜¯â€proâ€å’Œâ€#lityâ€æ²¡æœ‰è¢«Maskã€‚è¿™æ ·çš„é¢„æµ‹ä»»åŠ¡å°±å˜å¾—å®¹æ˜“äº†ï¼Œå› ä¸ºåœ¨â€proâ€å’Œâ€#lityâ€ä¹‹é—´åŸºæœ¬ä¸Šåªèƒ½æ˜¯â€#babiâ€äº†ã€‚è¿™æ ·å®ƒåªéœ€è¦è®°ä½ä¸€äº›è¯(WordPieceçš„åºåˆ—)å°±å¯ä»¥å®Œæˆè¿™ä¸ªä»»åŠ¡ï¼Œè€Œä¸æ˜¯æ ¹æ®ä¸Šä¸‹æ–‡çš„è¯­ä¹‰å…³ç³»æ¥é¢„æµ‹å‡ºæ¥çš„ã€‚ç±»ä¼¼çš„ä¸­æ–‡çš„è¯â€æ¨¡åž‹â€ä¹Ÿå¯èƒ½è¢«Maskéƒ¨åˆ†(å…¶å®žç”¨â€çµç¶â€çš„ä¾‹å­å¯èƒ½æ›´å¥½ï¼Œå› ä¸ºè¿™ä¸¤ä¸ªå­—åªèƒ½ä¸€èµ·å‡ºçŽ°è€Œä¸èƒ½å•ç‹¬å‡ºçŽ°)ï¼Œè¿™ä¹Ÿä¼šè®©é¢„æµ‹å˜å¾—å®¹æ˜“ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå¾ˆè‡ªç„¶çš„æƒ³æ³•å°±æ˜¯è¯ä½œä¸ºä¸€ä¸ªæ•´ä½“è¦ä¹ˆéƒ½Maskè¦ä¹ˆéƒ½ä¸Maskï¼Œè¿™å°±æ˜¯æ‰€è°“çš„Whole Word Maskingã€‚ å¯¹äºŽtransformer æˆ–è€…bert æœ¬èº«çš„æ¨¡åž‹ä¼˜åŒ–ï¼Œè¿™ä¸ªæ¨¡åž‹è¿˜æ˜¯æœ‰ç‚¹å¤æ‚ã€‚ é€Ÿåº¦ä¸Šè®¡ç®—çš„ä¼˜åŠ¿ï¼Œ bert æ˜¯åŸºäºŽtransformerï¼Œè€Œtransformeræ˜¯åŸºäºŽself-attentionï¼Œself-attention æ˜¯å¯ä»¥è¿žæŽ¥ä»»æ„ä¸¤ä¸ªç»“ç‚¹ï¼Œæ‰€ä»¥å¯ä»¥å¹¶è¡Œçš„è¿ç®—ã€‚ bert çš„ å…³äºŽbert å’Œtransformerä¸­çš„è¾“å…¥ï¼ˆinputï¼‰ï¼Ÿ åœ¨ word2vec ä¸­ä½¿ç”¨ one-hot æ–¹å¼è¿›è¡Œè¡¨ç¤ºï¼Œvector çš„é•¿åº¦å°±æ˜¯è¯æ±‡è¡¨ vocabulary çš„é•¿åº¦ã€‚ä½†æ˜¯åœ¨transformerä¸­å¹¶ä¸è¿™æ ·åšï¼Œå› ä¸ºè¿™ç§æ–¹å¼è¿‡äºŽç¨€ç–ã€‚å¦‚æžœæ˜¯åœ¨pytorch ä¸­ï¼Œç»å¸¸ä½¿ç”¨ nn.Embedding æ¥åšæˆ–è€…ä½¿ç”¨ one-hot å’Œæƒé‡çŸ©é˜µ $W$ ç›¸ä¹˜å¾—åˆ°ã€‚nn.Embedding åŒ…å«ä¸€ä¸ªæƒé‡çŸ©é˜µ Wï¼Œå¯¹åº”çš„ shape ä¸º ( num_embeddingsï¼Œembedding_dim )ã€‚num_embeddings æŒ‡çš„æ˜¯è¯æ±‡é‡ï¼Œå³æƒ³è¦ç¿»è¯‘çš„ vocabulary çš„é•¿åº¦ã€‚embedding_dim æŒ‡çš„æ˜¯æƒ³ç”¨å¤šé•¿çš„ vector æ¥è¡¨è¾¾ä¸€ä¸ªè¯ï¼Œå¯ä»¥ä»»æ„é€‰æ‹©ï¼Œæ¯”å¦‚64ï¼Œ128ï¼Œ256ï¼Œ512ç­‰ã€‚åœ¨ Transformer è®ºæ–‡ä¸­é€‰æ‹©çš„æ˜¯512(å³ d_model =512)ã€‚å¤„ç† nn.Embedding æƒé‡çŸ©é˜µæœ‰ä¸¤ç§é€‰æ‹©ï¼š ä½¿ç”¨ pre-trained çš„ embeddings å¹¶å›ºåŒ–ï¼Œè¿™ç§æƒ…å†µä¸‹å®žé™…å°±æ˜¯ä¸€ä¸ª lookup tableã€‚ å¯¹å…¶è¿›è¡Œéšæœºåˆå§‹åŒ–(å½“ç„¶ä¹Ÿå¯ä»¥é€‰æ‹© pre-trained çš„ç»“æžœ)ï¼Œä½†è®¾ä¸º trainableã€‚è¿™æ ·åœ¨ training è¿‡ç¨‹ä¸­ä¸æ–­åœ°å¯¹ embeddings è¿›è¡Œæ”¹è¿›ã€‚Transformer é€‰æ‹©çš„æ˜¯åŽè€…ã€‚ä½†æ˜¯è¿™ä¸ªæ˜¯æ²¡æœ‰ä½ç½®ä¿¡æ¯çš„ï¼Œæ‰€ä»¥åŠ å…¥äº†position embeddingã€‚ 10åˆ†é’Ÿå¸¦ä½ æ·±å…¥ç†è§£TransformeråŽŸç†åŠå®žçŽ° å…³é”®è¯æå–æŠ€æœ¯å¡æ–¹åˆ†å¸ƒï¼šå¡æ–¹æ£€éªŒæ˜¯ä»¥Ï‡2åˆ†å¸ƒä¸ºåŸºç¡€çš„ä¸€ç§å¸¸ç”¨å‡è®¾æ£€éªŒæ–¹æ³•ã€‚è¯¥æ£€éªŒçš„åŸºæœ¬æ€æƒ³æ˜¯ï¼šé¦–å…ˆå‡è®¾$H_0$ï¼ˆæ¯”å¦‚è¯´æŸä¸ªç‰¹å¾å’Œlabel æ— å…³ï¼‰æˆç«‹ï¼ŒåŸºäºŽæ­¤å‰æè®¡ç®—å‡ºÏ‡2å€¼ï¼Œå®ƒè¡¨ç¤ºè§‚å¯Ÿå€¼ä¸Žç†è®ºå€¼ä¹‹é—´çš„åç¦»ç¨‹åº¦ã€‚å¡æ–¹åˆ†å¸ƒä¸­çš„å‚æ•°Fï¼ˆè‡ªç”±åº¦ï¼Œï¼ˆè¡Œæ•° - 1ï¼‰ * ï¼ˆåˆ—æ•° - 1ï¼‰ï¼‰ï¼Œæœ‰äº†è‡ªç”±åº¦é‚£ä¹ˆå°±å¯ä»¥å¾—åˆ°å¯¹åº”è¡¨ä¸­çš„å¡æ–¹å€¼ï¼Œç„¶åŽå¾—åˆ°åŽŸå‡è®¾æˆç«‹çš„æ¦‚çŽ‡ã€‚ä½†æ˜¯åœ¨å®žé™…åº”ç”¨ä¸­ï¼Œåªéœ€è¦å°†æœ€åŽçš„å°†æœ€åŽçš„ç»“æžœè¿›è¡ŒæŽ’åºï¼Œé€‰æ‹©æœ€å¤§çš„å‰Kï¼Œå°±æ˜¯æœ€åŽçš„ç»“æžœã€‚ç¼ºç‚¹ï¼š è€ƒè™‘çš„æ˜¯å‡ºçŽ°ä¸Žå¦ï¼Œä¸æ˜¯é¢‘çŽ‡ï¼›æ²¡æœ‰è€ƒè™‘è¯­æ„ä¿¡æ¯ã€‚ å¤šçº¿ç¨‹ï¼Œå¤šè¿›è¡Œpython ä¸­çš„å®žçŽ°ï¼Œ å¤šçº¿ç¨‹æ˜¯ ï¼Œ ä½¿ç”¨threadingï¼Œ å¤„ç†çš„æ˜¯io å“åº”ï¼›å¤šè¿›ç¨‹æ˜¯Concurrencyï¼Œ ä½¿ç”¨multiprocessing åŒ…ï¼Œå¤„ç†çš„æ˜¯å¤šæ ¸cpuçš„æ“ä½œã€‚å¹¶å‘å’Œå¹¶è¡Œï¼Œå¹¶å‘åªæ˜¯ç”¨æˆ·æ„Ÿè§‰ï¼Œé€šè¿‡å¿«é€Ÿåˆ‡æ¢ï¼Œä¿å­˜çŽ°åœºå®žçŽ°ï¼›å¹¶è¡Œæ˜¯çœŸæ­£çš„åŒä¸€æ—¶åˆ»è¿è¡Œç€ä¸åŒçš„ç¨‹åºã€‚å¯¹äºŽio ç»‘å®šçš„ä»»åŠ¡ï¼Œä½¿ç”¨å¤šè¿›ç¨‹å¯ä»¥æé«˜æ€§èƒ½ï¼›ä½¿ç”¨å¤šè¿›ç¨‹ä¹Ÿå¯ä»¥æé«˜æ€§èƒ½ï¼Œä½†æ˜¯å¼€é”€å¾€å¾€æ¯”å¤šçº¿ç¨‹é«˜ã€‚æ¯”å¦‚è¯´è®¿é—®å¤šä¸ªç½‘ç«™ï¼Œä½¿ç”¨å¤šçº¿ç¨‹è¿›è¡Œçˆ¬å–ç½‘é¡µçš„ä»»åŠ¡çš„æ•ˆçŽ‡æ˜¯é«˜äºŽå•ä¸ªçº¿ç¨‹çš„æ•ˆçŽ‡ã€‚ï¼ˆå¤§éƒ¨åˆ†å’Œio ç»‘å®šçš„ç¨‹åº éƒ½æ˜¯åœ¨ç­‰å¾…è¾“å…¥è¾“å‡ºï¼Œæ— æ‰€äº‹äº‹ã€‚æ¯”å¦‚ç”±äºŽç½‘ç»œå»¶è¿Ÿï¼Œå¯¼è‡´æ¥è‡ªç½‘ç»œ æ•°æ®åº“ æ–‡ä»¶æ‰€èŠ±è´¹çš„æ—¶é—´æ˜¯è¿œè¿œå¤§äºŽ cpu å¤„ç†æ—¶é—´ï¼Œé‚£ä¹ˆè¿™ä¸ªæ—¶å€™ä½¿ç”¨å¤šçº¿ç¨‹å°±æ¯”è¾ƒniceï¼‰å¯¹äºŽcpu ç»‘å®šçš„ä»»åŠ¡ï¼Œä½¿ç”¨å¤šçº¿ç¨‹å¾€å¾€å¯ä»¥é™ä½Žæ€§èƒ½ï¼Œä½¿ç”¨å¤šè¿›ç¨‹å¯ä»¥æé«˜æ€§èƒ½ã€‚æ¯”å¦‚è¯´å°±ç®— 1w ä»¥å†…çš„æ‰€æœ‰çš„è´¨æ•°ï¼Œå› ä¸ºçŽ°åœ¨çš„cpu éƒ½æ˜¯å¤šæ ¸çš„ï¼Œå¯ä»¥è°ƒç”¨å¤šä¸ªå¤„ç†æ¨¡å—ï¼Œä½†æ˜¯å½“ç”Ÿæˆçš„è¿›ç¨‹æ•°é‡å¤šäºŽcpu çš„å¤„ç†èƒ½åŠ›ï¼Œé‚£ä¹ˆå°±è§‚å¯Ÿåˆ°äº†æ€§èƒ½çš„ä¸‹é™ï¼Œå› ä¸ºè¿™ä¸ªæ—¶å€™ä½¿ç”¨æ›´å¤šçš„å·¥ä½œæ¥æ¢å–cpu å†…æ ¸å†…å¤–çš„è¿›ç¨‹ã€‚ æ–°è¯å‘çŽ°è¿™é‡Œæœ‰ä¸‰ä¸ªé˜ˆå€¼ï¼ˆéƒ½æ˜¯è¶Šå¤§è¶Šå¥½ï¼‰ï¼šç¬¬ä¸€æ˜¯æœ€å°äº’ä¿¡æ¯ï¼Œå› ä¸ºäº’ä¿¡æ¯è¶Šå¤§è¯´æ˜Žç›¸å…³åº¦è¶Šå¤§ï¼Œå°†n-gramåˆ†å¥½çš„è¯è®¡ç®—äº’ä¿¡æ¯ï¼Œå¦‚æžœä½ŽäºŽé˜ˆå€¼ï¼Œåˆ™è¯´æ˜Žä¸èƒ½æˆè¯ã€‚ç¬¬äºŒæ˜¯æœ€å°ç†µå€¼ï¼Œå› ä¸ºç†µä¹Ÿæ˜¯è¶Šå¤§è¯´æ˜Žå‘¨è¾¹è¯è¶Šä¸°å¯Œï¼Œè®¡ç®—å…¶å·¦ç†µå’Œå³ç†µçš„æœ€å°å€¼ï¼Œå¦‚æžœæœ€å°å€¼ä½ŽäºŽé˜ˆå€¼ï¼Œåˆ™è¯´æ˜Žä¸èƒ½æˆè¯ã€‚ç¬¬ä¸‰ä¸ªæ˜¯æœ€å°‘å‡ºçŽ°æ¬¡æ•°ï¼Œä¸ºä»€ä¹ˆæœ‰è¿™ä¸ªæ•°å‘¢ï¼Ÿå‡è®¾å‰åŽä¸¤ä¸ªè¯æ˜¯å®Œå…¨ç›¸å…³çš„ï¼Œå‡ºçŽ°400æ¬¡ï¼Œæ€»å…±8000è¯ï¼Œé‚£ä¹ˆäº’ä¿¡æ¯=log((400/8000)/(400/8000)(400/8000))ï¼Œçº¦æŽ‰ä¹‹åŽå‰©ä¸‹log(8000/400)ã€‚ä½†æ˜¯ä¸€ä¸ªè¯å¦‚æžœä»Žå¤´åˆ°å°¾å‡ºçŽ°äº†ä¸€æ¬¡ï¼Œä½†æ˜¯å¹¶ä¸æ˜¯å•è¯ï¼Œåˆ™äº’ä¿¡æ¯ä¸º=log((1/8000)/(1/8000)(1/8000))=log(8000/1)ï¼Œé‚£ä¹ˆå®ƒçš„äº’ä¿¡æ¯ä¼šæ›´å¤§ã€‚å–æœ€å°‘å‡ºçŽ°æ¬¡æ•°ä¹Ÿä¼šå‡ºçŽ°é—®é¢˜ï¼Œå°±æ˜¯ä¸€äº›ä½Žé¢‘çŽ‡çš„è¯ä¸èƒ½å‘çŽ°ã€‚æœ‰æ›´åŠ è¯¦ç»†çš„å…¬å¼ æ–‡ç« åŽ»é‡å‚åŠ çš„ä¸€ä¸ªè¯¾é¢˜é¡¹ç›®ï¼Œé’ˆå¯¹æŸä¸ªç‰¹å®šçš„è¡Œä¸šï¼Œæ¯”å¦‚æˆ¿åœ°äº§ã€äº’è”ç½‘ï¼ŒåŸºäºŽå¤§æ•°æ®ï¼Œå¯¹ç½‘é¡µæˆ–è€…æ–‡ç« è¿›è¡Œåˆ†æžï¼Œä½¿ç”¨æ•°æ®æŒ–æŽ˜çš„æ‰‹æ®µï¼Œæ•æ‰çƒ­ç‚¹ï¼Œç„¶åŽä¸ºä¼ä¸šæˆ–è€…ä¸ªäººæä¾›äº‹ä»¶æˆ–è€…å“ç‰Œçš„æƒ…æ„Ÿåˆ†æžã€å“ç‰Œåˆ†æžã€‚è¿™ä¸ªæ˜¯å¤§çš„é¡¹ç›®èƒŒæ™¯ã€‚ æˆ‘å‚ä¸Žçš„æ˜¯åœ¨äºŽå¯¹ç½‘é¡µæˆ–è€…ç½‘é¡µçš„åŽ»é‡å·¥ä½œï¼Œå› ä¸ºä¹‹åŽçš„æ–‡ç« åˆ†æžçš„æŒ‡æ ‡è®¡ç®—ï¼Œæ¯”å¦‚æµè¡Œåº¦ï¼Œéƒ½æ˜¯æ¯”è¾ƒä¾èµ–äºŽæ•°æ®çš„å‡†ç¡®æ€§ã€‚æ•°æ®çš„æ¥æºï¼šæ–°é—»ï¼ˆæœç‹ç½‘ã€æ–°æµªç½‘ï¼‰ç”µå­æŠ¥çº¸ï¼Œapp æ–°é—»ï¼Œåˆ†æˆä¸åŒç±»åˆ«çš„æ–°é—»ï¼Œæ¯”å¦‚ç§‘æŠ€ã€æ•™è‚²ã€é‡‘èžå’Œä½“è‚²ã€‚æ¯æ¡æ•°æ®ç”±æ ‡é¢˜ã€ç«™ç‚¹ã€urlã€å‘å¸ƒæ—¶é—´ã€å†…å®¹ã€é˜…è¯»é‡ã€è¯„è®ºé‡ç­‰ç»„æˆï¼Œæ•°æ®é‡æ˜¯ç™¾ä¸‡çº§åˆ«çš„ã€‚å…¶ä¸­å†…å®¹éƒ¨åˆ†æ˜¯ç”±500 åˆ°2000ä¸ç­‰çš„å­—æ•°ç»„æˆã€‚æ­¥éª¤çš„è¯ï¼Œå…ˆæ˜¯æ–‡æœ¬çš„é¢„å¤„ç†ï¼Œæå–å…³é”®è¯ï¼Œç„¶åŽä½¿ç”¨simhash æˆ–è€…minhash è¿›è¡Œè®¡ç®—ï¼Œé‡å¤æ–‡ç« çš„é›†åˆï¼Œæœ€åŽåŽ»æŽ‰é‡å¤çš„æ–‡ç« ã€‚ ä¼˜åŒ–ï¼šå¤šçº¿ç¨‹ï¼Œå­—å…¸ï¼ˆæœ‰ä¸€äº›å“ç‰Œç±»çš„ï¼Œäººåç±»ï¼Œéœ€è¦è¿›è¡Œäººå·¥çš„æ·»åŠ ã€æ–°è¯å‘çŽ°ï¼Œç½‘ç»œè¯æ±‡ï¼‰ å¦‚ä½•åŽ»è€ƒå¯Ÿæœ€åŽåŽ»é‡çš„æ•ˆæžœï¼Œä¸€èˆ¬æ¥è¯´ï¼Œsimhash ä¸­çš„è·ç¦»å‡½æ•°æ˜¯æ±‰æ˜Žè·ç¦»ï¼Œè¿™ä¸ªåœ¨3 ä»¥å†…ï¼Œéƒ½æ˜¯å¯ä»¥è®¤ä¸ºæ˜¯ç›¸ä¼¼çš„æ–‡ç« ã€‚å½“ç„¶å¯¹äºŽå®šé‡çš„è¯„ä»·çš„è¯ï¼Œæœ‰ä¸€ä¸ªæ ‡æ³¨çš„å°çš„æµ‹è¯•é›†ï¼Œç„¶åŽå¯ä»¥åœ¨ä¸Šé¢è¿›è¡Œ baselineçš„éªŒè¯ã€‚ Home credit default riskå¤„ç†æ•°æ®åº“æ•°æ®ï¼Œç»å¸¸æ˜¯éœ€è¦å¤„ç†å­è¡¨ä¿¡æ¯çš„ï¼Œé‚£ä¹ˆå¿…ç„¶å­˜åœ¨ç€ä¸»è¡¨ï¼Œè€Œå­è¡¨ç³»ä¿¡æ¯å¾€å¾€æ˜¯ä¸»è¡¨ä¿¡æ¯çš„æŸä¸€æ–¹é¢çš„ç»†åŒ–ã€‚æ‰€ä»¥æœ‰å¿…è¦å°†ä¸¤è€…è¿žæŽ¥èµ·æ¥ã€‚ æ•°æ®æ¸…æ´— Data Pre-processing å­¦ä¹ ç¬”è®°ï¼Œæœ¬èº«å°±æ€»ç»“çš„å¾ˆå¥½äº†ï¼Œæ‰€ä»¥å¤šçœ‹çœ‹å°±å¥½ã€‚ å¯¹äºŽæœºå™¨å­¦ä¹ ä¸­çš„ç‰¹å¾æå–ï¼Œå¯ä»¥ä»Žä¸šåŠ¡å’Œç»Ÿè®¡å­¦é€šç”¨æ–¹æ³•ä¸¤æ–¹é¢å…¥æ‰‹ã€‚é¦–å…ˆå°½å¯èƒ½çš„ä»Žä¸šåŠ¡æœ¬èº«ï¼Œæå–æ›´å¤šå¯è§£é‡Šã€ç¨³å®šçš„ç‰¹å¾ã€‚è¿™ä¸ªé¡¹ç›®æ˜¯ä¸€ä¸ªå°çš„é£ŽæŽ§æ¨¡åž‹ï¼Œå…¶ä¸­æœ‰ä¸€ä¸ªç‰¹å¾æ˜¯æ¶ˆè´¹æ°´å¹³æ¯”ä¸Šæ”¶å…¥æ°´å¹³ï¼Œä¸€èˆ¬æ¥è¯´æ¶ˆè´¹æ°´å¹³å¯¹åº”çš„æ˜¯äººçš„æ¶ˆè´¹è§‚ï¼Œä¸»è§‚æ„æ„¿å¤šèŠ±é’±ä¸Žå¦ï¼›æ”¶å…¥æ°´å¹³æ˜¯å®¢è§‚å­˜åœ¨çš„ï¼Œå¦‚æžœé«˜æ”¶å…¥äººç¾¤ï¼Œä¸€èˆ¬æ¥è¯´æ¶ˆè´¹æ°´å¹³æ¯”è¾ƒé«˜ã€‚å¹¶ä¸”è¿‘å‡ ä¸ªæœˆçš„æ¶ˆè´¹æ°´å¹³å’Œ é•¿æœŸçš„æ¶ˆè´¹æ°´å¹³å¯¹äºŽé£ŽæŽ§æ¨¡åž‹æœ‰ç€ä¸åŒå½±å“ç¨‹åº¦ï¼Œä¸€èˆ¬æ¥è¯´è¿‘æœŸçš„è¡Œä¸ºå¯¹æ¨¡åž‹å½±å“æ›´å¤§ã€‚æ‰€ä»¥éœ€è¦å°½å¯èƒ½åœ°æ‡‚æ•°æ®ï¼Œç„¶åŽä»Žè¿™äº›ç»´åº¦æå–å¯è§£é‡Šçš„ç‰¹å¾ã€‚ äººå·¥è°ƒå‚æ˜¯æŠ€æœ¯æ´»ï¼Œéœ€è¦å¯¹æ¨¡åž‹å’Œæ•°æ®æœ‰ä¸ªæ¯”ä»·é•¿çš„è®¤è¯†ï¼Œä¸€å¼€å§‹çš„æ—¶å€™å¸¸å¸¸ä½¿ç”¨Grid search å’ŒRandom search è¿™ä¸ªä¹Ÿæ˜¯å¯ä»¥å±•å¼€çš„ï¼šdomainï¼š æ‰€æœ‰çš„è¶…å‚æ•°åŠå…¶å€¼ çš„dictionaryï¼ˆé”®å€¼å¯¹ï¼‰Optimization algorithm: å¦‚ä½•åŽ»é€‰æ‹©ä¸‹ä¸€ç»„ è¶…å‚æ•°ã€‚ç›®æ ‡å‡½æ•°ï¼šè¿™ä¸ªæ˜¯æ¨¡åž‹ä¸­çš„ç›®æ ‡å‡½æ•°results historyï¼š ç›®æ ‡å‡½æ•°å’Œ ä¸€ç»„è¶…å‚æ•°çš„å¯¹åº”å…³ç³» å…³äºŽ results history çš„ä½¿ç”¨å°±æ˜¯ random search å’ŒåŸºäºŽè´å¶æ–¯æ–¹å¼æœç´¢çš„åŒºåˆ«ï¼Œå‰è€…æ²¡æœ‰ä½¿ç”¨è¿™ç§å¯¹åº”çš„å…³ç³»ï¼ŒåŽè€…æœ‰åˆ©ç”¨è¿™ç§å…³ç³»ã€‚ è´å¶æ–¯ï¼Œp(ç›®æ ‡å‡½æ•° | ä¸€ç»„è¶…å‚æ•°)ã€‚ ç‰¹å¾å·¥ç¨‹ ç‰¹å¾æ¥æºä¸€éƒ¨åˆ†æ˜¯ä¸šåŠ¡åœºæ™¯ï¼Œä¸€éƒ¨åˆ†æ˜¯å¸¸è§„æ“ä½œã€‚å¸¸è§„æ“ä½œåŒ…æ‹¬aggregationèšåˆæ“ä½œï¼ˆä¸»è¦é’ˆå¯¹å­è¡¨ï¼‰ï¼Œç‰¹å¾ç¦»æ•£åŒ–ï¼Œç»„åˆç‰¹å¾ã€‚ä¸šåŠ¡ç‰¹å¾ï¼Œå°±æ˜¯æ ¹æ®ä¸åŒçš„åœºæ™¯ï¼Œæž„é€ åœ¨è¯¥åœºæ™¯ä¸‹é‡è¦å­—æ®µã€‚å½“ç„¶è¿˜æœ‰ä¸€äº›éªšæ“ä½œï¼Œä½¿ç”¨æœºå™¨æ¨¡åž‹è¿›è¡Œç‰¹å¾çš„æž„é€ å’Œé€‰æ‹©ï¼Œä¼˜ç‚¹æ˜¯workï¼Œç¼ºç‚¹æ˜¯å¯è§£é‡Šæ€§å·®ï¼Œæ¯”å¦‚ä½¿ç”¨xgboost +LR æ¨¡åž‹ï¼Œå‰è€…å°±æ˜¯ä¸€ç§ç‰¹å¾æå–çš„åŠŸèƒ½ï¼Œæœ€åŽå¶å­ç»“ç‚¹çš„è¾“å‡ºï¼ŒçŸ¥é“å…¶æ˜¯é‡è¦çš„ï¼Œä½†æ˜¯ä¸çŸ¥é“å…¶å«ä¹‰æ˜¯ä»€ä¹ˆã€‚ è¿žç»­ç‰¹å¾ç¦»æ•£åŒ–çš„å¥½å¤„ï¼š (1) å¢žåŠ äº†æ¨¡åž‹çš„éžçº¿æ€§ï¼Œæå‡äº†æ¨¡åž‹è¡¨è¾¾èƒ½åŠ› (2) ç¦»æ•£åŒ–ç‰¹å¾å¯¹å¼‚å¸¸æ•°æ®å…·æœ‰å¾ˆå¼ºçš„é²æ£’æ€§ã€‚å¸¸ç”¨çš„é€‰å–ç¦»æ•£ç‚¹çš„æ–¹æ³•ï¼š(1) ç­‰è·ç¦»ç¦»æ•£ (2) ç­‰æ ·æœ¬ç¦»æ•£ (3) ç”»å›¾ (4) æ ¹æ®å®žé™…åœºæ™¯ï¼Œæ¯”å¦‚å¯¹äºŽå¹´é¾„çš„åˆ’åˆ† ç‰¹å¾ç»„åˆ( 1)åŸºæœ¬ç‰¹å¾çš„éžçº¿æ€§ç»„åˆ (2) ç‰¹å¾ä¹‹é—´çš„å·®å’Œä¹˜ç§¯å•†ï¼Œmean,varianceï¼Œstd ç»Ÿè®¡å­¦ç‰¹å¾ ç‰¹å¾é€‰æ‹©ï¼ˆé™ç»´ï¼‰çš„æ–¹æ³•: (1) ç‰¹å¾æœ¬èº« ï¼ˆå¦‚æžœç¼ºçœå€¼æ¯”è¾ƒå¤§æˆ–è€…æ•°æ®çš„æ³¢åŠ¨æ¯”è¾ƒå°ï¼‰ (2) ç‰¹å¾ä¹‹é—´çš„å…³ç³»ï¼ˆç‰¹å¾ä¹‹é—´æœ‰è¾ƒå¼ºçš„ç›¸å…³æ€§ï¼Œå¯ä»¥ä½¿ç”¨PCAè¿›è¡Œé™ç»´ï¼‰ (3 ) ç‰¹å¾å’Œæœ€åŽtarget çš„å…³ç³» (feature importance, å¡æˆ¿åˆ†å¸ƒï¼Œ pearson ç›¸å…³ç³»æ•°) (4) å¾ˆå¤šå¸¸è§çš„æœºå™¨å­¦ä¹ æ¨¡åž‹éƒ½æ˜¯ä¸€ç§ç‰¹å¾é€‰æ‹©çš„æ–¹å¼ï¼Œæ¯”å¦‚xgboost è¿žç»­ç‰¹å¾ç¦»æ•£åŒ–ï¼Œç¦»æ•£ç‰¹å¾one-hot åŒ–ï¼ˆè¿™ä¸ªéƒ½æ˜¯ä¸ºäº†LR ä½¿ç”¨æ–¹ä¾¿ï¼Œæ˜¯ä¸æ˜¯å¾ˆæŠ¼éŸµï¼‰ pygen é¡¹ç›®faker ä¸­ç”Ÿæˆçš„ä¿¡æ¯æ˜¯å•åˆ—çš„ï¼Œä¸ªäººä¿¡æ¯ä¹‹é—´æ˜¯æ²¡æœ‰è”ç³»çš„ï¼Œæ‰€ä»¥æƒ³è¦ç”¨åœ¨æœºå™¨å­¦ä¹ è®­ç»ƒçš„æ—¶å€™æ¯”è¾ƒéš¾ã€‚å…³é”®æŠ€æœ¯ï¼šä¸­æ–‡åå­—æœ‰å¾ˆå¼ºçš„æ€§åˆ«å±žæ€§ã€‚ä¾‹å¦‚åå­—ä¸­å¸¦æœ‰â€œæ°â€â€œå¿—â€â€œå®â€ç­‰å­—çš„ä¸€èˆ¬ä¸ºç”·æ€§ï¼Œå¸¦æœ‰â€œç¬â€â€œä½©â€â€œæ¢…â€ç­‰å­—çš„ä¸€èˆ¬ä¸ºå¥³æ€§ã€‚å½“ç„¶ä¹Ÿæœ‰ä¸€äº›æ¯”è¾ƒä¸­æ€§çš„å­—ï¼Œä¾‹å¦‚â€œæ–‡â€â€œå®‰â€â€œæ¸…â€ç­‰ï¼Œæ¯”è¾ƒéš¾çŒœæµ‹æ€§åˆ«ã€‚ gan è®ºæ–‡D ç½‘ç»œåœ¨åˆ¤åˆ«çš„æ—¶å€™ï¼Œæ˜¯ä»Žé€¼çœŸç¨‹åº¦ä¸Šè¿›è¡Œåˆ¤åˆ«çš„ï¼Œå¹¶ä¸æ˜¯ä»Žç”Ÿæˆå›¾åƒå¤šæ ·æ€§ä¸Šè¿›è¡Œåˆ¤åˆ«çš„ï¼Œå¹¶ä¸”æ˜¯æ— æ³•ä»Žå¤šæ ·æ€§ä¸Šè¿›è¡Œåˆ¤åˆ«çš„ï¼Œå› ä¸ºè¾“å…¥åˆ°D ç½‘ç»œä¸­çš„æ˜¯ä¸€ä¸ªæ ·æœ¬æˆ–è€…è¯´æ˜¯ä¸€ä¸ª batchçš„æ ·æœ¬ï¼Œæ˜¯å¾ˆéš¾å¾—åˆ°ç”Ÿæˆå›¾åƒçš„å¤šæ ·æ€§è¿™ä¸ªè§’åº¦çš„ã€‚ åŒç† G ç½‘ç»œä¹Ÿåªæ˜¯è€ƒè™‘å•ä¸ªçš„ç”Ÿæˆå›¾åƒï¼Œå¯¹äºŽG ç½‘ç»œå›¾åƒçš„å¤šæ ·æ€§æ˜¯æ²¡æœ‰è€ƒè™‘åœ¨å†…çš„ã€‚ æœ‰æ—¶å€™ä¹Ÿä¼šåœ¨è®­ç»ƒè¿‡ç¨‹ä¸­ä¹Ÿä¼šåˆ©ç”¨è¿™ç§æ€§è´¨ï¼Œæ¯”å¦‚è¯´åªæ˜¯ä¸ºäº†å¾—åˆ°ä¸€å¼ æˆ–è€…å‡ å¼ éžå¸¸é€¼çœŸå¥½çœ‹çš„å›¾åƒï¼Œè€Œä¸ä¼šå¾ˆåœ¨ä¹Žæœ€åŽæ˜¯å¦ç”Ÿæˆäº†å¤šæ ·æ€§çš„å›¾åƒã€‚ å­ªç”Ÿç½‘ç»œæœ€åˆæ˜¯ç”¨æ¥åšæŒ‡çº¹çš„éªŒè¯ï¼Œç„¶åŽæ‰©å±•åˆ° cv å’Œnlp ä¸­éƒ½æœ‰ç”¨æ¥åšç›¸ä¼¼åº¦æ–¹é¢çš„è®¡ç®—ã€‚åœ¨è®ºæ–‡ä¸­çš„æ˜¯ç”¨æ¥ä½œä¸ºç”Ÿæˆå›¾åƒä¹‹é—´ç›¸ä¼¼åº¦çš„è®¡ç®—ï¼Œè¯¥ç½‘ç»œä¸­ä¸¤ä¸ª CNN ç”¨äºŽæå–ç‰¹å¾ï¼Œç„¶åŽåŸºäºŽ æ¬§å¼è·ç¦»è¿›è¡Œè®¡ç®—ï¼Œè¾“å‡ºlabel æ˜¯0-1 ä¹‹é—´çš„æ•°å­—ï¼Œ 0è¡¨ç¤ºæœ€ç›¸è¿‘ï¼Œ1è¡¨ç¤ºä¸ç›¸è¿‘ã€‚æŸå¤±å‡½æ•°ä½¿ç”¨çš„æ˜¯ å¯¹æ¯”æŸå¤±å‡½æ•°ï¼Œæœ‰ç‚¹ç±»ä¼¼äº¤å‰ç†µçš„æ„Ÿè§‰ï¼Œåˆ†æ®µå‡½æ•°ï¼Œ y =0 çš„æ—¶å€™æ˜¯å¹³æ–¹æŸå¤±å‡½æ•°ï¼Œy =1 çš„æ—¶å€™ï¼Œæ˜¯åˆé¡µæŸå¤±å‡½æ•°ã€‚ ä¸»è¦çš„æ˜¯åšäº†ä»¥ä¸‹çš„ä¼˜åŒ–ï¼šlabel æµ®ç‚¹åŒ–ï¼ŒLabel Smoothing :è¿™ç§è·ç¦»çš„è®¡ç®—æ˜¯é€šè¿‡èšç±»å®žçŽ°çš„ï¼Œåœ¨åŒä¸€ä¸ªç°‡ä¸­æˆ–è€…ç›¸é‚»ç°‡ä¸­çš„è·ç¦»å°ï¼Œå‘ç€0 é è¿‘ï¼›åœ¨ä¸åŒçš„ç°‡ä¹‹é—´çš„ç›¸è·å¤§ï¼Œä¸è¶…è¿‡1. ç½‘ç»œç»“æž„ä¸Šæœ‰ä¸¤ç‚¹ä¼˜åŒ–ï¼šå¯¹äºŽå¯¹æŠ—ç”Ÿæˆç½‘ç»œçš„D ç½‘è·¯çš„æƒé‡è¿›è¡Œæ­£åˆ™åŒ–ï¼Œå…·ä½“æ¥è¯´æ˜¯ è°±å½’ä¸€åŒ–ï¼Œä½¿å…¶ç¬¦åˆlipschitz çº¦æŸï¼Œå…¶ä¸­è¶…å‚æ•° K å–1.å³ D(x) -D(y) çš„æ¬§å¼è·ç¦»æ˜¯ä¸å¤§äºŽ x-y çš„æ¬§å¼è·ç¦»çš„ã€‚ åŠ å…¥äº† self -attentionæœºåˆ¶ã€‚ XGboost å’ŒGBDT æ¯”è¾ƒæœ€åŽçš„æ•ˆæžœæå‡ï¼šæ•°æ®æ–¹é¢ Ignoring sparse inputsè¿™ä¸ªæ˜¯å¤„ç†ç¼ºçœå€¼ï¼ˆæˆ–è€… 0ï¼‰çš„æ‰‹æ®µï¼šä¸¤è€…åœ¨split åˆ†è£‚ç‚¹çš„æ—¶å€™ï¼Œéƒ½æ˜¯å…ˆä¸å¤„ç†æ•°å€¼ 0ï¼›ç„¶åŽæ‰¾åˆ°åˆ†è£‚ç‚¹ä¹‹åŽï¼ŒæŠŠ0 æ”¾åˆ°å“ªè¾¹é€ æˆçš„loss ä¸‹é™çš„æ¯”è¾ƒå¤§ï¼Œç„¶åŽå°±æ”¾åˆ°å“ªè¾¹ã€‚ æ¨¡åž‹æ–¹é¢ å¸¦æ·±åº¦é™åˆ¶çš„Leaf-wiseçš„å¶å­ç”Ÿé•¿ç­–ç•¥æœ€å¼€å§‹çš„æ—¶å€™xgboost ä¸­å¶å­ç”Ÿé•¿æ–¹å¼æ˜¯ level-wise çš„ç”Ÿé•¿ç­–ç•¥ï¼Œå®žé™…ä¸Šè¿™æ˜¯ä¸€ç§æ¯”è¾ƒéžå¸¸ä½Žæ•ˆçš„ç®—æ³•ï¼Œå› ä¸ºåŒä¸€å±‚çš„å¾ˆå¤šå¶å­åˆ†è£‚å¢žç›Šè¾ƒä½Žï¼Œæ²¡æœ‰å¿…è¦è¿›è¡Œæœç´¢å’Œåˆ†ç±»ã€‚è¿™ç§ä¸åŠ åŒºåˆ†çš„å¯¹å¾…åŒä¸€å±‚å¶å­å¸¦æ¥çš„æ˜¯æ²¡æœ‰å¿…è¦çš„å¼€é”€ã€‚leaf-wise æ˜¯ lightGBM ä¸Šä½¿ç”¨çš„ä¸€ç§ç®—æ³•ï¼Œåœ¨åˆ†è£‚æ¬¡æ•°ç›¸åŒçš„æƒ…å†µä¸‹ï¼Œå¯ä»¥é™ä½Žæ›´å¤šçš„è¯¯å·®ï¼Œå¾—åˆ°æ›´å¥½çš„ç²¾åº¦ã€‚leaf-wise çš„ç¼ºç‚¹å¯èƒ½ä¼šè¿‡æ‹Ÿåˆï¼Œæ‰€ä»¥åŠ ä¸Šäº†æ·±åº¦çš„é™åˆ¶ï¼Œåœ¨ä¿è¯é«˜æ•ˆçŽ‡çš„åŒæ—¶é˜²æ­¢è¿‡æ‹Ÿåˆã€‚ loss functionç›¸å¯¹æ¯” GBDTï¼Œç›®æ ‡å‡½æ•°åŠ å…¥äº†æ­£åˆ™é¡¹ï¼Œå› ä¸ºæ ‘ç»“æž„çš„æ¨¡åž‹æ˜¯å¾ˆå®¹æ˜“è¿‡æ‹Ÿåˆå¤§ï¼ŒåŠ å…¥æ­£åˆ™é¡¹å¯ä»¥å‡å°‘æ¨¡åž‹çš„å¤æ‚åº¦ï¼Œå¢žåŠ æ¨¡åž‹çš„æ³›åŒ–èƒ½åŠ›ã€‚ shrinkage å’Œ column subsamplingæå‡ºäº†ä¸¤ç§é˜²æ­¢è¿‡æ‹Ÿåˆçš„æ–¹æ³•ï¼šè¡°å‡å› å­å’Œé‡‡æ ·ã€‚å‰è€…åº”ç”¨äºŽä¸Šå±‚æ ‘ï¼ŒåŽè€…åº”ç”¨äºŽç‰¹å¾ï¼Œé€‰æ‹©éƒ¨åˆ†ç‰¹å¾è¿›è¡Œå»ºæ ‘ã€‚XGBooståˆ©ç”¨æ¢¯åº¦ä¼˜åŒ–æ¨¡åž‹ç®—æ³•, æ ·æœ¬æ˜¯ä¸æ”¾å›žçš„ï¼Œæƒ³è±¡ä¸€ä¸ªæ ·æœ¬è¿žç»­é‡å¤æŠ½å‡º,æ¢¯åº¦æ¥å›žè¸æ­¥ï¼Œè¿™æ˜¾ç„¶ä¸åˆ©äºŽæ”¶æ•›ã€‚ä½†æ˜¯ï¼ŒXGBoostæ”¯æŒå­é‡‡æ ·, ä¹Ÿå°±æ˜¯æ¯è½®è®¡ç®—å¯ä»¥ä¸ä½¿ç”¨å…¨éƒ¨æ ·æœ¬ã€‚ è®¡ç®—æ•ˆçŽ‡çš„æå‡ï¼š find the best splitxgboost æ˜¯åŸºäºŽå†³ç­–æ ‘ï¼Œé‚£ä¹ˆå¦‚ä½•å¿«é€Ÿå‘çŽ°æœ€åŽçš„åˆ†è£‚ç‚¹ã€‚ä¸€èˆ¬åšæ³•ä½¿ç”¨éåŽ†æ‰€æœ‰çš„æ ·æœ¬å’Œæ‰€æœ‰çš„ç‰¹å¾ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ $( n_{data}n_{features})$ã€‚xgboost é‡‡ç”¨äº†ä¸€ç§ä¼˜åŒ–æ‰‹æ®µï¼Œå¼•å…¥ä¸€ä¸ªè¶…å‚æ•° number of bins, æ—¶é—´å¤æ‚åº¦ä¼˜åŒ–åˆ° $n_{data}n_{bins}$ã€‚å½“ä½ çš„ bins çš„æ•°é‡è¶Šå¤§ï¼Œé‚£ä¹ˆè¿›åº¦æ˜¯è¶Šé«˜çš„ï¼Œè¿™æ˜¯ä¸€ç§ trade-offã€‚ æ”¯æŒå¹¶è¡ŒåŒ–è™½ç„¶å±‚æ¬¡æ ‘çš„å»ºç«‹æ˜¯ä¸²è¡Œçš„ï¼Œä½†æ˜¯åœ¨ä¸€ä¸ªç»“ç‚¹é€‰æ‹©å€™é€‰ç»“ç‚¹çš„æ—¶å€™ï¼Œæ˜¯å¯ä»¥ä½¿ç”¨å¤šè¿›ç¨‹å¹¶è¡Œè¿ç®—çš„ã€‚ loss functionæ˜¯äºŒé˜¶æ±‚å¯¼ï¼ˆtaylor äºŒé˜¶å±•å¼€å¼ï¼‰ æ³°å‹’å…¬å¼ä¸€å¥è¯æè¿°ï¼šå°±æ˜¯ç”¨å¤šé¡¹å¼å‡½æ•°åŽ»é€¼è¿‘å…‰æ»‘å‡½æ•°ã€‚é€šç”¨å¼å­å¦‚ä¸‹ï¼Œ$$f(x) =\sum_{n=0}^{N} \frac{f^{(n)}(0)}{n !} x^{n}$$æœ‰å¸¸è§çš„ä¸¤ç§å†™æ³•ï¼Œä¸€ç§æ˜¯ $f(x)$ åœ¨ $x_0$å¤„çš„åŸºæœ¬å½¢å¼ï¼Œ$$\begin{split}f(x) &amp;=\sum_{n=0}^{\infty} \frac{f^{(n)}(x_{0})}{n !}(x-x_{0})^{n} \\ &amp;=f(x_{0})+f^{1}(x_{0})(x-x_{0})+\frac{f^{2}(x_{0})}{2}(x-x_{0})^{2}+\cdots+\frac{f^{(n)}(x_{0})}{n !}(x-x_{0})^{n}\end{split}$$è¿˜æœ‰ä¸€ç§å¸¸è§çš„å†™æ³•ï¼Œ $x^{t +1} = x^t + \Delta x$ï¼Œ å°† $f (x^{t+1})$ åœ¨ $x^t$ å¤„è¿›è¡Œæ³°å‹’å±•å¼€$$f\left(x^{t+1}\right)=f\left(x^{t}\right)+f^{1}\left(x^{t}\right) \Delta x+\frac{f^{2}\left(x^{t}\right)}{2} \Delta x^{2}+\cdots$$ machine-learning-xgboost ä¸­çš„æ¨¡åž‹å­¦ä¹ éƒ¨åˆ†æœ‰å…¬å¼æŽ¨å¯¼ï¼Œå¥½å¥½çœ‹ã€‚ fasttext &amp; faissfasttex ä¸­æœ‰æœ‰ä¸¤éƒ¨åˆ†ï¼š æ— ç›‘ç£çš„å­¦ä¹ (subword)è¯å‘é‡çš„è®­ç»ƒ å’Œæœ‰ç›‘ç£åˆ†ç±»(text classification)ä»»åŠ¡ï¼Œä½¿ç”¨çš„æ˜¯ä¸‰å±‚ç½‘ç»œç»“æž„ï¼šè¾“å…¥å±‚ï¼Œéšè—å±‚å’Œè¾“å‡ºå±‚ã€‚ ä½¿ç”¨äºŒå‰æ ‘çš„ç»“æž„ï¼Œæ—¶é—´å¤æ‚åº¦ä»Ž $O(N) $ ä¼˜åŒ–åˆ°äº†$log_2(N)$ï¼Œå½“ä½¿ç”¨huffman æ ‘çš„æ—¶å€™ï¼Œè¿™ç§æ•ˆæžœæ›´åŠ æ˜Žæ˜¾ã€‚å±‚æ¬¡softmax ä¸æ˜¯fasttext çš„é¦–åˆ›ï¼Œå®ƒçš„æ”¹è¿›ä¹‹å¤„åœ¨å®žçŽ°çš„æ—¶å€™åŸºäºŽ huffman æ ‘è€Œä¸æ˜¯æ™®é€šçš„äºŒå‰æ ‘ï¼Œ å±žäºŽè¿ç®—ä¸Šçš„ä¼˜åŒ–ã€‚åˆ©ç”¨äº†ç±»åˆ«ä¸å‡è¡¡çš„ç‰¹ç‚¹ï¼Œç±»åˆ«å¤šçš„è·¯å¾„çŸ­ï¼Œæ•´ä½“ä¸Šçš„æ—¶é—´æ•ˆçŽ‡ä¼šæé«˜ã€‚ N-gram ä¸€ç§æ˜¯åŸºäºŽcharacter-level å¯¹äºŽä¸å¸¸è§å•è¯çš„æ‰©å……ï¼Œè§£å†³çš„æ˜¯OOVé—®é¢˜ï¼›ä¸€ç§æ˜¯word-levelï¼Œè€ƒè™‘çš„æ˜¯è¯è¯­å‘¨è¾¹çš„ä¿¡æ¯ï¼ŒåŠ å…¥äº†context çš„ä¿¡æ¯ï¼Œlocal context çš„ä¿¡æ¯ã€‚ negative sampling æ˜¯è§£å†³æœ€åŽsoftmax å±‚ä¸­ï¼Œä¸æ›´æ–°æ‰€æœ‰çš„negative wordsï¼Œåªæ˜¯æ›´æ–°å°‘éƒ¨åˆ†å•è¯ï¼Œæ ¹æ®è¯é¢‘é€‰æ‹©negative wordsï¼Œå¹¶ä¸”è¿™ç§è¯é¢‘æ˜¯ç»è¿‡çº¦æŸï¼Œä¸»è¦æ˜¯ä½¿å¾—ä½Žé¢‘è¯è¯­ä¹Ÿæœ‰å‡ºçŽ°çš„æœºä¼šã€‚ è°ƒå‚åˆ†ä¸ºå­—å…¸ç›¸å…³çš„å‚æ•°å’Œè®­ç»ƒç›¸å…³å‚æ•° fasttext çš„å’Œä¹‹å‰ CBOWçš„åŒºåˆ«ï¼šç½‘ç»œç»“æž„ä¸­çš„è¾“å…¥å±‚ï¼ŒCBOWæ˜¯ç»è¿‡one-hotçš„ä¸Šä¸‹æ–‡å•è¯ï¼Œè€Œfasttext æ˜¯å•è¯+ n-gram çš„ç‰¹å¾ï¼Œåœ¨è§£å†³OOVæ•ˆæžœæ¯”è¾ƒå¥½ï¼›å¦å¤–åœ¨æœ€åŽçš„è¾“å‡ºå±‚ï¼ŒåŸºäºŽhuffman æ ‘å®žçŽ°äº†å±‚æ¬¡softmaxï¼Œå¯¹äºŽç±»åˆ«ä¸å‡è¡¡çš„è®­ç»ƒé›†æ¥è¯´ï¼Œè®­ç»ƒæ—¶é—´ä¼šå˜å¾—æ›´çŸ­ã€‚ fasttext çš„ç¼ºç‚¹ï¼Œä½¿ç”¨æ–‡æœ¬åˆ†ç±»çš„æ—¶å€™ï¼Œå½“ç±»åˆ«æ¯”è¾ƒå¤šçš„æ—¶å€™æå‡æ•ˆæžœæ¯”è¾ƒæ˜Žæ˜¾ï¼Œå¦åˆ™æ˜¯å®¹æ˜“è¿‡æ‹Ÿåˆçš„ã€‚ fasttext å’Œ word2vec çš„åŒºåˆ«? CBOWçš„è¾“å…¥æ˜¯ç›®æ ‡å•è¯çš„ä¸Šä¸‹æ–‡ï¼ŒfastTextçš„è¾“å…¥æ˜¯å¤šä¸ªå•è¯åŠå…¶n-gramç‰¹å¾ï¼Œè¿™äº›ç‰¹å¾ç”¨æ¥è¡¨ç¤ºå•ä¸ªæ–‡æ¡£ï¼› CBOWçš„è¾“å…¥å•è¯è¢«onehotç¼–ç è¿‡ï¼ŒfastTextçš„è¾“å…¥ç‰¹å¾æ˜¯è¢«embeddingè¿‡ï¼›ï¼ˆEMBEDDING_DIMè¡¨ç¤ºç»è¿‡embeddingå±‚è¾“å‡ºï¼Œæ¯ä¸ªè¯è¢«åˆ†å¸ƒå¼è¡¨ç¤ºçš„å‘é‡çš„ç»´åº¦ï¼Œè¿™é‡Œè®¾ç½®ä¸º100ã€‚æ¯”å¦‚å¯¹äºŽâ€œè¾¾è§‚â€è¿™ä¸ªè¯ï¼Œä¼šè¢«ä¸€ä¸ªé•¿åº¦ä¸º100çš„ç±»ä¼¼äºŽ[ 0.97860014, 5.93589592, 0.22342691, -3.83102846, -0.23053935, â€¦]çš„å®žå€¼å‘é‡æ¥è¡¨ç¤ºï¼›ï¼‰ word2vecæ˜¯ä¸€ä¸ªæ— ç›‘ç£ç®—æ³•ï¼Œè€Œfasttextæ˜¯ä¸€ä¸ªæœ‰ç›‘ç£ç®—æ³•ã€‚CBOWçš„è¾“å‡ºæ˜¯ç›®æ ‡è¯æ±‡ï¼ŒfastTextçš„è¾“å‡ºæ˜¯æ–‡æ¡£å¯¹åº”çš„ç±»æ ‡ã€‚ word2vec ä¸­ çš„è®­ç»ƒtrickï¼ˆè¿™ä¸ªä¹Ÿä¸æ˜¯ word2vec çš„é¦–åˆ›ï¼‰ï¼š hierarchical softmax æœ¬è´¨æ˜¯æŠŠ N åˆ†ç±»é—®é¢˜å˜æˆ log(N)æ¬¡äºŒåˆ†ç±» negative sampling æœ¬è´¨æ˜¯é¢„æµ‹æ€»ä½“ç±»åˆ«çš„ä¸€ä¸ªå­é›† åœ¨æŸäº›æ–‡æœ¬åˆ†ç±»ä»»åŠ¡ä¸­ç±»åˆ«å¾ˆå¤šï¼Œè®¡ç®—çº¿æ€§åˆ†ç±»å™¨çš„å¤æ‚åº¦é«˜ã€‚ä¸ºäº†æ”¹å–„è¿è¡Œæ—¶é—´ï¼ŒfastText æ¨¡åž‹ä½¿ç”¨äº†å±‚æ¬¡ Softmax æŠ€å·§ã€‚å±‚æ¬¡ Softmax æŠ€å·§å»ºç«‹åœ¨å“ˆå¼—æ›¼ç¼–ç çš„åŸºç¡€ä¸Šï¼Œå¯¹æ ‡ç­¾è¿›è¡Œç¼–ç ï¼Œèƒ½å¤Ÿæžå¤§åœ°ç¼©å°æ¨¡åž‹é¢„æµ‹ç›®æ ‡çš„æ•°é‡ã€‚ n-gram æ˜¯æœ‰ä¸¤ä¸ªç»´åº¦çš„ï¼šå­—ç¬¦n-gram æ˜¯ç¼“è§£ oov é—®é¢˜ï¼› å­—ç»´åº¦æ˜¯å¯ä»¥åŠ å…¥éƒ¨åˆ†çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚ fasttext çš„ä¼˜åŠ¿ï¼š é€‚åˆå¤§åž‹æ•°æ®+é«˜æ•ˆçš„è®­ç»ƒé€Ÿåº¦ï¼šèƒ½å¤Ÿè®­ç»ƒæ¨¡åž‹â€œåœ¨ä½¿ç”¨æ ‡å‡†å¤šæ ¸CPUçš„æƒ…å†µä¸‹10åˆ†é’Ÿå†…å¤„ç†è¶…è¿‡10äº¿ä¸ªè¯æ±‡â€ fastTextä¸“æ³¨äºŽæ–‡æœ¬åˆ†ç±»ï¼Œåœ¨è®¸å¤šæ ‡å‡†é—®é¢˜ä¸Šå®žçŽ°å½“ä¸‹æœ€å¥½çš„è¡¨çŽ°ï¼ˆä¾‹å¦‚æ–‡æœ¬å€¾å‘æ€§åˆ†æžæˆ–æ ‡ç­¾é¢„æµ‹ï¼‰ã€‚ faiss æ˜¯ç¨ å¯†å‘é‡ä¹‹é—´è®¡ç®—è·ç¦»çš„å¼€æºå·¥å…·ã€‚ faiss ä¸‰ç§æ¨¡å¼æˆ–è€…è¯´ç´¢å¼•ã€‚ä¸€ç§ç®€å•æ¨¡å¼åœ¨å°çš„æ•°æ®é›†ä¸Šè®¡ç®—æ¬§å¼è·ç¦»ï¼›ä¸€ç§åŠ å¿«æ£€ç´¢çš„é€Ÿåº¦ï¼Œä½¿ç”¨èšç±»ç®—æ³•ï¼Œæ£€ç´¢çš„æ—¶å€™åªæ˜¯æ£€ç´¢id æ‰€åœ¨çš„ç°‡å’Œå‘¨å›´çš„ç°‡ï¼Œä¸è¿‡è¿™ä¸ªè¿‡ç¨‹æ˜¯éœ€è¦é¢„è®­ç»ƒçš„ï¼›ä¸€ç§æ˜¯å‡å°‘å†…å­˜çš„æ—¶å€™ï¼Œå¦‚æžœæ˜¯æ±‚è§£è¿‘ä¼¼è§£ï¼Œé‚£ä¹ˆä¸å¿…å­˜å‚¨å®Œæ•´çš„å‘é‡ï¼Œä½¿ç”¨pca é™ç»´ã€‚è¿˜æœ‰æ¯”è¾ƒé€šç”¨çš„åŠ å¿«é€Ÿåº¦çš„æ–¹å¼ï¼Œæ¯”å¦‚åˆ†æ®µè®¡ç®—å’Œä½¿ç”¨gpu è¿›è¡Œè®¡ç®—ã€‚ å…³äºŽk-meansä¸­é€‰æ‹©èšç±»ç°‡kçš„ä¸ªæ•°çš„ç®—æ³•ï¼šå°è¯•æ³•ã€‚å¦‚æžœå¢žå¤§kï¼Œå‘çŽ°å¹¶ä¸èƒ½ä½¿å¾—æŒ‡æ ‡æ˜Žæ˜¾çš„ä¸‹é™ï¼Œè¿™ä¸ªæ—¶å€™å°±è¾¾åˆ°äº†é˜ˆå€¼ã€‚æŒ‡æ ‡ï¼šä¸€ä¸ªç°‡å†…æ‰€æœ‰çš„ç‚¹åˆ°ç°‡ç±»ä¸­å¿ƒçš„è·ç¦»çš„æ€»å’Œã€‚ knn å’Œk-means çš„åŒºåˆ«ï¼Œå‰è€…æ˜¯æœ‰ç›‘ç£çš„åˆ†ç±»ç®—æ³•ï¼Œæ ¹æ®æµ‹è¯•ç‚¹å‘¨å›´k ä¸ªç‚¹çš„ç±»åˆ«ä¿¡æ¯åˆ¤æ–­è¯¥ç‚¹çš„ä¿¡æ¯ï¼›k-means æ˜¯æ— ç›‘ç£ç®—æ³•ï¼Œå±žäºŽèšç±»ä¸­çš„ä¸€ç§ã€‚ ä½¿ç”¨ä»€ä¹ˆåº“å‡½æ•°æœºå™¨å­¦ä¹ ä¸­ç»å¸¸ä½¿ç”¨ numpyï¼Œsklearnï¼Œpandasï¼Œxgboost NLPå’Œæ·±åº¦å­¦ä¹ ä¸­ä¸­ä½¿ç”¨jiebaï¼ŒNLTKï¼Œtensorflow å¦‚ä½•è¯„ä»·è‡ªå·±ç¼ºç‚¹ï¼š ï¼ˆè¯´ä¸€ä¸ªçœŸå®žçš„ç¼ºç‚¹ï¼Œè¿™ä¸ªç¼ºç‚¹å¿…é¡»æ˜¯æ­£åœ¨æ”¹å–„çš„ç¼ºç‚¹ï¼Œæœ€å¥½èƒ½å¤Ÿæˆä¸ºä¼˜ç‚¹çš„é‚£ç§ã€‚ï¼‰æœ‰æ—¶å€™è‡ªå·±å¯èƒ½è¿‡äºŽä¸“æ³¨äºŽæŸä¸€ç‚¹ï¼ŒæŠŠå¤ªå¤šçš„æ—¶é—´èŠ±è´¹åœ¨æŸä¸€æ–¹é¢ã€‚å®žä¹ å’Œåœ¨å­¦æ ¡æ˜¯ä¸å¤ªä¸€æ ·çš„ï¼Œå…¬å¸æ›´åŠ çœ‹é‡æˆæžœï¼Œæœ€åŽåšå‡ºæ¥çš„ä¸œè¥¿çš„æ•ˆæžœï¼Œæ‰€ä»¥å’Œå®žéªŒå®¤ä¸­æ•´å¤©æ•´ä¸ªæœˆåšä¸€ä»¶äº‹æƒ…æ˜¯ä¸å¤ªä¸€æ ·çš„ï¼Œå¯èƒ½éœ€è¦æ ¹æ®å…¬å¸ä¸šåŠ¡çš„éœ€æ±‚åŽ»è°ƒæ•´å·¥ä½œçš„é‡å¿ƒã€‚å®žä¹ æœŸé—´ï¼Œè‡ªå·±ä¹Ÿæ˜¯åœ¨åŠªåŠ›è°ƒæ•´è¿™ç§çŠ¶æ€ã€‚ ä¼˜ç‚¹ï¼š åŠ¨æ‰‹èƒ½åŠ›å¼ºï¼Œå¯¹äºŽä¸€ä¸ªæ–°ä¸œè¥¿ï¼Œä¸Šæ‰‹æ¯”è¾ƒå¿«ï¼Œåœ¨ai å¤§å¤šæ•°çš„é¢†åŸŸï¼Œè¿˜æ˜¯ä»Žç¾Žå›½ç¡…è°·å“ªé‡Œæ¥çš„ï¼Œæ‰€ä»¥è‹±è¯­èƒ½åŠ›æ¯”è¾ƒé‡è¦ï¼Œè€Œè‡ªå·±çš„è‹±è¯­æ°´å¹³æ¯”è¾ƒå¥½ï¼Œçœ‹è‹±æ–‡è®ºæ–‡è°ƒç ”æ–¹ä¾¿æ¯”è¾ƒæœ‰ä¼˜åŠ¿ã€‚å¿«é€Ÿå­¦ä¹ èƒ½åŠ›æ¯”è¾ƒå¼ºï¼Œæ‰€ä»¥èƒ½å¤Ÿæ¯”è¾ƒå¿«çš„æŽ¥å—æ–°é²œçš„äº‹ç‰©ï¼Œä¸Šæ‰‹æ¯”è¾ƒå¿«ã€‚ è¿™äº›ä»»åŠ¡ä¸­ï¼Œä½ çš„è§’è‰²æ˜¯ä»€ä¹ˆï¼Ÿ è¿™ä¸ªé—®é¢˜å¸¸å¸¸è¢«é¢è¯•å®˜è¿™æ ·é—®é“â€œè¿™ä¸ªæ˜¯ä½ ä¸€ä¸ªäººåšçš„å—ï¼Ÿ æ„Ÿè§‰æ—¢è¦ä½“çŽ°è‡ªå·±çš„ç‹¬ç«‹åšäº‹çš„èƒ½åŠ›åˆè¦æœ‰åˆä½œç²¾ç¥žã€‚å®žä¹ å·¥ä½œåŸºæœ¬ä¸Šéƒ½æ˜¯ç‹¬ç«‹å®Œæˆçš„ï¼Œé¡¹ç›®æ˜¯å’Œå®žéªŒå®¤çš„äººåˆä½œå®Œæˆçš„ï¼Œæˆ‘æ˜¯ä¸»è¦è´Ÿè´£äººã€‚ éœ€è¦å•ç‹¬å¤ä¹ çš„æ–‡ç« å¦‚ä½•å¤„ç† overfit æœ€åŽçš„å‘é—®ï¼Ÿ ä½ ä»¬æ‰€åœ¨çš„å°ç»„ä¸»è¦æ˜¯ä»€ä¹ˆä¸šåŠ¡å‘¢ï¼Ÿ å¦‚æžœæœ‰æœºä¼šæ¥è¿™é‡Œå·¥ä½œï¼Œé‚£ä¹ˆä¸»è¦çš„å·¥ä½œå†…å®¹æ˜¯ä»€ä¹ˆï¼Ÿ é¢è¯•ç»“æžœå¤§æ¦‚ä»€ä¹ˆæ—¶å€™å‡ºï¼Ÿ å¦‚æžœæ„Ÿè§‰é¢è¯•çš„æ¯”è¾ƒå¥½ï¼Œé‚£ä¹ˆé—®ä¸€ä¸‹å¯ä»¥ç®€å•çš„è¯„ä»·æˆ‘è¿™æ¬¡é¢è¯•å—ï¼Œå› ä¸ºæ‚¨ä¹Ÿé¢è¯•äº†ä¸å°‘çš„åŒå­¦äº†å§ã€‚]]></content>
      <categories>
        <category>NOT_FOR_YOU</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[logistics å’Œsoftmax çš„å…¬å¼æŽ¨å¯¼]]></title>
    <url>%2F2019%2F07%2F05%2Flogistics2softmax%2F</url>
    <content type="text"><![CDATA[Logistics å’Œ softmax çš„å…¬å¼æŽ¨å¯¼ã€‚æ€»ç»“å¸¸åœ¨é¢è¯•è¿‡ç¨‹ä¸­ç”¨åˆ°çš„å…¬å¼æŽ¨å¯¼ã€‚ Logisticså…¬å¼æŽ¨å¯¼Logistics Regression æ˜¯çº¿æ€§åˆ†ç±»å™¨ã€‚æ‰€ä»¥è¿˜æ˜¯å…ˆä»Žçº¿æ€§å›žå½’ä¸­å¼€å§‹æŽ¨å¯¼ã€‚LR æ¨¡åž‹æŽ¨å¯¼åˆ†æˆä»¥ä¸‹å››ä¸ªéƒ¨åˆ†ï¼š çº¿æ€§å›žå½’è¡¨ç¤ºï¼Œsigmoid æ¿€æ´»å‡½æ•°ã€ä¼˜åŒ–ç›®æ ‡æžå¤§ä¼¼ç„¶ä¼°è®¡ å’Œä½¿ç”¨æ¢¯åº¦ä¸Šå‡çš„æ–¹å¼æ›´æ–°æƒé‡ã€‚ çº¿æ€§å‡½æ•° $$\begin{split}h_{w}\left(x^{i}\right) &amp;=w_{0}+w_{1} x_{1}+w x_{2}+\ldots+w_{n} x_{n} \\h_{w}\left(x^{j}\right) &amp;=w^{T} x_{i}=W^{T} X\end{split}$$ ç„¶åŽåˆ†åˆ«è¿›è¡Œå‘é‡è¡¨ç¤ºï¼š $$\begin{split}X &amp;= \left[ 1 \ x_1 \ \dots x_n \right]^T \\W &amp;= \left[ w_0 \ w_1 \ \dots \ w_n \right]^T \\\end{split}$$ ä¸ºäº†æ›´å¥½çš„è¡¨ç¤ºåˆ†ç±»æ¨¡åž‹ï¼Œä½¿ç”¨sigmoid æ¿€æ´»å‡½æ•°ï¼Œå¼•å…¥äº†Logistics å›žå½’ã€‚ é€»è¾‘å›žå½’æ˜¯å‡è®¾æ•°æ®æœä»Ž Bernoulli åˆ†å¸ƒï¼ˆæŠ›ç¡¬å¸ï¼‰ï¼Œå› æ­¤LRå±žäºŽå‚æ•°æ¨¡åž‹ã€‚LRç›®æ ‡å‡½æ•°çš„å®šä¹‰ï¼š$$h_{\theta}(x)=g\left(\theta^{T} x\right)$$å…¶ä¸­sigmoid å‡½æ•°ä¸ºï¼š$g(z)=\frac{1}{1+e^{-z}}$ã€‚ sigmoid å‡½æ•°çš„å¯¼æ•°æœ‰å¾ˆå¥½çš„æ€§è´¨ $ g^{\prime}(z)=g(z)(1-g(z))$ ä¼¼ç„¶å‡½æ•° ä¸ºä»€ä¹ˆè¿™é‡Œä¼šå‡ºçŽ°æ¦‚çŽ‡å‘¢ï¼Ÿ å› ä¸ºç»è¿‡sigmoid æ¿€æ´»å‡½æ•°ä¹‹åŽï¼Œä¼šè¾“å‡º $y_{pred}$ï¼Œ èŒƒå›´æ˜¯åœ¨ [0, 1] ä¹‹é—´ï¼Œä¸€èˆ¬æ˜¯è·Ÿå†› 0.5 åŽ»åˆ’åˆ†ï¼Œå¦‚æžœå¤§äºŽ 0.5 é‚£ä¹ˆæ˜¯ A ç±»ï¼Œå¦åˆ™æ˜¯B ç±»ã€‚é€»è¾‘å›žå½’çš„ä¼˜åŒ–ç›®æ ‡æ˜¯æžå¤§åŒ–å¯¹æ•°ä¼¼ç„¶ä¼°è®¡ï¼Œé‡‡ç”¨æ¢¯åº¦ä¸Šå‡æ¥å­¦ä¹ åŠæ›´æ–°å‚æ•°$ \theta $å‘é‡çš„å€¼ã€‚ å‡è®¾æœ‰nä¸ªç‹¬ç«‹çš„è®­ç»ƒæ ·æœ¬ ${(x_1, y_1),(x_2, y_2), \ldots,(x_n, y_n)} $, å¹¶ä¸”$ y ={ 0, 1} $ã€‚é‚£æ¯ä¸€ä¸ªè§‚å¯Ÿåˆ°çš„æ ·æœ¬ $(x_i, y_i)$ å‡ºçŽ°çš„æ¦‚çŽ‡æ˜¯ï¼š $$P(y_i, x_i) = {P(y_i = 1| x_i)}^{y_i}{(1 -P(y_i =1| x_i)}^{1-y_i)}$$ æŽ¨å¹¿åˆ°æ‰€æœ‰æ ·æœ¬ä¸‹ï¼Œå¾—åˆ°æ•´ä½“çš„ä¼¼ç„¶å‡½æ•°è¡¨è¾¾ï¼Œéœ€è¦å°†æ‰€æœ‰çš„æ ·æœ¬ä¼¼ç„¶å‡½æ•°å…¨éƒ¨ç›¸ä¹˜ã€‚ $$L(\theta) =\Pi{P(y_i = 1| x_i)}^{y_i}({1 -P(y_i =1| x_i)})^{1-y_i}$$ ç´¯ä¹˜çš„å½¢å¼ä¸åˆ©äºŽè¿›è¡Œä¼˜åŒ–åˆ†æžï¼Œè¿™é‡Œå°†ä¼¼ç„¶å‡½æ•°å–å¯¹æ•°ï¼Œå¾—åˆ°å¯¹æ•°ä¼¼ç„¶å‡½æ•°ï¼Œä½œä¸ºæˆ‘ä»¬çš„æœ€ç»ˆä¼˜åŒ–ç›®æ ‡ï¼Œè¿ç”¨æžå¤§ä¼¼ç„¶ä¼°è®¡æ¥æ±‚å¾—æœ€ä¼˜çš„ $\theta$ (è¿™ä¸ªå‚æ•°æ˜¯æ¥è‡ªçº¿æ€§ç›¸ä¹˜ä¸­çš„å‚æ•°) $$\begin{split}l(\theta) &amp;=logL(\theta) \\&amp;= \sum_{i =1}^{m}(y^{(i)} \log h\left(x^{(i)}\right)+\left(1-y^{(i)}\right) \log \left(1-h\left(x^{(i)}\right)\right))\end{split}$$ æœ€ä¼˜åŒ–æ±‚è§£ ä½¿ç”¨é“¾å¼æ³•å¯¹ç›®æ ‡å‡½æ•°è¿›è¡Œæ±‚å¯¼ç„¶åŽæ±‚è§£ã€‚ $$\frac{\partial}{\theta_{j}} J(\theta)=\frac{\partial J(\theta)}{\partial g\left(\theta^{T} x\right)} \times \frac{\partial g\left(\theta^{T} x\right)}{\partial \theta^{T} x} \times \frac{\partial \theta^{T} x}{\partial \theta_{j}}$$ åˆ†æˆä¸‰éƒ¨åˆ†ï¼šç¬¬ä¸€éƒ¨åˆ†$$\frac{\partial J(\theta)}{\partial g\left(\theta^{T} x\right)}=y \times \frac{1}{g\left(\theta^{T} x\right)}+(y-1) \times \frac{1}{1-g\left(\theta^{T_{x} x}\right)}$$ ç¬¬äºŒéƒ¨åˆ† $$\frac{\partial g\left(\theta^{T} x\right)}{\partial \theta^{T} x}=g\left(\theta^{T} x\right)\left(1-g\left(\theta^{T} x\right)\right)$$ ç¬¬ä¸‰éƒ¨åˆ† $$\frac{\partial \theta^{T} x}{\theta_{j}}=\frac{\partial J\left(\theta_{1} x_{1}+\theta_{2} x_{2}+\cdots \theta_{n} x_{n}\right)}{\partial \theta_{j}}=x_{j}$$ æœ€åŽç›¸ä¹˜å¯ä»¥å¾—åˆ°ï¼š $$ \frac{\partial}{\partial \theta_{j}} \ell(\theta)= \left(y-h_{\theta}(x)\right) x_{j}$$ å› æ­¤æ€»çš„ $\theta $ çš„æ›´æ–°å…¬å¼ä¸ºï¼š$$ J(\theta) := \theta_{j}+\alpha\left(y^{(i)}-h_{\theta}\left(x^{(i)}\right)\right) x_{j}^{(i)}$$ å…³äºŽlogistics çš„å…¬å¼æŽ¨å¯¼å·²ç»ç»“æŸã€‚ åŽŸæ–‡é“¾æŽ¥ï¼šLogisticsåˆ°softmaxæŽ¨å¯¼æ•´ç† çº¯python å®žçŽ°é€»è¾‘å›žå½’çº¿æ€§åˆ†ç±»å™¨ï¼šæ¨¡åž‹æ˜¯å‚æ•°çš„çº¿æ€§å‡½æ•°ï¼Œåˆ†ç±»å¹³é¢æ˜¯ï¼ˆè¶…ï¼‰å¹³é¢ï¼›éžçº¿æ€§åˆ†ç±»å™¨ï¼šæ¨¡åž‹åˆ†ç•Œé¢å¯ä»¥æ˜¯æ›²é¢æˆ–è€…è¶…å¹³é¢çš„ç»„åˆã€‚å…¸åž‹çš„çº¿æ€§åˆ†ç±»å™¨æœ‰æ„ŸçŸ¥æœºï¼ŒLDAï¼Œé€»è¾‘æ–¯ç‰¹å›žå½’ï¼ŒSVMï¼ˆçº¿æ€§æ ¸ï¼‰ï¼›å…¸åž‹çš„éžçº¿æ€§åˆ†ç±»å™¨æœ‰ kNNï¼Œå†³ç­–æ ‘ï¼ŒSVMï¼ˆéžçº¿æ€§æ ¸ï¼‰ å…³é”®æ˜¯çœ‹åŽé¢ï¼Œå¦‚ä½•ä½¿ç”¨çº¯python åŽ»å®žçŽ°ä¸€ä¸ªé€»è¾‘å›žå½’ã€‚ ä»£ç ï¼šé€»è¾‘å›žå½’.pyè®²è§£ï¼šæœºå™¨å­¦ä¹ ç®—æ³• ä¹‹é€»è¾‘å›žå½’ä»¥åŠpythonå®žçŽ° åœ¨numpy ä¸­ï¼Œ12* å’Œ np.multiply éƒ½æ˜¯éƒ½æ˜¯æ•°å­—ç›¸ä¹˜ï¼Œå¦‚æžœæ˜¯çŸ©é˜µï¼Œé‚£ä¹ˆå°±æ˜¯å¯¹åº”ä½ç½®ç›¸ä¹˜@ å’Œnp.dot éƒ½æ˜¯çŸ©é˜µç›¸ç§°ï¼Œå¯¹åº”å‘é‡å†…ç§¯ softmax çš„æŽ¨å¯¼å¤šåˆ†ç±»ä¸­ä½¿ç”¨çš„æ˜¯äº¤å‰ç†µæŸå¤±å‡½æ•° ( cross entropy error function)ï¼Œäº¤å‰ç†µå‡½æ•°æ˜¯å‡¸å‡½æ•°ã€‚æœ€åŽä¸€å±‚çš„ç½‘ç»œå±•å¼€ï¼Œæœ€ç»ˆçš„ç»“æžœå±•å¼€æˆ one-hot çš„å½¢å¼ï¼Œç”¨ softmax å¾—åˆ°çš„æ¦‚çŽ‡å€¼è¿›è¡Œäº¤å‰ç†µçš„è®¡ç®—ï¼Œå¸¦å…¥å…¬å¼ $$J=-\sum_{c=1}^{M} y_{c} \log \left(p_{c}\right)$$ å¥½å¥½ç†è§£ä¸€ä¸‹ä»Žsoftmax åˆ°äº¤å‰ç†µè®¡ç®—è¿‡ç¨‹ã€‚ è¿™ä¸ªé‡Œé¢æœ‰ä¸€éƒ¨åˆ†å…³ä¹Ž softmax çš„æŽ¨å¯¼ï¼Œä½†æ˜¯æ„Ÿè§‰ä¸æ˜¯å¾ˆå…¨å¾ˆè¯¦ç»†ï¼šLogisticsåˆ°softmaxæŽ¨å¯¼æ•´ç† SVMå…¬å¼æŽ¨å¯¼ å¦‚ä¸Šå›¾ä¸­åªæœ‰çº¿ä¸Šçš„ç‚¹å«åšæ”¯æŒå‘é‡ï¼Œå…¶ä»–çš„ç‚¹åœ¨ $y$ ä¸­çš„è¡¨ç¤ºè¦ä¹ˆæ˜¯ 1è¦ä¹ˆæ˜¯-1ã€‚æ”¯æŒå‘é‡å¯ä»¥ç”¨æ¥è¿›è¡Œåˆ†ç±»å’Œå›žå½’ï¼Œè¿™é‡Œä»‹ç»çš„æ˜¯åˆ†ç±»é—®é¢˜ã€‚æ”¯æŒå‘é‡çš„ç›®æ ‡æ˜¯æœ€å¤§åŒ–æ­£è´Ÿæ ·æœ¬ä¹‹é—´çš„é—´éš”ã€‚åˆ†ç±»é—®é¢˜å¯ä»¥åˆ†æˆä¸‰ç±»ï¼š çº¿æ€§å¯åˆ†ï¼ˆç¡¬é—´éš”æ”¯æŒå‘é‡ï¼‰ è¿‘ä¼¼çº¿æ€§å¯åˆ†ï¼ˆè½¯é—´éš”æ”¯æŒå‘é‡ï¼Œé€šè¿‡å¼•å…¥æ¾å¼›å˜é‡å®žçŽ°ï¼‰ çº¿æ€§å®Œå…¨ä¸å¯åˆ†ï¼ˆä½¿ç”¨éžçº¿æ€§æ ¸å‡½æ•°ï¼‰ ä¸‹é¢çš„å…¬å¼æŽ¨å¯¼éƒ½æ˜¯åŸºäºŽçº¿æ€§å¯åˆ†æ¡ä»¶ä¸‹çš„ï¼Œä¹Ÿå°±æ˜¯ç¡¬é—´éš”æ”¯æŒå‘é‡æœºã€‚æ­¥éª¤æœ‰äºŒï¼š å¯»æ‰¾æœ€å¤§åˆ†éš”é—´è·ï¼ˆåŽŸé—®é¢˜å¯ä»¥è½¬æ¢æˆå¯¹å¶é—®é¢˜ï¼‰ é€šè¿‡æ‹‰æ ¼æœ—æ—¥æ±‚è§£ä¼˜åŒ–é—®é¢˜ ä»Žç¬¬ä¸€æ­¥ä¸­å¾—åˆ°æ˜¯ä¸€ä¸ªäºŒæ¬¡è§„åˆ’é—®é¢˜ï¼Œå¯ä»¥æ±‚è§£ï¼Œä½†å½“æ ·æœ¬é‡å¤§çš„æ—¶å€™ï¼Œè®¡ç®—é‡éžå¸¸å¤§ï¼Œæ‰€ä»¥å¯ä»¥è½¬æ¢æˆå…¶å¯¹å¶é—®é¢˜æ±‚è§£ã€‚ç„¶åŽä½¿ç”¨æ‹‰æ ¼æœ—æ—¥å…¬å¼æ±‚è§£ï¼Œè¿™ä¸ªæ—¶å€™å¼•å…¥ä¸€ä¸ªå‚æ•°æ‹‰æ ¼æœ—æ—¥å‚æ•°ï¼Œæ±‚è§£è¿™ä¸ªå‚æ•°å³å¯ã€‚ å…·ä½“å…¬å¼çš„æŽ¨å¯¼å¯ä»¥å‚è€ƒä¸‹é¢çš„æ–‡ç« ï¼š SVMå…¬å¼æŽ¨å¯¼ å¯¹äºŽä¸Šé¢æ–‡ç« çš„è§£è¯» åœ¨æ ·æœ¬ç©ºé—´ï¼Œåˆ’åˆ†è¶…å¹³é¢å¯ä»¥é€šè¿‡ä»¥ä¸‹çº¿æ€§æ–¹ç¨‹æè¿°ï¼š$$w^Tx+b =0$$å‡è®¾è¶…å¹³é¢ $(w,b) $èƒ½å°†è®­ç»ƒæ ·æœ¬æ­£ç¡®åˆ†ç±»ï¼Œå³å¯¹äºŽ$(x_i,y_i)âˆˆD $ï¼Œè‹¥ $y_i=+1$ï¼Œåˆ™æœ‰ $w^Tx+b&gt;0 $ï¼›è‹¥ $y_i=âˆ’1$ ï¼ˆè¿™ä¸ªæ¡ä»¶æ˜¯å‡è®¾çš„ï¼Œä»¤ï¼‰ ä»ŽåŽŸæ¥çš„åˆ†æ®µå‡½æ•°è¡¨ç¤ºæˆä¸‹é¢çš„å…¬å¼ï¼Œåœ¨äºŽè¿™æ ·çš„ç»“æžœæ˜¯å¯ä»¥ç›´æŽ¥è¡¨ç¤ºåˆ†ç±»ç»“æžœçš„æ­£ç¡®ä¸Žå¦ï¼Œå¦‚æžœç»“æžœå¤§äºŽ0è¡¨ç¤º $f(x)$ å’Œ $label $ æ˜¯åŒå·ï¼Œé‚£ä¹ˆè¡¨ç¤ºé¢„æµ‹æ­£ç¡®ï¼Œå¦åˆ™é¢„æµ‹é”™è¯¯ã€‚$$y_{i} \cdot\left(w^{T} x_{i}+b\right) \geq 1$$å…¬å¼ä¸­çš„ 1-5 å¯¹åº”çš„æ˜¯æ­¥éª¤ä¸€ï¼›æ­¥éª¤6-10 æ˜¯å¯¹åº”æ±‚è§£é—®é¢˜ã€‚ åœ¨è®¡ç®—è¿‡ç¨‹ä¸­æ”¯æŒå‘é‡çš„ç‚¹æ˜¯ç”¨æ¥è®¡ç®—è·ç¦»çš„ï¼Œå…¶ä»–æ ·æœ¬ç‚¹æ˜¯ä½“çŽ°åœ¨çº¦æŸæ¡ä»¶ä¸­ã€‚ åˆ¤åˆ«æ¨¡åž‹ åå‘ä¼ æ’­çš„æŽ¨å¯¼è¿™ä¸ªæŽ¨å¯¼ä¹Ÿæ˜¯è¶…çº§ç®€å•ï¼Œåˆ†æˆä¸‰ä¸ªæ­¥éª¤ï¼š å‰å‘ä¼ æ’­ï¼Œæ³¨æ„$f_1$ å’Œ $y_1$ æ‰€è¡¨ç¤ºçš„å«ä¹‰çš„ä¸åŒï¼Œå‰è€…ç»è¿‡æ¿€æ´»å‡½æ•° æ¯”å¦‚è¯´sigmoid å°±å¾—åˆ°äº†åŽè€… åå‘ä¼ æ’­ï¼Œå’Œå‰å‘ä¼ æ’­æ˜¯ä¸€æ ·çš„ï¼Œåªä¸è¿‡å‡ºå‘ç‚¹æ˜¯ $\delta$ï¼Œå…³é”®æ˜¯è¦ä½¿ç”¨åˆ°å‰é¢çš„weight ä¿¡æ¯è¿›è¡Œ $\delta$ çš„é‡æ–°åˆ†é… æƒå€¼æ›´æ–°ï¼Œæ³¨æ„æ¶‰åŠåˆ°åŽŸæ¥çš„ weightsã€errorã€æ¢¯åº¦å’Œå­¦ä¹ çŽ‡å››ä¸ªå˜é‡ã€‚ (æ³¨æ„åœ¨æƒå€¼æ›´æ–°æŽ¨å¯¼çš„æ—¶å€™ï¼Œä¸€å®šè¦ä½¿ç”¨åˆ°å­¦ä¹ çŽ‡ï¼Œæ±‚å¯¼ï¼Œerror è¿™å‡ ä¸ªå˜é‡ï¼Œå¦åˆ™æ˜¯æ²¡æœ‰åŠžæ³•åŸºäºŽä¹‹å‰çš„è¿›è¡Œæ›´æ–°çš„)è¯¦ç»†æƒ…å†µå¯ä»¥çœ‹è¿™é‡Œ åå‘ä¼ æ’­çš„æŽ¨å¯¼ xgboost ä¸­çš„ç†è®ºæŽ¨å¯¼xgboost çš„loss çš„äºŒé˜¶å±•å¼€æŽ¨å¯¼ ä¸Šé¢å¼å­ä¸­çš„ lossåŒ…å«ç€æ­£åˆ™é¡¹ã€‚ ä¸€ä¸ªæ˜¯æ ‘é‡Œé¢å¶å­èŠ‚ç‚¹çš„ä¸ªæ•°T ä¸€ä¸ªæ˜¯æ ‘ä¸Šå¶å­èŠ‚ç‚¹çš„å¾—åˆ†wçš„L2æ¨¡å¹³æ–¹ï¼ˆå¯¹wè¿›è¡ŒL2æ­£åˆ™åŒ–ï¼Œç›¸å½“äºŽé’ˆå¯¹æ¯ä¸ªå¶ç»“ç‚¹çš„å¾—åˆ†å¢žåŠ L2å¹³æ»‘ï¼Œç›®çš„æ˜¯ä¸ºäº†é¿å…è¿‡æ‹Ÿåˆï¼‰ æ³°å‹’äºŒé˜¶å±•å¼€å¼ï¼š $$f(x+\Delta x) \simeq f(x)+f^{\prime}(x) \Delta x+\frac{1}{2} f^{\prime \prime}(x) \Delta x^{2}$$ XGBoostä¸ŽGBDTæœ‰ä»€ä¹ˆä¸åŒ GBDTæ˜¯æœºå™¨å­¦ä¹ ç®—æ³•ï¼ŒXGBoostæ˜¯è¯¥ç®—æ³•çš„å·¥ç¨‹å®žçŽ°ã€‚ åœ¨ä½¿ç”¨CARTä½œä¸ºåŸºåˆ†ç±»å™¨æ—¶ï¼ŒXGBoostæ˜¾å¼åœ°åŠ å…¥äº†æ­£åˆ™é¡¹æ¥æŽ§åˆ¶æ¨¡ åž‹çš„å¤æ‚åº¦ï¼Œæœ‰åˆ©äºŽé˜²æ­¢è¿‡æ‹Ÿåˆï¼Œä»Žè€Œæé«˜æ¨¡åž‹çš„æ³›åŒ–èƒ½åŠ›ã€‚ GBDTåœ¨æ¨¡åž‹è®­ç»ƒæ—¶åªä½¿ç”¨äº†ä»£ä»·å‡½æ•°çš„ä¸€é˜¶å¯¼æ•°ä¿¡æ¯ï¼ˆéšæœºæ¢¯åº¦ä¸‹é™ï¼‰ï¼ŒXGBoostå¯¹ä»£ ä»·å‡½æ•°è¿›è¡ŒäºŒé˜¶æ³°å‹’å±•å¼€ï¼Œå¯ä»¥åŒæ—¶ä½¿ç”¨ä¸€é˜¶å’ŒäºŒé˜¶å¯¼æ•°ã€‚ï¼ˆç‰›é¡¿æ³•ï¼‰ ä¼ ç»Ÿçš„GBDTé‡‡ç”¨CARTä½œä¸ºåŸºåˆ†ç±»å™¨ï¼ŒXGBoostæ”¯æŒå¤šç§ç±»åž‹çš„åŸºåˆ†ç±» å™¨ï¼Œæ¯”å¦‚çº¿æ€§åˆ†ç±»å™¨ã€‚ ä¼ ç»Ÿçš„GBDTåœ¨æ¯è½®è¿­ä»£æ—¶ä½¿ç”¨å…¨éƒ¨çš„æ•°æ®ï¼ŒXGBooståˆ™é‡‡ç”¨äº†ä¸Žéšæœº æ£®æž—ç›¸ä¼¼çš„ç­–ç•¥ï¼Œæ”¯æŒå¯¹æ•°æ®è¿›è¡Œé‡‡æ ·ã€‚ ä¼ ç»Ÿçš„GBDTæ²¡æœ‰è®¾è®¡å¯¹ç¼ºå¤±å€¼è¿›è¡Œå¤„ç†ï¼ŒXGBoostèƒ½å¤Ÿè‡ªåŠ¨å­¦ä¹ å‡ºç¼º å¤±å€¼çš„å¤„ç†ç­–ç•¥ã€‚ XGBoostä½¿ç”¨äº†ä¸€é˜¶å’ŒäºŒé˜¶åå¯¼, äºŒé˜¶å¯¼æ•°æœ‰åˆ©äºŽæ¢¯åº¦ä¸‹é™çš„æ›´å¿«æ›´å‡†. ä½¿ç”¨æ³°å‹’å±•å¼€å–å¾—å‡½æ•°åšè‡ªå˜é‡çš„äºŒé˜¶å¯¼æ•°å½¢å¼, å¯ä»¥åœ¨ä¸é€‰å®šæŸå¤±å‡½æ•°å…·ä½“å½¢å¼çš„æƒ…å†µä¸‹, ä»…ä»…ä¾é è¾“å…¥æ•°æ®çš„å€¼å°±å¯ä»¥è¿›è¡Œå¶å­åˆ†è£‚ä¼˜åŒ–è®¡ç®—, æœ¬è´¨ä¸Šä¹Ÿå°±æŠŠæŸå¤±å‡½æ•°çš„é€‰å–å’Œæ¨¡åž‹ç®—æ³•ä¼˜åŒ–/å‚æ•°é€‰æ‹©åˆ†å¼€äº†. è¿™ç§åŽ»è€¦åˆå¢žåŠ äº†XGBoostçš„é€‚ç”¨æ€§, ä½¿å¾—å®ƒæŒ‰éœ€é€‰å–æŸå¤±å‡½æ•°, å¯ä»¥ç”¨äºŽåˆ†ç±», ä¹Ÿå¯ä»¥ç”¨äºŽå›žå½’ã€‚ XGBooståœ¨è®­ç»ƒçš„è¿‡ç¨‹ä¸­ç»™å‡ºå„ä¸ªç‰¹å¾çš„è¯„åˆ†ï¼Œä»Žè€Œè¡¨æ˜Žæ¯ä¸ªç‰¹å¾å¯¹æ¨¡åž‹è®­ç»ƒçš„é‡è¦æ€§ã€‚XGBooståˆ©ç”¨æ¢¯åº¦ä¼˜åŒ–æ¨¡åž‹ç®—æ³•, æ ·æœ¬æ˜¯ä¸æ”¾å›žçš„ï¼Œæƒ³è±¡ä¸€ä¸ªæ ·æœ¬è¿žç»­é‡å¤æŠ½å‡º,æ¢¯åº¦æ¥å›žè¸æ­¥ï¼Œè¿™æ˜¾ç„¶ä¸åˆ©äºŽæ”¶æ•›ã€‚XGBoostæ”¯æŒå­é‡‡æ ·, ä¹Ÿå°±æ˜¯æ¯è½®è®¡ç®—å¯ä»¥ä¸ä½¿ç”¨å…¨éƒ¨æ ·æœ¬ã€‚ (XGBoostè¯¦è§£)[https://www.jianshu.com/p/ac1c12f3fba1] XGBoostäºŒé˜¶æ³°å‹’å±•å¼€å…¬å¼æŽ¨å¯¼]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Text Summarization]]></title>
    <url>%2F2019%2F06%2F30%2Ftext-summarization%2F</url>
    <content type="text"><![CDATA[Text Summarization Text summarization is the process of distilling the most important information from a source (or sources) to produce an abridged version for a particular user (or users) and task (or tasks). There are many reasons why Automatic Text Summarization is useful: Summaries reduce reading time. Automatic summarization algorithms are less biased than human summarizers. Personalized summaries are useful in question-answering systems as they provide personalized information. Text summarization methods can be classified into different types. è™½ç„¶æ˜¯å¯ä»¥ä»Žä¸åŒçš„è§’åº¦è¿›è¡Œåˆ’åˆ†ï¼Œä½†æœ€å¸¸è§çš„åˆ†ç±»è§’åº¦æ˜¯ based on output type: extractive and abstractive. All extractive summarization algorithms attempt to score the phrases or sentences in a document and return only the most highly informative blocks of text. Abstractive text summarization actually creates new text which doesnâ€™t exist in that form in the document. Abstractive summarization is what you might do when explaining a book you read to your friend, and it is much more difficult for a computer to do than extractive summarization. extractive æ˜¯ä»Žæºå¥å­ä¸­æ‰¾å…³é”®å¥çš„è¿‡ç¨‹ï¼Œ abstractive æ˜¯æ¦‚æ‹¬ï¼Œç”Ÿæˆå¯¹äºŽæ–‡ç« æ€»ç»“çš„è¿‡ç¨‹ã€‚ Computers just arenâ€™t that great at the act of creation. To date, there arenâ€™t any abstractive summarization techniques which work suitably well on long documents. The best performing ones merely create a sentence based upon a single paragraph, or cut the length of a sentence in half while maintaining as much information as possible. Often, grammar suffers horribly. Theyâ€™re usually based upon neural network models. What is ROUGE?To evaluate the goodness of the generated summary, the common metric in the Text Summarization space is called Rouge score. ROUGE stands for Recall-Oriented Understudy for Gisting Evaluation It works by comparing an automatically produced summary or translation against a set of reference summaries (typically human-produced). It works by matching overlap of n-grams of the generated and reference summary. Extractive Techniques LexRank SummarizerLexRank is an unsupervised approach that gets its inspiration from the same ideas behind Googleâ€™s PageRank algorithm. It finds the relative importance of all words in a document and selects the sentences which contain the most of those high-scoring words. NLTK Summarizer å°†å¥å­çš„é‡è¦ç¨‹åº¦ä¸‹æ”¾åˆ°è¯è¯­ word çš„å…³é”®ç¨‹åº¦ã€‚å…ˆæ˜¯æ–‡æœ¬çš„é¢„å¤„ç†ï¼Œç„¶åŽæŒ‘é€‰å…³é”®è¯ï¼Œç„¶åŽæŒ‘é€‰å…³é”®å¥ã€‚ Although the technique is basic, we found that it did a good job at creating large summaries. Gensim Summarizer ï¼ˆpagerank çš„æ€æƒ³å¾ˆç®€å•ï¼Œæ¯ä¸€ä¸ªç½‘é¡µéƒ½æ˜¯ä¸€ç§æŠ•ç¥¨ï¼Œç„¶åŽè¢«æŠ•ç¥¨çš„é‡è¦ç¨‹åº¦è¶Šé«˜ï¼Œé‚£ä¹ˆè¿™ä¸ªç½‘é¡µæˆ–è€…ç½‘ç«™çš„é‡è¦æ€§å°±è¶Šé«˜ï¼Œæœ€åŽçš„æŽ’åå°±è¶Šé å‰ï¼‰TextRank is based on PageRank algorithm that is used on Google Search Engine. In simple words, it prefers pages which has higher number of pages hitting it. TextRank is a bit more simplistic than LexRank; although both algorithms are very similar, LexRank applies a heuristic post-processing step to remove sentences with highly duplicitous. The gensim algorithm does a good job at creating both long and short summaries. Another cool feature of gensim is that we can get a list of top keywords chosen by the algorithm. This feature can come in handy for other NLP tasks, where we want to use â€œTextRankâ€ to select words from a document instead of â€œBag of Wordsâ€ or â€œTF-IDFâ€. Gensim also has a well-maintained repository and has an active community which is an added asset to using this algorithm. Sentence Embeddingsï¼ˆå½“æºæ–‡æœ¬æ¯”è¾ƒçŸ­çš„æ—¶å€™ï¼Œæ¯”å¦‚ review æˆ–è€…emailï¼Œ sentence embedding ï¼Œç„¶åŽä½¿ç”¨èšç±»çš„æ–¹å¼ï¼Œå¾—åˆ°ä¸åŒçš„ç°‡ä¹‹åŽï¼Œæ¯ä¸ªç°‡å¯ä»¥é€‰æ‹©ä¸€ä¸ªå¥å­ï¼Œç±»ä¼¼äºŽé™ç»´çš„æ€æƒ³ï¼‰ We wanted to evaluate how text summarization works on shorter documents like reviews, emails etc. We used K-means clustering to summarize the types of documents following the aforementioned structure. Then, all of the sentences in a document are clustered in k = sqrt(length of document) clusters. Each cluster of sentence embeddings can be interpreted as a set of semantically similar sentences whose meaning can be expressed by just one candidate sentence in the summary. Candidate sentences corresponding to each cluster are then ordered to form a summary for an email. The order of the candidate sentences in the summary is determined by the positions of the sentences in their corresponding clusters in the original document. Abstraction techniques Pointer â€” Generator Networks Compared to the sequence-to-sequence-with-attention system, the pointer-generator network does a better job at copying words from the source text. Additionally it also is able to copy out-of-vocabulary words allowing the algorithm to handle unseen words even if the corpus has a smaller vocabulary. Hence we can think of pointer generator as a combination approach combining both extraction (pointing) and abstraction (generating). Drawbacks of Abstractive summarization Firstly, training the model requires a lot of data and hence time. An inherent problem with abstraction is that the summarizer reproduces factual details incorrectly. For instance, if the article talks about Germany beating Argentina 3â€“2, the summarizer may replace 3â€“2 by 2â€“0 Repetition is another problem faced by the summarizer. As we can see in the second example above, some phrases are repeated in the summary To Summarize..Given the architecture of RNNs and the current computing capabilities, we observed that extractive summarization methods are faster, but equally intuitive as abstractive methods. A few other observations: The network fails to focus on the core of the source text and summarizes a less important, secondary piece of information The attention mechanism, by revealing what the network is â€œlooking atâ€, shines some precious light into the black box of neural networks, helping us to debug problems like repetition and copying. To make further advances, we need greater insight into what RNNs are learning from text and how that knowledge is represented. Case Study: Text Summarization on EmailsUnsupervised Text Summarization using Sentence Embeddings Step-1: Email CleaningAs salutation and signature lines (ç§°è°“ç­¾åè¡Œ) can vary from email to email and from one language to the other, removing them will require matching against a regular expression. Hi Jane, Thank you for keeping me updated on this issue. I&apos;m happy to hear that the issue got resolved after all and you can now use the app in its full functionality again. Also many thanks for your suggestions. We hope to improve this feature in the future. In case you experience any further problems with the app, please don&apos;t hesitate to contact me again. Best regards, John Doe Customer Support 1600 Amphitheatre Parkway Mountain View, CA United States Step-2: Language Detection As the emails to be summarized can be of any language, the first thing one needs to do is to determine which language an email is in. I used langdetect for my purpose and it supports 55 different languages. Step-3: Sentence TokenizationOnce the languages identification is performed for every email, we can use this information to split each email into its constituent sentences using specific rules for sentence delimiters (åˆ†éš”ç¬¦) for each language. Step-4: Skip-Thought EncoderWe need a way to generate fixed length vector representations for each sentence in our emails. Step-5: Clusteringï¼ˆå¯¹äºŽ æœ€åŽsummary çš„é•¿åº¦ï¼Œè¿™ä¸ªæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„baselineï¼Œç»™å‡ºäº†ä¸€ä¸ªå®šé‡çš„ç»“æžœï¼Œä½¿ç”¨ $ \sqrt{N}$, N è¡¨ç¤ºåŽŸå§‹æ®µè½æˆ–è€…æ–‡ç« çš„é•¿åº¦ï¼‰The number of clusters will be equal to desired number of sentences in the summary. I chose the numbers of sentences in the summary to be equal to the square root of the total number of sentence in the email. Step-6: SummarizationEach cluster of sentence embeddings can be interpreted as a set of semantically similar sentences whose meaning can be expressed by just one candidate sentence in the summary. The candidate sentence is chosen to be the sentence whose vector representation is closest to the cluster center. Candidate sentences corresponding to each cluster are then ordered to form a summary for an email. PageRank ç®—æ³•å’ŒTextRank ä»‹ç» PageRank ç®—æ³• PageRanké€šè¿‡äº’è”ç½‘ä¸­çš„è¶…é“¾æŽ¥å…³ç³»æ¥ç¡®å®šä¸€ä¸ªç½‘é¡µçš„æŽ’åï¼Œå…¶å…¬å¼æ˜¯é€šè¿‡ä¸€ç§æŠ•ç¥¨çš„æ€æƒ³æ¥è®¾è®¡çš„ã€‚æ•´ä¸ªäº’è”ç½‘å¯ä»¥çœ‹ä½œæ˜¯ä¸€å¼ æœ‰å‘å›¾ï¼Œç½‘é¡µæ˜¯å›¾ä¸­çš„èŠ‚ç‚¹ï¼Œç½‘é¡µä¹‹é—´çš„é“¾æŽ¥å°±æ˜¯å›¾ä¸­çš„è¾¹ã€‚å¦‚æžœç½‘é¡µ A å­˜åœ¨åˆ°ç½‘é¡µ B çš„é“¾æŽ¥ï¼Œé‚£ä¹ˆå°±æœ‰ä¸€æ¡ä»Žç½‘é¡µ A æŒ‡å‘ç½‘é¡µ B çš„æœ‰å‘è¾¹ã€‚æž„é€ å®Œå›¾åŽï¼Œä½¿ç”¨ä¸‹é¢çš„å…¬å¼æ¥è®¡ç®—ç½‘é¡µ$ i$çš„é‡è¦æ€§ï¼ˆPRå€¼ï¼‰ï¼š $$S \left( V _ { i } \right) = ( 1 - d ) + d \cdot \sum _ { j \in I n \left( V _ { i } \right) } \frac { 1 } { \left| O u t \left( V _ { j } \right) \right| } S \left( V _ { j } \right)$$ $d$ æ˜¯é˜»å°¼ç³»æ•°ï¼Œä¸€èˆ¬è®¾ç½®ä¸º0.85. $\operatorname { In } \left( V _ { i } \right)$ æ˜¯æŒ‡å‘ç½‘é¡µ $i$ çš„é“¾æŽ¥çš„ç½‘é¡µé›†åˆã€‚ $\operatorname { Out } \left( V _ { j } \right)$ æ˜¯ç½‘é¡µ $j$ ä¸­çš„é“¾æŽ¥æŒ‡å‘çš„ç½‘é¡µçš„é›†åˆã€‚ $\left| O u t \left( V _ { j } \right) \right|$ æ˜¯é›†åˆä¸­å…ƒç´ çš„ä¸ªæ•°ã€‚ PageRank éœ€è¦å¤šæ¬¡è¿­ä»£æ‰èƒ½å¾—åˆ°æœ€åŽçš„ç»“æžœã€‚ (å…¬å¼çœ‹ç€æ¯”è¾ƒå¤æ‚ï¼Œä½†æ˜¯åŽŸç†éžå¸¸ç®€å•ï¼Œå¦‚æžœè®¡ç®—ç½‘é¡µ içš„ pagerankï¼Œé‚£ä¹ˆå¯¹äºŽæ‰€æœ‰æŒ‡å‘è¯¥ç½‘é¡µçš„ç½‘ç«™é›†åˆï¼Œè¿›è¡Œæƒé‡çš„åˆ†æ‘Šã€‚ä¹Ÿå°±æ˜¯è¯´æŸä¸ªpageranking å¾ˆé«˜çš„ç½‘ç«™æŒ‡å‘äº†æŸä¸ªç½‘ç«™ï¼Œé‚£ä¹ˆè¿™ä¸ªç½‘ç«™çš„pageranking ä¼šå˜é«˜ï¼Œç±»ä¼¼å¸¦æœ‰æƒé‡çš„æŠ•ç¥¨) å‡è®¾æˆ‘ä»¬æœ‰4ä¸ªç½‘é¡µâ€”â€”w1ï¼Œw2ï¼Œw3ï¼Œw4ã€‚è¿™äº›é¡µé¢åŒ…å«æŒ‡å‘å½¼æ­¤çš„é“¾æŽ¥ã€‚æœ‰äº›é¡µé¢å¯èƒ½æ²¡æœ‰é“¾æŽ¥ï¼Œè¿™äº›é¡µé¢è¢«ç§°ä¸ºæ‚¬ç©ºé¡µé¢ã€‚ Webpage Links w1 [w4, 22] w2 [w3, w1] w3 [] w4 [w1] åœ¨æœ¬ä¾‹ä¸­åˆå§‹åŒ–æˆè¿™æ ·ï¼š æœ€åŽï¼Œè¿™ä¸ªçŸ©é˜µä¸­çš„å€¼å°†ä»¥è¿­ä»£çš„æ–¹å¼æ›´æ–°ï¼Œä»¥èŽ·å¾—ç½‘é¡µæŽ’åã€‚ ï¼ˆä¸Šé¢çš„pageranking çš„è®²è§£æ˜¯ä¸ºäº† ä¸‹é¢çš„textranking çš„ç†è§£ï¼‰ TextRank å…³é”®è¯æå– ä¸¤è€…çš„ç›¸ä¼¼ä¹‹å¤„ï¼š In place of web pages, we use sentences Similarity between any two sentences is used as an equivalent to the web page transition probability The similarity scores are stored in a square matrix, similar to the matrix M used for PageRank ä¸åŒä¹‹å¤„åœ¨äºŽåŽè€…ä½¿ç”¨å¥å­ä¹‹é—´çš„ç›¸ä¼¼åº¦ä½œä¸º weights. $W S \left( V _ { i } \right) = ( 1 - d ) + d \cdot \sum _ { V _ { j } \in \operatorname { In } ( V i ) } \frac { w _ { j i } } { \sum _ { V _ { k } \in O u t \left( V _ { j } \right) } w _ { j k } } W S \left( V _ { j } \right)$ $w_{ij}$ å°±æ˜¯å›¾ä¸­èŠ‚ç‚¹ $V_i$ åˆ°$V_j$ çš„è¾¹çš„æƒå€¼ï¼Œ å°±æ˜¯ä¸¤ä¸ªå¥å­ $S_i$ å’Œå¥å­ $S_j$ çš„ç›¸ä¼¼ç¨‹åº¦ã€‚ä¸‹é¢çš„ä»£ç ä¸­ä½¿ç”¨çš„æ˜¯ cosine å‡½æ•°æ¥è¡¨ç¤ºè¿™ç§ç›¸ä¼¼åº¦ã€‚ æ­¥éª¤ï¼š The first step would be to concatenate all the text contained in the articles Then split the text into individual sentences In the next step, we will find vector representation (word embeddings) for each and every sentence Similarities between sentence vectors are then calculated and stored in a matrix The similarity matrix is then converted into a graph, with sentences as vertices and similarity scores as edges, for sentence rank calculation Finally, a certain number of top-ranked sentences form the final summary è¿™é‡Œä½¿ç”¨çš„ cosine similarity scoresï¼Œè®¡ç®—å¥å­ä¹‹é—´çš„ç›¸ä¼¼åº¦ï¼Œå¥å­embedding æ˜¯é€šè¿‡ word embedding ç›¸åŠ è€Œæˆã€‚1234for i in range(len(sentences)): for j in range(len(sentences)): if i != j: sim_mat[i][j] = cosine_similarity(sentence_vectors[i].reshape(1,100), sentence_vectors[j].reshape(1,100))[0,0] Applying PageRank Algorithm123import networkx as nxnx_graph = nx.from_numpy_array(sim_mat)scores = nx.pagerank(nx_graph) TF-IDF å’Œ TextRank å¯¹æ¯”æ€»ç»“ï¼š TextRankä¸ŽTFIDFå‡ä¸¥é‡ä¾èµ–äºŽåˆ†è¯ç»“æžœâ€”â€”å¦‚æžœæŸè¯åœ¨åˆ†è¯æ—¶è¢«åˆ‡åˆ†æˆäº†ä¸¤ä¸ªè¯ï¼Œé‚£ä¹ˆåœ¨åšå…³é”®è¯æå–æ—¶æ— æ³•å°†ä¸¤ä¸ªè¯é»åˆåœ¨ä¸€èµ·ï¼ˆTextRankæœ‰éƒ¨åˆ†é»åˆæ•ˆæžœï¼Œä½†éœ€è¦è¿™ä¸¤ä¸ªè¯å‡ä¸ºå…³é”®è¯ï¼‰ã€‚å› æ­¤æ˜¯å¦æ·»åŠ æ ‡æ³¨å…³é”®è¯è¿›è‡ªå®šä¹‰è¯å…¸ï¼Œå°†ä¼šé€ æˆå‡†ç¡®çŽ‡ã€å¬å›žçŽ‡å¤§ç›¸å¾„åº­ã€‚ TextRankçš„æ•ˆæžœå¹¶ä¸ä¼˜äºŽTFIDFã€‚ TextRankè™½ç„¶è€ƒè™‘åˆ°äº†è¯ä¹‹é—´çš„å…³ç³»ï¼Œä½†æ˜¯ä»ç„¶å€¾å‘äºŽå°†é¢‘ç¹è¯ä½œä¸ºå…³é”®è¯ã€‚ ç”±äºŽTextRankæ¶‰åŠåˆ°æž„å»ºè¯å›¾åŠè¿­ä»£è®¡ç®—ï¼Œæ‰€ä»¥æå–é€Ÿåº¦è¾ƒæ…¢ã€‚ è‡ªç„¶è¯­è¨€å¤„ç†æœ‰ä¸¤ä¸ªåˆ‡å…¥ç‚¹ï¼Œä¸€ä¸ªæ˜¯é¢‘çŽ‡ä¸€ä¸ªæ˜¯è¯­ä¹‰ã€‚ä¸Šè¿°ä¸¤ç§æ–¹æ³•æœ¬è´¨ä¸Šè¿˜æ˜¯åŸºäºŽè¯é¢‘çš„ã€‚å¦‚ä½•è¿›è¡Œæ–¹æ³•çš„è¯„ä»·ï¼Œå¦‚æžœæ˜¯åŸºäºŽæ¦‚çŽ‡ ï¼ˆé¢‘çŽ‡ï¼‰è¿›è¡Œè®¡ç®—ï¼Œé‚£ä¹ˆä¸€ä¸ªåˆ‡å…¥ç‚¹æ˜¯å¦èƒ½å¤Ÿä½“çŽ°ä¸Šä¸‹æ–‡å…³ç³»ï¼Œæ˜¯å¦æœ‰è¯­ä¹‰ä¿¡æ¯ã€‚å¦‚æžœæ˜¯åŸºäºŽç½‘ç»œï¼Œé‚£ä¹ˆä¸€ä¸ªæ–¹æ³•å°±æ˜¯å†…å­˜å’Œè®­ç»ƒæ—¶é—´ä¸Šæ˜¯å¦å¯ä»¥åœ¨å¤§è§„æ¨¡çš„å·¥ä¸šç•Œå±•å¼€ä½¿ç”¨ã€‚ Referenceshttps://medium.com/jatana/unsupervised-text-summarization-using-sentence-embeddings-adb15ce83db1 https://towardsdatascience.com/data-scientists-guide-to-summarization-fc0db952e363 https://www.jiqizhixin.com/articles/2018-12-28-18 https://www.analyticsvidhya.com/blog/2018/11/introduction-text-summarization-textrank-python/ https://xiaosheng.me/2017/04/08/article49/ å¤ä¹ æ€»ç»“ æ–‡æœ¬æ‘˜è¦æœ‰ä¸¤ç§æ–¹æ³•ï¼Œä¸€ç§æ˜¯ä»Žæºå¥å­ä¸­æŠ½å–çš„è¿‡ç¨‹ï¼Œä¸€ç§æ˜¯æ¦‚æ‹¬çš„è¿‡ç¨‹ï¼Œç”Ÿæˆå¯¹äºŽæ–‡ç« æ€»ç»“çš„è¿‡ç¨‹ã€‚ pagerank ç®—æ³•å’Œ textrank ç®—æ³•å¯¹äºŽç®€åŽ†ä¸Šçš„å†…å®¹ç›¸å…³æ€§ä¸å¤§ï¼Œå°±å…ˆä¸å¤ä¹ äº†]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>text-summarization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NLP Papers Reading-Machine Translation]]></title>
    <url>%2F2019%2F06%2F29%2Fnlp-papers-reading-machine-translation%2F</url>
    <content type="text"><![CDATA[ç®€å•ä»‹ç»ä¸€ä¸‹ ç¿»è¯‘ç³»ç»Ÿçš„å‘å±•è¿‡ç¨‹ ç„¶åŽé™„ä¸Šä¸¤ç¯‡è¯¥æ–¹é¢è®ºæ–‡çš„é˜…è¯»ç¬”è®°ï¼Œ å³Sequence to Sequence Learning with Neural Network å’Œ Effective Approaches to Attention-based Neural Machine Translationã€‚ äº”ä¸ªä¸»è¦çš„å‘å±•è¿‡ç¨‹why difficult? Machine translation is challenging given the inherent ambiguity and flexibility of human language. Statistical machine translation replaces classical rule-based systems with models that learn to translate from examples. Neural machine translation models fit a single model rather than a pipeline of fine-tuned models and currently achieve state-of-the-art results. Rule-based Machine Translation Classical machine translation methods often involve rules for converting text in the source language to the target language. The rules are often developed by linguists and may operate at the lexical, syntactic, or semantic level. This focus on rules gives the name to this area of study: Rule-based Machine Translation, or RBMT. The key limitations of the classical machine translation approaches are both the expertise required to develop the rules, and the vast number of rules and exceptions required. Statistical Machine Translation Statistical machine translation, or SMT for short, is the use of statistical models that learn to translate text from a source language to a target language given a large corpus of examples. Given a sentence T in the target language, we seek the sentence S from which the translator produced T. We know that our chance of error is minimized by choosing that sentence S that is most probable given T. Thus, we wish to choose S so as to maximize $P_r(S|T)$. The approach is data-driven, requiring only a corpus of examples with both source and target language text. This means linguists are not longer required to specify the rules of translation. Although effective, statistical machine translation methods suffered from a narrow focus on the phrases being translated , losing the broader nature of the target text. The hard focus on data-driven approaches also meant that methods may have ignored important syntax distinctions known by linguists. Finally, the statistical approaches required careful tuning of each module in the translation pipeline. Neural Machine Translation The key benefit to the approach is that a single system can be trained directly on source and target text, no longer requiring the pipeline of specialized systems used in statistical machine learning. As such, neural machine translation systems are said to be end-to-end systems as only one model is required for the translation. Encoder-Decoder Model Multilayer Perceptron neural network models can be used for machine translation, although the models are limited by a fixed-length input sequence where the output must be the same length. These early models have been greatly improved upon recently through the use of recurrent neural networks organized into an encoder-decoder architecture that allow for variable length input and output sequences. The key to the encoder-decoder architecture is the ability of the model to encode the source text into an internal fixed-length representation called the context vector. Interestingly, once encoded, different decoding systems could be used, in principle, to translate the context into different languages. The power of this model lies in the fact that it can map sequences of different lengths to each other. Encoder-Decoders with Attention Although effective, the Encoder-Decoder architecture has problems with long sequences of text to be translated. The problem stems from the fixed-length internal representation that must be used to decode each word in the output sequence. The solution is the use of an attention mechanism that allows the model to learn where to place attention on the input sequence as each word of the output sequence is decoded. The encoder-decoder recurrent neural network architecture with attention is currently the state-of-the-art on some benchmark problems for machine translation. And this architecture is used in the heart of the Google Neural Machine Translation system, or GNMT, used in their Google Translate service. Although effective, the neural machine translation systems still suffer some issues, such as scaling to larger vocabularies of words and the slow speed of training the models. There are the current areas of focus for large production neural translation systems, such as the Google system. Attention VS LSTM A limitation of the LSTM architecture is that it encodes the input sequence to a fixed length internal representation. This imposes limits on the length of input sequences that can be reasonably learned and results in worse performance for very long input sequences. After reading this, you will know: This (LSTM) is believed to limit the performance of these networks, especially when considering long input sequences, such as very long sentences in text translation problems. Put another way, each item in the output sequence is conditional on selective items in the input sequence. è€Œå¯¹äºŽ Attention è€Œè¨€: Each time the proposed model generates a word in a translation, it (soft-) searches for a set of positions in a source sentence where the most relevant information is concentrated. The model then predicts a target word based on the context vectors associated with these source positions and all the previous generated target words.â€¦ it encodes the input sentence into a sequence of vectors and chooses a subset of these vectors adaptively while decoding the translation. This frees a neural translation model from having to squash all the information of a source sentence, regardless of its length, into a fixed-length vector. And, This (Attention) increases the computational burden of the model, but results in a more targeted and better-performing model. åŒæ ·ï¼Œé™¤äº†åœ¨ machine translation ä¸­æœ‰åº”ç”¨ï¼Œ åœ¨å…¶ä»–é¢†åŸŸå¦‚image description, CNN ä¸­åŒæ ·æœ‰å€Ÿé‰´çš„æ„ä¹‰ã€‚Convolutional neural networks applied to computer vision problems also suffer from similar limitations, where it can be difficult to learn models on very large images. å‚è€ƒæ–‡çŒ® introduction-neural-machine-translationattention-long-short-term-memory-recurrent-neural-networks ä¸¤ç¯‡machine translation è®ºæ–‡ Sequence to Sequence Learning with Neural Network ç ”ç©¶ç›®çš„ï¼šCNNséœ€è¦è¾“å…¥ã€è¾“å‡ºç»´åº¦æ˜¯å·²çŸ¥å’Œå›ºå®šçš„ã€‚è€Œè¯­éŸ³è¯†åˆ«ã€æœºå™¨ç¿»è¯‘ã€é—®ç­”ç³»ç»Ÿç­‰åºåˆ—åˆ°åºåˆ—é—®é¢˜çš„åºåˆ—é•¿åº¦æ˜¯æœªçŸ¥çš„ã€‚CNNæœ‰ä¸€ä¸ªæ˜Žæ˜¾çš„ç¼ºé™·ï¼šCNNåªèƒ½å¤„ç†è¾“å…¥ã€è¾“å‡ºå‘é‡ç»´åº¦æ˜¯å®šé•¿çš„æƒ…å½¢ã€‚å¯¹äºŽè¾“å…¥ã€è¾“å‡ºå¯å˜é•¿çš„æƒ…å†µï¼Œä½¿ç”¨RNN-Recurrent Neural Networkæ›´æ˜“æ±‚è§£ã€‚ è®ºæ–‡è´¡çŒ®ä¹‹ä¸€åœ¨äºŽç½‘ç»œç»“æž„ä¸Šï¼šé€šè¿‡å­¦ä¹ ç¼–ç ä¸€ä¸ªå¯å˜é•¿åº¦çš„åºåˆ—æˆä¸€ä¸ªå›ºå®šé•¿åº¦çš„å‘é‡è¡¨ç¤ºï¼Œè§£ç ä¸€ä¸ªç»™å®šçš„å›ºå®šé•¿åº¦çš„å‘é‡æˆä¸€ä¸ªå¯å˜é•¿åº¦çš„åºåˆ—ã€‚å®žçŽ°çš„æ—¶å€™é¦–å…ˆå°†source sequenceé€šè¿‡ä¸€ä¸ªencode LSTM mapæˆä¸€ä¸ªvectorï¼Œç„¶åŽå†é€šè¿‡å¦ä¸€ä¸ªdecoder LSTMè¿›è¡Œç¿»è¯‘å¾—å‡ºoutputï¼Œè¿™ä¹Ÿæ°æ°æ˜¯image captioné‡Œçš„æ€æƒ³å‘€ï¼ˆé€šè¿‡CNNå°†è¾“å…¥å›¾åƒconvæˆä¸€ä¸ªvectoræˆ–è€…feature mapï¼Œç„¶åŽå†è¾“å…¥LSTMï¼‰ï¼ŒåŽŸæ¥å¤§ä½“æ˜¯è¿™æ ·ï¼ŒæŽ¥ç€çœ‹ã€‚ å¦å¤–è¿˜æœ‰ä¸€ä¸ªå°çš„ç­–ç•¥ï¼šLSTMåœ¨é•¿å¥ç¿»è¯‘ä¸­çš„è¡¨çŽ°ä¹Ÿä¸ä¿—ã€‚è¿™å½’åŠŸäºŽå¯¹æºåºåˆ—ä¸­è¯åºçš„é€†è½¬ã€‚è™½ç„¶LSTMèƒ½å¤ŸåŸºäºŽé•¿æœŸçš„ç›¸å…³æ€§å¤„ç†é—®é¢˜ï¼Œä½†æˆ‘ä»¬å‘çŽ°åœ¨æŠŠåŽŸå¥åºåˆ—é€†è½¬çš„æƒ…å†µä¸‹LSMTèƒ½å­¦ä¹ å¾—æ›´åŠ å‡ºè‰²ã€‚é€†è½¬ä¹‹åŽï¼ŒLSTMæµ‹è¯•çš„å¤æ‚åº¦ä»Ž5.8é™è‡³4.7ï¼Œå¹¶ä¸”åœ¨BLEUä¸Šçš„å¾—åˆ†ä»Ž25.9æå‡è‡³30.6ã€‚ ä¸è¶³ä¹‹å¤„ï¼šå…¶ä»–æ–¹é¢éƒ½æ¯”è¾ƒæ™®é€šï¼Œæˆ–è€…è¯´å¾ˆå¤šè®ºæ–‡ä¸­éƒ½æœ‰æåˆ°è¿‡ï¼Œæ¯”å¦‚LSTMå¯ä»¥è§£å†³vanishingçš„é—®é¢˜ä½†æ²¡æ³•è§£å†³gradient explodingçš„é—®é¢˜ï¼Œå› æ­¤æŽ¡å–gradient cropã€‚æ¨¡åž‹æŽ¡ç”¨äº†SGD without momentumã€‚å®žç”¨çš„LSTMç»“æž„å¼Graveçš„ã€ŠGenerating sequence from RNNã€‹ä¸­çš„LSTMç»“æž„ï¼Œç­‰ç­‰ã€‚ æ€»ç»“ï¼šæ€»ä½“æ¥è¯´ï¼Œè¿™ä¸ªæ¨¡åž‹è¿˜æ˜¯æŽ¡å–äº†è´ªå©ªçš„ç®—æ³•ï¼Œæ¢å¥è¯è¯´ï¼ŒåŽé¢çš„é¢„æµ‹å¯¹å‰é¢çš„çŠ¶æ€æœ‰æžå¼ºçš„ä¾èµ–ï¼Œä¸€æ—¦å‰é¢çš„é¢„æµ‹å‡ºçŽ°é—®é¢˜ï¼ŒåŽé¢çš„é¢„æµ‹å°±ä¸å¯é äº†ï¼Œè¿™ä¹Ÿæ˜¯ä¸€ä¸ªå€¼å¾—æ€è€ƒå’Œæ”¹è¿›çš„åœ°æ–¹ã€‚ Effective Approaches to Attention-based Neural Machine Translation è¿™ç¯‡æ–‡ç« çš„æ ¸å¿ƒåœ¨äºŽ attentionã€‚ Attention çš„ä½œç”¨å¯ä»¥çœ‹ä½œæ˜¯ä¸€ä¸ªå¯¹é½æ¨¡åž‹ï¼Œä¼ ç»Ÿ SMT æˆ‘ä»¬ç”¨ EM ç®—æ³•æ¥æ±‚è§£å¯¹é½ï¼Œè¿™é‡Œåšä¸€ä¸ªéšå¼çš„å¯¹é½ï¼Œå°† alignment model ç”¨ä¸€ä¸ª feedforward neural network å‚æ•°åŒ–ï¼Œå’Œå…¶ä»–éƒ¨åˆ†ä¸€èµ·è®­ç»ƒï¼Œç¥žç»ç½‘ç»œä¼šåŒæ—¶æ¥å­¦ä¹  ç¿»è¯‘æ¨¡åž‹(translation) å’Œ å¯¹é½æ¨¡åž‹(alignment)ã€‚ Attention å¯ä»¥åˆ†æˆ hard and softä¸¤ç§æ¨¡åž‹ï¼Œç®€å•ç†è§£ hard attention å°±æ˜¯ä»Ž source sentence ä¸­æ‰¾åˆ°ä¸€ä¸ªèƒ½äº§ç”Ÿå•è¯ $t^{th}$ å¯¹é½çš„ç‰¹å®šå•è¯ï¼ŒæŠŠ $s_{t,i}$ è®¾ä¸º1ï¼Œå…¶ä»–æ‰€æœ‰å•è¯ç¡¬æ€§çš„è®¤ä¸ºå…¶æ¦‚çŽ‡ä¸º0; soft attention å¯¹äºŽsource sentenceä¸­æ¯ä¸ªå•è¯éƒ½ç»™å‡ºä¸€ä¸ªå¯¹é½æ¦‚çŽ‡ï¼Œå¾—åˆ°ä¸€ä¸ªæ¦‚çŽ‡åˆ†å¸ƒï¼Œcontext vector å°±æ˜¯è¿™äº›æ¦‚çŽ‡åˆ†å¸ƒçš„ä¸€ä¸ªåŠ æƒå’Œï¼Œæ•´ä¸ªæ¨¡åž‹æ˜¯å¹³æ»‘çš„ä¸”å¤„å¤„å¯åˆ†ã€‚ è€Œåœ¨è¯¥ç¯‡è®ºæ–‡ä¸­æå‡ºäº†ä¸€ä¸ªæ–°çš„ attention æœºåˆ¶ local attentionï¼Œåœ¨å¾—åˆ° context vector æ—¶ï¼Œæˆ‘ä»¬ä¸æƒ³çœ‹æ‰€æœ‰çš„ source hidden stateï¼Œè€Œæ˜¯æ¯æ¬¡åªçœ‹ä¸€ä¸ª hidden state çš„å­é›†(subset)ï¼Œè¿™æ ·çš„ attention å…¶å®žæ›´é›†ä¸­ï¼Œä¹Ÿä¼šæœ‰æ›´å¥½çš„ç»“æžœã€‚Global attention å…¶å®žå°±æ˜¯ soft attentionï¼Œ local model å®žé™…ç›¸å½“äºŽ hard å’Œ soft attention çš„ä¸€ä¸ªæ··åˆæˆ–è€…è¯´æŠ˜ä¸­ï¼Œä¸»è¦æ˜¯ç”¨æ¥é™ä½Ž attention çš„èŠ±è´¹ï¼Œç®€å•æ¥è¯´å°±æ˜¯æ¯æ¬¡è®¡ç®—å…ˆç”¨é¢„æµ‹å‡½æ•°å¾—åˆ° source ç›¸å…³ä¿¡æ¯çš„çª—å£ã€‚ soft or hard attention è¿˜æ˜¯ global or local attentionæ˜¯ä»Žä¸åŒçš„è§’åº¦è¿›è¡Œåˆ†ç±»çš„ï¼Œå‰è€…æ˜¯åœ¨æ¦‚çŽ‡åˆ†å¸ƒä¸Šï¼ŒåŽè€…æ˜¯åœ¨ contextä¸Šã€‚ è¿™ä¸ªæ˜¯global attentionï¼š è¿™ä¸ªæ˜¯ local attention æ€»ç»“ ä¸‰ç§ä¸åŒçš„attention ç§ç±» attention åˆ†æˆ hard å’Œsoft ä¸¤ç§æ¨¡å¼ï¼Œç®€å•ç†è§£ hard attention å°±æ˜¯ä»Žsource sentenceä¸­å›½æ‰¾åˆ°ä¸€ä¸ªèƒ½å¤Ÿäº§ç”Ÿ $t^{th}$ çš„ç‰¹å®šå•è¯ï¼ŒæŠŠè¿™ä¸ªå•è¯è®¾ç½®æˆ1ï¼Œå…¶ä»–å•è¯è®¾ç½®æˆ0ï¼›è€Œsoft attention ï¼ˆglobal attentionï¼‰æ˜¯æŠŠsource sentenceä¸­æ¯ä¸ªå•è¯éƒ½ç»™å‡ºä¸€ä¸ªå¯¹é½çš„æ¦‚çŽ‡æ¨¡åž‹ï¼Œå¾—åˆ°ä¸€ä¸ªåˆ†å¸ƒï¼Œç„¶åŽæ•´ä¸ªæ¨¡åž‹æ˜¯å¤„å¤„å¯åˆ†çš„ã€‚è€Œå‰è€…ä¸æ˜¯å¤„å¤„å¯åˆ†çš„ã€‚local attentionæ˜¯ç›¸å¯¹äºŽ global attentionè€Œè¨€çš„ï¼Œä¸æ˜¯å¾—åˆ°ä¸€ä¸ªå…¨å±€çš„attentionï¼Œè€Œæ˜¯å…¨å±€çš„å­é›†ï¼Œè¿™æ ·å¯ä»¥é™ä½Žè®¡ç®—attention çš„èŠ±è´¹ï¼Œå¾—åˆ°ä¸€ä¸ªç›¸å…³ä¿¡æ¯çš„çª—å£ã€‚ nlp ä¸­ä¸€èˆ¬çš„å‘å±•è·¯å¾„: æ˜¾ç¤ºåŸºäºŽ rule-baseï¼Œç„¶åŽæ˜¯åŸºäºŽæ¦‚çŽ‡åˆ†å¸ƒçš„ï¼ŒæŽ¥ç€æ˜¯NNï¼Œ encoder-decoderæ¡†æž¶ï¼Œå¯èƒ½åŠ ä¸Šä¸€äº›å°çš„trick æ¯”å¦‚è¯´attention æœºåˆ¶æ¥å¤„ç†æ¯”è¾ƒé•¿çš„å¥å­ã€‚]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Seq2Seq Translation (English to Chinese)]]></title>
    <url>%2F2019%2F06%2F28%2Fseq2seq-translation-codes%2F</url>
    <content type="text"><![CDATA[åŸºäºŽ tensorflow çš„è‹±æ–‡æ–‡æœ¬çš„é¢„å¤„ç†å’ŒåŸºäºŽ keras çš„ä¸­è‹±æ–‡æœ¬é¢„å¤„ç†ã€‚ä¸»è¦æ˜¯ä»£ç ï¼Œè¾…åŠ©æ³¨é‡Šã€‚é¢„å¤„ç†æ¯”è¾ƒè¯¦ç»†çš„æ­¥éª¤ï¼š unicode to ascii normalize string tokenization (choose one-hot or not) padding (find proper length of tokenization) éœ€è¦é€‰æ‹©ä¸€ä¸ªæ¡†æž¶ tensorflow or keras åŽ»å®žçŽ°ã€‚å¤§é‡æ•°æ®å»ºè®®é€‰æ‹© tensorflowï¼Œå°æ¨¡åž‹ä½¿ç”¨ keras å°±è¡Œã€‚ çƒ­èº«Text data typically requires some cleanup before it can be embedded in vector space and fed to a machine learning model. Remove tags. For example, â€œ&lt;i>Hello&lt;/i> &lt;b>World&lt;/b>!â€ is converted to â€œHello World!â€ Remove repeating whitespace characters (spaces, tabs, line breaks). Convert tabs and line breaks to spaces. Remove stopwords. These include the most commonly occurring words in a language, like â€œthe,â€ â€œon,â€ â€œis,â€ etc. NLP libraries like gensim provide a default list of stopwords. Convert all text to lowercase. Perform Porter stemming. Porter stemming reduces inflections like â€œfishing,â€ â€œfished,â€ and â€œfisherâ€ to the root â€œfish.â€ This makes it easier for an ML model to learn how to glean meaning or intent form a sequence of words. è°ƒç”¨ gensim æ¡†æž¶å®žçŽ°é¢„å¤„ç†ï¼š 12345678from gensim.parsing.preprocessing import preprocess_string, strip_tags, strip_multiple_whitespaces, remove_stopwords, stem_textcustom_filters = [strip_tags, strip_multiple_whitespaces, remove_stopwords, stem_text]# ç”Ÿæˆå™¨å‡½æ•°def get_tokenized_questions(X): series = pd.Series(pd.concat([X['question1'], X['question2']]),dtype=str) series.dropna() for question in series: yield preprocess_string(question, custom_filters) All by yourself: å°†è‹±æ–‡ punctuation characters å’Œå­—æ¯ä»¥ç©ºæ ¼éš”å¼€ã€‚ è¾“å…¥ï¼š s = &apos;bla. bla? bla.bla! bla...&apos; è¾“å‡ºï¼š bla . bla ? bla . bla ! bla . . . python2 ç‰ˆæœ¬ï¼ŒåŸºäºŽåº“å‡½æ•° re å®žçŽ°ã€‚ 1234567891011s = 'bla. bla? bla.bla! bla...'import re# è¿™ä¸ªç¬¦å·æ˜¯å¯ä»¥é€‰æ‹©çš„s = re.sub('([.,!?()])', r' \1 ', s) # use a regular expression to match the punctuation characters you are interested and surround them by spaces,s = re.sub('\s&#123;2,&#125;', ' ', s) # use a second step to collapse multiple spaces anywhere in the document:print(s)# replacing everything with space except (a-z, A-Z, ".", "?", "!", ",")w = re.sub(r"[^a-zA-Z?.!,Â¿]+", " ", w)w = w.rstrip().strip()w = '&lt;start&gt; ' + w + ' &lt;end&gt;' # è¿™ä¸ªæ˜¯å¯é€‰çš„ï¼Œåœ¨é¦–å°¾åŠ ä¸Š 'start' or 'end' python3 ç‰ˆæœ¬ï¼ŒåŸºäºŽ translateå®žçŽ°ã€‚ 123# åœ¨python3 ä¸­å¯ä»¥ä½¿ç”¨ translate() è¿™ä¸ªæ–¹æ³•import stringtext = text.translate(str.maketrans(&#123;key: " &#123;0&#125; ".format(key) for key in string.punctuation&#125;)) tensorflow text preprocessingåŸºäºŽ tensorflow çš„æ–‡æœ¬é¢„å¤„ç†ï¼Œ é€‚åˆå¤§é‡æ•°æ®ï¼Œå¯ä»¥ä½¿ç”¨batch è¾“å…¥åˆ°æ¨¡åž‹ä¸­åŽ»ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import tensorflow as tfimport numpy as npimport unicodedataimport reraw_data = ( ('What a ridiculous concept!', 'Quel concept ridicule !'), ('Your idea is not entirely crazy.', "Votre idÃ©e n'est pas complÃ¨tement folle."), ("A man's worth lies in what he is.", "La valeur d'un homme rÃ©side dans ce qu'il est."), ('What he did is very wrong.', "Ce qu'il a fait est trÃ¨s mal."), ("All three of you need to do that.", "Vous avez besoin de faire cela, tous les trois."), ("Are you giving me another chance?", "Me donnez-vous une autre chance ?"), ("Both Tom and Mary work as models.", "Tom et Mary travaillent tous les deux comme mannequins."), ("Can I have a few minutes, please?", "Puis-je avoir quelques minutes, je vous prie ?"), ("Could you close the door, please?", "Pourriez-vous fermer la porte, s'il vous plaÃ®t ?"), ("Did you plant pumpkins this year?", "Cette annÃ©e, avez-vous plantÃ© des citrouilles ?"), ("Do you ever study in the library?", "Est-ce que vous Ã©tudiez Ã  la bibliothÃ¨que des fois ?"), ("Don't be deceived by appearances.", "Ne vous laissez pas abuser par les apparences."), ("Excuse me. Can you speak English?", "Je vous prie de m'excuser ! Savez-vous parler anglais ?"), ("Few people know the true meaning.", "Peu de gens savent ce que cela veut rÃ©ellement dire."), ("Germany produced many scientists.", "L'Allemagne a produit beaucoup de scientifiques."), ("Guess whose birthday it is today.", "Devine de qui c'est l'anniversaire, aujourd'hui !"), ("He acted like he owned the place.", "Il s'est comportÃ© comme s'il possÃ©dait l'endroit."), ("Honesty will pay in the long run.", "L'honnÃªtetÃ© paye Ã  la longue."), ("How do we know this isn't a trap?", "Comment savez-vous qu'il ne s'agit pas d'un piÃ¨ge ?"), ("I can't believe you're giving up.", "Je n'arrive pas Ã  croire que vous abandonniez."),)# convert the unicode file to ascii, ä¸»è¦æ˜¯ç»Ÿä¸€ç¼–ç æ–¹å¼ï¼Œç„¶åŽåŽ»é™¤ é‡éŸ³ç¬¦å·def unicode_to_ascii(s): return ''.join( c for c in unicodedata.normalize('NFD', s) # UCDæ˜¯Unicodeå­—ç¬¦æ•°æ®åº“ï¼ˆUnicode Character DataBaseï¼‰çš„ç¼©å†™ã€‚ if unicodedata.category(c) != 'Mn') # åŽ»é™¤ é‡éŸ³ç¬¦å·# ç±»ä¼¼äºŽçƒ­èº«ä¸­çš„åŠŸèƒ½def normalize_string(s): s = unicode_to_ascii(s) s = re.sub(r'([!.?])', r' \1', s) # å¦‚æžœæ˜¯è¿™ä¸‰ä¸ªç¬¦å·ï¼Œé‚£ä¹ˆæ˜¯éœ€è¦å‰é¢åŠ ä¸Šä¸€ä¸ªç©ºæ ¼ s = re.sub(r'[^a-zA-Z.!?]+', r' ', s) # é™¤åŽ»ä¸æ˜¯è¿™äº›ç¬¦å·çš„å­—ç¬¦ s = re.sub(r'\s+', r' ', s) # å‡ºçŽ°å¤šä¸ªç©ºæ ¼ï¼Œå°±åŽ»é™¤ç›´åˆ°1ä¸ª return sraw_data_en, raw_data_fr = list(zip(*raw_data)) # å˜é‡åç§°å‰åŠ  *ï¼Œè¡¨ç¤ºä¼ å…¥çš„æ˜¯ä¸€ä¸ªå…ƒç»„ï¼Œä¸¤ä¸ªæ˜Ÿå·è¡¨ç¤ºæ˜¯ä¸€ä¸ªdictionary# ä»Žè¿è¡Œçš„ç»“æžœçœ‹ï¼Œç”±åŽŸæ¥çš„ tuple of tuple å˜æˆäº†ä¸¤ä¸ªstring of tupleï¼Œå¹¶æ²¡æœ‰list ä»€ä¹ˆäº‹æƒ…raw_data_en, raw_data_fr = list(raw_data_en), list(raw_data_fr) # from tuple to list è¿™ä¸ªæ˜¯è½¬æ¢äº†raw_data_en = [normalize_string(data) for data in raw_data_en]# è¿™ä¸ªæ˜¯decoderçš„è¾“å…¥ï¼Œdecoder æ˜¯æœ‰ä¸¤ä¸ªè¾“å…¥çš„ï¼Œä¸€ä¸ªæ˜¯encoderçš„è¾“å‡ºï¼Œä¸€ä¸ªæ˜¯ å…¶ä¸­ä¸€ä¸ªstart destination sentenceï¼Œ æœ€åŽæ˜¯ä¸€ä¸ª end# æ˜¯ç”¨æ¥è®¡ç®— lossçš„raw_data_fr_in = ['&lt;start&gt; ' + normalize_string(data) for data in raw_data_fr]raw_data_fr_out = [normalize_string(data) + ' &lt;end&gt;' for data in raw_data_fr] # è¿™ç§æ“ä½œæ¯”è¾ƒç®€æ´å“ˆen_tokenizer = tf.keras.preprocessing.text.Tokenizer(filters='')# é»˜è®¤æ˜¯ä¼šæŠŠ ? . or ! åŽ»æŽ‰, å› ä¸ºæˆ‘ä»¬ä¸æƒ³è®©å…¶ filter æŽ‰ ä¸Šè¿°ä¸‰ä¸ªå­—ç¬¦ï¼Œæ‰€æœ‰è‡ªå·±è¿›è¡Œäº†å¤„ç†en_tokenizer.fit_on_texts(raw_data_en)data_en = en_tokenizer.texts_to_sequences(raw_data_en)# è¿™ä¸ªpadding æ˜¯ä¸ºäº†ä¹‹åŽåˆ›å»º tf.data.Dataset object ä½¿ç”¨çš„ï¼Œæ‰€ä»¥è¿˜æ˜¯æ¯”è¾ƒniceçš„data_en = tf.keras.preprocessing.sequence.pad_sequences(data_en, padding='post')fr_tokenizer = tf.keras.preprocessing.text.Tokenizer(filters='')# éƒ½æ˜¯å…ˆä½¿ç”¨ fit_on_texts() ç„¶åŽæ‰ä½¿ç”¨ texts_to_sequence() ï¼Œå‰è€…ç›¸å½“äºŽè®­ç»ƒï¼ŒåŽè€…æ˜¯è¾“å‡ºçš„ç»“æžœï¼Œæˆ‘çš„ç†è§£# A mid-way notice though, we can call fit_on_texts multiple times on different corpora and it will update vocabulary automatically.fr_tokenizer.fit_on_texts(raw_data_fr_in)fr_tokenizer.fit_on_texts(raw_data_fr_out)data_fr_in = fr_tokenizer.texts_to_sequences(raw_data_fr_in)data_fr_in = tf.keras.preprocessing.sequence.pad_sequences(data_fr_in, padding='post')data_fr_out = fr_tokenizer.texts_to_sequences(raw_data_fr_out)data_fr_out = tf.keras.preprocessing.sequence.pad_sequences(data_fr_out, padding='post') in additionï¼š 1234567891011121314# çœŸæ­£åœ¨åšå®žéªŒçš„æ—¶å€™éœ€è¦æ³¨æ„çš„äº‹æƒ…ï¼š# ä¸€ç§å¸¸è§çš„æ‰‹æ®µå°±æ˜¯ limit the size of the dataset to experiment faster (optimal)# ä½¿ç”¨tensorflow ä¸­çš„dataset çš„æ—¶å€™ï¼Œæœ‰æ„è¯†çš„ shuffle() æ•°æ®é›† å¹¶ä¸”ä½¿ç”¨batch çš„æ€æƒ³dataset = tf.data.Dataset.from_tensor_slices((input_tensor_train, target_tensor_train)).shuffle(BUFFER_SIZE)dataset = dataset.batch(BATCH_SIZE, drop_remainder=True)# è¿™ä¸ªå’Œä¸Šé¢çš„è¯­å¥æ˜¯æ­é…ä½¿ç”¨çš„example_input_batch, example_target_batch = next(iter(dataset))example_input_batch.shape, example_target_batch.shape# å°±æ˜¯åœ¨çœŸæ­£çš„å®žéªŒçš„è¿‡ç¨‹ä¸­ï¼Œ ç½‘ç»œä¸­çš„shape (batch_size, embedding_size, )# è¶…çº§å¸¸ç”¨çš„å¤„ç†çš„æ‰‹æ®µï¼Œ preprocess_sentence() æ˜¯ä¸€ä¸ªå‡½æ•°, apply(lambda )data["eng"] = data.eng.apply(lambda w: preprocess_sentence(w))data["es"] = data.es.apply(lambda w: preprocess_sentence(w)) keras text preprocessingè¿™ä¸ªç‰ˆæœ¬çš„ä»£ç é€‚ç”¨äºŽå°çš„æ•°æ®é‡ï¼Œå› ä¸ºå½“æ•°æ®é‡è¾¾åˆ°ç™¾ä¸‡çš„æ—¶å€™ï¼Œåº”è¯¥ä½¿ç”¨batch åŽ»è®­ç»ƒæ¨¡åž‹ï¼Œä¸åº”ä¸€ä¸‹å­è¯»å…¥åˆ°å†…å­˜ä¸­ï¼Œå®¹æ˜“çˆ†å†…å­˜ã€‚æ¯”è¾ƒæœ‰ç‰¹ç‚¹çš„ filter ä¸­æ–‡çš„å­—ç¬¦ä½¿ç”¨translate è¿›è¡Œå¤„ç†ã€‚ä¸€èˆ¬ä»Žç»éªŒä¸Šè®²æ˜¯ä¸å»ºè®® filter æŽ‰ â€œï¼Ÿã€‚ï¼Œâ€ è¿™ä¸‰ä¸ªä¸­æ–‡å­—ç¬¦çš„ï¼Œå…¶ä»–çš„å¯ä»¥filter æŽ‰ï¼Œå¯¹åº”è‹±æ–‡ä¸­çš„ â€œ? , .â€ è¿™ä¸‰ä¸ªå­—ç¬¦ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import stringimport refrom numpy import array, argmax, random, takeimport pandas as pdfrom keras.models import Sequentialfrom keras.layers import Dense, LSTM, Embedding, Bidirectional, RepeatVector, TimeDistributedfrom keras.preprocessing.text import Tokenizerfrom keras.callbacks import ModelCheckpointfrom keras.preprocessing.sequence import pad_sequencesfrom keras.models import load_modelfrom keras import optimizersimport matplotlib.pyplot as pltfrom sklearn.model_selection import train_test_splitimport numpy as npdef read_text(filename): # open the file file = open(filename, mode='rt', encoding='utf-8') # read all text text = file.read() file.close() return textdef to_lines(text): sents = text.strip().split('\n') sents = [i.split('\t') for i in sents] return sentsdef to_array(path, debug): data =read_text(path) import gc eng_ch =to_lines(data) del data gc.collect() #import ipdb #ipdb.set_trace() eng_ch =np.asarray(eng_ch) # max memory #eng_ch =np.asarray(eng_ch[:5000000]) if debug: #eng_ch =eng_ch[:4, :]# just for chinese dict test eng_ch =eng_ch[:2000, :] return eng_chdef pre_process(eng_ch): import jieba cn_punctuation = "ï¼ï¼Ÿï½¡ ï¼Ÿã€‚? ï¼ƒï¼„ï¼…ï¼† !ï¼ˆï¼‰. ï¼Šï¼‹ï¼ï¼ï¼šï¼›ï¼œï¼ï¼žï¼ ï¼»ï¼¼ï¼½ï¼¾ï¼¿ï½€ï½›ï½œï½ï½žï½Ÿï½ ï½¢ï½£ï½¤ã€ã€ƒã€‹ã€Œã€ã€Žã€ã€ã€‘ã€”ã€•ã€–ã€—ã€˜ã€™ã€šã€›ã€œã€ã€žã€Ÿã€°ã€¾ ã€¿â€“â€”â€˜ â€™ â€› â€œ â€ â€ž â€Ÿ â€¦â€§ï¹" eng_ch[:, 0] = [s.translate(str.maketrans('', '', string.punctuation)) for s in eng_ch[:, 0]] eng_ch[:, 1] = [s.translate(str.maketrans('', '', cn_punctuation)) for s in eng_ch[:, 1]] for i in range(len(eng_ch)): eng_ch[i, 0] =eng_ch[i, 0].lower() for i in range(len(eng_ch)): seg_list =jieba.cut(eng_ch[i, 1]) eng_ch[i, 1] =' '.join(seg_list) return eng_chdef sentence_length(eng_ch): eng_l =[] ch_l =[] # è¿™é‡Œéœ€è¦çœ‹ä¸€ä¸‹ englishçš„æ•°æ®æ˜¯å¦å‰åŽæœ‰ ç©ºæ ¼ for i in eng_ch[:, 0]: eng_l.append(len(i.split())) for i in eng_ch[:,1]: ch_l.append(len(i)) length_df =pd.DataFrame(&#123;'eng': eng_l, 'ch':ch_l&#125;) length_df.hist(bins =50) plt.savefig('data-dist-cn.png')def tokenization(lines): tokenizer = Tokenizer() tokenizer.fit_on_texts(lines) return tokenizerdef encode_sequences(tokenizer, length, lines): seq =tokenizer.texts_to_sequences(lines) seq = pad_sequences(seq, maxlen=length, padding='post') return seq]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>seq2seq</tag>
        <tag>translation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bairong]]></title>
    <url>%2F2019%2F06%2F27%2Fbairong%2F</url>
    <content type="text"><![CDATA[æ€»ç»“åœ¨ç™¾èžçš„å®žä¹ ç»åŽ†ã€‚ä¾§é‡å­¦åˆ°çš„ä¸œè¥¿ã€‚ å¦‚æžœéœ€è¦æ‰“ä¸Štagï¼Œé‚£ä¹ˆå°±æ˜¯â€œæœºå™¨å­¦ä¹ + é‡‘èž+ é£ŽæŽ§â€ã€‚ é‡‘èžæ–¹é¢æœ¯è¯­æ•´ä¸ªé£ŽæŽ§æ˜¯åˆ†æˆä¸‰ä¸ªé˜¶æ®µï¼šè¦ä¸è¦æ”¾è´·ï¼Œé¢åº¦ç­–ç•¥å’Œå®šä»·ç­–ç•¥ã€‚ é£ŽæŽ§çš„é‡è¦æ€§ï¼šå› ä¸ºå¤§éƒ¨åˆ†çš„å¹³å°éƒ½æ˜¯é é«˜åˆ©çŽ‡æ¥è¦†ç›–é«˜é£Žé™©ï¼Œè‡ªå·±æœ¬èº«æ²¡æœ‰åšå¥½è¶³å¤Ÿçš„é£Žé™©æŽ§åˆ¶ã€‚ä½†ä»Žä»Šå¾€åŽï¼Œå“ªä¸ªå¹³å°çš„é£ŽæŽ§èƒ½å¤Ÿåšçš„å¥½ï¼Œå°±èƒ½åœ¨é•¿å‘¨æœŸä¸¥ç›‘ç®¡çš„å‰æä¸‹ç”Ÿå­˜ä¸‹åŽ»ï¼Œè€Œä¸èƒ½ä»…ä»…ä¾é é«˜åˆ©çŽ‡äº†ã€‚ é¢åº¦ç­–ç•¥ ç›®æ ‡ï¼šé‡‘é¢åè´¦çŽ‡å°äºŽè´¦æˆ·åè´¦çŽ‡ã€‚å¦‚ä½•å®žçŽ°ä¸Šè¿°çš„ç›®æ ‡å‘¢ï¼Ÿæ€»çš„ç­–ç•¥æ˜¯å¯¹äºŽç”¨æˆ·ä¿¡ç”¨è¯„åˆ†è¿›è¡ŒæŽ’åºï¼Œç»™é«˜é£Žé™©çš„äººä½Žé¢åº¦ï¼Œåä¹‹æˆç«‹ã€‚ æ¨¡åž‹ä»Žç†è®ºä¸Šè®²ï¼Œæ˜¯å­˜åœ¨æžç«¯æœ€ä¼˜è§£çš„ï¼Œä½†æ˜¯åœ¨å®žé™…ä¸­å¾€å¾€ä¸æ˜¯è¿™æ ·åšçš„ã€‚æ¯”è¾ƒå¸¸è§çš„æ¨¡åž‹ï¼š çº¿æ€§æ¨¡åž‹ï¼šç†è®ºä¸Šåˆ†å¾—è¶Šç»†ï¼Œæ•ˆæžœæ˜¯è¶Šå¥½ã€‚ æ¯”è¾ƒå…‰æ»‘çš„æŒ‡æ•°æ¨¡åž‹ å¹‚å‡½æ•° sigmoid å‡½æ•°ï¼š sigmoid å‡½æ•°å½¢çŠ¶æ˜¯ç”±ä¸¤ä¸ªå‚æ•°è¿›è¡ŒæŽ§åˆ¶çš„ã€‚ å¯ä»¥ä½¿ç”¨sigmoid å‡½æ•°è¿‘ä¼¼çš„åŽ»ä¸æ–­çš„æŽ¥è¿‘æœ€ä¼˜è§£ã€‚æœ€ä¼˜æ¨¡åž‹çš„å½¢çŠ¶ä¸€éƒ¨åˆ†æ˜¯minï¼Œä¸€éƒ¨åˆ†æ˜¯ maxï¼Œä¸­é—´çš„æ–œçŽ‡æ¯”è¾ƒå¤§ã€‚ï¼ˆå’Œsigmoid çš„å½¢çŠ¶æ˜¯æ¯”è¾ƒåƒï¼‰ ä¸Šé¢ä½¿ç”¨çš„æ˜¯ä¸ªäººçš„ä¿¡ç”¨è¯„åˆ†ï¼Œå¾—åˆ°æ˜¯ä¸€ä¸ªåŸºç¡€é¢åº¦ã€‚æœ€åŽçš„é¢åº¦è¿˜éœ€è¦è€ƒè™‘ä¸ªäººèµ„è´¨ç­‰ä¸€ç³»åˆ—çš„å› ç´ ã€‚ å®šä»·ç­–ç•¥ è¿™é‡Œçš„å®šä»·æ˜¯åˆ©çŽ‡çš„å®šä»·ï¼Œè¿˜æ¬¾åˆ©çŽ‡çš„é«˜ä½Žã€‚ä¸»è¦è¦æä¾›å·®å¼‚åŒ–å®šä»·ç­–ç•¥ã€‚åœ¨è¿™ä¸ªè®¨è®ºä¸­æåˆ°ä¸€ä¸ªä¸“ä¸šçš„åè¯ï¼Œè´´æ°´ã€‚ä½ å¾—åˆ°çš„åˆ©çŽ‡æ˜¯åŒ…å«ä½ çš„é£Žé™©ã€‚åŸºæœ¬çš„åŽŸåˆ™ï¼Œé£Žé™©è¶Šé«˜ï¼Œåˆ©çŽ‡è¶Šé«˜ã€‚ å¦‚ä½•æ”¶ç›Šçš„å¢žåŠ ï¼Ÿå›žåŽ»å€Ÿè´·é«˜é£Žé™©ï¼Œå¯¹äºŽåˆ©çŽ‡ä¸å¤ªæ•æ„Ÿï¼Œé€‚å½“å¢žåŠ çš„åˆ©çŽ‡æˆ–è€…è´´æ°´ã€‚å¯¹äºŽèµ„è´¨æ¯”è¾ƒå¥½çš„ï¼Œå¯¹äºŽåˆ©çŽ‡æ¯”è¾ƒæ•æ„Ÿï¼Œé‚£ä¹ˆç»´æŒè¾ƒä½Žçš„åˆ©çŽ‡ã€‚åœ¨é«˜é£Žé™©äººç¾¤å¾—åˆ°æ”¶ç›Šã€‚ è¯„åˆ†æ¨¡åž‹ åˆ†æˆè´·å‰ã€è´·ä¸­å’Œè´·åŽä¸‰ä¸ªé˜¶æ®µã€‚ KS æ›²çº¿å¯¹äºŽé¢„æµ‹èƒ½åŠ›æŒ‡æ ‡ï¼šROC/ AUC, K-SæŒ‡æ ‡ å’ŒGINIç³»æ•°ã€‚ KS(Kolmogorov-Smirnov)ï¼šKSç”¨äºŽæ¨¡åž‹é£Žé™©åŒºåˆ†èƒ½åŠ›è¿›è¡Œè¯„ä¼°ï¼Œ æŒ‡æ ‡è¡¡é‡çš„æ˜¯å¥½åæ ·æœ¬ç´¯è®¡éƒ¨åˆ†ä¹‹é—´çš„å·®å€¼ã€‚å¥½åæ ·æœ¬ç´¯è®¡å·®å¼‚è¶Šå¤§ï¼ŒKSæŒ‡æ ‡è¶Šå¤§ï¼Œé‚£ä¹ˆæ¨¡åž‹çš„é£Žé™©åŒºåˆ†èƒ½åŠ›è¶Šå¼ºã€‚æ•°å­¦è¡¨è¾¾å¼ä¸ºï¼š $K-S = max( TPR- FPR)$ã€‚ KSå€¼çš„å–å€¼èŒƒå›´æ˜¯ $[0, 1]$ã€‚ ä¸‹é¢æ˜¯å›¾è§£ã€‚ è®¡ç®—æ­¥éª¤ è®¡ç®—æ¯ä¸ªè¯„åˆ†åŒºé—´çš„å¥½åè´¦æˆ·æ•°ã€‚ è®¡ç®—æ¯ä¸ªè¯„åˆ†åŒºé—´çš„ç´¯è®¡å¥½è´¦æˆ·æ•°å æ€»å¥½è´¦æˆ·æ•°æ¯”çŽ‡(good%)å’Œç´¯è®¡åè´¦æˆ·æ•°å æ€»åè´¦æˆ·æ•°æ¯”çŽ‡(bad%)ã€‚ è®¡ç®—æ¯ä¸ªè¯„åˆ†åŒºé—´ç´¯è®¡åè´¦æˆ·å æ¯”ä¸Žç´¯è®¡å¥½è´¦æˆ·å æ¯”å·®çš„ç»å¯¹å€¼ï¼ˆç´¯è®¡good%-ç´¯è®¡bad%ï¼‰ï¼Œç„¶åŽå¯¹è¿™äº›ç»å¯¹å€¼å–æœ€å¤§å€¼å³å¾—æ­¤è¯„åˆ†å¡çš„K-Så€¼ã€‚ åœ¨å®Œæˆä¸€ä¸ªæ¨¡åž‹åŽï¼Œå°†æµ‹è¯•æ¨¡åž‹çš„æ ·æœ¬å¹³å‡åˆ†æˆ10ç»„ï¼Œä»¥å¥½æ ·æœ¬å æ¯”é™åºä»Žå·¦åˆ°å³è¿›è¡ŒæŽ’åˆ—ï¼Œå…¶ä¸­ç¬¬ä¸€ç»„çš„å¥½æ ·æœ¬å æ¯”æœ€å¤§ï¼Œåæ ·æœ¬å æ¯”æœ€å°ã€‚è¿™äº›ç»„åˆ«çš„å¥½åæ ·æœ¬å æ¯”è¿›è¡Œç´¯åŠ åŽå¾—åˆ°æ¯ä¸€ç»„å¯¹åº”çš„ç´¯è®¡çš„å æ¯”ã€‚å¥½åæ ·æœ¬çš„ç´¯è®¡å æ¯”éšç€æ ·æœ¬çš„ç´¯è®¡è€Œå˜åŒ–ï¼ˆå›¾ä¸­Good/Badä¸¤æ¡æ›²çº¿ï¼‰ï¼Œè€Œä¸¤è€…å·®å¼‚æœ€å¤§æ—¶å°±æ˜¯æˆ‘ä»¬è¦æ±‚çš„K-Så€¼ï¼ˆå›¾ä¸­æ¯”è¾ƒé•¿çš„ç›´çº¿ç®­å¤´çš„é‚£ä¸ªä½ç½®ï¼‰ã€‚ è¿™ä¸¤æ¡æ›²çº¿ä¹‹é—´çš„å·®å€¼ï¼Œå°±æ˜¯K-Sæ›²çº¿ã€‚å¦‚å›¾1æ‰€ç¤ºï¼Œç»™å®šä¸€ä¸ªé€šè¿‡çŽ‡20%ï¼ˆæ‹’ç»çŽ‡80%ï¼‰ï¼Œåˆ™è¯¥æ¨¡åž‹å¯ä»¥æŒ‘å‡ºæ¥60%çš„å¥½äººï¼ŒåŒæ—¶æ¼è¿›æ¥8%çš„åäººï¼ˆ92%çš„åäººéƒ½è¢«æ‹’ç»æŽ‰äº†ï¼‰ã€‚é‚£ä¹ˆK-Sæ›²çº¿åœ¨è¿™ä¸ªé€šè¿‡çŽ‡ä¸Šçš„å€¼ï¼Œå°±æ˜¯60%-8%=0.52ã€‚(å¥½å¥½çœ‹ï¼Œè¿™ä¸ªåæ ‡çš„å¯¹åº”å…³ç³») K-Sæ›²çº¿ä¸»è¦æ˜¯éªŒè¯æ¨¡åž‹çš„åŒºåˆ†èƒ½åŠ›ï¼Œé€šå¸¸æ˜¯åœ¨æ¨¡åž‹é¢„æµ‹å…¨ä½“æ ·æœ¬çš„ä¿¡ç”¨è¯„åˆ†åŽï¼Œå°†å…¨ä½“æ ·æœ¬æŒ‰è¿çº¦ä¸Žéžè¿çº¦åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œç„¶åŽç”¨K-Sç»Ÿè®¡é‡æ¥æ£€éªŒè¿™ä¸¤ç»„æ ·æœ¬ä¿¡ç”¨è¯„åˆ†çš„åˆ†å¸ƒæ˜¯å¦æœ‰æ˜¾è‘—å·®å¼‚ã€‚é€‰æ‹©æœ€å¤§é—´éš”å¯¹äºŽçš„æ¨ªè½´æ¦‚çŽ‡é˜ˆå€¼ä¸ºæœ€ä½³æ¦‚çŽ‡é˜ˆå€¼ã€‚ KSå€¼ å«ä¹‰ $&gt; 0.3$ æ¨¡åž‹é¢„æµ‹æ€§è¾ƒå¥½ $0.2 \sim 0.3 $ æ¨¡åž‹å¯ç”¨ $0 \sim 0.2$ æ¨¡åž‹é¢„æµ‹èƒ½åŠ›è¾ƒå·® $&lt; 0$ æ¨¡åž‹é”™è¯¯ K-Så€¼ä¸€èˆ¬æ˜¯å¾ˆéš¾è¾¾åˆ°0.6çš„ï¼Œåœ¨0.2~0.6ä¹‹é—´éƒ½ä¸é”™ã€‚ä¸€èˆ¬å¦‚æžœæ˜¯å¦‚æžœè´Ÿæ ·æœ¬å¯¹ä¸šåŠ¡å½±å“æžå¤§ï¼Œé‚£ä¹ˆåŒºåˆ†åº¦è‚¯å®šå°±å¾ˆé‡è¦ï¼Œæ­¤æ—¶K-Sæ¯”AUCæ›´åˆé€‚ç”¨ä½œæ¨¡åž‹è¯„ä¼°ï¼Œå¦‚æžœæ²¡ä»€ä¹ˆç‰¹åˆ«çš„å½±å“ï¼Œé‚£ä¹ˆç”¨AUCå°±å¾ˆå¥½äº†ã€‚ K-S å€¼è¶Šå¤§ï¼Œè¡¨æ˜Žåˆ†ç±»å™¨å¯¹æ­£ è´Ÿç±»çš„åŒºåˆ†èƒ½åŠ›è¶Šå¥½ã€‚å¹¶éžæ‰€æœ‰çš„æƒ…å†µKSéƒ½æ˜¯è¶Šé«˜è¶Šå¥½çš„ï¼Œå°¤å…¶åœ¨å¾ä¿¡æ¨¡åž‹ä¸­ã€‚å¾ä¿¡æ¨¡åž‹ä¸­ï¼Œæœ€æœŸæœ›å¾—åˆ°çš„ä¿¡ç”¨åˆ†æ•°åˆ†å¸ƒæ˜¯æ­£æ€åˆ†å¸ƒï¼Œå¯¹äºŽæ­£è´Ÿæ ·æœ¬åˆ†åˆ«è€Œè¨€ï¼Œä¹Ÿéƒ½æœŸæœ›æ˜¯å‘ˆæ­£æ€åˆ†å¸ƒçš„æ ·å­ã€‚å¦‚æžœKSå€¼è¿‡å¤§ï¼Œä¸€èˆ¬è¶…è¿‡0.9ï¼Œå°±å¯ä»¥è®¤ä¸ºæ­£è´Ÿæ ·æœ¬åˆ†å¾—è¿‡å¼€äº†ï¼Œä¸å¤ªå¯èƒ½æ˜¯æ­£æ€åˆ†å¸ƒçš„ï¼Œåè€Œæ˜¯æ¯”è¾ƒæžç«¯åŒ–çš„åˆ†å¸ƒçŠ¶æ€ï¼ˆUå­—å½¢ï¼Œä¸¤è¾¹å¤šï¼Œä¸­é—´å°‘ï¼‰ï¼Œè¿™æ ·çš„åˆ†æ•°å°±å¾ˆä¸å¥½ï¼ŒåŸºæœ¬å¯ä»¥è®¤ä¸ºä¸å¯ç”¨ã€‚ä½†å¦‚æžœæ¨¡åž‹çš„ç›®çš„å°±æ˜¯å®Œç¾ŽåŒºåˆ†æ­£è´Ÿæ ·æœ¬ï¼Œé‚£ä¹ˆKSå€¼è¶Šå¤§å°±è¡¨æ˜Žåˆ†éš”èƒ½åŠ›è¶Šçªå‡ºã€‚å¦å¤–ï¼ŒKSå€¼æ‰€ä»£è¡¨çš„ä»…ä»…æ˜¯æ¨¡åž‹çš„åˆ†éš”èƒ½åŠ›ï¼Œå¹¶ä¸ä»£è¡¨åˆ†éš”çš„æ ·æœ¬æ˜¯å‡†ç¡®çš„ã€‚æ¢å¥è¯è¯´ï¼Œæ­£è´Ÿæ ·æœ¬å®Œå…¨åˆ†é”™ï¼Œä½†KSå€¼å¯ä»¥ä¾æ—§å¾ˆé«˜ã€‚(åœ¨å®žä¹ çš„è¿‡ç¨‹ä¸­ï¼Œå¯¹äºŽæ­£å¤ªåˆ†å¸ƒçš„æ‰§ç€çœŸæ˜¯éžå¸¸æ‰§ç€çš„) KSæ›²çº¿å’ŒROC æ›²çº¿çš„åŒºåˆ«å’Œè”ç³»ï¼š K-Sæ›²çº¿å…¶å®žæ•°æ®æ¥æºå’Œæœ¬è´¨å’ŒROCæ›²çº¿æ˜¯ä¸€è‡´çš„ï¼Œåªæ˜¯ROCæ›²çº¿æ˜¯æŠŠçœŸæ­£çŽ‡å’Œå‡æ­£çŽ‡å½“ä½œæ¨ªçºµè½´ï¼Œè€ŒK-Sæ›²çº¿æ˜¯æŠŠçœŸæ­£çŽ‡å’Œå‡æ­£çŽ‡éƒ½å½“ä½œæ˜¯çºµè½´ï¼Œæ¨ªè½´åˆ™ç”±é€‰å®šçš„é˜ˆå€¼æ¥å……å½“ã€‚ä¸åŒçš„æ˜¯ï¼ŒROCæ›²çº¿ç”¨FPRä½œä¸ºæ¨ªè½´ï¼ŒTPRä½œä¸ºçºµè½´ï¼Œé‡‡ç”¨æç‚¹æ³•ç»˜åˆ¶ï¼Œå›¾ä¸­æ€»å…±æ˜¯ä¸€æ¡çº¿ï¼›è€ŒKSæ›²çº¿çš„æ¨ªè½´åˆ™æ˜¯ä¸åŒçš„æ¦‚çŽ‡åˆ¤æ–­é˜ˆå€¼ï¼Œå›¾ä¸­ä¸€å…±æœ‰ä¸¤æ¡çº¿ï¼Œåˆ†åˆ«ä»£è¡¨äº†FPRå€¼å’ŒTPRå€¼ã€‚ï¼ˆå…·ä½“å¯ä»¥å‚è€ƒä¸Šæ–‡çš„å›¾åƒè®²è§£ï¼‰ è¦å¼„æ˜Žç™½kså€¼å’Œaucå€¼çš„å…³ç³»é¦–å…ˆè¦å¼„æ‡‚rocæ›²çº¿å’Œksæ›²çº¿æ˜¯æ€Žä¹ˆç”»å‡ºæ¥çš„ã€‚å…¶å®žä»ŽæŸä¸ªè§’åº¦ä¸Šæ¥è®²ROCæ›²çº¿å’ŒKSæ›²çº¿æ˜¯ä¸€å›žäº‹ï¼Œåªæ˜¯æ¨ªçºµåæ ‡çš„å–æ³•ä¸åŒè€Œå·²ã€‚æ‹¿é€»è¾‘å›žå½’ä¸¾ä¾‹ï¼Œæ¨¡åž‹è®­ç»ƒå®Œæˆä¹‹åŽæ¯ä¸ªæ ·æœ¬éƒ½ä¼šå¾—åˆ°ä¸€ä¸ªç±»æ¦‚çŽ‡å€¼ï¼ˆæ³¨æ„æ˜¯ç±»ä¼¼çš„ç±»ï¼‰ï¼ŒæŠŠæ ·æœ¬æŒ‰è¿™ä¸ªç±»æ¦‚çŽ‡å€¼æŽ’åºåŽåˆ†æˆ10ç­‰ä»½ï¼Œæ¯ä¸€ä»½å•ç‹¬è®¡ç®—å®ƒçš„çœŸæ­£çŽ‡å’Œå‡æ­£çŽ‡ï¼Œç„¶åŽè®¡ç®—ç´¯è®¡æ¦‚çŽ‡å€¼ï¼Œç”¨çœŸæ­£çŽ‡å’Œå‡æ­£çŽ‡çš„ç´¯è®¡åšä¸ºåæ ‡ç”»å‡ºæ¥çš„å°±æ˜¯ROCæ›²çº¿ï¼Œç”¨10ç­‰åˆ†åšä¸ºæ¨ªåæ ‡ï¼Œç”¨çœŸæ­£çŽ‡å’Œå‡æ­£çŽ‡çš„ç´¯è®¡å€¼åˆ†åˆ«åšä¸ºçºµåæ ‡å°±å¾—åˆ°ä¸¤ä¸ªæ›²çº¿ï¼Œè¿™å°±æ˜¯KSæ›²çº¿ã€‚AUCå€¼å°±æ˜¯ROCæ›²çº¿ä¸‹æ”¾çš„é¢ç§¯å€¼ï¼Œè€Œkså€¼å°±æ˜¯ksæ›²çº¿ä¸­ä¸¤æ¡æ›²çº¿ä¹‹é—´çš„æœ€å¤§é—´éš”è·ç¦»ã€‚ç”±äºŽkså€¼èƒ½æ‰¾å‡ºæ¨¡åž‹ä¸­å·®å¼‚æœ€å¤§çš„ä¸€ä¸ªåˆ†æ®µï¼Œå› æ­¤é€‚åˆç”¨äºŽcut_offï¼Œåƒè¯„åˆ†å¡è¿™ç§å°±å¾ˆé€‚åˆç”¨kså€¼æ¥è¯„ä¼°ã€‚ä½†æ˜¯kså€¼åªèƒ½åæ˜ å‡ºå“ªä¸ªåˆ†æ®µæ˜¯åŒºåˆ†æœ€å¤§çš„ï¼Œè€Œä¸èƒ½æ€»ä½“åæ˜ å‡ºæ‰€æœ‰åˆ†æ®µçš„æ•ˆæžœï¼Œå› æžœAUCå€¼æ›´èƒ½èƒœä»»ã€‚ å¥½çš„ä¿¡ç”¨é£ŽæŽ§æ¨¡åž‹ä¸€èˆ¬ä»Žå‡†ç¡®æ€§ã€ç¨³å®šæ€§å’Œå¯è§£é‡Šæ€§æ¥è¯„ä¼°æ¨¡åž‹ã€‚ å‚è€ƒèµ„æ–™ï¼šæ·±å…¥ç†è§£KS GINIç³»æ•° è¿˜è®°å¾—ç»æµŽå­¦ä¸­é‚£ä¸ªè‘—åçš„åŸºå°¼ç³»æ•°å—ï¼Ÿä¸‹å›¾åº”è¯¥å¯ä»¥è®©ä½ å›žå¿†èµ·æ¥ã€‚å°†ä¸€ä¸ªå›½å®¶æ‰€æœ‰çš„äººå£æŒ‰æœ€è´«ç©·åˆ°æœ€å¯Œæœ‰è¿›è¡ŒæŽ’åˆ—ï¼Œéšç€äººæ•°çš„ç´¯è®¡ï¼Œè¿™äº›äººå£æ‰€æ‹¥æœ‰çš„è´¢å¯Œçš„æ¯”ä¾‹ä¹Ÿé€æ¸å¢žåŠ åˆ°100%ï¼ŒæŒ‰è¿™ä¸ªæ–¹æ³•å¾—åˆ°å›¾ä¸­çš„æ›²çº¿ï¼Œç§°ä¸ºæ´›ä¼¦å…¹æ›²çº¿ã€‚åŸºå°¼ç³»æ•°å°±æ˜¯å›¾ä¸­A/Bçš„æ¯”ä¾‹ã€‚å¯ä»¥çœ‹åˆ°ï¼Œå‡å¦‚è¿™ä¸ªå›½å®¶æœ€å¯Œæœ‰çš„é‚£ç¾¤äººå æ®äº†è¶Šå¤šçš„è´¢å¯Œï¼Œè´«å¯Œå·®è·è¶Šå¤§ï¼Œé‚£ä¹ˆæ´›ä¼¦èŒ¨æ›²çº¿å°±ä¼šè¶Šå¼¯æ›²ï¼ŒåŸºå°¼ç³»æ•°å°±è¶Šå¤§ã€‚ åŒæ ·çš„ï¼Œå‡è®¾æˆ‘ä»¬æŠŠ100ä¸ªäººçš„ä¿¡ç”¨è¯„åˆ†æŒ‰ç…§ä»Žé«˜åˆ°ä½Žè¿›è¡ŒæŽ’åºï¼Œä»¥æ¨ªè½´ä¸ºç´¯è®¡äººæ•°æ¯”ä¾‹ï¼Œçºµè½´ä½œä¸ºç´¯è®¡åæ ·æœ¬æ¯”ä¾‹ï¼Œéšç€ç´¯è®¡äººæ•°æ¯”ä¾‹çš„ä¸Šå‡ï¼Œç´¯è®¡åæ ·æœ¬çš„æ¯”ä¾‹ä¹Ÿåœ¨ä¸Šå‡ã€‚å¦‚æžœè¿™ä¸ªè¯„åˆ†çš„åŒºåˆ†èƒ½åŠ›æ¯”è¾ƒå¥½ï¼Œé‚£ä¹ˆè¶Šå¤§æ¯”ä¾‹çš„åæ ·æœ¬ä¼šé›†ä¸­åœ¨è¶Šä½Žçš„åˆ†æ•°åŒºé—´ï¼Œæ•´ä¸ªå›¾åƒå½¢æˆä¸€ä¸ªå‡¹ä¸‹åŽ»çš„å½¢çŠ¶ã€‚æ‰€ä»¥æ´›ä¼¦å…¹æ›²çº¿çš„å¼§åº¦è¶Šå¤§ï¼ŒåŸºå°¼ç³»æ•°è¶Šå¤§ï¼Œè¿™ä¸ªæ¨¡åž‹åŒºåˆ†å¥½åæ ·æœ¬çš„èƒ½åŠ›å°±è¶Šå¼ºã€‚ é£ŽæŽ§æ¨¡åž‹ï¼šksï¼Œ åŸºå°¼ç³»æ•° -&gt;è´¨é‡psi -&gt;ç¨³å®šæ€§PSIå³Population stability indexï¼š æ¨¡åž‹ç¨³å®šæ€§ å…¶ä»–ç»æµŽå­¦æ¦‚å¿µè‚¡å¸‚å’Œå€ºå¸‚çš„åŒºåˆ« è‚¡å¸‚å’Œå€ºå¸‚çš„å…³ç³» å½“è‚¡å¸‚å¼€å§‹èµ°ç‰›æ—¶ï¼Œå€ºå¸‚ç‰›å¸‚è¿›å…¥æœ€åŽé˜¶æ®µï¼Œå½“å¤§éƒ¨åˆ†äººéƒ½çŸ¥é“è‚¡å¸‚ç‰›å¸‚æ¥ä¸´æ—¶ï¼Œå€ºå¸‚å¼€å§‹èµ°ç†Šã€‚ å½“è‚¡å¸‚ä»Žç‰›å¸‚è½¬ä¸ºç†Šå¸‚æ—¶ï¼Œå€ºå¸‚è·Œæœ€åŽä¸€æ³¢ï¼Œå½“å¤§éƒ¨åˆ†äººéƒ½çŸ¥é“è‚¡å¸‚ç†Šå¸‚æ¥ä¸´æ—¶ï¼Œå€ºå¸‚å¼€å§‹èµ°ç‰›ã€‚ è¿™æ˜¯å› ä¸ºç»æµŽå‘¨æœŸå†³å®šçš„ã€‚ç»æµŽè¿›å…¥å¤è‹æœŸåŽï¼Œç¤¾ä¼šå„è¡Œä¸šå¹³å‡åˆ©æ¶¦çŽ‡é€æ­¥å‡é«˜ï¼Œè€Œè´·æ¬¾åˆ©çŽ‡å…¶å®žå°±æ˜¯å„è¡Œä¸šå¹³å‡åˆ©æ¶¦çŽ‡ï¼Œæ‰€ä»¥é“¶è¡Œåˆ©çŽ‡åœæ­¢ä¸‹é™ï¼Œä½†æ­¤æ—¶é“¶è¡Œåˆ©çŽ‡è¿˜åœ¨æœ€ä½Žç‚¹ï¼Œç¤¾ä¼šæµåŠ¨æ€§ä¹Ÿå……è¶³ï¼Œå€ºå¸‚é æƒ¯æ€§è¿›å…¥ç‰›å¸‚çš„æœ€åŽä¸€æ³¢ã€‚å› ä¸ºç»æµŽå¤è‹ï¼Œè‚¡å¸‚å¼€å§‹è¿›å…¥ç‰›å¸‚ã€‚è‚¡å¸‚èµ°ç‰›ä¸€æ®µæ—¶é—´åŽï¼Œå› ä¸ºèµ„æœ¬çš„é€åˆ©æ€§ï¼Œå¤§é‡æŠ•èµ„è€…å¼€å§‹ä»Žå€ºå¸‚æ’¤é€€ï¼›å€ºå¸‚ç»è¿‡é•¿æœŸä¸Šæ¶¨ï¼Œå…¶æ”¶ç›ŠçŽ‡ä¹Ÿè¿œè¿œä½ŽäºŽè‚¡ç¥¨çš„åˆ†çº¢çŽ‡ï¼›åˆ©çŽ‡çš„å¼€å§‹ä¸Šæ¶¨å¯¼è‡´å€ºå¸‚åŸºæœ¬é¢é€†è½¬ã€‚å€ºå¸‚å¼€å§‹èµ°ç†Šï¼Œè€Œè‚¡å¸‚ç»§ç»­èµ°ç‰›ã€‚éšç€ç»æµŽç”±å¤è‹è¿›å…¥ç¹è£ï¼Œç¤¾ä¼šå„è¡Œä¸šå¹³å‡åˆ©æ¶¦çŽ‡åˆ°è¾¾é«˜å³°ï¼Œè‚¡å¸‚è¿›å…¥ç‰›å¸‚æœ€åŽé˜¶æ®µï¼Œå€ºå¸‚ç»§ç»­èµ°ç†Šã€‚å½“ç»æµŽç”±ç¹è£è¿›å…¥å±æœºæœŸï¼Œä¸ºäº†åº”å¯¹å±æœºï¼Œå›½å®¶è¿˜åœ¨ä¸æ–­æ”¶ç´§æµåŠ¨æ€§ï¼Œç¤¾ä¼šå„è¡Œä¸šå¹³å‡åˆ©æ¶¦çŽ‡ä¹Ÿå¼€å§‹ä¸‹é™ï¼Œç»æµŽæ»žæ¶¨ï¼Œè‚¡å¸‚å’Œå€ºå¸‚åŒæ—¶ä¸‹è·Œã€‚å½“ç»æµŽç”±å±æœºè¿›å…¥è§æ¡æœŸï¼Œå›½å®¶å¼€å§‹é€æ­¥æ”¾æ¾è´§å¸ï¼Œä½†ç¤¾ä¼šå„è¡Œä¸šå¹³å‡åˆ©æ¶¦çŽ‡ä»ç„¶åœ¨ä¸‹æ»‘ï¼Œè´·æ¬¾éœ€æ±‚ä¸‹é™ï¼Œå¤§é‡å®½æ¾å‡ºæ¥çš„é“¶è¡Œèµ„é‡‘é¦–å…ˆè¿›å…¥å€ºå¸‚ï¼›ç»è¿‡æ¼«é•¿ä¸‹è·Œï¼Œå€ºå¸‚çš„æ”¶ç›ŠçŽ‡åœ¨åŽ†å²é«˜ä½ï¼Œå…·æœ‰æŠ•èµ„ä»·å€¼ï¼›å½“å¤§éƒ¨åˆ†äººéƒ½çŸ¥é“ç†Šå¸‚æ¥åŽï¼Œèµ„é‡‘å¼€å§‹ä»Žè‚¡å¸‚å‘å€ºå¸‚è½¬ç§»ï¼Œå¯¼è‡´å€ºå¸‚å¼€å§‹èµ°ç‰›ã€‚åŽ»å¹´ç¾Žå›½å›½å€ºå±…ç„¶ä¸Šæ¶¨äº†18%ï¼Œ5å¹´æœŸå›½å€ºå¹´æ”¶ç›ŠçŽ‡åªæœ‰0.65%ï¼Œä¸»è¦å°±æ˜¯å› ä¸ºç¾Žå›½ç»æµŽåŽ»å¹´åœ¨è§æ¡æœŸï¼Œä»Šå¹´ç¾Žå›½ç»æµŽå¼€å§‹å¤è‹ï¼Œè‚¡ç¥¨å°±æˆä¸ºæœ€å¥½çš„æŠ•èµ„æ ‡çš„ã€‚ è‚¡å¸‚å’Œå€ºå¸‚çš„å®šä¹‰ï¼š è‚¡ç¥¨å¸‚åœºæ˜¯å·²ç»å‘è¡Œçš„è‚¡ç¥¨è½¬è®©ã€ä¹°å–å’Œæµé€šçš„åœºæ‰€ï¼ŒåŒ…æ‹¬äº¤æ˜“æ‰€å¸‚åœºå’Œåœºå¤–äº¤æ˜“å¸‚åœºä¸¤å¤§ç±»åˆ«ã€‚ç”±äºŽå®ƒæ˜¯å»ºç«‹åœ¨å‘è¡Œå¸‚åœºåŸºç¡€ä¸Šçš„ï¼Œå› æ­¤åˆç§°ä½œäºŒçº§å¸‚åœºã€‚è‚¡ç¥¨å¸‚åœºçš„ç»“æž„å’Œäº¤æ˜“æ´»åŠ¨æ¯”å‘è¡Œå¸‚åœºï¼ˆä¸€çº§å¸‚åœºï¼‰æ›´ä¸ºå¤æ‚ï¼Œå…¶ä½œç”¨å’Œå½±å“åŠ›ä¹Ÿæ›´å¤§ã€‚è‚¡ç¥¨å¸‚åœºçš„å‰èº«èµ·æºäºŽ1602å¹´è·å…°äººåœ¨é˜¿å§†æ–¯ç‰¹æ²³å¤§æ¡¥ä¸Šè¿›è¡Œè·å±žä¸œå°åº¦å…¬å¸è‚¡ç¥¨çš„ä¹°å–ï¼Œè€Œæ­£è§„çš„è‚¡ç¥¨å¸‚åœºæœ€æ—©å‡ºçŽ°åœ¨ç¾Žå›½ã€‚è‚¡ç¥¨å¸‚åœºæ˜¯æŠ•æœºè€…å’ŒæŠ•èµ„è€…åŒåŒæ´»è·ƒçš„åœ°æ–¹ï¼Œæ˜¯ä¸€ä¸ªå›½å®¶æˆ–åœ°åŒºç»æµŽå’Œé‡‘èžæ´»åŠ¨çš„å¯’æš‘è¡¨ï¼Œè‚¡ç¥¨å¸‚åœºçš„ä¸è‰¯çŽ°è±¡ä¾‹å¦‚æ— è´§æ²½ç©ºç­‰ç­‰ï¼Œå¯ä»¥å¯¼è‡´è‚¡ç¾ç­‰å„ç§å±å®³çš„äº§ç”Ÿã€‚è‚¡ç¥¨å¸‚åœºå”¯ä¸€ä¸å˜çš„å°±æ˜¯ï¼šæ—¶æ—¶åˆ»åˆ»éƒ½æ˜¯å˜åŒ–çš„ã€‚ä¸­å›½æœ‰ä¸Šäº¤æ‰€å’Œæ·±äº¤æ‰€ä¸¤ä¸ªäº¤æ˜“å¸‚åœºã€‚å€ºåˆ¸å¸‚åœºæ˜¯å‘è¡Œå’Œä¹°å–å€ºåˆ¸çš„åœºæ‰€ï¼Œæ˜¯ï¼ˆé‡‘èžå¸‚åœºï¼‰ä¸€ä¸ªé‡è¦ç»„æˆéƒ¨åˆ†ã€‚å€ºåˆ¸å¸‚åœºæ˜¯ä¸€å›½é‡‘èžä½“ç³»ä¸­ä¸å¯æˆ–ç¼ºçš„éƒ¨åˆ†ã€‚ ä¸€ä¸ªç»Ÿä¸€ã€æˆç†Ÿçš„å€ºåˆ¸å¸‚åœºå¯ä»¥ä¸ºå…¨ç¤¾ä¼šçš„æŠ•èµ„è€…å’Œç­¹èµ„è€…æä¾›ä½Žé£Žé™©çš„æŠ•èžèµ„å·¥å…·ï¼›å€ºåˆ¸çš„æ”¶ç›ŠçŽ‡æ›²çº¿æ˜¯ç¤¾ä¼šç»æµŽä¸­ä¸€åˆ‡é‡‘èžå•†å“æ”¶ç›Šæ°´å¹³çš„åŸºå‡†ï¼Œå› æ­¤å€ºåˆ¸å¸‚åœºä¹Ÿæ˜¯ä¼ å¯¼ä¸­å¤®é“¶è¡Œè´§å¸æ”¿ç­–çš„é‡è¦è½½ä½“ã€‚å¯ä»¥è¯´ï¼Œç»Ÿä¸€ã€æˆç†Ÿçš„å€ºåˆ¸å¸‚åœºæž„æˆäº†ä¸€ä¸ªå›½å®¶é‡‘èžå¸‚åœºçš„åŸºç¡€ã€‚ å¤šæŠ•: æŠ•å…¥äº†å¤šå®¶è¿›è¡Œå€Ÿè´·ä¹‹ç±»çš„ å¯¹äºŽç¬¬ä¸‰æ–¹ï¼Œå°±ä¸€ä¸ªå¤§æ•°æ®å…¬å¸ï¼Œè¿˜æ˜¯è¦ä½“çŽ°æ•°æ®ä¼˜åŠ¿ï¼Œæ•°æ®è´¨é‡ï¼ŒåŒ¹é…ç¨‹åº¦ã€‚è´·å‰æ˜¯é£Žé™©æŽ§åˆ¶ï¼Œ è´·ä¸­æ˜¯ä»·å€¼æŒ–æŽ˜ï¼Œå‘çŽ°ä¼˜è´¨å®¢æˆ·ã€‚ç»´åº¦ï¼šä¸‰æ–¹æ•°æ®ã€å·¥å•†åŸºæœ¬ä¿¡æ¯å’Œè‡ªæœ‰æ•°æ®ã€‚ ç™½æˆ·å’Œçº¯ç™½æˆ·ï¼šï¼ˆä¿¡ç”¨è®°å½•æ˜¯ä¸å…¨çš„ï¼‰ç™½æˆ·æ˜¯æŒ‡æœ‰ç”³è¯·è®°å½•ï¼Œä½†æœ€åŽç”³è¯·å¤±è´¥æ²¡æœ‰ä¸‹å¡ï¼Œæ—¶é—´åŠå¹´ä»¥ä¸Šã€‚ çº¯ç™½æˆ·æ˜¯æŒ‡ï¼Œæ²¡æœ‰ç”³è¯·è¿‡ä¿¡ç”¨å¡ä¸Žè´·æ¬¾ï¼Œä¸ªäººä¿¡ç”¨ç©ºç™½çš„å«çº¯ç™½æˆ·ã€‚ çº¯ç™½æˆ·å’Œç™½æˆ·éƒ½æ˜¯æŒ‡æ²¡æœ‰é“¶è¡Œä¿¡ç”¨è®°å½•çš„å®¢æˆ·ç¾¤ä½“ï¼Œæ­¤ç±»äººç¾¤åœ¨åŠžç†è´·æ¬¾æ—¶ï¼Œéš¾å…ä¼šå¡å£³é‡é˜»ï¼Œç©¶å…¶åŽŸå› ï¼Œä¸ºäº†æŠŠæŽ§é£Žé™©ï¼Œéƒ¨åˆ†é“¶è¡Œåªå°†å—ä¼—é”å®šåœ¨äº†æœ‰ä¿¡ç”¨è®°å½•ä¸”è‰¯å¥½çš„äººç¾¤èº«ä¸Šã€‚ Excel çš„ä½¿ç”¨ vloopup å‡½æ•°ç”¨äºŽåŒ¹é…æŸ¥æ‰¾ã€‚ å››ä¸ªå‚æ•°ï¼š(æŸ¥æ‰¾çš„å…³é”®å­—ï¼Œåœ¨å“ªä¸ªåŒºåŸŸæŸ¥æ‰¾ï¼Œè¿”å›žå¾€å³è¾¹æ•°ç¬¬å‡ åˆ—ï¼Œç²¾ç¡®æŸ¥æ‰¾/ æ¨¡ç³ŠæŸ¥æ‰¾)ç¬¬ä¸€ä¸ªå‚æ•°å°±æ˜¯å…³é”®å­—ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯å…³é”®å­—æ‰€åœ¨åˆ—ä¸ºæœ€å·¦ä¾§çš„åˆ—çš„åŒºåŸŸå…¨é€‰çš„æ—¶å€™ï¼Œé€‰ä¸­æ ‡é¢˜è¡Œï¼Œctrl shift + down +F4è¿™æ ·å°±é€‰ä¸­äº†æ‰€æœ‰ä¸‹é¢çš„æ•°æ®ç›¸å¯¹äºŽå…³é”®å­—ç¬¬ä¸‰å‚æ•°ï¼šä»¥å…³é”®è¯æ‰€åœ¨çš„åˆ—ä¸ºç¬¬ä¸€åˆ—ï¼Œç„¶åŽæ˜¯è¦çš„ç¬¬å‡ åˆ—çš„æ•°æ®ç¬¬å››ä¸ªå‚æ•°ä½¿ç”¨ 0 æˆ–è€… falseï¼Œè¡¨ç¤ºç²¾ç¡®æŸ¥æ‰¾ é€è§†è¡¨/é€è§†å›¾ è¿›è¡Œæ•°æ®çš„ç­›é€‰å’Œç»Ÿè®¡ åœ¨excel ä¸­å¯ä»¥ä½¿ç”¨ â€œ=leftâ€ è¿›è¡Œå­—ç¬¦ä¸²çš„åˆ‡åˆ† ä¼šè®®è®°å½•ä¹¦å†™æ¨¡æ¿ åŒæ–¹å‚ä¸Žäººå‘˜ï¼šæ—¶é—´ï¼šåœ°ç‚¹ ä¼šè®®çš„ä¸»è¦å†…å®¹ï¼š â€¦ â€¦ â€¦. åŽç»­çš„è®¡åˆ’å®‰æŽ’ ä¹Ÿæ˜¯å¾ˆé‡è¦ï¼Œä¸€å®šè¦å†™å¥½ã€‚ æœºå™¨å­¦ä¹ å…³äºŽè§„åˆ™è¿˜æ˜¯æ¨¡åž‹ï¼Ÿç¨³å®šçš„ç‰¹å¾æ˜¯åœ¨æ¨¡åž‹ä¸­ï¼Œä¸å¤ªç¨³å®šçš„æ˜¯åœ¨è§„åˆ™ä¸­ã€‚ å¸¸å¸¸ä½¿ç”¨çš„å·¥å…·ï¼šxgblightgbmspss å•†ä¸šè½¯ä»¶ æ•°æ®åˆ†æžè½¯ä»¶ ä¸ªäººä¿¡æ¯ä¸‰è¦ç´ ï¼šå§“åã€æ‰‹æœºå·å’Œèº«ä»½è¯å·ã€‚ åªè¦å°†è¿™äº›ä¿¡æ¯è¿›è¡ŒåŠ å¯†or ç¼ºçœï¼Œé‚£ä¹ˆä¸€èˆ¬æ˜¯ä¸ä¼šé€ æˆæ•°æ®çš„ç¼ºå¤±çš„ã€‚ é£ŽæŽ§çš„æµç¨‹å›¾ï¼š]]></content>
      <categories>
        <category>NOT_FOR_YOU</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Similarity Measures]]></title>
    <url>%2F2019%2F06%2F21%2Fsimilarity-measures%2F</url>
    <content type="text"><![CDATA[The similarity measure is the measure of how much alike two data objects are. Similarity measure in a data mining context is a distance with dimensions representing features of the objects. If this distance is small, it will be the high degree of similarity where large distance will be the low degree of similarity. The similarity is subjective and is highly dependent on the domain and application. For example, two fruits are similar because of color or size or taste. Care should be taken when calculating distance across dimensions/features that are unrelated. The relative values of each element must be normalized, or one feature could end up dominating the distance calculation. Similarity are measured in the range 0 to 1 [0,1]. Euclidean distanceEuclidean distance is the most common use of distance. In most cases when people said about distance, they will refer to Euclidean distance. Euclidean distance is also known as simply distance. When data is dense or continuous, this is the best proximity measure. Applications: Where data is continuous or numerical . Also knows as L2 Norm famously. In an n dimensional space between two vectors x and y the formula is simply the square root of the sum of the square distance: $$d \left( \left[ x _ { 1 } , x _ { 2 } , \ldots , x _ { n } \right] , \left[ y _ { 1 } , y _ { 2 } , \ldots , y _ { n } \right] \right) = \sqrt { \sum _ { i = 1 } ^ { n } \left( x _ { i } - y _ { i } \right) ^ { 2 } }$$ 123456from math import * def euclidean_distance(x,y): return sqrt(sum(pow(a-b,2) for a, b in zip(x, y))) print euclidean_distance([0,3,4,5],[7,6,3,-1]) é€‚ç”¨èŒƒå›´ï¼šé€šç”¨åž‹ï¼Œåœ¨è¿žç»­ç¨ å¯†çš„å‘é‡è®¡ç®—ä¸­ç›¸æ¯”æ›´å¥½ã€‚ä½¿ç”¨è¿™ä¸ª matrix çš„æ—¶å€™ï¼Œæœ€å¥½æ˜¯å°†æ•°æ®è§„èŒƒåŒ–ï¼Œä¸€ç§åŽŸå› åœ¨äºŽ è¿™ä¸ªæ˜¯ä¹˜æ–¹çš„è¿ç®—ï¼Œè§„èŒƒåŒ–ä¹‹åŽè¯¯å·®æ˜¯ä¸è‡³äºŽå¤ªå¤§ã€‚ Manhattan distanceThis Manhattan distance metric is also known as Manhattan length, rectilinear distance, L1 distance or L1 norm, city block distance, Minkowskiâ€™s L1 distance, taxi-cab metric, or city block distance. Applications: can be used if the dimensions are continuous or numeric. This distance measure is very similar to Euclidean but it is a sum of the absolute difference of every dimension rather than the sum of squares. $$d = \sum _ { i = 1 } ^ { n } \left| x _ { i } - y _ { i } \right|$$ 123456from math import *def manhattan_distance(x,y): return sum(abs(a-b) for a,b in zip(x,y)) print manhattan_distance([10,20,10],[10,20,20]) é€‚ç”¨èŒƒå›´ï¼šå¯ä»¥å¤„ç†å¼‚å¸¸å€¼ã€å…·æœ‰ç‰¹å¾é€‰æ‹©çš„åŠŸèƒ½ï¼Œå¯ä»¥æœ‰å¤šä¸ªè§£ï¼ˆè€Œ Euclidean distance åªæœ‰ä¸€ä¸ªæœ€ä¼˜è§£ï¼‰ Minkowski distanceMinkowski distance is the generalized distance metric. å½“p =1 å’Œ2 æ—¶ï¼Œæ°å¥½æ˜¯ Euclidean distance å’ŒManhattan distance. $$\left( \sum _ { i = 1 } ^ { n } \left| x _ { i } - y _ { i } \right| ^ { p } \right) ^ { 1 / p }$$ 1234567891011121314 from math import *from decimal import Decimal def nth_root(value, n_root): root_value = 1/float(n_root) return round (Decimal(value) ** Decimal(root_value),3) def minkowski_distance(x,y,p_value): return nth_root(sum(pow(abs(a-b),p_value) for a,b in zip(x, y)),p_value) print minkowski_distance([0,3,4,5],[7,6,3,-1],3) Cosine similarityCosine similarity is particularly used in positive space, where the outcome is neatly bounded in [0,1]. One of the reasons for the popularity of cosine similarity is that it is very efficient to evaluate, especially for sparse vectors. Applications: Used in identifying document similarity, product recommendations, Information retrieval and works efficiently with high-dimensional sparse data. It is an angle between two data points in the vector space. Given a vector A and B, the cosine distance is the dot product of x and y divided by Euclidean distance. $$\text { similarity } = \cos ( \theta ) = \frac { \mathbf { A } \cdot \mathbf { B } } { | \mathbf { A } | | \mathbf { B } | } = \frac { \sum _ { i = 1 } ^ { n } A _ { i } B _ { i } } { \sqrt { \sum _ { i = 1 } ^ { n } A _ { i } ^ { 2 } } \sqrt { \sum _ { i = 1 } ^ { n } B _ { i } ^ { 2 } } }$$ 12345678910111213from math import * def square_rooted(x): return round(sqrt(sum([a*a for a in x])),3) # round(num, ndigits) åœ¨python2 ä¸­æ˜¯å››èˆäº”å…¥ def cosine_similarity(x,y): numerator = sum(a*b for a,b in zip(x,y)) denominator = square_rooted(x)*square_rooted(y) return round(numerator/float(denominator),3) print cosine_similarity([3, 45, 7, 2], [2, 54, 13, 15]) Cosine similarity vs Euclidean distanceé¦–å…ˆä»Žå…¬å¼ä¸Šè¯´ï¼Œ cosine similarity è€ƒè™‘çš„æ˜¯è§’åº¦ (angle)è€Œä¸æ˜¯ magnitudeï¼Œå¯ä»¥æŽ’é™¤æ–‡ç« é•¿åº¦çš„å¹²æ‰°ã€‚ Mathematically, it measures the cosine of the angle between two vectors projected in a multi-dimensional space. The cosine similarity is advantageous because even if the two similar documents are far apart by the Euclidean distance (due to the size of the document). å¦‚æžœæ¶‰åŠåˆ°ï¼ˆä½¿ç”¨ tf or tf-idfï¼‰ç”Ÿæˆäº†å‘é‡è¡¨ç¤ºï¼Œä½¿ç”¨ cosine similarity æ¯” euclidean æ›´å¥½ã€‚ å¦‚æžœä½¿ç”¨ word2vec ç”Ÿæˆçš„å‘é‡ï¼Œé‚£ä¹ˆ euclidean æ˜¯ä¸æ˜¯æ›´å¥½çš„é€‰æ‹©ã€‚Cosine is mostly used on very sparse, discrete domains such as text. Here, most dimensions are 0 and do not matter at all. å¦‚æžœä½ æƒ³è¦ magnitudeï¼Œé‚£ä¹ˆä½¿ç”¨ EDã€‚Euclidean is commonly used on dense, continuous variables. There every dimension mattersã€‚ è¿™é‡Œæœ‰ä¸€ä¸ªé‡è¦çš„è§‚ç‚¹ï¼Œ Cosine is essentially the same as Euclidean on normalized data. åœ¨å¾ˆé«˜çš„ç»´åº¦ï¼Œä¸¤è€…éƒ½æ˜¯ä¸è¡Œçš„ï¼Œè¿™å°±æ˜¯ Curse of Dimensionality. é€‚ç”¨èŒƒå›´ï¼š sparse, discrete è¿™ä¸ªç‰¹ç‚¹å†³å®šäº†åœ¨ nlp ä¸­ä½¿ç”¨æ˜¯æ¯”è¾ƒå¹¿æ³›çš„ï¼› è€ŒEuclidean distance åœ¨å›¾åƒä¸­ï¼ˆç¨ å¯†è¿žç»­å€¼ï¼‰ä¸­ä½¿ç”¨æ¯”è¾ƒå¹¿æ³›ã€‚ Jaccard similarityJaccard Distance measures how close two sets are. It is simply a ratio of the intersection of the sets to the Union. Can be used when the datatypes are categorical . Example: Products purchased/viewed by customers. Typically used in Product recommendation, Clustering customers based on purchase/engagement patterns. Please note Jaccard distance is a dissimilarity metric and Jaccard coefficient, J(A,B) is a similarity metric. $$d _ { J } ( A , B ) = 1 - J ( A , B ) = \frac { | A \cup B | - | A \cap B | } { | A \cup B | }$$ 123456789from math import * def jaccard_similarity(x,y): intersection_cardinality = len(set.intersection(*[set(x), set(y)])) # å‚æ•°å‰ä¸€ä¸ª *è¡¨ç¤ºä¼ å…¥çš„æ˜¯ä¸€ä¸ªå…ƒç¥– tuple union_cardinality = len(set.union(*[set(x), set(y)])) return intersection_cardinality/float(union_cardinality) print jaccard_similarity([0,1,2,5,6],[0,2,3,5,7,9]) é€‚ç”¨èŒƒå›´ï¼šset() ä¸­è®¡ç®—ã€‚ Edit Distance Edit distance is used when the comparing strings. Ideal use cases would be auto spell check, meta data correction etc. The distance between two strings are smaller if the number of corrections ( insertions or deletions ) needed to perfectly match are smaller. å¸¸è§çš„dp è§£æ³•ã€‚ 123456789101112131415161718192021222324class Solution(object): def minDistance(self, word1, word2): """ :type word1: str :type word2: str :rtype: int """ m = len(word1) n = len(word2) table = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): table[i][0] = i for j in range(n + 1): table[0][j] = j for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: table[i][j] = table[i - 1][j - 1] else: table[i][j] = 1 + min(table[i - 1][j], table[i][j - 1], table[i - 1][j - 1]) return table[-1][-1] é€‚ç”¨èŒƒå›´ï¼š string ä¸­çš„è·ç¦»ã€‚ Kullbackâ€“Leibler divergenceKullbackâ€“Leibler divergence (KL æ•£åº¦) (also called relative entropy ç›¸å¯¹ç†µ)ï¼Œ æ˜¯è¡¡é‡ä¸¤ä¸ªåˆ†å¸ƒä¹‹é—´çš„å·®å¼‚æ€§æŒ‡æ ‡ã€‚ å¯ä»¥å†™æˆè¿™æ ·ï¼š $$D_{\mathrm{KL}}(P | Q)=-\sum_{x \in \mathcal{X}} P(x) \log \left(\frac{Q(x)}{P(x)}\right)$$ ä¹Ÿå¯ä»¥å†™æˆè¿™æ ·ï¼š $$D_{\mathrm{KL}}(P | Q)=\sum_{x \in \mathcal{X}} P(x) \log \left(\frac{P(x)}{Q(x)}\right)$$ KL æ•£åº¦æ˜¯äº¤å‰ç†µå’Œç†µä¹‹å·®ã€‚æŽ¨å¯¼å¦‚ä¸‹ï¼š$$\begin{split}D_{K L}(p | q) &amp;= H(p) -H(p, q) \\ &amp; =-\int p(x) \log q(x)-\left(-\int p(x) \log p(x)\right) \\ &amp;=-\int p(x) \log \frac{q(x)}{p(x)} d x\end{split}$$ï¼ˆä¸Šé¢çš„å¼å­æ˜¯é”™è¯¯çš„ï¼Œåº”è¯¥æ˜¯äº¤å‰ç†µå’Œç†µçš„å·®ï¼‰ ç‰¹ç‚¹ï¼š ä¸å…·æœ‰å¯¹ç§°æ€§ å½“ä¸¤ä¸ªåˆ†å¸ƒä¸ç›¸äº¤æ—¶å€™ï¼Œè·ç¦»è¶‹å‘æ— ç©·ï¼Œæ— æ³•ååº”è·ç¦»å…³ç³» å¤ä¹ æ€»ç»“ Euclidean distance æœ€å¸¸ç”¨çš„ï¼Œé€‚åˆåœ¨è¿žç»­ç¨ å¯†çš„å‘é‡ä¸­è¿›è¡Œè®¡ç®—ã€‚ ç»å¯¹å€¼distanceï¼Œ é€‚åˆå¤„ç†å¼‚å¸¸å€¼ï¼Œå…·æœ‰ç‰¹å¾é€‰æ‹©çš„åŠŸèƒ½ï¼ˆæ˜¯å¦è¿˜è®°å¾—L1ï¼‰ cosine similarityï¼Œé€‚åˆåœ¨æ–‡ç« ç›¸ä¼¼åº¦ã€å•†å“æŽ¨èã€ä¿¡æ¯å¬å›žç­‰ç¨€ç–é«˜çº¬æ•°æ®ä¸­ã€‚ cosine vs. æ¬§æ°è·ç¦»ï¼Œå‰è€…è€ƒè™‘çš„æ˜¯è§’åº¦(angle) è€Œä¸æ˜¯magnitudeï¼Œå› æ­¤å¯ä»¥æŽ’é™¤æ–‡ç« é•¿åº¦çš„å½±å“ï¼›å‰è€…åœ¨nlpä¸­ä½¿ç”¨æ¯”è¾ƒå¹¿æ³›ï¼ŒåŽè€…åœ¨å›¾åƒï¼ˆç¨ å¯†è¿žç»­å€¼ï¼‰ä¸­ä½¿ç”¨æ¯”è¾ƒå¹¿æ³›ã€‚ Jaccard similarityï¼Œäº¤é›†æ¯”ä¸Šå¹¶é›† edit distanceï¼Œå­—ç¬¦ä¸²çš„ç¼–è¾‘è·ç¦» KL æ•£åº¦ï¼Œè¡¡é‡ä¸¤ä¸ªåˆ†å¸ƒä¹‹é—´å·®å¼‚çš„æŒ‡æ ‡]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>similarity-measures</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[overfit]]></title>
    <url>%2F2019%2F06%2F21%2Foverfit%2F</url>
    <content type="text"><![CDATA[åˆ†æžæœºå™¨å­¦ä¹  å’Œæ·±åº¦å­¦ä¹ ä¸­å‡ºçŽ°çš„è¿‡æ‹ŸåˆçŽ°è±¡ï¼Œä»Žä¸åŒçš„è§’åº¦ç®€è¿°å¸¸ç”¨çš„å¤„ç†æ‰‹æ®µã€‚ ä»€ä¹ˆæ˜¯è¿‡æ‹Ÿåˆ?è®­ç»ƒæ•°æ®é›†è§„æ¨¡å°æ˜¯å¯¼è‡´è¿‡æ‹Ÿåˆçš„åŽŸå› ï¼Œè€Œç½‘ç»œè¶³å¤Ÿçš„å¤æ‚ï¼ˆæœ‰èƒ½åŠ›ï¼‰è®°ä½äº†æ‰€æœ‰çš„æ ·æœ¬ï¼Œç„¶åŽåœ¨train sets è¡¨çŽ°è¦è¿œè¿œå¥½äºŽ test setsã€‚ è¿˜æœ‰ä¸€ç§è¯´æ³•æ˜¯ç½‘ç»œæ‹Ÿåˆäº†å™ªå£°æ•°æ®ã€‚ å¦‚ä½•å¤„ç†è¿‡æ‹Ÿåˆå¤„ç†è¯¥é—®é¢˜å¯ä»¥ä»Žæ•°æ®å’Œæ¨¡åž‹ä¸¤ä¸ªæ–¹é¢åŽ»è€ƒè™‘ã€‚ æ¨¡åž‹è§’åº¦ç®€åŒ–æ¨¡åž‹ï¼Œé€šè¿‡ä¸æ–­é™ä½Žæ¨¡åž‹çš„å¤æ‚åº¦ï¼ˆæ¯”å¦‚éšæœºæ£®æž—ä¸­çš„ä¼°è®¡é‡ï¼Œç¥žç»ç½‘ç»œä¸­çš„å‚æ•°ï¼‰ï¼Œæœ€ç»ˆè¾¾åˆ°ä¸€ä¸ªå¹³è¡¡çŠ¶æ€ï¼šæ¨¡åž‹è¶³å¤Ÿç®€å•åˆ°ä¸äº§ç”Ÿè¿‡æ‹Ÿåˆï¼Œåˆè¶³å¤Ÿå¤æ‚åˆ°èƒ½ä»Žæ•°æ®ä¸­å­¦ä¹ ã€‚è¿™æ ·æ“ä½œæ—¶ä¸€ä¸ªæ¯”è¾ƒæ–¹ä¾¿çš„æ–¹æ³•æ˜¯æ ¹æ®æ¨¡åž‹çš„å¤æ‚ç¨‹åº¦æŸ¥çœ‹æ¨¡åž‹åœ¨æ‰€æœ‰æ•°æ®é›†ä¸Šçš„è¯¯å·®ã€‚å¦‚ å›¾ 1 æ‰€ç¤ºã€‚ å›¾ 1 ç®€åŒ–æ¨¡åž‹çš„å¦ä¸€ä¸ªå¥½å¤„åœ¨äºŽè®­ç»ƒé€Ÿåº¦æ›´åŠ å¿«. æ•°æ®è§’åº¦ èŽ·å–æ›´å¤šçš„æ•°æ® æ•°æ®å¢žå¼º èŽ·å–æ›´å¤šçš„æ•°æ®ä¾§é‡èŽ·å–å¾—åˆ°çš„åŽŸå§‹çš„è®­ç»ƒæ•°æ®é›†ï¼›è€Œæ•°æ®å¢žå¼ºåœ¨å›¾åƒå¤„ç†ä¸­æ›´åŠ å¸¸è§ï¼Œä¸»è¦æ˜¯å›¾åƒçš„å˜å½¢ï¼Œå™ªå£°æ–¹é¢è¿›è¡Œè€ƒè™‘ã€‚ è®­ç»ƒè¿‡ç¨‹è§’åº¦æå‰ç»ˆæ­¢ (early stop) å¦‚å›¾ 1 ï¼Œå½“ test error å¢žåŠ çš„æ—¶å€™ï¼Œé‚£ä¹ˆæ¨¡åž‹å°±åº”è¯¥åœæ­¢äº†ã€‚ æ­£åˆ™åŒ–è§’åº¦ç¥žç»ç½‘ç»œä¸­æœ‰ä¸»è¦æœ‰ä¸¤ç±»å®žä½“ï¼šç¥žç»å…ƒå’Œè¿žæŽ¥ç¥žç»å…ƒçš„è¾¹ã€‚æ‰€ä»¥æŒ‰ç…§è§„èŒƒåŒ–çš„æ“ä½œå¯¹è±¡çš„ä¸åŒå¯ä»¥åˆ†æˆä¸¤å¤§ç±»ï¼Œä¸€ç±»æ˜¯å¯¹äºŽL å±‚çš„ç¥žç»å…ƒçš„æ¿€æ´»å€¼æˆ–è€…è¯´å¯¹äºŽç¬¬ L+1 å±‚ç½‘ç»œç¥žç»å…ƒçš„è¾“å…¥å€¼è¿›è¡Œnormalization æ“ä½œï¼Œæ¯”å¦‚è¯´ batch normalization / Layer normalization ç­‰æ–¹æ³•éƒ½æ˜¯å±žäºŽè¿™ç±»ï¼›å¦ä¸€ç§æ˜¯å¯¹äºŽç¥žç»å…ƒä¹‹é—´ç›¸è¿žçš„è¾¹ä¸Šçš„æƒé‡è¿›è¡Œè§„èŒƒåŒ–æ“ä½œï¼Œæ¯”å¦‚è¯´ weights normalizationå°±å±žäºŽè¿™ç±»ã€‚ å¹¿ä¹‰ä¸Šè®²ï¼Œä¸€èˆ¬æœºå™¨å­¦ä¹ ä¸­çš„æŸå¤±å‡½æ•°ä¸­åŠ å…¥çš„ L1/ L2 ç­‰æ­£åˆ™é¡¹ å±žäºŽç¬¬äºŒç±»ã€‚L1 æ­£åˆ™é¡¹é€ æˆå‚æ•°çš„ç¨€ç–æ€§ï¼Œä½¿å¾—å¤§é‡çš„å‚æ•°å–å¾— 0å€¼ï¼Œ L2 æ­£åˆ™é¡¹ä½¿å¾—åŽŸå§‹å‚æ•°å€¼æœ‰æ•ˆçš„å‡å°ã€‚é€šè¿‡è¿™äº›è§„èŒƒåŒ–çš„æ‰‹æ®µæ”¹å˜å‚æ•°å€¼ï¼Œå·²è¾¾åˆ°é¿å…æ¨¡åž‹è¿‡æ‹Ÿåˆçš„ç›®çš„ã€‚ ï¼ˆæœ€åˆå¯¹äºŽè¾“å…¥data çš„normalizationï¼Œ æ˜¯å±žäºŽç¥žç»å…ƒçš„ normalizationï¼‰ è™½ç„¶ä¸Šè¿°æ–¹æ³•åˆ†åˆ«å¯¹ç¥žç»å…ƒå’Œweights è¿›è¡Œäº†è§„èŒƒåŒ–ï¼Œä½†æœ¬è´¨ä¸Šéƒ½å®žçŽ°äº†å¯¹æ•°æ®çš„è§„èŒƒåŒ–ï¼Œåªæ˜¯ scale çš„å‚æ•°çš„æ¥æºæ˜¯ä¸åŒçš„ã€‚ ä½¿ç”¨L1 or L2 åœ¨ loss function (error function) ä¸­æ·»åŠ æ­£åˆ™é¡¹ï¼Œå¯¹æŸå¤±å‡½æ•°ä¸­çš„weights è¿›è¡Œé™åˆ¶å…¶å˜å¤§ã€‚ å¯¹äºŽç¥žç»å…ƒçš„æ¿€æ´»å€¼æ¥è¯´ï¼Œä¸ç®¡å“ªç§æ–¹å¼ï¼Œå…¶ç›®æ ‡éƒ½æ˜¯ä¸€æ ·çš„ï¼Œå°†æ¿€æ´»å€¼è§„èŒƒåˆ°å‡å€¼ä¸º0ï¼Œæ–¹å·®ä¸º1 çš„æ­£å¤ªåˆ†å¸ƒã€‚ BN å®šä¹‰ï¼šBNé’ˆå¯¹ä¸€ä¸ªminibatchçš„è¾“å…¥æ ·æœ¬ï¼Œè®¡ç®—å‡å€¼å’Œæ–¹å·®ï¼ŒåŸºäºŽè®¡ç®—çš„å‡å€¼å’Œæ–¹å·®æ¥å¯¹æŸä¸€å±‚ç¥žç»ç½‘ç»œçš„è¾“å…¥Xä¸­æ¯ä¸€ä¸ªcaseè¿›è¡Œå½’ä¸€åŒ–æ“ä½œã€‚ BN çš„ä¼˜ç‚¹ï¼š æ˜¯ä¸€ç§æ­£åˆ™åŒ–æ‰‹æ®µï¼ŒåŠ ä¸ŠBN ä¹‹åŽï¼Œå­¦ä¹ çŽ‡å¯ä»¥æœ‰å¾ˆå¤§çš„æé«˜ï¼Œå¯ä»¥åŠ å¿«æ¨¡åž‹çš„æ”¶æ•›é€Ÿåº¦ ä¸€èˆ¬æ¥è¯´åœ¨æ¿€æ´»å‡½æ•°ä¹‹å‰æ¯”è¾ƒå¥½è§£é‡Šä¸€äº›ï¼Œæ•ˆæžœå¥½ä¸€äº›ï¼›è¾“å…¥æ¿€æ´»å‡½æ•°ä¹‹å‰è¿›è¡Œäº†æ•°æ®çš„å½’ä¸€åŒ–ï¼Œé˜²æ­¢è¿›åŽ»åˆ°æ¿€æ´»å‡½æ•°çš„é¥±å’ŒåŒºã€‚ æ‰€ä»¥å¯ä»¥å¾—åˆ°BN çš„é€‚ç”¨åœºæ™¯ï¼šæ¯ä¸ªmini-batch éƒ½æ¯”è¾ƒå¤§ï¼Œæ•°æ®åˆ†å¸ƒæ¯”è¾ƒæŽ¥è¿‘ã€‚åœ¨è®­ç»ƒä¹‹å‰ï¼Œæœ€å¥½æ˜¯åšå¥½äº† å……åˆ†çš„shuffleï¼Œå¦åˆ™æ•ˆæžœå¯èƒ½ä¸å¤ªå¥½ã€‚ BN çš„ä¸è¶³ï¼š é«˜åº¦ä¾èµ– mini-batch çš„å¤§å°ï¼Œå½“batch size æ¯”è¾ƒå°çš„æ—¶å€™ï¼Œæ•ˆæžœä¸å¥½ã€‚å› ä¸ºæ•°æ®æ ·æœ¬å°‘ï¼Œå¾—ä¸åˆ°æœ‰æ•ˆçš„ç»Ÿè®¡é‡ï¼Œä¹Ÿå¯ä»¥è¯´å™ªå£°æ¯”è¾ƒå¤§ã€‚å½“ç„¶æ˜¯å¯ä»¥é€šè¿‡è°ƒæ•´ batch size çš„å¤§å°è§„é¿è¿™ç§é—®é¢˜ï¼Œä½†æ˜¯æœ‰çš„ä»»åŠ¡è¦æ±‚ batch size ä¸èƒ½å¤ªå¤§ï¼›å¹¶ä¸”BN æ˜¯æ— æ³•åº”ç”¨åˆ° online learning ä¸­çš„ï¼Œå› ä¸ºonline éƒ½æ˜¯å•å®žä¾‹æ›´æ–°æ¨¡åž‹ï¼Œå¾ˆéš¾ç»„ç»‡èµ· mini-batch çš„ç»“æž„ã€‚ å¯¹äºŽç›¸ä¼¼çº§åˆ«çš„å›¾åƒç”Ÿæˆä»»åŠ¡ï¼ŒBN æ•ˆæžœä¸ä½³å¯¹äºŽå›¾ç‰‡åˆ†ç±»ç­‰ä»»åŠ¡ï¼Œåªè¦èƒ½å¤Ÿæ‰¾å‡ºå…³é”®ç‰¹å¾ï¼Œå°±èƒ½æ­£ç¡®åˆ†ç±»ï¼Œè¿™ç®—æ˜¯ä¸€ç§ç²—ç²’åº¦çš„ä»»åŠ¡ï¼Œåœ¨è¿™ç§æƒ…å½¢ä¸‹é€šå¸¸ BN æ˜¯æœ‰ç§¯æžæ•ˆæžœçš„ã€‚ä½†æ˜¯å¯¹äºŽæœ‰äº›è¾“å…¥è¾“å‡ºéƒ½æ˜¯å›¾ç‰‡çš„åƒç´ çº§åˆ«å›¾ç‰‡ç”Ÿæˆä»»åŠ¡ï¼Œæ¯”å¦‚å›¾ç‰‡é£Žæ ¼è½¬æ¢ç­‰åº”ç”¨åœºæ™¯ï¼Œä½¿ç”¨ BN ä¼šå¸¦æ¥è´Ÿé¢æ•ˆæžœï¼Œè¿™å¾ˆå¯èƒ½æ˜¯å› ä¸ºåœ¨ Mini-Batch å†…å¤šå¼ æ— å…³çš„å›¾ç‰‡ä¹‹é—´è®¡ç®—ç»Ÿè®¡é‡ï¼Œå¼±åŒ–äº†å•å¼ å›¾ç‰‡æœ¬èº«ç‰¹æœ‰çš„ä¸€äº›ç»†èŠ‚ä¿¡æ¯ã€‚ å› ä¸ºè¾“å…¥çš„ Sequence åºåˆ—æ˜¯ä¸å®šé•¿çš„ï¼Œè¿™æºè‡ªåŒä¸€ä¸ª Mini-Batch ä¸­çš„è®­ç»ƒå®žä¾‹æœ‰é•¿æœ‰çŸ­ã€‚å¯¹äºŽç±»ä¼¼ RNN è¿™ç§åŠ¨æ€ç½‘ç»œç»“æž„ï¼ŒBN ä½¿ç”¨èµ·æ¥ä¸æ–¹ä¾¿ è®­ç»ƒæ—¶å’ŒæŽ¨ç†æ—¶ç»Ÿè®¡é‡ä¸ä¸€è‡´å¯¹äºŽ BN æ¥è¯´ï¼Œé‡‡ç”¨ Mini-Batch å†…å®žä¾‹æ¥è®¡ç®—ç»Ÿè®¡é‡ï¼Œè¿™åœ¨è®­ç»ƒæ—¶æ²¡æœ‰é—®é¢˜ï¼Œä½†æ˜¯åœ¨æ¨¡åž‹è®­ç»ƒå¥½ä¹‹åŽï¼Œåœ¨çº¿æŽ¨ç†çš„æ—¶å€™ä¼šæœ‰éº»çƒ¦ã€‚å› ä¸ºåœ¨çº¿æŽ¨ç†æˆ–é¢„æµ‹çš„æ—¶å€™ï¼Œæ˜¯å•å®žä¾‹çš„ï¼Œä¸å­˜åœ¨ Mini-Batchã€‚è™½è¯´å®žé™…ä½¿ç”¨å¹¶æ²¡å¤§é—®é¢˜ï¼Œä½†æ˜¯ç¡®å®žå­˜åœ¨è®­ç»ƒå’ŒæŽ¨ç†æ—¶åˆ»ç»Ÿè®¡é‡è®¡ç®—æ–¹æ³•ä¸ä¸€è‡´çš„é—®é¢˜ã€‚ Layer normalization ä¹Ÿæ˜¯ä¸€ç§æ­£åˆ™åŒ–æ‰‹æ®µ BN vs LN ï¼š ä»Žå›¾ä¸­çœ‹å¯ä»¥çŸ¥é“ batchæ˜¯â€œç«–â€ç€æ¥çš„ï¼Œå„ä¸ªç»´åº¦åšå½’ä¸€åŒ–ï¼Œæ‰€ä»¥ä¸Žbatch sizeæœ‰å…³ç³»ã€‚ layeræ˜¯â€œæ¨ªâ€ç€æ¥çš„ï¼Œå¯¹ä¸€ä¸ªæ ·æœ¬ï¼Œä¸åŒçš„ç¥žç»å…ƒneuroné—´åšå½’ä¸€åŒ–ã€‚æ˜¾ç¤ºäº†åŒä¸€å±‚çš„ç¥žç»å…ƒçš„æƒ…å†µã€‚å‡è®¾è¿™ä¸ªmini-batchä¸€å…±æœ‰Nä¸ªæ ·æœ¬ï¼Œåˆ™Batch Normalizationæ˜¯å¯¹æ¯ä¸€ä¸ªç»´åº¦è¿›è¡Œå½’ä¸€ã€‚è€ŒLayer Normalizationå¯¹äºŽå•ä¸ªçš„æ ·æœ¬å°±å¯ä»¥å¤„ç†ã€‚ ç›¸åŒç‚¹ï¼š BN å’ŒLN éƒ½æ˜¯å¯ä»¥å¾ˆå¥½çš„ä¸€ç›´æ¢¯åº¦æ¶ˆå¤±å’Œæ¢¯åº¦çˆ†ç‚¸çš„ã€‚ å®žè·µè¯æ˜Žï¼Œ LN æ›´åŠ é€‚åˆ RNN ï¼ŒBN æ›´åŠ é€‚åˆCNN è‡³äºŽå„ç§ Normalization çš„é€‚ç”¨åœºæ™¯ï¼Œå¯ä»¥ç®€æ´å½’çº³å¦‚ä¸‹ï¼šå¯¹äºŽ RNN çš„ç¥žç»ç½‘ç»œç»“æž„æ¥è¯´ï¼Œç›®å‰åªæœ‰ LayerNorm æ˜¯ç›¸å¯¹æœ‰æ•ˆçš„ï¼›å¦‚æžœæ˜¯ GAN ç­‰å›¾ç‰‡ç”Ÿæˆæˆ–å›¾ç‰‡å†…å®¹æ”¹å†™ç±»åž‹çš„ä»»åŠ¡ï¼Œå¯ä»¥ä¼˜å…ˆå°è¯• InstanceNormï¼›å¦‚æžœä½¿ç”¨åœºæ™¯çº¦æŸ BatchSize å¿…é¡»è®¾ç½®å¾ˆå°ï¼Œæ— ç–‘æ­¤æ—¶è€ƒè™‘ä½¿ç”¨ GroupNormï¼›è€Œå…¶å®ƒä»»åŠ¡æƒ…å½¢åº”è¯¥ä¼˜å…ˆè€ƒè™‘ä½¿ç”¨ BatchNormã€‚ å‚è€ƒæ–‡çŒ®ï¼šæ·±åº¦å­¦ä¹ ä¸­çš„Normalizationæ¨¡åž‹ å››ç§ä¸åŒçš„normalization å››ç§ normalization æ—¶é—´è½´ BNï¼ˆBatch Normalizationï¼‰äºŽ2015å¹´ç”± Google æå‡ºï¼Œå¼€åˆ›äº†Normalization å…ˆæ²³ï¼›2016å¹´å‡ºäº†LNï¼ˆlayer normalizationï¼‰å’ŒINï¼ˆInstance Normalizationï¼‰ï¼›2018å¹´ä¹Ÿå°±æ˜¯ä»Šå¹´ï¼ŒKaimingæå‡ºäº†GNï¼ˆGroup normalizationï¼‰ï¼Œæˆä¸ºäº†ECCV 2018æœ€ä½³è®ºæ–‡æåã€‚ æ­£åˆ™åŒ–çš„æœ¬è´¨æ˜¯ä¸ºäº†å‡å°‘æ•°æ®çš„å¤æ‚ç¨‹åº¦å’Œå‡å°‘æ¨¡åž‹çš„å¤æ‚ç¨‹åº¦ï¼Œè¿™æ ·å°±å¯ä»¥è®¾ç½®æ›´å¤§çš„å­¦ä¹ çŽ‡ï¼Œæ›´å¿«çš„è¿›è¡Œæ”¶æ•›ã€‚ ç”¨æ›´ç®€å•çš„è¯­è¨€æ¥è®²ï¼Œå„ç§Normä¹‹é—´çš„å·®åˆ«åªæ˜¯é’ˆå¯¹çš„ç»´åº¦ä¸åŒè€Œå·²ã€‚ BNæ˜¯åœ¨batchä¸Šï¼Œå¯¹Nã€Hã€Wåšå½’ä¸€åŒ–ï¼Œè€Œä¿ç•™é€šé“ C çš„ç»´åº¦ã€‚BNå¯¹è¾ƒå°çš„batch sizeæ•ˆæžœä¸å¥½ã€‚BNé€‚ç”¨äºŽå›ºå®šæ·±åº¦çš„å‰å‘ç¥žç»ç½‘ç»œï¼Œå¦‚CNNï¼Œä¸é€‚ç”¨äºŽRNNï¼› LNåœ¨é€šé“æ–¹å‘ä¸Šï¼Œå¯¹Cã€Hã€Wå½’ä¸€åŒ–ï¼Œä¸»è¦å¯¹RNNæ•ˆæžœæ˜Žæ˜¾ï¼› INåœ¨å›¾åƒåƒç´ ä¸Šï¼Œå¯¹Hã€Wåšå½’ä¸€åŒ–ï¼Œç”¨åœ¨é£Žæ ¼åŒ–è¿ç§»ï¼› GNå°†channelåˆ†ç»„ï¼Œç„¶åŽå†åšå½’ä¸€åŒ–ã€‚ BN ä¸»è¦åœ¨ CNNä¸­ä½¿ç”¨ BN çš„ç¼ºç‚¹ æ•ˆæžœä¾èµ–äºŽbatch sizeï¼Œå¦‚æžœbatch size æ¯”è¾ƒå°ï¼Œé‚£ä¹ˆæ•ˆæžœæ¯”è¾ƒå·® ç†è®ºä¸Š batch size è¶Šå¤§ï¼Œé‚£ä¹ˆæ•ˆæžœæ˜¯è¶Šå¥½çš„ï¼Œä½†æ˜¯batch size å¤§çš„æ—¶å€™ï¼Œå¯èƒ½å‡ºçŽ° out of memory çš„é—®é¢˜ LN ä¸ä¾èµ–äºŽ batch size, åœ¨ RNN ä¸­æ•ˆæžœæ›´å¥½ã€‚ IN INé’ˆå¯¹å›¾åƒåƒç´ åšnormalizationï¼Œæœ€åˆç”¨äºŽå›¾åƒçš„é£Žæ ¼åŒ–è¿ç§»ã€‚åœ¨ä¸‰ç»´å›¾åƒä¸­ä½¿ç”¨ã€‚ GN GNæ˜¯ä¸ºäº†è§£å†³BNå¯¹è¾ƒå°çš„mini-batch sizeæ•ˆæžœå·®çš„é—®é¢˜ã€‚ å°±åƒä½œè€…è‡ªå·±æ¯”è¾ƒçš„è¯´æ³•ï¼šLNå’ŒINåªæ˜¯GNçš„ä¸¤ç§æžç«¯å½¢å¼ã€‚æˆ‘ä»¬å¯¹channelè¿›è¡Œåˆ†ç»„ï¼Œåˆ†ç»„æ•°ä¸ºGï¼Œå³ä¸€å…±åˆ†Gç»„ã€‚ å½“G=1æ—¶ï¼ŒGNå°±æ˜¯LNäº†ï¼›å½“G=Cæ—¶ï¼ŒGNå°±æ˜¯INäº†ã€‚è¿™ä¹Ÿæ˜¯ä¸€ä¸ªæœ‰è¶£çš„æ¯”è¾ƒï¼Œç±»ä¼¼äºŽGNæ˜¯LNå’ŒINçš„ä¸€ä¸ªtradeoffã€‚æ–‡ç« é‡Œå¯¹Gçš„é»˜è®¤å€¼æ˜¯32ã€‚ æ·±åº¦å­¦ä¹ ä¸­çš„Normalizationæ€»ç»“å¸¸ç”¨çš„ Normalization æ–¹æ³• æ·±åº¦å­¦ä¹ ä¸­çš„æ¨¡åž‹Dropout æˆ–è€…Dropconnect. å…¶ç†å¿µå°±æ˜¯åœ¨è®­ç»ƒä¸­éšæœºè®©ç¥žç»å…ƒæ— æ•ˆï¼ˆå³dropoutï¼‰æˆ–è®©ç½‘ç»œä¸­çš„è¿žæŽ¥æ— æ•ˆï¼ˆå³dropconnectï¼‰ã€‚è¿™ä¸ªæœ‰ç‚¹ç±»ä¼¼é›†æˆå­¦ä¹ ï¼Œæé«˜ç½‘ç»œæ¨¡åž‹çš„æ³›åŒ–æ€§èƒ½ï¼Œå‡å°‘è¿‡æ‹Ÿåˆçš„é—®é¢˜ã€‚ï¼ˆç±»ä¼¼bagging çš„æ€æƒ³ï¼Œä½¿ç”¨ä¸åŒçš„ç½‘ç»œç»“æž„åœ¨ä¸åŒçš„è®­ç»ƒé›†ä¸Šè¿›è¡Œè®­ç»ƒï¼‰.å¦‚æžœä»Žé›†æˆå­¦ä¹ è§’åº¦ç†è§£dropoutï¼Œé‚£ä¹ˆresnet ç½‘ç»œæ˜¯ä¸æ˜¯ä¹Ÿæœ‰ç‚¹é›†æˆå­¦ä¹ çš„å‘³é“ã€‚ Dropout çš„å…·ä½“æµç¨‹ é¦–å…ˆéšæœºï¼ˆä¸´æ—¶ï¼‰åˆ æŽ‰ç½‘ç»œä¸­ä¸€åŠçš„éšè—ç¥žç»å…ƒï¼Œè¾“å…¥è¾“å‡ºç¥žç»å…ƒä¿æŒä¸å˜ï¼ˆå›¾3ä¸­è™šçº¿ä¸ºéƒ¨åˆ†ä¸´æ—¶è¢«åˆ é™¤çš„ç¥žç»å…ƒï¼‰ ç„¶åŽæŠŠè¾“å…¥xé€šè¿‡ä¿®æ”¹åŽçš„ç½‘ç»œå‰å‘ä¼ æ’­ï¼Œç„¶åŽæŠŠå¾—åˆ°çš„æŸå¤±ç»“æžœé€šè¿‡ä¿®æ”¹çš„ç½‘ç»œåå‘ä¼ æ’­ã€‚ä¸€å°æ‰¹è®­ç»ƒæ ·æœ¬æ‰§è¡Œå®Œè¿™ä¸ªè¿‡ç¨‹åŽï¼Œåœ¨æ²¡æœ‰è¢«åˆ é™¤çš„ç¥žç»å…ƒä¸ŠæŒ‰ç…§éšæœºæ¢¯åº¦ä¸‹é™æ³•æ›´æ–°å¯¹åº”çš„å‚æ•°ï¼ˆwï¼Œbï¼‰ã€‚ ç„¶åŽç»§ç»­é‡å¤è¿™ä¸€è¿‡ç¨‹ æ¢å¤è¢«åˆ æŽ‰çš„ç¥žç»å…ƒï¼ˆæ­¤æ—¶è¢«åˆ é™¤çš„ç¥žç»å…ƒä¿æŒåŽŸæ ·ï¼Œè€Œæ²¡æœ‰è¢«åˆ é™¤çš„ç¥žç»å…ƒå·²ç»æœ‰æ‰€æ›´æ–°ï¼‰ ä»Žéšè—å±‚ç¥žç»å…ƒä¸­éšæœºé€‰æ‹©ä¸€ä¸ªä¸€åŠå¤§å°çš„å­é›†ä¸´æ—¶åˆ é™¤æŽ‰ï¼ˆå¤‡ä»½è¢«åˆ é™¤ç¥žç»å…ƒçš„å‚æ•°ï¼‰ã€‚ å¯¹ä¸€å°æ‰¹è®­ç»ƒæ ·æœ¬ï¼Œå…ˆå‰å‘ä¼ æ’­ç„¶åŽåå‘ä¼ æ’­æŸå¤±å¹¶æ ¹æ®éšæœºæ¢¯åº¦ä¸‹é™æ³•æ›´æ–°å‚æ•°ï¼ˆwï¼Œbï¼‰ ï¼ˆæ²¡æœ‰è¢«åˆ é™¤çš„é‚£ä¸€éƒ¨åˆ†å‚æ•°å¾—åˆ°æ›´æ–°ï¼Œåˆ é™¤çš„ç¥žç»å…ƒå‚æ•°ä¿æŒè¢«åˆ é™¤å‰çš„ç»“æžœï¼‰ã€‚ Dropout vs Dropconnectï¼š å®ƒä»¬çš„åŒºåˆ«å¤§ä½“åœ¨äºŽï¼Œåœ¨è®­ç»ƒè¿‡ç¨‹ä¸­dropoutæ˜¯éšæœºdropæŽ‰ä¸€äº›èŠ‚ç‚¹ï¼Œè€Œdropconnectåˆ™æ˜¯éšæœºdropæŽ‰ä¸€äº›è¾¹ã€‚ ä½¿ç”¨å¤šç§æ¨¡åž‹Baggingï¼š æœ€å…¸åž‹çš„å°±æ˜¯ éšæœºæ£®æž—( Random Forest)ï¼Œ é€šè¿‡ä¸ç›¸å…³çš„å†³ç­–æ ‘åœ¨ä¸åŒçš„æ•°æ®é›†ä¸Šè¿›è¡Œè®­ç»ƒï¼Œæœ€åŽçš„æ¯ä¸ªæ¨¡åž‹ä½¿ç”¨ç›¸åŒçš„æƒé‡æ¥â€œèžåˆâ€ã€‚Boosting: åœ¨ç®€å•çš„ç½‘ç»œä¸Šä¸æ–­æå‡ã€‚ æ€»ç»“é™ä½Žâ€œè¿‡æ‹Ÿåˆâ€çš„æ–¹æ³•ï¼šï¼ˆ1ï¼‰èŽ·å¾—æ›´å¤šçš„è®­ç»ƒæ•°æ®ï¼ˆ2ï¼‰é™ä½Žæ¨¡åž‹å¤æ‚åº¦ï¼ˆ3ï¼‰æ­£åˆ™åŒ–æ–¹æ³•ï¼ˆ4ï¼‰é›†æˆå­¦ä¹ æ–¹æ³•é™ä½Žâ€œæ¬ æ‹Ÿåˆâ€é£Žé™©çš„æ–¹æ³•ï¼šï¼ˆ1ï¼‰æ·»åŠ æ–°ç‰¹å¾ï¼ˆ2ï¼‰å¢žåŠ æ¨¡åž‹å¤æ‚åº¦ï¼ˆ3ï¼‰å‡å°æ­£åˆ™åŒ–ç³»æ•°]]></content>
      <categories>
        <category>Deep learning</category>
      </categories>
      <tags>
        <tag>overfit</tag>
        <tag>dropout</tag>
        <tag>normalization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ResNet and Inception V3 Understanding]]></title>
    <url>%2F2019%2F06%2F21%2Fresnet-understanding%2F</url>
    <content type="text"><![CDATA[æœ¬æ–‡ä»‹ç» ResNetçš„èƒŒæ™¯ï¼Œæƒ³è¦è§£å†³çš„é—®é¢˜ï¼ŒåŸºæœ¬æ€è·¯å’Œæ¡†æž¶ å’Œå¯¹äºŽå…¶çš„ä¸€ç§è§£è¯»æ–¹å¼ã€‚å¦å¤–ï¼Œå’Œ Resnet æ€è·¯ç›¸åçš„æ˜¯ Inception ç³»åˆ—ã€‚ èƒŒæ™¯ç½‘ç»œçš„æ·±åº¦æ˜¯å®¹æ˜“å‡ºçŽ°æ¢¯åº¦çˆ†ç‚¸å’Œæ¢¯åº¦æ¶ˆå¤±ï¼Œé€ æˆç½‘ç»œçš„ä¸æ”¶æ•›ã€‚ä¸€äº›æ–¹æ³•å·²ç»åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šå¯ä»¥ç¼“è§£è¿™ä¸ªé—®é¢˜ï¼Œæ¯”å¦‚ä½¿ç”¨ ReLUæ¿€æ´»å‡½æ•°ã€ è‰¯å¥½çš„æƒå€¼åˆå§‹åŒ–æ–¹æ³• ã€è¿˜æœ‰ intermediate normalization layers(å³ç½‘ç»œä¸­é—´çš„batch normalization)ã€‚å¹¶ä¸”å¯¹äºŽç½‘ç»œè¿‡ç¨‹ä¸­çš„è¿‡æ‹Ÿåˆé—®é¢˜ï¼Œä¹Ÿæå‡ºäº†ä¸€äº›åŠžæ³•å¦‚ï¼Œä½¿ç”¨ regularizationã€æƒå€¼è¡°å‡å’Œdropoutæ–¹æ³•ã€‚ ä½†è§£å†³äº†æ·±åº¦ç½‘ç»œæ”¶æ•›é—®é¢˜ä¹‹åŽï¼Œåˆå‡ºçŽ°äº†å¦å¤–ä¸€ä¸ªé—®é¢˜ã€‚ æ®‹å·®ç½‘ç»œè¦è§£å†³çš„é—®é¢˜ä¸€èˆ¬æ¥è¯´åœ¨æ²¡æœ‰è¿‡æ‹Ÿåˆçš„æƒ…å†µä¸‹ï¼Œå¯ä»¥é€æ­¥å¢žåŠ ç½‘ç»œçš„æ·±åº¦ã€‚ä½†åœ¨å®žéªŒä¸­å‘çŽ°äº†è¿™æ ·çš„é—®é¢˜ã€‚ç½‘ç»œé€€åŒ–ï¼š ç½‘ç»œè¶Šæ·±ï¼Œè®­ç»ƒè¯¯å·®è¶Šå¤§ã€‚ï¼ˆaccuracyå¼€å§‹é¥±å’Œï¼ŒåŽŸæ–‡ä¸­è¿™æ ·è¯´çš„ï¼‰è¿™ç§é€€åŒ–å¹¶ä¸æ˜¯ç”±äºŽè¿‡æ‹Ÿåˆé€ æˆçš„ï¼Œå¹¶ä¸”åœ¨é€‚å½“æ·±åº¦æ¨¡åž‹ä¸­å¢žåŠ æ›´å¤šçš„å±‚ä¼šå¯¼è‡´æ›´å¤šçš„è®­ç»ƒè¯¯å·® åŸºæœ¬æ€è·¯å’Œç»“æž„ä½œè€…åŸºäºŽå¢žåŠ å±‚å¦‚æžœä¸ºæ’ç­‰æ˜ å°„é‚£ä¹ˆæ›´æ·±å±‚ç½‘ç»œä¸åº”è¯¥æ¯”æµ…å±‚ç½‘ç»œäº§ç”Ÿæ›´é«˜é”™è¯¯çŽ‡çš„æ€æƒ³ å¦‚å›¾æ‰€ç¤ºå·¦è¾¹çš„æ˜¯ä¼ ç»Ÿçš„plain networksçš„ç»“æž„ï¼Œå³è¾¹çš„æ˜¯ä¿®æ”¹ä¸ºResNetçš„ç»“æž„ã€‚æ”¹å˜å‰ç›®æ ‡ï¼š è®­ç»ƒ F(x) é€¼è¿‘ H(x)æ”¹å˜åŽç›®æ ‡ï¼šè®­ç»ƒ F(x) é€¼è¿‘ H(x) -x å³å¢žåŠ ä¸€ä¸ªidentity mappingï¼ˆæ’ç­‰æ˜ å°„ï¼‰ï¼Œå°†åŽŸå§‹æ‰€éœ€è¦å­¦çš„å‡½æ•°H(x)è½¬æ¢æˆF(x)+xï¼Œè€Œä½œè€…è®¤ä¸ºè¿™ä¸¤ç§è¡¨è¾¾çš„æ•ˆæžœç›¸åŒï¼Œä½†æ˜¯ä¼˜åŒ–çš„éš¾åº¦å´å¹¶ä¸ç›¸åŒï¼Œä½œè€…å‡è®¾F(x)çš„ä¼˜åŒ– ä¼šæ¯”H(x)ç®€å•çš„å¤šã€‚è¿™ä¸€æƒ³æ³•ä¹Ÿæ˜¯æºäºŽå›¾åƒå¤„ç†ä¸­çš„æ®‹å·®å‘é‡ç¼–ç ï¼Œé€šè¿‡ä¸€ä¸ªreformulationï¼Œå°†ä¸€ä¸ªé—®é¢˜åˆ†è§£æˆå¤šä¸ªå°ºåº¦ç›´æŽ¥çš„æ®‹å·®é—®é¢˜ï¼Œèƒ½å¤Ÿå¾ˆå¥½çš„èµ·åˆ°ä¼˜åŒ–è®­ç»ƒçš„æ•ˆæžœ åœ¨è®ºæ–‡ä¸­å°è¯•äº† skip 2å±‚æˆ–è€… 3å±‚ ä¸€ç§è§£è¯»æ–¹å¼æ®‹å·®ç½‘ç»œå•å…ƒå…¶ä¸­å¯ä»¥åˆ†è§£æˆå³å›¾çš„å½¢å¼ï¼Œä»Žå›¾ä¸­å¯ä»¥çœ‹å‡ºï¼Œæ®‹å·®ç½‘ç»œå…¶å®žæ˜¯ç”±å¤šç§è·¯å¾„ç»„åˆçš„ä¸€ä¸ªç½‘ç»œï¼Œç›´ç™½äº†è¯´ï¼Œæ®‹å·®ç½‘ç»œå…¶å®žæ˜¯å¾ˆå¤šå¹¶è¡Œå­ç½‘ç»œçš„ç»„åˆï¼Œæ•´ä¸ªæ®‹å·®ç½‘ç»œå…¶å®žç›¸å½“äºŽä¸€ä¸ªå¤šäººæŠ•ç¥¨ç³»ç»Ÿï¼ˆEnsemblingï¼‰ ä»Žè¿™å¯ä»¥çœ‹å‡ºå…¶å®žResNetæ˜¯ç”±å¤§å¤šæ•°ä¸­åº¦ç½‘ç»œå’Œä¸€å°éƒ¨åˆ†æµ…åº¦ç½‘ç»œå’Œæ·±åº¦ç½‘ç»œç»„æˆçš„ï¼Œ è¯´æ˜Žè™½ç„¶è¡¨é¢ä¸ŠResNetç½‘ç»œå¾ˆæ·±ï¼Œä½†æ˜¯å…¶å®žèµ·å®žé™…ä½œç”¨çš„ç½‘ç»œå±‚æ•°å¹¶æ²¡æœ‰å¾ˆæ·±æˆ‘ä»¬å¯ä»¥çœ‹å‡ºå¤§å¤šæ•°çš„æ¢¯åº¦å…¶å®žéƒ½é›†ä¸­åœ¨ä¸­é—´çš„è·¯å¾„ä¸Šï¼Œè®ºæ–‡é‡Œç§°ä¸ºeffective pathã€‚ (ç½‘ç»œè¶Šæ·±ï¼Œä¹Ÿæ˜¯å®¹æ˜“å‡ºçŽ°æ¢¯åº¦æ¶ˆå¤±æˆ–è€…æ¢¯åº¦çˆ†ç‚¸ï¼Œè¿™ä¸ªæ˜¯æ²¡æœ‰é—®é¢˜çš„)ResNetå…¶å®žå°±æ˜¯ä¸€ä¸ªå¤šäººæŠ•ç¥¨ç³»ç»Ÿã€‚ çŽ°åœ¨æ·±åº¦ç½‘ç»œåŸºæœ¬ä¸Šåˆ†æˆä¸¤ä¸ªæ–¹å‘ï¼Œä¸€ä¸ªåƒ resnet å‘ç€â€æ·±åº¦â€œå‘å±•ï¼Œä¸€ä¸ªå‘ç€â€å®½åº¦â€œçš„inception network Inception V3å¦‚æžœ ResNet æ˜¯ä¸ºäº†æ›´æ·±ï¼Œé‚£ä¹ˆ Inception å®¶æ—å°±æ˜¯ä¸ºäº†æ›´å®½ã€‚ç¬¬ä¸€ä¸ªè§è§£ä¸Žå¯¹å±‚çš„æ“ä½œæœ‰å…³ã€‚åœ¨ä¼ ç»Ÿçš„å·ç§¯ç½‘ç»œä¸­ï¼Œæ¯ä¸€å±‚éƒ½ä¼šä»Žä¹‹å‰çš„å±‚æå–ä¿¡æ¯ï¼Œä»¥ä¾¿å°†è¾“å…¥æ•°æ®è½¬æ¢æˆæ›´æœ‰ç”¨çš„è¡¨å¾ã€‚ è§è§£ 1ï¼šä¸ºä»€ä¹ˆä¸è®©æ¨¡åž‹é€‰æ‹©ï¼Ÿ è¿™ç§æ¨¡åž‹æž¶æž„çš„ä¿¡æ¯å¯†åº¦æ›´å¤§äº†ï¼Œè¿™å°±å¸¦æ¥äº†ä¸€ä¸ªçªå‡ºçš„é—®é¢˜ï¼šè®¡ç®—æˆæœ¬å¤§å¤§å¢žåŠ ã€‚ä¸ä»…å¤§åž‹ï¼ˆæ¯”å¦‚ 5Ã—5ï¼‰å·ç§¯è¿‡æ»¤å™¨çš„å›ºæœ‰è®¡ç®—æˆæœ¬é«˜ï¼Œå¹¶æŽ’å †å å¤šä¸ªä¸åŒçš„è¿‡æ»¤å™¨æ›´ä¼šæžå¤§å¢žåŠ æ¯ä¸€å±‚çš„ç‰¹å¾æ˜ å°„çš„æ•°é‡ã€‚è€Œè¿™ç§è®¡ç®—æˆæœ¬å¢žé•¿å°±æˆä¸ºäº†æˆ‘ä»¬æ¨¡åž‹çš„è‡´å‘½ç“¶é¢ˆã€‚ è¿™å°±æ¶‰åŠåˆ°äº†è§è§£ 2ï¼šä½¿ç”¨ 1Ã—1 å·ç§¯æ¥æ‰§è¡Œé™ç»´ã€‚ä¸ºäº†è§£å†³ä¸Šè¿°è®¡ç®—ç“¶é¢ˆï¼ŒInception çš„ä½œè€…ä½¿ç”¨äº† 1Ã—1 å·ç§¯æ¥ã€Œè¿‡æ»¤ã€è¾“å‡ºçš„æ·±åº¦ã€‚ä¸€ä¸ª 1Ã—1 å·ç§¯ä¸€æ¬¡ä»…æŸ¥çœ‹ä¸€ä¸ªå€¼ï¼Œä½†åœ¨å¤šä¸ªé€šé“ä¸Šï¼Œå®ƒå¯ä»¥æå–ç©ºé—´ä¿¡æ¯å¹¶å°†å…¶åŽ‹ç¼©åˆ°æ›´ä½Žçš„ç»´åº¦ã€‚æ¯”å¦‚ï¼Œä½¿ç”¨ 20 ä¸ª 1Ã—1 è¿‡æ»¤å™¨ï¼Œä¸€ä¸ªå¤§å°ä¸º 64Ã—64Ã—100ï¼ˆå…·æœ‰ 100 ä¸ªç‰¹å¾æ˜ å°„ï¼‰çš„è¾“å…¥å¯ä»¥è¢«åŽ‹ç¼©åˆ° 64Ã—64Ã—20ã€‚é€šè¿‡å‡å°‘è¾“å…¥æ˜ å°„çš„æ•°é‡ï¼ŒInception å¯ä»¥å°†ä¸åŒçš„å±‚å˜æ¢å¹¶è¡Œåœ°å †å åˆ°ä¸€èµ·ï¼Œä»Žè€Œå¾—åˆ°æ—¢æ·±åˆå®½ï¼ˆå¾ˆå¤šå¹¶è¡Œæ“ä½œï¼‰çš„ç½‘ç»œã€‚ Inception Net v3 incorporated all of the above upgrades stated for Inception v2, and in addition used the following: RMSProp Optimizer. Factorized 7x7 convolutions. BatchNorm in the Auxillary Classifiers. Label Smoothing (A type of regularizing component added to the loss formula that prevents the network from becoming too confident about a class. Prevents over fitting).]]></content>
      <categories>
        <category>Deep learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Interview Questions]]></title>
    <url>%2F2019%2F06%2F21%2Finterview-questions%2F</url>
    <content type="text"><![CDATA[é¢è¯•ä¸­çš„éžæŠ€æœ¯ç±»é—®é¢˜ã€‚ é¢è¯•ä¸­æœ€é‡è¦çš„æ˜¯å’Œé¢è¯•å®˜è¿›è¡Œäº’åŠ¨ï¼Œäº’ç›¸äº†è§£çš„è¿‡ç¨‹ã€‚å¦‚æžœä¸€æ–¹è¯´çš„è¿‡å¤šï¼Œé‚£ä¹ˆè¿™ä¸ªé¢è¯•ä»ç„¶æ˜¯ä¸æˆåŠŸçš„ã€‚åœ¨äº’åŠ¨çš„è¿‡ç¨‹ä¸­ï¼Œä¹Ÿæ˜¯å¯ä»¥å­¦ä¹ åˆ°å¾ˆå¤šçš„ã€‚ â€œä½ æœ‰ä»€ä¹ˆé—®é¢˜æƒ³è¦é—®æˆ‘å—ï¼Ÿâ€ ä¸è¦åšçš„äº‹æƒ…å¦‚ä¸‹ï¼š åƒä¸‡ä¸è¦é—®å°ç™½é—®é¢˜ï¼ˆå‡¡æ˜¯å®˜ç½‘ä¸Šã€åº¦å¨˜ä¸Šèƒ½å¤ŸèŽ·å–çš„ä¿¡æ¯éƒ½æ˜¯å°ç™½é—®é¢˜ï¼‰ã€‚ä½†æ˜¯ä½ åŸºäºŽèŽ·å¾—çš„çŸ¥è¯†ï¼Œè¿›ä¸€æ­¥æå‡ºè‡ªå·±çš„è§‚ç‚¹å’Œçœ‹æ³•ï¼Œé‚£ä¹ˆè¿™ä¸ªå°±æ˜¯ä¸€ä¸ªæ¯”è¾ƒå¥½çš„é—®é¢˜ã€‚ ä¸è¦é—®å¯¹æ–¹æ— æ³•ç»™å‡ºä½ ç­”æ¡ˆçš„é—®é¢˜ã€‚æ¯”å¦‚ä¸è¦é—® HRéƒ¨é—¨çš„å…·ä½“ä¸šåŠ¡ï¼Œä¸è¦é—®æŠ€æœ¯é¢è¯•å®˜ å…³äºŽè–ªé…¬çš„é—®é¢˜ã€‚ å¤§çš„å‰ææ˜¯æ ¹æ®é¢è¯•å®˜çš„èº«ä»½ï¼Œå›´ç»•ç€åº”è˜èŒä½è¿›è¡Œæé—®ã€‚æ¯”å¦‚è¯´é—®HR å…¬å¸æ˜¯å¦æœ‰é’ˆå¯¹æŠ€æœ¯æ–¹é¢çš„ä¸€äº›åŸ¹è®­åˆ¶åº¦ï¼Œå›¢å»ºä¹‹ç±»çš„ï¼Œæƒ³è¦äº†è§£ä¸€ä¸‹å…¬å¸çš„æ°›å›´å’Œä¼ä¸šæ–‡åŒ– â€œé¢è¯•ä¸­çš„è‡ªæˆ‘è¯„ä»·â€ ä¸»è¦ä»Žä»¥ä¸‹çš„ä¸‰ä¸ªæ–¹é¢å…¥æ‰‹ï¼š æœ‰è‡ªå·±çš„ä¼˜ç‚¹ï¼Œæ¯”å¦‚è¯´è‡ªå·±å¼€æœ—ï¼Œå…·æœ‰åˆä½œç²¾ç¥žï¼Œé‚£ä¹ˆæœ€å¥½æœ‰äº‹ä¾‹è¿›è¡Œè¯´æ˜Ž å’Œæ‹›è˜å²—ä½åŒ¹é…ç¨‹åº¦ ä¸ªäººçš„ç¼ºç‚¹ï¼Œå½“ç„¶è¿™ä¸ªç¼ºç‚¹ä¸æ˜¯è‡´å‘½çš„ï¼Œæ˜¯å¯ä»¥è¿›è¡Œè½¬æŠ˜çš„é‚£ç§ â€œä¸ºä»€ä¹ˆé€‰ä½ ï¼Œè€Œä¸æ˜¯åˆ«äººâ€ è¿™æœ¬æ¥æ˜¯é¢è¯•å®˜çš„èŒè´£ï¼Œé‚£ä¹ˆæ—¢ç„¶é—®äº†ï¼Œå…¶å®žæ˜¯åˆ›æ–°æ€§çš„å¸…é”…ç»™äº†å€™é€‰äººï¼Œé¢è¯•å®˜å¸¦ç€â€œè¯æ˜Žä½ é…å¾—ä¸Šè¿™åˆ†å·¥ä½œâ€çš„å¿ƒæ€åŽ»æé—®ï¼Œè¦ä¹ˆæ˜¯æ‡’ï¼Œè¦ä¹ˆæ˜¯æš—ç¤ºè¿™ä¸ªå²—ä½å¾ˆçƒ­é—¨ã€‚ æ—¢ç„¶æ˜¯è¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬èƒ½åšå°±æ˜¯ä¸“æ³¨äºŽæˆ‘å¯ä»¥æ€Žä¹ˆæ ·â€¦ å› ä¸ºåˆ«äººçš„ä¿¡æ¯ä½ ä¹Ÿæ˜¯æ— æ³•å›žç­”çš„ã€‚æœ‰ä»¥ä¸‹å‡ ä¸ªåå¥—è·¯å‡ºå‘ç‚¹ ä»Žå·¥ä½œå†…å®¹å‡ºå‘å¦‚æžœä½ å·²ç»é¢äº†ä¸€é¢ã€äºŒé¢ï¼Œå¯¹äºŽè‡ªå·±åšçš„äº‹æƒ…æœ‰äº†ä¸€ä¸ªæ¯”è¾ƒæ¸…æ™°çš„è®¤è¯†ï¼Œé‚£ä¹ˆä½ å¯ä»¥è¯´â€¦ è¿™ä¸ªèŒä½çš„å·¥ä½œå†…å®¹ï¼Œæ­£æ˜¯æˆ‘æ¯”è¾ƒç†Ÿæ‚‰å’Œæ“…é•¿çš„ã€‚éœ€è¦ä½¿ç”¨å…·ä½“çš„äº‹å®žæ¡ˆä¾‹è¿›è¡Œè¯æ˜Žã€‚ çœŸè¯šåé—®ï¼Œåˆ›é€ äº’åŠ¨å¦‚æžœä¸æ˜¯å¾ˆæ¸…æ¥šå²—ä½çš„éœ€æ±‚ï¼Œé‚£ä¹ˆä¸Šé¢çš„æ–¹å¼å°±ä¸è¡Œï¼Œè¿™ä¸ªæ—¶å€™éœ€è¦åˆ›é€ äº’åŠ¨ã€‚ç®€å•è‡ªæˆ‘ä»‹ç»ä¸€ä¸‹ï¼Œç„¶åŽè¯´â€œæˆ‘æ­£æƒ³å’Œæ‚¨æŽ¢è®¨ä¸€ä¸‹ï¼Œ æ‚¨è®¤ä¸ºåšå¥½è¿™ä¸ªå·¥ä½œï¼Œå€™é€‰äººåº”è¯¥å…·å¤‡æ€Žæ ·çš„æ¡ä»¶ï¼Ÿâ€ å¦‚æžœæåˆ°çš„æ˜¯è‡ªå·±çš„ä¼˜åŠ¿ï¼Œé‚£ä¹ˆå°±ä½¿ç”¨äº‹ä¾‹è¯æ˜Žä¸€ä¸‹ï¼›å¦‚æžœæ˜¯è‡ªå·±çš„å¼±é¡¹ï¼Œé‚£ä¹ˆç®€å•çš„è¯´ä¸€ä¸‹ï¼Œç„¶åŽè¯´è‡ªå·±æ˜¯å¦‚ä½•æé«˜å’Œæ”¹è¿›ï¼Œå±•ç¤ºçš„å¥½å­¦çš„ä¸€é¢ï¼Œæœ€å¥½æ˜¯æœ‰ä¾‹å­è¯æ˜Žã€‚ æœ€åŽå¦‚æžœèŠå¾—æ¯”è¾ƒæ¥ï¼Œè‡ªå·±ç­”é¢˜ä¸é”™çš„è¯ï¼Œé‚£ä¹ˆå¯ä»¥åœ¨ç»“æŸçš„æ—¶å€™è¡¥ä¸Šä¸€å¥ï¼šâ€œæˆ‘å†’æ˜§é—®ä¸€å¥ï¼Œæ‚¨ä¹Ÿé¢è¯•äº†ä¸€äº›å€™é€‰äººï¼Œæ‚¨è§‰å¾—æˆ‘çš„æœºä¼šå¤§å—ï¼Ÿâ€ â€œä½ æœ€å¤§çš„ç¼ºç‚¹æ˜¯ä»€ä¹ˆâ€œ æ‹›è˜æœ¬èº«å°±æ˜¯ç”¨äººä¹‹é•¿ï¼Œå¼¥è¡¥è‡ªèº«çš„ç¼ºé™·ã€‚é¢è¯•å®˜ç©¶ç«Ÿæƒ³è¦ä»€ä¹ˆï¼Ÿ å€™é€‰äººåœ¨å›žç­”è¿™ç§åˆé’»é—®é¢˜æ—¶ï¼Œå¾ˆå–œæ¬¢é¿é‡å°±è½»ï¼šâ€œæˆ‘æœ€å¤§çš„ç¼ºç‚¹ï¼Œå°±æ˜¯å¤ªè¾ƒçœŸï¼Œå¯¹ç»†èŠ‚è¦æ±‚å¤ªé«˜â€â€œæˆ‘æœ€å¤§çš„ç¼ºç‚¹æ˜¯å¤ªæ‹¼äº†ï¼Œä¸æ³¨æ„èº«ä½“â€é¢â€¦â€¦è¿™æ°æ°ä¸­äº†é¢è¯•å®˜çš„å¥—è·¯ï¼šâ€œè¿™ä½å€™é€‰äººä¸å¤ŸçœŸè¯šã€‚â€ å¯¹äºŽå€™é€‰äººæ¥è¯´ï¼Œæˆ‘æŽ¨èä¸¤ç§æ›´åŠ çœŸè¯šçš„å›žç­”å¥—è·¯ï¼ˆå¯¹ï¼Œå¥—è·¯ä¹Ÿå¯ä»¥çœŸè¯šï¼‰ã€‚æ­£ç¡®çš„æ–¹å¼- è®²ä¸€ä¸ªçœŸå®žå­˜åœ¨çš„ç¼ºé™·ï¼Œä½†å¼ºè°ƒä½ å·²ç»æ„è¯†åˆ°ï¼Œå¹¶å·²ç»åœ¨æ”¹å–„äº†ã€‚â€¦.. ï¼ˆéœ€è¦æœ‰äº‹ä¾‹è¿›è¡Œè¯´æ˜Žï¼‰è¿™ç§æ–¹å¼ï¼Œæ—¢èƒ½è®©é¢è¯•å®˜æ„Ÿå—åˆ°ä½ çš„çœŸè¯šï¼Œä¹Ÿèƒ½è®©é¢è¯•å®˜è§‰å¾—ä½ æ˜¯å¯¹è‡ªå·±æœ‰æ¸…é†’çš„è®¤è¯†åŒæ—¶å·²ç»å¼€å§‹è¡ŒåŠ¨ï¼Œæ˜¯ä¸€ä¸ªæ¯”è¾ƒè¸å®žçš„å€™é€‰äººã€‚ è¯´åˆ°åº•ï¼Œä¼ä¸šæ‹›äººæ˜¯æ‹›äººä¹‹é•¿ï¼Œå¦‚æžœä½ çš„é•¿å¤„æ˜¯ä¼ä¸šæ€¥éœ€çš„ï¼Œé‚£ä¹ˆä½ çš„å¼±ç‚¹å¹¶éžè‡´å‘½ï¼Œé¢è¯•å®˜è¿˜æ˜¯å¾ˆå¸Œæœ›å¾—åˆ°ä½ çš„ã€‚ â€è¯·ç®€å•çš„ä»‹ç»ä¸€ä¸‹è‡ªå·±â€œ å½“é¢è¯•å®˜é—®å‡ºè¿™ç§é—®é¢˜çš„æ—¶å€™ï¼Œæˆ‘çš„ç¬¬ä¸€ååº”å°±æ˜¯ï¼šè¿™ä¸ªé¢è¯•å®˜æ²¡æœ‰æå‰é˜…è¯»æˆ‘çš„ç®€åŽ†ã€‚æˆ‘å¸Œæœ›é¢è¯•å®˜æ˜¯é˜…è¯»äº†çš„ï¼Œç„¶è€Œï¼Œæˆ‘ä¹Ÿæ¸…æ¥šè¿™å‡ çŽ‡å¾ˆä½Žã€‚ æ‰€ä»¥è§è¯å¥—è·¯çš„æ—¶å€™åˆ°äº†ï¼Œç®€å•çš„è‡ªæˆ‘ä»‹ç»ï¼Œæˆ‘æ¥è‡ªâ€¦ ä¹‹å‰åŽ»â€¦ åšè¿‡â€¦å·¥ä½œï¼Œç„¶åŽåœ¨â€¦ çœ‹åˆ°ä½ ä»¬æ‹›è˜â€¦ å²—ä½ï¼Œè§‰å¾—è¿™ä¸ªæ˜¯ä¸€ä¸ªä¸é”™çš„æœºä¼šï¼Œæ‰€ä»¥æŠ•äº†ç®€åŽ†ã€‚æˆ‘æƒ³ç®€å•é—®æ‚¨ä¸€ä¸ªé—®é¢˜ï¼Œå¯ä»¥å—ï¼Ÿæ‚¨è¿™ä¸ªèŒä½æ˜¯æ–°è®¾ç½®ï¼Œè¿˜æ˜¯ä¹‹å‰çš„åŒäº‹ç¦»èŒå‘¢ï¼Ÿ â€è¦å’Œé¢è¯•å®˜è¿›è¡Œäº’åŠ¨ï¼Œé¢è¯•å®˜è¯´çš„è¶Šå¤šï¼Œé‚£ä¹ˆæˆåŠŸçš„å¯èƒ½æ€§æ˜¯è¶Šå¤§çš„ï¼Œä¸æ˜¯ä¸€æ˜§çš„å¬ï¼Œè€Œæ˜¯åˆ›é€ å’Œé¢è¯•å®˜ä¹‹é—´çš„æœ‰æœºçš„äº’åŠ¨â€ å¥½çš„é¢è¯•å¦‚åŒè€å‹é‡é€¢åœ¨Central Perkï¼Œäº’ç›¸å°Šé‡äº’ç›¸ç†è§£ï¼Œå³ä½¿åšä¸æˆåŒäº‹ï¼Œæ²¡å‡†è¿˜å¯ä»¥åšæœ‹å‹ã€‚æˆ‘ä»¬å¹³æ—¶å’Œå°ä¼™ä¼´ä»¬è°ˆç¬‘é£Žç”Ÿï¼Œå¯ä»¥å‹å¥½çš„æé—®ï¼Œä¹Ÿå¯ä»¥å¼€å–„æ„çš„çŽ©ç¬‘ã€‚ä½†åˆ°äº†é¢è¯•æ—¶ï¼Œä¸ºä»€ä¹ˆè¦æŠ±ç€æ­»æ¿çš„å¿ƒæ€ç”Ÿç¡¬å°´èŠå‘¢ï¼Ÿåœ¨è¿™ä¸€ç‚¹ä¸Šæˆ‘å€’æ˜¯å¾ˆèµžèµéƒ¨åˆ†äº’è”ç½‘å…¬å¸çš„é«˜ç®¡ï¼Œ ä»–ä»¬æŠ±ç€å¼€æ”¾çš„æ€åº¦å’Œå€™é€‰äººèŠå·¥ä½œç”šè‡³èŠäººç”Ÿï¼Œä¹Ÿæ„¿æ„ç»™å€™é€‰äººæä¾›è‡ªå·±çš„å»ºè®®ã€‚ â€œä½ èƒ½åœ¨å…¬å¸å¾…å¤šä¹…â€ å¯¹è¿™ä¸ªå…¬å¸å‘å±•çš„å‰æ™¯æ¯”è¾ƒæ„Ÿå…´è¶£ï¼Œæˆ‘ä¹Ÿå¸Œæœ›èƒ½ç»™å…¬å¸å¸¦æ¥ç‚¹ä»€ä¹ˆï¼Œèƒ½å¤Ÿå‘æŒ¥ä½œç”¨ï¼›åªè¦åŒæ–¹éƒ½è§‰å¾—æœ‰æ”¶èŽ·ï¼Œåšçš„äº‹æƒ…æœ‰æŒ‘æˆ˜æœ‰æ„ä¹‰ï¼Œå°±éƒ½æ˜¯okçš„ã€‚ â€œä½ å¸Œæœ›è¿™ä¸ªèŒä½çš„è–ªæ°´æ˜¯å¤šå°‘â€ è¿™ä¸ªæ˜¯ä¸€ä¸ªå¾®å¦™çš„é—®é¢˜ï¼Œåœ¨æ¡ä»¶å…è®¸çš„æƒ…å†µä¸‹ï¼Œå°½å¯èƒ½çš„æ‹–å»¶ç»™å‡ºä¸€ä¸ªç²¾ç¡®çš„æ•°æ®æ¥å›žç­”è¿™ä¸ªé—®é¢˜ã€‚ä½ å¯ä»¥è¯´ï¼Œæˆ‘çŸ¥é“è¿™ä¸ªå·¥ä½œçš„è–ªæ°´å¤§æ¦‚èŒƒå›´æ˜¯.. åˆ°â€¦ã€‚ æˆ–è€…æ‚¨èƒ½å¦é€éœ²ä¸€ä¸‹å…¬å¸ä¸­å¯¹ç›¸ä¼¼èŒä½çš„å·¥ä½œçš„è–ªæ°´å¤§æ¦‚æ˜¯ä»€ä¹ˆæ ·å­çš„å‘¢ï¼Ÿ å¦‚æžœé¢è¯•å®˜ç»§ç»­è¿½é—®ï¼Œé‚£ä¹ˆä½ è¯´â€œæˆ‘çŽ°åœ¨çš„è–ªæ°´æ˜¯â€¦ å’Œå…¶ä»–äººä¸€æ ·ï¼Œæˆ‘å¸Œæœ›èƒ½å¤Ÿæå‡è¿™ä¸ªæ•°å­—ï¼Œä½†æˆ‘ä¸»è¦çš„å…´è¶£è¿˜æ˜¯åœ¨å·¥ä½œæœ¬èº«â€ è¦è®°ä½æ–°çš„å·¥ä½œæœ¬èº«å¹¶ä¸ä¼šä½¿å¾—ä½ èµšåˆ°æ›´å¤šçš„é’±ã€‚ åœ¨ä½ é¢è¯•è¿‡ç¨‹ä¸­çš„æœ€åŽä¸€ä¸ªé˜¶æ®µä¹‹å‰ï¼Œå°‘è°ˆè–ªæ°´çš„é—®é¢˜ã€‚å› ä¸ºåˆ°äº†é‚£ä¸ªæ—¶å€™ä½ å°±æ¸…æ¥šï¼Œå¦‚æžœå…¬å¸å¯¹ä½ æœ‰å¾ˆå¤§çš„å…´è¶£ï¼Œé‚£ä¹ˆè¿™ä¸ªæ—¶å€™è–ªæ°´å¾…é‡å°±æœ‰å¾ˆå¤§çš„ä½™åœ°ã€‚ â€œå¦‚ä½•çœ‹å¾…åŠ ç­ï¼Ÿâ€å¦‚æžœç‰¹æ®Šæ—¶æœŸé¡¹ç›®éœ€è¦ä¸Šçº¿ä¹‹ç±»ï¼Œé‚£ä¹ˆå¶å°”åŠ ç­æ˜¯å¯ä»¥æŽ¥å—çš„ï¼Œä½†æ˜¯å¦‚æžœå¼ºåˆ¶é•¿æœŸåŠ ç­ï¼Œé‚£è¿˜æ˜¯ç®—äº†ã€‚å½“ç„¶ï¼Œå¦‚æžœè‡ªå·±è´Ÿè´£çš„äº‹æƒ…å‡ºäº†é—®é¢˜ï¼Œå³ä½¿å…¬å¸æ²¡æœ‰è¦æ±‚åŠ ç­ï¼Œé‚£ä¹ˆè‡ªå·±ä¹Ÿæ˜¯ä¼šä¸»åŠ¨åŠ ç­æŠŠäº‹æƒ…å¼„å¥½ï¼Œå°½è‡ªå·±æœ€å¤§çš„åŠªåŠ›ä¿è¯é¡¹ç›®ä¸å»¶æœŸã€‚ æœ€å¥½çš„æ–¹å¼æ˜¯å‡­ç€å·¥ä½œèƒ½åŠ›è¯´è¯ï¼Œè®©åˆ«äººè§‰å¾—èƒ½åŠ›ok ä¸åŠ ç­ä¹Ÿæ˜¯æŠŠå·¥ä½œåšå®Œåšå¥½çš„ã€‚ ç›®å‰å›¢é˜Ÿå·¥ä½œæ°›å›´æ€Žä¹ˆæ ·ï¼Ÿ åŠ ç­æƒ…å†µå¦‚ä½•ï¼Ÿä¹‹ç±»çš„æ˜¯å¯ä»¥æå‰é—®ä¸€ä¸‹çš„ã€‚å¦‚æžœè‡ªå·±æ€¥éœ€å·¥ä½œï¼Œå…ˆæ‹¿ä¸‹å·¥ä½œä¹‹åŽå†è¯´ï¼Œç­‰è‡ªå·±ç¼“å’Œä¸€ä¸‹å†è°‹å‡ºè·¯ã€‚ æœ€åŽçš„å‘é—®ï¼Ÿä½ ä»¬å°ç»„æ˜¯å¹²ä»€ä¹ˆï¼Œæœ‰ä»€ä¹ˆä¸šåŠ¡äº§å“ï¼Ÿå›¢é˜Ÿæ€Žä¹ˆæ ·ï¼Ÿå¦‚æžœæˆ‘æ¯”è¾ƒå¹¸è¿èƒ½å¤Ÿæ¥ç€å·¥ä½œçš„è¯ï¼Œé‚£ä¹ˆä¸»è¦åšå“ªäº›æ–¹é¢çš„å·¥ä½œï¼Ÿ]]></content>
      <categories>
        <category>NOT_FOR_YOU</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[å‰‘æŒ‡Offer-æ ˆã€é˜Ÿåˆ—ã€é“¾è¡¨å’Œæ ‘]]></title>
    <url>%2F2019%2F06%2F17%2F%E5%89%91%E6%8C%87Offer-%E6%A0%88-%E9%98%9F%E5%88%97-%E9%93%BE%E8%A1%A8%E5%92%8C%E6%A0%91%2F</url>
    <content type="text"><![CDATA[è¿™æ˜¯å‰‘æŒ‡offer ç³»åˆ—å››éƒ¨æ›²ä¸­çš„ç¬¬äºŒéƒ¨ï¼šæ ˆã€é˜Ÿåˆ—ã€é“¾è¡¨å’Œæ ‘ã€‚ç¬¬ä¸€éƒ¨å…³äºŽå­—ç¬¦ä¸²å’Œæ•°ç»„ï¼Œç¬¬ä¸‰éƒ¨æ˜¯é€’å½’ã€å›žæº¯å’ŒåŠ¨æ€è§„åˆ’ï¼Œ æœ€åŽä¸€éƒ¨åˆ†åœ¨è¿™é‡Œã€‚ ä»Žå°¾åˆ°å¤´æ‰“å°é“¾è¡¨ è¾“å…¥ä¸€ä¸ªé“¾è¡¨ï¼ŒæŒ‰é“¾è¡¨å€¼ä»Žå°¾åˆ°å¤´çš„é¡ºåºè¿”å›žä¸€ä¸ªArrayListã€‚ æ­£å‘éåŽ†ä¹‹åŽï¼Œä½¿ç”¨çš„æ˜¯python ä¸­listçš„ç‰¹æ€§ï¼Œ list[::-1] è¿™æ ·è¿›è¡Œè¾“å‡ºçš„ã€‚ 123456789101112131415161718# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # è¿”å›žä»Žå°¾éƒ¨åˆ°å¤´éƒ¨çš„åˆ—è¡¨å€¼åºåˆ—ï¼Œä¾‹å¦‚[1,2,3] # += , -= è¿™ä¸ªéƒ½æ˜¯åŒä¸€ç§ç±»åž‹çš„ def printListFromTailToHead(self, listNode): # write code here arraylist =[] head = listNode while head != None: arraylist += [head.val] # è¿™ä¸ªåœ¨è¿™é‡Œç­‰æ•ˆäºŽ arraylist.append(head.val) head = head.next return arraylist[::-1] åœ¨çº¿ç¼–ç¨‹ä¸­å¾ˆå°‘è€ƒå¯Ÿæ ‘çš„ç»“æž„ã€‚æ‰€ä»¥å°±ä¸å†™ main å‡½æ•°ç‰ˆæœ¬äº†ã€‚ 12345678910111213class Solution &#123;public: // è·Ÿæˆ‘çš„æƒ³æ³•æ˜¯ä¸€æ ·çš„ï¼Œé¦–å…ˆéåŽ†ä¸€éï¼Œç„¶åŽç¿»è½¬ï¼Œc++ ä¸­çš„reverse æ“ä½œ vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; vector&lt;int&gt; res; while(head) &#123; res.push_back(head-&gt;val); head =head-&gt;next; &#125; return vector&lt;int&gt;(res.rbegin(), res.rend()); &#125;&#125;; é‡å»ºäºŒå‰æ ‘ (ç»å…¸ï¼Œ å¤šæ•²å¤šèƒŒè¯µ) è¾“å…¥æŸäºŒå‰æ ‘çš„å‰åºéåŽ†å’Œä¸­åºéåŽ†çš„ç»“æžœï¼Œè¯·é‡å»ºå‡ºè¯¥äºŒå‰æ ‘ã€‚å‡è®¾è¾“å…¥çš„å‰åºéåŽ†å’Œä¸­åºéåŽ†çš„ç»“æžœä¸­éƒ½ä¸å«é‡å¤çš„æ•°å­—ã€‚ä¾‹å¦‚è¾“å…¥å‰åºéåŽ†åºåˆ—{1,2,4,7,3,5,6,8}å’Œä¸­åºéåŽ†åºåˆ—{4,7,2,1,5,3,8,6}ï¼Œåˆ™é‡å»ºäºŒå‰æ ‘å¹¶è¿”å›žã€‚ Tips: é€’å½’ï¼ŒäºŒå‰æ ‘çš„é¢˜ç›®å¤§å¤šæ•°éƒ½æ˜¯å¯ä»¥ä½¿ç”¨é€’å½’çš„æ€æƒ³è¿›è¡Œè§£å†³ï¼Œå› ä¸ºäºŒå‰æ ‘æœ¬èº«ç»“æž„å°±æ˜¯é€’å½’å®šä¹‰çš„ã€‚é€’å½’ä¼˜ç‚¹åœ¨äºŽä»£ç é‡æ¯”è¾ƒå°‘ã€‚ä»Žå…ˆåºéåŽ†ä¸­æ‰¾å‡ºæ ¹èŠ‚ç‚¹ï¼Œä»Žä¸­åºéåŽ†ä¸­æ‰¾å‡ºå·¦å³å­æ ‘ åˆ«æ€•ï¼Œæ‰‹å†™ä¸­å¦‚ä½•é‡å»ºäºŒå‰æ ‘ï¼Œåœ¨ä»£ç ä¸­å°±æ˜¯å¦‚ä½•å®žçŽ°é‡å»ºäºŒå‰æ ‘çš„ã€‚é¦–å…ˆä»Žå‰åºlist ä¸­æ‰¾åˆ°å¤´ç»“ç‚¹ï¼Œç„¶åŽä»Žä¸­åºé˜Ÿåˆ—ä¸­æ‰¾è§å¯¹åº”èŠ‚ç‚¹çš„indexï¼Œé‚£ä¹ˆå‰é¢çš„å°±æ˜¯å¤´ç»“ç‚¹çš„å·¦å­æ ‘ï¼ŒåŽé¢çš„å°±æ˜¯å³å­æ ‘ã€‚ 12345678910111213141516171819202122# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # è¿”å›žæž„é€ çš„TreeNodeæ ¹èŠ‚ç‚¹ # éœ€è¦ç†è§£åœ¨å‰åºéåŽ†ä¸­æ˜¯å…ˆéåŽ†å·¦å­æ ‘çš„ï¼Œå¹¶ä¸”ä¸­åºå’Œå‰åºä¸­å·¦å­æ ‘çš„ä¸ªæ•°æ˜¯ä¸ä¼šå˜çš„ def reConstructBinaryTree(self, pre, tin): # write code here if len(pre) == 0: return None root = TreeNode(pre[0]) # è¿™ä¸ªindex å‡½æ•°æ˜¯éœ€è¦è®°ä½çš„ index = tin.index(pre[0]) # è¿™é‡Œä¹Ÿæ˜¯éœ€è¦ä¿®æ”¹çš„ # pre å’Œ tinéƒ½æ˜¯éœ€è¦ç©ºå‡ºä¸€ä¸ª root.value çš„ä½ç½®ï¼Œåªä¸è¿‡é€‰æ‹©ç©ºçš„ä½ç½®æ˜¯ä¸ä¸€æ ·çš„ root.left = self.reConstructBinaryTree(pre[1:index + 1], tin[:index]) root.right = self.reConstructBinaryTree(pre[index + 1:], tin[index + 1:]) return root ä¼˜åŒ–ç‚¹ï¼šå¿«é€Ÿçš„åœ¨ä¸­åºè¡¨ä¸­æ‰¾è§æŸä¸ªæ•°çš„ä½ç½®ã€‚ä½¿ç”¨hash è¡¨å®žçŽ°ã€‚ æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n)$ 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: map&lt;int, int&gt; hash; vector&lt;int&gt; preorder, inorder; TreeNode* reConstructBinaryTree(vector&lt;int&gt; _pre,vector&lt;int&gt; _vin) &#123; preorder =_pre, inorder =_vin; // æ–¹ä¾¿éåŽ† for(int i =0; i&lt; inorder.size(); i++) hash[inorder[i]] =i; return dfs(0, preorder.size() -1, 0, inorder.size() -1); &#125; TreeNode* dfs(int pl, int pr, int il, int ir) &#123; if(pl &gt; pr) return nullptr; auto root =new TreeNode(preorder[pl]); int k =hash[root-&gt;val]; auto left =dfs(pl +1, pl+k -il,il, k-1); // ä¸­åºå’Œå‰åºå¯¹äºŽ å·¦å­æ ‘çš„è¡¨ç¤º auto right =dfs(pl+k-il+1, pr, k+1, ir); root-&gt;left =left, root-&gt;right =right; return root; &#125; &#125;; ç”¨ä¸¤ä¸ªæ ˆå®žçŽ°é˜Ÿåˆ— ï¼ˆç»å…¸ï¼‰ ç”¨ä¸¤ä¸ªæ ˆæ¥å®žçŽ°ä¸€ä¸ªé˜Ÿåˆ—ï¼Œå®Œæˆé˜Ÿåˆ—çš„Pushå’ŒPopæ“ä½œã€‚ é˜Ÿåˆ—ä¸­çš„å…ƒç´ ä¸ºintç±»åž‹ã€‚ Tipsï¼š åœ¨python ä¸­æ ˆç­‰åŒäºŽä½¿ç”¨list å®žçŽ°ã€‚ä½¿ç”¨ä¸¤ä¸ªæ ˆï¼Œæ„å‘³ç€ä¸€ä¸ªæ˜¯push_stack ä¸€ä¸ªæ˜¯pop_stackï¼Œä½¿ç”¨ä¸¤ä¸ªæ ˆçš„â€œåŽè¿›å…ˆå‡ºâ€è¡¨ç¤ºé˜Ÿåˆ—çš„å…ˆè¿›å…ˆå‡ºï¼ˆpush and popï¼‰ä»Žè¯­æ³•ä¸Šè®² ï¼Œif list1 ==[], é‚£ä¹ˆ list1 ==None, è¿™ä¸¤ä¸ªæ¡ä»¶æ˜¯å¯ä»¥äº¤æ¢åˆ¤æ–­çš„ã€‚ï¼ˆåœ¨list ä¸­ï¼‰ 12345678910111213141516171819class Solution: def __init__(self): self.list1 =[] self.list2 =[] def push(self, node): # write code here self.list1.append(node) def pop(self): # return if not self.list1 and not self.list2 : return None if self.list2 : return self.list2.pop() else: while self.list1: self.list2.append(self.list1.pop()) return self.list2.pop() c++ å®žçŽ°ã€‚ Â·Â·Â·c++class Solution{ // ä½¿ç”¨ä¸€ä¸ªè¾…åŠ©æ ˆ cache è¿›è¡Œpop() çš„æ“ä½œpublic: void push(int node) { stack1.push(node); } void copy(stack&lt;int&gt; &amp;a, stack&lt;int&gt; &amp;b) { while(a.size()) { // ä»Žä¸€ä¸ªæ ˆåˆ°å¦ä¸€ä¸ªæ ˆçš„è½¬æ¢ï¼Œè¿™æ ·å°±å®žçŽ°äº† ç”¨æ ˆè¡¨ç¤ºé˜Ÿåˆ— // è®¿é—®æœºåˆ¶æ˜¯ å…ˆtop() è®¿é—®ï¼Œç„¶åŽæ˜¯ pop() è¿›è¡Œå¼¹å‡º b.push(a.top()); a.pop(); } } int pop() { copy(stack1, cache); int res =cache.top(); cache.pop(); copy(cache, stack1); return res; } private: stack stack1; stack cache;};Â·Â·Â· é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªç»“ç‚¹ è¾“å…¥ä¸€ä¸ªé“¾è¡¨ï¼Œè¾“å‡ºè¯¥é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªç»“ç‚¹ã€‚ Tipsï¼š ä¸¤ç§è§£æ³•ã€‚ä¸€ç§æ˜¯éåŽ†å­˜å‚¨åˆ°list ä¸­ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯O(N), å¦å¤–ä¸€ç§æ˜¯ä¸¤ä¸ªæŒ‡é’ˆp1ï¼Œp2ï¼Œè·ç¦»ç›¸å·®kï¼Œå½“p2 åˆ°è¾¾é“¾è¡¨å°¾éƒ¨ï¼Œp1 å°±åœ¨å¯¼æ•°ç¬¬k ä¸ªä½ç½®ã€‚ 1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = None"""å°è¯•ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆç‰ˆæœ¬p1 p2 å¹¶ä¸”è¿™ç§ length åœ¨å‘½åä¸Šæ˜¯éœ€è¦è§„èŒƒçš„, å¹¶ä¸”è¿™ç§æŒ‡é’ˆæ“ä½œï¼Œæœ€å¥½æ˜¯æ‹·è´å‡ºæ¥è¿›è¡Œæ“ä½œä¸ç®¡æ€Žä¹ˆè¯´ï¼Œè¿˜æ˜¯åº”è¯¥æ±‚è§£å‡ºæ¥ length of listNodeï¼Œè¿™ç§æ‰æ˜¯æ­£é€”å¯ä»¥ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆï¼Œ"""class Solution: def FindKthToTail(self, head, k): # write code here if head == None or k &lt;= 0: return None p1 = head p2 = head len1 = 0 while p1: len1 += 1 p1 = p1.next if k &gt; len1: return None p1 = head while k: p1 = p1.next k -= 1 while p1: p1 = p1.next p2 = p2.next return p2 æœ‰ä¸¤ç§æ€è·¯ï¼Œä¸€ç§æ˜¯æ­£å‘éåŽ†ä¸€éï¼Œå­˜å‚¨åˆ°list ä¸­ï¼Œç„¶åŽä½¿ç”¨list æ€§è´¨ï¼Œè¿”å›žå€’æ•°ç¬¬k ä¸ªç»“ç‚¹ï¼Œè¿™ä¸ªç©ºé—´å¤æ‚åº¦æ˜¯ $O(n)$ã€‚è¿˜æœ‰ä¸€ç§æ€è·¯æ˜¯ éåŽ†ä¸€éå¾—åˆ°é“¾è¡¨çš„é•¿åº¦ï¼Œç„¶åŽå€’æ•°ç¬¬ k ä¸ªç»“ç‚¹å°±æ˜¯æ­£å‘æ•° n-k +1 ä¸ªç»“ç‚¹ï¼Œå†æ¬¡éåŽ†ä¸€éå°±å¯ä»¥è¿”å›žã€‚ 123456789101112131415161718192021/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* FindKthToTail(ListNode* head, unsigned int k) &#123; int n =0; for(auto p =head ; p; p =p-&gt;next) n++; //å¯¹äºŽå¤æ‚çš„æ•°æ®ç±»åž‹ï¼Œç›´æŽ¥ä½¿ç”¨ auto è¿™ç§æ–¹å¼è¿›è¡Œå®šä¹‰å°±å¯ä»¥äº† if(k &gt;n) return nullptr; // è¿™ä¸ªæ˜¯ä¸€ä¸ªç»†èŠ‚ï¼Œä½†æ˜¯ç‰›å®¢ç½‘ä¸Šæ²¡æœ‰æ˜¾ç¤ºï¼Œå¦‚æžœ k æ˜¯è¶…è¿‡æ€»çš„é•¿åº¦é‚£ä¹ˆæ€Žä¹ˆåŠž auto p =head; for(int i =0; i&lt;n-k; i++) p =p-&gt;next; return p; &#125;&#125;; åè½¬é“¾è¡¨ è¾“å…¥ä¸€ä¸ªé“¾è¡¨ï¼Œåè½¬é“¾è¡¨åŽï¼Œè¾“å‡ºæ–°é“¾è¡¨çš„è¡¨å¤´ã€‚ Tipsï¼š éœ€è¦ä¸‰ä¸ªæŒ‡é’ˆï¼Œcurï¼Œnext_node, preã€‚ ç®€å•çš„é“¾è¡¨çš„ä¿®æ”¹ï¼Œæœ€åŽæ–°çš„è¡¨å¤´å°±æ˜¯ä¸€å¼€å§‹çš„å°¾èŠ‚ç‚¹ã€‚ 1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = None"""ä¿®æ”¹é“¾è¡¨æ˜¯éœ€è¦ä¸‰ä¸ªæŒ‡é’ˆçš„ pre, cur, next_node å¦‚æžœå¯¹ä¸‰ä¸ªæŒ‡é’ˆåè¿›è¡Œå‘½åå¥½äº†ï¼Œé‚£ä¹ˆè¿™ä¸ªå°±æ˜¯æˆåŠŸçš„ä¸€èˆ¬äº†ï¼Œ è¿™ä¸ªä¸å®¹æ˜“æƒ³åˆ°çš„æ˜¯è®¾ç½®pre =None ï¼Œè¿™ä¸ªæ˜¯ä¸€ä¸ªç»†èŠ‚ç»éªŒæ€§çš„é—®é¢˜"""class Solution: # è¿”å›žListNode def ReverseList(self, pHead): # write code here if pHead ==None: return None pre =None cur =pHead while cur: next_node =cur.next cur.next =pre pre, cur =cur, next_node return pre å•é“¾è¡¨ä¸­éœ€è¦è®°å½•ä¸€ä¸ªå‰é©±ç»“ç‚¹ã€‚è¿™ä¸ªæ˜¯è€ƒç‚¹æ‰€åœ¨ã€‚è¿™ä¸ªæ˜¯æ²¡æœ‰é—®é¢˜çš„ã€‚ 123456789101112131415161718192021222324252627/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* ReverseList(ListNode* head) &#123; // è¿™ä¸ªauto çš„å…³é”®å­— ä¸èƒ½æ˜¯åœ¨ç¨‹åºæœªçŸ¥çš„æƒ…å†µä¸‹ä½¿ç”¨ï¼Œåº”è¯¥æ˜¯åœ¨â€œå¯çŸ¥â€çš„æƒ…å†µä¸‹ä½¿ç”¨ ListNode* pre =nullptr; auto cur =head; while(cur) &#123; auto next =cur-&gt;next; cur-&gt;next =pre; pre =cur; // è¿™ä¸ªæ—¶å€™éœ€è¦éåŽ† cur æŒ‡é’ˆ cur =next; &#125; return pre; &#125;&#125;; åˆå¹¶ä¸¤ä¸ªæŽ’åºçš„é“¾è¡¨ Tipsï¼š å½’å¹¶æŽ’åºä¸­çš„â€œå¹¶â€ æ“ä½œï¼Œåªä¸è¿‡ç”±åŽŸæ¥çš„list æ“ä½œåˆ°çŽ°åœ¨çš„ linkedlist æ“ä½œã€‚ è¾“å…¥ä¸¤ä¸ªå•è°ƒé€’å¢žçš„é“¾è¡¨ï¼Œè¾“å‡ºä¸¤ä¸ªé“¾è¡¨åˆæˆåŽçš„é“¾è¡¨ï¼Œå½“ç„¶æˆ‘ä»¬éœ€è¦åˆæˆåŽçš„é“¾è¡¨æ»¡è¶³å•è°ƒä¸å‡è§„åˆ™ã€‚ 123456789101112131415161718192021222324252627282930313233# def __init__(self, x):# self.val = x# self.next = None"""å°±æ˜¯åœ¨ä½¿ç”¨ä¸¤ä¸ªæˆ–è€…å¤šä¸ª index (p1 or p2) éåŽ†çš„æ—¶å€™ï¼Œä¸€ä¸ªå¸¸è§çš„é”™è¯¯å°±æ˜¯å¿˜è®°äº†ä¸æ–­æ›´æ–°index"""class Solution: # è¿”å›žåˆå¹¶åŽåˆ—è¡¨ def Merge(self, pHead1, pHead2): # write code here if pHead1 == None: return pHead2 if pHead2 == None: return pHead1 head = ListNode(-1) head1 = head p1 = pHead1 p2 = pHead2 while p1 and p2: if p1.val &lt; p2.val: head.next = p1 p1 = p1.next else: head.next = p2 p2 = p2.next head = head.next if p1 == None: head.next = p2 if p2 == None: head.next = p1 return head1.next å½’å¹¶æŽ’åºçš„åŽŸç†ï¼Œåˆå¹¶ä¸¤ä¸ªæœ‰åºçš„æ•°ç»„æˆ–è€…é“¾è¡¨ï¼Œä½¿ç”¨çº¿æ€§çš„å¤æ‚åº¦å°±å¯ä»¥ä½¿ç”¨ã€‚ å½’å¹¶æŽ’åºä¸­while ä¸­ä½¿ç”¨çš„if elseï¼Œ ç„¶åŽä¸¤ä¸ªwhile åˆ¤æ–­è¾¹ç•Œæ¡ä»¶ã€‚ å¿«æŽ’ä¸­ while å¾ªçŽ¯é‡Œé¢åµŒå¥—çš„æ˜¯ä¸¤ä¸ªwhile æŽ’åºã€‚è¿™ä¸¤ä¸ªæŽ’åºç®—æ³•åº”è¯¥æ˜¯ç¢Žè§‰éƒ½æ˜¯ååˆ†ç†Ÿæ‚‰çš„ï¼Œæ€Žä¹ˆå¯ä»¥è¿™æ ·å‘¢ï¼Ÿæ¯å¤©éƒ½æ˜¯è¦å¤šå¤ä¹ çš„ã€‚ 1234567891011121314151617181920212223242526272829303132333435/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* Merge(ListNode* p1, ListNode* p2) &#123; auto dummy =new ListNode(-1); // è™šæ‹Ÿç»“ç‚¹ auto cur =dummy; while(p1 &amp;&amp; p2) &#123; if(p1-&gt;val &lt; p2-&gt; val) &#123; cur -&gt; next= p1; cur =cur-&gt;next; p1 =p1-&gt;next; &#125; else &#123; cur -&gt; next =p2; cur =cur-&gt;next; p2 =p2-&gt;next; &#125; &#125; if (p1) cur-&gt;next =p1; else cur-&gt;next =p2; return dummy-&gt;next; &#125;&#125;; æ ‘çš„å­ç»“æž„ è¾“å…¥ä¸¤æ£µäºŒå‰æ ‘Aï¼ŒBï¼Œåˆ¤æ–­Bæ˜¯ä¸æ˜¯Açš„å­ç»“æž„ã€‚ï¼ˆpsï¼šæˆ‘ä»¬çº¦å®šç©ºæ ‘ä¸æ˜¯ä»»æ„ä¸€ä¸ªæ ‘çš„å­ç»“æž„ï¼‰ é€’å½’å®šä¹‰ï¼Œæ ¹èŠ‚ç‚¹æ˜¯å¦ç›¸åŒï¼Œå·¦å³å­æ ‘æ˜¯å¦ç›¸åŒã€‚ 12345678910111213141516171819202122232425262728293031323334# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None"""åˆ†æˆä¸¤éƒ¨ï¼šé¦–å…ˆå¯»æ‰¾ä¸¤ä¸ªæ ¹èŠ‚ç‚¹çš„å€¼æ˜¯å¦ç›¸åŒï¼›ç„¶åŽåˆ¤æ–­å­æ ‘æ˜¯å¦å®Œå…¨ç›¸åŒsubTree è¿™ä¸ªå‡½æ•°å°±æ˜¯åˆ¤æ–­å­æ ‘æ˜¯å¦å®Œå…¨ç›¸åŒçš„ï¼Œæ‰€ä»¥å‡½æ•°çš„åŠŸèƒ½ä¸€å®šè¦æžå¥½"""class Solution: def HasSubtree(self, pRoot1, pRoot2): if not pRoot1: return False if not pRoot2: return False result =False if pRoot1.val ==pRoot2.val: result =self.subTree(pRoot1, pRoot2) if result ==False: result = self.HasSubtree(pRoot1.left, pRoot2) or self.HasSubtree(pRoot1.right, pRoot2) return result def subTree(self, root1, root2): if not root2: return True if not root1: return False if root1.val ==root2.val: return self.subTree(root1.left, root2.left) and self.subTree(root1.right, root2.right) return False ä»Žå­—ç¬¦ä¸²çš„åŒ¹é… æ‰©å±•äº† æ ‘çš„åŒ¹é… 12345678910111213141516171819202122232425262728293031/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: bool HasSubtree(TreeNode* root1, TreeNode* root2) &#123; if ( !root1 || !root2 ) return false; // è¿™ä¸ªæ˜¯å¯»æ‰¾æ ¹èŠ‚ç‚¹çš„è¿‡ç¨‹ if(isPart(root1, root2)) return true; return HasSubtree(root1-&gt; left, root2) || HasSubtree(root1-&gt; right, root2); &#125; bool isPart(TreeNode *p1, TreeNode *p2) &#123; // æ‰¾åˆ°ä¸€ä¸ªæ ¹èŠ‚ç‚¹ç›¸åŒï¼Œç„¶åŽä¸æ–­å¾€ä¸‹éåŽ†çš„è¿‡ç¨‹ if (!p2) return true; if(!p1 || p1-&gt;val != p2-&gt; val) return false; return isPart(p1-&gt;left, p2-&gt;left) &amp;&amp; isPart(p1-&gt;right, p2-&gt;right); &#125;&#125;;// å…ˆæ˜¯éåŽ†æ‰¾ç›¸åŒçš„æ ¹èŠ‚ç‚¹ï¼Œ// å¦‚æžœç›¸åŒçš„è¯ï¼ŒæŽ¥ç€åŽ»æ‰¾ç›¸åº”çš„å·¦å³å­æ ‘æ˜¯å¦ç›¸åŒ ç¬¬äºŒé1234567891011121314151617181920212223242526272829/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: //å…ˆæ˜¯éåŽ†æ ¹èŠ‚ç‚¹ï¼Œç„¶åŽå†éåŽ†å¯¹åº”æ ¹èŠ‚ç‚¹çš„å·¦å³ç»“ç‚¹ bool HasSubtree(TreeNode* root1, TreeNode* root2) &#123; if( !root1 || ! root2) return false; if(isSub(root1, root2)) return true; return HasSubtree(root1-&gt; left, root2) || HasSubtree(root1-&gt; right, root2); &#125; bool isSub(TreeNode * root1, TreeNode * root2) &#123; if( !root2) return true; if( ! root1 || root1-&gt;val != root2-&gt;val) return false; return isSub(root1-&gt; left, root2-&gt; left) &amp;&amp; isSub(root1-&gt; right, root2-&gt; right); &#125;&#125;; äºŒå‰æ ‘çš„é•œåƒ æ“ä½œç»™å®šçš„äºŒå‰æ ‘ï¼Œå°†å…¶å˜æ¢ä¸ºæºäºŒå‰æ ‘çš„é•œåƒã€‚ Tipsï¼šæ±‚è§£äºŒå‰æ ‘é•œåƒï¼ŒA çš„å·¦å­æ ‘å¯¹åº”ç€B çš„å³å­æ ‘ã€‚ 123456789101112131415161718192021# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None"""å°±æ˜¯åœ¨æŸä¸ªå·¦ï¼ˆå³ï¼‰å­æ ‘æ˜¯None çš„æƒ…å†µä¸‹ï¼Œè¿™ä¸ªä¹Ÿæ˜¯å¯ä»¥è¿›è¡Œäº¤æ¢çš„ï¼Œç»“æŸçš„æ ‡å¿—åº”è¯¥æ˜¯æ ¹èŠ‚ç‚¹æ˜¯å¦ä¸ºç©º"""class Solution: # è¿”å›žé•œåƒæ ‘çš„æ ¹èŠ‚ç‚¹ def Mirror(self, root): # write code here if not root: return None root.left , root.right =root.right, root.left if root.left: self.Mirror(root.left) if root.right: self.Mirror(root.right) return root ä»»æ„ä¸€ä¸ªç»“ç‚¹çš„å·¦å³å­æ ‘éƒ½å‘ç”Ÿäº’æ¢ã€‚ 12345678910111213141516171819202122/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: // ç‰¹ç‚¹ï¼Œä»»æ„ä¸€ä¸ªç»“ç‚¹ï¼Œå·¦å³å­æ ‘éƒ½æ˜¯ç›¸åçš„ // äº’æ¢çš„è¿‡ç¨‹åº”è¯¥æ˜¯ ä»Žä¸‹åˆ°ä¸Šè¿›è¡Œçš„ï¼Œæ‰€ä»¥æ˜¯ä¸æ–­çš„è¿›è¡Œé€’å½’ï¼Œç„¶åŽæœ€åŽä¸€ä¸ªæ˜¯ swap() æ“ä½œ void Mirror(TreeNode *pRoot) &#123; if ( ! pRoot) return ; Mirror(pRoot -&gt; left); Mirror(pRoot -&gt; right); swap(pRoot -&gt; left, pRoot-&gt; right); &#125;&#125;; åŒ…å«minå‡½æ•°çš„æ ˆ å®šä¹‰æ ˆçš„æ•°æ®ç»“æž„ï¼Œè¯·åœ¨è¯¥ç±»åž‹ä¸­å®žçŽ°ä¸€ä¸ªèƒ½å¤Ÿå¾—åˆ°æ ˆä¸­æ‰€å«æœ€å°å…ƒç´ çš„minå‡½æ•°ï¼ˆæ—¶é—´å¤æ‚åº¦åº”ä¸ºOï¼ˆ1ï¼‰ï¼‰ã€‚ Tips: è¿™ä¸ªè·Ÿâ€œä½¿ç”¨ä¸¤ä¸ªæ ˆè¡¨ç¤ºé˜Ÿåˆ—â€ æ˜¯å·®ä¸å¤šçš„ï¼Œå°±æ˜¯å•ç‹¬ä½¿ç”¨ä¸€ä¸ªlist å­˜å‚¨min å‡½æ•°è°ƒç”¨çš„ä¸€ä¸ªåˆ—è¡¨ï¼Œè¿™æ ·çš„è¯èƒ½è¾¾åˆ°æ—¶é—´å¤æ‚åº¦æ˜¯ O(1). åœ¨åŽŸæ¥çš„åŸºç¡€ä¸Šï¼Œstack çš„åŸºç¡€ä¸Šï¼Œä½¿ç”¨æ–°çš„ min_stack æ»¡è¶³è¿™ä¸ªéœ€æ±‚ï¼ŒåŒæ ·ï¼ŒåŽŸæ¥çš„ push pop è¿™ç§æ“ä½œè¿˜æ˜¯ä¸èƒ½å°‘çš„ã€‚æ‰€ä»¥æ˜¯ç»´æŠ¤äº†ä¸¤ä¸ª listï¼ˆnormal_list, min_listï¼‰ï¼Œä½†æ˜¯å½“normal_list pop() å‡ºæ¥çš„æ—¶å€™ï¼Œè¿™ä¸ªmin_list å’Œå…¶pop å‡ºæ¥çš„ä¸ä¸€å®šæ˜¯ç›¸åŒçš„å€¼ã€‚ï¼ˆæˆ‘æ„Ÿè§‰ï¼‰ 1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-"""è¿™ä¸ªæ ˆä¸­æœ€å°çš„å…ƒç´ æ˜¯å˜åŒ–çš„ï¼Œå¥½å¥½ç†è§£ä¸€ä¸‹ï¼Œå¦‚æžœå¼¹å‡ºäº†ä¸€ä¸ªæ¯”è¾ƒå¤§çš„å…ƒç´ ï¼Œé‚£ä¹ˆæ ˆä¸­æœ€å°çš„å…ƒç´ æ˜¯ä¸å˜çš„æ‰€å«å…ƒç´ çš„æœ€å°å…ƒç´ top() and min() æ“ä½œæ˜¯ä¸éœ€è¦åˆ é™¤å…ƒç´ çš„ï¼Œ pop æ˜¯åˆ é™¤äº†å…ƒç´ """class Solution: def __init__(self): self.all_list = [] self.min_list = [] def push(self, node): # write code here if not self.min_list: self.min_list.append(node) else: self.min_list.append(min(node, self.min())) # å¥½å¤šæ€æƒ³éƒ½æ˜¯åŸºäºŽä¹‹å‰çš„ç»“æžœè¿›è¡Œæ±‚è§£ self.all_list.append(node) def pop(self): self.all_list.pop() self.min_list.pop() # write code here def top(self): return self.all_list[-1] # write code here def min(self): return self.min_list[-1] 123456789101112131415161718192021222324252627class Solution &#123;public: // å…³é”®åœ¨äºŽç»´æŠ¤ä¸¤ä¸ª stack stack&lt;int&gt; stk, stk_min; // è¿™ä¸ªæ˜¯æœ€é‡è¦çš„functionäº† void push(int value) &#123; stk.push(value); //if( stk_min.size()) value = value&lt; stk_min.top() ? value, stk_min.top(); if(stk_min.size()) value =std::min(value, stk_min.top()); stk_min.push(value); &#125; void pop() &#123; stk.pop(); stk_min.pop(); &#125; int top() &#123; return stk.top(); &#125; int min() &#123; return stk_min.top(); &#125;&#125;; æ ˆçš„åŽ‹å…¥ã€å¼¹å‡ºåºåˆ— è¾“å…¥ä¸¤ä¸ªæ•´æ•°åºåˆ—ï¼Œç¬¬ä¸€ä¸ªåºåˆ—è¡¨ç¤ºæ ˆçš„åŽ‹å…¥é¡ºåºï¼Œè¯·åˆ¤æ–­ç¬¬äºŒä¸ªåºåˆ—æ˜¯å¦å¯èƒ½ä¸ºè¯¥æ ˆçš„å¼¹å‡ºé¡ºåºã€‚å‡è®¾åŽ‹å…¥æ ˆçš„æ‰€æœ‰æ•°å­—å‡ä¸ç›¸ç­‰ã€‚ä¾‹å¦‚åºåˆ—1,2,3,4,5æ˜¯æŸæ ˆçš„åŽ‹å…¥é¡ºåºï¼Œåºåˆ—4,5,3,2,1æ˜¯è¯¥åŽ‹æ ˆåºåˆ—å¯¹åº”çš„ä¸€ä¸ªå¼¹å‡ºåºåˆ—ï¼Œä½†4,3,5,1,2å°±ä¸å¯èƒ½æ˜¯è¯¥åŽ‹æ ˆåºåˆ—çš„å¼¹å‡ºåºåˆ—ã€‚ï¼ˆæ³¨æ„ï¼šè¿™ä¸¤ä¸ªåºåˆ—çš„é•¿åº¦æ˜¯ç›¸ç­‰çš„ï¼‰ Tips: ä½¿ç”¨ä¸€ä¸ªlist æ¥æ¨¡æ‹ŸåŽ‹å…¥å’Œå¼¹å‡ºè¿‡ç¨‹ï¼ŒéåŽ†å¼¹å‡ºåºåˆ—popVï¼Œå¦‚æžœç»“æŸï¼Œé‚£ä¹ˆreturn Trueã€‚ 12345678910111213def IsPopOrder( pushV, popV): if not pushV: return False tmp =[] while popV: if tmp and popV[0] == tmp[-1]: popV.pop(0) tmp.pop() elif pushV: tmp.append(pushV.pop(0)) else: return False return True æ˜¯ä¸€ç§æ¨¡æ‹Ÿé¢˜ï¼Œå› ä¸ºé€‰æ‹©æ˜¯å”¯ä¸€çš„ï¼Œå¯¹åº”æŸç§æƒ…å†µï¼Œé‚£ä¹ˆæ“ä½œæ˜¯ä¸€å®šçš„ã€‚ä½¿ç”¨ä¸€ä¸ª æ ˆæ¨¡æ‹Ÿæ•´ä¸ªæ“ä½œã€‚ 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stack&gt;using namespace std;bool isPopOrder(vector&lt;int&gt; pushV, vector&lt;int&gt; popV)&#123; if(pushV.size() != popV.size()) return false; stack&lt;int&gt; stk; int i =0; for(auto u: pushV) &#123; stk.push(u); while(stk.size() &amp;&amp; stk.top() == popV[i]) &#123; //cout&lt;&lt; stk.top()&lt;&lt;" "&lt;&lt; endl; //cout&lt;&lt; stk.top() &lt;&lt;" "&lt;&lt; i&lt;&lt; endl; stk.pop(); i ++; &#125; &#125; return stk.empty();&#125;int main()&#123; vector&lt;int&gt; pushV=&#123;1, 2, 3, 4, 5&#125;; vector&lt;int&gt; popV=&#123;4, 5, 3, 2, 1&#125;; cout&lt;&lt; isPopOrder(pushV, popV)&lt;&lt; endl; return 0;&#125; ä»Žä¸Šå¾€ä¸‹æ‰“å°äºŒå‰æ ‘ ä»Žä¸Šå¾€ä¸‹æ‰“å°å‡ºäºŒå‰æ ‘çš„æ¯ä¸ªèŠ‚ç‚¹ï¼ŒåŒå±‚èŠ‚ç‚¹ä»Žå·¦è‡³å³æ‰“å°ã€‚ Tipsï¼š å±‚æ¬¡éåŽ†ï¼ŒéåŽ†æ ¹èŠ‚ç‚¹ä¹‹åŽåŠ å…¥å·¦å³ç»“ç‚¹ã€‚ 123456789101112131415161718192021222324# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # è¿”å›žä»Žä¸Šåˆ°ä¸‹æ¯ä¸ªèŠ‚ç‚¹å€¼åˆ—è¡¨ï¼Œä¾‹ï¼š[1,2,3] # å±‚åºéåŽ†äºŒå‰æ ‘ï¼Œ è¿™ä¸ªè·Ÿæ•°æ®ç»“æž„ é˜Ÿåˆ—æœ‰ç±»ä¼¼çš„ # nodes è£…ä¸Šç»“ç‚¹ï¼Œç„¶åŽvlaues è£…ä¸Šæ•°å€¼ def PrintFromTopToBottom(self, root): # write code here if not root: return [] nodes =[] values = [] nodes.append(root) while nodes: node = nodes.pop(0) values.append(node.val) if node.left: nodes.append(node.left) if node.right: nodes.append(node.right) return values å¥½çš„æ–¹æ³•ï¼Œå°±æ˜¯æžšä¸¾å‡ºæ¥çš„æ–¹æ³•ï¼Œå¤§å®¶éƒ½æ˜¯è¿™ä¸ªæ˜¯ç»å…¸çš„ç®—æ³•ï¼Œä½†æ˜¯è¿™ç§ä¸€å¼€å§‹çš„ intuitionï¼Œè¿™ç§ idea æ˜¯æ€Žä¹ˆå‡ºæ¥çš„ã€‚ä¸€èˆ¬æ˜¯æ²¡æœ‰äººåŽ»æ€Žä¹ˆæè¿°çš„ã€‚æ‰€ä»¥ï¼Œæ˜¯è¦è¿½æ ¹æº¯æºçš„ã€‚å¯¹äºŽä¸€ä¸ªé—®é¢˜ï¼Œä¸€å…±æœ‰å“ªäº›æ–¹æ³•æ˜¯åœ¨è¿™ä¸ªèŒƒç•´ï¼Œå“ªäº›æ˜¯å¯ä»¥ç”¨çš„ã€‚æŽ’é™¤ä¸€ä¸ªè®¤ä¸ºä¸å¯èƒ½çš„ï¼Œç„¶åŽå°±å¼€å§‹å°è¯•ã€‚ é¢˜ç›®è¦æ±‚æ˜¯ä¸€ç§å±‚åºéåŽ†ã€‚å¯¹äºŽæ ‘çš„éåŽ†æ˜¯æœ‰æ·±æœ å’Œå®½æœä¸¤ç§æ–¹å¼ï¼Œå‘çŽ°ç¥žæœä¸åˆé€‚ï¼Œå®½æœæ­£å¥½ï¼Œæ‰€ä»¥ä½¿ç”¨å®½åº¦ä¼˜å…ˆæœç´¢ã€‚å¯¹äºŽå®½åº¦ä¼˜å…ˆæœç´¢æ˜¯éœ€è¦ç»´æŠ¤ä¸€ä¸ªé˜Ÿåˆ—ã€‚ 123456789101112131415161718192021222324252627282930313233/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: // é˜Ÿåˆ—ä¸­çš„æ“ä½œ queue, front() è®¿é—®ï¼Œ pop() åˆ é™¤ vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123; vector&lt;int&gt; res; if( !root) return res; queue&lt;TreeNode*&gt; qu; qu.push(root); while(qu.size()) &#123; auto t =qu.front(); qu.pop(); res.push_back(t-&gt;val); if(t-&gt;left) qu.push(t-&gt;left); if(t-&gt;right) qu.push(t-&gt;right); &#125; return res; &#125;&#125;; å±‚åºéåŽ†ï¼ŒæŠŠäºŒå‰æ ‘æ‰“å°æˆå¤šè¡Œï¼ˆè¿™ä¸ªæ˜¯è¾“å‡ºæ˜¯å¤šè¡Œï¼Œè€Œä¸æ˜¯ä¸€è¡Œï¼‰c++ å®žçŽ°ã€‚é‡ç‚¹ä½¿ç”¨äº† nullptr æŒ‡é’ˆè¿›è¡Œäº†å°¾éƒ¨çš„æ ‡è®°ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: // æ‰“å°æˆå¤šè¡Œï¼Œæ‰€ä»¥åœ¨æ¯è¡Œæ‰“å°çš„æ—¶å€™ï¼Œæ¯è¡Œçš„æœ€åŽå¯ä»¥åŠ å…¥ä¸€ä¸ª nullptr ä½œä¸ºç»“æŸ vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(! pRoot) return res; queue&lt;TreeNode*&gt; qu; qu.push(pRoot); qu.push(nullptr); vector&lt;int&gt; level; //åˆ¤æ–­ queue æ˜¯å¦ä¸ºç©ºçš„æ¡ä»¶ while(qu.size()) &#123; auto t =qu.front(); qu.pop(); if(! t) &#123; if(level.empty()) break; res.push_back(level); qu.push(nullptr); level.clear(); continue; &#125; level.push_back(t-&gt;val); if(t-&gt;left) qu.push(t-&gt;left); if(t-&gt;right) qu.push(t-&gt;right); &#125; return res; &#125; &#125;; äºŒå‰æœç´¢æ ‘çš„åŽåºéåŽ†åºåˆ— è¾“å…¥ä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œåˆ¤æ–­è¯¥æ•°ç»„æ˜¯ä¸æ˜¯æŸäºŒå‰æœç´¢æ ‘çš„åŽåºéåŽ†çš„ç»“æžœã€‚å¦‚æžœæ˜¯åˆ™è¾“å‡ºYes,å¦åˆ™è¾“å‡ºNoã€‚å‡è®¾è¾“å…¥çš„æ•°ç»„çš„ä»»æ„ä¸¤ä¸ªæ•°å­—éƒ½äº’ä¸ç›¸åŒã€‚ Tipsï¼šäºŒå‰æœç´¢æ ‘ï¼ŒæŒ‰ç…§ä¸­åºéåŽ†çš„è¯ï¼Œå°±æ˜¯ä¸€ä¸ªæŽ’åºçš„äºŒå‰æ ‘ï¼Œæ ¹èŠ‚ç‚¹å¤§äºŽå·¦å­æ ‘ï¼Œå³å­æ ‘å¤§äºŽæ ¹èŠ‚ç‚¹ã€‚åŽåºéåŽ†åºåˆ—ä¸­æœ€åŽä¸€ä¸ªæ˜¯æ ¹èŠ‚ç‚¹ï¼Œå°äºŽæ ¹èŠ‚ç‚¹æ˜¯å·¦å­æ ‘ï¼Œå¤§äºŽæ ¹èŠ‚ç‚¹çš„æ˜¯å³å­æ ‘ï¼Œè¿™æ ·è¿›è¡Œåˆ¤æ–­ã€‚ 123456789101112131415class Solution: # åŽåºéåŽ†ç»“æžœï¼Œ æœ€åŽä¸€ä¸ªæ˜¯æ ¹èŠ‚ç‚¹ï¼Œè¿™ä¸ªæ˜¯é€’å½’çš„æ€æƒ³ # äºŒå‰æœç´¢æ ‘ï¼Œ å·¦å­æ ‘å°äºŽæ ¹èŠ‚ç‚¹ï¼Œå³å­æ ‘å¤§äºŽæ ¹èŠ‚ç‚¹ def VerifySquenceOfBST(self, sequence): # write code here if not sequence: return False root = sequence[-1] for i in range(len(sequence)): if sequence[i] &gt; root: break for j in range(i, len(sequence)): if sequence[j] &lt; root: return False return True è¿™ä¸ªè¾¹ç•Œæ¡ä»¶ä¹Ÿæ˜¯æ¯”è¾ƒå¥½è¿›è¡Œå¤„ç†çš„ã€‚ 1234567891011121314151617181920212223242526class Solution &#123;public: // æ˜¯åˆ¤æ–­é¢˜ï¼Œéœ€è¦è¿”å›žçš„true or false ä¸¤ç§é€‰æ‹© // æœç´¢äºŒå‰æ ‘ ï¼Œå·¦å­æ ‘å°äºŽæ ¹èŠ‚ç‚¹ï¼Œ å³å­æ ‘å¤§äºŽæ ¹èŠ‚ç‚¹ï¼ŒåŽåºéåŽ†æ˜¯å·¦å­æ ‘ å³å­æ ‘ ç„¶åŽæ˜¯æ ¹èŠ‚ç‚¹ // é‚£ä¹ˆæœ€åŽä¸€ä¸ªæ˜¯æ ¹èŠ‚ç‚¹ï¼Œå¦‚æžœå€¼å°äºŽæ ¹èŠ‚ç‚¹ï¼Œé‚£ä¹ˆå°±æ˜¯è¯¥æ ¹ç»“ç‚¹çš„å·¦å­æ ‘ï¼›å¦åˆ™æ˜¯è¯¥æ ¹èŠ‚ç‚¹çš„å³å­æ ‘ï¼Œé€’å½’çš„è¿›è¡Œåˆ¤æ–­ vector&lt;int&gt; seq; bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123; if( sequence.empty()) return false; seq =sequence; return dfs(0, seq.size() -1); &#125; bool dfs(int l, int r) &#123; if(l &gt;= r) return true; int root =seq[r]; int k =l; while( k&lt; r &amp;&amp; seq[k] &lt; root) k++; for(int i =k; i&lt; r ; i++) if(seq[i] &lt; root) return false; return dfs(l, k -1) &amp;&amp; dfs(k, r-1); &#125;&#125;; äºŒå‰æ ‘ä¸­å’Œä¸ºæŸä¸€å€¼çš„è·¯å¾„** è¾“å…¥ä¸€é¢—äºŒå‰æ ‘çš„è·ŸèŠ‚ç‚¹å’Œä¸€ä¸ªæ•´æ•°ï¼Œæ‰“å°å‡ºäºŒå‰æ ‘ä¸­ç»“ç‚¹å€¼çš„å’Œä¸ºè¾“å…¥æ•´æ•°çš„æ‰€æœ‰è·¯å¾„ã€‚è·¯å¾„å®šä¹‰ä¸ºä»Žæ ‘çš„æ ¹ç»“ç‚¹å¼€å§‹å¾€ä¸‹ä¸€ç›´åˆ°å¶ç»“ç‚¹æ‰€ç»è¿‡çš„ç»“ç‚¹å½¢æˆä¸€æ¡è·¯å¾„ã€‚(æ³¨æ„: åœ¨è¿”å›žå€¼çš„listä¸­ï¼Œæ•°ç»„é•¿åº¦å¤§çš„æ•°ç»„é å‰) Tipsï¼š æ ‘çš„éåŽ†ï¼Œæ·±åº¦ä¼˜å…ˆç®—æ³•ï¼ˆdfsï¼‰ è¿™ä¸ªæ˜¯éžå¸¸å…¸åž‹çš„ dfsï¼Œæ˜¯å€¼å¾—æŽŒæ¡çš„ã€‚ 123456789101112131415161718192021222324252627# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # è¿”å›žäºŒç»´åˆ—è¡¨ï¼Œå†…éƒ¨æ¯ä¸ªåˆ—è¡¨è¡¨ç¤ºæ‰¾åˆ°çš„è·¯å¾„ # æ·±åº¦ä¼˜å…ˆ dfs() è¿™æ ·çš„ä¸€ä¸ªç®—æ³• def FindPath(self, root, expectNumber): # write code here if not root: return [] self.target = expectNumber paths = [] self.dfs(root, [root.val], paths) return pathsdef dfs(self, root, path, paths): if not root.left and not root.right and sum(path) == self.target: paths.append(path) if root.left: self.dfs(root.left, path + [root.left.val], paths) if root.right: self.dfs(root.right, path + [root.right.val], paths) c++ å†™æ³•1234567891011121314151617181920212223242526272829303132333435/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; // æ·±åº¦ä¼˜å…ˆçš„éåŽ† vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123; if(! root) return res ; dfs(root, expectNumber); // ä½¿ç”¨ sum -val å¯ä»¥å‡å°‘ä¸€ä¸ªå˜é‡çš„ä½¿ç”¨ return res; &#125; void dfs(TreeNode * root, int sum) &#123; if(!root) return ; sum -= root-&gt; val; path.push_back(root-&gt; val); if( !root-&gt; left &amp;&amp; !root-&gt; right &amp;&amp; !sum) res.push_back(path); dfs(root-&gt; left, sum); dfs(root-&gt; right, sum); path.pop_back(); // è¿™ä¸ªæ˜¯ c++ ä¸­ vector() çš„æ“ä½œ å°±æ˜¯pop_back() æ˜¯æ²¡æœ‰å…¶ä»–çš„å‚æ•°çš„ &#125;&#125;; å¤æ‚é“¾è¡¨çš„å¤åˆ¶ ï¼ˆæ¯”è¾ƒç»å…¸çš„ï¼‰ è¾“å…¥ä¸€ä¸ªå¤æ‚é“¾è¡¨ï¼ˆæ¯ä¸ªèŠ‚ç‚¹ä¸­æœ‰èŠ‚ç‚¹å€¼ï¼Œä»¥åŠä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸€ä¸ªæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¦ä¸€ä¸ªç‰¹æ®ŠæŒ‡é’ˆæŒ‡å‘ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹ï¼‰ï¼Œè¿”å›žç»“æžœä¸ºå¤åˆ¶åŽå¤æ‚é“¾è¡¨çš„headã€‚ï¼ˆæ³¨æ„ï¼Œè¾“å‡ºç»“æžœä¸­è¯·ä¸è¦è¿”å›žå‚æ•°ä¸­çš„èŠ‚ç‚¹å¼•ç”¨ï¼Œå¦åˆ™åˆ¤é¢˜ç¨‹åºä¼šç›´æŽ¥è¿”å›žç©ºï¼‰ Tips: å…ˆæ˜¯åœ¨åŽŸæ¥çš„é“¾è¡¨ä¸Šè¿›è¡Œäº†ç›¸åŒç»“ç‚¹çš„copyå’Œnext æŒ‡é’ˆçš„æŒ‡å‘ï¼Œç„¶åŽæ˜¯random æŒ‡é’ˆçš„æŒ‡å‘ï¼Œæœ€åŽæ˜¯å°†åŽŸå§‹é“¾è¡¨å’Œcopy çš„é“¾è¡¨è¿›è¡Œåˆ†ç¦»ã€‚ æ€è·¯ï¼Œæ˜¯å…ˆå¤åˆ¶èŠ‚ç‚¹å’Œ next æŒ‡é’ˆï¼Œç„¶åŽå†éåŽ†ä¸€éå¤åˆ¶ random æŒ‡é’ˆã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding:utf-8 -*-# class RandomListNode:# def __init__(self, x):# self.label = x# self.next = None# self.random = Noneclass Solution: # è¿”å›ž RandomListNode # é¦–å…ˆæ˜¯ç»“ç‚¹çš„å¤åˆ¶å’Œ next æŒ‡é’ˆçš„è¿žæŽ¥ï¼Œ ç„¶åŽæ˜¯random æŒ‡é’ˆçš„è¿žæŽ¥ï¼Œæœ€åŽæ˜¯é€‰æ‹©å‡ºå¤åˆ¶çš„ç»“ç‚¹def Clone(self, pHead): # write code here if not pHead: return None self.clone_nodes(pHead) self.connect_nodes(pHead) return self.select_nodes(pHead)def clone_nodes(self, head): if not head: return None while head: cloned = RandomListNode(head.label) cloned.next = head.next head.next = cloned head = cloned.nextdef connect_nodes(self, head): if not head: return None while head: cloned = head.next if head.random: cloned.random = head.random.next head = cloned.nextdef select_nodes(self, head): if not head: return None cloned =cloned_head =None # è¿™ä¸ªif çš„ä½œç”¨æ˜¯ä¸ºäº†ä¿å­˜ä¸€ä¸ª cloned_headçš„ç»“ç‚¹ï¼Œ # ä¸€å®šè¦ä»Žè¿™ä¸ªåŠŸèƒ½å‡ºå‘ if head: cloned =cloned_head =head.next head.next =cloned.next head =head.next while head: cloned.next =head.next cloned =cloned.next head.next =cloned.next head =head.next return cloned_head æ€è·¯æ˜¯å®Œå…¨æ­£ç¡®çš„ï¼Œä½†æ˜¯ä¸çŸ¥é“ä¸ºä»€ä¹ˆåœ¨ ç‰›å®¢ä¸Šï¼Œè¿™ä¸ªcase é€šè¿‡çŽ‡æ˜¯0.çœŸçš„æ˜¯å¤ªéš¾äº† 123456789101112131415161718192021222324252627282930313233343536373839404142/*struct RandomListNode &#123; int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: // åˆ†æˆä¸‰æ­¥éª¤ï¼Œé¦–å…ˆæ˜¯å¤åˆ¶ç»“ç‚¹æ’å…¥åˆ°åŽŸæ¥çš„é“¾è¡¨ä¸­ï¼Œç„¶åŽå¤„ç†randomæŒ‡é’ˆï¼Œæœ€åŽæ˜¯å°†é“¾è¡¨æŒ‘é€‰å‡ºæ¥ RandomListNode* Clone(RandomListNode* pHead) &#123; // åŠ å…¥ä¸€ä¸ªnode æ˜¯éœ€è¦æ“ä½œä¸¤ä¸ªæŒ‡é’ˆçš„ for( auto p=pHead; p;) &#123; auto np =new RandomListNode(p-&gt;label); auto next =p-&gt;next; p -&gt;next =np; np-&gt;next =next; p =next; &#125; // å¤„ç†randomæŒ‡é’ˆ for(auto p =pHead; p; p =p-&gt;next-&gt;next) &#123; if(p-&gt;random) p-&gt;next -&gt;random =p-&gt;random-&gt;next; &#125; auto dummy =new RandomListNode(-1); auto cur =dummy; for( auto p =pHead; p;p =p-&gt;next-&gt;next ) &#123; cur -&gt;next =p-&gt;next; cur =cur-&gt;next; //p =p-&gt;next; &#125; return dummy-&gt;next; &#125;&#125;; äºŒå‰æœç´¢æ ‘ä¸ŽåŒå‘é“¾è¡¨ è¾“å…¥ä¸€æ£µäºŒå‰æœç´¢æ ‘ï¼Œå°†è¯¥äºŒå‰æœç´¢æ ‘è½¬æ¢æˆä¸€ä¸ªæŽ’åºçš„åŒå‘é“¾è¡¨ã€‚è¦æ±‚ä¸èƒ½åˆ›å»ºä»»ä½•æ–°çš„ç»“ç‚¹ï¼Œåªèƒ½è°ƒæ•´æ ‘ä¸­ç»“ç‚¹æŒ‡é’ˆçš„æŒ‡å‘ã€‚ Tipsï¼šä¸­åºéåŽ†äºŒå‰æœç´¢æ ‘å°±æ˜¯ä¸€ç§æŽ’åºçš„æ ‘çš„ç»“ç‚¹ï¼Œç„¶åŽæ ‘çš„å·¦å³æŒ‡é’ˆå¯ä»¥ä½œä¸ºé“¾è¡¨ä¸­çš„æŒ‡å‘ä½¿ç”¨ã€‚ 12345678910111213141516171819202122232425262728293031323334# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # ä½¿ç”¨çš„æ ‘çš„ç»“æž„ è¡¨ç¤ºä¸€ç§åŒå‘é“¾è¡¨ # äºŒå‰æœç´¢æ ‘ ï¼Œå·¦å­æ ‘å°äºŽæ ¹èŠ‚ç‚¹ï¼Œå³å­æ ‘å¤§äºŽæ ¹èŠ‚ç‚¹ # ä¸­åºéåŽ†å¾—åˆ°å°±æ˜¯ä¸€ç§æŽ’å¥½åºçš„ç»“æž„ # åªèƒ½è°ƒæ•´æ ‘ä¸­ç»“ç‚¹æŒ‡é’ˆçš„æŒ‡å‘ def Convert(self, pRootOfTree): # write code here if not pRootOfTree: return None tree = pRootOfTree res = [] self.helper(tree, res) for i in range(len(res) - 1): res[i].right = res[i + 1] res[i + 1].left = res[i] # è¿™ä¸ªè¿”å›žå€¼ä¹Ÿæ˜¯æ¯”è¾ƒé¬¼ç•œå‘€ï¼Œ å°±æ˜¯éœ€è¦è¿™æ ·è¿”å›ž return res[0]def helper(self, root, res): if not root: return None if root.left: self.helper(root.left, res) res.append(root) if root.right: self.helper(root.right, res) è¿™ä¸ªä»£ç é•¿åº¦æœ‰ç‚¹å¤šï¼Œæ‰€ä»¥ä¹‹åŽå†çœ‹ã€‚è®²è§£é“¾æŽ¥ ä¸¤ä¸ªé“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…¬å…±ç»“ç‚¹ è¾“å…¥ä¸¤ä¸ªé“¾è¡¨ï¼Œæ‰¾å‡ºå®ƒä»¬çš„ç¬¬ä¸€ä¸ªå…¬å…±ç»“ç‚¹ã€‚ Tipsï¼šå°±æ˜¯ä¸€ä¸ª m*n çš„é—®é¢˜ï¼ˆmï¼Œn åˆ†åˆ«ä»£è¡¨ä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦ï¼‰ 12345678910111213141516171819# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘çš„æ˜¯ ä¸€ä¸ªç»“ç‚¹ï¼Œä¸€ä¸ªå†…å­˜çš„ä¸¤ä¸ªæŒ‡å‘ # å°†å¯èƒ½ä¸åŒé•¿åº¦çš„ä¸¤ä¸ªé“¾è¡¨è½¬æ¢æˆç›¸åŒé•¿åº¦çš„ä¸¤ä¸ªé“¾è¡¨çš„æ¯”è¾ƒï¼Œä½¿ç”¨ def FindFirstCommonNode(self, pHead1, pHead2): # write code here if not pHead1 or not pHead2: return None p1 = pHead1 p2 = pHead2 while p1 != p2: # è¿™ä¸ªp1 åªèƒ½æŒ‡å‘äº†æœ€åŽä¸€ä¸ªç»“ç‚¹ï¼Œä½†æœ€åŽä¸€ä¸ªèŠ‚ç‚¹ä¸ä¸€å®šç›¸åŒ p1 = pHead2 if not p1 else p1.next p2 = pHead1 if not p2 else p2.next return p1 è¯¥é¢˜ç›®æœ‰ä¸€ç§æ¯”è¾ƒå·§å¦™çš„åšæ³•ï¼Œå¦‚æžœä¸€ä¸ªæŒ‡é’ˆèµ°å®Œä¹‹åŽï¼ŒæŒ‡å‘å¦ä¸€ä¸ªlist çš„å¼€å¤´ï¼›åŒç†ï¼Œå¦ä¸€ä¸ªæŒ‡é’ˆä¹Ÿæ˜¯å¯ä»¥è¿™æ ·è¿›è¡Œæ“ä½œã€‚å¦‚æžœæ˜¯å¯ä»¥ç›¸é‡çš„ï¼Œé‚£ä¹ˆä¸€å®šæœ€åŽå¯ä»¥ç›¸é‡ï¼Œå› ä¸ºèµ°è¿‡çš„è·¯å¾„æ˜¯ä¸€æ ·çš„é•¿åº¦çš„ã€‚ 1234567891011121314151617181920212223242526/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* FindFirstCommonNode( ListNode* head1, ListNode* head2) &#123; auto p1 =head1, p2 =head2; while(p1 != p2) &#123; if(p1) p1 =p1-&gt;next; else p1 =head2; if(p2) p2 =p2-&gt;next; else p2 =head1; &#125; // è¿™ä¸ªæ—¶å€™p1 å’Œp2 å·²ç»ç›¸ç­‰äº† return p1; &#125;&#125;; äºŒå‰æ ‘çš„æ·±åº¦ è¾“å…¥ä¸€æ£µäºŒå‰æ ‘ï¼Œæ±‚è¯¥æ ‘çš„æ·±åº¦ã€‚ä»Žæ ¹ç»“ç‚¹åˆ°å¶ç»“ç‚¹ä¾æ¬¡ç»è¿‡çš„ç»“ç‚¹ï¼ˆå«æ ¹ã€å¶ç»“ç‚¹ï¼‰å½¢æˆæ ‘çš„ä¸€æ¡è·¯å¾„ï¼Œæœ€é•¿è·¯å¾„çš„é•¿åº¦ä¸ºæ ‘çš„æ·±åº¦ã€‚ Tipsï¼šé€’å½’ï¼Œç›¸æ¯”äºŽäºŒå‰æ ‘çš„è·¯å¾„ï¼Œè¿™ä¸ªåªæ˜¯è¿”å›žä¸€ä¸ªæ•°å€¼å°±è¡Œã€‚ 12345678910111213141516171819# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: """ åˆ†åˆ«æ±‚è§£ å·¦å³å­æ ‘çš„æ·±åº¦ï¼Œç„¶åŽmax(left, right) è¿™æ ·çš„æ“ä½œ """ def TreeDepth(self, pRoot): if not pRoot: return 0 left = self.TreeDepth(pRoot.left) + 1 right = self.TreeDepth(pRoot.right) + 1 # è¿™ä¸ªreturn æ˜¯æœ€åŽæ‰§è¡Œä¸€æ¬¡çš„ï¼Œç„¶åŽä¸Šé¢é‚£ä¸ªéƒ½æ˜¯ä¸æ–­çš„åœ¨è¿›è¡Œé€’å½’åŠ æ·± # è¿™ä¸ª left right å·²ç»å®Œæˆäº†ï¼Œæœ€åŽçš„æ•ˆæžœåªæ˜¯ è¿”å›ž max(left, right) è¿™æ ·å­ return max(left, right) ä¸€èˆ¬äºŒå‰æ ‘çš„é—®é¢˜éƒ½æ˜¯å¯ä»¥ä½¿ç”¨é€’å½’æ±‚è§£çš„ï¼Œå› ä¸ºæ ‘æœ¬èº«å°±æ˜¯ä½¿ç”¨é€’å½’è¿›è¡Œå®šä¹‰çš„ã€‚æ€è·¯ï¼šå¦‚æžœå·¦å³å­æ ‘ä¸ä¸ºç©ºï¼Œé‚£ä¹ˆå°±è¿”å›žå·¦å³å­æ ‘æ·±åº¦ +1ã€‚è¿™ä¸ªå°±æ˜¯é€’å½’çš„å®šä¹‰ã€‚ 1234567891011121314151617/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: int TreeDepth(TreeNode* root) &#123; if(!root) return 0; return max(TreeDepth(root -&gt; left), TreeDepth(root-&gt; right)) +1; &#125;&#125;; å¹³è¡¡äºŒå‰æ ‘ è¾“å…¥ä¸€æ£µäºŒå‰æ ‘ï¼Œåˆ¤æ–­è¯¥äºŒå‰æ ‘æ˜¯å¦æ˜¯å¹³è¡¡äºŒå‰æ ‘ã€‚ Tipsï¼š å·¦å³å­æ ‘çš„æ·±åº¦å·®æœ€å¤§ä¸è¶…è¿‡1ã€‚ä¸¤ä¸ªé€’å½’ï¼Œä¸€ä¸ªæ˜¯è®¡ç®—æ ‘çš„æ·±åº¦çš„é€’å½’ï¼Œä¸€ä¸ªæ˜¯åˆ¤æ–­å·¦å³å­æ ‘æ˜¯å¦æ˜¯å¹³è¡¡äºŒå‰æ ‘çš„é€’å½’ã€‚ å¯¹äºŽå¹³è¡¡äºŒå‰æ ‘çš„ç¬¬ä¸€ååº”ï¼Œåº”è¯¥æƒ³åˆ°è¿™ä¸ªæ˜¯äºŒå‰æœç´¢æ ‘çš„ä¸€ç§æ”¹è¿›ã€‚ä¸ºäº†é˜²æ­¢å‡ºçŽ°é“¾è¡¨å¼çš„äºŒå‰æœç´¢æ ‘ï¼Œå¹³è¡¡äºŒå‰æ ‘é™åˆ¶äº†å·¦å³å­æ ‘çš„ç›¸å·®çš„é«˜åº¦ã€‚é€šè¿‡è°ƒæ•´å·¦å³å­æ ‘ï¼Œä¿æŒäº†äºŒå‰æœç´¢æ ‘çš„æ€§è´¨ã€‚ ç›´è§‚ä¸Šè®²ä¸æ˜¯å¾ˆåï¼ˆæ²¡æœ‰åå‘ä¸€è¾¹ï¼‰ 123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # é€’å½’å¸¸è§çš„éƒ½ä¼šæœ‰ä¸¤ä¸ªreturn è·³å‡ºæ¡ä»¶ï¼Œä¸€ä¸ªæ˜¯å¼‚å¸¸çš„æ¡ä»¶ï¼Œä¸€ä¸ªæ˜¯æ­£ç¡®çš„è¿”å›ž def get_depth(self, root): if not root: return 0 left =self.get_depth(root.left) right =self.get_depth(root.right) return max(left, right) +1 def IsBalanced_Solution(self, pRoot): if not pRoot: return True left =self.get_depth(pRoot.left) right =self.get_depth(pRoot.right) if abs(left-right) &gt;1: return False return self.IsBalanced_Solution(pRoot.left) and self.IsBalanced_Solution(pRoot.right) åœ¨æ±‚è§£ æ ‘çš„æ·±åº¦çš„è¿‡ç¨‹ä¸­ï¼Œåˆ¤æ–­æ˜¯å¦æ˜¯å¹³è¡¡äºŒå‰æ ‘ã€‚ 123456789101112131415161718192021class Solution &#123;public: // æœ¬é—®é¢˜æ±‚è§£çš„è¿‡ç¨‹ä¸­ä½¿ç”¨åˆ°äº† æ±‚è§£æ ‘çš„æ·±åº¦ä»£ç  bool ans =true; bool IsBalanced_Solution(TreeNode* pRoot) &#123; dfs(pRoot); return ans; &#125; // æ±‚è§£æ·±åº¦çš„è¿‡ç¨‹ int dfs(TreeNode* root) &#123; if(! root) return 0; int left =dfs(root-&gt;left ), right =dfs(root-&gt; right); if(abs(left -right) &gt;1) ans =false; return max(left, right) +1; &#125; &#125;; é“¾è¡¨ä¸­çŽ¯çš„å…¥å£ç»“ç‚¹ ç»™ä¸€ä¸ªé“¾è¡¨ï¼Œè‹¥å…¶ä¸­åŒ…å«çŽ¯ï¼Œè¯·æ‰¾å‡ºè¯¥é“¾è¡¨çš„çŽ¯çš„å…¥å£ç»“ç‚¹ï¼Œå¦åˆ™ï¼Œè¾“å‡ºnullã€‚ Tipsï¼š ä¸¤ä¸ªå¿«æ…¢æŒ‡é’ˆï¼Œå¼€æŒ‡é’ˆåœ¨çŽ¯å†…ç›¸é‡æ…¢æŒ‡é’ˆã€‚ï¼ˆä¸¤ä¸ªæŒ‡é’ˆä¸€ä¸ªéœ€è¦å†çŽ¯å¤–ï¼Œä¸€ä¸ªåœ¨çŽ¯å†…ï¼Œç„¶åŽåŒæ ·çš„é€Ÿåº¦èµ°ï¼Œæœ€åŽæ‰èƒ½ç›¸é‡ï¼‰é‡ç½®å¿«æŒ‡é’ˆåˆ°å¤´ç»“ç‚¹ï¼Œä¸¤ä¸ªæŒ‡é’ˆç›¸åŒé€Ÿåº¦ï¼Œå½“å†æ¬¡ç›¸é‡æ—¶å€™ï¼Œé‚£å°±æ˜¯å…¥å£ç»“ç‚¹ã€‚ 123456789101112131415161718192021# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # çŽ°åœ¨é•¿ä¸ªè®°æ€§å§ï¼Œåœ¨ä½¿ç”¨next è¿™æ ·çš„æ—¶å€™ è¦å…ˆåˆ¤æ–­è¿™ä¸ªæ˜¯ä¸æ˜¯å­˜åœ¨çš„ def EntryNodeOfLoop(self, pHead): # write code here if not pHead or not pHead.next or not pHead.next.next: return None twoTimes =pHead.next.next oneTime =pHead.next while twoTimes != oneTime: twoTimes =twoTimes.next.next oneTime =oneTime.next twoTimes =pHead while twoTimes != oneTime: twoTimes =twoTimes.next oneTime =oneTime.next return twoTimes 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;// c++ ä¸­ å•é“¾è¡¨çš„å®šä¹‰struct ListNode&#123; int val; ListNode *next; ListNode(int x) :val(x), next(NULL)&#123;&#125; // æž„é€ å‡½æ•° &#125;;ListNode *entryNodeOfLoop(ListNode *head)&#123; auto i =head, j =head; while(i &amp;&amp; j) &#123; i =i-&gt;next; j =j -&gt;next; if(j ) j= j-&gt;next; if(i ==j) &#123; i =head; while(i != j) &#123; i =i-&gt;next; j =j-&gt;next; &#125; return i; &#125; &#125; return 0; &#125;int main()&#123; ListNode *head =new ListNode(-1); ListNode *p1 =new ListNode(1); ListNode *p2 =new ListNode(2); ListNode *p3 =new ListNode(3); ListNode *p4 =new ListNode(4); head -&gt;next =p1, p1-&gt;next =p2, p2-&gt;next =p3, p3-&gt;next =p4; p4-&gt;next =p1; //cout&lt;&lt; head-&gt;val&lt;&lt;endl; ListNode *p =entryNodeOfLoop(head); cout&lt;&lt; p-&gt;val&lt;&lt;endl; return 0;&#125; åˆ é™¤é“¾è¡¨ä¸­é‡å¤çš„ç»“ç‚¹ åœ¨ä¸€ä¸ªæŽ’åºçš„é“¾è¡¨ä¸­ï¼Œå­˜åœ¨é‡å¤çš„ç»“ç‚¹ï¼Œè¯·åˆ é™¤è¯¥é“¾è¡¨ä¸­é‡å¤çš„ç»“ç‚¹ï¼Œé‡å¤çš„ç»“ç‚¹ä¸ä¿ç•™ï¼Œè¿”å›žé“¾è¡¨å¤´æŒ‡é’ˆã€‚ ä¾‹å¦‚ï¼Œé“¾è¡¨1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 å¤„ç†åŽä¸º 1-&gt;2-&gt;5 12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def deleteDuplication(self, pHead): # write code here head = ListNode(-1) head.next = pHead curr = pHead last = head while curr and curr.next: # val =curr.val # è¿™ä¸ªæ¡ä»¶æ¯”è¾ƒç®€å•ï¼Œæ‰€ä»¥å¯ä»¥æ”¾åˆ°å‰é¢ if curr.val != curr.next.val: curr = curr.next last = last.next else: # è¿™ä¸ªæ¡ä»¶ curr è¿˜æ˜¯éœ€è¦æ³¨æ„ä¸€ä¸‹çš„ val = curr.val # python ä¸­ condition1 and condition2 è¿™ç§æ˜¯æœ‰å…ˆåŽé¡ºåºçš„ # å¯èƒ½æ˜¯å­˜åœ¨çŸ­è·¯çŽ°è±¡çš„ï¼Œ å¦‚æžœ curr ä¸æˆç«‹ï¼Œé‚£ä¹ˆåŽé¢çš„æ˜¯ä¸ä¼šæ‰§è¡Œçš„ # è‰æ‹Ÿ while curr and val == curr.val: curr = curr.next last.next = curr return head.next å‡¡æ˜¯å¯èƒ½æŠŠå¤´ç»“ç‚¹åˆ æŽ‰çš„é—®é¢˜ï¼Œä¸€èˆ¬æ¥è¯´æˆ‘ä»¬éƒ½æ˜¯ä¼šå®šä¹‰ä¸€ä¸ªè™šæ‹Ÿå¤´ç»“ç‚¹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;struct ListNode&#123; int val; ListNode *next; ListNode(int x): val(x), next(NULL)&#123;&#125;&#125;;// è¿™ä¸ªæ˜¯æŽ’åºä¹‹åŽçš„é“¾è¡¨ï¼Œé‚£ä¹ˆå¯ä»¥æŠŠåŽŸæ¥çš„list çœ‹æˆä¸€æ®µä¸€æ®µï¼Œ ä½¿ç”¨p å’Œq ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«æŒ‡å‘çš„ä¸¤æ®µçš„å¼€å¤´// å¯¹äºŽå¯èƒ½åˆ é™¤å¤´ç»“ç‚¹çš„ï¼Œä¸€èˆ¬ä½¿ç”¨è™šæ‹Ÿç»“ç‚¹ï¼Œç®€åŒ–å¤„ç†çš„æƒ…å†µListNode * deleteDumplication(ListNode* head)&#123; auto dummy =new ListNode(-1); dummy-&gt;next =head; auto p =dummy; while(p-&gt;next) &#123; auto q =p-&gt;next; while(q &amp;&amp; p-&gt;next-&gt;val == q-&gt;val) q =q-&gt;next; if(p -&gt;next-&gt;next == q) p =p-&gt;next; else p-&gt;next =q; &#125; return dummy-&gt;next;&#125;int main()&#123; auto p1 =new ListNode(1); auto p2 =new ListNode(2); auto p3 =new ListNode(3); auto p22 =new ListNode(2); auto p33 =new ListNode(3); auto p4 =new ListNode(4); p1-&gt;next =p2,p2-&gt;next =p22, p22-&gt;next =p3, p3-&gt;next =p33, p33-&gt;next =p4; auto res =deleteDumplication(p1); cout&lt;&lt; res-&gt;val&lt;&lt;endl; return 0;&#125; åœ¨ $O(1)æ—¶é—´åˆ é™¤é“¾è¡¨ç»“ç‚¹$ ç»™å®šå•å‘é“¾è¡¨çš„ä¸€ä¸ªèŠ‚ç‚¹æŒ‡é’ˆï¼Œå®šä¹‰ä¸€ä¸ªå‡½æ•°åœ¨ $O(1)$ æ—¶é—´åˆ é™¤è¯¥ç»“ç‚¹ã€‚ é¢˜ç›®è§†é¢‘è®²è§£ ä¸€èˆ¬åˆ é™¤ä¸€ä¸ªèŠ‚ç‚¹éœ€è¦çŸ¥é“å…¶å‰é©±ç»“ç‚¹ï¼Œä½†æ˜¯è¿˜æœ‰å¦å¤–ä¸€ç§åšæ³•ï¼Œå°±æ˜¯é€šè¿‡ä¸‹ä¸€ä¸ªç»“ç‚¹è¦†ç›–åˆ°æœ¬ç»“ç‚¹ï¼Œç„¶åŽåˆ é™¤ä¸‹ä¸€ä¸ªç»“ç‚¹ã€‚ 1234567891011121314151617/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void deleteNode(ListNode* node) &#123; node-&gt;val =node-&gt;next-&gt;val; node-&gt;next =node-&gt;next-&gt;next; &#125;&#125;; äºŒå‰æ ‘çš„ä¸‹ä¸€ä¸ªç»“ç‚¹ ç»™å®šä¸€ä¸ªäºŒå‰æ ‘å’Œå…¶ä¸­çš„ä¸€ä¸ªç»“ç‚¹ï¼Œè¯·æ‰¾å‡ºä¸­åºéåŽ†é¡ºåºçš„ä¸‹ä¸€ä¸ªç»“ç‚¹å¹¶ä¸”è¿”å›žã€‚æ³¨æ„ï¼Œæ ‘ä¸­çš„ç»“ç‚¹ä¸ä»…åŒ…å«å·¦å³å­ç»“ç‚¹ï¼ŒåŒæ—¶åŒ…å«æŒ‡å‘çˆ¶ç»“ç‚¹çš„æŒ‡é’ˆã€‚ Tipsï¼šä¸­åºéåŽ†çš„ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼Œå¦‚æžœå­˜åœ¨å³èŠ‚ç‚¹ï¼Œé‚£ä¹ˆä¸‹ä¸€ä¸ªç»“ç‚¹æ˜¯å³èŠ‚ç‚¹æœ€å·¦è¾¹çš„ä¸€ä¸ªç‚¹ï¼›å¦‚æžœè¯¥ç»“ç‚¹æ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å·¦ç»“ç‚¹ï¼Œé‚£ä¹ˆä¸‹ä¸€èŠ‚ç‚¹æ˜¯å…¶çˆ¶èŠ‚ç‚¹ï¼Œå¦åˆ™ä¸€ç›´å›žæº¯ã€‚ 123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: # https://blog.csdn.net/fuxuemingzhu/article/details/79723819 # è¿™ä¸ªæ˜¯æ±‚è§£ä¸­åºéåŽ†ä¸­æŸä¸ªç»“ç‚¹çš„ä¸‹ä¸€ä¸ªç»“ç‚¹ # è¿™pNode å°±æ˜¯ä¸€ä¸ªæ™®é€šçš„ç»“ç‚¹ def GetNext(self, pNode): # write code here if not pNode: return None # å¦‚æžœå­˜åœ¨å³ç»“ç‚¹ if pNode.right: pNode = pNode.right while pNode.left: pNode = pNode.left return pNode # å¦‚æžœæ˜¯çˆ¶èŠ‚ç‚¹çš„å·¦å­æ ‘ else: # è¿™é‡Œä½¿ç”¨ pNode.next è¡¨ç¤ºçˆ¶èŠ‚ç‚¹ while pNode.next: if pNode == pNode.next.left: return pNode.next # è¿™ä¸ªæ˜¯å³ç»“ç‚¹ pNode = pNode.next return None å¯¹ç§°çš„äºŒå‰æ ‘ è¯·å®žçŽ°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨æ¥åˆ¤æ–­ä¸€é¢—äºŒå‰æ ‘æ˜¯ä¸æ˜¯å¯¹ç§°çš„ã€‚æ³¨æ„ï¼Œå¦‚æžœä¸€ä¸ªäºŒå‰æ ‘åŒæ­¤äºŒå‰æ ‘çš„é•œåƒæ˜¯åŒæ ·çš„ï¼Œå®šä¹‰å…¶ä¸ºå¯¹ç§°çš„ã€‚ Tips: åˆ¤æ–­é•œåƒå’Œé€’å½’ç”Ÿæˆè¿›è¡Œè¿˜æ˜¯ä¸å¤ªä¸€æ ·çš„å“ˆã€‚é€’å½’åˆ¤æ–­ï¼Œæ ¹èŠ‚ç‚¹ç›¸åŒï¼Œç„¶åŽå·¦å³å­æ ‘æ˜¯å¦æ˜¯å¯¹ç§°ã€‚ 1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # é•œåƒçš„æ¦‚å¿µ å’Œé€’å½’ # isSame() è¿™ä¸ªå°±æ˜¯åˆ¤æ–­ä¸¤ä¸ªå­æ ‘æ˜¯å¦é•œåƒçš„æ“ä½œ def isSame(self, p, q): if not p and not q: return True # å¥½å¥½æ€è€ƒ ä¸‹é¢è¿™ä¸¤ä¸ªè·³å‡ºæ¡ä»¶ä¸ºä»€ä¹ˆæ˜¯ä¸åˆé€‚çš„ if p and q and p.val == q.val: return self.isSame(p.left, q.right) and self.isSame(p.right, q.left) def isSymmetrical(self, pRoot): # write code here # æœ€å¼€å§‹çš„æ¡ä»¶ å¦‚æžœéƒ½æ˜¯ none é‚£ä¹ˆè¿™ä¸ªæ˜¯å¯¹ç§°çš„ if not pRoot: return True if pRoot.left and not pRoot.right: return False if not pRoot.left and pRoot.right: return False return self.isSame(pRoot.left, pRoot.right) é™¤äº†æ ¹ç»“ç‚¹ï¼Œå·¦å³ä¸¤ä¸ªå­æ ‘éƒ½æ˜¯å¯¹ç§°çš„ã€‚å¯¹ç§°äºŒå‰æ ‘ï¼Œéžå¯¹ç§°äºŒå‰æ ‘ï¼ˆæƒå€¼ä¸å¯¹ç§°ï¼‰ï¼Œéžå¯¹ç§°äºŒå‰æ ‘ï¼ˆç»“æž„ä¸å¯¹ç§°ï¼‰ã€‚æ‰€ä»¥è¿™ä¸ªæ˜¯å¯¹ç§°æˆ–è€…é•œåƒæ˜¯æœ‰ä¸¤ä¸ªç»´åº¦çš„ï¼Œç»“æž„å’Œå†…å®¹ã€‚ c++ å®žçŽ° 123456789101112131415161718192021222324252627282930/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: bool isSymmetrical(TreeNode* root) &#123; if(!root) return true; return dfs(root-&gt;left, root-&gt;right); &#125; // åœ¨å®šä¹‰çš„æ—¶å€™ï¼Œä¸è¦ä½¿ç”¨auto äº†ï¼Œä½¿ç”¨å…·ä½“çš„ç±»åž‹ bool dfs(TreeNode *p, TreeNode *q) &#123; // å¦‚æžœæœ‰ç©ºçš„æƒ…å†µä¸‹ï¼Œåªæœ‰ä¸¤è€…éƒ½ä¸ºç©ºï¼Œé‚£ä¹ˆè¿”å›žçš„æ˜¯trueï¼Œå¦åˆ™æ˜¯false // è¿™ç§ç®€æ´çš„ä»£ç  å°±åº”è¯¥è®°ä½ if(!p || !q) return !p &amp;&amp; !q; if(p-&gt;val != q-&gt;val) return false; return dfs(p-&gt;left, q-&gt; right) &amp;&amp; dfs(p-&gt;right, q-&gt;left); &#125;&#125;; æŒ‰ä¹‹å­—å½¢é¡ºåºæ‰“å°äºŒå‰æ ‘ å¯¹äºŽäºŒå‰æ ‘çš„å±‚åºéåŽ†æœ‰ä¸‰ç§ä¸åŒçš„é¢˜åž‹ã€‚ ä¸åˆ†è¡Œçš„å±‚åºéåŽ† ä¸åˆ†è¡Œçš„å±‚åºéåŽ†ï¼ˆå¶æ•°è¡Œæ˜¯ä»Žå·¦åˆ°å³ï¼Œå¥‡æ•°è¡Œæ˜¯ä»Žå³åˆ°å·¦ï¼‰ åˆ†è¡Œçš„å±‚åºéåŽ†ï¼ˆæ¯æ‰“å°ä¸€è¡Œå°±å¦èµ·ä¸€è¡Œï¼‰ è¯·å®žçŽ°ä¸€ä¸ªå‡½æ•°æŒ‰ç…§ä¹‹å­—å½¢æ‰“å°äºŒå‰æ ‘ï¼Œå³ç¬¬ä¸€è¡ŒæŒ‰ç…§ä»Žå·¦åˆ°å³çš„é¡ºåºæ‰“å°ï¼Œç¬¬äºŒå±‚æŒ‰ç…§ä»Žå³è‡³å·¦çš„é¡ºåºæ‰“å°ï¼Œç¬¬ä¸‰è¡ŒæŒ‰ç…§ä»Žå·¦åˆ°å³çš„é¡ºåºæ‰“å°ï¼Œå…¶ä»–è¡Œä»¥æ­¤ç±»æŽ¨ã€‚ Tipsï¼šå±‚åºéåŽ†çš„å‡çº§ç‰ˆï¼Œæœ‰ä¸¤ç§æ€è·¯ï¼Œä¸€ç§æ˜¯ä½¿ç”¨å•ç‹¬ stack (list) çš„æ€æƒ³å­˜å‚¨å¶æ•°å±‚æ•°ï¼Œä¸€ç§æ˜¯å…ˆæŒ‰ç…§åŽŸå…ˆå±‚åºéåŽ†çš„æ€æƒ³ï¼Œæœ€åŽå¯¹äºŽå¶æ•°çš„ç»“æžœè¿›è¡Œâ€œç¿»è½¬â€ å¤„ç†ã€‚é€‰æ‹©åŽè€…ï¼Œå› ä¸ºä»£ç ä¸Šæ¯”è¾ƒç®€å•ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # å±‚åºéåŽ† + å¶æ•°ç¿»è½¬ # https://blog.csdn.net/fuxuemingzhu/article/details/79724959 def level(self, root, level, res): """ root: the root of tree level: res: result """ if not root: return if len(res) == level: res.append([]) res[level].append(root.val) if root.left: self.level(root.left, level + 1, res) if root.right: self.level(root.right, level + 1, res) def Print(self, pRoot): # write code here if not pRoot: return [] res = [] self.level(pRoot, 0, res) for level in range(1, len(res), 2): res[level] = res[level][::-1] return res æŒ‰ç…§ä¹‹å­—å½¢é¡ºåºæ‰“å°äºŒå‰æ ‘ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125; &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(! pRoot) return res; queue&lt;TreeNode*&gt; qu; qu.push(pRoot); qu.push(nullptr); vector&lt;int&gt; level; bool zigzag =false; //åˆ¤æ–­ queue æ˜¯å¦ä¸ºç©ºçš„æ¡ä»¶ while(qu.size()) &#123; auto t =qu.front(); qu.pop(); if(! t) &#123; if(level.empty()) break; if(zigzag) reverse(level.begin(), level.end()); res.push_back(level); qu.push(nullptr); zigzag =!zigzag; // è¿™ä¸ªå–åçš„æ“ä½œ level.clear(); //å› ä¸ºä½¿ç”¨çš„æ˜¯push back æ“ä½œï¼Œæ‰€ä»¥å¾—clear() æ“ä½œ continue; &#125; level.push_back(t-&gt;val); if(t-&gt;left) qu.push(t-&gt;left); if(t-&gt;right) qu.push(t-&gt;right); &#125; return res; &#125;&#125;; æŠŠäºŒå‰æ ‘æ‰“å°æˆå¤šè¡Œ ä»Žä¸Šåˆ°ä¸‹æŒ‰å±‚æ‰“å°äºŒå‰æ ‘ï¼ŒåŒä¸€å±‚ç»“ç‚¹ä»Žå·¦è‡³å³è¾“å‡ºã€‚æ¯ä¸€å±‚è¾“å‡ºä¸€è¡Œã€‚ Tips: å’Œä¸Šä¸€ä¸ªé¢˜ç›®ç±»ä¼¼ï¼Œåœ¨éåŽ†äºŒå‰æ ‘çš„æ—¶å€™ï¼Œå…³é”®æ˜¯åŠ å…¥äº† [level] å±‚æ•°è¿™ç§ä¿¡æ¯ã€‚ 123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # è¿”å›žäºŒç»´åˆ—è¡¨[[1,2],[4,5]] def level(self, root, level, res): # ä½ è¿™é‡Œä¹Ÿæ²¡æœ‰è¯´è¦è¿”å›žå€¼çš„æ„æ€å‘€ï¼Œè¿™ä¸ªç›´æŽ¥æ˜¯ return if not root: return if level == len(res): res.append([]) res[level].append(root.val) if root.left: self.level(root.left, level + 1, res) if root.right: # res[level] =self.level(root.right, level+1, res) # å› ä¸ºè¿™ä¸ªæ˜¯ ä¼ çš„å€¼ï¼Œæ‰€ä»¥ä¸éœ€è¦ä½¿ç”¨è¿”å›žå€¼çš„ self.level(root.right, level + 1, res) def Print(self, pRoot): if not pRoot: return [] res = [] self.level(pRoot, 0, res) return res åºåˆ—åŒ–äºŒå‰æ ‘ è¯·å®žçŽ°ä¸¤ä¸ªå‡½æ•°ï¼Œåˆ†åˆ«ç”¨æ¥åºåˆ—åŒ–å’Œååºåˆ—åŒ–äºŒå‰æ ‘ Tipsï¼šåºåˆ—å·å’Œååºåˆ—åŒ–åªæ˜¯ä¸€ç§çº¦å®šçš„å­˜å‚¨çš„å½¢å¼ã€‚ 12345678910111213141516171819202122232425262728293031# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: """ åºåˆ—åŒ–å°±æ˜¯ä»Žæ ‘ç»“æž„ è½¬æˆå­—ç¬¦ä¸²çš„ç»“æž„ï¼›åä¹‹ï¼Œä¹Ÿæ˜¯æˆç«‹çš„ã€‚ ä½¿ç”¨å…ˆåºéåŽ†çš„æ–¹æ³•ã€‚ https://suixinblog.cn/2019/03/target-offer-serialize-binary-tree.html#%E4%BB%A3%E7%A0%81 """ def __init__(self): self.flag = -1 def Serialize(self, root): # write code here if not root: return "#" return str(root.val) + "," + self.Serialize(root.left) + "," + self.Serialize(root.right) def Deserialize(self, s): # write code here self.flag += 1 string = s.split(',') if self.flag &gt; len(string): return None root = None if string[self.flag] != '#': root = TreeNode(int(string[self.flag])) root.left = self.Deserialize(s) root.right = self.Deserialize(s) return root åºåˆ—åŒ–äºŒå‰æ ‘ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // åºåˆ—åŒ–çš„æ—¶å€™ä½¿ç”¨ #è¡¨ç¤ºç©ºèŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹å’Œç»“ç‚¹ä¹‹é—´ä½¿ç”¨ ,éš”å¼€ // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; string res; dfs_s(root, res); return res; &#125; void dfs_s(TreeNode* root, string &amp; res) &#123; if(!root) &#123; res += "#,"; return ; &#125; res += to_string(root-&gt;val)+','; dfs_s(root-&gt;left, res); dfs_s(root-&gt;right, res); &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; int u =0; return dfs_d(data, u); &#125; TreeNode* dfs_d(string &amp;data, int &amp;u) &#123; if(data[u] =='#') &#123; u +=2; return NULL; &#125; int t =0; bool is_minus =false; while(data[u] !=',') &#123; if(data[u] =='-') is_minus =true; else t =t*10 +data[u] -'0'; u ++; &#125; u ++; // è¿™ä¸ªæœ¬èº«ä»£è¡¨çš„å«ä¹‰æ˜¯ data[u] ==','ï¼Œ æ³¨æ„è¿™ç§ä¸Šä¸‹æ–‡ if(is_minus ) t =-t; auto root =new TreeNode(t); root-&gt; left =dfs_d(data, u); root-&gt;right =dfs_d(data, u); return root; &#125;&#125;; äºŒå‰æœç´¢æ ‘çš„ç¬¬kä¸ªç»“ç‚¹ ç»™å®šä¸€æ£µäºŒå‰æœç´¢æ ‘ï¼Œè¯·æ‰¾å‡ºå…¶ä¸­çš„ç¬¬kå°çš„ç»“ç‚¹ã€‚ä¾‹å¦‚ï¼Œ ï¼ˆ5ï¼Œ3ï¼Œ7ï¼Œ2ï¼Œ4ï¼Œ6ï¼Œ8ï¼‰ ä¸­ï¼ŒæŒ‰ç»“ç‚¹æ•°å€¼å¤§å°é¡ºåºç¬¬ä¸‰å°ç»“ç‚¹çš„å€¼ä¸º4ã€‚ Tips: äºŒå‰æœç´¢æ ‘ï¼Œä¸­åºéåŽ†ä¹‹åŽæœ‰åºï¼Œç„¶åŽå–ç¬¬ k ä¸ªç»“ç‚¹ã€‚ 12345678910111213141516171819202122232425# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def middle(self, root, result): if not root: return if root.left: self.middle(root.left, result) result.append(root) if root.right: self.middle(root.right, result) def KthNode(self, pRoot, k): # write code here if not pRoot: return result = [] self.middle(pRoot, result) if len(result) &lt; k or k &lt; 1: return return result[k - 1] æ—¶é—´å¤æ‚åº¦æ˜¯ $O(K)$, è¿™ä¸ªæ˜¯æœ€ä¼˜çš„è§£æ³•äº†ã€‚ 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* res; TreeNode* kthNode(TreeNode* root, int k) &#123; dfs(root, k); return res; &#125; // å½“ä½ ä¼ é€’å”¯ä¸€çš„k çš„æ—¶å€™ï¼Œä¸€å®šè¦ä¿è¯æ“ä½œçš„æ˜¯ä¸€ä¸ªæ•°å­—ã€‚ void dfs(TreeNode* root, int&amp; k) &#123; if(! root) return ;// è·³å‡ºæ¡ä»¶ dfs(root-&gt; left, k); k --; if(!k) res =root; if(k &gt;0) dfs(root-&gt;right, k); &#125;&#125;;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[tensorflow learning]]></title>
    <url>%2F2019%2F06%2F17%2Ftf-learning%2F</url>
    <content type="text"><![CDATA[linear_regression 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import numpy as npimport matplotlib.pyplot as pltimport tensorflow as tfimport xlrd # å³xlrdæ˜¯è¯»excelï¼Œxlwtæ˜¯å†™excelçš„åº“ã€‚import osfrom sklearn.utils import check_random_staten =50XX =np.arange(n)rs =check_random_state(0)YY =rs.randint(-10, 10, size=(n, ))+ 2.0* XXdata =np.stack([XX,YY], axis= 1) #æ²¿ç€çš„çºµè½´num_epochs =50# å˜é‡çš„åˆå§‹åŒ–W =tf.Variable(0.0, name="weights")b =tf.Variable(0.0, name ="bias")# å®šä¹‰æ•°æ® placeholddef inputs(): X =tf.placeholder(tf.float32, name ="X") Y =tf.placeholder(tf.float32, name ="Y") return X,Ydef inference(X): return X* W+bdef loss(X, Y): Y_predicted =inference(X) # square æ˜¯å¹³æ–¹ï¼Œå¹³æ–¹å·®å…¬å¼ return tf.reduce_sum(tf.squared_difference(Y, Y_predicted))(2.0* data.shape[0])# train çš„è¿‡ç¨‹å°±æ˜¯ minimize loss çš„è¿‡ç¨‹def train(loss): learning_rate =0.0001 return tf.train.GradientDescentOptimizer(learning_rate).minimize(loss)with tf.Session() as sess: sess.run(tf.global_variables_initializer()) X, Y =inputs() train_loss =loss(X, Y) train_op =train(train_loss) for epoch_num in range(num_epochs): loss_value, _ =sess.run([train_loss, train_op], feed_dict=&#123;X :data[:, 0], Y:data[:, 1]&#125;) print("epoch %d, loss =%f"%(epoch_num+1, loss_value)) # å·²ç» trainä¹‹åŽï¼Œé‚£ä¹ˆè¿™ä¸ª run weights å’Œ bias çš„æ„ä¹‰ wcoeff, bias =sess.run([ W, b])# show resultsInput_values =data[:, 0]Labels =data[:, 1]Prediction_values =data[:, 0] *wcoeff +biasplt.plot(Input_values, Labels, 'ro', label ="main")plt.plot(Input_values, Prediction_values, label ="predicted")plt.legend()plt.show()plt.close() tensorflow ä¸­å›¾çš„æ¦‚å¿µ Tensorflowæœ‰å›¾çš„æ¦‚å¿µï¼ŒOperationsä¼šè¢«æ·»åŠ åˆ°å›¾ä¸­ï¼Œä½œä¸ºå›¾çš„èŠ‚ç‚¹ã€‚åœ¨æ·»åŠ æŸä¸ªOperationçš„æ—¶å€™ï¼Œä¸ä¼šç«‹å³æ‰§è¡Œè¯¥Operationã€‚Tensorflowä¼šç­‰æ‰€æœ‰Operationæ·»åŠ å®Œæ¯•ï¼Œç„¶åŽä¼˜åŒ–è¯¥è®¡ç®—å›¾ï¼Œä»¥ä¾¿å†³å®šå¦‚ä½•æ‰§è¡Œè®¡ç®—ã€‚ è€ŒTensoråˆ™æ˜¯ä»£ç ä¸­çš„å˜é‡å’Œå¸¸é‡ã€‚æ‰€æœ‰å˜é‡éƒ½éœ€è¦åœ¨å¼€å§‹æ‰§è¡Œå›¾è®¡ç®—ä¹‹å‰è¿›è¡Œåˆå§‹åŒ–ï¼Œé€šè¿‡è°ƒç”¨tf.initialize_all_variables().run()æ¥åˆå§‹åŒ–æ‰€æœ‰å˜é‡ã€‚ ä½¿ç”¨Tensorflowï¼Œä¸€èˆ¬éœ€è¦ä¸‰ä¸ªæ­¥éª¤ï¼š åˆ›å»ºTensorï¼› æ·»åŠ Operationsï¼ˆOperationsè¾“å…¥Tensorï¼Œç„¶åŽè¾“å‡ºå¦ä¸€ä¸ªTensorï¼‰ï¼› æ‰§è¡Œè®¡ç®—ï¼ˆä¹Ÿå°±æ˜¯è¿è¡Œä¸€ä¸ªå¯è®¡ç®—çš„å›¾ï¼‰ã€‚ Tensorflowçš„å›¾å¿…é¡»åœ¨ä¸€ä¸ªä¼šè¯(Session)ä¸­æ¥è®¡ç®—ã€‚Sessionæä¾›äº†Operationæ‰§è¡Œå’ŒTensoræ±‚å€¼çš„çŽ¯å¢ƒ tensorflow ä¸­name scope å’Œ variable scope çš„åŒºåˆ« TensorFlowæä¾›äº†é€šè¿‡å˜é‡åç§°ï¼ˆnameï¼‰æ¥åˆ›å»ºæˆ–è€…èŽ·å–ä¸€ä¸ªå˜é‡çš„æœºåˆ¶ï¼Œ æ˜¯é€šè¿‡åŠ ä¸Šå‰ç¼€æ¥è¿›è¡Œå˜é‡çš„ç®¡ç†ã€‚ variable scopeä¸ºäº†å®žçŽ°tensorflowä¸­çš„å˜é‡å…±äº«æœºåˆ¶ï¼šå³ä¸ºäº†ä½¿å¾—åœ¨ä»£ç çš„ä»»ä½•éƒ¨åˆ†å¯ä»¥ä½¿ç”¨æŸä¸€ä¸ªå·²ç»åˆ›å»ºçš„å˜é‡ï¼ŒTFå¼•å…¥äº†å˜é‡å…±äº«æœºåˆ¶ï¼Œä½¿å¾—å¯ä»¥è½»æ¾çš„å…±äº«å˜é‡ï¼Œè€Œä¸ç”¨ä¼ ä¸€ä¸ªå˜é‡çš„å¼•ç”¨ã€‚ TensorFlowæä¾›äº†ä¸¤ç§åˆ›å»ºå˜é‡çš„æ–¹æ³•ï¼Œä¸€ç§æ˜¯tf.Variable()ï¼Œå¦ä¸€ç§æ˜¯tf.get_variable()ã€‚ tf.get_variable()é™¤äº†å¯ä»¥åˆ›å»ºå˜é‡å¤–ï¼Œè¿˜èƒ½èŽ·å–å˜é‡ã€‚ ç»™å‡ºä¸€ä¸ªæ¡ˆä¾‹è¿›è¡Œå­¦ä¹ ã€‚ 1234567891011121314151617import tensorflow as tfwith tf.name_scope('name_scope_test'): v1 = tf.get_variable('v', shape=[1], initializer=tf.constant_initializer(1.0)) v2 = tf.Variable(tf.constant(1.0, shape=[1]), name='v') v3 = tf.Variable(tf.constant(1.0, shape=[1]), name='v')with tf.Session() as sess: init_op = tf.global_variables_initializer() sess.run(init_op) print('the name of v1:', v1.name) print('the name of v2:', v2.name) print('the name of v3:', v3.name)#è¾“å‡ºä¸º#the name of v1: v:0#the name of v2: name_scope_test/v:0#the name of v3: name_scope_test/v_1:0 tf.ConfigProto() åˆ›å»ºsession() çš„æ—¶å€™ï¼Œç”¨æ¥å¯¹ session() è¿›è¡Œå‚æ•°é…ç½®ã€‚ç®€å•çš„ä¸¾ä¸ªä¾‹å­. 123config = tf.ConfigProto(allow_soft_placement=True, allow_soft_placement=True)config.gpu_options.per_process_gpu_memory_fraction = 0.4 #å ç”¨40%æ˜¾å­˜sess = tf.Session(config=config) å¸¸è§çš„å‚æ•°ï¼š è®°å½•è®¾å¤‡æŒ‡æ´¾æƒ…å†µ : tf.ConfigProto(log_device_placement=True) è‡ªåŠ¨é€‰æ‹©è¿è¡Œè®¾å¤‡ ï¼š tf.ConfigProto(allow_soft_placement=True) é™åˆ¶GPUèµ„æºä½¿ç”¨ï¼š åŠ¨æ€çš„ç”³è¯· 123config = tf.ConfigProto()config.gpu_options.allow_growth = Truesession = tf.Session(config=config) é™åˆ¶GPUä½¿ç”¨çŽ‡ 123config = tf.ConfigProto()config.gpu_options.per_process_gpu_memory_fraction = 0.4 #å ç”¨40%æ˜¾å­˜session = tf.Session(config=config) æˆ–è€… 123gpu_options=tf.GPUOptions(per_process_gpu_memory_fraction=0.4)config=tf.ConfigProto(gpu_options=gpu_options)session = tf.Session(config=config) è®¾ç½®ä½¿ç”¨å“ªå—GPU æ–¹æ³•ä¸€ï¼š åœ¨ç¨‹åºä¸­è®¾ç½® 123os.environ['CUDA_VISIBLE_DEVICES'] = '0' #ä½¿ç”¨ GPU 0os.environ['CUDA_VISIBLE_DEVICES'] = '0,1' # ä½¿ç”¨ GPU 0ï¼Œ1 æ–¹æ³•äºŒï¼š åœ¨ shell è„šæœ¬ä¸­è®¾ç½® 1CUDA_VISIBLE_DEVICES=0,1 python yourcode.py ä¿å­˜å’Œæ¢å¤ ä¿å­˜ï¼šåˆ›å»º Saverï¼ˆä½¿ç”¨ tf.train.Saver()ï¼‰æ¥ç®¡ç†æ¨¡åž‹ä¸­çš„æ‰€æœ‰å˜é‡ã€‚ æ¢å¤: tf.train.Saver å¯¹è±¡ä¸ä»…å°†å˜é‡ä¿å­˜åˆ°æ£€æŸ¥ç‚¹æ–‡ä»¶ä¸­ï¼Œè¿˜å°†æ¢å¤å˜é‡ã€‚è¯·æ³¨æ„ï¼Œå½“æ‚¨æ¢å¤å˜é‡æ—¶ï¼Œæ‚¨ä¸å¿…äº‹å…ˆå°†å…¶åˆå§‹åŒ–ã€‚ å˜é‡çš„ç§ç±»å’Œä½¿ç”¨èŒƒå›´ TensorFlow æ”¯æŒå ä½ç¬¦placeholderã€‚å ä½ç¬¦å¹¶æ²¡æœ‰åˆå§‹å€¼ï¼Œå®ƒåªä¼šåˆ†é…å¿…è¦çš„å†…å­˜ã€‚åœ¨ä¼šè¯ä¸­ï¼Œå ä½ç¬¦å¯ä»¥ä½¿ç”¨ feed_dict é¦ˆé€æ•°æ®ã€‚feed_dictæ˜¯ä¸€ä¸ªå­—å…¸ï¼Œåœ¨å­—å…¸ä¸­éœ€è¦ç»™å‡ºæ¯ä¸€ä¸ªç”¨åˆ°çš„å ä½ç¬¦çš„å–å€¼ã€‚ é‚£ä¹ˆï¼Œä»€ä¹ˆæ—¶å€™è¯¥ç”¨tf.placeholderï¼Œä»€ä¹ˆæ—¶å€™è¯¥ä½¿ç”¨tf.Variableä¹‹ç±»ç›´æŽ¥å®šä¹‰å‚æ•°å‘¢ï¼Ÿç­”æ¡ˆæ˜¯ï¼Œtf.Variableé€‚åˆä¸€äº›éœ€è¦åˆå§‹åŒ–æˆ–è¢«è®­ç»ƒè€Œå˜åŒ–çš„æƒé‡æˆ–å‚æ•°ï¼Œè€Œtf.placeholderé€‚åˆé€šå¸¸ä¸ä¼šæ”¹å˜çš„è¢«è®­ç»ƒçš„æ•°æ®é›†ã€‚ æºç ä¹Ÿå¯ä»¥å‚è€ƒè¿™é‡Œ logistic regression 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150import numpys as npimport matplotlib.pyplot as pltimport tensorflow as tfimport tempfileimport urllibimport pandas as pdimport osfrom tensorflow.examples.tutorials.mnist import input_data# tempfile è¿™ä¸ªæ¨¡å—ä¸»è¦æ˜¯ç”¨æ¥åˆ›å»ºä¸´æ—¶æ–‡ä»¶å’Œç›®å½•ï¼Œç”¨å®ŒåŽä¼šè‡ªåŠ¨åˆ é™¤ï¼Œçœçš„ä½ è‡ªå·±åŽ»åˆ›å»ºä¸€ä¸ªæ–‡ä»¶ã€ä½¿ç”¨è¿™ä¸ªæ–‡ä»¶ã€å†åˆ é™¤è¿™ä¸ªè¿‡ç¨‹äº†ã€‚max_num_checkpoint =10num_classes =2batch_size =512num_epochs =10# learning rateinitial_learning_rate =0.001learing_rate_decay_factor =0.95num_epochs_per_decay =1# statusis_training =Falsefine_tuning =Falseonline_test =Trueallow_soft_placement =Truelog_device_placement =False# Download and get MNIST dataset(available in tensorflow.contrib.learn.python.learn.datasets.mnist)# It checks and download MNIST if it's not already downloaded then extract it.# The 'reshape' is True by default to extract feature vectors but we set it to false to we get the original images.mnist = input_data.read_data_sets("MNIST_data/", reshape=True, one_hot=False)# data processing# è¿™ç§é”®å€¼å¯¹è¿˜èƒ½å†™æˆè¿™ç§å½¢å¼ï¼Œæˆ‘è‰data =&#123;&#125;data["train/image"] =mnist.train.imagesdata["train/label"] =mnist.train.labelsdata["test/image"] =mnist.test.imagesdata["test/label"] =mnist.test.labelsdef extract_samples_Fn(data): index_list =[] for sample_index in range(data.shape[0]): label =data[sample_index] if label ==1 or label ==0: index_list.append(sample_index) return index_listindex_list_train =extract_samples_Fn(data["train/label"])index_list_test =extract_samples_Fn(data["test/label"])data["train/image"] =mnist.train.images[index_list_train]data["train/label"] =mnist.train.labels[index_list_train]data["test/image"] =mnist.test.images[index_list_test]data["test/label"] =mnist.test.labels[index_list_test]dimenionality_train =data["train/image"].shapenum_train_samples =dimenionality_train[0]num_features =dimenionality_train[1]graph =tf.Graph()with graph.as_default(): global_step =tf.Variable(0, name= ="global_step", trainable =False) # decay steps æ˜¯å’Œ è®­ç»ƒæ ·æœ¬æ•°é‡ï¼Œ batch sizeç›¸å…³çš„ decay_steps = int(num_train_samples /batch_size * num_epochs_per_decay) learing_rate =tf.train.exponential_decay(initial_learning_rate, global_step, decay_steps, learing_rate_decay_factor, staircase=True, name="exponential_decay_learning_rate") # define placeholder image_place =tf.placeholder(tf.float32, shape=([None, num_features]), name= "image") label_place =tf.placeholder(tf.int32, shape=([None, ]), name = "gt") label_one_hot =tf.one_hot(label_place, depth= num_classes, axis= -1) # è¿™ä¸ªæ˜¯æŒ‰ç…§æœ€åŽä¸€ä¸ªè½´è¿›è¡Œæ“ä½œ dropout_param =tf.placeholder(tf.float32) # æˆ‘çš„ç†è§£è¿™ä¸ªä¸æ˜¯ä¸€ç§å¸¸é‡å—ï¼Œ ä¸ºä»€ä¹ˆè¿˜è¦ä½¿ç”¨ placeholder # fully connnected logits =tf.contrib.layers.fully_connected(inputs =image_place, num_outputs =num_classes, scope ="fc") # define loss, with tf.name_scope("loss"): loss_tensor =tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits =logits, labels= label_one_hot)) # argmax(, 0) è¿”å›žè¡Œä¸­çš„æœ€å¤§å€¼çš„ç´¢å¼•ï¼Œ è¿”å›žåˆ—ä¸­çš„æœ€å¤§ç´¢å¼• # tf.cast(predict_correct, tf.float32) ç±»åž‹è½¬æ¢ prediction_correct =tf.equal(tf.argmax(logits, 1), tf.argmax(label_one_hot, 1)) accuracy =tf.reduce_mean(tf.cast(prediction_correct, tf.float32)) # optimizer, ä¸Šé¢æ˜¯æ‰‹åŠ¨decayçš„ï¼ŒçŽ°åœ¨æœ‰äº†ä¸€ä¸ªè‡ªåŠ¨è°ƒæ•´ learning rate çš„å·¥å…· optimizer =tf.train.AdamOptimizer(learning_rate= learing_rate) with tf.name_scope("train_op"): # åŠ ä¸Šäº†ä¸€ä¸ªå‰ç¼€ gradients_and_variables =optimizer.compute_gradients(loss_tensor) train_op =optimizer.apply_gradients(gradients_and_variables, global_step= global_step) # run the session session_conf =tf.ConfigProto( allow_soft_placement =allow_soft_placement, log_device_placement =log_device_placement, ) sess =tf.Session(graph= graph, config= session_conf) with sess.as_default(): saver =tf.train.Saver() sess.run(tf.global_variables_initializer()) checkpoint_prefix ="model" if fine_tuning: saver.restore(sess, os.path.join(checkpoint_path, checkpoint_prefix)) print(" Model restored for fine-tuning") test_accuracy =0 for epoch in range(num_epochs): # batch çš„æ¬¡æ•° æ˜¯å’Œ data å’Œ batch_size ç›¸å…³çš„ total_batch_training =int(data["data/image"].shape[0] /batch_size) for batch_num in range(total_batch_training): start_idx =batch_num *batch_size end_idx =(batch_num +1) * batch_size train_batch_data, train_batch_label =data['train/image'][start_idx: end_idx], data["train/label"][start_idx: end_idx] batch_loss, _, training_step = sess.run([ loss_tensor, train_op, global_step], feed_dict=&#123;image_place: train_batch_data, label_place: train_batch_label, dropout_param: 0.5&#125;) # ä½¿ç”¨å ä½ç¬¦è¿›è¡Œçš„è¾“å‡º print("Epoch "+ str(epoch +1) +", Training loss =" + "&#123;:.5f&#125;".format(batch_loss)) # æ¯è¿›è¡Œä¸€ä¸ªbatch é‚£ä¹ˆæ˜¯éœ€è¦é‡æ–°è®¡ç®—ä¸€ä¸‹ accçš„ test_accuracy = 100* sess.run(accuracy, feed_dict=&#123; image_place: data["test/image"], label_place: data["test/label"], dropout_param :1.&#125;) # åœ¨è¿›è¡Œtest çš„æ—¶å€™æ˜¯ä¸éœ€è¦è¿›è¡Œ dropoutçš„ print(" Final Test Accuracy is %% %.2f" %test_accuracy) RNN åœ¨ tensorflow ä¸­çš„ä½¿ç”¨ å­¦ä¹ å•æ­¥æ‰§è¡Œçš„RNN ï¼š RNNCell æ¯ä¸ªRNNCelléƒ½æœ‰ä¸€ä¸ªcallæ–¹æ³•ï¼Œä½¿ç”¨æ–¹å¼æ˜¯ï¼š(output, next_state) = call(input, state)ã€‚å€ŸåŠ©å›¾ç‰‡æ¥è¯´å¯èƒ½æ›´å®¹æ˜“ç†è§£ã€‚å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªåˆå§‹çŠ¶æ€h0ï¼Œè¿˜æœ‰è¾“å…¥x1ï¼Œè°ƒç”¨call(x1, h0)åŽå°±å¯ä»¥å¾—åˆ°(output1, h1)ï¼š å†è°ƒç”¨ä¸€æ¬¡call(x2, h1)å°±å¯ä»¥å¾—åˆ°(output2, h2)ï¼š ä¹Ÿå°±æ˜¯è¯´ï¼Œæ¯è°ƒç”¨ä¸€æ¬¡RNNCellçš„callæ–¹æ³•ï¼Œå°±ç›¸å½“äºŽåœ¨æ—¶é—´ä¸Šâ€œæŽ¨è¿›äº†ä¸€æ­¥â€ï¼Œè¿™å°±æ˜¯RNNCellçš„åŸºæœ¬åŠŸèƒ½ã€‚ é™¤äº†callæ–¹æ³•å¤–ï¼Œå¯¹äºŽRNNCellï¼Œè¿˜æœ‰ä¸¤ä¸ªç±»å±žæ€§æ¯”è¾ƒé‡è¦ï¼š state_size output_size å‰è€…æ˜¯éšå±‚çš„å¤§å°ï¼ŒåŽè€…æ˜¯è¾“å‡ºçš„å¤§å°ã€‚æ¯”å¦‚æˆ‘ä»¬é€šå¸¸æ˜¯å°†ä¸€ä¸ªbatché€å…¥æ¨¡åž‹è®¡ç®—ï¼Œè®¾è¾“å…¥æ•°æ®çš„å½¢çŠ¶ä¸º(batch_size, input_size)ï¼Œé‚£ä¹ˆè®¡ç®—æ—¶å¾—åˆ°çš„éšå±‚çŠ¶æ€å°±æ˜¯(batch_size, state_size)ï¼Œè¾“å‡ºå°±æ˜¯(batch_size, output_size)ã€‚ ä¸€æ¬¡æ‰§è¡Œå¤šæ­¥ï¼š tf.nn.dynamic_rnn tf.nn.dynamic_rnnå‡½æ•°ï¼Œä½¿ç”¨è¯¥å‡½æ•°å°±ç›¸å½“äºŽè°ƒç”¨äº†næ¬¡callå‡½æ•°ã€‚å³é€šè¿‡{h0,x1, x2, â€¦., xn}ç›´æŽ¥å¾—{h1,h2â€¦,hn}ã€‚ 1234# inputs: shape = (batch_size, time_steps, input_size) # cell: RNNCell# initial_state: shape = (batch_size, cell.state_size)ã€‚åˆå§‹çŠ¶æ€ã€‚ä¸€èˆ¬å¯ä»¥å–é›¶çŸ©é˜µoutputs, state = tf.nn.dynamic_rnn(cell, inputs, initial_state=initial_state) æ­¤æ—¶ï¼Œå¾—åˆ°çš„outputså°±æ˜¯time_stepsæ­¥é‡Œæ‰€æœ‰çš„è¾“å‡ºã€‚å®ƒçš„å½¢çŠ¶ä¸º(batch_size, time_steps, cell.output_size)ã€‚stateæ˜¯æœ€åŽä¸€æ­¥çš„éšçŠ¶æ€ï¼Œå®ƒçš„å½¢çŠ¶ä¸º(batch_size, cell.state_size)ã€‚ tf.nn.dynamic_rnn å‡½æ•°æ˜¯tensorflowå°è£…çš„ç”¨æ¥å®žçŽ°é€’å½’ç¥žç»ç½‘ç»œï¼ˆRNNï¼‰çš„å‡½æ•°ã€‚ 1234567891011tf.nn.dynamic_rnn( cell, inputs, sequence_length=None, initial_state=None, dtype=None, parallel_iterations=None, swap_memory=False, time_major=False, scope=None) é‡è¦å‚æ•°ä»‹ç»ï¼š ï¼ˆä¸ªäººæ„Ÿè§‰è¿™å‚æ•°è¿˜æ˜¯æŒºé‡è¦çš„ï¼Œå¯ä»¥æ”¾ä»»ä½•ä¸œè¥¿ï¼‰cellï¼šLSTMã€GRUç­‰çš„è®°å¿†å•å…ƒã€‚cellå‚æ•°ä»£è¡¨ä¸€ä¸ªLSTMæˆ–GRUçš„è®°å¿†å•å…ƒï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªcellã€‚ä¾‹å¦‚ï¼Œcell = tf.nn.rnn_cell.LSTMCell((num_units)ï¼Œå…¶ä¸­ï¼Œnum_unitsè¡¨ç¤ºrnn cellä¸­ç¥žç»å…ƒä¸ªæ•°ï¼Œä¹Ÿå°±æ˜¯ä¸‹æ–‡çš„cell.output_sizeã€‚è¿”å›žä¸€ä¸ªLSTMæˆ–GRU cellï¼Œä½œä¸ºå‚æ•°ä¼ å…¥ã€‚ inputsï¼šè¾“å…¥çš„è®­ç»ƒæˆ–æµ‹è¯•æ•°æ®ï¼Œä¸€èˆ¬æ ¼å¼ä¸º[batch_size, max_time, embed_size]ï¼Œå…¶ä¸­batch_sizeæ˜¯è¾“å…¥çš„è¿™æ‰¹æ•°æ®çš„æ•°é‡ï¼Œmax_timeå°±æ˜¯è¿™æ‰¹æ•°æ®ä¸­åºåˆ—çš„æœ€é•¿é•¿åº¦ï¼Œembed_sizeè¡¨ç¤ºåµŒå…¥çš„è¯å‘é‡çš„ç»´åº¦ã€‚ sequence_lengthï¼šæ˜¯ä¸€ä¸ªlistï¼Œå‡è®¾ä½ è¾“å…¥äº†ä¸‰å¥è¯ï¼Œä¸”ä¸‰å¥è¯çš„é•¿åº¦åˆ†åˆ«æ˜¯5,10,25,é‚£ä¹ˆsequence_length=[5,10,25]ã€‚ å¦‚æžœæœ‰æ›´å¤šçš„æ—¶é—´ï¼Œé‚£ä¹ˆæ˜¯å¯ä»¥å­¦ä¹ ä¸€ä¸‹ charRNN è¿™ä¸ªæ¨¡åž‹ï¼Œè¿˜æ˜¯æ¯”è¾ƒæœ‰æ„æ€çš„ã€‚ RNN çš„ä¸€ä¸ªä¾‹å­1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import tensorflow as tfimport numpy as npimport matplotlib.pyplot as pltimport argparse# argparse è§£æžå‘½ä»¤è¡Œå‚æ•°learing_rate =0.001seed =111# trainingbatch_size =128num_epoch =10hidden_size =128# è¿™ä¸ªæ˜¯å¾ˆå¥½çš„æ–¹å¼ï¼Œå¯ä»¥ç”¨æ¥ é‡çŽ°å®žéªŒç»“æžœçš„# Reset the graph set the random numbers to be the same using "seed"tf.reset_default_graph()tf.set_random_seed(seed)np.random.seed(seed)# divde 28*28 images to rows of data to feed to RNN as sequantial informationstep_size= 28input_size =28output_size =10X =tf.placeholder(tf.float32, [None, step_size, input_size])y =tf.placeholder(tf.int32, [None])# RNNcell =tf.nn.rnn_cell.BasicRNNCell( num_units= hidden_size)output, state =tf.nn.dynamic_rnn(cell, X, dtype =tf.float32)# dynamic_rnn(cell, inputs)# state è¡¨ç¤ºæœ€åŽä¸€å±‚çš„éšçŠ¶æ€ï¼Œoutput è¿™ä¸ªè¿˜æ˜¯æœ‰ç‚¹æ¨¡ç³Šçš„# forward pass and loss calculationlogits = tf.layers.dense(state, output_size)# åªæœ‰åœ¨å®žçŽ°çš„æ—¶å€™ï¼Œæ‰èƒ½åˆ‡èº«çš„æ„Ÿå—åˆ° loss function æ˜¯ä»€ä¹ˆcross_entropy =tf.nn.sparse_softmax_cross_entropy_with_logits(labels= y, logits =logits)loss =tf.reduce_mean(cross_entropy)optimizer =tf.train.AdamOptimizer(learning_rate=learing_rate).minimize(loss)# Prediction,prediction =tf.nn.in_top_k(logits, y, 1) # è¿™ä¸ªè¯­å¥æ„Ÿè§‰æ˜¯è¯´ä¸é€šçš„accuracy =tf.reduce_mean(tf.cast(prediction, tf.float32))# input datafrom tensorflow.examples.tutorials.mnist import input_datamnist =input_data.read_data_sets("MNIST_data/")# process MNISTX_test =mnist.test.imagesX_test =X_test.reshape([-1, step_size, input_size])y_test =mnist.test.labelsinit =tf.global_variables_initializer()loss_train_list =[]acc_train_list =[]with tf.Session() as sess: sess.run(init) n_batches =mnist.train.num_examples / batch_size for epoch in range(num_epoch): # è¿­ä»£çš„æ¬¡æ•° for batch in range(n_batches): # è¿™ä¸ªæ˜¯ä¸€ä¸ª batchçš„ä¸œè¥¿ X_train, y_train =mnist.train.next_batch(batch_size) X_train =X_train.reshape([-1, step_size, input_size]) # ç¬¬ä¸€ä¸ªå‚æ•°æœ‰æ—¶å€™è¿˜æ˜¯ä¸å¤ªä¸€æ ·çš„ï¼Œ å¹¶ä¸æ€»æ˜¯ loss sess.run(optimizer, feed_dict=&#123;X: X_train, y: y_train&#125;) loss_train, acc_train = sess.run([loss, accuracy],feed_dict=&#123;X: X_train, y: y_train&#125;) loss_train_list.append(loss_train) acc_train_list.append(acc_train) # æ¯ä¸€ä¸ª epoch ä¹‹åŽæ˜¯è¿›è¡Œè¾“å‡ºçš„ print("Epoch :&#123;&#125;, Train loss :&#123;:.3f&#125;, Train Acc &#123;:.3f&#125;".format(epoch+1, loss_train, acc_train)) loss_test, acc_test =sess.run([loss, acc_test], feed_dict=&#123;X: X_test, y: y_test&#125;) print("Test Loss: &#123;:.3f&#125;, Test ACC: &#123;:.3f&#125;".format(loss_test, acc_test))]]></content>
      <categories>
        <category>Deep learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BERTå­¦ä¹ ç¬”è®°(2)]]></title>
    <url>%2F2019%2F06%2F16%2Fnlp_bert(2)%2F</url>
    <content type="text"><![CDATA[å­¦ä¹ BERTæ¨¡åž‹è¯¦è§£ ç¬”è®°ã€‚ ï¼ˆä¼ ç»Ÿçš„æœºå™¨å­¦ä¹ ç‰¹å¾ç¡®å®žæ˜¯ç¨€ç–ï¼‰Word Embeddingè§£å†³äº†ä¼ ç»Ÿæœºå™¨å­¦ä¹ æ–¹æ³•çš„ç‰¹å¾ç¨€ç–é—®é¢˜ï¼Œå®ƒé€šè¿‡æŠŠä¸€ä¸ªè¯æ˜ å°„åˆ°ä¸€ä¸ªä½Žç»´ç¨ å¯†çš„è¯­ä¹‰ç©ºé—´ï¼Œä»Žè€Œä½¿å¾—ç›¸ä¼¼çš„è¯å¯ä»¥å…±äº«ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œä»Žè€Œæå‡æ³›åŒ–èƒ½åŠ›ã€‚ ï¼ˆä¸åŒçš„å¯¹è±¡å¯¹æ¯”ï¼Œæ˜¯æœ‰ä¸åŒçš„ä¾§é‡ç‚¹çš„ï¼‰Self-Attentionçš„åˆè¡·æ˜¯ä¸ºäº†ç”¨Attentionæ›¿ä»£LSTMï¼Œä»Žè€Œå¯ä»¥æ›´å¥½çš„å¹¶è¡Œ(å› ä¸ºLSTMçš„æ—¶åºä¾èµ–ç‰¹æ•ˆå¾ˆéš¾å¹¶è¡Œ)ï¼Œä»Žè€Œå¯ä»¥å¤„ç†æ›´å¤§è§„æ¨¡çš„è¯­æ–™ã€‚ transformer æ˜¯å¯ä»¥ä½œä¸ºä¸€ä¸ªåŸºæœ¬çš„ encoder æˆ–è€…decoder è€Œå­˜åœ¨ï¼Œè¿™ä¸ªå¯¹ç­‰çš„åœ°ä½æ˜¯å’Œ lstm æ˜¯ç›¸åŒçš„ã€‚ å½“ç„¶é€šè¿‡Multi-Task Learningï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨å…¶å®ƒç›¸å…³ä»»åŠ¡çš„æ•°æ®ã€‚æ¯”å¦‚æˆ‘ä»¬è¦åšæ–‡æœ¬åˆ†ç±»ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨æœºå™¨ç¿»è¯‘çš„è®­ç»ƒæ•°æ®ï¼Œé€šè¿‡åŒæ—¶ä¼˜åŒ–ä¸¤ä¸ª(å¤šä¸ª)ç›®æ ‡ï¼Œè®©æ¨¡åž‹åŒæ—¶å­¦åˆ°ä¸¤ä¸ªä»»åŠ¡ä¸Šçš„è¯­ä¹‰ä¿¡æ¯ï¼Œå› ä¸ºè¿™ä¸¤ä¸ªä»»åŠ¡è‚¯å®šæ˜¯å…±äº«å¾ˆå¤šåŸºç¡€è¯­ä¹‰ä¿¡æ¯çš„ï¼Œæ‰€ä»¥å®ƒçš„æ•ˆæžœè¦æ¯”å•ä¸ªä»»åŠ¡å¥½ã€‚ä½†å³ä½¿è¿™æ ·ï¼Œæ ‡æ³¨çš„æ•°æ®é‡è¿˜æ˜¯éžå¸¸æœ‰é™çš„ã€‚ å› ä¸ºæ•°æ®é‡çš„é—®é¢˜ï¼Œæ‰€ä»¥è½¬å‘äº†æ— ç›‘ç£å­¦ä¹ ï¼Œè¿™æ ·æ‰èƒ½ä½¿ç”¨å¤§è§„æ¨¡çš„æ•°æ®é›†ï¼Œä½¿ç”¨æµ·é‡çš„æ— æ ‡æ³¨çš„æ•°æ®å­¦ä¹ æ¨¡åž‹ã€‚å¤šä»»åŠ¡å­¦ä¹ ä¹Ÿæ˜¯å¯ä»¥è¢«ç”¨æ¥åšè¯æ±‡è¡¥å……çš„ã€‚ å…³äºŽbert çš„ç†è§£è¿˜æ˜¯è¦å¤šçœ‹çœ‹çš„ã€‚ è€ŒBERTå’ŒOpenAI GPTçš„æ–¹æ³•ç±»ä¼¼ï¼Œä¹Ÿæ˜¯Fine-Tuningçš„æ€è·¯ï¼Œä½†æ˜¯å®ƒè§£å†³äº†OpenAI GPT(åŒ…æ‹¬ELMo)å•å‘ä¿¡æ¯æµçš„é—®é¢˜ï¼ŒåŒæ—¶å®ƒçš„æ¨¡åž‹å’Œè¯­æ–™åº“ä¹Ÿæ›´å¤§ã€‚ä¾èµ–Googleå¼ºå¤§çš„è®¡ç®—èƒ½åŠ›å’Œå·¥ç¨‹èƒ½åŠ›ï¼ŒBERTæ¨ªæ‰«äº†OpenAI GPTã€‚æˆçŽ‹è´¥å¯‡ï¼Œå¾ˆå°‘è¿˜æœ‰äººè®°å¾—OpenAI GPTçš„è´¡çŒ®äº†ã€‚ä½†æ˜¯BERTçš„å¾ˆå¤šæ€è·¯éƒ½æ˜¯æ²¿ç”¨OpenAI GPTçš„ï¼Œè¦è¯´BERTçš„å­¦æœ¯è´¡çŒ®ï¼Œæœ€å¤šæ˜¯åˆ©ç”¨äº†Mask LM(è¿™ä¸ªæ¨¡åž‹åœ¨ä¸Šä¸–çºªå°±å­˜åœ¨äº†)å’ŒPredicting Next Sentenceè¿™ä¸ªMulti-task Learningè€Œå·²ã€‚ ï¼ˆé¦–å…ˆ transformer ä¸€å¼€å§‹å°±æ˜¯ç”¨æ¥åš æœºå™¨ç¿»è¯‘çš„ï¼Œå…¶æ¬¡è¿™æ®µè½æ˜¯ä¸å¤ªç†è§£çš„ï¼Œ æ¥æºï¼‰ä¹‹å‰æˆ‘ä»¬ä»‹ç»çš„Transformeræ¨¡åž‹æ˜¯ç”¨æ¥åšæœºå™¨ç¿»è¯‘çš„ï¼Œå®ƒæœ‰ä¸€ä¸ªEncoderå’Œä¸€ä¸ªDecoderã€‚è¿™é‡Œä½¿ç”¨çš„æ˜¯Encoderï¼Œåªä¸è¿‡Encoderçš„è¾“å‡ºä¸æ˜¯ç»™Decoderä½¿ç”¨ï¼Œè€Œæ˜¯ç›´æŽ¥ç”¨å®ƒæ¥é¢„æµ‹ä¸‹ä¸€ä¸ªè¯ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ä½†æ˜¯ç›´æŽ¥ç”¨Self-Attentionæ¥è®­ç»ƒè¯­è¨€æ¨¡åž‹æ˜¯æœ‰é—®é¢˜çš„ï¼Œå› ä¸ºåœ¨kæ—¶åˆ»ð‘(ð‘¡ð‘˜|ð‘¡1,..,ð‘¡ð‘˜âˆ’1)ï¼Œä¹Ÿå°±æ˜¯è®¡ç®—ð‘¡ð‘˜çš„æ—¶å€™åªèƒ½åˆ©ç”¨å®ƒä¹‹å‰çš„è¯(æˆ–è€…é€†å‘çš„è¯­è¨€æ¨¡åž‹åªèƒ½ç”¨å®ƒä¹‹åŽçš„è¯)ã€‚ä½†æ˜¯Transformerçš„Self-Attentionæ˜¯å¯ä»¥åˆ©ç”¨æ•´ä¸ªå¥å­çš„ä¿¡æ¯çš„ï¼Œè¿™æ˜¾ç„¶ä¸è¡Œï¼Œå› ä¸ºä½ è®©å®ƒæ ¹æ®â€it is aâ€æ¥é¢„æµ‹åŽé¢çš„è¯ï¼Œè€Œä¸”è¿˜å‘Šè¯‰å®ƒæ•´ä¸ªå¥å­æ˜¯â€it is a good dayâ€ï¼Œå®ƒå°±å¯èƒ½â€ä½œå¼Šâ€ï¼Œç›´æŽ¥æŠŠä¸‹ä¸€ä¸ªè¯è¾“å‡ºäº†ï¼Œè¿™æ ·lossæ˜¯é›¶ã€‚ å¯¹äºŽç›¸ä¼¼åº¦çš„è®¡ç®—æ˜¯æœ‰ä¸¤ç§é€”å¾„ï¼š é€šè¿‡æ— ç›‘ç£çš„å­¦ä¹ å¾—åˆ°è¯å‘é‡ï¼Œç„¶åŽä½¿ç”¨è¯å‘é‡è®¡ç®—å¥å­çš„ç›¸ä¼¼åº¦ï¼ˆæ— ç›‘ç£çš„ï¼‰ å¦‚æžœæœ‰æ ‡æ³¨çš„è®­ç»ƒé›†çš„è¯ï¼Œé‚£ä¹ˆæ˜¯å¯ä»¥ä½¿ç”¨ seq2seq è¿™æ ·çš„æ¨¡åž‹ è¿›è¡Œæœ‰ç›‘ç£çš„å­¦ä¹ çš„ ELMoå’ŒGPTæœ€å¤§çš„é—®é¢˜å°±æ˜¯ä¼ ç»Ÿçš„è¯­è¨€æ¨¡åž‹æ˜¯å•å‘çš„â€”â€”æˆ‘ä»¬æ˜¯æ ¹æ®ä¹‹å‰çš„åŽ†å²æ¥é¢„æµ‹å½“å‰è¯ã€‚ä½†æ˜¯æˆ‘ä»¬ä¸èƒ½åˆ©ç”¨åŽé¢çš„ä¿¡æ¯ã€‚æ¯”å¦‚å¥å­â€The animal didnâ€™t cross the street because it was too tiredâ€ã€‚æˆ‘ä»¬åœ¨ç¼–ç itçš„è¯­ä¹‰çš„æ—¶å€™éœ€è¦åŒæ—¶åˆ©ç”¨å‰åŽçš„ä¿¡æ¯ï¼Œå› ä¸ºåœ¨è¿™ä¸ªå¥å­ä¸­ï¼Œitå¯èƒ½æŒ‡ä»£animalä¹Ÿå¯èƒ½æŒ‡ä»£streetã€‚æ ¹æ®tiredï¼Œæˆ‘ä»¬æŽ¨æ–­å®ƒæŒ‡ä»£çš„æ˜¯animalï¼Œå› ä¸ºstreetæ˜¯ä¸èƒ½tiredã€‚ä½†æ˜¯å¦‚æžœæŠŠtiredæ”¹æˆwideï¼Œé‚£ä¹ˆitå°±æ˜¯æŒ‡ä»£streetäº†ã€‚ä¼ ç»Ÿçš„è¯­è¨€æ¨¡åž‹ï¼Œä¸ç®¡æ˜¯RNNè¿˜æ˜¯Transformerï¼Œå®ƒéƒ½åªèƒ½åˆ©ç”¨å•æ–¹å‘çš„ä¿¡æ¯ã€‚æ¯”å¦‚å‰å‘çš„RNNï¼Œåœ¨ç¼–ç itçš„æ—¶å€™å®ƒçœ‹åˆ°äº†animalå’Œstreetï¼Œä½†æ˜¯å®ƒè¿˜æ²¡æœ‰çœ‹åˆ°tiredï¼Œå› æ­¤å®ƒä¸èƒ½ç¡®å®šitåˆ°åº•æŒ‡ä»£ä»€ä¹ˆã€‚å¦‚æžœæ˜¯åŽå‘çš„RNNï¼Œåœ¨ç¼–ç çš„æ—¶å€™å®ƒçœ‹åˆ°äº†tiredï¼Œä½†æ˜¯å®ƒè¿˜æ ¹æœ¬æ²¡çœ‹åˆ°animalï¼Œå› æ­¤å®ƒä¹Ÿä¸èƒ½çŸ¥é“æŒ‡ä»£çš„æ˜¯animalã€‚Transformerçš„Self-Attentionç†è®ºä¸Šæ˜¯å¯ä»¥åŒæ—¶attend toåˆ°è¿™ä¸¤ä¸ªè¯çš„ï¼Œä½†æ˜¯æ ¹æ®å‰é¢çš„ä»‹ç»ï¼Œç”±äºŽæˆ‘ä»¬éœ€è¦ç”¨Transformeræ¥å­¦ä¹ è¯­è¨€æ¨¡åž‹ï¼Œå› æ­¤å¿…é¡»ç”¨Maskæ¥è®©å®ƒçœ‹ä¸åˆ°æœªæ¥çš„ä¿¡æ¯ï¼Œæ‰€ä»¥å®ƒä¹Ÿä¸èƒ½è§£å†³è¿™ä¸ªé—®é¢˜çš„ã€‚ å¦‚ä¸‹å›¾æ‰€ç¤ºï¼ŒBERTèƒ½å¤ŸåŒæ—¶åˆ©ç”¨å‰åŽä¸¤ä¸ªæ–¹å‘çš„ä¿¡æ¯ï¼Œè€ŒELMoå’ŒGPTåªèƒ½ä½¿ç”¨å•ä¸ªæ–¹å‘çš„ã€‚ BERTä»ç„¶ä½¿ç”¨çš„æ˜¯Transformeræ¨¡åž‹ï¼Œé‚£å®ƒæ˜¯æ€Žä¹ˆè§£å†³è¯­è¨€æ¨¡åž‹åªèƒ½åˆ©ç”¨ä¸€ä¸ªæ–¹å‘çš„ä¿¡æ¯çš„é—®é¢˜å‘¢ï¼Ÿç­”æ¡ˆæ˜¯å®ƒçš„pretrainingè®­ç»ƒçš„ä¸æ˜¯æ™®é€šçš„è¯­è¨€æ¨¡åž‹ï¼Œè€Œæ˜¯Maskè¯­è¨€æ¨¡åž‹ã€‚åœ¨ä»‹ç»Maskè¯­è¨€æ¨¡åž‹ä¹‹å‰æˆ‘ä»¬å…ˆä»‹ç»BERTçš„è¾“å…¥è¡¨ç¤ºã€‚ è¾“å…¥è¡¨ç¤º BERTçš„è¾“å…¥è¡¨ç¤ºå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚æ¯”å¦‚è¾“å…¥çš„æ˜¯ä¸¤ä¸ªå¥å­â€my dog is cuteâ€ï¼Œâ€he likes playingâ€ã€‚åŽé¢ä¼šè§£é‡Šä¸ºä»€ä¹ˆéœ€è¦ä¸¤ä¸ªå¥å­ã€‚è¿™é‡Œé‡‡ç”¨ç±»ä¼¼GPTçš„ä¸¤ä¸ªå¥å­çš„è¡¨ç¤ºæ–¹æ³•ï¼Œé¦–å…ˆä¼šåœ¨ç¬¬ä¸€ä¸ªå¥å­çš„å¼€å¤´å¢žåŠ ä¸€ä¸ªç‰¹æ®Šçš„Token [CLS]ï¼Œåœ¨cuteçš„åŽé¢å¢žåŠ ä¸€ä¸ª[SEP]è¡¨ç¤ºç¬¬ä¸€ä¸ªå¥å­ç»“æŸï¼Œåœ¨##ingåŽé¢ä¹Ÿä¼šå¢žåŠ ä¸€ä¸ª[SEP]ã€‚æ³¨æ„è¿™é‡Œçš„åˆ†è¯ä¼šæŠŠâ€playingâ€åˆ†æˆâ€playâ€å’Œâ€##ingâ€ä¸¤ä¸ªTokenï¼Œè¿™ç§æŠŠè¯åˆ†æˆæ›´ç»†ç²’åº¦çš„Word Pieceçš„æ–¹æ³•åœ¨å‰é¢çš„æœºå™¨ç¿»è¯‘éƒ¨åˆ†ä»‹ç»è¿‡äº†ï¼Œè¿™æ˜¯ä¸€ç§è§£å†³æœªç™»å½•è¯çš„å¸¸è§åŠžæ³•ï¼ŒåŽé¢çš„ä»£ç éƒ¨åˆ†ä¹Ÿä¼šç®€å•ä»‹ç»ã€‚æŽ¥ç€å¯¹æ¯ä¸ªTokenè¿›è¡Œ3ä¸ªEmbeddingï¼šè¯çš„Embeddingï¼›ä½ç½®çš„Embeddingå’ŒSegmentçš„Embeddingã€‚è¯çš„Embeddingå¤§å®¶éƒ½å¾ˆç†Ÿæ‚‰äº†ï¼Œè€Œä½ç½®çš„Embeddingå’Œè¯ç±»ä¼¼ï¼ŒæŠŠä¸€ä¸ªä½ç½®(æ¯”å¦‚2)æ˜ å°„æˆä¸€ä¸ªä½Žç»´ç¨ å¯†çš„å‘é‡ã€‚è€ŒSegmentåªæœ‰ä¸¤ä¸ªï¼Œè¦ä¹ˆæ˜¯å±žäºŽç¬¬ä¸€ä¸ªå¥å­(segment)è¦ä¹ˆå±žäºŽç¬¬äºŒä¸ªå¥å­ï¼Œä¸ç®¡é‚£ä¸ªå¥å­ï¼Œå®ƒéƒ½å¯¹åº”ä¸€ä¸ªEmbeddingå‘é‡ã€‚åŒä¸€ä¸ªå¥å­çš„Segment Embeddingæ˜¯å…±äº«çš„ï¼Œè¿™æ ·å®ƒèƒ½å¤Ÿå­¦ä¹ åˆ°å±žäºŽä¸åŒSegmentçš„ä¿¡æ¯ã€‚å¯¹äºŽæƒ…æ„Ÿåˆ†ç±»è¿™æ ·çš„ä»»åŠ¡ï¼Œåªæœ‰ä¸€ä¸ªå¥å­ï¼Œå› æ­¤Segment idæ€»æ˜¯0ï¼›è€Œå¯¹äºŽEntailmentä»»åŠ¡ï¼Œè¾“å…¥æ˜¯ä¸¤ä¸ªå¥å­ï¼Œå› æ­¤Segmentæ˜¯0æˆ–è€…1ã€‚ BERTæ¨¡åž‹è¦æ±‚æœ‰ä¸€ä¸ªå›ºå®šçš„Sequenceçš„é•¿åº¦ï¼Œæ¯”å¦‚128ã€‚å¦‚æžœä¸å¤Ÿå°±åœ¨åŽé¢paddingï¼Œå¦åˆ™å°±æˆªå–æŽ‰å¤šä½™çš„Tokenï¼Œä»Žè€Œä¿è¯è¾“å…¥æ˜¯ä¸€ä¸ªå›ºå®šé•¿åº¦çš„Tokenåºåˆ—ï¼ŒåŽé¢çš„ä»£ç ä¼šè¯¦ç»†çš„ä»‹ç»ã€‚ç¬¬ä¸€ä¸ªTokenæ€»æ˜¯ç‰¹æ®Šçš„[CLS]ï¼Œå®ƒæœ¬èº«æ²¡æœ‰ä»»ä½•è¯­ä¹‰ï¼Œå› æ­¤å®ƒä¼š(å¿…é¡»)ç¼–ç æ•´ä¸ªå¥å­(å…¶å®ƒè¯)çš„è¯­ä¹‰ã€‚ Mask LM ä¸ºäº†è§£å†³åªèƒ½åˆ©ç”¨å•å‘ä¿¡æ¯çš„é—®é¢˜ï¼ŒBERTä½¿ç”¨çš„æ˜¯Maskè¯­è¨€æ¨¡åž‹è€Œä¸æ˜¯æ™®é€šçš„è¯­è¨€æ¨¡åž‹ã€‚Maskè¯­è¨€æ¨¡åž‹æœ‰ç‚¹ç±»ä¼¼ä¸Žå®Œå½¢å¡«ç©ºâ€”â€”ç»™å®šä¸€ä¸ªå¥å­ï¼ŒæŠŠå…¶ä¸­æŸä¸ªè¯é®æŒ¡èµ·æ¥ï¼Œè®©äººçŒœæµ‹å¯èƒ½çš„è¯ã€‚è¿™é‡Œä¼šéšæœºçš„MaskæŽ‰15%çš„è¯ï¼Œç„¶åŽè®©BERTæ¥é¢„æµ‹è¿™äº›Maskçš„è¯ï¼Œé€šè¿‡è°ƒæ•´æ¨¡åž‹çš„å‚æ•°ä½¿å¾—æ¨¡åž‹é¢„æµ‹æ­£ç¡®çš„æ¦‚çŽ‡å°½å¯èƒ½å¤§ï¼Œè¿™ç­‰ä»·äºŽäº¤å‰ç†µçš„æŸå¤±å‡½æ•°ã€‚è¿™æ ·çš„Transformeråœ¨ç¼–ç ä¸€ä¸ªè¯çš„æ—¶å€™ä¼š(å¿…é¡»)å‚è€ƒä¸Šä¸‹æ–‡çš„ä¿¡æ¯ã€‚ ä½†æ˜¯è¿™æœ‰ä¸€ä¸ªé—®é¢˜ï¼šåœ¨Pretraining Mask LMæ—¶ä¼šå‡ºçŽ°ç‰¹æ®Šçš„Token [MASK]ï¼Œä½†æ˜¯åœ¨åŽé¢çš„fine-tuningæ—¶å´ä¸ä¼šå‡ºçŽ°ï¼Œè¿™ä¼šå‡ºçŽ°Mismatchçš„é—®é¢˜ã€‚å› æ­¤BERTä¸­ï¼Œå¦‚æžœæŸä¸ªTokenåœ¨è¢«é€‰ä¸­çš„15%ä¸ªTokené‡Œï¼Œåˆ™æŒ‰ç…§ä¸‹é¢çš„æ–¹å¼éšæœºçš„æ‰§è¡Œï¼š 80%çš„æ¦‚çŽ‡æ›¿æ¢æˆ[MASK]ï¼Œæ¯”å¦‚my dog is hairy â†’ my dog is [MASK] 10%çš„æ¦‚çŽ‡æ›¿æ¢æˆéšæœºçš„ä¸€ä¸ªè¯ï¼Œæ¯”å¦‚my dog is hairy â†’ my dog is apple 10%çš„æ¦‚çŽ‡æ›¿æ¢æˆå®ƒæœ¬èº«ï¼Œæ¯”å¦‚my dog is hairy â†’ my dog is hairy è¿™æ ·åšçš„å¥½å¤„æ˜¯ï¼ŒBERTå¹¶ä¸çŸ¥é“[MASK]æ›¿æ¢çš„æ˜¯å“ªä¸€ä¸ªè¯ï¼Œè€Œä¸”ä»»ä½•ä¸€ä¸ªè¯éƒ½æœ‰å¯èƒ½æ˜¯è¢«æ›¿æ¢æŽ‰çš„ï¼Œæ¯”å¦‚å®ƒçœ‹åˆ°çš„appleå¯èƒ½æ˜¯è¢«æ›¿æ¢çš„è¯ã€‚è¿™æ ·å¼ºè¿«æ¨¡åž‹åœ¨ç¼–ç å½“å‰æ—¶åˆ»çš„æ—¶å€™ä¸èƒ½å¤ªä¾èµ–äºŽå½“å‰çš„è¯ï¼Œè€Œè¦è€ƒè™‘å®ƒçš„ä¸Šä¸‹æ–‡ï¼Œç”šè‡³æ›´åŠ ä¸Šä¸‹æ–‡è¿›è¡Œâ€çº é”™â€ã€‚æ¯”å¦‚ä¸Šé¢çš„ä¾‹å­æ¨¡åž‹åœ¨ç¼–ç appleæ˜¯æ ¹æ®ä¸Šä¸‹æ–‡my dog isåº”è¯¥æŠŠapple(éƒ¨åˆ†)ç¼–ç æˆhairyçš„è¯­ä¹‰è€Œä¸æ˜¯appleçš„è¯­ä¹‰ã€‚ é¢„æµ‹å¥å­å…³ç³» åœ¨æœ‰äº›ä»»åŠ¡ä¸­ï¼Œæ¯”å¦‚é—®ç­”ï¼Œå‰åŽä¸¤ä¸ªå¥å­æœ‰ä¸€å®šçš„å…³è”å…³ç³»ï¼Œæˆ‘ä»¬å¸Œæœ›BERT Pretrainingçš„æ¨¡åž‹èƒ½å¤Ÿå­¦ä¹ åˆ°è¿™ç§å…³ç³»ã€‚å› æ­¤BERTè¿˜å¢žåŠ äº†ä¸€ä¸ªæ–°çš„ä»»åŠ¡â€”â€”é¢„æµ‹ä¸¤ä¸ªå¥å­æ˜¯å¦æœ‰å…³è”å…³ç³»ã€‚è¿™æ˜¯ä¸€ç§Multi-Task Learingã€‚BERTè¦æ±‚çš„Pretrainingçš„æ•°æ®æ˜¯ä¸€ä¸ªä¸€ä¸ªçš„â€æ–‡ç« â€ï¼Œæ¯”å¦‚å®ƒä½¿ç”¨äº†BookCorpuså’Œç»´åŸºç™¾ç§‘çš„æ•°æ®ï¼ŒBookCorpusæ˜¯å¾ˆå¤šæœ¬ä¹¦ï¼Œæ¯æœ¬ä¹¦çš„å‰åŽå¥å­æ˜¯æœ‰å…³è”å…³ç³»çš„ï¼›è€Œç»´åŸºç™¾ç§‘çš„æ–‡ç« çš„å‰åŽå¥å­ä¹Ÿæ˜¯æœ‰å…³ç³»çš„ã€‚å¯¹äºŽè¿™ä¸ªä»»åŠ¡ï¼ŒBERTä¼šä»¥50%çš„æ¦‚çŽ‡æŠ½å–æœ‰å…³è”çš„å¥å­(æ³¨æ„è¿™é‡Œçš„å¥å­å®žé™…åªæ˜¯è”ç³»çš„Tokenåºåˆ—ï¼Œä¸æ˜¯è¯­è¨€å­¦æ„ä¹‰ä¸Šçš„å¥å­)ï¼Œå¦å¤–ä»¥50%çš„æ¦‚çŽ‡éšæœºæŠ½å–ä¸¤ä¸ªæ— å…³çš„å¥å­ï¼Œç„¶åŽè®©BERTæ¨¡åž‹æ¥åˆ¤æ–­è¿™ä¸¤ä¸ªå¥å­æ˜¯å¦ç›¸å…³ã€‚æ¯”å¦‚ä¸‹é¢çš„ä¸¤ä¸ªç›¸å…³çš„å¥å­ï¼š [CLS] the man went to [MASK] store [SEP] he bought a gallon [MASK] milk [SEP] ä¸‹é¢æ˜¯ä¸¤ä¸ªä¸ç›¸å…³çš„å¥å­ï¼š [CLS] the man [MASK] to the store [SEP] penguin [MASK] are flight ##less birds [SEP] ELMO å’ŒOpenAI GPT çš„åŒºåˆ«ï¼š UMLFiTæ¯”è¾ƒå¤æ‚ï¼Œè€Œä¸”æ•ˆæžœä¹Ÿä¸æ˜¯ç‰¹åˆ«å¥½ï¼Œæˆ‘ä»¬æš‚ä¸”ä¸æã€‚ELMoå’ŒOpenAI GPTçš„æ€æƒ³å…¶å®žéžå¸¸éžå¸¸ç®€å•ï¼Œå°±æ˜¯ç”¨æµ·é‡çš„æ— æ ‡æ³¨æ•°æ®å­¦ä¹ è¯­è¨€æ¨¡åž‹ï¼Œåœ¨å­¦ä¹ è¯­è¨€æ¨¡åž‹çš„è¿‡ç¨‹ä¸­è‡ªç„¶è€Œç„¶çš„å°±å­¦åˆ°äº†ä¸Šä¸‹æ–‡çš„è¯­ä¹‰å…³ç³»ã€‚å®ƒä»¬éƒ½æ˜¯æ¥å­¦ä¹ ä¸€ä¸ªè¯­è¨€æ¨¡åž‹ï¼Œå‰è€…ä½¿ç”¨çš„æ˜¯LSTMè€ŒåŽè€…ä½¿ç”¨Transformerï¼Œåœ¨è¿›è¡Œä¸‹æ¸¸ä»»åŠ¡å¤„ç†çš„æ—¶å€™ä¹Ÿæœ‰æ‰€ä¸åŒï¼ŒELMoæ˜¯æŠŠå®ƒå½“æˆç‰¹å¾ã€‚æ‹¿åˆ†ç±»ä»»åŠ¡æ¥è¯´ï¼Œè¾“å…¥ä¸€ä¸ªå¥å­ï¼ŒELMoç”¨LSTMæŠŠå®ƒæ‰«ä¸€æ¬¡ï¼Œè¿™æ ·å°±å¯ä»¥å¾—åˆ°æ¯ä¸ªè¯çš„è¡¨ç¤ºï¼Œè¿™ä¸ªè¡¨ç¤ºæ˜¯è€ƒè™‘ä¸Šä¸‹æ–‡çš„ï¼Œå› æ­¤â€He deposited his money in this bankâ€å’Œâ€His soldiers were arrayed along the river bankâ€ä¸­çš„ä¸¤ä¸ªbankçš„å‘é‡æ˜¯ä¸åŒçš„ã€‚ä¸‹æ¸¸ä»»åŠ¡ç”¨è¿™äº›å‘é‡æ¥åšåˆ†ç±»ï¼Œå®ƒä¼šå¢žåŠ ä¸€äº›ç½‘ç»œå±‚ï¼Œä½†æ˜¯ELMoè¯­è¨€æ¨¡åž‹çš„å‚æ•°æ˜¯å›ºå®šçš„ã€‚è€ŒOpenAI GPTä¸åŒï¼Œå®ƒç›´æŽ¥ç”¨ç‰¹å®šä»»åŠ¡æ¥Fine-Tuning Transformerçš„å‚æ•°ã€‚å› ä¸ºç”¨ç‰¹å®šä»»åŠ¡çš„æ•°æ®æ¥è°ƒæ•´Transformerçš„å‚æ•°ï¼Œè¿™æ ·å®ƒæ›´å¯èƒ½å­¦ä¹ åˆ°ä¸Žè¿™ä¸ªä»»åŠ¡ç‰¹å®šçš„ä¸Šä¸‹æ–‡è¯­ä¹‰å…³ç³»ï¼Œå› æ­¤æ•ˆæžœä¹Ÿæ›´å¥½ã€‚ Skip Thought Vector åœ¨è®­ç»ƒè¯­æ–™ä¸Šçš„åŒºåˆ« å’Œè®­ç»ƒWord2Vecä¸åŒï¼ŒWord2Vecåªéœ€è¦æä¾›å¥å­ï¼Œè€ŒSkip Thought Vectoréœ€è¦æ–‡ç« (è‡³å°‘æ˜¯æ®µè½)ã€‚è®ºæ–‡ä½¿ç”¨çš„æ•°æ®é›†æ˜¯BookCorpus(http://yknzhu.wixsite.com/mbweb)ï¼Œç›®å‰ç½‘ç«™å·²ç»ä¸æä¾›ä¸‹è½½äº†ã€‚BookCorpusçš„ç»Ÿè®¡ä¿¡æ¯å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œæœ‰ä¸€ä¸‡å¤šæœ¬ä¹¦ï¼Œä¸ƒåƒå¤šä¸‡ä¸ªå¥å­ã€‚ è¯æ±‡æ‰©å±•ï¼š ä½¿ç”¨ä¸€ä¸ªword2vec çš„è¯å‘é‡åŽ»æ˜ å°„åœ¨è®­ç»ƒå¥å­å‘é‡ä¸­å¾—åˆ°çš„å‘é‡ï¼Œå…¶ä¸­çš„æ˜ å°„å…³ç³»æ˜¯ $w$, è¿™ä¸ªå‚æ•°å¯ä»¥é€šè¿‡å…±çŽ°è¯è¿›è¡Œå­¦ä¹ ã€‚ ç¬”è®°BERT çš„åˆ›æ–°ç‚¹åœ¨äºŽ mask LMå’Œ predicting next sentence è¿™ä¸ªå¤šä»»åŠ¡å­¦ä¹ ã€‚mask è¯­è¨€æ¨¡åž‹æœ‰ç‚¹åƒå®Œå½¢å¡«ç©ºï¼Œå¯¹ä¸€ä¸ªå¥å­ï¼Œä¼šéšæœºmask æŽ‰15% çš„è¯è¯­ï¼Œè®©bert æ¥é¢„æµ‹è¿™äº›è¯è¯­ã€‚è¿™äº›è¯80% æ˜¯è¢«æ›¿æ¢æˆ [MASK], 10% æ˜¯è¢«éšæœºæ›¿æ¢æˆä¸€ä¸ªè¯è¯­ï¼Œ10% æ˜¯æ›¿æ¢æˆå•è¯æœ¬èº«ã€‚åœ¨é¢„æµ‹å¥å­å…³ç³»ä¸­ï¼Œéšæœº50% æŠ½å–ä¸¤ä¸ªæ— å…³çš„å¥å­ï¼Œ50% æŠ½å–ä¸¤ä¸ªæœ‰å…³è”çš„å¥å­ï¼Œç„¶åŽä½¿ç”¨bert æ¨¡åž‹åˆ¤æ–­è¿™ä¸¤ä¸ªå¥å­çš„ç›¸å…³æ€§ã€‚åœ¨è®­ç»ƒçš„æ—¶å€™æ˜¯å¤šä»»åŠ¡å­¦ä¹ ã€‚ BERT å’ŒOpenAI GPT çš„åŒºåˆ«ï¼š ä»Žè®­ç»ƒç›®æ ‡ä¸Šè®²ï¼Œbert æ˜¯åŒæ—¶ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œè€Œå…¶ä»–çš„éƒ½æ˜¯å•å‘çš„ã€‚]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[tmp]]></title>
    <url>%2F2019%2F06%2F16%2Fnlp-tmp%2F</url>
    <content type="text"><![CDATA[å­¦ä¹ BERTæ¨¡åž‹è¯¦è§£ ç¬”è®°ã€‚ ï¼ˆä¼ ç»Ÿçš„æœºå™¨å­¦ä¹ ç‰¹å¾ç¡®å®žæ˜¯ç¨€ç–ï¼‰Word Embeddingè§£å†³äº†ä¼ ç»Ÿæœºå™¨å­¦ä¹ æ–¹æ³•çš„ç‰¹å¾ç¨€ç–é—®é¢˜ï¼Œå®ƒé€šè¿‡æŠŠä¸€ä¸ªè¯æ˜ å°„åˆ°ä¸€ä¸ªä½Žç»´ç¨ å¯†çš„è¯­ä¹‰ç©ºé—´ï¼Œä»Žè€Œä½¿å¾—ç›¸ä¼¼çš„è¯å¯ä»¥å…±äº«ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œä»Žè€Œæå‡æ³›åŒ–èƒ½åŠ›ã€‚ ï¼ˆä¸åŒçš„å¯¹è±¡å¯¹æ¯”ï¼Œæ˜¯æœ‰ä¸åŒçš„ä¾§é‡ç‚¹çš„ï¼‰Self-Attentionçš„åˆè¡·æ˜¯ä¸ºäº†ç”¨Attentionæ›¿ä»£LSTMï¼Œä»Žè€Œå¯ä»¥æ›´å¥½çš„å¹¶è¡Œ(å› ä¸ºLSTMçš„æ—¶åºä¾èµ–ç‰¹æ•ˆå¾ˆéš¾å¹¶è¡Œ)ï¼Œä»Žè€Œå¯ä»¥å¤„ç†æ›´å¤§è§„æ¨¡çš„è¯­æ–™ã€‚ transformer æ˜¯å¯ä»¥ä½œä¸ºä¸€ä¸ªåŸºæœ¬çš„ encoder æˆ–è€…decoder è€Œå­˜åœ¨ï¼Œè¿™ä¸ªå¯¹ç­‰çš„åœ°ä½æ˜¯å’Œ lstm æ˜¯ç›¸åŒçš„ã€‚ ï¼ˆå¤šä»»åŠ¡å­¦ä¹ ï¼‰å½“ç„¶é€šè¿‡Multi-Task Learningï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨å…¶å®ƒç›¸å…³ä»»åŠ¡çš„æ•°æ®ã€‚æ¯”å¦‚æˆ‘ä»¬è¦åšæ–‡æœ¬åˆ†ç±»ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨æœºå™¨ç¿»è¯‘çš„è®­ç»ƒæ•°æ®ï¼Œé€šè¿‡åŒæ—¶ä¼˜åŒ–ä¸¤ä¸ª(å¤šä¸ª)ç›®æ ‡ï¼Œè®©æ¨¡åž‹åŒæ—¶å­¦åˆ°ä¸¤ä¸ªä»»åŠ¡ä¸Šçš„è¯­ä¹‰ä¿¡æ¯ï¼Œå› ä¸ºè¿™ä¸¤ä¸ªä»»åŠ¡è‚¯å®šæ˜¯å…±äº«å¾ˆå¤šåŸºç¡€è¯­ä¹‰ä¿¡æ¯çš„ï¼Œæ‰€ä»¥å®ƒçš„æ•ˆæžœè¦æ¯”å•ä¸ªä»»åŠ¡å¥½ã€‚ä½†å³ä½¿è¿™æ ·ï¼Œæ ‡æ³¨çš„æ•°æ®é‡è¿˜æ˜¯éžå¸¸æœ‰é™çš„ã€‚ å› ä¸ºæ•°æ®é‡çš„é—®é¢˜ï¼Œæ‰€ä»¥è½¬å‘äº†æ— ç›‘ç£å­¦ä¹ ï¼Œè¿™æ ·æ‰èƒ½ä½¿ç”¨å¤§è§„æ¨¡çš„æ•°æ®é›†ï¼Œä½¿ç”¨æµ·é‡çš„æ— æ ‡æ³¨çš„æ•°æ®å­¦ä¹ æ¨¡åž‹ã€‚ å…³äºŽbert çš„ç†è§£è¿˜æ˜¯è¦å¤šçœ‹çœ‹çš„ã€‚ è€ŒBERTå’ŒOpenAI GPTçš„æ–¹æ³•ç±»ä¼¼ï¼Œä¹Ÿæ˜¯Fine-Tuningçš„æ€è·¯ï¼Œä½†æ˜¯å®ƒè§£å†³äº†OpenAI GPT(åŒ…æ‹¬ELMo)å•å‘ä¿¡æ¯æµçš„é—®é¢˜ï¼ŒåŒæ—¶å®ƒçš„æ¨¡åž‹å’Œè¯­æ–™åº“ä¹Ÿæ›´å¤§ã€‚ä¾èµ–Googleå¼ºå¤§çš„è®¡ç®—èƒ½åŠ›å’Œå·¥ç¨‹èƒ½åŠ›ï¼ŒBERTæ¨ªæ‰«äº†OpenAI GPTã€‚æˆçŽ‹è´¥å¯‡ï¼Œå¾ˆå°‘è¿˜æœ‰äººè®°å¾—OpenAI GPTçš„è´¡çŒ®äº†ã€‚ä½†æ˜¯BERTçš„å¾ˆå¤šæ€è·¯éƒ½æ˜¯æ²¿ç”¨OpenAI GPTçš„ï¼Œè¦è¯´BERTçš„å­¦æœ¯è´¡çŒ®ï¼Œæœ€å¤šæ˜¯åˆ©ç”¨äº†Mask LM(è¿™ä¸ªæ¨¡åž‹åœ¨ä¸Šä¸–çºªå°±å­˜åœ¨äº†)å’ŒPredicting Next Sentenceè¿™ä¸ªMulti-task Learningè€Œå·²ã€‚ ï¼ˆé¦–å…ˆ transformer ä¸€å¼€å§‹å°±æ˜¯ç”¨æ¥åš æœºå™¨ç¿»è¯‘çš„ï¼Œå…¶æ¬¡è¿™æ®µè½æ˜¯ä¸å¤ªç†è§£çš„ï¼Œ æ¥æºï¼‰ä¹‹å‰æˆ‘ä»¬ä»‹ç»çš„Transformeræ¨¡åž‹æ˜¯ç”¨æ¥åšæœºå™¨ç¿»è¯‘çš„ï¼Œå®ƒæœ‰ä¸€ä¸ªEncoderå’Œä¸€ä¸ªDecoderã€‚è¿™é‡Œä½¿ç”¨çš„æ˜¯Encoderï¼Œåªä¸è¿‡Encoderçš„è¾“å‡ºä¸æ˜¯ç»™Decoderä½¿ç”¨ï¼Œè€Œæ˜¯ç›´æŽ¥ç”¨å®ƒæ¥é¢„æµ‹ä¸‹ä¸€ä¸ªè¯ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ä½†æ˜¯ç›´æŽ¥ç”¨Self-Attentionæ¥è®­ç»ƒè¯­è¨€æ¨¡åž‹æ˜¯æœ‰é—®é¢˜çš„ï¼Œå› ä¸ºåœ¨kæ—¶åˆ»ð‘(ð‘¡ð‘˜|ð‘¡1,..,ð‘¡ð‘˜âˆ’1)ï¼Œä¹Ÿå°±æ˜¯è®¡ç®—ð‘¡ð‘˜çš„æ—¶å€™åªèƒ½åˆ©ç”¨å®ƒä¹‹å‰çš„è¯(æˆ–è€…é€†å‘çš„è¯­è¨€æ¨¡åž‹åªèƒ½ç”¨å®ƒä¹‹åŽçš„è¯)ã€‚ä½†æ˜¯Transformerçš„Self-Attentionæ˜¯å¯ä»¥åˆ©ç”¨æ•´ä¸ªå¥å­çš„ä¿¡æ¯çš„ï¼Œè¿™æ˜¾ç„¶ä¸è¡Œï¼Œå› ä¸ºä½ è®©å®ƒæ ¹æ®â€it is aâ€æ¥é¢„æµ‹åŽé¢çš„è¯ï¼Œè€Œä¸”è¿˜å‘Šè¯‰å®ƒæ•´ä¸ªå¥å­æ˜¯â€it is a good dayâ€ï¼Œå®ƒå°±å¯èƒ½â€ä½œå¼Šâ€ï¼Œç›´æŽ¥æŠŠä¸‹ä¸€ä¸ªè¯è¾“å‡ºäº†ï¼Œè¿™æ ·lossæ˜¯é›¶ã€‚ å¯¹äºŽç›¸ä¼¼åº¦çš„è®¡ç®—æ˜¯æœ‰ä¸¤ç§é€”å¾„ï¼š é€šè¿‡æ— ç›‘ç£çš„å­¦ä¹ å¾—åˆ°è¯å‘é‡ï¼Œç„¶åŽä½¿ç”¨è¯å‘é‡è®¡ç®—å¥å­çš„ç›¸ä¼¼åº¦ï¼ˆæ— ç›‘ç£çš„ï¼‰ å¦‚æžœæœ‰æ ‡æ³¨çš„è®­ç»ƒé›†çš„è¯ï¼Œé‚£ä¹ˆæ˜¯å¯ä»¥ä½¿ç”¨ seq2seq è¿™æ ·çš„æ¨¡åž‹ è¿›è¡Œæœ‰ç›‘ç£çš„å­¦ä¹ çš„ ELMoå’ŒGPTæœ€å¤§çš„é—®é¢˜å°±æ˜¯ä¼ ç»Ÿçš„è¯­è¨€æ¨¡åž‹æ˜¯å•å‘çš„â€”â€”æˆ‘ä»¬æ˜¯æ ¹æ®ä¹‹å‰çš„åŽ†å²æ¥é¢„æµ‹å½“å‰è¯ã€‚ä½†æ˜¯æˆ‘ä»¬ä¸èƒ½åˆ©ç”¨åŽé¢çš„ä¿¡æ¯ã€‚æ¯”å¦‚å¥å­â€The animal didnâ€™t cross the street because it was too tiredâ€ã€‚æˆ‘ä»¬åœ¨ç¼–ç itçš„è¯­ä¹‰çš„æ—¶å€™éœ€è¦åŒæ—¶åˆ©ç”¨å‰åŽçš„ä¿¡æ¯ï¼Œå› ä¸ºåœ¨è¿™ä¸ªå¥å­ä¸­ï¼Œitå¯èƒ½æŒ‡ä»£animalä¹Ÿå¯èƒ½æŒ‡ä»£streetã€‚æ ¹æ®tiredï¼Œæˆ‘ä»¬æŽ¨æ–­å®ƒæŒ‡ä»£çš„æ˜¯animalï¼Œå› ä¸ºstreetæ˜¯ä¸èƒ½tiredã€‚ä½†æ˜¯å¦‚æžœæŠŠtiredæ”¹æˆwideï¼Œé‚£ä¹ˆitå°±æ˜¯æŒ‡ä»£streetäº†ã€‚ä¼ ç»Ÿçš„è¯­è¨€æ¨¡åž‹ï¼Œä¸ç®¡æ˜¯RNNè¿˜æ˜¯Transformerï¼Œå®ƒéƒ½åªèƒ½åˆ©ç”¨å•æ–¹å‘çš„ä¿¡æ¯ã€‚æ¯”å¦‚å‰å‘çš„RNNï¼Œåœ¨ç¼–ç itçš„æ—¶å€™å®ƒçœ‹åˆ°äº†animalå’Œstreetï¼Œä½†æ˜¯å®ƒè¿˜æ²¡æœ‰çœ‹åˆ°tiredï¼Œå› æ­¤å®ƒä¸èƒ½ç¡®å®šitåˆ°åº•æŒ‡ä»£ä»€ä¹ˆã€‚å¦‚æžœæ˜¯åŽå‘çš„RNNï¼Œåœ¨ç¼–ç çš„æ—¶å€™å®ƒçœ‹åˆ°äº†tiredï¼Œä½†æ˜¯å®ƒè¿˜æ ¹æœ¬æ²¡çœ‹åˆ°animalï¼Œå› æ­¤å®ƒä¹Ÿä¸èƒ½çŸ¥é“æŒ‡ä»£çš„æ˜¯animalã€‚Transformerçš„Self-Attentionç†è®ºä¸Šæ˜¯å¯ä»¥åŒæ—¶attend toåˆ°è¿™ä¸¤ä¸ªè¯çš„ï¼Œä½†æ˜¯æ ¹æ®å‰é¢çš„ä»‹ç»ï¼Œç”±äºŽæˆ‘ä»¬éœ€è¦ç”¨Transformeræ¥å­¦ä¹ è¯­è¨€æ¨¡åž‹ï¼Œå› æ­¤å¿…é¡»ç”¨Maskæ¥è®©å®ƒçœ‹ä¸åˆ°æœªæ¥çš„ä¿¡æ¯ï¼Œæ‰€ä»¥å®ƒä¹Ÿä¸èƒ½è§£å†³è¿™ä¸ªé—®é¢˜çš„ã€‚ å¦‚ä¸‹å›¾æ‰€ç¤ºï¼ŒBERTèƒ½å¤ŸåŒæ—¶åˆ©ç”¨å‰åŽä¸¤ä¸ªæ–¹å‘çš„ä¿¡æ¯ï¼Œè€ŒELMoå’ŒGPTåªèƒ½ä½¿ç”¨å•ä¸ªæ–¹å‘çš„ã€‚ BERTä»ç„¶ä½¿ç”¨çš„æ˜¯Transformeræ¨¡åž‹ï¼Œé‚£å®ƒæ˜¯æ€Žä¹ˆè§£å†³è¯­è¨€æ¨¡åž‹åªèƒ½åˆ©ç”¨ä¸€ä¸ªæ–¹å‘çš„ä¿¡æ¯çš„é—®é¢˜å‘¢ï¼Ÿç­”æ¡ˆæ˜¯å®ƒçš„pretrainingè®­ç»ƒçš„ä¸æ˜¯æ™®é€šçš„è¯­è¨€æ¨¡åž‹ï¼Œè€Œæ˜¯Maskè¯­è¨€æ¨¡åž‹ã€‚åœ¨ä»‹ç»Maskè¯­è¨€æ¨¡åž‹ä¹‹å‰æˆ‘ä»¬å…ˆä»‹ç»BERTçš„è¾“å…¥è¡¨ç¤ºã€‚ è¾“å…¥è¡¨ç¤º BERTçš„è¾“å…¥è¡¨ç¤ºå¦‚å›¾ä¸‹å›¾æ‰€ç¤ºã€‚æ¯”å¦‚è¾“å…¥çš„æ˜¯ä¸¤ä¸ªå¥å­â€my dog is cuteâ€ï¼Œâ€he likes playingâ€ã€‚åŽé¢ä¼šè§£é‡Šä¸ºä»€ä¹ˆéœ€è¦ä¸¤ä¸ªå¥å­ã€‚è¿™é‡Œé‡‡ç”¨ç±»ä¼¼GPTçš„ä¸¤ä¸ªå¥å­çš„è¡¨ç¤ºæ–¹æ³•ï¼Œé¦–å…ˆä¼šåœ¨ç¬¬ä¸€ä¸ªå¥å­çš„å¼€å¤´å¢žåŠ ä¸€ä¸ªç‰¹æ®Šçš„Token [CLS]ï¼Œåœ¨cuteçš„åŽé¢å¢žåŠ ä¸€ä¸ª[SEP]è¡¨ç¤ºç¬¬ä¸€ä¸ªå¥å­ç»“æŸï¼Œåœ¨##ingåŽé¢ä¹Ÿä¼šå¢žåŠ ä¸€ä¸ª[SEP]ã€‚æ³¨æ„è¿™é‡Œçš„åˆ†è¯ä¼šæŠŠâ€playingâ€åˆ†æˆâ€playâ€å’Œâ€##ingâ€ä¸¤ä¸ªTokenï¼Œè¿™ç§æŠŠè¯åˆ†æˆæ›´ç»†ç²’åº¦çš„Word Pieceçš„æ–¹æ³•åœ¨å‰é¢çš„æœºå™¨ç¿»è¯‘éƒ¨åˆ†ä»‹ç»è¿‡äº†ï¼Œè¿™æ˜¯ä¸€ç§è§£å†³æœªç™»å½•è¯çš„å¸¸è§åŠžæ³•ï¼ŒåŽé¢çš„ä»£ç éƒ¨åˆ†ä¹Ÿä¼šç®€å•ä»‹ç»ã€‚æŽ¥ç€å¯¹æ¯ä¸ªTokenè¿›è¡Œ3ä¸ªEmbeddingï¼šè¯çš„Embeddingï¼›ä½ç½®çš„Embeddingå’ŒSegmentçš„Embeddingã€‚è¯çš„Embeddingå¤§å®¶éƒ½å¾ˆç†Ÿæ‚‰äº†ï¼Œè€Œä½ç½®çš„Embeddingå’Œè¯ç±»ä¼¼ï¼ŒæŠŠä¸€ä¸ªä½ç½®(æ¯”å¦‚2)æ˜ å°„æˆä¸€ä¸ªä½Žç»´ç¨ å¯†çš„å‘é‡ã€‚è€ŒSegmentåªæœ‰ä¸¤ä¸ªï¼Œè¦ä¹ˆæ˜¯å±žäºŽç¬¬ä¸€ä¸ªå¥å­(segment)è¦ä¹ˆå±žäºŽç¬¬äºŒä¸ªå¥å­ï¼Œä¸ç®¡é‚£ä¸ªå¥å­ï¼Œå®ƒéƒ½å¯¹åº”ä¸€ä¸ªEmbeddingå‘é‡ã€‚åŒä¸€ä¸ªå¥å­çš„Segment Embeddingæ˜¯å…±äº«çš„ï¼Œè¿™æ ·å®ƒèƒ½å¤Ÿå­¦ä¹ åˆ°å±žäºŽä¸åŒSegmentçš„ä¿¡æ¯ã€‚å¯¹äºŽæƒ…æ„Ÿåˆ†ç±»è¿™æ ·çš„ä»»åŠ¡ï¼Œåªæœ‰ä¸€ä¸ªå¥å­ï¼Œå› æ­¤Segment idæ€»æ˜¯0ï¼›è€Œå¯¹äºŽEntailmentä»»åŠ¡ï¼Œè¾“å…¥æ˜¯ä¸¤ä¸ªå¥å­ï¼Œå› æ­¤Segmentæ˜¯0æˆ–è€…1ã€‚ BERTæ¨¡åž‹è¦æ±‚æœ‰ä¸€ä¸ªå›ºå®šçš„Sequenceçš„é•¿åº¦ï¼Œæ¯”å¦‚128ã€‚å¦‚æžœä¸å¤Ÿå°±åœ¨åŽé¢paddingï¼Œå¦åˆ™å°±æˆªå–æŽ‰å¤šä½™çš„Tokenï¼Œä»Žè€Œä¿è¯è¾“å…¥æ˜¯ä¸€ä¸ªå›ºå®šé•¿åº¦çš„Tokenåºåˆ—ï¼ŒåŽé¢çš„ä»£ç ä¼šè¯¦ç»†çš„ä»‹ç»ã€‚ç¬¬ä¸€ä¸ªTokenæ€»æ˜¯ç‰¹æ®Šçš„[CLS]ï¼Œå®ƒæœ¬èº«æ²¡æœ‰ä»»ä½•è¯­ä¹‰ï¼Œå› æ­¤å®ƒä¼š(å¿…é¡»)ç¼–ç æ•´ä¸ªå¥å­(å…¶å®ƒè¯)çš„è¯­ä¹‰ã€‚ Mask LM ä¸ºäº†è§£å†³åªèƒ½åˆ©ç”¨å•å‘ä¿¡æ¯çš„é—®é¢˜ï¼ŒBERTä½¿ç”¨çš„æ˜¯Maskè¯­è¨€æ¨¡åž‹è€Œä¸æ˜¯æ™®é€šçš„è¯­è¨€æ¨¡åž‹ã€‚Maskè¯­è¨€æ¨¡åž‹æœ‰ç‚¹ç±»ä¼¼ä¸Žå®Œå½¢å¡«ç©ºâ€”â€”ç»™å®šä¸€ä¸ªå¥å­ï¼ŒæŠŠå…¶ä¸­æŸä¸ªè¯é®æŒ¡èµ·æ¥ï¼Œè®©äººçŒœæµ‹å¯èƒ½çš„è¯ã€‚è¿™é‡Œä¼šéšæœºçš„MaskæŽ‰15%çš„è¯ï¼Œç„¶åŽè®©BERTæ¥é¢„æµ‹è¿™äº›Maskçš„è¯ï¼Œé€šè¿‡è°ƒæ•´æ¨¡åž‹çš„å‚æ•°ä½¿å¾—æ¨¡åž‹é¢„æµ‹æ­£ç¡®çš„æ¦‚çŽ‡å°½å¯èƒ½å¤§ï¼Œè¿™ç­‰ä»·äºŽäº¤å‰ç†µçš„æŸå¤±å‡½æ•°ã€‚è¿™æ ·çš„Transformeråœ¨ç¼–ç ä¸€ä¸ªè¯çš„æ—¶å€™ä¼š(å¿…é¡»)å‚è€ƒä¸Šä¸‹æ–‡çš„ä¿¡æ¯ã€‚ ä½†æ˜¯è¿™æœ‰ä¸€ä¸ªé—®é¢˜ï¼šåœ¨Pretraining Mask LMæ—¶ä¼šå‡ºçŽ°ç‰¹æ®Šçš„Token [MASK]ï¼Œä½†æ˜¯åœ¨åŽé¢çš„fine-tuningæ—¶å´ä¸ä¼šå‡ºçŽ°ï¼Œè¿™ä¼šå‡ºçŽ°Mismatchçš„é—®é¢˜ã€‚å› æ­¤BERTä¸­ï¼Œå¦‚æžœæŸä¸ªTokenåœ¨è¢«é€‰ä¸­çš„15%ä¸ªTokené‡Œï¼Œåˆ™æŒ‰ç…§ä¸‹é¢çš„æ–¹å¼éšæœºçš„æ‰§è¡Œï¼š 80%çš„æ¦‚çŽ‡æ›¿æ¢æˆ[MASK]ï¼Œæ¯”å¦‚my dog is hairy â†’ my dog is [MASK] 10%çš„æ¦‚çŽ‡æ›¿æ¢æˆéšæœºçš„ä¸€ä¸ªè¯ï¼Œæ¯”å¦‚my dog is hairy â†’ my dog is apple 10%çš„æ¦‚çŽ‡æ›¿æ¢æˆå®ƒæœ¬èº«ï¼Œæ¯”å¦‚my dog is hairy â†’ my dog is hairy è¿™æ ·åšçš„å¥½å¤„æ˜¯ï¼ŒBERTå¹¶ä¸çŸ¥é“[MASK]æ›¿æ¢çš„æ˜¯å“ªä¸€ä¸ªè¯ï¼Œè€Œä¸”ä»»ä½•ä¸€ä¸ªè¯éƒ½æœ‰å¯èƒ½æ˜¯è¢«æ›¿æ¢æŽ‰çš„ï¼Œæ¯”å¦‚å®ƒçœ‹åˆ°çš„appleå¯èƒ½æ˜¯è¢«æ›¿æ¢çš„è¯ã€‚è¿™æ ·å¼ºè¿«æ¨¡åž‹åœ¨ç¼–ç å½“å‰æ—¶åˆ»çš„æ—¶å€™ä¸èƒ½å¤ªä¾èµ–äºŽå½“å‰çš„è¯ï¼Œè€Œè¦è€ƒè™‘å®ƒçš„ä¸Šä¸‹æ–‡ï¼Œç”šè‡³æ›´åŠ ä¸Šä¸‹æ–‡è¿›è¡Œâ€çº é”™â€ã€‚æ¯”å¦‚ä¸Šé¢çš„ä¾‹å­æ¨¡åž‹åœ¨ç¼–ç appleæ˜¯æ ¹æ®ä¸Šä¸‹æ–‡my dog isåº”è¯¥æŠŠapple(éƒ¨åˆ†)ç¼–ç æˆhairyçš„è¯­ä¹‰è€Œä¸æ˜¯appleçš„è¯­ä¹‰ã€‚ é¢„æµ‹å¥å­å…³ç³» åœ¨æœ‰äº›ä»»åŠ¡ä¸­ï¼Œæ¯”å¦‚é—®ç­”ï¼Œå‰åŽä¸¤ä¸ªå¥å­æœ‰ä¸€å®šçš„å…³è”å…³ç³»ï¼Œæˆ‘ä»¬å¸Œæœ›BERT Pretrainingçš„æ¨¡åž‹èƒ½å¤Ÿå­¦ä¹ åˆ°è¿™ç§å…³ç³»ã€‚å› æ­¤BERTè¿˜å¢žåŠ äº†ä¸€ä¸ªæ–°çš„ä»»åŠ¡â€”â€”é¢„æµ‹ä¸¤ä¸ªå¥å­æ˜¯å¦æœ‰å…³è”å…³ç³»ã€‚è¿™æ˜¯ä¸€ç§Multi-Task Learingã€‚BERTè¦æ±‚çš„Pretrainingçš„æ•°æ®æ˜¯ä¸€ä¸ªä¸€ä¸ªçš„â€æ–‡ç« â€ï¼Œæ¯”å¦‚å®ƒä½¿ç”¨äº†BookCorpuså’Œç»´åŸºç™¾ç§‘çš„æ•°æ®ï¼ŒBookCorpusæ˜¯å¾ˆå¤šæœ¬ä¹¦ï¼Œæ¯æœ¬ä¹¦çš„å‰åŽå¥å­æ˜¯æœ‰å…³è”å…³ç³»çš„ï¼›è€Œç»´åŸºç™¾ç§‘çš„æ–‡ç« çš„å‰åŽå¥å­ä¹Ÿæ˜¯æœ‰å…³ç³»çš„ã€‚å¯¹äºŽè¿™ä¸ªä»»åŠ¡ï¼ŒBERTä¼šä»¥50%çš„æ¦‚çŽ‡æŠ½å–æœ‰å…³è”çš„å¥å­(æ³¨æ„è¿™é‡Œçš„å¥å­å®žé™…åªæ˜¯è”ç³»çš„Tokenåºåˆ—ï¼Œä¸æ˜¯è¯­è¨€å­¦æ„ä¹‰ä¸Šçš„å¥å­)ï¼Œå¦å¤–ä»¥50%çš„æ¦‚çŽ‡éšæœºæŠ½å–ä¸¤ä¸ªæ— å…³çš„å¥å­ï¼Œç„¶åŽè®©BERTæ¨¡åž‹æ¥åˆ¤æ–­è¿™ä¸¤ä¸ªå¥å­æ˜¯å¦ç›¸å…³ã€‚æ¯”å¦‚ä¸‹é¢çš„ä¸¤ä¸ªç›¸å…³çš„å¥å­ï¼š [CLS] the man went to [MASK] store [SEP] he bought a gallon [MASK] milk [SEP] ä¸‹é¢æ˜¯ä¸¤ä¸ªä¸ç›¸å…³çš„å¥å­ï¼š [CLS] the man [MASK] to the store [SEP] penguin [MASK] are flight ##less birds [SEP] ELMO å’ŒOpenAI GPT çš„åŒºåˆ«ï¼š UMLFiTæ¯”è¾ƒå¤æ‚ï¼Œè€Œä¸”æ•ˆæžœä¹Ÿä¸æ˜¯ç‰¹åˆ«å¥½ï¼Œæˆ‘ä»¬æš‚ä¸”ä¸æã€‚ELMoå’ŒOpenAI GPTçš„æ€æƒ³å…¶å®žéžå¸¸éžå¸¸ç®€å•ï¼Œå°±æ˜¯ç”¨æµ·é‡çš„æ— æ ‡æ³¨æ•°æ®å­¦ä¹ è¯­è¨€æ¨¡åž‹ï¼Œåœ¨å­¦ä¹ è¯­è¨€æ¨¡åž‹çš„è¿‡ç¨‹ä¸­è‡ªç„¶è€Œç„¶çš„å°±å­¦åˆ°äº†ä¸Šä¸‹æ–‡çš„è¯­ä¹‰å…³ç³»ã€‚å®ƒä»¬éƒ½æ˜¯æ¥å­¦ä¹ ä¸€ä¸ªè¯­è¨€æ¨¡åž‹ï¼Œå‰è€…ä½¿ç”¨çš„æ˜¯LSTMè€ŒåŽè€…ä½¿ç”¨Transformerï¼Œåœ¨è¿›è¡Œä¸‹æ¸¸ä»»åŠ¡å¤„ç†çš„æ—¶å€™ä¹Ÿæœ‰æ‰€ä¸åŒï¼ŒELMoæ˜¯æŠŠå®ƒå½“æˆç‰¹å¾ã€‚æ‹¿åˆ†ç±»ä»»åŠ¡æ¥è¯´ï¼Œè¾“å…¥ä¸€ä¸ªå¥å­ï¼ŒELMoç”¨LSTMæŠŠå®ƒæ‰«ä¸€æ¬¡ï¼Œè¿™æ ·å°±å¯ä»¥å¾—åˆ°æ¯ä¸ªè¯çš„è¡¨ç¤ºï¼Œè¿™ä¸ªè¡¨ç¤ºæ˜¯è€ƒè™‘ä¸Šä¸‹æ–‡çš„ï¼Œå› æ­¤â€He deposited his money in this bankâ€å’Œâ€His soldiers were arrayed along the river bankâ€ä¸­çš„ä¸¤ä¸ªbankçš„å‘é‡æ˜¯ä¸åŒçš„ã€‚ä¸‹æ¸¸ä»»åŠ¡ç”¨è¿™äº›å‘é‡æ¥åšåˆ†ç±»ï¼Œå®ƒä¼šå¢žåŠ ä¸€äº›ç½‘ç»œå±‚ï¼Œä½†æ˜¯ELMoè¯­è¨€æ¨¡åž‹çš„å‚æ•°æ˜¯å›ºå®šçš„ã€‚è€ŒOpenAI GPTä¸åŒï¼Œå®ƒç›´æŽ¥ç”¨ç‰¹å®šä»»åŠ¡æ¥Fine-Tuning Transformerçš„å‚æ•°ã€‚å› ä¸ºç”¨ç‰¹å®šä»»åŠ¡çš„æ•°æ®æ¥è°ƒæ•´Transformerçš„å‚æ•°ï¼Œè¿™æ ·å®ƒæ›´å¯èƒ½å­¦ä¹ åˆ°ä¸Žè¿™ä¸ªä»»åŠ¡ç‰¹å®šçš„ä¸Šä¸‹æ–‡è¯­ä¹‰å…³ç³»ï¼Œå› æ­¤æ•ˆæžœä¹Ÿæ›´å¥½ã€‚ Skip Thought Vector åœ¨è®­ç»ƒè¯­æ–™ä¸Šçš„åŒºåˆ« å’Œè®­ç»ƒWord2Vecä¸åŒï¼ŒWord2Vecåªéœ€è¦æä¾›å¥å­ï¼Œè€ŒSkip Thought Vectoréœ€è¦æ–‡ç« (è‡³å°‘æ˜¯æ®µè½)ã€‚è®ºæ–‡ä½¿ç”¨çš„æ•°æ®é›†æ˜¯BookCorpus(http://yknzhu.wixsite.com/mbweb)ï¼Œç›®å‰ç½‘ç«™å·²ç»ä¸æä¾›ä¸‹è½½äº†ã€‚BookCorpusçš„ç»Ÿè®¡ä¿¡æ¯å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œæœ‰ä¸€ä¸‡å¤šæœ¬ä¹¦ï¼Œä¸ƒåƒå¤šä¸‡ä¸ªå¥å­ã€‚ è¯æ±‡æ‰©å±•ï¼š ä½¿ç”¨ä¸€ä¸ªword2vec çš„è¯å‘é‡åŽ»æ˜ å°„åœ¨è®­ç»ƒå¥å­å‘é‡ä¸­å¾—åˆ°çš„å‘é‡ï¼Œå…¶ä¸­çš„æ˜ å°„å…³ç³»æ˜¯ $w$, è¿™ä¸ªå‚æ•°å¯ä»¥é€šè¿‡å…±çŽ°è¯è¿›è¡Œå­¦ä¹ ã€‚ ELMo è¿™ç¯‡è®ºæ–‡çš„æƒ³æ³•å…¶å®žéžå¸¸éžå¸¸ç®€å•ï¼Œä½†æ˜¯å–å¾—äº†éžå¸¸å¥½çš„æ•ˆæžœã€‚å®ƒçš„æ€è·¯æ˜¯ç”¨æ·±åº¦çš„åŒå‘RNN(LSTM)åœ¨å¤§é‡æœªæ ‡æ³¨æ•°æ®ä¸Šè®­ç»ƒè¯­è¨€æ¨¡åž‹ã€‚ç„¶åŽåœ¨å®žé™…çš„ä»»åŠ¡ä¸­ï¼Œå¯¹äºŽè¾“å…¥çš„å¥å­ï¼Œæˆ‘ä»¬ä½¿ç”¨è¿™ä¸ªè¯­è¨€æ¨¡åž‹æ¥å¯¹å®ƒå¤„ç†ï¼Œå¾—åˆ°è¾“å‡ºçš„å‘é‡ï¼Œå› æ­¤è¿™å¯ä»¥çœ‹æˆæ˜¯ä¸€ç§ç‰¹å¾æå–ã€‚]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[é€»è¾‘å›žå½’æ¦‚å¿µ]]></title>
    <url>%2F2019%2F06%2F09%2Flr%2F</url>
    <content type="text"><![CDATA[æœ¬æ–‡ä¸»è¦ä»‹ç»é€»è¾‘å›žå½’ï¼ˆlogistics regressionï¼‰å’Œå†³ç­–æ ‘ï¼ˆDecision Treeï¼‰ã€‚é€»è¾‘å›žå½’ä»Žçº¿æ€§å›žå½’å‡ºå‘åˆ°é€»è¾‘å›žå½’ï¼Œç„¶åŽæ‰‹æŽ¨å…¬å¼å’Œç›¸å…³çš„ä¸€äº›ç‰¹ç‚¹ï¼›ä»‹ç»ä¸€ä¸‹å†³ç­–æ ‘çš„ç‰¹ç‚¹ã€‚ é€»è¾‘å›žå½’é€»è¾‘å›žå½’æ˜¯çº¿æ€§æ¨¡åž‹ï¼Œè™½ç„¶å«åšâ€å›žå½’â€œï¼Œç©¶å…¶åŽŸå›  é€»è¾‘å›žå½’ä»Žçº¿æ€§å›žå½’å¼•ç”³è€Œæ¥ï¼Œå¯¹å›žå½’çš„ç»“æžœè¿›è¡Œ logistic å‡½æ•°è¿ç®—ï¼Œå°†èŒƒå›´é™åˆ¶åœ¨[0,1]åŒºé—´ï¼Œå¹¶æ›´æ”¹æŸå¤±å‡½æ•°ä¸ºäºŒå€¼äº¤å‰ç†µæŸå¤±ï¼Œä½¿å…¶å¯ç”¨äºŽ2åˆ†ç±»é—®é¢˜(é€šè¿‡å¾—åˆ°çš„æ¦‚çŽ‡å€¼ä¸Žé˜ˆå€¼æ¯”è¾ƒè¿›è¡Œåˆ†ç±»)ã€‚é€»è¾‘å›žå½’æ˜¯å¹¿ä¹‰ä¸Šçš„çº¿æ€§æ¨¡åž‹ï¼Œç„¶åŽæœ€åŽçš„sigmoid åŠ å…¥äº†éžçº¿æ€§ã€‚æ˜¯å¤„ç†çº¿æ€§é—®é¢˜çš„ã€‚ å…¬å¼æŽ¨å¯¼ä»Žçº¿æ€§å›žå½’é—®é¢˜åˆ°é€»è¾‘å›žå½’è¿‡ç¨‹çš„æŽ¨å¯¼ã€‚ çº¿æ€§äºŒåˆ†æ¨¡åž‹ï¼š $$f ( x ) = \theta ^ { T } x$$ é€»è¾‘å›žå½’å†³ç­–å‡½æ•°æ˜¯å°†æ­¤çº¿æ€§äºŒåˆ†ç±»åµŒå¥—ä¸€ä¸ªsigmoidå‡½æ•°ï¼š $$ f ( x ) = \frac { 1 } { 1 + e ^ { - \theta ^ { T } x } }$$ æŸå¤±å‡½æ•°ï¼šå¦‚æžœç”¨å¹³æ–¹è¯¯å·®ï¼ˆMSEï¼‰ä½œä¸ºé€»è¾‘å›žå½’çš„æŸå¤±å‡½æ•°,é‚£ä¹ˆå‡½æ•°æ›²çº¿å°†æ˜¯è·³è·ƒå¼çš„,éžå‡¸çš„(non-convex),åŽŸå› æ˜¯logisticå‡½æ•°å°†æ•°æ®èŒƒå›´é™åˆ¶åœ¨[0,1]åŒºé—´,è€ŒçœŸå®žæ ‡ç­¾å€¼éž0å³1.æœ€å°åŒ– MSE æŸå¤±å®¹æ˜“é™·å…¥å±€éƒ¨æžå°ç‚¹.é€»è¾‘å›žå½’æŸå¤±æ˜¯å¦‚ä¸‹çš„åˆ†æƒ…å†µçš„å‡¸å‡½æ•°(å•ä¸ªxä¸Žyçš„æŸå¤±)ã€‚ $$P ( y = 1 | x ; \theta ) = h _ { \theta } ( x )$$ $$P ( y = 0 | x ; \theta ) = 1 - h _ { \theta } ( x )$$æœ€åˆæ˜¯ä¸Šè¿°çš„åˆ†æ®µå‡½æ•°ï¼Œåˆå¹¶æˆä¸‹é¢çš„å‡½æ•°ï¼Œæ–¹ä¾¿è®¡ç®—ã€‚$$p ( y | x ; \theta ) = \left( h _ { \theta } ( x ) \right) ^ { y } \left( 1 - h _ { \theta } ( x ) \right) ^ { 1 - y }$$ä½¿ç”¨æœ€å¤§ä¼¼ç„¶çš„æ€æƒ³æ±‚è§£ã€‚å‡è®¾æˆ‘ä»¬æœ‰nä¸ªç‹¬ç«‹çš„è®­ç»ƒæ ·æœ¬{(x1, y1) ,(x2, y2),â€¦, (xn, yn)}ï¼Œy={0, 1}ã€‚é‚£æ¯ä¸€ä¸ªè§‚å¯Ÿåˆ°çš„æ ·æœ¬(xi, yi)å‡ºçŽ°çš„æ¦‚çŽ‡æ˜¯ï¼š ä¸Šè¿°ä¼¼ç„¶å‡½æ•°ä¹˜æ³•å¤ªéš¾ç®—äº†ï¼Œç„¶åŽä½¿ç”¨log å°†å…¶æ”¹ä¸ºåŠ æ³•ï¼Œå˜æˆäº†å¯¹æ•°ä¼¼ç„¶å‡½æ•°ã€‚$$J( \theta ) = \log ( L ( \theta ) ) = \sum _ { i = 1 } ^ { m } y ^ { ( i ) } \log \left( h \left( x ^ { ( i ) } \right) \right) + \left( 1 - y ^ { ( i ) } \right) \log \left( 1 - h \left( x ^ { ( i ) } \right) \right)$$ æ±‚å¯¼ä¼˜åŒ–é—®é¢˜sigmoid å‡½æ•°çš„ç‰¹æ®Šæ€§è´¨ï¼š$$\sigma ^ { \prime } ( x ) = \sigma ( x ) ( 1 - \sigma ( x ) )$$ åˆ†æˆä¸‰éƒ¨åˆ†æ±‚å¯¼ï¼š ç”¨L(Î¸)å¯¹Î¸æ±‚å¯¼ï¼Œå¾—åˆ°ï¼š$$\begin{split}\frac { d } { d \theta _ { i } } \operatorname { loss } ( \theta ) &amp;= \left( y \frac { 1 } { \sigma \left( \theta ^ { T } x \right) } - ( 1 - y ) \frac { 1 } { 1 - \sigma \left( \theta ^ { T } x \right) } \right) \frac { d } { d \theta _ { i } } \sigma \left( \theta ^ { T } x \right) \\&amp;= \left( y \frac { 1 } { \sigma \left( \theta ^ { T } x \right) } - ( 1 - y ) \frac { 1 } { 1 - \sigma \left( \theta ^ { T } x \right) } \right) \sigma \left( \theta ^ { T } x \right) \left( 1 - \sigma \left( \theta ^ { T } x \right) \right) \frac { d } { d \theta _ { i } } \theta ^ { T } x \\&amp;= \left( y \left( 1 - \sigma \left( \theta ^ { T } x \right) \right) - ( 1 - y ) \sigma \left( \theta ^ { T } x \right) \right) x _ { i } \\&amp;= \left( y - h _ { \theta } ( x ) \right) x _ { i }\end{split}$$ æ³¨æ„ä¸€ä¼šå„¿æœ‰ $\sum$ ä¸€ä¼šå„¿æ²¡æœ‰çš„ï¼Œå…¶å®žæˆ‘ä»¬æ›´å€¾å‘äºŽä¸ç”¨ï¼Œé‡‡ç”¨çŸ©é˜µç›¸ä¹˜çš„æ–¹å¼æ›´åŠ ç®€æ´ã€‚åªæ˜¯åœ¨è¡¨è¾¾ä¼¼ç„¶å‡½æ•°ï¼Œä½¿ç”¨$ \sum$æ›´åŠ ç›´è§‚$$\theta _ { i } : = \theta _ { j } + \alpha \left( y ^ { ( i ) } - h _ { \theta } \left( x ^ { ( i ) } \right) \right) x _ { j } ^ { ( i ) }$$ ä¸ºä»€ä¹ˆä½¿ç”¨ logistics functionä¸€ç§è§£é‡Šæ˜¯å¯ä»¥ã€‚ sigmoid å‡½æ•°è¿žç»­ï¼Œå•è°ƒé€’å¢ž å¯¹ sigmoid å‡½æ•°æ±‚å¯¼éžå¸¸çš„æ–¹ä¾¿ å¯ä»¥å°†è´Ÿæ— ç©·åˆ°æ­£æ— ç©·çš„æ•°å€¼æ˜ å°„åˆ° [0, 1] è¿™æ ·çš„åŒºé—´ å¦å¤–ä¸€ç§ç»´åº¦æ˜¯ä»Žä¼¯åŠªåˆ©åˆ†å¸ƒçš„è§’åº¦åŽ»è§£é‡Šã€‚ $$f(x ; p)=p^{x}(1-p)^{1-x} \quad x=0,1$$å…¶ä¸­ $p$ æ˜¯æˆåŠŸçš„æ¦‚çŽ‡ã€‚å¦‚æžœè¿›è¡Œä¸€æ¬¡æŠ•æŽ·ï¼Œé‚£ä¹ˆå‡å€¼æ˜¯ $p$ æ–¹å·®æ˜¯ $p (1-p)$ã€‚ ç„¶åŽå†çœ‹äºŒåˆ†ç±»ä»»åŠ¡ï¼Œæ ·æœ¬çš„æ ‡ç­¾$y$ æœä»ŽäºŒé¡¹åˆ†å¸ƒã€‚ $$p ( y | x ; \theta ) = \left( h _ { \theta } ( x ) \right) ^ { y } \left( 1 - h _ { \theta } ( x ) \right) ^ { 1 - y }$$è¯¦ç»†çš„æŽ¨å¯¼å¯ä»¥çœ‹è¿™é‡Œï¼š [img]https://ftp.bmp.ovh/imgs/2019/09/39e481f9fd958d4b.png[/img] é€»è¾‘å›žå½’çš„ç‰¹ç‚¹ ä¼˜ç‚¹ï¼š LR èƒ½ä»¥æ¦‚çŽ‡çš„å½¢å¼è¾“å‡ºç»“æžœ,è€Œéžåªæ˜¯ 0,1 åˆ¤å®šï¼Œ å¯ä»¥åš ranking modelï¼› LR çš„å¯è§£é‡Šæ€§å¼º,å¯æŽ§åº¦é«˜ï¼› è®­ç»ƒå¿« ç¼ºç‚¹ï¼š å®¹æ˜“æ¬ æ‹Ÿåˆï¼Œä¸€èˆ¬å‡†ç¡®åº¦ä¸å¤ªé«˜ åªèƒ½å¤„ç†ä¸¤åˆ†ç±»é—®é¢˜. (å¯ä»¥åº”ç”¨å¤šä¸ªé€»è¾‘å›žå½’å®žçŽ°å¤šåˆ†ç±»,ç±»ä¼¼SVMçš„æ–¹å¼; å¦å¤–å¯¹äºŽçˆ¶å­ç±»åˆ«åŒæ—¶åˆ†ç±»çš„æƒ…å†µ,ä½¿ç”¨é€»è¾‘å›žå½’è¦æ¯”Softmaxç­‰æ–¹å¼æ•ˆæžœå¥½) â€œæµ·é‡ç¦»æ•£ç‰¹å¾+ç®€å•æ¨¡åž‹â€ åŒâ€œå°‘é‡è¿žç»­ç‰¹å¾+å¤æ‚æ¨¡åž‹â€çš„æƒè¡¡ã€‚æ—¢å¯ä»¥ç¦»æ•£åŒ–ç”¨çº¿æ€§æ¨¡åž‹ï¼Œä¹Ÿå¯ä»¥ç”¨è¿žç»­ç‰¹å¾åŠ æ·±åº¦å­¦ä¹  ä¸ºä»€ä¹ˆå¯¹ç‰¹å¾è¿›è¡Œç¦»æ•£åŒ– ç‰¹å¾ä»Žè¿žç»­å˜é‡çŠ¶æ€åˆ°ç¦»æ•£åŒ–çš„åˆè¡·åœ¨äºŽæˆ‘ä»¬è®¤ä¸ºä¸åŒçš„åŒºé—´å¯¹äºŽæœ€åŽçš„ç»“æžœçš„é‡è¦æ€§æ˜¯ä¸åŒçš„ã€‚åŒæ ·åœ¨å·¥ä¸šç•Œï¼Œå¾ˆå°‘ç›´æŽ¥å°†è¿žç»­å€¼ä½œä¸ºé€»è¾‘å›žå½’æ¨¡åž‹çš„ç‰¹å¾è¾“å…¥ï¼Œè€Œæ˜¯å°†è¿žç»­ç‰¹å¾ç¦»æ•£åŒ–ä¸ºä¸€ç³»åˆ—0ã€1ç‰¹å¾(one-hotç¼–ç )äº¤ç»™é€»è¾‘å›žå½’æ¨¡åž‹ï¼Œè¿™æ ·åšçš„ä¼˜åŠ¿æœ‰ä»¥ä¸‹å‡ ç‚¹ ç¦»æ•£ç‰¹å¾çš„å¢žåŠ å’Œå‡å°‘éƒ½å¾ˆå®¹æ˜“ï¼Œæ˜“äºŽæ¨¡åž‹çš„å¿«é€Ÿè¿­ä»£ï¼› ç¨€ç–å‘é‡å†…ç§¯ä¹˜æ³•è¿ç®—é€Ÿåº¦å¿«ï¼Œè®¡ç®—ç»“æžœæ–¹ä¾¿å­˜å‚¨ï¼Œå®¹æ˜“æ‰©å±•ï¼› ç¦»æ•£åŒ–åŽçš„ç‰¹å¾å¯¹å¼‚å¸¸æ•°æ®æœ‰å¾ˆå¼ºçš„é²æ£’æ€§ï¼šæ¯”å¦‚ä¸€ä¸ªç‰¹å¾æ˜¯å¹´é¾„&gt;30æ˜¯1ï¼Œå¦åˆ™0ã€‚å¦‚æžœç‰¹å¾æ²¡æœ‰ç¦»æ•£åŒ–ï¼Œä¸€ä¸ªå¼‚å¸¸æ•°æ®â€œå¹´é¾„300å²â€ä¼šç»™æ¨¡åž‹é€ æˆå¾ˆå¤§çš„å¹²æ‰°ï¼› å•å˜é‡ç¦»æ•£åŒ–ä¸ºNä¸ªåŽï¼Œæ¯ä¸ªå˜é‡æœ‰å•ç‹¬çš„æƒé‡ï¼Œç›¸å½“äºŽä¸ºæ¨¡åž‹å¼•å…¥äº†éžçº¿æ€§ï¼Œèƒ½å¤Ÿæå‡æ¨¡åž‹è¡¨è¾¾èƒ½åŠ›ï¼ŒåŠ å¤§æ‹Ÿåˆ ç¦»æ•£åŒ–åŽå¯ä»¥è¿›è¡Œç‰¹å¾äº¤å‰ ç©¶å…¶åŽŸå› ï¼Œä½¿ç”¨ LR+ç¦»æ•£æ¨¡åž‹åœ¨äºŽå¯æŽ§å¯è§£é‡Šã€‚è€ŒGBDT ç›´æŽ¥ä½¿ç”¨è¿žç»­çš„å˜é‡ï¼Œä¸€æ–¹é¢çš„åŽŸå› åœ¨äºŽå¦‚æžœç‰¹å¾è¿‡å¤šï¼Œé‚£ä¹ˆGBDT æ˜¯è·‘ä¸åŠ¨çš„ã€‚ ä¸ºä»€ä¹ˆLRæ¨¡åž‹çš„æŸå¤±å‡½æ•°æ˜¯äº¤å‰ç†µ,è€Œçº¿æ€§å›žå½’æ¨¡åž‹çš„æŸå¤±å‡½æ•°å´æ˜¯æœ€å°äºŒä¹˜å‘¢ï¼Ÿèƒ½å¦éšæ„ç¡®å®šä¸€ä¸ªæŸå¤±å‡½æ•°ä½œä¸ºç›®æ ‡å‘¢ï¼Ÿ æ¨¡åž‹çš„æŸå¤±å‡½æ•°ç”±å„è‡ªçš„å“åº”å˜é‡yçš„æ¦‚çŽ‡åˆ†å¸ƒå†³å®šï¼Œå¯¹äºŽçº¿æ€§å›žå½’æ¨¡åž‹ï¼Œå…¶è¾“å‡ºæ˜¯è¿žç»­å€¼ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯¹äºŽè¯¥é—®é¢˜å‡è®¾yæœä»Žæ­£æ€åˆ†å¸ƒï¼›ç›¸å¯¹çš„ï¼ŒLRæ¨¡åž‹ä¸€èˆ¬ç”¨æ¥è§£å†³äºŒåˆ†ç±»é—®é¢˜ï¼Œæ‰€ä»¥å…¶è¾“å‡ºæ˜¯0/1ï¼Œæ•…è€Œæˆ‘ä»¬å‡è®¾å…¶è¾“å‡ºæœä»Žä¼¯åŠªåˆ©åˆ†å¸ƒï¼›è€Œè¿›ä¸€æ­¥åœ°ï¼Œä¸¤è€…çš„æŸå¤±å‡½æ•°éƒ½æ˜¯é€šè¿‡æžå¤§ä¼¼ç„¶ä¼°è®¡æŽ¨å¯¼çš„æ¥çš„ï¼Œæ‰€ä»¥æ¨¡åž‹çš„æŸå¤±å‡½æ•°å¹¶éžéšæ„ç¡®å®šã€‚åˆ†ç±»æ¨¡åž‹ä¸Žå›žå½’æ¨¡åž‹ä¹‹é—´æœ‰ç§ç§è”ç³»,æ¯”å¦‚ SVM æ¨¡åž‹å¯ä»¥çœ‹ä½œé€»è¾‘å›žå½’åŠ L2æ­£åˆ™é¡¹, å¹¶ä½¿ç”¨äº†ä¸åŒçš„æŸå¤±å‡½æ•°. ä¸ºä»€ä¹ˆä¸ä½¿ç”¨å›žå½’æ¨¡åž‹æ¥åšåˆ†ç±»?è¿™æ˜¯ä¸€ç§ä¸å¥½çš„åšæ³•, å› ä¸ºé˜ˆå€¼ä¸å¥½ç¡®å®š, éšç€æ•°æ®é›†çš„å˜åŠ¨, é˜ˆå€¼ä¹Ÿéœ€è¦æœ‰è¾ƒå¤§å˜åŒ–. æ­£åˆ™é¡¹ L2 è§£å†³è¿‡æ‹Ÿåˆ L1 è§£å†³æ•°æ®ç¨€ç–æ€§ L1å’ŒL2æ­£åˆ™å…ˆéªŒåˆ†åˆ«æœä»Žä»€ä¹ˆåˆ†å¸ƒä»Žä¿¡æ¯è®ºçš„è§’åº¦çœ‹ï¼Œå‘ç³»ç»ŸåŠ å…¥äº†æ­£ç¡®å…ˆéªŒè¿™ä¸ªä¿¡æ¯ï¼Œè‚¯å®šä¼šæé«˜ç³»ç»Ÿçš„æ€§èƒ½ã€‚ä¸¤è€…çš„å·®åˆ«æ„Ÿæ€§çš„ç†è§£ï¼ŸL1æ˜¯æ‹‰æ™®æ‹‰æ–¯åˆ†å¸ƒï¼ŒL2æ˜¯é«˜æ–¯åˆ†å¸ƒã€‚æ‹‰æ™®æ‹‰æ–¯åˆ†å¸ƒï¼š$$f ( x | \mu , b ) = \frac { 1 } { 2 b } e ^ { - \frac { | x - \mu | } { b } }$$é«˜æ–¯åˆ†å¸ƒï¼š$$f \left( x | \mu , \sigma ^ { 2 } \right) = \frac { 1 } { \sqrt { 2 \pi \sigma ^ { 2 } } } e ^ { - \frac { ( x - \mu ) ^ { 2 } } { 2 \sigma ^ { 2 } } }$$ Decision treeä¸»è¦ä»‹ç»ä¸€ä¸‹ å†³ç­–æ ‘çš„ç‰¹ç‚¹ã€‚ ä»Žè¿™æ¬¡å­¦ä¹ ä¸­æ˜Žæ˜¾çš„æ„Ÿå—åˆ°è¿™ä¸ª decision tree æ˜¯éžå¸¸å®¹æ˜“è¿‡æ‹Ÿåˆçš„ã€‚ We can make our tree more complex by increasing its size , which will result in more and more partitions trying to emulate the circular boundary. ä¼˜ç‚¹åœ¨äºŽï¼šå¯ä»¥handle éžçº¿æ€§çš„å˜åŒ–ã€‚decision tree ç»™äººçš„æ„Ÿè§‰å°±æ˜¯çº¿æ€§æˆ–è€…ç¦»æ•£çš„(category)çš„éƒ½æ˜¯å¯ä»¥ä½¿ç”¨ï¼Œå› ä¸ºdecision tree å¾—åˆ°å°±æ˜¯ä¸€ä¸ªç¦»æ•£çš„ç»“æžœï¼Œæœ€å¤§çš„ç¼ºç‚¹å°±æ˜¯å®¹æ˜“è¿‡æ‹Ÿåˆã€‚ This brings us to the biggest problem associated with Decision Trees, that is, they are highly biased class of models. You can make a decision tree model on your training set which might outperform all other algorithms but itâ€™ll prove to be a poor predictor on your test set. Youâ€™ll have to rely heavily on pruning and cross validation to get a non-over-fitting model with Decision Trees. è¿‡æ‹Ÿåˆæ˜¯å¯ä»¥é€šè¿‡å‰ªæžæˆ–è€… cross validation è¿›è¡Œç¼“è§£ overfitçš„æ•ˆæžœçš„æˆ–è€…ä½¿ç”¨ random forestéšæœºæ€§è¿›è¡Œâ€ä¸­å’Œâ€œã€‚ This problem of over-fitting is overcome to large extent by using Random Forests, which are nothing but a very clever extension of decision trees. But random forest take away easy to explain business rules because now you have thousands of such trees and their majority votes to make things complex. Also by decision trees have forced interactions between variables , which makes them rather inefficient if most of your variables have no or very weak interactions. LR vs. SVMå•ç‹¬è®²è§£SVMã€‚è¿™é‡Œä¸»è¦æ˜¯æ¯”è¾ƒä¸¤ç§çš„å¼‚åŒã€‚ ç›¸åŒç‚¹ LRå’ŒSVMéƒ½æ˜¯åˆ†ç±»ç®—æ³•ã€‚ï¼ˆsvm å¯ä»¥ä½œä¸ºå›žå½’æ¨¡åž‹ï¼‰ LRå’ŒSVMéƒ½æ˜¯ç›‘ç£å­¦ä¹ ç®—æ³•ã€‚ç›‘ç£æ˜¯ä½“çŽ°åœ¨æœ‰æ ‡ç­¾ã€‚ ä¸¤è€…éƒ½å±žäºŽåˆ¤åˆ«æ¨¡åž‹ã€‚ï¼ˆç›¸å¯¹äºŽbayes æ¨¡åž‹ï¼‰ åˆ¤åˆ«æ¨¡åž‹ä¼šç”Ÿæˆä¸€ä¸ªè¡¨ç¤º$P(Y|X) $çš„åˆ¤åˆ«å‡½æ•°ï¼ˆæˆ–é¢„æµ‹æ¨¡åž‹ï¼‰ï¼Œè€Œç”Ÿæˆæ¨¡åž‹å…ˆè®¡ç®—è”åˆæ¦‚çŽ‡$P(Y,X) $ç„¶åŽé€šè¿‡è´å¶æ–¯å…¬å¼è½¬åŒ–ä¸ºæ¡ä»¶æ¦‚çŽ‡ã€‚å¸¸è§çš„åˆ¤åˆ«æ¨¡åž‹æœ‰ï¼šï¼šKNNã€SVMã€LRã€‚å¸¸è§çš„ç”Ÿæˆæ¨¡åž‹æœ‰ï¼šæœ´ç´ è´å¶æ–¯ï¼Œéšé©¬å°”å¯å¤«æ¨¡åž‹ã€‚ ä¸åŒç‚¹ ä»Žæ•°æ®å’Œæ¨¡åž‹çš„è§’åº¦åˆ†æžã€‚ æ•°æ® SVM ä¸­è¾¹ç•Œé™„è¿‘çš„ç‚¹ä¼šèµ·åˆ°å†³ç­–çš„ä½œç”¨ï¼Œåœ¨çº¿ä¸Šçš„ç‚¹å«åšæ”¯æŒå‘é‡ã€‚è€ŒLR æ˜¯å…¨å±€ä¿¡æ¯ï¼Œå…¨éƒ¨çš„æ•°æ®é›†éƒ½ä¼šå‚ä¸Žåˆ°å†³ç­–ï¼Œ å¦‚æžœæ•°æ®æ˜¯ä¸¥é‡çš„ unbalanced, é‚£ä¹ˆéœ€è¦æ˜¯å¯¹æ•°æ®è¿›è¡Œ balance æ“ä½œï¼Œå› ä¸ºæ¨¡åž‹æ˜¯ä¾èµ–äºŽæ•°æ®æ¦‚çŽ‡åˆ†å¸ƒã€‚ loss function çš„ä¸åŒ LR çš„æŸå¤±å‡½æ•° $$J( \theta ) = \log ( L ( \theta ) ) = \sum _ { i = 1 } ^ { m } y ^ { ( i ) } \log \left( h \left( x ^ { ( i ) } \right) \right) + \left( 1 - y ^ { ( i ) } \right) \log \left( 1 - h \left( x ^ { ( i ) } \right) \right)$$ SVMçš„æŸå¤±å‡½æ•°(åœ¨çº¿æ€§çš„å¯åˆ†çš„æ¡ä»¶ä¸‹) $$L ( w , b , \alpha ) = \frac { 1 } { 2 } | w | ^ { 2 } + \sum _ { i } \alpha _ { i } [ 1 - y _ { i } ( w ^ { T } x _ { i } + b ) ]$$(æœ¬è´¨ä¸Šä½¿ç”¨æ‹‰æ ¼æœ—æ—¥è¿›è¡Œæœ€å°åŒ–çš„æ±‚è§£) æ•°æ®é¢„å¤„ç† ç®€å•æ¥è¯´ï¼Œâ€‹é€»è¾‘å›žå½’æ–¹æ³•åŸºäºŽæ¦‚çŽ‡ç†è®ºï¼Œä¸€ä¸ªæ ·æœ¬é€šè¿‡sigmoid å‡½æ•°è¿›è¡Œæ¦‚çŽ‡è¡¨ç¤ºï¼Œç„¶åŽä½¿ç”¨æžå¤§ä¼¼ç„¶çš„æ–¹å¼ä¼°è®¡å‡ºå‚æ•°çš„å€¼ã€‚æ”¯æŒå‘é‡æ˜¯åŸºäºŽå‡ ä½•é—´éš”æœ€å¤§åŒ–åŽŸç†ï¼Œå­˜åœ¨å‡ ä½•é—´éš”æœ€å¤§çš„è¶…å¹³é¢ï¼ŒåŸºäºŽå‡ ä½•è·ç¦»çš„æµ‹é‡å‡½æ•°ï¼Œä¸€èˆ¬éœ€è¦å¯¹æ•°æ®åšnormalizationï¼Œè€ŒLR åˆ™ä¸å—è¿™ä¸ªå› ç´ å½±å“ã€‚ å¢žé‡è®­ç»ƒ å½“è®­ç»ƒå¥½ä¸€ä¸ª SVM å’ŒLRï¼Œç„¶åŽæ¥äº†ä¸€æ‰¹æ–°çš„æ•°æ®ï¼Œå¯¹äºŽSVM çš„å†³ç­–å¹³é¢å˜åŒ–æ¯”è¾ƒå°ï¼Œè€Œå¯¹äºŽLR å°±æ˜¯è¦é‡æ–°è¿›è¡Œè®­ç»ƒã€‚ æ­£åˆ™é¡¹ SVM çš„æŸå¤±å‡½æ•°ä¸­è‡ªå¸¦æ­£åˆ™ ($ \frac { 1 } { 2 } | w | ^ { 2 }$, è¿™å°±ç±»ä¼¼L2 æ­£åˆ™é¡¹)ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆSVMæ˜¯ç»“æž„é£Žé™©æœ€å°åŒ–ç®—æ³•çš„åŽŸå› ã€‚ï¼ˆæ‰€è°“ç»“æž„é£Žé™©æœ€å°åŒ–ï¼Œæ„æ€å°±æ˜¯åœ¨è®­ç»ƒè¯¯å·®å’Œæ¨¡åž‹å¤æ‚åº¦ä¹‹é—´å¯»æ±‚å¹³è¡¡ï¼Œé˜²æ­¢è¿‡æ‹Ÿåˆï¼‰ã€‚è€ŒLR æƒ³è¦å¾—åˆ°æ›´å¥½çš„æ³›åŒ–æ€§èƒ½ï¼Œéœ€è¦æ‰‹åŠ¨åŠ ä¸Šæ­£åˆ™é¡¹ã€‚ é€‰æ‹©æ ‡å‡†ï¼ˆå´æ©è¾¾è¯¾ç¨‹ï¼‰ næ˜¯æ•°æ®ä¸­ç‰¹å¾çš„æ•°é‡ mæ˜¯æ ·æœ¬æ•° 1ã€å¦‚æžœnç›¸å¯¹äºŽmæ¥è¯´å¾ˆå¤§ï¼Œåˆ™ä½¿ç”¨LRç®—æ³•æˆ–è€…ä¸å¸¦æ ¸å‡½æ•°çš„SVMï¼ˆçº¿æ€§åˆ†ç±»ï¼‰nè¿œå¤§äºŽmï¼Œn=10000ï¼Œm=10-10002ã€å¦‚æžœnå¾ˆå°ï¼Œmçš„æ•°é‡é€‚ä¸­ï¼ˆn=1-1000ï¼Œm=10-10000ï¼‰ä½¿ç”¨å¸¦æœ‰æ ¸å‡½æ•°çš„SVMç®—æ³•3ã€å¦‚æžœnå¾ˆå°ï¼Œmå¾ˆå¤§ï¼ˆn=1-1000ï¼Œm=50000+ï¼‰å¢žåŠ æ›´å¤šçš„featureç„¶åŽä½¿ç”¨LRç®—æ³•æˆ–è€…ä¸å¸¦æ ¸å‡½æ•°çš„SVMLRå’Œä¸å¸¦æ ¸å‡½æ•°çš„SVMæ¯”è¾ƒç±»ä¼¼ã€‚ ç®€å•è¯´ï¼Œå¦‚æžœç‰¹å¾ç›¸å¯¹äºŽæ•°æ®é‡æ¥è¯´å¾ˆå¤§ï¼Œé‚£ä¹ˆä½¿ç”¨ LRæˆ–è€…çº¿æ€§SVM ç®—æ³•ï¼›å¦‚æžœç›¸åï¼Œé‚£ä¹ˆä½¿ç”¨å¸¦æœ‰æ ¸å‡½æ•°çš„SVMã€‚ æ€»ç»“åˆ†ç±»æ¨¡åž‹åŒºåˆ«LR vs. SVM vs. Bayes æ•°æ® LR æ•°æ®å¤„ç†æ˜¯ balancedï¼ˆä¾èµ–äºŽæ¦‚çŽ‡åˆ†å¸ƒï¼‰ï¼›SVM ä¸€èˆ¬æ˜¯è¦normalizationï¼ˆç©ºé—´è·ç¦»å‡½æ•°ï¼‰ loss function LR æ˜¯log lossï¼Œä½¿ç”¨æœ€å¤§ä¼¼ç„¶ä¼°è®¡æ±‚è§£ \theta ï¼› SVM æ˜¯æ‹‰æ ¼æœ—æ—¥å®šé‡æ±‚è§£ã€‚ æ­£åˆ™é¡¹ LR éœ€è¦æ‰‹åŠ¨åŠ ä¸Šï¼›SVMè‡ªå¸¦ï¼ŒSVMæ˜¯ç»“æž„é£Žé™©æœ€å°åŒ–ç®—æ³•çš„ å¢žé‡å­¦ä¹ LR æ”¶åˆ°æ–°æ¥çš„æ•°æ®çš„å½±å“ï¼Œ SVM ä¸å—ï¼ˆåŸºæœ¬ä¸Šåªæ˜¯ä¾èµ– æ”¯æŒå‘é‡ çš„ç‚¹ï¼‰ï¼Œbayes æ”¯æŒå¢žé‡å­¦ä¹ ã€‚ å®žæˆ˜LR å’Œä¸å¸¦æ ¸å‡½æ•°çš„SVM æ¯”è¾ƒç±»ä¼¼ã€‚ï¼ˆåŸºæœ¬ä¸Šå¯ä»¥äº’ç”¨ï¼‰ m æ˜¯æ ·æœ¬æ•°ï¼ˆæ•°æ®é‡ï¼‰ï¼Œn æ˜¯ç‰¹å¾æ•°ç‰¹å¾æ•°n è¿œå¤§äºŽæ•°æ®é‡ mï¼Œé€‰æ‹©LR æ¨¡åž‹ ï¼ˆn =1wï¼Œm&lt; 1000ï¼‰ç‰¹å¾n å°ï¼Œm é€‚ä¸­ ï¼ˆn &lt; 1000, m ~1wï¼‰ä½¿ç”¨å¸¦æœ‰æ ¸å‡½æ•°çš„SVM ç®—æ³•ç‰¹å¾n å¾ˆå°ï¼Œm å¾ˆå¤§ ï¼ˆm &gt; 5wï¼‰ å¢žåŠ ç‰¹å¾ LR å’Œæœ´ç´ è´å¶æ–¯çš„åŒºåˆ«]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>LR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç¬”è¯•æ€»ç»“]]></title>
    <url>%2F2019%2F06%2F09%2F%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[æ¶ˆæ¯é€šä¿¡çš„åŸºæœ¬æ–¹å¼æœ‰ä¸¤ç§ï¼š åŒæ­¥æ–¹å¼ ä¸¤ä¸ªé€šä¿¡åº”ç”¨æœåŠ¡ä¹‹é—´å¿…é¡»è¦è¿›è¡ŒåŒæ­¥ï¼Œä¸¤ä¸ªæœåŠ¡ä¹‹é—´å¿…é¡»éƒ½æ˜¯æ­£å¸¸è¿è¡Œçš„ã€‚å‘é€ç¨‹åºå’ŒæŽ¥æ”¶ç¨‹åºéƒ½å¿…é¡»ä¸€ç›´å¤„äºŽè¿è¡ŒçŠ¶æ€ï¼Œå¹¶ä¸”éšæ—¶åšå¥½ç›¸äº’é€šä¿¡çš„å‡†å¤‡ã€‚ å‘é€ç¨‹åºé¦–å…ˆå‘æŽ¥æ”¶ç¨‹åºå‘èµ·ä¸€ä¸ªè¯·æ±‚ï¼Œç§°ä¹‹ä¸ºå‘é€æ¶ˆæ¯ï¼Œå‘é€ç¨‹åºç´§æŽ¥ç€å°±ä¼šå µå¡žå½“å‰è‡ªèº«çš„è¿›ç¨‹ï¼Œä¸ä¸Žå…¶ä»–åº”ç”¨è¿›è¡Œä»»ä½•çš„é€šä¿¡ä»¥åŠäº¤äº’ï¼Œç­‰å¾…æŽ¥æ”¶ç¨‹åºçš„å“åº”ï¼Œå¾…å‘é€æ¶ˆæ¯å¾—åˆ°æŽ¥æ”¶ç¨‹åºçš„è¿”å›žæ¶ˆæ¯ä¹‹åŽä¼šç»§ç»­å‘ä¸‹è¿è¡Œï¼Œè¿›è¡Œä¸‹ä¸€æ­¥çš„ä¸šåŠ¡å¤„ç†ã€‚ å¼‚æ­¥æ–¹å¼ ä¸¤ä¸ªé€šä¿¡åº”ç”¨ä¹‹é—´å¯ä»¥ä¸ç”¨åŒæ—¶åœ¨çº¿ç­‰å¾…ï¼Œä»»ä½•ä¸€æ–¹åªéœ€å„è‡ªå¤„ç†è‡ªå·±çš„ä¸šåŠ¡ï¼Œæ¯”å¦‚å‘é€æ–¹å‘é€æ¶ˆæ¯ä»¥åŽä¸ç”¨ç™»å½•æŽ¥æ”¶æ–¹çš„å“åº”ï¼Œå¯ä»¥æŽ¥ç€å¤„ç†å…¶ä»–çš„ä»»åŠ¡ã€‚ä¹Ÿå°±æ˜¯è¯´å‘é€æ–¹å’ŒæŽ¥æ”¶æ–¹éƒ½æ˜¯ç›¸äº’ç‹¬ç«‹å­˜åœ¨çš„ï¼Œå‘é€æ–¹åªç®¡æ–¹ï¼ŒæŽ¥æ”¶æ–¹åªèƒ½æŽ¥æ”¶ï¼Œæ— é¡»åŽ»ç­‰å¾…å¯¹æ–¹çš„å“åº”ã€‚ Javaä¸­JMSå°±æ˜¯å…¸åž‹çš„å¼‚æ­¥æ¶ˆæ¯å¤„ç†æœºåˆ¶ï¼ŒJMSæ¶ˆæ¯æœ‰ä¸¤ç§ç±»åž‹ï¼šç‚¹å¯¹ç‚¹ã€å‘å¸ƒ/è®¢é˜…ã€‚ è§†å›¾çš„æ“ä½œï¼Œæ˜¯æœ€ç»ˆéƒ½è¦è½¬åŒ–æˆå¯¹åŸºæœ¬è¡¨çš„æ“ä½œ å¸¸è§çš„è®¾è®¡æ¨¡å¼ å¤§è‡´æŒ‰ç…§æ¨¡å¼çš„åº”ç”¨ç›®æ ‡åˆ†ç±»ï¼Œè®¾è®¡æ¨¡å¼å¯ä»¥åˆ†ä¸ºåˆ›å»ºåž‹æ¨¡å¼ã€ç»“æž„åž‹æ¨¡å¼å’Œè¡Œä¸ºåž‹æ¨¡å¼ã€‚ åˆ›å»ºåž‹æ¨¡å¼ï¼Œæ˜¯å¯¹å¯¹è±¡åˆ›å»ºè¿‡ç¨‹çš„å„ç§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆçš„æ€»ç»“ï¼ŒåŒ…æ‹¬å„ç§å·¥åŽ‚æ¨¡å¼ï¼ˆFactoryã€Abstract Factoryï¼‰ã€å•ä¾‹æ¨¡å¼ï¼ˆSingletonï¼‰ã€æž„å»ºå™¨æ¨¡å¼ï¼ˆBuilderï¼‰ã€åŽŸåž‹æ¨¡å¼ï¼ˆProtoTypeï¼‰ã€‚ ç»“æž„åž‹æ¨¡å¼ï¼Œæ˜¯é’ˆå¯¹è½¯ä»¶è®¾è®¡ç»“æž„çš„æ€»ç»“ï¼Œå…³æ³¨äºŽç±»ã€å¯¹è±¡ç»§æ‰¿ã€ç»„åˆæ–¹å¼çš„å®žè·µç»éªŒã€‚å¸¸è§çš„ç»“æž„åž‹æ¨¡å¼ï¼ŒåŒ…æ‹¬æ¡¥æŽ¥æ¨¡å¼ï¼ˆBridgeï¼‰ã€é€‚é…å™¨æ¨¡å¼ï¼ˆAdapterï¼‰ã€è£…é¥°è€…æ¨¡å¼ï¼ˆDecoratorï¼‰ã€ä»£ç†æ¨¡å¼ï¼ˆProxyï¼‰ã€ç»„åˆæ¨¡å¼ï¼ˆCompositeï¼‰ã€å¤–è§‚æ¨¡å¼ï¼ˆFacadeï¼‰ã€äº«å…ƒæ¨¡å¼ï¼ˆFlyweightï¼‰ç­‰ã€‚ è¡Œä¸ºåž‹æ¨¡å¼ï¼Œæ˜¯ä»Žç±»æˆ–å¯¹è±¡ä¹‹é—´äº¤äº’ã€èŒè´£åˆ’åˆ†ç­‰è§’åº¦æ€»ç»“çš„æ¨¡å¼ã€‚æ¯”è¾ƒå¸¸è§çš„è¡Œä¸ºåž‹æ¨¡å¼æœ‰ç­–ç•¥æ¨¡å¼ï¼ˆStrategyï¼‰ã€è§£é‡Šå™¨æ¨¡å¼ï¼ˆInterpreterï¼‰ã€å‘½ä»¤æ¨¡å¼ï¼ˆCommandï¼‰ã€è§‚å¯Ÿè€…æ¨¡å¼ï¼ˆObserverï¼‰ã€è¿­ä»£å™¨æ¨¡å¼ï¼ˆIteratorï¼‰ã€æ¨¡æ¿æ–¹æ³•æ¨¡å¼ï¼ˆTemplate Methodï¼‰ã€è®¿é—®è€…æ¨¡å¼ï¼ˆVisitorï¼‰ã€‚ å·¥åŽ‚æ¨¡å¼æ˜¯æˆ‘ä»¬æœ€å¸¸ç”¨çš„å®žä¾‹åŒ–å¯¹è±¡æ¨¡å¼äº†ï¼Œç®€å•è®²æ˜¯ç”¨å·¥åŽ‚æ–¹æ³•ä»£æ›¿newæ“ä½œçš„ä¸€ç§æ¨¡å¼ã€‚å•ä¾‹æ¨¡å¼é™åˆ¶äº†ç±»å®žä¾‹çš„åˆ›å»ºï¼Œä½†é‡‡ç”¨è¿™ç§æ¨¡å¼è®¾è®¡çš„ç±»ï¼Œå¯ä»¥ä¿è¯ä»…æœ‰ä¸€ä¸ªå®žä¾‹ï¼Œå¹¶å¯æä¾›è®¿é—®è¯¥å®žä¾‹çš„å…¨å±€è®¿é—®ç‚¹ã€‚åˆ›å»º HttpRequest çš„è¿‡ç¨‹ï¼Œå°±æ˜¯å…¸åž‹çš„æž„å»ºå™¨æ¨¡å¼ï¼ˆBuilderï¼‰ï¼Œé€šå¸¸ä¼šè¢«å®žçŽ°æˆfluent é£Žæ ¼çš„ APIï¼Œä¹Ÿæœ‰äººå«å®ƒæ–¹æ³•é“¾ã€‚é€‚é…å™¨æ¨¡å¼ ï¼šå°†ä¸€ä¸ªç±»çš„æŽ¥å£è½¬æ¢æˆå®¢æˆ·å¸Œæœ›çš„å¦å¤–ä¸€ä¸ªæŽ¥å£ã€‚é€‚é…å™¨æ¨¡å¼ä½¿å¾—åŽŸæœ¬ç”±äºŽæŽ¥å£ä¸å…¼å®¹è€Œä¸èƒ½ä¸€èµ·å·¥ä½œçš„é‚£äº›ç±»å¯ä»¥ä¸€èµ·å·¥ä½œã€‚è£…é¥°å™¨æ¨¡å¼ï¼ˆDecorator Patternï¼‰å…è®¸å‘ä¸€ä¸ªçŽ°æœ‰çš„å¯¹è±¡æ·»åŠ æ–°çš„åŠŸèƒ½ï¼ŒåŒæ—¶åˆä¸æ”¹å˜å…¶ç»“æž„ã€‚è¿™ç§ç±»åž‹çš„è®¾è®¡æ¨¡å¼å±žäºŽç»“æž„åž‹æ¨¡å¼ï¼Œå®ƒæ˜¯ä½œä¸ºçŽ°æœ‰çš„ç±»çš„ä¸€ä¸ªåŒ…è£…ã€‚ å¤šæ€çš„ä»£ç é¢˜ç›® 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;class Base1&#123;public: virtual void fun() &#123; cout &lt;&lt;"Base 1" &lt;&lt;endl; &#125;&#125;;class Base2&#123;public: void fun() &#123; cout &lt;&lt;"Base 2" &lt;&lt;endl; &#125;&#125;;class Derived: public Base1, public Base2&#123;public: void fun() &#123; cout &lt;&lt;"Derived" &lt;&lt;endl; &#125;&#125;;int main()&#123; Base1 bs1, *p1; Base2 bs2, *p2; Derived dv; p1 =&amp;bs1; p1-&gt; fun(); p1 =&amp;dv; p1-&gt; fun(); p2 =&amp;bs2; p2-&gt; fun(); p2 =&amp;dv; p2-&gt; fun(); return 0;&#125; è¾“å‡ºæ˜¯1234Base 1DerivedBase 2Base 2 é€»è¾‘é‡å’ŒçœŸå‡å€¼æ˜¯ç›¸åŒçš„æ„æ€ã€‚ å¸¸è§çš„æ•°æ®æ ¡éªŒæ–¹æ³• å®šä¹‰ï¼šæ ¡éªŒ,æ˜¯ä¸ºä¿æŠ¤æ•°æ®çš„å®Œæ•´æ€§ï¼Œç”¨ä¸€ç§æŒ‡å®šçš„ç®—æ³•å¯¹åŽŸå§‹æ•°æ®è®¡ç®—å‡ºçš„ä¸€ä¸ªæ ¡éªŒå€¼ã€‚å½“æŽ¥æ”¶æ–¹ç”¨åŒæ ·çš„ç®—æ³•å†ç®—ä¸€æ¬¡æ ¡éªŒå€¼ï¼Œå¦‚æžœä¸¤æ¬¡æ ¡éªŒå€¼ä¸€æ ·ï¼Œè¡¨ç¤ºæ•°æ®å®Œæ•´ã€‚ å¥‡å¶æ ¡éªŒï¼š æ ¹æ®è¢«ä¼ è¾“çš„ä¸€ç»„äºŒè¿›åˆ¶ä»£ç ä¸­â€œ1â€çš„ä¸ªæ•°æ˜¯å¥‡æ•°æˆ–å¶æ•°æ¥è¿›è¡Œæ ¡éªŒã€‚eg. æ•°æ®ä½ä¸º 10001100 ï¼ˆ1ï¼‰ -&gt; æœ€åŽä¸€ä½ä¸ºæ ¡éªŒä½ã€‚æ­¤æ—¶è‹¥çº¦å®šå¥½ä¸ºå¥‡æ ¡éªŒï¼Œé‚£ä¹ˆæ•°æ®è¡¨ç¤ºä¸ºæ­£ç¡®çš„ï¼Œè‹¥ä¸ºå¶æ ¡éªŒï¼Œé‚£ä¹ˆæ•°æ®ä¼ è¾“å‡ºé”™äº†ã€‚CRCæ ¡éªŒï¼ˆå¾ªçŽ¯å†—ä½™æ ¡éªŒç ï¼‰ï¼šåˆ©ç”¨é™¤æ•°ä»¥åŠä½™æ•°çš„åŽŸç†è¿›è¡Œé”™è¯¯æ£€æµ‹ï¼Œå°†æŽ¥æ”¶åˆ°çš„ç ç»„è¿›è¡Œé™¤æ³•è¿ç®— ï¼Œå¦‚æžœé™¤å°½ï¼Œåˆ™è¯´æ˜Žä¼ è¾“æ— è¯¯ï¼›å¦‚æžœæœªé™¤å°½ï¼Œåˆ™è¡¨æ˜Žä¼ è¾“å‡ºçŽ°å·®é”™ã€‚ å€ŸåŠ©äºŽå¤šé¡¹å¼é™¤æ³•ï¼Œå…¶ä½™æ•°ä¸ºæ ¡éªŒå­—æ®µã€‚ ä¾‹å¦‚ï¼šä¿¡æ¯å­—æ®µä»£ç ä¸º: 1011001ï¼›å¯¹åº”m(x)=x6+x4+x3+1 å‡è®¾ç”Ÿæˆå¤šé¡¹å¼ä¸ºï¼šg(x)=x4+x3+1ï¼›åˆ™å¯¹åº”g(x)çš„ä»£ç ä¸º: 11001 x4m(x)=x10+x8+x7+x4 å¯¹åº”çš„ä»£ç è®°ä¸ºï¼š10110010000ï¼› é‡‡ç”¨å¤šé¡¹å¼é™¤æ³•: å¾—ä½™æ•°ä¸º: 1010 (å³æ ¡éªŒå­—æ®µä¸ºï¼š1010ï¼‰ å‘é€æ–¹ï¼šå‘å‡ºçš„ä¼ è¾“å­—æ®µä¸º: 1 0 1 1 0 0 11 0 10 ä¿¡æ¯å­—æ®µ æ ¡éªŒå­—æ®µ tcp æœåŠ¡å™¨ç«¯å¯åŠ¨è¿›ç¨‹ï¼Œè°ƒç”¨Socketåˆ›å»ºä¸€ä¸ªåŸºäºŽTCPåè®®çš„æµå¥—æŽ¥å­—æè¿°ç¬¦ã€‚ å…¶æ¬¡ï¼ŒæœåŠ¡è¿›ç¨‹è°ƒç”¨bindå‘½åå¥—æŽ¥å­—ï¼Œå°†å¥—æŽ¥å­—æè¿°ç¬¦ç»‘å®šåˆ°æœ¬åœ°åœ°å€å’Œæœ¬åœ°ç«¯å£ä¸Šã€‚ å†æ¬¡ï¼ŒæœåŠ¡å™¨ç«¯è°ƒç”¨listenï¼Œå¼€å§‹ä¾¦å¬å®¢æˆ·ç«¯çš„Socketè¿žæŽ¥è¯·æ±‚ã€‚ æŽ¥ä¸‹æ¥é˜»å¡žï¼Œç›´åˆ°æ”¶åˆ°äº†å®¢æˆ·ç«¯çš„connectè¯·æ±‚ï¼Œè°ƒç”¨acceptè¿›è¡Œç›¸åº”ã€‚ å› æ­¤ï¼Œä¸é˜»å¡žbindå’Œlisten å•ä¾‹æ¨¡å¼ï¼ˆä»¥ä¸‹éƒ½æ˜¯æ­£ç¡®çš„ï¼‰A ç”¨æˆ·æ— æ³•é€šè¿‡newæ–¹å¼å®žä¾‹åŒ–å•ä¾‹ç±»B è¿èƒŒäº†å•ä¸€èŒè´£åŽŸåˆ™C å•ä¾‹æ¨¡å¼ç”¨äºŽå¤šçº¿ç¨‹åº”ç”¨ç¨‹åºD å•ä¾‹æ¨¡å¼å±žäºŽåˆ›å»ºåž‹æ¨¡å¼ äº§ç”Ÿå¼(production)æè¿°äº†å°†ç»ˆç»“ç¬¦å’Œéžç»ˆç»“ç¬¦ç»„åˆæˆä¸²çš„æ–¹æ³• ä¸€ä¸ªä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ä¸€èˆ¬æ˜¯ç”±ä¸€ç»„éžç»ˆç»“ç¬¦å·ï¼Œä¸€ç»„ç»ˆç»“ç¬¦å·ï¼Œä¸€ä¸ªå¼€å§‹ç¬¦å·å’Œä¸€ç»„äº§ç”Ÿå¼æž„æˆï¼Œé‚£ä¹ˆäº§ç”Ÿå¼æ˜¯ç”¨äºŽå®šä¹‰ï¼ˆè¯­æ³•æˆåˆ†ï¼‰çš„ä¸€ç§è§„åˆ™ å †çš„å­˜å‚¨ æ ¹æ®ç»“ç‚¹åˆ¤åˆ«å¤§æ ¹å †å’Œå°æ ¹å †ã€‚ ä¸€èˆ¬ç”¨æ•°ç»„æ¥è¡¨ç¤ºå †ï¼Œè‹¥æ ¹ç»“ç‚¹å­˜åœ¨åºå·0å¤„ï¼Œ iç»“ç‚¹çš„çˆ¶ç»“ç‚¹ä¸‹æ ‡å°±ä¸ºi/2ã€‚iç»“ç‚¹çš„å·¦å³å­ç»“ç‚¹ä¸‹æ ‡åˆ†åˆ«ä¸º2i+1å’Œ2i+2ã€‚ï¼ˆæ³¨ï¼šå¦‚æžœæ ¹ç»“ç‚¹æ˜¯ä»Ž1å¼€å§‹ï¼Œåˆ™å·¦å³å­©å­ç»“ç‚¹åˆ†åˆ«æ˜¯2iå’Œ2i+1ã€‚ï¼‰å¦‚ç¬¬0ä¸ªç»“ç‚¹å·¦å³å­ç»“ç‚¹ä¸‹æ ‡åˆ†åˆ«ä¸º1å’Œ2ã€‚ å¸¸è§çš„ç«¯å£å’ŒæœåŠ¡ ç«¯å£ï¼š21 æœåŠ¡ï¼šFTP è¯´æ˜Žï¼šFTPæœåŠ¡å™¨æ‰€å¼€æ”¾çš„ç«¯å£ï¼Œç”¨äºŽä¸Šä¼ ã€ä¸‹è½½ã€‚ç«¯å£ï¼š23 æœåŠ¡ï¼šTelnet è¯´æ˜Žï¼šè¿œç¨‹ç™»å½•ï¼Œå…¥ä¾µè€…åœ¨æœç´¢è¿œç¨‹ç™»å½•UNIXçš„æœåŠ¡ã€‚ç«¯å£ï¼š80 æœåŠ¡ï¼šHTTP è¯´æ˜Žï¼šç”¨äºŽç½‘é¡µæµè§ˆã€‚æœ¨é©¬Executorå¼€æ”¾æ­¤ç«¯å£ã€‚ windows ä¸­çš„ åœ¨windows,çº¿ç¨‹åŒæ­¥çš„æ–¹å¼æ¯”è¾ƒå¤š,è¿™ç¯‡åªæ˜¯ç®€å•çš„ä»‹ç»ä½¿ç”¨å†…æ ¸å¯¹è±¡äº’æ–¥é‡è¿›è¡Œçº¿ç¨‹åŒæ­¥,äº’æ–¥é‡Mutexä¸ºå†…æ ¸å¯¹è±¡,ä½¿ç”¨æ–¹å¼åŽŸç†å’Œä¸´ç•ŒåŒºCriticalSectionå·®ä¸å¤š,ä¸´ç•ŒåŒºæ˜¯åŸºäºŽç”¨æˆ·ç©ºé—´è¿›è¡Œçº¿ç¨‹åŒæ­¥çš„,åªèƒ½è¿›è¡ŒåŒä¸€ä¸ªè¿›ç¨‹ä¸­çº¿ç¨‹çš„åŒæ­¥,ä¸èƒ½è·¨è¿›ç¨‹,å› ä¸ºä¸æ˜¯åŸºäºŽå†…æ ¸æ€çš„. linux ä¸­çš„åŒæ­¥å’Œäº’æ–¥ ä¸´ç•Œèµ„æºçš„æ¦‚å¿µï¼šå¤šä¸ªçº¿ç¨‹ä¸èƒ½åŒæ—¶ä½¿ç”¨çš„èµ„æºç§°ä¸ºä¸´ç•Œèµ„æºCRï¼ˆCritical Resourceï¼‰ã€‚ä¸´ç•Œèµ„æºå¯ä»¥æ˜¯ä¸€äº›ç‹¬å è®¾å¤‡ï¼Œæ¯”å¦‚æ‰“å°æœºç­‰ï¼Œä¹Ÿå¯ä»¥æ˜¯ä¸€äº›å…±äº«å˜é‡ï¼Œè¡¨æ ¼ï¼Œé“¾è¡¨ç­‰ã€‚ä¸´ç•ŒåŒºï¼šä¸è®ºç¡¬ä»¶ä¸´ç•Œèµ„æºè¿˜æ˜¯è½¯ä»¶ä¸´ç•Œèµ„æºï¼Œå¤šä¸ªçº¿ç¨‹å¿…é¡»äº’æ–¥çš„å¯¹å…¶è¿›è¡Œè®¿é—®ã€‚æ¯ä¸ªçº¿ç¨‹ä¸­è®¿é—®ä¸´ç•Œèµ„æºçš„é‚£æ®µä»£ç ç§°ä¸ºä¸´ç•ŒåŒºCSï¼ˆCritical Sectionï¼‰ã€‚æ¯ä¸ªçº¿ç¨‹åœ¨è¿›å…¥ä¸´ç•ŒåŒºä»¥å‰ï¼Œåº”è¯¥å¯¹æ¬²è®¿é—®çš„ä¸´ç•Œèµ„æºè¿›è¡Œæ£€æŸ¥ï¼Œçœ‹ä»–æ˜¯å¦æ­£åœ¨è¢«è®¿é—®ã€‚è‹¥æ˜¯ï¼Œåˆ™è¯¥çº¿ç¨‹ä¸èƒ½è¿›å…¥ä¸´ç•ŒåŒºï¼Œè‹¥å¦ï¼Œåˆ™è¯¥çº¿ç¨‹å¯ä»¥è¿›å…¥ä¸´ç•ŒåŒºå¯¹è¯¥èµ„æºè¿›è¡Œè®¿é—®ï¼Œå¹¶è®¾ç½®åªåœ¨è¢«è®¿é—®çš„æ ‡å¿—ã€‚çº¿ç¨‹äº’æ–¥çš„æ¦‚å¿µï¼šçº¿ç¨‹äº’æ–¥æ˜¯æŒ‡å¤šä¸ªçº¿ç¨‹ä¸èƒ½åŒæ—¶ä½¿ç”¨åŒä¸€ä¸ªä¸´ç•Œèµ„æºï¼Œå³ä¸¤ä¸ªæˆ–ä¸¤ä¸ªä»¥ä¸Šçº¿ç¨‹å¿…é¡»äº’æ–¥çš„ä½¿ç”¨ä¸´ç•Œèµ„æºï¼Œå½“ç„¶ä¸èƒ½åŒæ—¶è¿›å…¥ä¸´ç•ŒåŒºã€‚çº¿ç¨‹åŒæ­¥çš„æ¦‚å¿µï¼šçº¿ç¨‹åŒæ­¥æ˜¯æŒ‡æœ‰åä½œå…³ç³»çš„çº¿ç¨‹ä¹‹é—´ä¸æ–­åœ°è°ƒæ•´ä»–ä»¬ä¹‹é—´çš„ç›¸å¯¹é€Ÿåº¦æˆ–è€…æ‰§è¡Œè¿‡ç¨‹ï¼Œä»¥ä¿è¯ä¸´ç•Œèµ„æºçš„åˆç†åˆ©ç”¨å’Œçº¿ç¨‹çš„é¡ºåˆ©æ‰§è¡Œã€‚å®žçŽ°çº¿ç¨‹åŒæ­¥çš„æœºåˆ¶ç§°ä¸ºçº¿ç¨‹åŒæ­¥æœºåˆ¶ã€‚ åŒæ­¥æœºåˆ¶éµå¾ªçš„è§„åˆ™ï¼š ç©ºé—²è®©è¿›ï¼šå¹¶å‘çº¿ç¨‹ä¸­æŸä¸ªçº¿ç¨‹ä¸å†ä¸´ç•ŒåŒºæ—¶ï¼Œä¸é˜»æ­¢å…¶å®ƒçº¿ç¨‹è¿›å…¥ä¸´ç•ŒåŒºã€‚ å¿™åˆ™ç­‰å¾…ï¼šåªå…è®¸åŒä¸€æ—¶åˆ»ä¸€ä¸ªçº¿ç¨‹è¿›å…¥ä¸´ç•ŒåŒºï¼Œå…¶å®ƒæ¬²è¿›å…¥ä¸´ç•ŒåŒºçš„çº¿ç¨‹ç­‰å¾…ã€‚ æœ‰é™ç­‰å¾…ï¼šæ¬²è®¿é—®ä¸´ç•ŒåŒºçš„çº¿ç¨‹è¦åœ¨æœ‰é™çš„æ—¶é—´å†…è®¿é—®åˆ°ä¸´ç•ŒåŒºï¼Œé¿å…é™·å…¥â€œæ­»ç­‰â€çŠ¶æ€ã€‚ è®©æƒç­‰å¾…:å½“çº¿ç¨‹ä¸èƒ½è¿›å…¥è‡ªå·±çš„ä¸´ç•ŒåŒºçš„æ—¶å€™ï¼Œåº”ç«‹å³é‡Šæ”¾CPUï¼Œä»¥é¿å…çº¿ç¨‹é™·å…¥â€œå¿™ç­‰â€çŠ¶æ€ã€‚ é”æœºåˆ¶ï¼šå®žçŽ°äº’æ–¥çš„ä¸€ç§æ–¹å¼æ˜¯é‡‡ç”¨é”æœºåˆ¶ï¼Œå³æä¾›ä¸Šé”ï¼ˆLockï¼‰å’Œå¼€é”ï¼ˆUnlockï¼‰åŽŸè¯­ï¼Œä»¥åŠä¸€ä¸ªé”å˜é‡wæˆ–è€…é”ä½ï¼ˆ1bitï¼‰ã€‚ä¿¡å·é‡:ï¼ˆSemaphoreï¼‰ä¹Ÿå«ä¿¡å·ç¯ï¼Œæ˜¯åœ¨ä¿¡å·åŒæ­¥æœºåˆ¶ä¸­ç”¨äºŽå®žçŽ°çº¿ç¨‹çš„åŒæ­¥å’Œäº’æ–¥æœ‰æ•ˆçš„æ•°æ®ç»“æž„ã€‚ä¿¡å·é‡æœºåˆ¶ï¼šä¿¡å·é‡æœºåˆ¶ä¸­ï¼Œç”³è¯·å’Œé‡Šæ”¾ä¸´ç•Œèµ„æºçš„ä¸¤ä¸ªåŽŸè¯­æ“ä½œä¸ºwaitæ“ä½œå’Œsignalæ“ä½œï¼Œæœ‰æ—¶ä¹Ÿç§°ä¸ºPæ“ä½œå’ŒVæ“ä½œã€‚ å¸¸è§çš„é¡µé¢ç½®æ¢ç®—æ³• æœ€ä½³ç½®æ¢ç®—æ³•ï¼ˆOPTï¼‰ï¼šæœ€ä½³ï¼ˆOptimalï¼ŒOPTï¼‰ç½®æ¢ç®—æ³•æ‰€é€‰æ‹©çš„è¢«æ·˜æ±°é¡µé¢å°†æ˜¯ä»¥åŽæ°¸ä¸é€‚ç”¨çš„ï¼Œæˆ–è€…æ˜¯åœ¨æœ€é•¿æ—¶é—´å†…ä¸å†è¢«è®¿é—®çš„é¡µé¢ï¼Œè¿™æ ·å¯ä»¥ä¿è¯èŽ·å¾—æœ€ä½Žçš„ç¼ºé¡µçŽ‡ã€‚ä½†æ˜¯ç”±äºŽäººä»¬ç›®å‰æ— æ³•é¢„çŸ¥è¿›ç¨‹åœ¨å†…å­˜ä¸‹çš„è‹¥å¹²é¡µé¢ä¸­å“ªä¸ªæ˜¯æœªæ¥æœ€é•¿æ—¶é—´ä¸å†è¢«è®¿é—®çš„ï¼Œå› è€Œè¯¥ç®—æ³•æ— æ³•å®žçŽ°ã€‚ å…ˆè¿›å…ˆå‡ºï¼ˆFIFOï¼‰é¡µé¢ç½®æ¢ç®—æ³•ï¼šFIFOç®—æ³•è¿˜ä¼šäº§ç”Ÿå½“æ‰€åˆ†é…çš„ç‰©ç†å—æ•°å¢žå¤§è€Œé¡µæ•…éšœæ•°ä¸å‡åå¢žçš„å¼‚å¸¸çŽ°è±¡ï¼Œè¿™æ—¶ç”±beladyäºŽ1969å¹´å‘çŽ°ï¼Œæ•…ç§°ä¸ºBeladyå¼‚å¸¸ã€‚åªæœ‰FIFOç®—æ³•å¯èƒ½å‡ºçŽ°Beladyå¼‚å¸¸ï¼Œè€ŒLRUå’ŒOPTç®—æ³•æ°¸è¿œä¸ä¼šå‡ºçŽ°Beladyå¼‚å¸¸ã€‚ æœ€è¿‘æœ€ä¹…æœªä½¿ç”¨ï¼ˆLRUï¼‰ç½®æ¢ç®—æ³•ï¼šé€‰æ‹©æœ€è¿‘æœ€é•¿æ—¶é—´æœªè®¿é—®è¿‡çš„é¡µé¢äºˆä»¥æ·˜æ±°ï¼Œå®ƒè®¤ä¸ºè¿‡åŽ»æ—¶é—´å†…ä¸€æ®µæ—¶é—´å†…æœªè®¿é—®è¿‡çš„é¡µé¢ï¼Œåœ¨æœ€è¿‘çš„å°†æ¥ä¹Ÿä¸ä¼šè¢«è®¿é—®ã€‚ï¼ˆä½¿ç”¨ä¸€ä¸ªé˜Ÿåˆ—æ¥æ¨¡æ‹Ÿæ•´ä¸ªè¿‡ç¨‹ï¼‰ã€‚ LRUæ€§èƒ½è¾ƒå¥½ï¼Œä½†éœ€è¦å¯„å­˜å™¨å’Œæ ˆçš„ç¡¬ä»¶æ”¯æŒã€‚LRUæ˜¯å †æ ˆç±»çš„ç®—æ³•ã€‚ç†è®ºä¸Šå¯ä»¥è¯æ˜Žï¼Œå †æ ˆç±»çš„ç®—æ³•ä¸å¯èƒ½å‡ºçŽ°beladyå¼‚å¸¸ã€‚FIFOåŸºäºŽé˜Ÿåˆ—å®žçŽ°ï¼Œä¸æ˜¯å †æ ˆç±»ç®—æ³•ã€‚ LRUç®—æ³•çš„æ€§èƒ½æŽ¥è¿‘äºŽOPTï¼Œä½†æ˜¯å®žçŽ°èµ·æ¥æ¯”è¾ƒå›°éš¾ï¼Œä¸”å¼€é”€å¤§ï¼›FIFOç®—æ³•å®žçŽ°ç®€å•ï¼Œä½†æ€§èƒ½å·®ã€‚æ—¶é’Ÿï¼ˆCLOCKï¼‰ç½®æ¢ç®—æ³•ï¼šå¦‚æžœæ‰€æœ‰å¸§çš„ä½¿ç”¨ä½å‡ä¸º1ï¼Œåˆ™æŒ‡é’ˆåœ¨ç¼“å†²åŒºä¸­å®Œæ•´åœ°å¾ªçŽ¯ä¸€å‘¨ï¼Œå°†æ‰€æœ‰ä½¿ç”¨ä½éƒ½ç½®ä¸º0ï¼Œå¹¶ä¸”åœç•™åœ¨æœ€åˆçš„ä½ç½®ä¸Šï¼Œæ›¿æ¢è¯¥å¸§ä¸­çš„é¡µã€‚ç”±äºŽè¯¥ç®—æ³•å¾ªçŽ¯åœ°æ£€æŸ¥å„é¡µé¢çš„æƒ…å†µï¼Œæ•…ç§°ä¸ºCLOCKç®—æ³•ï¼Œåˆç§°ä¸ºæœ€è¿‘æœªä½¿ç”¨ï¼ˆNot Recently Usedï¼ŒNRUï¼‰ç®—æ³•ï¼ˆè¿™ä¸ªç®—æ³•å…¶å®žä¸æ˜¯å¾ˆæ‡‚ è¿‡ç¨‹ï¼Œï¼‰ ç¼ºé¡µçŽ‡çš„è®¡ç®— try catchçš„ä½¿ç”¨ åªæœ‰é”™è¯¯å¯é¢„çŸ¥æ—¶æ‰ç”¨tryã€‚æ‰€æœ‰ä¸å¯é¢„çŸ¥çš„é”™è¯¯ç”¨tryéƒ½æ˜¯ä¸è´Ÿè´£ä»»çš„å†™æ³• 12345678910try &#123; è¯­å¥ç»„&#125;catch(å¼‚å¸¸ç±»åž‹) &#123; å¼‚å¸¸å¤„ç†ä»£ç &#125;...catch(å¼‚å¸¸ç±»åž‹) &#123; å¼‚å¸¸å¤„ç†ä»£ç &#125; UMLç±»å›¾ä¸­çš„å…­å¤§å…³ç³»ï¼šå…³è”ã€èšåˆã€ç»„åˆã€ä¾èµ–ã€ç»§æ‰¿ã€å®žçŽ° å…³è”æè¿°ä¸¤ä¸ªç±»ä¹‹é—´è¡Œä¸ºçš„ä¸€èˆ¬äºŒå…ƒå…³ç³»ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªå­¦ç”Ÿé€‰ä¿®ä¸€é—¨ç‰¹å®šçš„è¯¾ç¨‹æ˜¯å­¦ç”Ÿç±»Studentå’Œè¯¾ç¨‹ç±»Courseä¹‹é—´çš„ä¸€ä¸ªå…³è”ï¼Œè€Œä¸€ä¸ªæ•™å¸ˆæ•™æŽˆä¸€é—¨è¯¾ç¨‹æ˜¯å¸ˆèµ„ç±»Facultyå’Œè¯¾ç¨‹ç±»Courseä¹‹é—´çš„ä¸€ä¸ªå…³è”ã€‚Javaä»£ç ä¸­ï¼Œå…³è”å¯ä»¥ç”¨å±žæ€§å’Œæ–¹æ³•æ¥å®žçŽ°ã€‚ èšåˆæ˜¯ä¸€ç§ç‰¹æ®Šçš„å…³è”(Association)å½¢å¼ï¼Œè¡¨ç¤ºä¸¤ä¸ªå¯¹è±¡ä¹‹é—´çš„æ‰€å±ž(has-a)å…³ç³»ã€‚æ‰€æœ‰è€…å¯¹è±¡ç§°ä¸ºèšåˆå¯¹è±¡ï¼Œå®ƒçš„ç±»ç§°ä¸ºèšåˆç±»ï¼›ä»Žå±žå¯¹è±¡ç§°ä¸ºè¢«èšåˆå¯¹è±¡ï¼Œå®ƒçš„ç±»ç§°ä¸ºè¢«èšåˆç±»ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªå…¬å¸æœ‰å¾ˆå¤šå‘˜å·¥å°±æ˜¯å…¬å¸ç±»Companyå’Œå‘˜å·¥ç±»Employeeä¹‹é—´çš„ä¸€ç§èšåˆå…³ç³»ã€‚è¢«èšåˆå¯¹è±¡å’Œèšåˆå¯¹è±¡æœ‰ç€å„è‡ªçš„ç”Ÿå‘½å‘¨æœŸï¼Œå³å¦‚æžœå…¬å¸å€’é—­å¹¶ä¸å½±å“å‘˜å·¥çš„å­˜åœ¨ã€‚ èšåˆæ˜¯ä¸€ç§è¾ƒå¼±å½¢å¼çš„å¯¹è±¡åŒ…å«(ä¸€ä¸ªå¯¹è±¡åŒ…å«å¦ä¸€ä¸ªå¯¹è±¡)å…³ç³»ã€‚è¾ƒå¼ºå½¢å¼æ˜¯ç»„åˆ(Composition). åœ¨ç»„åˆå…³ç³»ä¸­åŒ…å«å¯¹è±¡è´Ÿè´£è¢«åŒ…å«å¯¹è±¡çš„åˆ›å»ºä»¥åŠç”Ÿå‘½å‘¨æœŸï¼Œå³å½“åŒ…å«å¯¹è±¡è¢«é”€æ¯æ—¶è¢«åŒ…å«å¯¹è±¡ä¹Ÿä¼šä¸å¤å­˜åœ¨ã€‚ä¾‹å¦‚ä¸€è¾†æ±½è½¦æ‹¥æœ‰ä¸€ä¸ªå¼•æ“Žæ˜¯æ±½è½¦ç±»Carä¸Žå¼•æ“Žç±»Engineçš„ç»„åˆå…³ç³»ã€‚ ä¾èµ–(Dependency)æè¿°çš„æ˜¯ä¸€ä¸ªç±»çš„å¼•ç”¨ç”¨ä½œå¦ä¸€ä¸ªç±»çš„æ–¹æ³•çš„å‚æ•°ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥ä½¿ç”¨Calendarç±»ä¸­çš„setTime(Date date)æ–¹æ³•è®¾ç½®æ—¥åŽ†ï¼Œæ‰€ä»¥Calendarå’ŒDateä¹‹é—´çš„å…³ç³»å¯ä»¥ç”¨ä¾èµ–æè¿°ã€‚ ç»§æ‰¿(Inheritance)æ¨¡æ‹Ÿä¸¤ä¸ªç±»ä¹‹é—´çš„is-aå…³ç³»ã€‚å¼ºæ˜¯(strong is-a)å…³ç³»æè¿°ä¸¤ä¸ªç±»ä¹‹é—´çš„ç›´æŽ¥ç»§æ‰¿å…³ç³»ã€‚å¼±æ˜¯(weak is-a)å…³ç³»æè¿°ä¸€ä¸ªç±»å…·æœ‰æŸä¸ªå±žæ€§ã€‚å¼ºæ˜¯å…³ç³»å¯ä»¥ç”¨ç±»çš„ç»§æ‰¿è¡¨ç¤ºã€‚ä¾‹å¦‚ï¼ŒSpringçš„ApplicationEventæ˜¯ä¸€ä¸ªEventObjectï¼ŒApplicationEventå’ŒEventObjecté—´å°±æ˜¯ä¸€ç§å¼ºæ˜¯å…³ç³»ï¼Œå¯ä»¥ç”¨ç»§æ‰¿æè¿°ã€‚ å®žçŽ°(Realization)æè¿°çš„æ˜¯ä¸€ä¸ªç±»å®žçŽ°äº†æŽ¥å£ï¼ˆå¯ä»¥æ˜¯å¤šä¸ªï¼‰ã€‚ sizeof çš„ä½¿ç”¨ char,short int(short),int,long int(long),float,double, long doubleå¤§å°åˆ†åˆ«æ˜¯ï¼š1ï¼Œ2ï¼Œ4ï¼Œ4ï¼Œ4ï¼Œ8, 10ã€‚ ä¸æ‡‚å‡½æ•°ä¸­çš„é‚£ä¸ªä¸ºä»€ä¹ˆæ˜¯ sizeof æ˜¯8 å‘€ã€‚ 1234567891011121314#include&lt;iostream&gt;using namespace std;void func(char str[100])&#123; cout &lt;&lt; sizeof(str)&lt;&lt;endl; // 8&#125;int main()&#123; char str[200]; func(str); char ch; //1 cout &lt;&lt; sizeof(str)&lt;&lt;endl; //200 return 0;&#125; å¸¸è§çš„ç”Ÿæˆæ¨¡åž‹å’Œåˆ¤åˆ«æ¨¡åž‹ ç”Ÿæˆæ¨¡åž‹ï¼šhmmï¼Œæœ´ç´ è´å¶æ–¯åˆ¤åˆ«æ¨¡åž‹ï¼šæ¡ä»¶éšæœºåœºcrfï¼Œ ä¸‹é¢å“ªäº›ä¼˜åŒ–ç®—æ³•å’ŒåŠ¨é‡ç›¸å…³ momentum, adam, nesterov accelerated gradient(åœ¨rnn ä¸­ä½¿ç”¨æ¯”è¾ƒå¸¸è§ )ï¼ˆå‚è€ƒåšå®¢http://localhost:4000/2019/03/26/æ·±åº¦ç½‘ç»œä¸­çš„ç¢Žç¢Žå¿µ/ï¼‰ å››ç§æ•°æ®å­˜å‚¨ç»“æž„â€”é¡ºåºå­˜å‚¨ é“¾æŽ¥å­˜å‚¨ ç´¢å¼•å­˜å‚¨ æ•£åˆ—å­˜å‚¨ é¡ºåºç»“æž„å’Œé“¾æŽ¥ç»“æž„é€‚ç”¨åœ¨å†…å­˜ç»“æž„ä¸­ã€‚ç´¢å¼•ç»“æž„å’Œæ•£åˆ—ç»“æž„é€‚ç”¨åœ¨å¤–å­˜ä¸Žå†…å­˜äº¤äº’ç»“æž„ã€‚é™¤å»ºç«‹å­˜å‚¨ç»“ç‚¹ä¿¡æ¯å¤–ï¼Œè¿˜å»ºç«‹é™„åŠ çš„ç´¢å¼•è¡¨æ¥æ ‡è¯†ç»“ç‚¹çš„åœ°å€ã€‚ç´¢å¼•è¡¨ç”±è‹¥å¹²ç´¢å¼•é¡¹ç»„æˆã€‚å…¶ä¼˜ç‚¹æ˜¯æ£€ç´¢é€Ÿåº¦å¿«ï¼Œç¼ºç‚¹æ˜¯å¢žåŠ äº†é™„åŠ çš„ç´¢å¼•è¡¨,ä¼šå ç”¨è¾ƒå¤šçš„å­˜å‚¨ç©ºé—´ã€‚åœ¨æ•°æ®è¡¨ä¸­ï¼Œå°±æ˜¯ç”¨ç´¢å¼•é”®æ¥è¿›è¡Œå­˜å‚¨ä¸Žæ£€ç´¢çš„ã€‚æ•£åˆ—å­˜å‚¨ï¼Œåˆç§°hashå­˜å‚¨ï¼Œæ˜¯ä¸€ç§åŠ›å›¾å°†æ•°æ®å…ƒç´ çš„å­˜å‚¨ä½ç½®ä¸Žå…³é”®ç ä¹‹é—´å»ºç«‹ç¡®å®šå¯¹åº”å…³ç³»çš„æŸ¥æ‰¾æŠ€æœ¯ã€‚ æ ¹æ®ä½™æ•°è¿›è¡Œâ€œèšç±»â€çš„é¢˜ç›®å‡å®šä¸€ä¸ªçº¿æ€§è¡¨ä¸º (12,23,74,55,63,40) ï¼Œè‹¥æŒ‰ Key % 4 æ¡ä»¶è¿›è¡Œåˆ’åˆ†ï¼Œä½¿å¾—åŒä¸€ä½™æ•°çš„å…ƒç´ æˆä¸ºä¸€ä¸ªå­è¡¨ï¼Œåˆ™å¾—åˆ°çš„å››ä¸ªå­è¡¨åˆ†åˆ«ä¸ºï¼ˆ1ï¼‰ ã€ï¼ˆ2ï¼‰ ã€ï¼ˆ3ï¼‰ å’Œï¼ˆ4ï¼‰ ã€‚ é€»è¾‘ç»“æž„å’Œå­˜å‚¨ç»“æž„é€»è¾‘ç»“æž„åˆ†æˆçº¿æ€§ç»“æž„å’Œéžçº¿æ€§ç»“æž„ï¼›å­˜å‚¨ç»“æž„åˆ†ä¸ºé¡ºåºå­˜å‚¨ å’Œé“¾å¼å­˜å‚¨ã€‚ è¿ç®—ç¬¦å·è¡¨è¾¾å¼ (a++) +(++b) +ab æ³¨æ„åŠ æ³•æ˜¯æœ‰é¡ºåºçš„ï¼Œæ‰€ä»¥è¯´ç»“æžœåº”è¯¥æ˜¯ a+ b+1 + (a+1)(b+1) ã€‚å½“æ‰§è¡Œå®Œ a++ï¼Œè¿™ä¸ªæ—¶å€™ a å·²ç»å˜åŒ–äº†ã€‚ java çš„è¿‡ç¨‹ â€˜â€™â€˜javaä¸­æºæ–‡ä»¶çš„åŽç¼€ä¸º.javaï¼Œç»è¿‡javac.exeç¼–è¯‘åŽç”Ÿæˆå­—èŠ‚ç æ–‡ä»¶ï¼ŒåŽç¼€ä¸º.classï¼Œå†ç»è¿‡java.exeç¼–è¯‘ä¸ºå¯æ‰§è¡Œæ–‡ä»¶ï¼ŒåŽç¼€ä¸º.exeã€‚ .jar ä¸€ç§åŽ‹ç¼©åŒ…æ ¼å¼ï¼Œç”¨æ¥æ‰“åŒ…ç±»åº“Â·Â·Â· é‡å†™å­ç±»ä¸­çš„æŸä¸ªæ–¹æ³•å’Œå‡½æ•°åï¼Œå‚æ•°ä¸ªæ•°ï¼Œå‚æ•°ç±»åž‹å’Œçˆ¶ç±»ä¸­çš„æŸä¸ªæ–¹æ³•å®Œå…¨ä¸€æ ·ï¼Œé‚£ä¹ˆå°±æ˜¯è¦†ç›–äº†ã€‚]]></content>
      <categories>
        <category>CSåŸºç¡€</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SVM All You Need to Know]]></title>
    <url>%2F2019%2F06%2F08%2Fsvm-all-you-need%2F</url>
    <content type="text"><![CDATA[æœ¬æ–‡ä¸»è¦ä»‹ç»SVM ç›¸å…³å†…å®¹ï¼ŒåŒ…æ‹¬ç†è®ºåŽŸç†ã€åœ¨çº¿æ€§å¯åˆ†æ¡ä»¶ä¸‹çš„å…¬å¼æŽ¨å¯¼å’Œ SVMçš„åº”ç”¨ç‰¹ç‚¹ã€‚æœ€åŽç»¼åˆ LR å’Œ Decision Treeçš„è¿™ç¯‡åšå®¢ï¼Œç»™å‡ºäº†ä¸€äº›å°çš„å»ºè®®ã€‚ SVM ç†è®ºæ”¯æŒå‘é‡æœºåˆ†ä¸ºä¸‰ä¸ªéƒ¨åˆ†ï¼Œçº¿æ€§å¯åˆ†æ”¯æŒå‘é‡æœºã€çº¿æ€§æ”¯æŒå‘é‡æœºã€éžçº¿æ€§æ”¯æŒå‘é‡æœºã€‚ SVM åŽŸç†SVM æ˜¯ä¸€ç§äºŒç±»åˆ†ç±»æ¨¡åž‹ã€‚å®ƒçš„åŸºæœ¬æ¨¡åž‹æ˜¯åœ¨ç‰¹å¾ç©ºé—´ä¸­å¯»æ‰¾é—´éš”æœ€å¤§åŒ–çš„åˆ†ç¦»è¶…å¹³é¢çš„çº¿æ€§åˆ†ç±»å™¨ã€‚ å½“è®­ç»ƒæ ·æœ¬çº¿æ€§å¯åˆ†æ—¶ï¼Œé€šè¿‡ç¡¬é—´éš”æœ€å¤§åŒ–ï¼Œå­¦ä¹ ä¸€ä¸ªçº¿æ€§åˆ†ç±»å™¨ï¼Œå³çº¿æ€§å¯åˆ†æ”¯æŒå‘é‡æœºï¼›å½“è®­ç»ƒæ•°æ®è¿‘ä¼¼çº¿æ€§å¯åˆ†æ—¶ï¼Œå¼•å…¥æ¾å¼›å˜é‡ï¼Œé€šè¿‡è½¯é—´éš”æœ€å¤§åŒ–ï¼Œå­¦ä¹ ä¸€ä¸ªçº¿æ€§åˆ†ç±»å™¨ï¼Œå³çº¿æ€§æ”¯æŒå‘é‡æœºï¼›å½“è®­ç»ƒæ•°æ®çº¿æ€§ä¸å¯åˆ†æ—¶ï¼Œé€šè¿‡ä½¿ç”¨æ ¸æŠ€å·§åŠè½¯é—´éš”æœ€å¤§åŒ–ï¼Œå­¦ä¹ éžçº¿æ€§æ”¯æŒå‘é‡æœºã€‚ä»¥ä¸Šå„ç§æƒ…å†µä¸‹çš„æ•°å­¦æŽ¨åˆ°åº”å½“æŽŒæ¡ï¼Œç¡¬é—´éš”æœ€å¤§åŒ–ï¼ˆå‡ ä½•é—´éš”ï¼‰ã€å­¦ä¹ çš„å¯¹å¶é—®é¢˜ã€è½¯é—´éš”æœ€å¤§åŒ–ï¼ˆå¼•å…¥æ¾å¼›å˜é‡ï¼‰ã€éžçº¿æ€§æ”¯æŒå‘é‡æœºï¼ˆæ ¸æŠ€å·§ï¼‰ã€‚ SVM ä¸ºä»€ä¹ˆé‡‡ç”¨é—´éš”æœ€å¤§åŒ–å½“è®­ç»ƒæ•°æ®çº¿æ€§å¯åˆ†æ—¶ï¼Œå­˜åœ¨æ— ç©·ä¸ªåˆ†ç¦»è¶…å¹³é¢å¯ä»¥å°†ä¸¤ç±»æ•°æ®æ­£ç¡®åˆ†å¼€ã€‚æ„ŸçŸ¥æœºåˆ©ç”¨è¯¯åˆ†ç±»æœ€å°ç­–ç•¥ï¼Œæ±‚å¾—åˆ†ç¦»è¶…å¹³é¢ï¼Œä¸è¿‡æ­¤æ—¶çš„è§£æœ‰æ— ç©·å¤šä¸ªã€‚çº¿æ€§å¯åˆ†æ”¯æŒå‘é‡æœºåˆ©ç”¨é—´éš”æœ€å¤§åŒ–æ±‚å¾—æœ€ä¼˜åˆ†ç¦»è¶…å¹³é¢ï¼Œè¿™æ—¶ï¼Œè§£æ˜¯å”¯ä¸€çš„ã€‚å¦ä¸€æ–¹é¢ï¼Œæ­¤æ—¶çš„åˆ†éš”è¶…å¹³é¢æ‰€äº§ç”Ÿçš„åˆ†ç±»ç»“æžœæ˜¯æœ€é²æ£’çš„ï¼Œå¯¹æœªçŸ¥å®žä¾‹çš„æ³›åŒ–èƒ½åŠ›æœ€å¼ºã€‚å¯ä»¥å€Ÿæ­¤æœºä¼šé˜è¿°ä¸€ä¸‹å‡ ä½•é—´éš”ä»¥åŠå‡½æ•°é—´éš”çš„å…³ç³»ã€‚ ä¸ºä»€ä¹ˆè¦å°†æ±‚è§£ SVM çš„åŽŸå§‹é—®é¢˜è½¬æ¢ä¸ºå…¶å¯¹å¶é—®é¢˜ä¸€æ˜¯å¯¹å¶é—®é¢˜å¾€å¾€æ›´æ˜“æ±‚è§£ï¼Œå½“æˆ‘ä»¬å¯»æ‰¾çº¦æŸå­˜åœ¨æ—¶çš„æœ€ä¼˜ç‚¹çš„æ—¶å€™ï¼Œçº¦æŸçš„å­˜åœ¨è™½ç„¶å‡å°äº†éœ€è¦æœå¯»çš„èŒƒå›´ï¼Œä½†æ˜¯å´ä½¿é—®é¢˜å˜å¾—æ›´åŠ å¤æ‚ã€‚ä¸ºäº†ä½¿é—®é¢˜å˜å¾—æ˜“äºŽå¤„ç†ï¼Œæˆ‘ä»¬çš„æ–¹æ³•æ˜¯æŠŠç›®æ ‡å‡½æ•°å’Œçº¦æŸå…¨éƒ¨èžå…¥ä¸€ä¸ªæ–°çš„å‡½æ•°ï¼Œå³æ‹‰æ ¼æœ—æ—¥å‡½æ•°ï¼Œå†é€šè¿‡è¿™ä¸ªå‡½æ•°æ¥å¯»æ‰¾æœ€ä¼˜ç‚¹ã€‚äºŒæ˜¯å¯ä»¥è‡ªç„¶å¼•å…¥æ ¸å‡½æ•°ï¼Œè¿›è€ŒæŽ¨å¹¿åˆ°éžçº¿æ€§åˆ†ç±»é—®é¢˜ã€‚ ä¸ºä»€ä¹ˆ SVM è¦å¼•å…¥æ ¸å‡½æ•°å½“æ ·æœ¬åœ¨åŽŸå§‹ç©ºé—´çº¿æ€§ä¸å¯åˆ†æ—¶ï¼Œå¯å°†æ ·æœ¬ä»ŽåŽŸå§‹ç©ºé—´æ˜ å°„åˆ°ä¸€ä¸ªæ›´é«˜ç»´çš„ç‰¹å¾ç©ºé—´ï¼Œä½¿å¾—æ ·æœ¬åœ¨è¿™ä¸ªç‰¹å¾ç©ºé—´å†…çº¿æ€§å¯åˆ†ã€‚è€Œå¼•å…¥è¿™æ ·çš„æ˜ å°„åŽï¼Œæ‰€è¦æ±‚è§£çš„å¯¹å¶é—®é¢˜çš„æ±‚è§£ä¸­ï¼Œæ— éœ€æ±‚è§£çœŸæ­£çš„æ˜ å°„å‡½æ•°ï¼Œè€Œåªéœ€è¦çŸ¥é“å…¶æ ¸å‡½æ•°ã€‚æ ¸å‡½æ•°çš„å®šä¹‰ï¼šK(x,y)=&lt;Ï•(x),Ï•(y)&gt;ï¼Œå³åœ¨ç‰¹å¾ç©ºé—´çš„å†…ç§¯ç­‰äºŽå®ƒä»¬åœ¨åŽŸå§‹æ ·æœ¬ç©ºé—´ä¸­é€šè¿‡æ ¸å‡½æ•° K è®¡ç®—çš„ç»“æžœã€‚ä¸€æ–¹é¢æ•°æ®å˜æˆäº†é«˜ç»´ç©ºé—´ä¸­çº¿æ€§å¯åˆ†çš„æ•°æ®ï¼Œå¦ä¸€æ–¹é¢ä¸éœ€è¦æ±‚è§£å…·ä½“çš„æ˜ å°„å‡½æ•°ï¼Œåªéœ€è¦ç»™å®šå…·ä½“çš„æ ¸å‡½æ•°å³å¯ï¼Œè¿™æ ·ä½¿å¾—æ±‚è§£çš„éš¾åº¦å¤§å¤§é™ä½Žã€‚ ä¸ºä»€ä¹ˆSVMå¯¹ç¼ºå¤±æ•°æ®æ•æ„Ÿè¿™é‡Œè¯´çš„ç¼ºå¤±æ•°æ®æ˜¯æŒ‡ç¼ºå¤±æŸäº›ç‰¹å¾æ•°æ®ï¼Œå‘é‡æ•°æ®ä¸å®Œæ•´ã€‚SVM æ²¡æœ‰å¤„ç†ç¼ºå¤±å€¼çš„ç­–ç•¥ã€‚è€Œ SVM å¸Œæœ›æ ·æœ¬åœ¨ç‰¹å¾ç©ºé—´ä¸­çº¿æ€§å¯åˆ†ï¼Œæ‰€ä»¥ç‰¹å¾ç©ºé—´çš„å¥½åå¯¹SVMçš„æ€§èƒ½å¾ˆé‡è¦ã€‚ç¼ºå¤±ç‰¹å¾æ•°æ®å°†å½±å“è®­ç»ƒç»“æžœçš„å¥½åã€‚ SVM æ ¸å‡½æ•°ä¹‹é—´çš„åŒºåˆ«ä¸€èˆ¬é€‰æ‹©çº¿æ€§æ ¸å’Œé«˜æ–¯æ ¸ï¼Œä¹Ÿå°±æ˜¯çº¿æ€§æ ¸ä¸Ž RBF æ ¸ã€‚ çº¿æ€§æ ¸ï¼šä¸»è¦ç”¨äºŽçº¿æ€§å¯åˆ†çš„æƒ…å½¢ï¼Œå‚æ•°å°‘ï¼Œé€Ÿåº¦å¿«ï¼Œå¯¹äºŽä¸€èˆ¬æ•°æ®ï¼Œåˆ†ç±»æ•ˆæžœå·²ç»å¾ˆç†æƒ³äº†ã€‚ RBF æ ¸ï¼šä¸»è¦ç”¨äºŽçº¿æ€§ä¸å¯åˆ†çš„æƒ…å½¢ï¼Œå‚æ•°å¤šï¼Œåˆ†ç±»ç»“æžœéžå¸¸ä¾èµ–äºŽå‚æ•°ã€‚æœ‰å¾ˆå¤šäººæ˜¯é€šè¿‡è®­ç»ƒæ•°æ®çš„äº¤å‰éªŒè¯æ¥å¯»æ‰¾åˆé€‚çš„å‚æ•°ï¼Œä¸è¿‡è¿™ä¸ªè¿‡ç¨‹æ¯”è¾ƒè€—æ—¶ã€‚ å¦‚æžœ Feature çš„æ•°é‡å¾ˆå¤§ï¼Œè·Ÿæ ·æœ¬æ•°é‡å·®ä¸å¤šï¼Œè¿™æ—¶å€™é€‰ç”¨çº¿æ€§æ ¸çš„ SVMã€‚ å¦‚æžœ Feature çš„æ•°é‡æ¯”è¾ƒå°ï¼Œæ ·æœ¬æ•°é‡ä¸€èˆ¬ï¼Œä¸ç®—å¤§ä¹Ÿä¸ç®—å°ï¼Œé€‰ç”¨é«˜æ–¯æ ¸çš„ SVMã€‚ ä»¥ä¸Šæ˜¯å‡ ä¸ªé—®é¢˜åœ¨é¢è¯•ä¸­é‡åˆ° SVM ç®—æ³•æ—¶ï¼Œå‡ ä¹Žæ˜¯å¿…é—®çš„é—®é¢˜ï¼Œå¦å¤–ï¼Œå¤§å®¶ä¸€å®šè¦åšåˆ°è‡ªå·±å¯ä»¥æŽ¨å¯¼é›†åˆé—´éš”ã€å‡½æ•°é—´éš”ä»¥åŠå¯¹å¶å‡½æ•°ï¼Œå¹¶ä¸”ç†è§£å¯¹å¶å‡½æ•°çš„å¼•å…¥å¯¹è®¡ç®—å¸¦æ¥çš„ä¼˜åŠ¿ã€‚ æ”¯æŒå‘é‡ å¦‚å›¾æ‰€ç¤ºï¼Œä¸Šé¢åªæœ‰ä¸‰ä¸ªç‚¹ä¸Žæ±‚è§£çš„ä¼˜åŒ–é—®é¢˜æœ‰å…³ï¼Œå®ƒä»¬å°±å«åšæ”¯æŒå‘é‡ã€‚ SVMå…¬å¼æŽ¨å¯¼(çº¿æ€§å¯åˆ†æ¡ä»¶ä¸‹)å‡å®šæ ·æœ¬ç©ºé—´å¦‚ä¸‹$${ ( x _ { 1 } , y _ { 1 } ) , ( x _ { 2 } , y _ { 2 } ) , \ldots , ( x _ { N } , y _ { N } ) }$$ å…±æœ‰Nä¸ªå‘é‡ï¼Œå…¶ä¸­$x_k$æ˜¯ä¸€ä¸ªç‰¹å¾å‘é‡è€Œä¸æ˜¯ä¸€ä¸ªå•ä¸€æ•°å€¼ã€‚ å‡è®¾è¶…å¹³é¢èƒ½å¤Ÿå°†è®­ç»ƒæ ·æœ¬æ­£ç¡®åˆ†ç±»ï¼Œé‚£ä¹ˆå°±æœ‰ä»¥ä¸‹çš„å¼å­æˆç«‹ï¼š è¿™æ˜¯ä¸€ä¸ªäºŒåˆ†ç±»é—®é¢˜ï¼Œæ‰€ä»¥$y=+1 $æˆ–è€…$ y=âˆ’1$ã€‚é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥å¾—åˆ° $$ y = \begin{cases}+1 &amp; w^Tx +b &gt; 0 \\-1 &amp; w^Tx +b &lt;0\end{cases}$$ ä¸Šé¢æ˜¯é€»è¾‘å›žå½’çš„æ€è·¯ï¼Œæ²¡æœ‰ä¸€ç‚¹çš„ç¼“å†²ä½™åœ°ã€‚å¦‚å®žSVM ä½¿ç”¨ä¸‹é¢çš„åˆ¤åˆ«å¼ï¼š $$ y = \begin{cases}+1 &amp; w^Tx +b &gt;= +1 \\-1 &amp; w^Tx +b &lt;= -1\end{cases}$$ ä¸Šé¢è·ç¦»è¶…å¹³é¢æœ€è¿‘çš„å‡ ä¸ªè®­ç»ƒæ ·æœ¬ç‚¹ä½¿ä¸Šå¼çš„ç­‰å·æˆç«‹ï¼Œè¿™å‡ ä¸ªè®­ç»ƒæ ·æœ¬è¢«ç§°ä¸ºæ”¯æŒå‘é‡ï¼Œä¸¤ä¸ªå¼‚ç±»æ”¯æŒå‘é‡åˆ°è¶…å¹³é¢çš„è·ç¦» é‚£ä¹ˆï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°$$y _ { i } \cdot ( w ^ { T } x _ { i } + b ) \geq 1 , i = 1,2 , \ldots , N$$ å› ä¸ºæˆ‘ä»¬çŽ°åœ¨åªè®¨è®ºçº¿æ€§å¯åˆ†æƒ…å†µä¸‹çš„æ”¯æŒå‘é‡æœºï¼Œé‚£ä¹ˆåœ¨è¿™ä¸ªæ ·æœ¬ç©ºé—´ä¸­ä¸€å®šå­˜åœ¨ä¸€ä¸ªè¶…å¹³é¢å¯ä»¥å°†æ ·æœ¬é›†æŒ‰ç…§yçš„å€¼åˆ†å‰²åŸŽä¸¤ä¸ªéƒ¨åˆ†ï¼Œè¿™ä¸ªè¶…å¹³é¢å¯ä»¥è¡¨ç¤ºä¸º$$w ^ { T } x + b = 0$$ æ ¹æ®è¿™ä¸ªè¶…å¹³é¢çš„è¡¨è¾¾å¼ä»¥åŠç¬¬ä¸€æ­¥æŽ¨åˆ°ä¸­æˆ‘ä»¬å¾—åˆ°çš„ç»“æžœï¼Œå¯ä»¥å¾—åˆ°è¿™ä¸ªæ ·æœ¬é›†ä¸­ä»»æ„ä¸€ä¸ªæ ·æœ¬ç‚¹è·ç¦»è¶…å¹³é¢çš„è·ç¦»ï¼š$$\gamma = \frac { | w ^ { T } x + b | } { | w | } \geq \frac { 1 } { | w | }$$ä¸¤ä¸ªå¼‚ç±»æ”¯æŒå‘é‡åˆ°è¶…å¹³é¢çš„è·ç¦»ä¹‹å’Œï¼Œä¹Ÿç§°ä¸ºé—´éš”ï¼Œä¸º $$\gamma = \frac { 2 } { | w | }$$ ç”±æ­¤ï¼Œæ ¹æ®ç¬¬ä¸€æ­¥å’Œç¬¬ä¸‰æ­¥çš„ç»“æžœï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°æœ€åŸºæœ¬çš„ç›®æ ‡å‡½æ•°ï¼š $$\arg \max _ { w , b } \frac { 2 } { | w | } , \text {s.t. } y _ { i } ( w ^ { T } x _ { i } + b ) \geq 1 , i = 1,2 , \ldots , N$$ æˆ‘ä»¬è¿˜å¯ä»¥å¯¹è¿™ä¸ªç›®æ ‡å‡½æ•°è¿›ä¸€æ­¥åšå˜åŒ–ï¼š $$\arg \min _ { w , b } \frac { 1 } { 2 } | w | ^ { 2 }, \text {s.t. } y _ { i } ( w ^ { T } x _ { i } + b ) \geq 1 , i = 1,2 , \ldots , N $$ æˆ‘ä»¬æ— æ³•ç»§ç»­ç›´æŽ¥è¿›è¡Œè®¡ç®—äº†ï¼Œå› æ­¤å¼•å…¥æ‹‰æ ¼æœ—æ—¥ä¹˜å­$$L ( w , b , \alpha ) = \frac { 1 } { 2 } | w | ^ { 2 } + \sum _ { i } \alpha _ { i } [ 1 - y _ { i } ( w ^ { T } x _ { i } + b ) ]$$ å¯¹wå’Œbåˆ†åˆ«æ±‚Lçš„åå¯¼ï¼Œå¹¶ä»¤å…¶åå¯¼æ•°ç­‰äºŽ0ï¼š$$\frac { \partial L } { \partial w } = w - \sum _ { i } \alpha _ { i } y _ { i } x _ { i } = 0 \Rightarrow w = \sum _ { i } \alpha _ { i } y _ { i } x _ { i }$$$$\frac { \partial L } { \partial b } = \sum _ { i } \alpha _ { i } y _ { i } = 0$$ å°†ç¬¬ä¸ƒæ­¥å¾—åˆ°çš„wå’Œbä»£å…¥Lå‡½æ•° è‡³æ­¤ï¼Œæˆ‘ä»¬çš„ç›®æ ‡å‡½æ•°å·²ç»å˜æˆäº†$$\arg \max _ { \alpha } ( \sum _ { i } \alpha _ { i } - \frac { 1 } { 2 } \sum _ { i } \sum _ { j } \alpha _ { i } \alpha _ { j } y _ { i } y _ { j } x _ { i } ^ { T } x _ { j } )$$$$\text { s.t. } \sum _ { i } \alpha _ { i } y _ { i } = 0$$$$\alpha _ { i } \geq 0 , i = 1,2 , \ldots , N$$ ç”¨æ•°å€¼æ–¹æ³•è§£å‡ºÎ±ä»¥åŽï¼Œæˆ‘ä»¬å¸¦å…¥å¼å­ 7å°±å¯ä»¥å¾—åˆ° $$w^ { * } = \sum _ { i } \alpha _ { i } ^ { * } y _ { i } x _ { i }$$ SVMçš„ç‰¹ç‚¹SVMçš„ä¼˜ç‚¹ï¼šå°±æ˜¯å½“å¤§é‡çš„ç‰¹å¾å‡ºçŽ°çš„æ—¶å€™ï¼Œä½¿ç”¨SVM handle large feature spaces; ç„¶è€Œæ­¤æ—¶ LR ä¸æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„é€‰æ‹©ã€‚ SVM can handle large feature spaces which makes them one of the favorite algorithms in text analysis which almost always results in huge number of features where logistic regression is not a very good choice. SVM Pros: Can handle large feature space Can handle non-linear feature interactions Do not rely on entire data SVM Cons: Not very efficient with large number of observations It can be tricky to find appropriate kernel sometimes æ ¸å‡½æ•°çš„ä½œç”¨ï¼š æ ¸å‡½æ•°æ˜¯å°†åŽŸå§‹ç©ºé—´çº¿æ€§ä¸å¯åˆ†ï¼Œæ˜ å°„åˆ°ä¸€ä¸ªé«˜çº¬çš„ç‰¹å¾ç©ºé—´ï¼Œä½¿å¾—æ ·æœ¬åœ¨è¿™ä¸ªç»´åº¦å˜å¾—çº¿æ€§å¯åˆ†ã€‚ æ ¸å‡½æ•°çš„ç§ç±»ï¼š åˆ†ä¸ºçº¿æ€§æ ¸å‡½æ•°å’Œé«˜æ–¯æ ¸å‡½æ•°ã€‚å‰è€…å‚æ•°å°‘ï¼Œè®¡ç®—é‡å°ï¼Œå¦‚æžœæ˜¯ç‰¹å¾æ•°é‡æ¯”è¾ƒå¤§ï¼Œé‚£ä¹ˆæ˜¯å¯ä»¥è€ƒè™‘çº¿æ€§æ ¸å‡½æ•°ï¼›å¦‚æžœç‰¹å¾æ•°é‡æ¯”è¾ƒå°ï¼Œå¯ä»¥è€ƒè™‘é«˜æ–¯æ ¸å‡½æ•°ã€‚ TakeOffé¦–å…ˆä½¿ç”¨ LR è¿›è¡Œå°è¯•ï¼Œä¸å¦¨è¯•ä¸€ä¸‹ DTï¼Œç„¶åŽ å¦‚æžœç‰¹å¾æ¯”è¾ƒå¤šï¼Œä½†æ˜¯æ•°æ®é‡ä¸æ˜¯å¾ˆå¤šï¼Œè¿™ä¸ªæ—¶å€™ä½¿ç”¨SVMã€‚Always start with logistic regression, if nothing then to use the performance as baselineSee if decision trees (Random Forests) provide significant improvement. Even if you do not end up using the resultant model, you can use random forest results to remove noisy variablesGo for SVM if you have large number of features and number of observations are not a limitation for available resources and timeé™„ä¸Šé“¾æŽ¥ï¼šhttps://www.edvancer.in/logistic-regression-vs-decision-trees-vs-svm-part2/]]></content>
      <tags>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NLP Papers Reading-Sentence Embedding]]></title>
    <url>%2F2019%2F06%2F01%2Fnlp-papers-reading-sentence-embedding%2F</url>
    <content type="text"><![CDATA[Why Consider Sentence Embedding?One simple way you could do this is by generating a word embedding for each word in a sentence, adding up all the embeddings and divide by the number of words in the sentence to get an â€œaverageâ€ embedding for the sentence. å¥å­embeddingçš„è¡¨ç¤º = words emebddingï¼Œå¯èƒ½ä½¿ç”¨ TF-IDF or SIF ä½œä¸ºweights è¿›è¡Œä¼˜åŒ–ã€‚ Alternatively, you could use a more advanced method which attempts to add a weighting function to word embeddings which down-weights common words. This latter approach is known as Smooth Inverse Frequency (SIF). These methods can be used as a successful proxy for sentence embeddings. However, this â€œsuccessâ€ depends on the dataset being used and the task you want to execute. So for some tasks these methods could be good enough ä¸Šè¿°æ–¹æ³•çš„ä¸»è¦ç¼ºç‚¹ï¼šè¯­åºï¼›æ–‡å­—åœ¨ä¸Šä¸‹æ–‡ä¸­æ‰æœ‰æ„ä¹‰ï¼›é˜…è¯»ç†è§£ï¼Œä¸åŒçš„å¥å­æ˜¯ç›¸åŒçš„æ„æ€ï¼Œå´å¾—åˆ°ä¸åŒçš„embeddingï¼›ä¾èµ–äºŽå‰æœŸå¤„ç†ï¼Œå¦‚åˆ†è¯ã€‚ However, there are a number of issues with any of these types of approaches: They ignore word ordering. This is obviously problematic. Itâ€™s difficult to capture the semantic meaning of a sentence. The word crash can be used in multiple contexts, e.g. I crashed a party, the stock market crashed, or I crashed my car. Itâ€™s difficult to capture this change of context in a word embedding. Sentence length becomes problematic. With sentences we can chain them together to create a long sentence without saying very much, The Philadelphia Eagles won the Super Bowl, The Washington Post reported that the Philadelphia Eagles won the Super Bowl, The politician claimed it was fake news when the Washington Post reported that the Philadelphia Eagles won the Super Bowl, and so on. All these sentences are essentially saying the same thing but if we just use word embeddings, it can be difficult to discover if they are similar. They introduce extra complexity. When using word embeddings as a proxy for sentence embeddings we often need to take extra steps in conjunction with the base model. For example, we need to remove stop words, get averages, measure sentence length and so on. sentence embeddingçš„åº”ç”¨åœºæ™¯ï¼šSimilar approaches can be used to go beyond representations and semantic search, to document classification and understanding and eventually document summarizing or generation. Words Embedå¹³å‡è¯å‘é‡ä¸ŽTFIDFåŠ æƒå¹³å‡è¯å‘é‡SIFåŠ æƒå¹³å‡è¯å‘é‡æ¥è‡ªè®ºæ–‡ A simple but tough-to-beat baseline for sentence embeddingsï¼Œæ›´å¤šä¿¡æ¯å¯ä»¥å‚è€ƒè¿™é‡Œã€‚åœ¨å¤§å®¶éƒ½ä»Žæ— ç›‘ç£å­¦ä¹ èµ°å‘æœ‰ç›‘ç£å­¦ä¹ çš„æ—¶å€™ï¼Œè¿™ä¸ªæ— ç›‘ç£çš„æ–¹æ³•å’Œç¥žç»ç½‘ç»œçš„æ•ˆæžœæ˜¯æ——é¼“ç›¸å½“çš„ã€‚ åˆ©ç”¨n-grams embeddingfasttext ä»‹ç»ã€‚ç®€å•è¯´ n-gram æ˜¯ä¸€ç§æ¦‚å¿µï¼Œå¯ä»¥ç»†åŒ–æˆä¸¤éƒ¨åˆ†ï¼šcharacter-level å’Œword-levelï¼Œå‰è€…æ˜¯å¯ä»¥ç”¨æ¥è¡¥å……è¯æ±‡ï¼ŒåŠ å¼ºå¯¹äºŽä¸å¸¸è§è¯çš„è¡¨ç¤ºèƒ½åŠ›ï¼ŒåŽè€…æ˜¯å¯¹äºŽè¯åºçš„è¡¥å……ã€‚ DANï¼ˆDeep Unordered Composition Rivals Syntactic Methods for Text Classificationï¼‰å…¶å®žDAN(Deep Averaging Networks)åº”è¯¥å±žäºŽBag of Wordsç±»çš„ç®—æ³•ã€‚å› ä¸ºæ¯”è¾ƒç‰¹æ®Šï¼Œå•ç‹¬åˆ—å‡ºæ¥ã€‚ å®ƒæ˜¯åœ¨å¯¹æ‰€æœ‰è¯è¯­å–å¹³å‡åŽï¼Œåœ¨ä¸Šé¢åŠ ä¸Šå‡ å±‚ç¥žç»ç½‘ç»œã€‚ç‰¹æ®Šçš„åœ°æ–¹åœ¨äºŽå®ƒåœ¨sentiment analysisä¸­è¡¨çŽ°ä¹Ÿä¸é”™ï¼Œè¿™åœ¨BOWç±»æ–¹æ³•ä¸­æ¯”è¾ƒç½•è§ã€‚ æ–‡ä¸­æå‡ºäº†DAN(Deep average network)ï¼Œè¯´ç™½äº†å°±æ˜¯å¯¹äºŽä¸€ä¸ªå¥å­æˆ–è€…ä¸€ä¸ªæ®µè½ï¼ŒæŠŠæ¯ä¸ªå•è¯çš„embeddingè¿›è¡Œå¹³å‡æ±‚å’Œï¼Œå¾—åˆ°ç¬¬ä¸€å±‚å›ºå®šç»´åº¦çš„å‘é‡ï¼Œç„¶åŽåœ¨å¥—å‡ å±‚å…¨è¿žæŽ¥ç¥žç»ç½‘ç»œã€‚æœ¬è´¨æ¥è®²ï¼Œè¿™ä¸ªæ¨¡åž‹æ²¡æœ‰è€ƒè™‘å•è¯ä¹‹é—´çš„é¡ºåºï¼Œnotåœ¨ç¬¬ä¸€ä¸ªä½ç½®å’Œåœ¨æœ€åŽä¸€ä¸ªä½ç½®å¯¹äºŽDANæ¥è®²è¾“å…¥éƒ½æ˜¯ä¸€æ ·çš„ï¼Œæ‰€ä»¥è‡ªç„¶converä¸ä½è¿™ç§æƒ…å†µã€‚è¿™æ˜¯æ¨¡åž‹æœ¬èº«çš„é—®é¢˜ï¼Œæ²¡æœ‰åŠžæ³•æ”¹è¿›ï¼Œé™¤éžæ¢æ¨¡åž‹ï¼Œæ¯”å¦‚textcnnå°±èƒ½å¾ˆå¥½çš„è§£å†³è¿™ç§æƒ…å†µå¯¹äºŽå¦å®šè¯æ•æ„Ÿï¼Œæ¯”å¦‚but,notç­‰ï¼Œå¸¸å¸¸åˆ¤æ–­ä¸ºnegativeã€‚è®­ç»ƒé€Ÿåº¦å¿«ï¼Œä¸”ç»“æžœè¾ƒå¥½ï¼Œå’ŒSyntactic Compositionæ€§èƒ½å·®ä¸å¤šï¼Œä½†æ˜¯æ¶ˆè€—çš„è®¡ç®—èµ„æºå°‘ä½œä¸ºæœ‰ç›‘ç£å­¦ä¹ ä»»åŠ¡æ¥è®²ï¼Œå¯ä»¥è¯•ä¸€è¯•ã€‚ä½†æ˜¯ç”±äºŽå…¨è¿žæŽ¥å±‚ï¼Œæ— æ³•è¿›è¡Œæ— ç›‘ç£å­¦ä¹ ã€‚ç›¸åï¼ŒNBOWå¯ä»¥æ— ç›‘ç£å­¦ä¹ ï¼Œæ¯”å¦‚æ–‡æœ¬ç›¸ä¼¼åº¦è®¡ç®—ç­‰ã€‚å½“ç„¶ã€‚å¯¹äºŽDANè€Œè¨€ï¼Œå¯ä»¥é€šè¿‡è¿ç§»å­¦ä¹ ï¼Œé¢„è®­ç»ƒå¥½å…¨è¿žæŽ¥å‚æ•°ï¼Œå®žçŽ°æ— ç›‘ç£å­¦ä¹  æ€»ç»“ä¸€ä¸‹ï¼šå¯¹ç®€å•çš„ä»»åŠ¡æ¥è¯´ï¼Œç”¨ç®€å•çš„ç½‘ç»œç»“æž„è¿›è¡Œå¤„ç†åŸºæœ¬å°±å¤Ÿäº†ï¼Œä½†æ˜¯å¯¹æ¯”è¾ƒå¤æ‚çš„ä»»åŠ¡ï¼Œè¿˜æ˜¯ä¾ç„¶éœ€è¦æ›´å¤æ‚çš„ç½‘ç»œç»“æž„æ¥å­¦ä¹ sentence representationçš„ã€‚ Unsupervised Sentence EmbedåŸºäºŽEncoder-decoderçš„Skip-Thought Vectorsskip-thoughts ä¸­æåŠä¸€ä¸ªé‡è¦çš„æ–¹æ³•æ˜¯ è¯æ±‡æ‰©å±•ã€‚å…·ä½“æ¥è¯´æˆ‘ä»¬å¯ä»¥å…ˆç”¨æµ·é‡çš„è¯­æ–™è®­ç»ƒä¸€ä¸ªWord2Vecï¼Œè¿™æ ·å¯ä»¥æŠŠä¸€ä¸ªè¯æ˜ å°„åˆ°ä¸€ä¸ªè¯­ä¹‰ç©ºé—´ï¼Œæˆ‘ä»¬æŠŠè¿™ä¸ªå‘é‡å«åš $ V_{w 2 v} $ã€‚è€Œæˆ‘ä»¬ä¹‹å‰è®­ç»ƒçš„å¾—åˆ°çš„è¾“å…¥å‘é‡ä¹Ÿæ˜¯æŠŠä¸€ä¸ªè¯æ˜ å°„åˆ°å¦å¤–ä¸€ä¸ªè¯­ä¹‰ç©ºé—´ï¼Œæˆ‘ä»¬è®°ä½œ$V_{r n n}$. æˆ‘ä»¬å‡è®¾å®ƒä»¬ä¹‹é—´å­˜åœ¨ä¸€ä¸ªçº¿æ€§å˜æ¢$ f: V_{w 2 v} \rightarrow V_{r n n}$ã€‚è¿™ä¸ªçº¿æ€§å˜æ¢çš„å‚æ•°æ˜¯çŸ©é˜µWï¼Œä½¿å¾—$V_{r n n}$= $W V_{w 2 v} $ã€‚é‚£æ€Žä¹ˆæ±‚è¿™ä¸ªå˜æ¢çŸ©é˜µWå‘¢ï¼Ÿå› ä¸ºä¸¤ä¸ªè®­ç»ƒè¯­æ–™ä¼šæœ‰å…¬å…±çš„è¯(é€šå¸¸è®­ç»ƒword2vecçš„è¯­æ–™æ¯”skip vectorå¤§å¾—å¤šï¼Œä»Žè€Œè¯ä¹Ÿå¤šå¾—å¤š)ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥ç”¨è¿™äº›å…¬å…±çš„è¯æ¥å¯»æ‰¾ $W$ã€‚å¯»æ‰¾çš„ä¾æ®æ˜¯ï¼šéåŽ†æ‰€æœ‰å¯èƒ½çš„Wï¼Œä½¿å¾—$ W V_{w 2 v} $å’Œ$V_{rnn}$å°½é‡æŽ¥è¿‘ã€‚ å¯¹äºŽåŒå‘è®­ç»ƒï¼ˆä¸æ˜¯ä½¿ç”¨äº†ä¸¤ä¸ªæ¨¡åž‹ï¼Œè€Œæ˜¯ä½¿ç”¨æ­£åä¸¤ç§ä¸åŒé¡ºåºä¸åŒçš„è®­ç»ƒæ•°æ®é›†ï¼‰æ­¤å¤–è¿˜è®­ç»ƒäº†bi-skipå‘é‡ï¼Œå®ƒæ˜¯è¿™æ ·å¾—åˆ°çš„ï¼šé¦–å…ˆè®­ç»ƒ1200ç»´çš„uni-skipï¼Œç„¶åŽå¥å­å€’è¿‡æ¥ï¼Œæ¯”å¦‚åŽŸæ¥æ˜¯â€aa bbâ€ã€â€cc ddâ€å’Œâ€ee ffâ€ï¼Œæˆ‘ä»¬æ˜¯ç”¨â€cc ddâ€æ¥é¢„æµ‹â€aa bbâ€ä»¥åŠâ€ee ffâ€ï¼ŒçŽ°åœ¨åè¿‡æ¥å˜æˆâ€ff eeâ€ã€â€dd ccâ€å’Œâ€bb aaâ€ã€‚è¿™æ ·ä¹Ÿå¯ä»¥è®­ç»ƒä¸€ä¸ªæ¨¡åž‹ï¼Œå½“ç„¶ä¹Ÿå°±å¾—åˆ°ä¸€ä¸ªencoder(ä¸¤ä¸ªdecoderä¸éœ€è¦äº†)ï¼Œç»™å®šä¸€ä¸ªå¥å­æˆ‘ä»¬æŠŠå®ƒå€’è¿‡æ¥ç„¶åŽä¹Ÿç¼–ç æˆ1200ä¸ºçš„å‘é‡ï¼Œæœ€åŽæŠŠè¿™ä¸ªä¸¤ä¸ª1200ç»´çš„å‘é‡æ‹¼æŽ¥æˆ2400ç»´çš„å‘é‡ã€‚ æ¨¡åž‹è®­ç»ƒå®Œæˆä¹‹åŽè¿˜éœ€è¦è¿›è¡Œè¯æ±‡æ‰©å±•ã€‚é€šè¿‡BookCorpuså­¦ä¹ åˆ°äº†20,000ä¸ªè¯ï¼Œè€Œword2vecå…±é€‰æ‹©äº†930,911è¯ï¼Œé€šè¿‡å®ƒä»¬å…±åŒçš„è¯å­¦ä¹ å‡ºå˜æ¢çŸ©é˜µWï¼Œä»Žè€Œä½¿å¾—æˆ‘ä»¬çš„Skip Thought Vectorå¯ä»¥å¤„ç†930,911ä¸ªè¯ã€‚ï¼ˆæœ€ç»ˆå¾—åˆ°è¿˜æ˜¯è¯­è¨€æ¨¡åž‹ï¼‰ è¿™ç¯‡è®ºæ–‡ä¸­çš„è¦ç‚¹ è®­ç»ƒçš„æ—¶å€™åœ¨è¿œå¤§äºŽ word2vec çš„è®­ç»ƒé›†ä¸Šå±•å¼€ã€‚å¦‚ skip-thought ä¸­ä½¿ç”¨çš„ BookCorpus æ•°æ®é›†ä¸­æ˜¯åƒä¸‡çº§åˆ«çš„ words(984,846,357)ï¼Œåœ¨word2vec ä¸­è‹±æ–‡çš„ wikicorpus æ˜¯ç™¾ä¸‡ (120 million words)ï¼Œ æ‰€ä»¥ç›¸å·®ä¸€ä¸ªæ•°é‡çº§ã€‚ objective function æ˜¯è¯­è¨€æ¨¡åž‹ï¼ˆç±»ä¼¼ machine translation), ç»™å®šä¸Šä¸‹ä¸€ä¸ªå¥å­ï¼Œç„¶åŽé¢„æµ‹ä¸­å¿ƒå¥å­çš„æ¦‚çŽ‡ï¼Œä¸æ–­çš„æœ€å¤§åŒ–çš„è¿‡ç¨‹ã€‚ è¯æ±‡æ‰©å±•ï¼Œä½¿ç”¨äº†ä¸€ä¸ªword2vec ä¸­çš„embedding è¡¥å……åœ¨è®­ç»ƒæ•°æ®é›†ä¸­æ²¡æœ‰å‡ºçŽ°è¿‡çš„ wordï¼Œä»Žword2vec ä¸­çš„word åˆ°è¯¥æ¨¡åž‹ä¸­çš„ word embedding æ˜¯å­¦ä¹ äº†ä¸€ä¸ªmatrixï¼Œè½¬æ¢å…³ç³»ã€‚ç¼“è§£äº†oov é—®é¢˜ï¼›å…³äºŽoov é—®é¢˜ï¼Œå¥å­çš„ç›¸ä¼¼åº¦ä¸æ˜¯exactçš„ç›¸ä¼¼ï¼Œè€Œæ˜¯ä¸€ç§ åœ¨è¯­æ³•å’Œè¯­ä¹‰ä¸Šçš„è¿‘ä¼¼ç›¸ä¼¼ã€‚ Continuing the tour of older papers that started with our ResNet blog post, we now take on Skip-Thought Vectors by Kiros et al. Their goal was to come up with a useful embedding for sentences that was not tuned for a single task and did not require labeled data to train. They took inspiration from Word2Vec skip-gram (you can find my explanation of that algorithm here) and attempt to extend it to sentences. Changing a single word has had almost no effect on the meaning of that sentence. To account for these word level changes, the skip-thought model needs to be able to handle a large variety of words, some of which were not present in the training sentences. The authors solve this by using a pre-trained continuous bag-of-words (CBOW) Word2Vec model and learning a translation from the Word2Vec vectors to the word vectors in their sentences. Below are shown the nearest neighbor words after the vocabulary expansion using query words that do not appear in the training vocabulary: è®ºæ–‡æè¿°äº†ä¸€ç§é€šç”¨ã€åˆ†å¸ƒå¼å¥å­ç¼–ç å™¨çš„æ— ç›‘ç£å­¦ä¹ æ–¹æ³•ã€‚ä½¿ç”¨ä»Žä¹¦ç±ä¸­æå–çš„è¿žç»­æ–‡æœ¬ï¼Œè®­ç»ƒäº†ä¸€ä¸ªç¼–ç å™¨-è§£ç å™¨æ¨¡åž‹ï¼Œå€Ÿé‰´äº†word2vecä¸­skip-gramæ¨¡åž‹ï¼Œé€šè¿‡ä¸€å¥è¯æ¥é¢„æµ‹è¿™å¥è¯çš„ä¸Šä¸€å¥å’Œä¸‹ä¸€å¥ã€‚è¯­ä¹‰å’Œè¯­æ³•å±žæ€§ä¸€è‡´çš„å¥å­è¢«æ˜ å°„åˆ°ç›¸ä¼¼çš„å‘é‡è¡¨ç¤ºã€‚æŽ¥ç€å¼•å…¥ä¸€ä¸ªç®€å•çš„è¯æ±‡æ‰©å±•æ–¹æ³•æ¥ç¼–ç ä¸å†è®­ç»ƒé›†å†…çš„å•è¯ï¼Œä»¤è¯æ±‡é‡æ‰©å±•åˆ°ä¸€ç™¾ä¸‡è¯ã€‚æœ¬æ–‡çš„æ¨¡åž‹è¢«ç§°ä¸ºskip-thoughtsï¼Œç”Ÿæˆçš„å‘é‡ç§°ä¸ºskip-thought vectorã€‚æ¨¡åž‹é‡‡ç”¨äº†å½“ä¸‹æµè¡Œçš„ç«¯åˆ°ç«¯æ¡†æž¶ï¼Œé€šè¿‡æœé›†äº†å¤§é‡çš„å°è¯´ä½œä¸ºè®­ç»ƒæ•°æ®é›†ï¼Œå°†å¾—åˆ°çš„æ¨¡åž‹ä¸­encoderéƒ¨åˆ†ä½œä¸ºfeature extractorï¼Œå¯ä»¥ç»™ä»»æ„å¥å­ç”Ÿæˆvectorã€‚ skip-thoughtæ¨¡åž‹ç»“æž„å€ŸåŠ©äº†skip-gramçš„æ€æƒ³ã€‚åœ¨skip-gramä¸­ï¼Œæ˜¯ä»¥ä¸­å¿ƒè¯æ¥é¢„æµ‹ä¸Šä¸‹æ–‡çš„è¯ï¼›åœ¨skip-thoughtåŒæ ·æ˜¯åˆ©ç”¨ä¸­å¿ƒå¥å­æ¥é¢„æµ‹ä¸Šä¸‹æ–‡çš„å¥å­ã€‚ è®ºæ–‡é‡‡ç”¨äº†GRU-RNNä½œä¸ºencoderå’Œdecoderï¼Œencoderéƒ¨åˆ†çš„æœ€åŽä¸€ä¸ªè¯çš„hiddenstateä½œä¸ºdecoderçš„è¾“å…¥æ¥ç”Ÿæˆè¯ã€‚è¿™é‡Œç”¨çš„æ˜¯æœ€ç®€å•çš„ç½‘ç»œç»“æž„ï¼Œå¹¶æ²¡æœ‰è€ƒè™‘å¤æ‚çš„å¤šå±‚ç½‘ç»œã€åŒå‘ç½‘ç»œç­‰æå‡æ•ˆæžœã€‚decoderéƒ¨åˆ†ä¹Ÿåªæ˜¯ä¸€ä¸ªè€ƒè™‘äº†encoder last hidden stateçš„è¯­è¨€æ¨¡åž‹ï¼Œå¹¶æ— å…¶ä»–ç‰¹æ®Šä¹‹å¤„ï¼Œåªæ˜¯æœ‰ä¸¤ä¸ªdecoderï¼Œæ˜¯ä¸€ä¸ªone maps twoçš„æƒ…å†µï¼Œä½†è®¡ç®—æ–¹æ³•ä¸€æ ·ã€‚æ¨¡åž‹ä¸­çš„ç›®æ ‡å‡½æ•°ä¹Ÿæ˜¯ä¸¤ä¸ªéƒ¨åˆ†ï¼Œä¸€ä¸ªæ¥è‡ªäºŽé¢„æµ‹ä¸‹ä¸€å¥ï¼Œä¸€ä¸ªæ¥è‡ªäºŽé¢„æµ‹ä¸Šä¸€å¥ã€‚ ä¼ è¯´ä¸­çš„ objective function or loss function æ˜¯ä¸‹é¢è¿™ä¸ªæ ·å­ï¼š æˆ‘ä»¬å°†æž„é€ ä¸€ä¸ªç±»ä¼¼äºŽè‡ªç¼–ç å™¨çš„åºåˆ—åˆ°åºåˆ—ç»“æž„ï¼Œä½†æ˜¯å®ƒä¸Žè‡ªç¼–ç å™¨æœ‰ä¸¤ä¸ªä¸»è¦çš„åŒºåˆ«ã€‚ç¬¬ä¸€ï¼Œæˆ‘ä»¬æœ‰ä¸¤ä¸ª LSTM è¾“å‡ºå±‚ï¼šä¸€ä¸ªç”¨äºŽä¹‹å‰çš„å¥å­ï¼Œä¸€ä¸ªç”¨äºŽä¸‹ä¸€ä¸ªå¥å­ï¼›ç¬¬äºŒï¼Œæˆ‘ä»¬ä¼šåœ¨è¾“å‡º LSTM ä¸­ä½¿ç”¨æ•™å¸ˆå¼ºè¿«ï¼ˆteacher forcingï¼‰ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬ä¸ä»…ä»…ç»™è¾“å‡º LSTM æä¾›äº†ä¹‹å‰çš„éšè—çŠ¶æ€ï¼Œè¿˜æä¾›äº†å®žé™…çš„å‰ä¸€ä¸ªå•è¯ã€‚ çœ‹ä¸ŠåŽ»ï¼ŒSkip-thoughtå’ŒSkip-gramæŒºè±¡ã€‚å”¯ä¸€çš„é—æ†¾æ˜¯Skip-thoughtçš„decoderé‚£éƒ¨åˆ†ï¼Œå®ƒæ˜¯ä½œä¸ºlanguage modelingæ¥å¤„ç†çš„. ä»Žè¿™é‡Œçš„è®²è§£çŸ¥é“è¿™ä¸ªæ˜¯ä¸å­˜åœ¨ â€æ­£è´Ÿâ€œæ ·æœ¬çš„ï¼Œ è¿™ä¸ªçš„æŸå¤±å‡½æ•°æ˜¯ æ­£ç¡®çš„ä¸Šä¸‹å¥å’Œç”Ÿæˆçš„ä¸Šä¸‹å¥ä¹‹é—´çš„reconstruction errorã€‚ The end product of Skip-Thoughts is the Encoder. The Decoders are thrown away after training. The trained encoder can then be used to generate fixed length representations of sentences which can be used for several downstream tasks such as sentiment classification, semantic similarity, etc. The encoder utilises a word embedding layer that serves as a look up table. This converts each word in the input sentence to its corresponding word embedding, effectively converting the input sentence into a sequence of word embeddings. This embedding layer is also shared with both of the decoders. The model is then trained to minimise the reconstruction error of the previous and next sentences using the resulting embedding h(i) generated from sentence s(i) after it is passed through the encoder. Back propagating the reconstruction error from the decoder allows the encoder to learn the best representation of the input sentence while capturing the relation between itself and the surrounding sentences.Skip-Thoughts is designed to be a sentence encoder and the result is that the decoders are actually discarded after the training process. The encoder along with the word embedding layer is used as a feature extractor able to encode new sentences that are fed through it. Using cosine similarity on the resulting encoded sentence embeddings, provides a powerful semantic similarity mechanism, where you can measure how closely two sentences relate in terms of meaning as well as syntax. Encoder Network: The encoder is typically a GRU-RNN which generates a fixed length vector representation h(i) for each sentence S(i) in the input. The encoded representation h(i) is obtained by passing final hidden state of the GRU cell (i.e. after it has seen the entire sentence) to multiple dense layers. Decoder Network: The decoder network takes this vector representation h(i) as input and tries to generate two sentences â€” S(i-1) and S(i+1), which could occur before and after the input sentence respectively. Separate decoders are implemented for generation of previous and next sentences, both being GRU-RNNs. The vector representation h(i) acts as the initial hidden state for the GRUs of the decoder networks. è¯æ±‡æ‰©å±• å½“åˆæœ‰ä¸ªé¢è¯•å®˜é—®é“çš„è®­ç»ƒæ ·æœ¬ä¸è¶³çš„é—®é¢˜ï¼ŒçŽ°åœ¨ç»™å‡ºç­”æ¡ˆï¼Œä¸€ç§æ˜¯å¤§é‡çš„æ•°æ®é›†ï¼Œå› ä¸ºè¿™ä¸ªæ˜¯æ— ç›‘ç£çš„å­¦ä¹ ï¼Œä¸éœ€è¦æ ‡ç­¾ï¼Œæ‰€ä»¥ä½¿ç”¨äº†å¤§é‡çš„å°è¯´ä½œä¸ºè®­ç»ƒé›†ï¼›å¯¹äºŽç›¸ä¼¼å¥å­çš„å®šä¹‰ï¼Œä¸æ˜¯ exactçš„ç›¸ä¼¼ï¼Œåªè¦åœ¨è¯­æ³•æˆ–è€…è¯­ä¹‰ä¸Šç›¸ä¼¼ï¼Œé‚£ä¹ˆè¿™ä¸ªå°±å¯ä»¥çœ‹åšç›¸åŒçš„æ ·æœ¬ï¼›ç„¶åŽè¿˜ä½¿ç”¨äº† é¢„è®­ç»ƒçš„ æ¨¡åž‹è¿›è¡Œ vocabulary ä¸­è¯æ±‡çš„è¡¥å……ã€‚ ä½œè€…åœ¨è®­ç»ƒå®Œè¿‡åŽç”¨åœ¨Google News datasetä¸Šé¢„è®­ç»ƒçš„æ¨¡åž‹å¯¹Vocabularyè¿›è¡Œäº†è¯æ±‡æ‰©å±•ä¸»è¦æ˜¯ä¸ºäº†å¼¥è¡¥æˆ‘ä»¬çš„ Decoder æ¨¡åž‹ä¸­è¯æ±‡ä¸è¶³çš„é—®é¢˜ã€‚å…·ä½“çš„åšæ³•å°±æ˜¯ï¼š(from https://www.cnblogs.com/jiangxinyang/p/9638991.html) è¯¥æ€è·¯å€Ÿé‰´äºŽTomas Mikolovçš„ä¸€ç¯‡æ–‡ç« Exploiting Similarities among Languages for Machine Translationä¸­è§£å†³æœºå™¨ç¿»è¯‘missing wordsé—®é¢˜çš„æ€è·¯ï¼Œå¯¹è®­ç»ƒé›†äº§ç”Ÿçš„è¯æ±‡è¡¨V(RNN)è¿›è¡Œäº†æ‰©å±•ï¼Œå…·ä½“çš„æ€è·¯å¯å‚è€ƒMikolovçš„æ–‡ç« ï¼Œè¾¾åˆ°çš„æ•ˆæžœæ˜¯å»ºç«‹äº†å¤§æ•°æ®é›†ä¸‹V(Word2Vec)å’Œæœ¬æ–‡V(RNN)ä¹‹é—´çš„æ˜ å°„ï¼ŒV(Word2Vec)çš„è§„æ¨¡è¿œè¿œå¤§äºŽV(RNN)ï¼Œè®ºæ–‡ä¸­V(RNN)åŒ…æ‹¬äº†20000ä¸ªè¯ï¼ŒV(Word2Vec)åŒ…æ‹¬äº†930000å¤šä¸ªè¯ï¼ŒæˆåŠŸåœ°è§£å†³äº†è¿™ä¸€é—®é¢˜ï¼Œä½¿å¾—æœ¬æ–‡æå‡ºçš„æ— ç›‘ç£æ¨¡åž‹æœ‰å¤§çš„åº”ç”¨ä»·å€¼ã€‚ è¯„ä»·è§‚ç‚¹è¿™ä¸ªæ–¹æ³•åªæ˜¯é€‚ç”¨äºŽé•¿æ–‡æœ¬ï¼Œè¦æ±‚æ˜¯è‡³å°‘æœ‰ä¸¤ä¸ªè¡”æŽ¥çš„å¥å­ï¼Œæ€æƒ³å’Œskip-gram æ¯”è¾ƒç›¸è¿‘ã€‚ æºç google çš„å®žçŽ°ä½œè€…çš„å®žçŽ°è®ºæ–‡ Quick-Thought vectorsintuition: åŸºäºŽç”Ÿæˆçš„modelï¼Œ the models are trained to reconstruct the surface form of a sentence, but sometimes words are irrelevant to the meaning of the sentence as well ç”Ÿæˆæ¨¡åž‹çš„è®¡ç®—æˆæœ¬æ¯”è¾ƒé«˜ï¼Œ è€Œæ–‡ä¸­çš„æ¨¡åž‹æ˜¯ä¸€ç§åˆ¤åˆ«æ¨¡åž‹ï¼Œæ‰€ä»¥ä»ŽåŽŸç†ä¸Šè¿™ç§è®¡ç®—çš„æ•ˆçŽ‡å°±è¿œè¿œé«˜äºŽç”Ÿæˆæ¨¡åž‹ã€‚ Viewing generation as choosing a sentence from all possible sentences, this can be seen as a discriminative approximation to the generation problem. åœ¨å®žè·µä¸­ç»éªŒä¹‹è°ˆï¼Œ ä¸æ˜¯è¦æ±‚åˆ†ç±»å™¨åŽ»åˆ¤åˆ« positive / negative, åªæ˜¯è¦æ±‚åˆ†ç±»å™¨å¯¹äºŽ ground-truth contexts than contrastive contexts more plausibleã€‚è¿™ä¸ªæ¯”å‰è€…åœ¨å®žéªŒç»“æžœä¸Šæ˜¯å¥½çš„ã€‚ è®ºæ–‡ä¸­çš„ä¸€äº›è§‚ç‚¹ï¼šencoder-decoder based sequence models è™½ç„¶æ•ˆæžœå¥½ï¼Œä½†æ˜¯ slow to train on large amounts of data. å¦ä¸€æ–¹é¢, bag-of-words è™½ç„¶é«˜æ•ˆï¼Œä½†æ˜¯æ— æ³•æ•æ‰åˆ° word order ä¿¡æ¯ã€‚ 2018å¹´å‘è¡¨çš„è®ºæ–‡An efficient framework for learning sentence representationsæå‡ºäº†ä¸€ç§ç®€å•ä¸”æœ‰æ•ˆçš„æ¡†æž¶ç”¨äºŽå­¦ä¹ å¥å­è¡¨ç¤ºã€‚å’Œå¸¸è§„çš„ç¼–ç è§£ç ç±»æ¨¡åž‹ï¼ˆå¦‚skip-thoughtså’ŒSDAEï¼‰ä¸åŒçš„æ˜¯ï¼Œæœ¬æ–‡é‡‡ç”¨ä¸€ç§åˆ†ç±»å™¨çš„æ–¹å¼å­¦ä¹ å¥å­è¡¨ç¤ºã€‚å…·ä½“åœ°ï¼Œæ¨¡åž‹çš„è¾“å…¥ä¸ºä¸€ä¸ªå¥å­$s$ä»¥åŠä¸€ä¸ªå€™é€‰å¥å­é›†åˆ$S_{cand}$ï¼Œå…¶ä¸­$S_{cand}$åŒ…å«ä¸€ä¸ªå¥å­$s_{ctxt}$æ˜¯$s$çš„ä¸Šä¸‹æ–‡å¥å­ï¼ˆä¹Ÿå°±æ˜¯$s $)çš„å‰ä¸€ä¸ªå¥å­æˆ–åŽä¸€ä¸ªå¥å­ï¼‰ä»¥åŠå…¶ä»–ä¸æ˜¯$s$ä¸Šä¸‹æ–‡çš„å¥å­ã€‚æ¨¡åž‹é€šè¿‡å¯¹$s$ä»¥åŠ$S_{cand}$ä¸­çš„æ¯ä¸ªå¥å­è¿›è¡Œç¼–ç ï¼Œç„¶åŽè¾“å…¥åˆ°ä¸€ä¸ªåˆ†ç±»å™¨ä¸­ï¼Œè®©åˆ†ç±»å™¨é€‰å‡º$S_{cand}$ä¸­çš„å“ªä¸ªå¥å­æ˜¯$s_{ctxt}$ã€‚å®žéªŒè®¾ç½®å€™é€‰å¥å­é›†åˆå¤§å°ä¸º3ï¼Œå³$S_{cand}$åŒ…å«1ä¸ªä¸Šä¸‹æ–‡å¥å­å’Œä¸¤ä¸ªæ— å…³å¥å­ã€‚æ¨¡åž‹ç»“æž„å¦‚ä¸‹ï¼š æ¨¡åž‹æœ‰å¦‚ä¸‹ä¸¤ä¸ªç»†èŠ‚éœ€è¦æ³¨æ„ï¼šæ¨¡åž‹ä½¿ç”¨çš„åˆ†ç±»å™¨ï¼ˆå¾—åˆ†å‡½æ•°ï¼‰$c$éžå¸¸ç®€å•ï¼Œæ˜¯ä¸¤ä¸ªå‘é‡å†…ç§¯ï¼Œå³$c(u, v)=u^Tv$ï¼Œè®¡ç®—$s$çš„embeddingä¸Žæ‰€æœ‰$S_{cand}$ä¸­çš„å¥å­å‘é‡å†…ç§¯å¾—åˆ†åŽï¼Œè¾“å…¥åˆ°softmaxå±‚è¿›è¡Œåˆ†ç±»ã€‚ä½¿ç”¨ç®€å•åˆ†ç±»å™¨æ˜¯ä¸ºäº†å¼•å¯¼æ¨¡åž‹ç€é‡è®­ç»ƒå¥å­ç¼–ç å™¨ï¼Œå› ä¸ºæˆ‘ä»¬çš„ç›®çš„æ˜¯ä¸ºäº†å¾—åˆ°å¥½çš„å¥å­å‘é‡è¡¨ç¤ºè€Œä¸æ˜¯å¥½çš„åˆ†ç±»å™¨ã€‚è™½ç„¶æŸäº›ç›‘ç£ä»»åŠ¡æ¨¡åž‹å¦‚æ–‡æœ¬è•´å«æ¨¡åž‹æ˜¯å‚æ•°å…±äº«çš„ï¼Œ$s$çš„ç¼–ç å™¨å‚æ•°å’Œå€™é€‰å¥å­ç¼–ç å™¨å‚æ•°æ˜¯ä¸åŒçš„ï¼ˆä¸å…±äº«ï¼‰ï¼Œå› ä¸ºå¥å­è¡¨ç¤ºå­¦ä¹ å¾€å¾€æ˜¯åœ¨å¤§è§„æ¨¡è¯­æ–™ä¸Šè¿›è¡Œè®­ç»ƒï¼Œä¸å¿…æ‹…å¿ƒå‚æ•°å­¦ä¹ ä¸å……åˆ†çš„é—®é¢˜ ã€‚æµ‹è¯•æ—¶ï¼Œç»™å®šå¾…ç¼–ç å¥å­$s$ï¼Œé€šè¿‡è¯¥æ¨¡åž‹å¾—åˆ°çš„å¥å­è¡¨ç¤ºæ˜¯ä¸¤ç§ç¼–ç å™¨çš„è¿žç»“ $[ f ( s ) ;g ( s ) ]$ã€‚ çœ‹ä¸ŠåŽ»ï¼ŒSkip-thoughtå’ŒSkip-gramæŒºè±¡ã€‚å”¯ä¸€çš„é—æ†¾æ˜¯Skip-thoughtçš„decoderé‚£éƒ¨åˆ†ï¼Œå®ƒæ˜¯ä½œä¸ºlanguage modelingæ¥å¤„ç†çš„ã€‚QTé’ˆå¯¹è¿™ä¸ªé—®é¢˜ï¼Œå¯¹decoderéƒ¨åˆ†åšäº†å¤§çš„è°ƒæ•´ï¼Œå®ƒç›´æŽ¥æŠŠdecoderæ‹¿æŽ‰ï¼Œå–è€Œä»£ä¹‹çš„æ˜¯ä¸€ä¸ªclassifierã€‚è¿™ä¸ªclassifierè´Ÿè´£é¢„æµ‹å“ªäº›å¥å­æ‰æ˜¯context sentencesã€‚ QTçš„classifierå–ä»£äº†Skip-thoughtçš„Decoderã€‚è¿™æ ·åšçš„å¥½å¤„æ˜¯è¿è¡Œçš„é€Ÿåº¦å¤§å¤§æå‡äº†ï¼Œç”¨åˆ¤åˆ«é—®é¢˜å–ä»£äº†ç”Ÿæˆå¼é—®é¢˜ï¼ˆè¿™ä¸ªæ˜¯æ‰æ˜¯é€Ÿåº¦æå‡çš„åŽŸå› ï¼‰ã€‚æœ‰è¶£çš„æ˜¯ï¼Œè™½ç„¶QTå‡ºçŽ°çš„æ¯”Skip-thoughtæ›´æ™šï¼Œä½†æ˜¯æ–¹æ³•æ›´ç®€å•ï¼Œä¹Ÿæ›´åŠ æŽ¥è¿‘Word2Vecç®—æ³•ã€‚ QTæ˜¯ä¸€ç§æ–°çš„state-of-artçš„ç®—æ³•ã€‚å®ƒä¸å…‰æ•ˆæžœå¥½ï¼Œè€Œä¸”è®­ç»ƒæ—¶é—´è¦è¿œå°äºŽå…¶ä»–ç®—æ³•ã€‚åœ¨ç®—æ³•æ–¹æ³•ä¸Šå’Œæ•ˆæžœä¸Šï¼Œéƒ½å¯ç§°ä¸ºæ˜¯å¥å­è¡¨å¾ç•Œçš„Word2Vecä¸€èˆ¬çš„å­˜åœ¨ã€‚å’Œå‰é¢å‡ ç¯‡ä»‹ç»çš„ä¸åŒç®—æ³•æ”¾åœ¨ä¸€èµ·æ¯”è¾ƒï¼ŒåŒæ ·éƒ½æ˜¯ä¸ºäº†æ‰¾åˆ°å¥½çš„å¥å­è¡¨å¾ï¼Œå®ƒä»¬é‡‡å–äº†ä¸åŒçš„è·¯å¾„ï¼šInferSentåœ¨å¯»æ‰¾NLPé¢†åŸŸçš„ImageNet, å®ƒçš„æˆåŠŸæ›´åƒæ˜¯åœ¨å¯»æ‰¾æ•°æ®é›†å’Œä»»åŠ¡ä¸Šçš„æˆåŠŸï¼Œå½“ç„¶å®ƒæˆåŠŸçš„æ‰¾åˆ°äº†SNLI; Concatenated p-meansåœ¨å¯»æ‰¾NLPé¢†åŸŸçš„convolutional filter; QTåˆ™æ˜¯ç›´æŽ¥åœ¨ç®—æ³•å±‚é¢ä¸Šï¼Œå¯»æ‰¾å¥å­çº§åˆ«çš„Word2Vec, ç®—æ³•ä¸Šçš„æ”¹è¿›è®©å®ƒå—ç›Šã€‚æˆ‘ä»¬çœ‹åˆ°ä¸åŒçš„æ–¹æ³•åœ¨ä¸åŒçš„æ–¹å‘ä¸Šéƒ½ä½œå‡ºäº†åŠªåŠ›å’Œå–å¾—äº†æˆæ•ˆï¼Œå¾ˆéš¾è®²å“ªç§åŠªåŠ›ä¼šæ›´æœ‰æ•ˆæˆ–è€…æ›´æœ‰æ½œåŠ›ã€‚ Supervised Sentence EmbedInferSentæ¥è‡ªè®ºæ–‡Supervised Learning of Universal Sentence Representations from Natural Language Inference Dataï¼Œæ›´å¤šä¿¡æ¯å‚è€ƒ è¿™é‡Œ Multi-task learning Sentence EmbedUniversal Sentence Encoderæ¥è‡ªè®ºæ–‡ Universal Sentence Encoderï¼Œæ›´å¤šä¿¡æ¯å‚è€ƒ Universal Sentence Encoder sentence embeddingä¸ºä»€ä¹ˆè€ƒè™‘sentence embedding? è¯­åºï¼ˆè¯­ä¹‰ï¼‰åœ¨word embedding ä¸­ä¸èƒ½ä½“çŽ° word embedding çš„æ•ˆæžœä¾èµ–äºŽåˆ†è¯ SIF æ˜¯ä¸€ç§æ— ç›‘ç£çš„å­¦ä¹ æ–¹å¼ï¼Œä½†æ˜¯æœ€åŽçš„æ•ˆæžœå’ŒNN æ˜¯ç›¸å½“çš„ã€‚ è®­ç»ƒæ ·æœ¬ä¸è¶³çš„é—®é¢˜ è¯æ±‡æ‰©å±•ï¼šä½¿ç”¨word embeddingè¡¥å…… sentence embedding é›†æˆå­¦ä¹ ï¼šä½¿ç”¨å¤šä¸ªä¸åŒçš„æ¨¡åž‹æˆ–è€…å¤§çš„æ•°æ®é›†è¿›è¡Œè¡¥å…… è¯å‘é‡]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Unbalanced Datasets Problems]]></title>
    <url>%2F2019%2F06%2F01%2Funbalanced-datasets%2F</url>
    <content type="text"><![CDATA[æœºå™¨å­¦ä¹ ä¸­å‡ºçŽ°çš„ä¸å¹³è¡¡ç±»åˆ«é—®é¢˜çš„åˆ†æžã€å¸¸ç”¨çš„è§£å†³æ–¹æ¡ˆã€‚ å®šä¹‰ä¸åŒç±»åˆ«è®­ç»ƒæ•°æ®æ ·æœ¬çš„æ•°é‡ç›¸å·®å¾ˆå¤§ï¼Œå¯¼è‡´ä¼ ç»Ÿæ„ä¹‰ä¸Šçš„è¡¡é‡æŒ‡æ ‡â€œå‡†ç¡®çŽ‡â€ å¤±åŽ»äº†æ„ä¹‰ã€‚ è¯¥é—®é¢˜å‡ºçŽ°åœ¨å¤šä¸ªé¢†åŸŸä¸­ï¼ŒåŒ…æ‹¬ï¼š ä¿¡ç”¨æ¬ºè¯ˆ åžƒåœ¾é‚®ä»¶è¿‡æ»¤ ç–¾ç—…ç­›æŸ¥ å¤„ç†æ–¹æ³•æ¬ ï¼ˆä¸‹ï¼‰é‡‡æ ·ï¼ˆundersamplingï¼‰å¯¹è®­ç»ƒé›†ä¸­å¤šæ•°ç±»éšæœºè¿›è¡Œä¸‹é‡‡æ ·ï¼Œå–å¤šæ•°ç±»ä¸­çš„æ ·æœ¬ä½¿å¾—æ­£ä¾‹ã€åä¾‹æ•°ç›®æŽ¥è¿‘ï¼Œç„¶åŽè¿›è¡Œå­¦ä¹ ã€‚ä»Ž$S_{majority}$ ä¸­æ ·æœ¬æ•°é‡ä¸º $N_1$, ä½¿å¾—$N_1 =N_{minority}$ ç›´æŽ¥è¿™ç§éšæœºä¸‹é‡‡æ ·æ–¹æ³•æ˜¯æœ‰ä¸è¶³çš„ï¼Œæ¯”å¦‚é‡‡æ ·å¯¼è‡´åŽŸæœ‰ä¿¡æ¯çš„ç¼ºå¤±ã€‚æ‰€ä»¥å¸¸å¸¸ä½¿ç”¨EasyEnsemble ç®—æ³•è¿›è¡Œä¼˜åŒ–ã€‚ç®—æ³•æ­¥éª¤ï¼š ä»Žå¤šæ•°ç±»ä¸­æœ‰æ”¾å›žçš„éšæœºé‡‡æ ·$n$ æ¬¡ï¼Œæ¯æ¬¡é€‰å–å’Œå°‘æ•°ç±»åˆ«æ ·æœ¬ç›¸åŒæ•°ç›®çš„æ ·æœ¬ä¸ªæ•°ï¼Œå¾—åˆ° $n$ ä¸ªæ¨¡åž‹ ç„¶åŽæ¯ä¸ªä¸Šè¿°çš„å­é›†å’Œå°‘æ•°æ ·æœ¬åˆå¹¶è®­ç»ƒå…µè®­ç»ƒï¼Œå¯ä»¥å¾—åˆ° $n$ ä¸ªæ¨¡åž‹ æœ€ç»ˆè¿™äº›æ¨¡åž‹ç»„åˆå½¢æˆä¸€ä¸ªé›†æˆå­¦ä¹ ç³»ç»Ÿï¼Œæ¨¡åž‹çš„ç»“æžœæ˜¯è¿™$n$ ä¸ªæ¨¡åž‹çš„å¹³å‡å€¼ è¿‡ï¼ˆä¸Šï¼‰é‡‡æ ·ï¼ˆoversamplingï¼‰æœ€ç®€å•çš„æ–¹æ³•æ˜¯ï¼ˆå¦‚æžœæ²¡æœ‰æ›´å¤šçš„æ•°æ®ï¼Œåªéœ€è¦å¤åˆ¶çŽ°æœ‰çš„æ•°æ®ï¼Œå¹¶è½»å¾®çš„å˜åŒ–å³å¯ï¼‰ å›¾åƒæ•°æ®å¢žå¼ºé•œåƒç¿»è½¬ã€æ—‹è½¬ã€å¹³ç§»ã€ç¼©æ”¾ã€é¢œè‰²éšæœºæ‰°åŠ¨ã€éžçº¿æ€§å‡ ä½•å˜å½¢ç­‰ï¼›GANç”Ÿæˆæ–°æ ·æœ¬ï¼› æ–‡æœ¬æ•°æ®å¢žå¼º éšæœºè¿‡é‡‡æ ·åœ¨å°‘æ•°ç±» $S_{minority}$ ä¸­éšæœºé€‰æ‹©ä¸€äº›æ ·æœ¬ï¼Œç„¶åŽé€šè¿‡å¤åˆ¶è¿™äº›é€‰æ‹©çš„æ ·æœ¬å¾—åˆ°æ–°çš„ç»“åˆï¼Œè¿™äº›é›†åˆä½œä¸ºè®­ç»ƒä¸­çš„å°‘æ•°æ ·æœ¬æ•°æ®é›†ã€‚å…¶ç¼ºç‚¹ï¼šå®¹æ˜“é€ æˆæ¨¡åž‹çš„è¿‡æ‹Ÿåˆï¼Œå› ä¸ºè¿™äº›æ ·æœ¬éƒ½æ˜¯é€šè¿‡å¯¹åˆå§‹æ ·æœ¬å¤åˆ¶é‡‡æ ·å¾—æ¥ï¼Œä¸åˆ©äºŽæé«˜æ¨¡åž‹çš„æ³›åŒ–æ€§èƒ½ã€‚ SMOTEï¼ˆSynthetic Minority Oversamplingï¼‰ç®—æ³•å³ï¼Œåˆæˆå°‘æ•°ç±»è¿‡é‡‡æ ·æŠ€æœ¯æ˜¯å¯¹éšæœºè¿‡é‡‡æ ·çš„ä¸€ç§æ”¹è¿›ç®—æ³•ã€‚è€ŒSOMTç®—æ³•çš„åŸºæœ¬æ€æƒ³æ˜¯å¯¹æ¯ä¸ªå°‘æ•°ç±»æ ·æœ¬$x_i$ ï¼Œä»Žå®ƒçš„æœ€è¿‘é‚»ä¸­éšæœºé€‰æ‹©ä¸€ä¸ªæ ·æœ¬ $\hat{x_i}$ ï¼ˆ $\hat{x_i}$ æ˜¯å°‘æ•°ç±»ä¸­çš„ä¸€ä¸ªæ ·æœ¬ï¼‰ï¼Œç„¶åŽåœ¨$x_i$ å’Œ $\hat{x_i}$ ä¹‹é—´çš„è¿žçº¿ä¸Šéšæœºé€‰æ‹©ä¸€ç‚¹ä½œä¸ºæ–°åˆæˆçš„å°‘æ•°ç±»æ ·æœ¬ã€‚ç®—æ³•æè¿°å¦‚ä¸‹ï¼š1).å¯¹äºŽå°‘æ•°ç±»ä¸­çš„æ¯ä¸€ä¸ªæ ·æœ¬ $x_i$ï¼Œä»¥æ¬§æ°è·ç¦»ä¸ºæ ‡å‡†è®¡ç®—å®ƒåˆ°å°‘æ•°ç±»æ ·æœ¬é›† $S_{minority}$ä¸­æ‰€æœ‰æ ·æœ¬çš„è·ç¦»ï¼Œå¾—åˆ°å…¶kè¿‘é‚»ã€‚2).æ ¹æ®æ ·æœ¬ä¸å¹³è¡¡æ¯”ä¾‹è®¾ç½®ä¸€ä¸ªé‡‡æ ·æ¯”ä¾‹ä»¥ç¡®å®šé‡‡æ ·å€çŽ‡ $N$ï¼Œå¯¹äºŽæ¯ä¸€ä¸ªå°‘æ•°ç±»æ ·æœ¬ $x_i$ ï¼Œä»Žå…¶ $k$è¿‘é‚»ä¸­éšæœºé€‰æ‹©è‹¥å¹²ä¸ªæ ·æœ¬ï¼Œå‡è®¾é€‰æ‹©çš„æ˜¯ $\hat{x_i}$ ã€‚3).å¯¹äºŽæ¯ä¸€ä¸ªéšæœºé€‰å‡ºæ¥çš„è¿‘é‚» $\hat{x_i}$ ï¼Œåˆ†åˆ«ä¸Ž $x_i$ æŒ‰ç…§å¦‚ä¸‹å…¬å¼æž„å»ºæ–°çš„æ ·æœ¬ã€‚$$x_{new} =x_i +rand(0,1) \times (\hat{x_i} -x_i)$$å‚è€ƒï¼Œ æœ‰ä¸€ç§ä»£ç å®žçŽ°ä¸è¶³ä¹‹å¤„1). è§‚å¯Ÿåˆ°çš„æ•°ç›®æ˜¯åŠå…¶ç½•è§çš„ç±»åˆ«çš„æ—¶å€™ï¼Œå°±ä¸çŸ¥æ‰€æŽªã€‚2). æ¯ä¸ªå°‘æ•°æ ·æœ¬éƒ½ç”Ÿæˆæ–°æ ·æœ¬ï¼Œå®¹æ˜“å‘ç”Ÿæ ·æœ¬é‡å çš„é—®é¢˜3). ç”Ÿæˆæœºåˆ¶å­˜åœ¨ä¸€å®šçš„ç›²ç›®æ€§ï¼Œå¯èƒ½æœ‰äº›å°‘æ•°çš„æ ·æœ¬å¹¶ä¸å…·æœ‰å°‘æ•°æ ·æœ¬çš„ä»£è¡¨æ€§ Kè¿‘é‚»å•è¯æ›¿æ¢è¿™é‡Œç”¨åˆ°äº†word embeddingå·¥å…·ï¼Œåœ¨åºåˆ—æ¨¡åž‹ä¸­ï¼Œæ¯ä¸ªå•è¯éƒ½èƒ½æ˜ å°„æˆä¸€ä¸ªè¯å‘é‡ã€‚æ‰€ä»¥ä¸€ä¸ªå•è¯å¯ä»¥çœ‹åšé«˜ç»´ç©ºé—´ä¸­ä¸€ä¸ªæ ·æœ¬ç‚¹ï¼Œè¿™ä¹Ÿå°±å¯ä»¥ç”¨Kè¿‘é‚»æ¥å¾—åˆ°å’Œå®ƒè¯­ä¹‰ç›¸è¿‘çš„å•è¯äº†ã€‚è¿™é‡Œæ”¾ä¸€ä¸ªä»£ç é“¾æŽ¥ã€‚å¯ä»¥è¢«çœ‹åšæ˜¯å¤„ç†OOVé—®é¢˜çš„ä¸€ç§æ‰‹æ®µã€‚ æ”¹å˜è¯„ä»·æŒ‡æ ‡ ä½¿ç”¨auc 1from sklearn.metrics import roc_auc_score ä½¿ç”¨F1 æ”¹å˜æ¨¡åž‹ åŸºäºŽSVMæƒ©ç½šç®—æ³•ä½¿ç”¨æƒ©ç½šå­¦ä¹ ç®—æ³•å¢žåŠ å¯¹å°‘æ•°ç±»åˆ«åˆ†ç±»é”™è¯¯çš„ä»£ä»·ï¼Œä¸€ä¸ªæµè¡Œçš„ç®—æ³•æ˜¯æƒ©ç½šæ€§-SVM 1234from sklearn.svm import SVCclf_3 = SVC(kernel='linear', class_weight='balanced', # penalize probability=True) åŸºäºŽæ ‘çš„ç®—æ³•å†³ç­–æ ‘é€šå¸¸åœ¨ä¸å¹³è¡¡çš„æ•°æ®é›†ä¸Šè¡¨çŽ°è‰¯å¥½ï¼Œå› ä¸ºè¿™ç§å±‚åºç»“æž„å…è®¸å…¶ä»Žä¸¤ä¸ªç±»åˆ«åŽ»å­¦ä¹ ã€‚è€Œåœ¨ç›®å‰çœ‹æ¥ï¼Œæ ‘é›†åˆï¼ˆéšæœºæ£®æž—ã€æ¢¯åº¦æå‡æ ‘ï¼‰æ€»æ˜¯ä¼˜äºŽå•ä¸ªå†³ç­–æ ‘ï¼Œæ‰€ä»¥å¯ä»¥è€ƒè™‘xgboost ä¹‹ç±»çš„æ¡†æž¶ã€‚ ä¿®æ”¹æŸå¤±å‡½æ•° å¦‚æžœä½ ç”¨çš„æ˜¯kerasï¼Œæ¨¡åž‹è®­ç»ƒå‡½æ•°ä¸­æ˜¯å¯ä»¥è°ƒæ•´class_weightçš„ï¼Œå¯ä»¥åœ¨class_weightä¸­é€‚å½“å¢žå¤§æ­£æ ·æœ¬çš„æƒé‡ã€‚æ¯”è¾ƒå¿Œè®³æŠŠæ­£æ ·æœ¬æƒé‡å¢žå¤§åˆ°ä¸¤è€…æŸå¤±æ€»é‡ä¸€æ ·ï¼Œè¿™ä¹ˆè®¾ç½®ä»Žæ¥æ²¡æœ‰ä¸€æ¬¡æ•ˆæžœæ˜¯å¥½çš„ã€‚ç¬”è€…ä¸€èˆ¬æŠŠæ­£æ ·æœ¬æƒé‡è°ƒåˆ°è´Ÿæ ·æœ¬æƒé‡çš„1.1~1.5å€ï¼Œå¯ä»¥å–å¾—æ¯”ä¹‹å‰è¦å¥½çš„F1 scoreã€‚ Focal Lossæ˜¯ä¸ªå€¼å¾—è€ƒè™‘çš„ç›®æ ‡å‡½æ•°ï¼Œè®ºæ–‡ï¼šFocal Loss for Dense Object Detectionã€‚è¯¥æŸå¤±å‡½æ•°åœ¨ç›®æ ‡æ£€æµ‹é¢†åŸŸå–å¾—äº†è‰¯å¥½çš„å¤„ç†ç±»åˆ«ä¸å¹³è¡¡æ•ˆæžœå’Œæ”¹å–„è¯¯åˆ†ç±»çš„æ•ˆæžœï¼Œç¬”è€…åœ¨æ–‡æœ¬åˆ†ç±»çš„ä»»åŠ¡ä¸­ç”¨äº†è¯¥ç›®æ ‡å‡½æ•°ï¼Œä¹Ÿèƒ½å–å¾—è¾ƒå¤§æå‡ã€‚ å‚è€ƒå¦‚ä½•å¤„ç†æœºå™¨å­¦ä¹ ä¸­çš„ä¸å¹³è¡¡ç±»åˆ«åˆ†ç±»ä¸­è§£å†³ç±»åˆ«ä¸å¹³è¡¡é—®é¢˜]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>unbalanced_datasets</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dynamic Programming Examples(1)]]></title>
    <url>%2F2019%2F05%2F27%2FDynamic-Programming-Examples%2F</url>
    <content type="text"><![CDATA[Dynamic Programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions using a memory-based data structure (array, map, etc.). So the next time the same sub-problem occurs, instead of recomputing its solution, one simply looks up the previously computed solution, thereby saving computation time. knapsack problem: partition-equal-subset-sum ç½‘ç«™é“¾æŽ¥ python ç‰ˆæœ¬ 12345678910111213141516171819202122class Solution(object): def canPartition(self, nums): """ :type nums: List[int] :rtype: bool """ n =len(nums) s = sum(nums) if s &amp;1 ==1: return False dp =[0 for _ in range(s+1)] dp[0] =1 #import ipdb for num in nums: for i in range(s, -1, -1): # ipdb.set_trace() if dp[i]: dp[i+num] =1 if dp[s//2]: return True return False C++ ç‰ˆæœ¬ 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;// dp, 01 èƒŒåŒ…é—®é¢˜ï¼Œsumè¡¨ç¤ºä½“ç§¯ ä»Žå¤§åˆ°å°è¿›è¡Œæžšä¸¾ï¼Œ dp[i] é€‰æ‹©ç¬¬i ä¸ªæ•°ç»„æˆçš„å’Œ, è½¬ç§» dp[i],int main()&#123; int n; cin&gt;&gt; n; vector&lt;bool&gt; f(n+1, false); vector&lt;int&gt; arr; //for(int i =0; i&lt;n; i++) cin&gt;&gt;arr[i]; arr=&#123;1, 5, 11, 5&#125;; int sum =0; for(auto u: arr) sum += u; if(sum &amp;1) cout&lt;&lt;"false"&lt;&lt;endl; f[0] =true; int half =sum/2; for(auto num: arr) for(int j =half; j&gt;= num; j--) &#123; f[j] =f[j] || f[j-num]; // 01èƒŒåŒ…é—®é¢˜ï¼Œé€‰æ‹©ä¸Žå¦çš„å…³ç³» &#125; cout&lt;&lt;f[half]&lt;&lt;endl; return 0;&#125; longest commone substring Given two strings â€˜Xâ€™ and â€˜Yâ€™, find the length of the longest common substring. Input : X = â€œGeeksforGeeksâ€, y = â€œGeeksQuizâ€Output : 5 åŽŸæ–‡é“¾æŽ¥ é¦–å…ˆå®¡é¢˜æ˜¯éœ€è¦æ³¨æ„çš„ï¼Œéœ€è¦æ³¨æ„æ˜¯å…¬å…±å­ä¸²è¿˜æ˜¯å­åºåˆ—ï¼Œå‰è€…è¦æ±‚è¿žç»­index è€ŒåŽè€…ä¸è¦æ±‚ã€‚ 1234567891011121314151617181920212223242526272829"""Given two strings â€˜Xâ€™ and â€˜Yâ€™, find the length of the longest common substring."""class Solution(object): def minDistance(self, word1, word2): m =len(word1) n =len(word2) #dp=[ [None] for _ in range(n+1) for _ in range(m+1)] dp = [[None] *(n +1) for _ in range(m+1) ] for i in range(m+1): for j in range(n+1): if i ==0 or j ==0: dp[i][j] =0 # è¿™ä¸ªæ˜¯python ä¸­è¯­æ³•å†³å®šçš„ word1[len(word1)] æ˜¯è®¿é—®ä¸åˆ°çš„ï¼Œè¿™ä¸ªè®¿é—®æ˜¯ä»Ž0å¼€å§‹çš„ï¼Œæ‰€ä»¥åªèƒ½æ˜¯è¿™æ ·çš„ elif word1[i-1] == word2[j-1]: dp[i][j] =dp[i-1][j-1] +1 else: dp[i][j] =max(dp[i-1][j], dp[i][j-1]) return dp[m][n]solution =Solution()word1 ='abcdaf'word2 ='acbcf'result =solution.minDistance(word1, word2)print(result) c++ ç‰ˆæœ¬ã€‚å½“ä½¿ç”¨ f(n+1, m+1)ï¼Œ ç„¶åŽåœ¨éåŽ†çš„æ—¶å€™ï¼Œä»Ž1 å¼€å§‹éåŽ†çš„æ—¶å€™ï¼Œåœ¨if è¿›è¡Œåˆ¤æ–­çš„æ—¶å€™ï¼Œ text1[i-1] == text2[j-1] è¿™ä¸ªæ¡ä»¶æ˜¯ç»å¸¸å¼„é”™çš„ã€‚ä¸€å®šè¦ä»Ž i-1å¼€å§‹è®¡ç®—ã€‚ 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int longestCommonSubsequence(string text1, string text2) &#123; int n, m; n =text1.size(), m =text2.size(); vector&lt;vector&lt;int&gt;&gt; f(n+1, vector&lt;int&gt;(m+1)); f[0][0] =0; for(int i=1; i&lt;=n; i++) &#123; for(int j =1;j&lt;=m ; j++) &#123; if(text1[i-1] ==text2[j-1] ) f[i][j]=f[i-1][j-1] +1; else &#123; f[i][j] =max(f[i-1][j], f[i][j-1]); &#125; &#125; &#125; return f[n][m]; //cout&lt;&lt;f[n][m]&lt;&lt;endl; &#125;&#125;;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è®¡ç®—æœºåŸºç¡€ï¼ˆ2ï¼‰]]></title>
    <url>%2F2019%2F05%2F24%2Fbasics-of-cs2%2F</url>
    <content type="text"><![CDATA[è®¡ç®—æœºä¸­çš„åŸºç¡€çŸ¥è¯†ï¼Œæ¯”å¦‚è®¡ç®—æœºç½‘ç»œã€è½¯ä»¶å·¥ç¨‹ã€‚ è®¡ç®—æœºç½‘ç»œå¸¸ç”¨çš„å‘½ä»¤ pingping å‘½ä»¤å¼ç”¨æ¥æµ‹è¯•TCP/IP ç½‘ç»œæ˜¯å¦ç•…é€šæˆ–è€…ç½‘ç»œè¿žæŽ¥é€Ÿåº¦çš„å‘½ä»¤ã€‚ ç½‘ç»œè¿žé€šæ€§æµ‹è¯•çš„â€œ4éƒ¨æ›²â€ï¼š ï¼ˆ1ï¼‰è¾“å…¥â€œping 127.0.0.1â€å‘½ä»¤ï¼Œæ­¤å‘½ä»¤ç”¨äºŽæ£€æŸ¥æœ¬æœºçš„TCP/IP åè®®å®‰è£…æ˜¯å¦æ­£ç¡®ï¼Œå‡¡æ˜¯ä»¥127 å¼€å¤´çš„IPåœ°å€éƒ½ä»£è¡¨æœ¬æœºã€‚ï¼ˆ2ï¼‰è¾“å…¥â€œping æœ¬æœºIPåœ°å€å‘½ä»¤â€ï¼Œæ­¤å‘½ä»¤ç”¨äºŽæ£€æŸ¥æœ¬æœºçš„æœåŠ¡å’Œç½‘ç»œé€‚é…å™¨çš„ç»‘å®šæ˜¯å¦æ­£ç¡®ã€‚ï¼ˆ3ï¼‰è¾“å…¥â€œping ç½‘å…³IPåœ°å€â€å‘½ä»¤ï¼Œæ­¤å‘½ä»¤ç”¨æ¥æ£€æŸ¥æœ¬æœºå’Œç½‘å…³çš„è¿žæŽ¥æ˜¯å¦æ­£å¸¸ã€‚ï¼ˆ4ï¼‰è¾“å…¥â€œping è¿œç¨‹ä¸»æœºIPåœ°å€â€å‘½ä»¤ï¼Œæ­¤å‘½ä»¤ç”¨æ¥æ£€æŸ¥ç½‘å…³èƒ½å¦å°†æ•°æ®åŒ…è½¬å‘å‡ºåŽ»ã€‚ ipconfig è®¾ç½®å’ŒæŸ¥çœ‹ç½‘ç»œæŽ¥å£å·¥å…· net å‘½ä»¤ è¯¥å‘½ä»¤çš„å­å‘½ä»¤é‚£ä¸ªï¼Œå¯åœ¨å‘½ä»¤æç¤ºç¬¦çª—å£ä¸­æ‰§è¡Œnet/?å‘½ä»¤ã€‚å¦‚æžœè¦æŸ¥çœ‹å­å‘½ä»¤çš„ç›¸å…³å¸®åŠ©ï¼Œå¯åœ¨å‘½ä»¤æç¤ºç¬¦çª—å£ä¸­æ‰§è¡Œnet help å‘½ä»¤å³å¯ã€‚ä¾‹å¦‚è¾“å…¥net help accounts å‘½ä»¤å³å¯å¾—åˆ°accouns çš„ç›¸å…³å¸®åŠ©ã€‚ tracert tracert å‘½ä»¤å¯ä»¥ç”¨æ¥è·Ÿè¸ªæ•°æ®åŒ…ä½¿ç”¨çš„è·¯ç”±ï¼ˆè·¯å¾„ï¼‰ã€‚è¯¥ä½¿ç”¨ç¨‹åºè·Ÿè¸ªçš„è·¯å¾„æ˜¯æºè®¡ç®—æœºåˆ°ç›®çš„åœ°çš„ä¸€æ¡è·¯å¾„ï¼Œä¸èƒ½ä¿è¯æˆ–è®¤ä¸ºæ•°æ®åŒ…æ€»éµå¾ªè¿™ä¸ªè·¯å¾„ã€‚ netstat å‘½ä»¤ ä¸€èˆ¬ç”¨äºŽæ£€æµ‹æœ¬æœºå„ç«¯å£çš„ç½‘ç»œè¿žæŽ¥æƒ…å†µ ARP æŸ¥çœ‹å’Œè®¾ç½®åœ°å€è§£æžåè®®è¡¨é¡¹å·¥å…· ã€‚åœ°å€è§£æžä½œç”¨ï¼šæ˜¯æŠŠç›®çš„ä¸»æœºçš„IPåœ°å€è§£æžä¸ºç›®çš„ä¸»æœºçš„MACåœ°å€ã€‚ route æŸ¥çœ‹å’Œè®¾ç½®è·¯ç”±è¡¨çš„è¡¨é¡¹å·¥å…· nslookup æŸ¥çœ‹åŸŸåå·¥å…· ftp ftp å‘½ä»¤ï¼šç”¨äºŽæ–‡ä»¶ä¼ è¾“çš„å‘½ä»¤ï¼Œæ˜¯çŽ°åœ¨ä¸¤å°äº’è¿žçš„æœºå™¨ä¹‹é—´ä¼ é€æ–‡ä»¶ï¼Œè¯¥å‘½ä»¤ä¸Žå¸¸ç”¨çš„FTPé…ç½®è½¯ä»¶æ˜¯ä¸€æ ·çš„ talent è¿œç¨‹è®¿é—®å‘½ä»¤ï¼Œä¸ºåº”ç”¨å±‚åè®®è¿œç¨‹ç™»å½•è®¿é—®çš„åº”ç”¨ nslookup nslookupå‘½ä»¤ç”¨äºŽæŸ¥è¯¢DNSçš„è®°å½•ï¼ŒæŸ¥çœ‹åŸŸåè§£æžæ˜¯å¦æ­£å¸¸ï¼Œåœ¨ç½‘ç»œæ•…éšœçš„æ—¶å€™ç”¨æ¥è¯Šæ–­ç½‘ç»œé—®é¢˜ã€‚ Httpå’ŒHttpsçš„åŒºåˆ« Httpåè®®è¿è¡Œåœ¨TCPä¹‹ä¸Šï¼Œæ˜Žæ–‡ä¼ è¾“ï¼Œå®¢æˆ·ç«¯ä¸ŽæœåŠ¡å™¨ç«¯éƒ½æ— æ³•éªŒè¯å¯¹æ–¹çš„èº«ä»½ï¼›Httpsæ˜¯èº«æŠ«SSL(Secure Socket Layer)å¤–å£³çš„Httpï¼Œè¿è¡ŒäºŽSSLä¸Šï¼ŒSSLè¿è¡ŒäºŽTCPä¹‹ä¸Šï¼Œæ˜¯æ·»åŠ äº†åŠ å¯†å’Œè®¤è¯æœºåˆ¶çš„HTTPã€‚äºŒè€…ä¹‹é—´å­˜åœ¨å¦‚ä¸‹ä¸åŒï¼š ç«¯å£ä¸åŒï¼šHttpä¸ŽHttpä½¿ç”¨ä¸åŒçš„è¿žæŽ¥æ–¹å¼ï¼Œç”¨çš„ç«¯å£ä¹Ÿä¸ä¸€æ ·ï¼Œå‰è€…æ˜¯80ï¼ŒåŽè€…æ˜¯443ï¼› èµ„æºæ¶ˆè€—ï¼šå’ŒHTTPé€šä¿¡ç›¸æ¯”ï¼ŒHttpsé€šä¿¡ä¼šç”±äºŽåŠ å‡å¯†å¤„ç†æ¶ˆè€—æ›´å¤šçš„CPUå’Œå†…å­˜èµ„æºï¼› å¼€é”€ï¼šHttpsé€šä¿¡éœ€è¦è¯ä¹¦ï¼Œè€Œè¯ä¹¦ä¸€èˆ¬éœ€è¦å‘è®¤è¯æœºæž„è´­ä¹°ï¼› Httpsçš„åŠ å¯†æœºåˆ¶æ˜¯ä¸€ç§å…±äº«å¯†é’¥åŠ å¯†å’Œå…¬å¼€å¯†é’¥åŠ å¯†å¹¶ç”¨çš„æ··åˆåŠ å¯†æœºåˆ¶ã€‚ å¯¹ç§°åŠ å¯†ä¸Žéžå¯¹ç§°åŠ å¯† å¯¹ç§°å¯†é’¥åŠ å¯†æ˜¯æŒ‡åŠ å¯†å’Œè§£å¯†ä½¿ç”¨åŒä¸€ä¸ªå¯†é’¥çš„æ–¹å¼ï¼Œè¿™ç§æ–¹å¼å­˜åœ¨çš„æœ€å¤§é—®é¢˜å°±æ˜¯å¯†é’¥å‘é€é—®é¢˜ï¼Œå³å¦‚ä½•å®‰å…¨åœ°å°†å¯†é’¥å‘ç»™å¯¹æ–¹ï¼›è€Œéžå¯¹ç§°åŠ å¯†æ˜¯æŒ‡ä½¿ç”¨ä¸€å¯¹éžå¯¹ç§°å¯†é’¥ï¼Œå³å…¬é’¥å’Œç§é’¥ï¼Œå…¬é’¥å¯ä»¥éšæ„å‘å¸ƒï¼Œä½†ç§é’¥åªæœ‰è‡ªå·±çŸ¥é“ã€‚å‘é€å¯†æ–‡çš„ä¸€æ–¹ä½¿ç”¨å¯¹æ–¹çš„å…¬é’¥è¿›è¡ŒåŠ å¯†å¤„ç†ï¼Œå¯¹æ–¹æŽ¥æ”¶åˆ°åŠ å¯†ä¿¡æ¯åŽï¼Œä½¿ç”¨è‡ªå·±çš„ç§é’¥è¿›è¡Œè§£å¯†ã€‚ ç”±äºŽéžå¯¹ç§°åŠ å¯†çš„æ–¹å¼ä¸éœ€è¦å‘é€ç”¨æ¥è§£å¯†çš„ç§é’¥ï¼Œæ‰€ä»¥å¯ä»¥ä¿è¯å®‰å…¨æ€§ï¼›ä½†æ˜¯å’Œå¯¹ç§°åŠ å¯†æ¯”èµ·æ¥ï¼Œå®ƒéžå¸¸çš„æ…¢ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿˜æ˜¯è¦ç”¨å¯¹ç§°åŠ å¯†æ¥ä¼ é€æ¶ˆæ¯ï¼Œä½†å¯¹ç§°åŠ å¯†æ‰€ä½¿ç”¨çš„å¯†é’¥æˆ‘ä»¬å¯ä»¥é€šè¿‡éžå¯¹ç§°åŠ å¯†çš„æ–¹å¼å‘é€å‡ºåŽ»ã€‚ ä¸‰æ¬¡æ¡æ‰‹å’Œå››æ¬¡æ¡æ‰‹ ç¬¬ä¸€æ¬¡æ¡æ‰‹ï¼šClientå°†æ ‡å¿—ä½SYNç½®ä¸º1ï¼Œéšæœºäº§ç”Ÿä¸€ä¸ªå€¼seq=Jï¼Œå¹¶å°†è¯¥æ•°æ®åŒ…å‘é€ç»™Serverï¼ŒClientè¿›å…¥SYN_SENTçŠ¶æ€ï¼Œç­‰å¾…Serverç¡®è®¤ã€‚ ç¬¬äºŒæ¬¡æ¡æ‰‹ï¼šServeræ”¶åˆ°æ•°æ®åŒ…åŽç”±æ ‡å¿—ä½SYN=1çŸ¥é“Clientè¯·æ±‚å»ºç«‹è¿žæŽ¥ï¼ŒServerå°†æ ‡å¿—ä½SYNå’ŒACKéƒ½ç½®ä¸º1ï¼Œack=J+1ï¼Œéšæœºäº§ç”Ÿä¸€ä¸ªå€¼seq=Kï¼Œå¹¶å°†è¯¥æ•°æ®åŒ…å‘é€ç»™Clientä»¥ç¡®è®¤è¿žæŽ¥è¯·æ±‚ï¼ŒServerè¿›å…¥SYN_RCVDçŠ¶æ€ã€‚ ç¬¬ä¸‰æ¬¡æ¡æ‰‹ï¼šClientæ”¶åˆ°ç¡®è®¤åŽï¼Œæ£€æŸ¥ackæ˜¯å¦ä¸ºJ+1ï¼ŒACKæ˜¯å¦ä¸º1ï¼Œå¦‚æžœæ­£ç¡®åˆ™å°†æ ‡å¿—ä½ACKç½®ä¸º1ï¼Œack=K+1ï¼Œå¹¶å°†è¯¥æ•°æ®åŒ…å‘é€ç»™Serverï¼ŒServeræ£€æŸ¥ackæ˜¯å¦ä¸ºK+1ï¼ŒACKæ˜¯å¦ä¸º1ï¼Œå¦‚æžœæ­£ç¡®åˆ™è¿žæŽ¥å»ºç«‹æˆåŠŸï¼ŒClientå’ŒServerè¿›å…¥ESTABLISHEDçŠ¶æ€ï¼Œå®Œæˆä¸‰æ¬¡æ¡æ‰‹ï¼ŒéšåŽClientä¸ŽServerä¹‹é—´å¯ä»¥å¼€å§‹ä¼ è¾“æ•°æ®äº†ã€‚ ç¬¬ä¸€æ¬¡æŒ¥æ‰‹ï¼šClientå‘é€ä¸€ä¸ªFINï¼Œç”¨æ¥å…³é—­Clientåˆ°Serverçš„æ•°æ®ä¼ é€ï¼ŒClientè¿›å…¥FIN_WAIT_1çŠ¶æ€ã€‚ ç¬¬äºŒæ¬¡æŒ¥æ‰‹ï¼šServeræ”¶åˆ°FINåŽï¼Œå‘é€ä¸€ä¸ªACKç»™Clientï¼Œç¡®è®¤åºå·ä¸ºæ”¶åˆ°åºå·+1ï¼ˆä¸ŽSYNç›¸åŒï¼Œä¸€ä¸ªFINå ç”¨ä¸€ä¸ªåºå·ï¼‰ï¼ŒServerè¿›å…¥CLOSE_WAITçŠ¶æ€ã€‚æ­¤æ—¶TCPé“¾æŽ¥å¤„äºŽåŠå…³é—­çŠ¶æ€ï¼Œå³å®¢æˆ·ç«¯å·²ç»æ²¡æœ‰è¦å‘é€çš„æ•°æ®äº†ï¼Œä½†æœåŠ¡ç«¯è‹¥å‘é€æ•°æ®ï¼Œåˆ™å®¢æˆ·ç«¯ä»è¦æŽ¥æ”¶ã€‚ ç¬¬ä¸‰æ¬¡æŒ¥æ‰‹ï¼šServerå‘é€ä¸€ä¸ªFINï¼Œç”¨æ¥å…³é—­Serveråˆ°Clientçš„æ•°æ®ä¼ é€ï¼ŒServerè¿›å…¥LAST_ACKçŠ¶æ€ã€‚ ç¬¬å››æ¬¡æŒ¥æ‰‹ï¼šClientæ”¶åˆ°FINåŽï¼ŒClientè¿›å…¥TIME_WAITçŠ¶æ€ï¼ŒæŽ¥ç€å‘é€ä¸€ä¸ªACKç»™Serverï¼Œç¡®è®¤åºå·ä¸ºæ”¶åˆ°åºå·+1ï¼ŒServerè¿›å…¥CLOSEDçŠ¶æ€ï¼Œå®Œæˆå››æ¬¡æŒ¥æ‰‹ã€‚ TCPåè®®å¦‚ä½•æ¥ä¿è¯ä¼ è¾“çš„å¯é æ€§ æ•°æ®åŒ…æ ¡éªŒï¼šç›®çš„æ˜¯æ£€æµ‹æ•°æ®åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­çš„ä»»ä½•å˜åŒ–ï¼Œè‹¥æ ¡éªŒå‡ºåŒ…æœ‰é”™ï¼Œåˆ™ä¸¢å¼ƒæŠ¥æ–‡æ®µå¹¶ä¸”ä¸ç»™å‡ºå“åº”ï¼Œè¿™æ—¶TCPå‘é€æ•°æ®ç«¯è¶…æ—¶åŽä¼šé‡å‘æ•°æ®ï¼› å¯¹å¤±åºæ•°æ®åŒ…é‡æŽ’åºï¼šæ—¢ç„¶TCPæŠ¥æ–‡æ®µä½œä¸ºIPæ•°æ®æŠ¥æ¥ä¼ è¾“ï¼Œè€ŒIPæ•°æ®æŠ¥çš„åˆ°è¾¾å¯èƒ½ä¼šå¤±åºï¼Œå› æ­¤TCPæŠ¥æ–‡æ®µçš„åˆ°è¾¾ä¹Ÿå¯èƒ½ä¼šå¤±åºã€‚TCPå°†å¯¹å¤±åºæ•°æ®è¿›è¡Œé‡æ–°æŽ’åºï¼Œç„¶åŽæ‰äº¤ç»™åº”ç”¨å±‚ï¼› ä¸¢å¼ƒé‡å¤æ•°æ®ï¼šå¯¹äºŽé‡å¤æ•°æ®ï¼Œèƒ½å¤Ÿä¸¢å¼ƒé‡å¤æ•°æ®ï¼› åº”ç­”æœºåˆ¶ï¼šå½“TCPæ”¶åˆ°å‘è‡ªTCPè¿žæŽ¥å¦ä¸€ç«¯çš„æ•°æ®ï¼Œå®ƒå°†å‘é€ä¸€ä¸ªç¡®è®¤ã€‚è¿™ä¸ªç¡®è®¤ä¸æ˜¯ç«‹å³å‘é€ï¼Œé€šå¸¸å°†æŽ¨è¿Ÿå‡ åˆ†ä¹‹ä¸€ç§’ï¼› è¶…æ—¶é‡å‘ï¼šå½“TCPå‘å‡ºä¸€ä¸ªæ®µåŽï¼Œå®ƒå¯åŠ¨ä¸€ä¸ªå®šæ—¶å™¨ï¼Œç­‰å¾…ç›®çš„ç«¯ç¡®è®¤æ”¶åˆ°è¿™ä¸ªæŠ¥æ–‡æ®µã€‚å¦‚æžœä¸èƒ½åŠæ—¶æ”¶åˆ°ä¸€ä¸ªç¡®è®¤ï¼Œå°†é‡å‘è¿™ä¸ªæŠ¥æ–‡æ®µï¼› æµé‡æŽ§åˆ¶ï¼šTCPè¿žæŽ¥çš„æ¯ä¸€æ–¹éƒ½æœ‰å›ºå®šå¤§å°çš„ç¼“å†²ç©ºé—´ã€‚TCPçš„æŽ¥æ”¶ç«¯åªå…è®¸å¦ä¸€ç«¯å‘é€æŽ¥æ”¶ç«¯ç¼“å†²åŒºæ‰€èƒ½æŽ¥çº³çš„æ•°æ®ï¼Œè¿™å¯ä»¥é˜²æ­¢è¾ƒå¿«ä¸»æœºè‡´ä½¿è¾ƒæ…¢ä¸»æœºçš„ç¼“å†²åŒºæº¢å‡ºï¼Œè¿™å°±æ˜¯æµé‡æŽ§åˆ¶ã€‚TCPä½¿ç”¨çš„æµé‡æŽ§åˆ¶åè®®æ˜¯å¯å˜å¤§å°çš„æ»‘åŠ¨çª—å£åè®®ã€‚ Getä¸ŽPOSTçš„åŒºåˆ« GETä¸ŽPOSTæ˜¯æˆ‘ä»¬å¸¸ç”¨çš„ä¸¤ç§HTTP Methodï¼ŒäºŒè€…ä¹‹é—´çš„åŒºåˆ«ä¸»è¦åŒ…æ‹¬å¦‚ä¸‹äº”ä¸ªæ–¹é¢ï¼š (1). ä»ŽåŠŸèƒ½ä¸Šè®²ï¼ŒGETä¸€èˆ¬ç”¨æ¥ä»ŽæœåŠ¡å™¨ä¸ŠèŽ·å–èµ„æºï¼ŒPOSTä¸€èˆ¬ç”¨æ¥æ›´æ–°æœåŠ¡å™¨ä¸Šçš„èµ„æºï¼› (2). ä»ŽRESTæœåŠ¡è§’åº¦ä¸Šè¯´ï¼ŒGETæ˜¯å¹‚ç­‰çš„ï¼Œå³è¯»å–åŒä¸€ä¸ªèµ„æºï¼Œæ€»æ˜¯å¾—åˆ°ç›¸åŒçš„æ•°æ®ï¼Œè€ŒPOSTä¸æ˜¯å¹‚ç­‰çš„ï¼Œå› ä¸ºæ¯æ¬¡è¯·æ±‚å¯¹èµ„æºçš„æ”¹å˜å¹¶ä¸æ˜¯ç›¸åŒçš„ï¼›è¿›ä¸€æ­¥åœ°ï¼ŒGETä¸ä¼šæ”¹å˜æœåŠ¡å™¨ä¸Šçš„èµ„æºï¼Œè€ŒPOSTä¼šå¯¹æœåŠ¡å™¨èµ„æºè¿›è¡Œæ”¹å˜ï¼› (3). ä»Žè¯·æ±‚å‚æ•°å½¢å¼ä¸Šçœ‹ï¼ŒGETè¯·æ±‚çš„æ•°æ®ä¼šé™„åœ¨URLä¹‹åŽï¼Œå³å°†è¯·æ±‚æ•°æ®æ”¾ç½®åœ¨HTTPæŠ¥æ–‡çš„ è¯·æ±‚å¤´ ä¸­ï¼Œä»¥?åˆ†å‰²URLå’Œä¼ è¾“æ•°æ®ï¼Œå‚æ•°ä¹‹é—´ä»¥&amp;ç›¸è¿žã€‚ç‰¹åˆ«åœ°ï¼Œå¦‚æžœæ•°æ®æ˜¯è‹±æ–‡å­—æ¯/æ•°å­—ï¼ŒåŽŸæ ·å‘é€ï¼›å¦åˆ™ï¼Œä¼šå°†å…¶ç¼–ç ä¸º application/x-www-form-urlencoded MIME å­—ç¬¦ä¸²(å¦‚æžœæ˜¯ç©ºæ ¼ï¼Œè½¬æ¢ä¸º+ï¼Œå¦‚æžœæ˜¯ä¸­æ–‡/å…¶ä»–å­—ç¬¦ï¼Œåˆ™ç›´æŽ¥æŠŠå­—ç¬¦ä¸²ç”¨BASE64åŠ å¯†ï¼Œå¾—å‡ºå¦‚ï¼š%E4%BD%A0%E5%A5%BDï¼Œå…¶ä¸­ï¼…XXä¸­çš„XXä¸ºè¯¥ç¬¦å·ä»¥16è¿›åˆ¶è¡¨ç¤ºçš„ASCII)ï¼›è€ŒPOSTè¯·æ±‚ä¼šæŠŠæäº¤çš„æ•°æ®åˆ™æ”¾ç½®åœ¨æ˜¯HTTPè¯·æ±‚æŠ¥æ–‡çš„ è¯·æ±‚ä½“ ä¸­ã€‚ (4). å°±å®‰å…¨æ€§è€Œè¨€ï¼ŒPOSTçš„å®‰å…¨æ€§è¦æ¯”GETçš„å®‰å…¨æ€§é«˜ï¼Œå› ä¸ºGETè¯·æ±‚æäº¤çš„æ•°æ®å°†æ˜Žæ–‡å‡ºçŽ°åœ¨URLä¸Šï¼Œè€Œä¸”POSTè¯·æ±‚å‚æ•°åˆ™è¢«åŒ…è£…åˆ°è¯·æ±‚ä½“ä¸­ï¼Œç›¸å¯¹æ›´å®‰å…¨ã€‚ (5). ä»Žè¯·æ±‚çš„å¤§å°çœ‹ï¼ŒGETè¯·æ±‚çš„é•¿åº¦å—é™äºŽæµè§ˆå™¨æˆ–æœåŠ¡å™¨å¯¹URLé•¿åº¦çš„é™åˆ¶ï¼Œå…è®¸å‘é€çš„æ•°æ®é‡æ¯”è¾ƒå°ï¼Œè€ŒPOSTè¯·æ±‚åˆ™æ˜¯æ²¡æœ‰å¤§å°é™åˆ¶çš„ã€‚ TCPä¸ŽUDPçš„åŒºåˆ« TCP (Transmission Control Protocol)å’ŒUDP(User Datagram Protocol)åè®®å±žäºŽä¼ è¾“å±‚åè®®ï¼Œå®ƒä»¬ä¹‹é—´çš„åŒºåˆ«åŒ…æ‹¬ï¼š TCPæ˜¯é¢å‘è¿žæŽ¥çš„ï¼ŒUDPæ˜¯æ— è¿žæŽ¥çš„ï¼› TCPæ˜¯å¯é çš„ï¼ŒUDPæ˜¯ä¸å¯é çš„ï¼› TCPåªæ”¯æŒç‚¹å¯¹ç‚¹é€šä¿¡ï¼ŒUDPæ”¯æŒä¸€å¯¹ä¸€ã€ä¸€å¯¹å¤šã€å¤šå¯¹ä¸€ã€å¤šå¯¹å¤šçš„é€šä¿¡æ¨¡å¼ï¼› TCPæ˜¯é¢å‘å­—èŠ‚æµçš„ï¼ŒUDPæ˜¯é¢å‘æŠ¥æ–‡çš„ï¼› TCPæœ‰æ‹¥å¡žæŽ§åˆ¶æœºåˆ¶;UDPæ²¡æœ‰æ‹¥å¡žæŽ§åˆ¶ï¼Œé€‚åˆåª’ä½“é€šä¿¡ï¼› TCPé¦–éƒ¨å¼€é”€(20ä¸ªå­—èŠ‚)æ¯”UDPçš„é¦–éƒ¨å¼€é”€(8ä¸ªå­—èŠ‚)è¦å¤§ï¼› TCPçš„æ‹¥å¡žå¤„ç† æ…¢å¯åŠ¨ï¼šä¸è¦ä¸€å¼€å§‹å°±å‘é€å¤§é‡çš„æ•°æ®ï¼Œå…ˆæŽ¢æµ‹ä¸€ä¸‹ç½‘ç»œçš„æ‹¥å¡žç¨‹åº¦ï¼Œä¹Ÿå°±æ˜¯è¯´ç”±å°åˆ°å¤§é€æ¸å¢žåŠ æ‹¥å¡žçª—å£çš„å¤§å°; æ‹¥å¡žé¿å…ï¼šæ‹¥å¡žé¿å…ç®—æ³•è®©æ‹¥å¡žçª—å£ç¼“æ…¢å¢žé•¿ï¼Œå³æ¯ç»è¿‡ä¸€ä¸ªå¾€è¿”æ—¶é—´RTTå°±æŠŠå‘é€æ–¹çš„æ‹¥å¡žçª—å£cwndåŠ 1ï¼Œè€Œä¸æ˜¯åŠ å€ï¼Œè¿™æ ·æ‹¥å¡žçª—å£æŒ‰çº¿æ€§è§„å¾‹ç¼“æ…¢å¢žé•¿ å¿«é‡ä¼ ï¼šå¿«é‡ä¼ è¦æ±‚æŽ¥æ”¶æ–¹åœ¨æ”¶åˆ°ä¸€ä¸ª å¤±åºçš„æŠ¥æ–‡æ®µ åŽå°±ç«‹å³å‘å‡º é‡å¤ç¡®è®¤ï¼ˆä¸ºçš„æ˜¯ä½¿å‘é€æ–¹åŠæ—©çŸ¥é“æœ‰æŠ¥æ–‡æ®µæ²¡æœ‰åˆ°è¾¾å¯¹æ–¹ï¼‰è€Œä¸è¦ç­‰åˆ°è‡ªå·±å‘é€æ•°æ®æ—¶æŽå¸¦ç¡®è®¤ã€‚å¿«é‡ä¼ ç®—æ³•è§„å®šï¼Œå‘é€æ–¹åªè¦ä¸€è¿žæ”¶åˆ°ä¸‰ä¸ªé‡å¤ç¡®è®¤å°±åº”å½“ç«‹å³é‡ä¼ å¯¹æ–¹å°šæœªæ”¶åˆ°çš„æŠ¥æ–‡æ®µï¼Œè€Œä¸å¿…ç»§ç»­ç­‰å¾…è®¾ç½®çš„é‡ä¼ è®¡æ—¶å™¨æ—¶é—´åˆ°æœŸã€‚ å¿«æ¢å¤ï¼šå¿«é‡ä¼ é…åˆä½¿ç”¨çš„è¿˜æœ‰å¿«æ¢å¤ç®—æ³•ï¼Œå½“å‘é€æ–¹è¿žç»­æ”¶åˆ°ä¸‰ä¸ªé‡å¤ç¡®è®¤æ—¶ï¼Œå°±æ‰§è¡Œâ€œä¹˜æ³•å‡å°â€ç®—æ³•ï¼ŒæŠŠssthreshé—¨é™å‡åŠï¼Œä½†æ˜¯æŽ¥ä¸‹åŽ»å¹¶ä¸æ‰§è¡Œæ…¢å¼€å§‹ç®—æ³•ï¼šå› ä¸ºå¦‚æžœç½‘ç»œå‡ºçŽ°æ‹¥å¡žçš„è¯å°±ä¸ä¼šæ”¶åˆ°å¥½å‡ ä¸ªé‡å¤çš„ç¡®è®¤ï¼Œæ‰€ä»¥å‘é€æ–¹çŽ°åœ¨è®¤ä¸ºç½‘ç»œå¯èƒ½æ²¡æœ‰å‡ºçŽ°æ‹¥å¡žã€‚æ‰€ä»¥æ­¤æ—¶ä¸æ‰§è¡Œæ…¢å¼€å§‹ç®—æ³•ï¼Œè€Œæ˜¯å°†cwndè®¾ç½®ä¸ºssthreshçš„å¤§å°ï¼Œç„¶åŽæ‰§è¡Œæ‹¥å¡žé¿å…ç®—æ³•ã€‚ ARPæ˜¯åœ°å€è§£æžåè®® DNSï¼ˆDomain Name Systemï¼‰åŸŸåç³»ç»Ÿ å½“DNSå®¢æˆ·æœºéœ€è¦åœ¨ç¨‹åºä¸­ä½¿ç”¨åç§°æ—¶ï¼Œå®ƒä¼šæŸ¥è¯¢DNSæœåŠ¡å™¨æ¥è§£æžè¯¥åç§°ã€‚å®¢æˆ·æœºå‘é€çš„æ¯æ¡æŸ¥è¯¢ä¿¡æ¯åŒ…æ‹¬ä¸‰æ¡ä¿¡æ¯ï¼šåŒ…æ‹¬ï¼šæŒ‡å®šçš„DNSåŸŸåï¼ŒæŒ‡å®šçš„æŸ¥è¯¢ç±»åž‹ï¼ŒDNSåŸŸåçš„æŒ‡å®šç±»åˆ«ã€‚åŸºäºŽUDPæœåŠ¡ï¼Œç«¯å£53.è¯¥åº”ç”¨ä¸€èˆ¬ä¸ç›´æŽ¥ä¸ºç”¨æˆ·ä½¿ç”¨ï¼Œè€Œæ˜¯ä¸ºå…¶ä»–åº”ç”¨æœåŠ¡ï¼Œå¦‚HTTPï¼ŒSMTPç­‰åœ¨å…¶ä¸­éœ€è¦å®Œæˆä¸»æœºååˆ°IPåœ°å€çš„è½¬æ¢ã€‚ TCPå’ŒUDPåˆ†åˆ«å¯¹åº”çš„å¸¸è§åº”ç”¨å±‚åè®® TCPå¯¹åº”çš„åº”ç”¨å±‚åè®® FTPï¼šå®šä¹‰äº†æ–‡ä»¶ä¼ è¾“åè®®ï¼Œä½¿ç”¨21ç«¯å£ã€‚å¸¸è¯´æŸæŸè®¡ç®—æœºå¼€äº†FTPæœåŠ¡ä¾¿æ˜¯å¯åŠ¨äº†æ–‡ä»¶ä¼ è¾“æœåŠ¡ã€‚ä¸‹è½½æ–‡ä»¶ï¼Œä¸Šä¼ ä¸»é¡µï¼Œéƒ½è¦ç”¨åˆ°FTPæœåŠ¡ã€‚ Telnetï¼šå®ƒæ˜¯ä¸€ç§ç”¨äºŽè¿œç¨‹ç™»é™†çš„ç«¯å£ï¼Œç”¨æˆ·å¯ä»¥ä»¥è‡ªå·±çš„èº«ä»½è¿œç¨‹è¿žæŽ¥åˆ°è®¡ç®—æœºä¸Šï¼Œé€šè¿‡è¿™ç§ç«¯å£å¯ä»¥æä¾›ä¸€ç§åŸºäºŽDOSæ¨¡å¼ä¸‹çš„é€šä¿¡æœåŠ¡ã€‚å¦‚ä»¥å‰çš„BBSæ˜¯-çº¯å­—ç¬¦ç•Œé¢çš„ï¼Œæ”¯æŒBBSçš„æœåŠ¡å™¨å°†23ç«¯å£æ‰“å¼€ï¼Œå¯¹å¤–æä¾›æœåŠ¡ã€‚ SMTPï¼šå®šä¹‰äº†ç®€å•é‚®ä»¶ä¼ é€åè®®ï¼ŒçŽ°åœ¨å¾ˆå¤šé‚®ä»¶æœåŠ¡å™¨éƒ½ç”¨çš„æ˜¯è¿™ä¸ªåè®®ï¼Œç”¨äºŽå‘é€é‚®ä»¶ã€‚å¦‚å¸¸è§çš„å…è´¹é‚®ä»¶æœåŠ¡ä¸­ç”¨çš„å°±æ˜¯è¿™ä¸ªé‚®ä»¶æœåŠ¡ç«¯å£ï¼Œæ‰€ä»¥åœ¨ç”µå­é‚®ä»¶è®¾ç½®-ä¸­å¸¸çœ‹åˆ°æœ‰è¿™ä¹ˆSMTPç«¯å£è®¾ç½®è¿™ä¸ªæ ï¼ŒæœåŠ¡å™¨å¼€æ”¾çš„æ˜¯25å·ç«¯å£ã€‚ POP3ï¼šå®ƒæ˜¯å’ŒSMTPå¯¹åº”ï¼ŒPOP3ç”¨äºŽæŽ¥æ”¶é‚®ä»¶ã€‚é€šå¸¸æƒ…å†µä¸‹ï¼ŒPOP3åè®®æ‰€ç”¨çš„æ˜¯110ç«¯å£ã€‚ä¹Ÿæ˜¯è¯´ï¼Œåªè¦ä½ æœ‰ç›¸åº”çš„ä½¿ç”¨POP3åè®®çš„ç¨‹åºï¼ˆä¾‹å¦‚Fo-xmailæˆ–Outlookï¼‰ï¼Œå°±å¯ä»¥ä¸ä»¥Webæ–¹å¼ç™»é™†è¿›é‚®ç®±ç•Œé¢ï¼Œç›´æŽ¥ç”¨é‚®ä»¶ç¨‹åºå°±å¯ä»¥æ”¶åˆ°é‚®ä»¶ï¼ˆå¦‚æ˜¯163é‚®ç®±å°±æ²¡æœ‰å¿…è¦å…ˆè¿›å…¥ç½‘æ˜“ç½‘ç«™ï¼Œå†è¿›å…¥è‡ªå·±çš„é‚®-ç®±æ¥æ”¶ä¿¡ï¼‰ã€‚ HTTPï¼šä»ŽWebæœåŠ¡å™¨ä¼ è¾“è¶…æ–‡æœ¬åˆ°æœ¬åœ°æµè§ˆå™¨çš„ä¼ é€åè®®ã€‚ UDPå¯¹åº”çš„åº”ç”¨å±‚åè®® DNSï¼šç”¨äºŽåŸŸåè§£æžæœåŠ¡ï¼Œå°†åŸŸååœ°å€è½¬æ¢ä¸ºIPåœ°å€ã€‚DNSç”¨çš„æ˜¯53å·ç«¯å£ã€‚ SNMPï¼šç®€å•ç½‘ç»œç®¡ç†åè®®ï¼Œä½¿ç”¨161å·ç«¯å£ï¼Œæ˜¯ç”¨æ¥ç®¡ç†ç½‘ç»œè®¾å¤‡çš„ã€‚ç”±äºŽç½‘ç»œè®¾å¤‡å¾ˆå¤šï¼Œæ— è¿žæŽ¥çš„æœåŠ¡å°±ä½“çŽ°å‡ºå…¶ä¼˜åŠ¿ã€‚ TFTP(Trival File Transfer Protocal)ï¼šç®€å•æ–‡ä»¶ä¼ è¾“åè®®ï¼Œè¯¥åè®®åœ¨ç†ŸçŸ¥ç«¯å£69ä¸Šä½¿ç”¨UDPæœåŠ¡ã€‚ Javaç¨‹åºä»Žæºæ–‡ä»¶åˆ›å»ºåˆ°ç¨‹åºè¿è¡Œè¦ç»è¿‡ä¸¤å¤§æ­¥éª¤ï¼š 1ã€æºæ–‡ä»¶ç”±ç¼–è¯‘å™¨ç¼–è¯‘æˆå­—èŠ‚ç ï¼ˆByteCodeï¼‰ï¼› 2ã€å­—èŠ‚ç ç”±javaè™šæ‹Ÿæœºè§£é‡Šè¿è¡Œã€‚å› ä¸ºjavaç¨‹åºæ—¢è¦ç¼–è¯‘åŒæ—¶ä¹Ÿè¦ç»è¿‡JVMçš„è§£é‡Šè¿è¡Œï¼Œæ‰€ä»¥è¯´Javaè¢«ç§°ä¸ºåŠè§£é‡Šè¯­è¨€ åº”ç”¨å±‚ï¼šHTTPã€SMTPã€FTPã€Telnetã€DNSã€DHCPã€SSH TELNET è¡¨ç¤ºå±‚ï¼šASCIIã€MPEGã€JPEGã€MIDI ä¼šè¯å±‚ï¼šNetBIOSã€SAPã€SDPã€NWLink ä¼ è¾“å±‚ï¼šTCPã€ UDPã€OSPFã€SPX ç½‘ç»œå±‚ï¼šIPã€IPXã€ ICMPã€ ARP æ•°æ®é“¾è·¯å±‚ï¼šEthernetã€Token Ringã€FDDIã€AppleTalk æ•°æ®é“¾è·¯å±‚ â€œé“¾æŽ¥å±‚â€çš„åŠŸèƒ½ï¼Œå®ƒåœ¨â€å®žä½“å±‚â€çš„ä¸Šæ–¹ï¼Œç¡®å®šäº†0å’Œ1çš„åˆ†ç»„æ–¹å¼ã€‚ä»¥å¤ªç½‘è§„å®šï¼Œä¸€ç»„ç”µä¿¡å·æž„æˆä¸€ä¸ªæ•°æ®åŒ…ï¼Œå«åšâ€å¸§â€ï¼ˆFrameï¼‰ã€‚æ¯ä¸€å¸§åˆ†æˆä¸¤ä¸ªéƒ¨åˆ†ï¼šæ ‡å¤´ï¼ˆHeadï¼‰å’Œæ•°æ®ï¼ˆDataï¼‰ã€‚ä»¥å¤ªç½‘è§„å®šï¼Œè¿žå…¥ç½‘ç»œçš„æ‰€æœ‰è®¾å¤‡ï¼Œéƒ½å¿…é¡»å…·æœ‰â€ç½‘å¡â€æŽ¥å£ã€‚æ•°æ®åŒ…å¿…é¡»æ˜¯ä»Žä¸€å—ç½‘å¡ï¼Œä¼ é€åˆ°å¦ä¸€å—ç½‘å¡ã€‚ç½‘å¡çš„åœ°å€ï¼Œå°±æ˜¯æ•°æ®åŒ…çš„å‘é€åœ°å€å’ŒæŽ¥æ”¶åœ°å€ï¼Œè¿™å«åšMACåœ°å€ã€‚æ¯å—ç½‘å¡å‡ºåŽ‚çš„æ—¶å€™ï¼Œéƒ½æœ‰ä¸€ä¸ªå…¨ä¸–ç•Œç‹¬ä¸€æ— äºŒçš„MACåœ°å€ï¼Œé•¿åº¦æ˜¯48ä¸ªäºŒè¿›åˆ¶ä½ï¼Œé€šå¸¸ç”¨12ä¸ªåå…­è¿›åˆ¶æ•°è¡¨ç¤ºã€‚ é¦–å…ˆï¼Œä¸€å—ç½‘å¡æ€Žä¹ˆä¼šçŸ¥é“å¦ä¸€å—ç½‘å¡çš„MACåœ°å€ï¼Ÿå›žç­”æ˜¯æœ‰ä¸€ç§ARPåè®®ï¼Œå¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚è¿™ä¸ªç•™åˆ°åŽé¢ä»‹ç»ï¼Œè¿™é‡Œåªéœ€è¦çŸ¥é“ï¼Œä»¥å¤ªç½‘æ•°æ®åŒ…å¿…é¡»çŸ¥é“æŽ¥æ”¶æ–¹çš„MACåœ°å€ï¼Œç„¶åŽæ‰èƒ½å‘é€ã€‚ä»¥å¤ªç½‘é‡‡ç”¨äº†ä¸€ç§å¾ˆâ€åŽŸå§‹â€çš„æ–¹å¼ï¼Œå®ƒä¸æ˜¯æŠŠæ•°æ®åŒ…å‡†ç¡®é€åˆ°æŽ¥æ”¶æ–¹ï¼Œè€Œæ˜¯å‘æœ¬ç½‘ç»œå†…æ‰€æœ‰è®¡ç®—æœºå‘é€ï¼Œè®©æ¯å°è®¡ç®—æœºè‡ªå·±åˆ¤æ–­ï¼Œæ˜¯å¦ä¸ºæŽ¥æ”¶æ–¹ã€‚ ä¸Šé¢æ˜¯å¤„ç†å­ç½‘å†…éƒ¨çš„å¯»æ‰¾é—®é¢˜ï¼Œé‚£ä¹ˆå¦‚ä½•åŽ»å¤„ç†å­ç½‘ä¹‹é—´çš„å‘¢ï¼Ÿè¿™å°±å¯¼è‡´äº†â€ç½‘ç»œå±‚â€çš„è¯žç”Ÿã€‚å®ƒçš„ä½œç”¨æ˜¯å¼•è¿›ä¸€å¥—æ–°çš„åœ°å€ï¼Œä½¿å¾—æˆ‘ä»¬èƒ½å¤ŸåŒºåˆ†ä¸åŒçš„è®¡ç®—æœºæ˜¯å¦å±žäºŽåŒä¸€ä¸ªå­ç½‘ç»œã€‚è¿™å¥—åœ°å€å°±å«åšâ€ç½‘ç»œåœ°å€â€ï¼Œç®€ç§°â€ç½‘å€â€ã€‚æ¯å°è®¡ç®—æœºæœ‰äº†ä¸¤ç§åœ°å€ï¼Œä¸€ç§æ˜¯MACåœ°å€ï¼Œå¦ä¸€ç§æ˜¯ç½‘ç»œåœ°å€ã€‚ä¸¤ç§åœ°å€ä¹‹é—´æ²¡æœ‰ä»»ä½•è”ç³»ï¼ŒMACåœ°å€æ˜¯ç»‘å®šåœ¨ç½‘å¡ä¸Šçš„ï¼Œç½‘ç»œåœ°å€åˆ™æ˜¯ç®¡ç†å‘˜åˆ†é…çš„ï¼Œå®ƒä»¬åªæ˜¯éšæœºç»„åˆåœ¨ä¸€èµ·ã€‚ è§„å®šç½‘ç»œåœ°å€çš„åè®®ï¼Œå«åšIPåè®®ã€‚å®ƒæ‰€å®šä¹‰çš„åœ°å€ï¼Œå°±è¢«ç§°ä¸ºIPåœ°å€ã€‚IPåè®®ç¬¬å››ç‰ˆï¼Œç®€ç§°IPv4ã€‚è¿™ä¸ªç‰ˆæœ¬è§„å®šï¼Œç½‘ç»œåœ°å€ç”±32ä¸ªäºŒè¿›åˆ¶ä½ç»„æˆã€‚ä¹ æƒ¯ä¸Šï¼Œæˆ‘ä»¬ç”¨åˆ†æˆå››æ®µçš„åè¿›åˆ¶æ•°è¡¨ç¤ºIPåœ°å€ï¼Œä»Ž0.0.0.0ä¸€ç›´åˆ°255.255.255.255ã€‚ é‚£ä¹ˆï¼Œæ€Žæ ·æ‰èƒ½ä»ŽIPåœ°å€ï¼Œåˆ¤æ–­ä¸¤å°è®¡ç®—æœºæ˜¯å¦å±žäºŽåŒä¸€ä¸ªå­ç½‘ç»œå‘¢ï¼Ÿè¿™å°±è¦ç”¨åˆ°å¦ä¸€ä¸ªå‚æ•°â€å­ç½‘æŽ©ç â€ï¼ˆsubnet maskï¼‰ã€‚æ‰€è°“â€å­ç½‘æŽ©ç â€ï¼Œå°±æ˜¯è¡¨ç¤ºå­ç½‘ç»œç‰¹å¾çš„ä¸€ä¸ªå‚æ•°ã€‚å®ƒåœ¨å½¢å¼ä¸Šç­‰åŒäºŽIPåœ°å€ï¼Œä¹Ÿæ˜¯ä¸€ä¸ª32ä½äºŒè¿›åˆ¶æ•°å­—ï¼Œå®ƒçš„ç½‘ç»œéƒ¨åˆ†å…¨éƒ¨ä¸º1ï¼Œä¸»æœºéƒ¨åˆ†å…¨éƒ¨ä¸º0ã€‚æ¯”å¦‚ï¼ŒIPåœ°å€172.16.254.1ï¼Œå¦‚æžœå·²çŸ¥ç½‘ç»œéƒ¨åˆ†æ˜¯å‰24ä½ï¼Œä¸»æœºéƒ¨åˆ†æ˜¯åŽ8ä½ï¼Œé‚£ä¹ˆå­ç½‘ç»œæŽ©ç å°±æ˜¯11111111.11111111.11111111.00000000ï¼Œå†™æˆåè¿›åˆ¶å°±æ˜¯255.255.255.0ã€‚ çŸ¥é“â€å­ç½‘æŽ©ç â€ï¼Œæˆ‘ä»¬å°±èƒ½åˆ¤æ–­ï¼Œä»»æ„ä¸¤ä¸ªIPåœ°å€æ˜¯å¦å¤„åœ¨åŒä¸€ä¸ªå­ç½‘ç»œã€‚æ–¹æ³•æ˜¯å°†ä¸¤ä¸ªIPåœ°å€ä¸Žå­ç½‘æŽ©ç åˆ†åˆ«è¿›è¡ŒANDè¿ç®—ï¼ˆä¸¤ä¸ªæ•°ä½éƒ½ä¸º1ï¼Œè¿ç®—ç»“æžœä¸º1ï¼Œå¦åˆ™ä¸º0ï¼‰ï¼Œç„¶åŽæ¯”è¾ƒç»“æžœæ˜¯å¦ç›¸åŒï¼Œå¦‚æžœæ˜¯çš„è¯ï¼Œå°±è¡¨æ˜Žå®ƒä»¬åœ¨åŒä¸€ä¸ªå­ç½‘ç»œä¸­ï¼Œå¦åˆ™å°±ä¸æ˜¯ã€‚ æ€»ç»“ä¸€ä¸‹ï¼ŒIPåè®®çš„ä½œç”¨ä¸»è¦æœ‰ä¸¤ä¸ªï¼Œä¸€ä¸ªæ˜¯ä¸ºæ¯ä¸€å°è®¡ç®—æœºåˆ†é…IPåœ°å€ï¼Œå¦ä¸€ä¸ªæ˜¯ç¡®å®šå“ªäº›åœ°å€åœ¨åŒä¸€ä¸ªå­ç½‘ç»œã€‚ ä½†æ˜¯å‰é¢è¯´è¿‡ï¼Œä»¥å¤ªç½‘æ•°æ®åŒ…åªåŒ…å«MACåœ°å€ï¼Œå¹¶æ²¡æœ‰IPåœ°å€çš„æ ä½ã€‚é‚£ä¹ˆæ˜¯å¦éœ€è¦ä¿®æ”¹æ•°æ®å®šä¹‰ï¼Œå†æ·»åŠ ä¸€ä¸ªæ ä½å‘¢ï¼Ÿ å›žç­”æ˜¯ä¸éœ€è¦ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠIPæ•°æ®åŒ…ç›´æŽ¥æ”¾è¿›ä»¥å¤ªç½‘æ•°æ®åŒ…çš„â€æ•°æ®â€éƒ¨åˆ†ï¼Œå› æ­¤å®Œå…¨ä¸ç”¨ä¿®æ”¹ä»¥å¤ªç½‘çš„è§„æ ¼ã€‚è¿™å°±æ˜¯äº’è”ç½‘åˆ†å±‚ç»“æž„çš„å¥½å¤„ï¼šä¸Šå±‚çš„å˜åŠ¨å®Œå…¨ä¸æ¶‰åŠä¸‹å±‚çš„ç»“æž„ã€‚ ç½‘ç»œå±‚ å…³äºŽâ€ç½‘ç»œå±‚â€ï¼Œè¿˜æœ‰æœ€åŽä¸€ç‚¹éœ€è¦è¯´æ˜Žã€‚ å› ä¸ºIPæ•°æ®åŒ…æ˜¯æ”¾åœ¨ä»¥å¤ªç½‘æ•°æ®åŒ…é‡Œå‘é€çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¿…é¡»åŒæ—¶çŸ¥é“ä¸¤ä¸ªåœ°å€ï¼Œä¸€ä¸ªæ˜¯å¯¹æ–¹çš„MACåœ°å€ï¼Œå¦ä¸€ä¸ªæ˜¯å¯¹æ–¹çš„IPåœ°å€ã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œå¯¹æ–¹çš„IPåœ°å€æ˜¯å·²çŸ¥çš„ï¼ˆåŽæ–‡ä¼šè§£é‡Šï¼‰ï¼Œä½†æ˜¯æˆ‘ä»¬ä¸çŸ¥é“å®ƒçš„MACåœ°å€ã€‚ æ‰€ä»¥ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ç§æœºåˆ¶ï¼Œèƒ½å¤Ÿä»ŽIPåœ°å€å¾—åˆ°MACåœ°å€ã€‚ è¿™é‡Œåˆå¯ä»¥åˆ†æˆä¸¤ç§æƒ…å†µã€‚ç¬¬ä¸€ç§æƒ…å†µï¼Œå¦‚æžœä¸¤å°ä¸»æœºä¸åœ¨åŒä¸€ä¸ªå­ç½‘ç»œï¼Œé‚£ä¹ˆäº‹å®žä¸Šæ²¡æœ‰åŠžæ³•å¾—åˆ°å¯¹æ–¹çš„MACåœ°å€ï¼Œåªèƒ½æŠŠæ•°æ®åŒ…ä¼ é€åˆ°ä¸¤ä¸ªå­ç½‘ç»œè¿žæŽ¥å¤„çš„â€ç½‘å…³â€ï¼ˆgatewayï¼‰ï¼Œè®©ç½‘å…³åŽ»å¤„ç†ã€‚ ç¬¬äºŒç§æƒ…å†µï¼Œå¦‚æžœä¸¤å°ä¸»æœºåœ¨åŒä¸€ä¸ªå­ç½‘ç»œï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ç”¨ARPåè®®ï¼Œå¾—åˆ°å¯¹æ–¹çš„MACåœ°å€ã€‚ARPåè®®ä¹Ÿæ˜¯å‘å‡ºä¸€ä¸ªæ•°æ®åŒ…ï¼ˆåŒ…å«åœ¨ä»¥å¤ªç½‘æ•°æ®åŒ…ä¸­ï¼‰ï¼Œå…¶ä¸­åŒ…å«å®ƒæ‰€è¦æŸ¥è¯¢ä¸»æœºçš„IPåœ°å€ï¼Œåœ¨å¯¹æ–¹çš„MACåœ°å€è¿™ä¸€æ ï¼Œå¡«çš„æ˜¯FF:FF:FF:FF:FF:FFï¼Œè¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªâ€å¹¿æ’­â€åœ°å€ã€‚å®ƒæ‰€åœ¨å­ç½‘ç»œçš„æ¯ä¸€å°ä¸»æœºï¼Œéƒ½ä¼šæ”¶åˆ°è¿™ä¸ªæ•°æ®åŒ…ï¼Œä»Žä¸­å–å‡ºIPåœ°å€ï¼Œä¸Žè‡ªèº«çš„IPåœ°å€è¿›è¡Œæ¯”è¾ƒã€‚å¦‚æžœä¸¤è€…ç›¸åŒï¼Œéƒ½åšå‡ºå›žå¤ï¼Œå‘å¯¹æ–¹æŠ¥å‘Šè‡ªå·±çš„MACåœ°å€ï¼Œå¦åˆ™å°±ä¸¢å¼ƒè¿™ä¸ªåŒ…ã€‚ æ€»ä¹‹ï¼Œæœ‰äº†ARPåè®®ä¹‹åŽï¼Œæˆ‘ä»¬å°±å¯ä»¥å¾—åˆ°åŒä¸€ä¸ªå­ç½‘ç»œå†…çš„ä¸»æœºMACåœ°å€ï¼Œå¯ä»¥æŠŠæ•°æ®åŒ…å‘é€åˆ°ä»»æ„ä¸€å°ä¸»æœºä¹‹ä¸Šäº†ã€‚ ä¼ è¾“å±‚çš„ç”±æ¥ ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ªå‚æ•°ï¼Œè¡¨ç¤ºè¿™ä¸ªæ•°æ®åŒ…åˆ°åº•ä¾›å“ªä¸ªç¨‹åºï¼ˆè¿›ç¨‹ï¼‰ä½¿ç”¨ã€‚è¿™ä¸ªå‚æ•°å°±å«åšâ€ç«¯å£â€ï¼ˆportï¼‰ï¼Œå®ƒå…¶å®žæ˜¯æ¯ä¸€ä¸ªä½¿ç”¨ç½‘å¡çš„ç¨‹åºçš„ç¼–å·ã€‚æ¯ä¸ªæ•°æ®åŒ…éƒ½å‘åˆ°ä¸»æœºçš„ç‰¹å®šç«¯å£ï¼Œæ‰€ä»¥ä¸åŒçš„ç¨‹åºå°±èƒ½å–åˆ°è‡ªå·±æ‰€éœ€è¦çš„æ•°æ®ã€‚ â€œç«¯å£â€æ˜¯0åˆ°65535ä¹‹é—´çš„ä¸€ä¸ªæ•´æ•°ï¼Œæ­£å¥½16ä¸ªäºŒè¿›åˆ¶ä½ã€‚0åˆ°1023çš„ç«¯å£è¢«ç³»ç»Ÿå ç”¨ï¼Œç”¨æˆ·åªèƒ½é€‰ç”¨å¤§äºŽ1023çš„ç«¯å£ã€‚ä¸ç®¡æ˜¯æµè§ˆç½‘é¡µè¿˜æ˜¯åœ¨çº¿èŠå¤©ï¼Œåº”ç”¨ç¨‹åºä¼šéšæœºé€‰ç”¨ä¸€ä¸ªç«¯å£ï¼Œç„¶åŽä¸ŽæœåŠ¡å™¨çš„ç›¸åº”ç«¯å£è”ç³»ã€‚â€ä¼ è¾“å±‚â€çš„åŠŸèƒ½ï¼Œå°±æ˜¯å»ºç«‹â€ç«¯å£åˆ°ç«¯å£â€çš„é€šä¿¡ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œâ€ç½‘ç»œå±‚â€çš„åŠŸèƒ½æ˜¯å»ºç«‹â€ä¸»æœºåˆ°ä¸»æœºâ€çš„é€šä¿¡ã€‚åªè¦ç¡®å®šä¸»æœºå’Œç«¯å£ï¼Œæˆ‘ä»¬å°±èƒ½å®žçŽ°ç¨‹åºä¹‹é—´çš„äº¤æµã€‚å› æ­¤ï¼ŒUnixç³»ç»Ÿå°±æŠŠä¸»æœº+ç«¯å£ï¼Œå«åšâ€å¥—æŽ¥å­—â€ï¼ˆsocketï¼‰ã€‚æœ‰äº†å®ƒï¼Œå°±å¯ä»¥è¿›è¡Œç½‘ç»œåº”ç”¨ç¨‹åºå¼€å‘äº†ã€‚ çŽ°åœ¨ï¼Œæˆ‘ä»¬å¿…é¡»åœ¨æ•°æ®åŒ…ä¸­åŠ å…¥ç«¯å£ä¿¡æ¯ï¼Œè¿™å°±éœ€è¦æ–°çš„åè®®ã€‚æœ€ç®€å•çš„å®žçŽ°å«åšUDPåè®®ï¼Œå®ƒçš„æ ¼å¼å‡ ä¹Žå°±æ˜¯åœ¨æ•°æ®å‰é¢ï¼ŒåŠ ä¸Šç«¯å£å·ã€‚UDPæ•°æ®åŒ…éžå¸¸ç®€å•ï¼Œâ€æ ‡å¤´â€éƒ¨åˆ†ä¸€å…±åªæœ‰8ä¸ªå­—èŠ‚ï¼Œæ€»é•¿åº¦ä¸è¶…è¿‡65,535å­—èŠ‚ï¼Œæ­£å¥½æ”¾è¿›ä¸€ä¸ªIPæ•°æ®åŒ…ã€‚UDPåè®®çš„ä¼˜ç‚¹æ˜¯æ¯”è¾ƒç®€å•ï¼Œå®¹æ˜“å®žçŽ°ï¼Œä½†æ˜¯ç¼ºç‚¹æ˜¯å¯é æ€§è¾ƒå·®ï¼Œä¸€æ—¦æ•°æ®åŒ…å‘å‡ºï¼Œæ— æ³•çŸ¥é“å¯¹æ–¹æ˜¯å¦æ”¶åˆ°ã€‚ ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæé«˜ç½‘ç»œå¯é æ€§ï¼ŒTCPåè®®å°±è¯žç”Ÿäº†ã€‚è¿™ä¸ªåè®®éžå¸¸å¤æ‚ï¼Œä½†å¯ä»¥è¿‘ä¼¼è®¤ä¸ºï¼Œå®ƒå°±æ˜¯æœ‰ç¡®è®¤æœºåˆ¶çš„UDPåè®®ï¼Œæ¯å‘å‡ºä¸€ä¸ªæ•°æ®åŒ…éƒ½è¦æ±‚ç¡®è®¤ã€‚å¦‚æžœæœ‰ä¸€ä¸ªæ•°æ®åŒ…é—å¤±ï¼Œå°±æ”¶ä¸åˆ°ç¡®è®¤ï¼Œå‘å‡ºæ–¹å°±çŸ¥é“æœ‰å¿…è¦é‡å‘è¿™ä¸ªæ•°æ®åŒ…äº†ã€‚ åº”ç”¨å±‚ â€œåº”ç”¨å±‚â€çš„ä½œç”¨ï¼Œå°±æ˜¯è§„å®šåº”ç”¨ç¨‹åºçš„æ•°æ®æ ¼å¼ã€‚ ä¸¾ä¾‹æ¥è¯´ï¼ŒTCPåè®®å¯ä»¥ä¸ºå„ç§å„æ ·çš„ç¨‹åºä¼ é€’æ•°æ®ï¼Œæ¯”å¦‚Emailã€WWWã€FTPç­‰ç­‰ã€‚é‚£ä¹ˆï¼Œå¿…é¡»æœ‰ä¸åŒåè®®è§„å®šç”µå­é‚®ä»¶ã€ç½‘é¡µã€FTPæ•°æ®çš„æ ¼å¼ï¼Œè¿™äº›åº”ç”¨ç¨‹åºåè®®å°±æž„æˆäº†â€åº”ç”¨å±‚â€ã€‚ ç”¨æˆ·çš„ä¸Šç½‘è®¾ç½® 1234 * æœ¬æœºçš„IPåœ°å€ * å­ç½‘æŽ©ç  * ç½‘å…³çš„IPåœ°å€ * DNSçš„IPåœ°å€ æ‰€è°“â€åŠ¨æ€IPåœ°å€â€ï¼ŒæŒ‡è®¡ç®—æœºå¼€æœºåŽï¼Œä¼šè‡ªåŠ¨åˆ†é…åˆ°ä¸€ä¸ªIPåœ°å€ï¼Œä¸ç”¨äººä¸ºè®¾å®šã€‚å®ƒä½¿ç”¨çš„åè®®å«åšDHCPåè®®ã€‚é¦–å…ˆï¼Œå®ƒæ˜¯ä¸€ç§åº”ç”¨å±‚åè®®ï¼Œå»ºç«‹åœ¨UDPåè®®ä¹‹ä¸Šã€‚ æˆ‘ä»¬çŸ¥é“ï¼Œå‘é€æ•°æ®åŒ…ï¼Œå¿…é¡»è¦çŸ¥é“å¯¹æ–¹çš„IPåœ°å€ã€‚ä½†æ˜¯ï¼ŒçŽ°åœ¨ï¼Œæˆ‘ä»¬åªçŸ¥é“ç½‘å€www.google.comï¼Œä¸çŸ¥é“å®ƒçš„IPåœ°å€ã€‚DNSåè®®å¯ä»¥å¸®åŠ©æˆ‘ä»¬ï¼Œå°†è¿™ä¸ªç½‘å€è½¬æ¢æˆIPåœ°å€ã€‚å·²çŸ¥DNSæœåŠ¡å™¨ä¸º8.8.8.8ï¼ŒäºŽæ˜¯æˆ‘ä»¬å‘è¿™ä¸ªåœ°å€å‘é€ä¸€ä¸ªDNSæ•°æ®åŒ…ï¼ˆ53ç«¯å£ï¼‰ã€‚TCPæ•°æ®åŒ…çš„æ ‡å¤´é•¿åº¦ä¸º20å­—èŠ‚ï¼ŒåŠ ä¸ŠåµŒå…¥HTTPçš„æ•°æ®åŒ…ï¼Œæ€»é•¿åº¦å˜ä¸º4980å­—èŠ‚ã€‚ IPæ•°æ®åŒ…çš„æ ‡å¤´é•¿åº¦ä¸º20å­—èŠ‚ï¼ŒåŠ ä¸ŠåµŒå…¥çš„TCPæ•°æ®åŒ…ï¼Œæ€»é•¿åº¦å˜ä¸º5000å­—èŠ‚ã€‚ ä»¥å¤ªç½‘æ•°æ®åŒ…çš„æ•°æ®éƒ¨åˆ†ï¼Œæœ€å¤§é•¿åº¦ä¸º1500å­—èŠ‚ï¼Œè€ŒçŽ°åœ¨çš„IPæ•°æ®åŒ…é•¿åº¦ä¸º5000å­—èŠ‚ã€‚å› æ­¤ï¼ŒIPæ•°æ®åŒ…å¿…é¡»åˆ†å‰²æˆå››ä¸ªåŒ…ã€‚å› ä¸ºæ¯ä¸ªåŒ…éƒ½æœ‰è‡ªå·±çš„IPæ ‡å¤´ï¼ˆ20å­—èŠ‚ï¼‰ï¼Œæ‰€ä»¥å››ä¸ªåŒ…çš„IPæ•°æ®åŒ…çš„é•¿åº¦åˆ†åˆ«ä¸º1500ã€1500ã€1500ã€560ã€‚ æµè§ˆç½‘é¡µç”¨çš„æ˜¯HTTPåè®® TCPæ•°æ®åŒ…éœ€è¦è®¾ç½®ç«¯å£ï¼ŒæŽ¥æ”¶æ–¹ï¼ˆGoogleï¼‰çš„HTTPç«¯å£é»˜è®¤æ˜¯80ï¼Œå‘é€æ–¹ï¼ˆæœ¬æœºï¼‰çš„ç«¯å£æ˜¯ä¸€ä¸ªéšæœºç”Ÿæˆçš„1024-65535ä¹‹é—´çš„æ•´æ•°ï¼Œå‡å®šä¸º51775ã€‚ è¿™ä¸¤ç¯‡æ–‡ç« æ˜¯å¯ä»¥ç»™ä½ ä¸€ä¸ªoverviewçš„ã€‚ äº’è”ç½‘åè®®å…¥é—¨ï¼ˆä¸€ï¼‰äº’è”ç½‘åè®®å…¥é—¨ï¼ˆäºŒï¼‰ åœ°å€è§£æžåè®®ï¼Œå³ARPï¼ˆAddress Resolution Protocolï¼‰ï¼Œæ˜¯æ ¹æ®IPåœ°å€èŽ·å–ç‰©ç†åœ°å€çš„ä¸€ä¸ªTCP/IPåè®®ã€‚ä¸»æœºå‘é€æ¶ˆæ¯æ—¶å°†åŒ…å«ç›®æ ‡IPåœ°å€çš„ARPè¯·æ±‚å¹¿æ’­é“ç½‘ç»œä¸Šçš„æ‰€æœ‰ä¸»æœºï¼Œå¹¶æŽ¥å—è¿”å›žæ¶ˆæ¯ï¼Œä»¥æ­¤ç¡®å®šç›®æ ‡çš„ç‰©ç†åœ°å€ï¼›æ”¶åˆ°è¿”å›žæ¶ˆæ¯åŽå°†è¯¥IPåœ°å€å’Œç‰©ç†åœ°å€å­˜å…¥æœ¬æœºARPç¼“å­˜ä¸­å¹¶ä¿ç•™ä¸€å®šæ—¶é—´ï¼Œä¸‹æ¬¡è¯·æ±‚æ—¶ç›´æŽ¥æŸ¥è¯¢ARPç¼“å­˜ä»¥èŠ‚çº¦èµ„æºã€‚ARPå‘½ä»¤å¯ç”¨äºŽæŸ¥è¯¢æœ¬æœºARPç¼“å­˜ä¸­IPåœ°å€å’ŒMACåœ°å€çš„å¯¹åº”å…³ç³»ã€æ·»åŠ æˆ–åˆ é™¤é™æ€å¯¹åº”å…³ç³»ç­‰ã€‚RARPåè®®ï¼šé€†åœ°å€è§£æžåè®®ï¼Œå³RARPï¼ŒåŠŸèƒ½å’ŒARPåè®®ç›¸å¯¹ï¼Œå…¶å°†å±€åŸŸç½‘ä¸­æŸä¸ªä¸»æœºçš„ç‰©ç†åœ°å€è½¬æ¢ä¸ºIPåœ°å€ å¸¸è§çš„è·¯ç”±é€‰æ‹©åè®®æœ‰ï¼šRIPåè®®ã€OSRFåè®®RIPåè®®ï¼šåº•å±‚æ˜¯è´å°”æ›¼ç¦ç‰¹ç®—æ³•ï¼Œå®ƒé€‰æ‹©è·¯ç”±çš„åº¦é‡æ ‡å‡†ï¼ˆmetric)æ˜¯è·³æ•°ï¼Œæœ€å¤§è·³æ•°æ˜¯15è·³ï¼Œå¦‚æžœå¤§äºŽ15è·³ï¼Œå®ƒå°±ä¼šä¸¢å¼ƒæ•°æ®åŒ…ã€‚OSPFåè®®ï¼šOpen Shortest Path Firstå¼€æ”¾å¼æœ€çŸ­è·¯å¾„ä¼˜å…ˆï¼Œåº•å±‚æ˜¯è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•ï¼Œæ˜¯é“¾è·¯çŠ¶æ€è·¯ç”±é€‰æ‹©åè®®ï¼Œå®ƒé€‰æ‹©è·¯ç”±çš„åº¦é‡æ ‡å‡†æ˜¯å¸¦å®½ï¼Œå»¶è¿Ÿã€‚ TCP/IPåè®®æ˜¯Internetæœ€åŸºæœ¬çš„åè®®ã€Internetå›½é™…äº’è”ç½‘ç»œçš„åŸºç¡€ï¼Œç”±ç½‘ç»œå±‚çš„IPåè®®å’Œä¼ è¾“å±‚çš„TCPåè®®ç»„æˆã€‚é€šä¿—è€Œè¨€ï¼šTCPè´Ÿè´£å‘çŽ°ä¼ è¾“çš„é—®é¢˜ï¼Œä¸€æœ‰é—®é¢˜å°±å‘å‡ºä¿¡å·ï¼Œè¦æ±‚é‡æ–°ä¼ è¾“ï¼Œç›´åˆ°æ‰€æœ‰æ•°æ®å®‰å…¨æ­£ç¡®åœ°ä¼ è¾“åˆ°ç›®çš„åœ°ã€‚è€ŒIPæ˜¯ç»™å› ç‰¹ç½‘çš„æ¯ä¸€å°è”ç½‘è®¾å¤‡è§„å®šä¸€ä¸ªåœ°å€ã€‚ä½¿ç”¨TCP/IP åè®®çš„åŒ…æ‹¬ï¼šFTPï¼ˆæ–‡ä»¶ä¼ è¾“åè®®ï¼‰ã€Telnetï¼ˆè¿œç¨‹ç™»å½•åè®®ï¼‰ã€SMTPï¼ˆç®€å•é‚®ä»¶ä¼ è¾“åè®®ï¼‰ã€POP3ï¼ˆå’ŒSMTPç›¸å¯¹ï¼Œç”¨äºŽæŽ¥æ”¶é‚®ä»¶ï¼‰ã€HTTPåè®®ç­‰ã€‚ UDPç”¨æˆ·æ•°æ®æŠ¥åè®®ï¼Œæ˜¯é¢å‘æ— è¿žæŽ¥çš„é€šè®¯åè®®ï¼ŒUDPæ•°æ®åŒ…æ‹¬ç›®çš„ç«¯å£å·å’Œæºç«¯å£å·ä¿¡æ¯ï¼Œç”±äºŽé€šè®¯ä¸éœ€è¦è¿žæŽ¥ï¼Œæ‰€ä»¥å¯ä»¥å®žçŽ°å¹¿æ’­å‘é€ã€‚UDPé€šè®¯æ—¶ä¸éœ€è¦æŽ¥æ”¶æ–¹ç¡®è®¤ï¼Œå±žäºŽä¸å¯é çš„ä¼ è¾“ï¼Œå¯èƒ½ä¼šå‡ºçŽ°ä¸¢åŒ…çŽ°è±¡ï¼Œå®žé™…åº”ç”¨ä¸­è¦æ±‚ç¨‹åºå‘˜ç¼–ç¨‹éªŒè¯ã€‚ä½¿ç”¨UDPåè®®åŒ…æ‹¬ï¼šTFTPï¼ˆç®€å•æ–‡ä»¶ä¼ è¾“åè®®ï¼‰ã€SNMPï¼ˆç®€å•ç½‘ç»œç®¡ç†åè®®ï¼‰ã€DNSï¼ˆåŸŸåè§£æžåè®®ï¼‰ã€NFSã€BOOTP TCPä¸ŽUDPçš„åŒºåˆ«ï¼šTCPæ˜¯é¢å‘è¿žæŽ¥çš„ï¼Œå¯é çš„å­—èŠ‚æµæœåŠ¡ï¼›UDPæ˜¯é¢å‘æ— è¿žæŽ¥çš„ï¼Œä¸å¯é çš„æ•°æ®æŠ¥æœåŠ¡ DNSæ˜¯åŸŸåç³»ç»Ÿ(DomainNameSystem)çš„ç¼©å†™ï¼Œè¯¥ç³»ç»Ÿç”¨äºŽå‘½åç»„ç»‡åˆ°åŸŸå±‚æ¬¡ç»“æž„ä¸­çš„è®¡ç®—æœºå’Œç½‘ç»œæœåŠ¡ï¼Œå¯ä»¥ç®€å•åœ°ç†è§£ä¸ºå°†URLè½¬æ¢ä¸ºIPåœ°å€ã€‚åŸŸåæ˜¯ç”±åœ†ç‚¹åˆ†å¼€ä¸€ä¸²å•è¯æˆ–ç¼©å†™ç»„æˆçš„ï¼Œæ¯ä¸€ä¸ªåŸŸåéƒ½å¯¹åº”ä¸€ä¸ªæƒŸä¸€çš„IPåœ°å€ï¼Œåœ¨Internetä¸ŠåŸŸåä¸ŽIPåœ°å€ä¹‹é—´æ˜¯ä¸€ä¸€å¯¹åº”çš„ï¼ŒDNSå°±æ˜¯è¿›è¡ŒåŸŸåè§£æžçš„æœåŠ¡å™¨ã€‚DNSå‘½åç”¨äºŽInternetç­‰TCP/IPç½‘ç»œä¸­ï¼Œé€šè¿‡ç”¨æˆ·å‹å¥½çš„åç§°æŸ¥æ‰¾è®¡ç®—æœºå’ŒæœåŠ¡ã€‚ NATç½‘ç»œåœ°å€è½¬æ¢(Network Address Translation)å±žæŽ¥å…¥å¹¿åŸŸç½‘(WAN)æŠ€æœ¯ï¼Œæ˜¯ä¸€ç§å°†ç§æœ‰ï¼ˆä¿ç•™ï¼‰åœ°å€è½¬åŒ–ä¸ºåˆæ³•IPåœ°å€çš„è½¬æ¢æŠ€æœ¯ï¼Œå®ƒè¢«å¹¿æ³›åº”ç”¨äºŽå„ç§ç±»åž‹InternetæŽ¥å…¥æ–¹å¼å’Œå„ç§ç±»åž‹çš„ç½‘ç»œä¸­ã€‚åŽŸå› å¾ˆç®€å•ï¼ŒNATä¸ä»…å®Œç¾Žåœ°è§£å†³äº†lPåœ°å€ä¸è¶³çš„é—®é¢˜ï¼Œè€Œä¸”è¿˜èƒ½å¤Ÿæœ‰æ•ˆåœ°é¿å…æ¥è‡ªç½‘ç»œå¤–éƒ¨çš„æ”»å‡»ï¼Œéšè—å¹¶ä¿æŠ¤ç½‘ç»œå†…éƒ¨çš„è®¡ç®—æœºã€‚ DHCPåŠ¨æ€ä¸»æœºè®¾ç½®åè®®ï¼ˆDynamic Host Configuration Protocolï¼‰æ˜¯ä¸€ä¸ªå±€åŸŸç½‘çš„ç½‘ç»œåè®®ï¼Œä½¿ç”¨UDPåè®®å·¥ä½œï¼Œä¸»è¦æœ‰ä¸¤ä¸ªç”¨é€”ï¼šç»™å†…éƒ¨ç½‘ç»œæˆ–ç½‘ç»œæœåŠ¡ä¾›åº”å•†è‡ªåŠ¨åˆ†é…IPåœ°å€ï¼Œç»™ç”¨æˆ·æˆ–è€…å†…éƒ¨ç½‘ç»œç®¡ç†å‘˜ä½œä¸ºå¯¹æ‰€æœ‰è®¡ç®—æœºä½œä¸­å¤®ç®¡ç†çš„æ‰‹æ®µã€‚ è¶…æ–‡æœ¬ä¼ è¾“åè®®ï¼ˆHTTPï¼ŒHyperText Transfer Protocol)æ˜¯äº’è”ç½‘ä¸Šåº”ç”¨æœ€ä¸ºå¹¿æ³›çš„ä¸€ç§ç½‘ç»œåè®®ã€‚æ‰€æœ‰çš„WWWæ–‡ä»¶éƒ½å¿…é¡»éµå®ˆè¿™ä¸ªæ ‡å‡†ã€‚ åœ¨æµè§ˆå™¨è¾“å…¥www.baidu.comåŽæ‰§è¡Œçš„å…¨éƒ¨è¿‡ç¨‹ï¼ˆæ¯”è¾ƒå¥½çš„è§£é‡Šå¯ä»¥å‚è€ƒ[è¿™é‡Œ](http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html)ï¼‰ 1ï¼‰å®¢æˆ·ç«¯æµè§ˆå™¨é€šè¿‡DNSè§£æžåˆ°www.baidu.comçš„IPåœ°å€220.181.27.48ï¼Œé€šè¿‡è¿™ä¸ªIPåœ°å€æ‰¾åˆ°å®¢æˆ·ç«¯åˆ°æœåŠ¡å™¨çš„è·¯å¾„ã€‚å®¢æˆ·ç«¯æµè§ˆå™¨å‘èµ·ä¸€ä¸ªHTTPä¼šè¯åˆ°220.161.27.48ï¼Œç„¶åŽé€šè¿‡TCPè¿›è¡Œå°è£…æ•°æ®åŒ…ï¼Œè¾“å…¥åˆ°ç½‘ç»œå±‚ã€‚ 2ï¼‰åœ¨å®¢æˆ·ç«¯çš„ä¼ è¾“å±‚ï¼ŒæŠŠHTTPä¼šè¯è¯·æ±‚åˆ†æˆæŠ¥æ–‡æ®µï¼Œæ·»åŠ æºå’Œç›®çš„ç«¯å£ï¼Œå¦‚æœåŠ¡å™¨ä½¿ç”¨80ç«¯å£ç›‘å¬å®¢æˆ·ç«¯çš„è¯·æ±‚ï¼Œå®¢æˆ·ç«¯ç”±ç³»ç»Ÿéšæœºé€‰æ‹©ä¸€ä¸ªç«¯å£å¦‚5000ï¼Œä¸ŽæœåŠ¡å™¨è¿›è¡Œäº¤æ¢ï¼ŒæœåŠ¡å™¨æŠŠç›¸åº”çš„è¯·æ±‚è¿”å›žç»™å®¢æˆ·ç«¯çš„5000ç«¯å£ã€‚ç„¶åŽä½¿ç”¨IPå±‚çš„IPåœ°å€æŸ¥æ‰¾ç›®çš„ç«¯ã€‚ 3ï¼‰å®¢æˆ·ç«¯çš„ç½‘ç»œå±‚ä¸ç”¨å…³ç³»åº”ç”¨å±‚æˆ–è€…ä¼ è¾“å±‚çš„ä¸œè¥¿ï¼Œä¸»è¦åšçš„æ˜¯é€šè¿‡æŸ¥æ‰¾è·¯ç”±è¡¨ç¡®å®šå¦‚ä½•åˆ°è¾¾æœåŠ¡å™¨ï¼ŒæœŸé—´å¯èƒ½ç»è¿‡å¤šä¸ªè·¯ç”±å™¨ï¼Œè¿™äº›éƒ½æ˜¯ç”±è·¯ç”±å™¨æ¥å®Œæˆçš„å·¥ä½œï¼Œä¸ä½œè¿‡å¤šçš„æè¿°ï¼Œæ— éžå°±æ˜¯é€šè¿‡æŸ¥æ‰¾è·¯ç”±è¡¨å†³å®šé€šè¿‡é‚£ä¸ªè·¯å¾„åˆ°è¾¾æœåŠ¡å™¨ã€‚ 4ï¼‰å®¢æˆ·ç«¯çš„é“¾è·¯å±‚ï¼ŒåŒ…é€šè¿‡é“¾è·¯å±‚å‘é€åˆ°è·¯ç”±å™¨ï¼Œé€šè¿‡é‚»å±…åè®®æŸ¥æ‰¾ç»™å®šIPåœ°å€çš„MACåœ°å€ï¼Œç„¶åŽå‘é€ARPè¯·æ±‚æŸ¥æ‰¾ç›®çš„åœ°å€ï¼Œå¦‚æžœå¾—åˆ°å›žåº”åŽå°±å¯ä»¥ä½¿ç”¨ARPçš„è¯·æ±‚åº”ç­”äº¤æ¢çš„IPæ•°æ®åŒ…çŽ°åœ¨å°±å¯ä»¥ä¼ è¾“äº†ï¼Œç„¶åŽå‘é€IPæ•°æ®åŒ…åˆ°è¾¾æœåŠ¡å™¨çš„åœ°å€ã€‚ äº’è”ç½‘çš„æœ¬è´¨å°±æ˜¯ä¸€ç³»åˆ—çš„ç½‘ç»œåè®® æ•°æ®å°±æ˜¯è¿™æ ·åœ¨è®¡ç®—æœºå’Œç½‘ç»œä¸­è¿›è¡Œä¼ é€’çš„ã€‚è¿™å…¶ä¸­åšçš„å·¥ä½œå°±æ˜¯æ¯å±‚è¿›è¡Œå±‚å±‚è§£åŒ…å’Œé™„åŠ è‡ªå·±æ‰€è¦ä¼ é€’çš„ä¿¡æ¯ï¼Œæœ¯è¯­å«åšæŠ¥å¤´ã€‚åœ¨å››å±‚ï¼Œæ—¢ä¼ è¾“å±‚æ•°æ®è¢«ç§°ä½œæ®µï¼ˆSegmentsï¼‰ï¼›ä¸‰å±‚ç½‘ç»œå±‚æ•°æ®è¢«ç§°åšåŒ…ï¼ˆPackagesï¼‰ï¼›äºŒå±‚æ•°æ®é“¾è·¯å±‚æ—¶æ•°æ®è¢«ç§°ä¸ºå¸§ï¼ˆFramesï¼‰ï¼›ä¸€å±‚ç‰©ç†å±‚æ—¶æ•°æ®è¢«ç§°ä¸ºæ¯”ç‰¹æµï¼ˆBitsï¼‰ã€‚ TCP/IP æ¨¡åž‹å°† OSI æ¨¡åž‹ç”±ä¸ƒå±‚ç®€åŒ–ä¸ºå››å±‚ï¼Œä¼ è¾“å±‚å’Œç½‘ç»œå±‚è¢«å®Œæ•´ä¿ç•™ï¼Œå› æ­¤ç½‘ç»œä¸­æœ€æ ¸å¿ƒçš„æŠ€æœ¯å°±æ˜¯ä¼ è¾“å±‚å’Œç½‘ç»œå±‚æŠ€æœ¯ã€‚TCP/IP åè®®ä¸­æ¯å±‚æŠ€æœ¯ä¸¾ä¾‹ï¼šç½‘ç»œè®¿é—®å±‚ï¼šARPã€RARPäº’è”ç½‘å±‚ï¼šICMPã€IPä¼ è¾“å±‚ï¼šTCPã€UDPåº”ç”¨å±‚ï¼šDNSã€FTPã€HTTPã€SMTPã€TELNETã€IRCã€WHOIS äº¤æ¢æœºæ˜¯ä¸€ç§åŸºäºŽMACåœ°å€è¯†åˆ«ï¼Œèƒ½å®Œæˆå°è£…è½¬å‘æ•°æ®åŒ…åŠŸèƒ½çš„ç½‘ç»œè®¾å¤‡ã€‚äº¤æ¢æœºå¯ä»¥â€œå­¦ä¹ â€MACåœ°å€ï¼Œå¹¶æŠŠå…¶å­˜æ”¾åœ¨å†…éƒ¨åœ°å€è¡¨ä¸­ï¼Œé€šè¿‡åœ¨æ•°æ®å¸§çš„å§‹å‘è€…å’Œç›®æ ‡æŽ¥æ”¶è€…ä¹‹é—´å»ºç«‹ä¸´æ—¶çš„äº¤æ¢è·¯å¾„ï¼Œä½¿æ•°æ®å¸§ç›´æŽ¥ç”±æºåœ°å€åˆ°è¾¾ç›®çš„åœ°å€ã€‚ç½‘ç»œä¸ƒå±‚æ¨¡åž‹æ˜¯ä¸€ä¸ªæ ‡å‡†ï¼Œè€Œéžå®žçŽ°ã€‚ ç½‘ç»œå››å±‚æ¨¡åž‹æ˜¯ä¸€ä¸ªå®žçŽ°çš„åº”ç”¨æ¨¡åž‹ã€‚ ç½‘ç»œå››å±‚æ¨¡åž‹ç”±ä¸ƒå±‚æ¨¡åž‹ç®€åŒ–åˆå¹¶è€Œæ¥ã€‚ TCPæ”¯æŒçš„åº”ç”¨åè®®ä¸»è¦æœ‰ï¼šTelnetã€FTPã€SMTPç­‰;UDPæ”¯æŒçš„åº”ç”¨å±‚åè®®ä¸»è¦æœ‰ï¼šNFS(ç½‘ç»œæ–‡ä»¶ç³»ç»Ÿ)ã€SNMP(ç®€å•ç½‘ç»œç®¡ç†åè®®)ã€DNS(ä¸»åŸŸåç§°ç³»ç»Ÿ)ã€TFTP(é€šç”¨æ–‡ä»¶ä¼ è¾“åè®®)ç­‰ã€‚ é›†çº¿å™¨ä¸Žè·¯ç”±å™¨åœ¨åŠŸèƒ½ä¸Šæœ‰ä»€ä¹ˆä¸åŒ? é¦–å…ˆè¯´HUB,ä¹Ÿå°±æ˜¯é›†çº¿å™¨ã€‚å®ƒçš„ä½œç”¨å¯ä»¥ç®€å•çš„ç†è§£ä¸ºå°†ä¸€äº›æœºå™¨è¿žæŽ¥èµ·æ¥ç»„æˆä¸€ä¸ªå±€åŸŸç½‘ã€‚è€Œäº¤æ¢æœºï¼ˆåˆåäº¤æ¢å¼é›†çº¿å™¨ï¼‰ä½œç”¨ä¸Žé›†çº¿å™¨å¤§ä½“ç›¸åŒã€‚ä½†æ˜¯ä¸¤è€…åœ¨æ€§èƒ½ä¸Šæœ‰åŒºåˆ«ï¼šé›†çº¿å™¨é‡‡ç”¨çš„å¼å…±äº«å¸¦å®½çš„å·¥ä½œæ–¹å¼ï¼Œè€Œäº¤æ¢æœºæ˜¯ç‹¬äº«å¸¦å®½ã€‚è¿™æ ·åœ¨æœºå™¨å¾ˆå¤šæˆ–æ•°æ®é‡å¾ˆå¤§æ—¶ï¼Œä¸¤è€…å°†ä¼šæœ‰æ¯”è¾ƒæ˜Žæ˜¾çš„ã€‚è€Œè·¯ç”±å™¨ä¸Žä»¥ä¸Šä¸¤è€…æœ‰æ˜Žæ˜¾åŒºåˆ«ï¼Œå®ƒçš„ä½œç”¨åœ¨äºŽè¿žæŽ¥ä¸åŒçš„ç½‘æ®µå¹¶ä¸”æ‰¾åˆ°ç½‘ç»œä¸­æ•°æ®ä¼ è¾“æœ€åˆé€‚çš„è·¯å¾„ã€‚è·¯ç”±å™¨æ˜¯äº§ç”ŸäºŽäº¤æ¢æœºä¹‹åŽï¼Œå°±åƒäº¤æ¢æœºäº§ç”ŸäºŽé›†çº¿å™¨ä¹‹åŽï¼Œæ‰€ä»¥è·¯ç”±å™¨ä¸Žäº¤æ¢æœºä¹Ÿæœ‰ä¸€å®šè”ç³»ï¼Œä¸æ˜¯å®Œå…¨ç‹¬ç«‹çš„ä¸¤ç§è®¾å¤‡ã€‚è·¯ç”±å™¨ä¸»è¦å…‹æœäº†äº¤æ¢æœºä¸èƒ½è·¯ç”±è½¬å‘æ•°æ®åŒ…çš„ä¸è¶³ã€‚ æ€»çš„æ¥è¯´ï¼Œè·¯ç”±å™¨ä¸Žäº¤æ¢æœºçš„ä¸»è¦åŒºåˆ«ä½“çŽ°åœ¨ä»¥ä¸‹å‡ ä¸ªæ–¹é¢ï¼š ï¼ˆ1ï¼‰å·¥ä½œå±‚æ¬¡ä¸åŒæœ€åˆçš„çš„äº¤æ¢æœºæ˜¯å·¥ä½œåœ¨æ•°æ®é“¾è·¯å±‚ï¼Œè€Œè·¯ç”±å™¨ä¸€å¼€å§‹å°±è®¾è®¡å·¥ä½œåœ¨ç½‘ç»œå±‚ã€‚ç”±äºŽäº¤æ¢æœºå·¥ä½œåœ¨æ•°æ®é“¾è·¯å±‚ï¼Œæ‰€ä»¥å®ƒçš„å·¥ä½œåŽŸç†æ¯”è¾ƒç®€å•ï¼Œè€Œè·¯ç”±å™¨å·¥ä½œåœ¨ç½‘ç»œå±‚ï¼Œå¯ä»¥å¾—åˆ°æ›´å¤šçš„åè®®ä¿¡æ¯ï¼Œè·¯ç”±å™¨å¯ä»¥åšå‡ºæ›´åŠ æ™ºèƒ½çš„è½¬å‘å†³ç­–ã€‚ ï¼ˆ2ï¼‰æ•°æ®è½¬å‘æ‰€ä¾æ®çš„å¯¹è±¡ä¸åŒäº¤æ¢æœºæ˜¯åˆ©ç”¨ç‰©ç†åœ°å€æˆ–è€…è¯´MACåœ°å€æ¥ç¡®å®šè½¬å‘æ•°æ®çš„ç›®çš„åœ°å€ã€‚è€Œè·¯ç”±å™¨åˆ™æ˜¯åˆ©ç”¨IPåœ°å€æ¥ç¡®å®šæ•°æ®è½¬å‘çš„åœ°å€ã€‚IPåœ°å€æ˜¯åœ¨è½¯ä»¶ä¸­å®žçŽ°çš„ï¼Œæè¿°çš„æ˜¯è®¾å¤‡æ‰€åœ¨çš„ç½‘ç»œã€‚MACåœ°å€é€šå¸¸æ˜¯ç¡¬ä»¶è‡ªå¸¦çš„ï¼Œç”±ç½‘å¡ç”Ÿäº§å•†æ¥åˆ†é…çš„ï¼Œè€Œä¸”å·²ç»å›ºåŒ–åˆ°äº†ç½‘å¡ä¸­åŽ»ï¼Œä¸€èˆ¬æ¥è¯´æ˜¯ä¸å¯æ›´æ”¹çš„ã€‚è€ŒIPåœ°å€åˆ™é€šå¸¸ç”±ç½‘ç»œç®¡ç†å‘˜æˆ–ç³»ç»Ÿè‡ªåŠ¨åˆ†é…ã€‚ ï¼ˆ3ï¼‰ä¼ ç»Ÿçš„äº¤æ¢æœºåªèƒ½åˆ†å‰²å†²çªåŸŸï¼Œä¸èƒ½åˆ†å‰²å¹¿æ’­åŸŸï¼›è€Œè·¯ç”±å™¨å¯ä»¥åˆ†å‰²å¹¿æ’­åŸŸç”±äº¤æ¢æœºè¿žæŽ¥çš„ç½‘æ®µä»å±žäºŽåŒä¸€ä¸ªå¹¿æ’­åŸŸï¼Œå¹¿æ’­æ•°æ®åŒ…ä¼šåœ¨äº¤æ¢æœºè¿žæŽ¥çš„æ‰€æœ‰ç½‘æ®µä¸Šä¼ æ’­ï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ä¼šå¯¼è‡´é€šä¿¡æ‹¥æŒ¤å’Œå®‰å…¨æ¼æ´žã€‚è¿žæŽ¥åˆ°è·¯ç”±å™¨ä¸Šçš„ç½‘æ®µä¼šè¢«åˆ†é…æˆä¸åŒçš„å¹¿æ’­åŸŸï¼Œå¹¿æ’­æ•°æ®ä¸ä¼šç©¿è¿‡è·¯ç”±å™¨ã€‚è™½ç„¶ç¬¬ä¸‰å±‚ä»¥ä¸Šäº¤æ¢æœºå…·æœ‰VLANåŠŸèƒ½ï¼Œä¹Ÿå¯ä»¥åˆ†å‰²å¹¿æ’­åŸŸï¼Œä½†æ˜¯å„å­å¹¿æ’­åŸŸä¹‹é—´æ˜¯ä¸èƒ½é€šä¿¡äº¤æµçš„ï¼Œå®ƒä»¬ä¹‹é—´çš„äº¤æµä»ç„¶éœ€è¦è·¯ç”±å™¨ã€‚ ï¼ˆ4ï¼‰è·¯ç”±å™¨æä¾›äº†é˜²ç«å¢™çš„æœåŠ¡è·¯ç”±å™¨ä»…ä»…è½¬å‘ç‰¹å®šåœ°å€çš„æ•°æ®åŒ…ï¼Œä¸ä¼ é€ä¸æ”¯æŒè·¯ç”±åè®®çš„æ•°æ®åŒ…ä¼ é€å’ŒæœªçŸ¥ç›®æ ‡ç½‘ç»œæ•°æ®åŒ…çš„ä¼ é€ï¼Œä»Žè€Œå¯ä»¥é˜²æ­¢å¹¿æ’­é£Žæš´ã€‚ è½¯ä»¶å·¥ç¨‹é»‘ç›’æµ‹è¯• ç™½ç›’æµ‹è¯• å’Œç°ç›’æµ‹è¯• é»‘ç›’æµ‹è¯•ï¼šä¹Ÿç§°åŠŸèƒ½æµ‹è¯•ã€æ•°æ®é©±åŠ¨æµ‹è¯•ï¼Œå®ƒå°†è¢«æµ‹è½¯ä»¶çœ‹ä½œä¸€ä¸ªæ‰“ä¸å¼€çš„é»‘ç›’ï¼Œä¸»è¦æ ¹æ®åŠŸèƒ½éœ€æ±‚è®¾è®¡æµ‹è¯•ç”¨ä¾‹ï¼Œè¿›è¡Œæµ‹è¯•ã€‚ å¸¸ç”¨çš„æ–¹æ³•ï¼š ç­‰ä»·ç±»åˆ’åˆ†æ³•ç­‰ä»·ç±»åˆ’åˆ†æ³•æ˜¯ä¸€ç§å…¸åž‹çš„ã€é‡è¦çš„é»‘ç›’æµ‹è¯•æ–¹æ³•ï¼Œå®ƒå°†ç¨‹åºæ‰€æœ‰å¯èƒ½çš„è¾“å…¥æ•°æ®åˆ’åˆ†ä¸ºè‹¥å¹²ä¸ªç­‰ä»·ç±»ã€‚ç„¶åŽä»Žæ¯ä¸ªéƒ¨åˆ†ä¸­é€‰å–å…·æœ‰ä»£è¡¨æ€§çš„æ•°æ®å½“åšæµ‹è¯•ç”¨ä¾‹ã€‚æµ‹è¯•ç”¨ä¾‹ç”±æœ‰æ•ˆç­‰ä»·ç±»å’Œæ— æ•ˆç­‰ä»·ç±»çš„ä»£è¡¨æ•°æ®ç»„æˆï¼Œä»Žè€Œä¿è¯æµ‹è¯•ç”¨ä¾‹å…·æœ‰å®Œæ•´æ€§å’Œä»£è¡¨æ€§ã€‚ä½¿ç”¨è¯¥æ–¹æ³•è®¾è®¡æµ‹è¯•ç”¨ä¾‹ä¸»è¦æœ‰ä¸¤ä¸ªæ­¥éª¤ï¼š(1)ç¡®å®šç­‰ä»·ç±»ï¼›(2)ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹ã€‚ è¾¹ç•Œå€¼åˆ†æžæ³•è¾¹ç•Œå€¼åˆ†æžæ³•æ˜¯å¯¹ç¨‹åºè¾“å…¥æˆ–è¾“å‡ºçš„è¾¹ç•Œå€¼è¿›è¡Œæµ‹è¯•çš„ä¸€ç§é»‘ç›’æµ‹è¯•æ–¹æ³•ã€‚å®žé™…çš„æµ‹è¯•å·¥ä½œè¯æ˜Žï¼Œè€ƒè™‘äº†è¾¹ç•Œæ¡ä»¶çš„æµ‹è¯•ç”¨ä¾‹æ¯”é‚£äº›æ²¡æœ‰è€ƒè™‘è¾¹ç•Œæ¡ä»¶çš„æµ‹è¯•ç”¨ä¾‹å…·æœ‰æ›´é«˜çš„æµ‹è¯•å›žæŠ¥çŽ‡ã€‚è¿™é‡Œæ‰€è¯´çš„è¾¹ç•Œæ¡ä»¶ï¼Œæ˜¯æŒ‡è¾“å…¥å’Œè¾“å…¥ç­‰ä»·ç±»ä¸­é‚£äº›æ°å¥½å¤„äºŽè¾¹ç•Œã€æˆ–è¶…è¿‡è¾¹ç•Œã€æˆ–åœ¨è¾¹ç•Œä»¥ä¸‹çš„çŠ¶æ€ã€‚ å› æžœå›¾æ³•å› æžœå›¾æ³•ä¹Ÿæ˜¯è¾ƒå¸¸ç”¨çš„ä¸€ç§é»‘ç›’æµ‹è¯•æ–¹æ³•ï¼Œæ˜¯ä¸€ç§ç®€åŒ–äº†çš„é€»è¾‘å›¾ã€‚å› æžœå›¾èƒ½ç›´è§‚åœ°è¡¨æ˜Žè¾“å…¥æ¡ä»¶å’Œè¾“å‡ºåŠ¨ä½œä¹‹é—´çš„å› æžœå…³ç³»ï¼Œèƒ½å¸®åŠ©æµ‹è¯•äººå‘˜æŠŠæ³¨æ„åŠ›é›†ä¸­åˆ°ä¸Žç¨‹åºåŠŸèƒ½æœ‰å…³çš„è¾“å…¥ç»„åˆä¸Šã€‚å› æžœå›¾æ³•æ˜¯ä¸€ç§é€‚åˆäºŽæè¿°å¯¹äºŽå¤šç§è¾“å…¥æ¡ä»¶ç»„åˆçš„æµ‹è¯•æ–¹æ³•ï¼Œæ ¹æ®è¾“å…¥æ¡ä»¶çš„ç»„åˆã€çº¦æŸå…³ç³»å’Œè¾“å‡ºæ¡ä»¶çš„å› æžœå…³ç³»ï¼Œåˆ†æžè¾“å…¥æ¡ä»¶çš„å„ç§ç»„åˆæƒ…å†µï¼Œä»Žè€Œè®¾è®¡æµ‹è¯•ç”¨ä¾‹çš„æ–¹æ³•ï¼Œå®ƒé€‚åˆäºŽæ£€æŸ¥ç¨‹åºè¾“å…¥æ¡ä»¶çš„å„ç§ç»„åˆæƒ…å†µ é”™è¯¯æŽ¨æµ‹æ³•é”™è¯¯æŽ¨æµ‹æ³•æ˜¯åŸºäºŽä»¥å¾€çš„ç»éªŒå’Œç›´è§‰ï¼Œå‚ç…§ä»¥å¾€çš„è½¯ä»¶ç³»ç»Ÿå‡ºçŽ°çš„é”™è¯¯ï¼ŒæŽ¨æµ‹å½“å‰è¢«æµ‹ç¨‹åºä¸­å¯èƒ½å­˜åœ¨çš„ç¼ºé™·å’Œé”™è¯¯ï¼Œæœ‰é’ˆå¯¹æ€§åœ°è®¾è®¡æµ‹è¯•ç”¨ä¾‹ã€‚ ç­‰ä»·ç±»åˆ’åˆ†æ³•æ˜¯ä¸€ç§å…¸åž‹çš„é»‘ç›’æµ‹è¯•ç”¨ä¾‹è®¾è®¡æ–¹æ³•ã€‚é‡‡ç”¨ç­‰ä»·ç±»åˆ’åˆ†æ³•æ—¶ï¼Œå®Œå…¨ä¸ç”¨è€ƒè™‘ç¨‹åºå†…éƒ¨ç»“æž„ï¼Œè®¾è®¡æµ‹è¯•ç”¨ä¾‹çš„å”¯ä¸€ä¾æ®æ˜¯è½¯ä»¶éœ€æ±‚è§„æ ¼è¯´æ˜Žä¹¦ã€‚æ‰€è°“ç­‰ä»·ç±»ï¼Œæ˜¯è¾“å…¥æ¡ä»¶çš„ä¸€ä¸ªå­é›†åˆï¼Œè¯¥è¾“å…¥é›†åˆä¸­çš„æ•°æ®å¯¹äºŽæ­ç¤ºç¨‹åºä¸­çš„é”™è¯¯æ˜¯ç­‰ä»·çš„ã€‚ç­‰ä»·ç±»åˆåˆ†ä¸ºæœ‰æ•ˆç­‰ä»·ç±»å’Œæ— æ•ˆç­‰ä»·ç±»ã€‚æœ‰æ•ˆç­‰ä»·ç±»ä»£è¡¨å¯¹ç¨‹åºæœ‰æ•ˆçš„è¾“å…¥ï¼Œè€Œæ— æ•ˆç­‰ä»·ç±»åˆ™æ˜¯å…¶ä»–ä»»ä½•å¯èƒ½çš„è¾“å…¥ï¼ˆå³ä¸æ­£ç¡®çš„è¾“å…¥å€¼ï¼‰ã€‚æœ‰æ•ˆç­‰ä»·ç±»å’Œæ— æ•ˆç­‰ä»·ç±»éƒ½æ˜¯ä½¿ç”¨ç­‰ä»·ç±»åˆ’åˆ†æ³•è®¾è®¡ç”¨ä¾‹æ—¶æ‰€å¿…é¡»çš„ï¼Œå› ä¸ºè¢«æµ‹ç¨‹åºè‹¥æ˜¯æ­£ç¡®çš„ï¼Œå°±åº”è¯¥æ—¢èƒ½æŽ¥å—æœ‰æ•ˆçš„è¾“å…¥ï¼Œä¹Ÿèƒ½æŽ¥å—æ— æ•ˆè¾“å…¥çš„è€ƒéªŒã€‚ ç™½ç›’æµ‹è¯•ï¼šä¹Ÿç§°ç»“æž„æµ‹è¯•æˆ–é€»è¾‘é©±åŠ¨æµ‹è¯•ï¼Œå®ƒæ˜¯çŸ¥é“äº§å“å†…éƒ¨å·¥ä½œè¿‡ç¨‹ï¼Œå¯é€šè¿‡æµ‹è¯•æ¥æ£€æµ‹äº§å“å†…éƒ¨åŠ¨ä½œæ˜¯å¦æŒ‰ç…§è§„æ ¼è¯´æ˜Žä¹¦çš„è§„å®šæ­£å¸¸è¿›è¡Œï¼ŒæŒ‰ç…§ç¨‹åºå†…éƒ¨çš„ç»“æž„æµ‹è¯•ç¨‹åºï¼Œæ£€éªŒç¨‹åºä¸­çš„æ¯æ¡é€šè·¯æ˜¯å¦éƒ½æœ‰èƒ½æŒ‰é¢„å®šè¦æ±‚æ­£ç¡®å·¥ä½œï¼Œè€Œä¸é¡¾å®ƒçš„åŠŸèƒ½ã€‚ ç™½ç›’æµ‹è¯•çš„æ–¹æ³•æœ‰ä¸‰ç§ï¼Œä¸€æ˜¯ç¨‹åºç»“æž„åˆ†æžï¼Œæ ¹æ®æºä»£ç å¯ä»¥é¦–å…ˆç»˜åˆ¶ç¨‹åºçš„æµç¨‹å›¾ï¼Œç„¶åŽæ ¹æ®æµç¨‹å›¾åˆ†æžç¨‹åºçš„ç»“æž„ã€‚äºŒæ˜¯é€»è¾‘è¦†ç›–æ–¹æµ‹è¯•ï¼Œæ ¹æ®ç¨‹åºçš„å†…éƒ¨ç»“æž„ï¼Œå¯¹æ‰€æœ‰çš„è·¯å¾„è¿›è¡Œæµ‹è¯•ï¼Œæ˜¯ä¸€ç§ç©·ä¸¾è·¯å¾„çš„æµ‹è¯•æ–¹æ³•ã€‚ä¸‰æ˜¯åŸºæœ¬è·¯å¾„æµ‹è¯•ï¼Œæ ¹æ®ç¨‹åºçš„é€»è¾‘åˆ¤æ–­ï¼Œåˆ†æžç¨‹åºä¸­çš„è·¯å¾„ï¼Œå†è¿›è¡Œç”¨ä¾‹çš„è®¾è®¡ã€‚ ç°ç›’æµ‹è¯•ï¼Œç¡®å®žæ˜¯ä»‹äºŽäºŒè€…ä¹‹é—´çš„ï¼Œå¯ä»¥è¿™æ ·ç†è§£ï¼Œç°ç›’æµ‹è¯•å…³æ³¨è¾“å‡ºå¯¹äºŽè¾“å…¥çš„æ­£ç¡®æ€§ï¼ŒåŒæ—¶ä¹Ÿå…³æ³¨å†…éƒ¨è¡¨çŽ°ï¼Œä½†è¿™ç§å…³æ³¨ä¸è±¡ç™½ç›’é‚£æ ·è¯¦ç»†ã€å®Œæ•´ï¼Œåªæ˜¯é€šè¿‡ä¸€äº›è¡¨å¾æ€§çš„çŽ°è±¡ã€äº‹ä»¶ã€æ ‡å¿—æ¥åˆ¤æ–­å†…éƒ¨çš„è¿è¡ŒçŠ¶æ€ï¼Œæœ‰æ—¶å€™è¾“å‡ºæ˜¯æ­£ç¡®çš„ï¼Œä½†å†…éƒ¨å…¶å®žå·²ç»é”™è¯¯äº†ï¼Œè¿™ç§æƒ…å†µéžå¸¸å¤šï¼Œå¦‚æžœæ¯æ¬¡éƒ½é€šè¿‡ç™½ç›’æµ‹è¯•æ¥æ“ä½œï¼Œæ•ˆçŽ‡ä¼šå¾ˆä½Žï¼Œå› æ­¤éœ€è¦é‡‡å–è¿™æ ·çš„ä¸€ç§ç°ç›’çš„æ–¹æ³•ã€‚]]></content>
      <categories>
        <category>CSåŸºç¡€</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode string]]></title>
    <url>%2F2019%2F05%2F24%2Fleetcode-string%2F</url>
    <content type="text"><![CDATA[cout and say 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;string cout_and_say(int n)&#123; string res ="1"; // è¿™ä¸ªåˆå§‹åŒ–æ„å‘³ç€éœ€è¦å°‘å¾ªçŽ¯ä¸€æ¬¡ï¼Œ while ( --n ) &#123; string tmp; for(int i =0; i&lt; res.size() ; i++) &#123; int j =i; // å¸¸ç”¨çš„ä¸€ç§éåŽ†æ‰‹æ®µ while(j &lt; res.size() &amp;&amp; res[j] ==res[i]) j +=1; tmp =to_string(j -i) +res[i]; i =j -1; &#125; res =tmp; &#125; return res;&#125;int main()&#123; int n ; cin &gt;&gt;n; string res =cout_and_say(n); for(auto u: res) cout &lt;&lt; u; cout &lt;&lt; endl; return 0;&#125; group anagrams sort å‡½æ•°æ˜¯ in-place() çš„æ“ä½œã€‚ 12345678910111213141516171819class Solution &#123;public: // æ€è·¯å¾ˆç®€å•ï¼Œ å…ˆæ˜¯æ”¾åˆ°ä¸€ä¸ª hashï¼Œç„¶åŽå†éåŽ†ä¸€édictionary vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; unordered_map&lt;string, vector&lt;string&gt;&gt; hash; for(auto str : strs) &#123; string key =str;// sort å‡½æ•°æ˜¯ in-place() çš„æ“ä½œ sort(key.begin(), key.end()); hash[key].push_back(str); &#125; vector&lt;vector&lt;string&gt;&gt; res ; for (auto item : hash) &#123; res.push_back(item.second); &#125; return res; &#125;&#125;; reverse words in a sting LeetCodeé¢˜ç›®é“¾æŽ¥ c++ ä¸­ç»å¤§éƒ¨åˆ†éƒ½æ˜¯å·¦é—­å³å¼€ï¼Œ æ¯”å¦‚è¯´reverse() . 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;string reverse_string(string str)&#123; string res; int n =str.size() ; int k =0; for(int i =0; i&lt; n; i++) &#123; while (i &lt; n &amp;&amp; str[i] ==' ') i ++; if (i &gt; n) break; int j =i ; while(j &lt; n &amp;&amp; str[j] != ' ') j ++; reverse(str.begin() +i, str.begin() +j); if(k ) str[k ++] =' '; // èµ‹å€¼å›žæ¥, è¿™ä¸ªè¯­å¥æ˜¯éžå¸¸ç§’çš„, æŠŠ i çš„index è¡¥å……äº†å›žæ¥ while(i &lt; j) str[k ++] =str[i ++]; &#125; str.erase(str.begin() +k , str.end()); reverse(str.begin(), str.end()); return str;&#125;int main()&#123; string input =" the sky is blue"; string res =reverse_string(input); for(auto u : res) cout&lt;&lt; u; cout &lt;&lt; endl; return 0;&#125; compare-version-numbers 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int cmpVersion(string str1, string str2)&#123; int n =str1.size() , m = str2.size(); int i =0, j =0; while(i &lt; n || j &lt; m) &#123; int x =i, y =j; while( x&lt; n &amp;&amp; str1[x] != '.') x ++; while( y&lt; m &amp;&amp; str2[y ] != '.') y ++; int sum1 = x ==i ? 0 : atoi(str1.substr(i, x -i).c_str()); int sum2 = x ==j ? 0: atoi(str2.substr(j, y -j).c_str()); i =x +1, j = y +1; if(sum1&lt; sum2) return -1; if (sum1 &gt; sum2) return 1; &#125; return 0;&#125;int main()&#123; string str1; // 0.1 string str2; //1.1 getline(cin, str1); getline(cin, str2); cout&lt;&lt; cmpVersion(str1, str2)&lt;&lt; endl; return 0;&#125; Unique Email Addresses è¿™é‡Œç»™å‡ºäº†ä¸€ç§å¦‚ä½•åŽ»è¯»å…¥ vectorï¼Œæœ€ç®€å•çš„æ–¹æ³•å°±æ˜¯å¤šå®šä¹‰ä¸€ä¸ªå¾ªçŽ¯ï¼Œè¿™æ ·çš„è¯å°±å¯ä»¥å®Œæ•´çš„è¯»å…¥æ‰€æœ‰çš„stringï¼Œå¯èƒ½å†æœ€åŽçš„ç»“æžœä¸­æœ‰ +1 æˆ–è€… -1 çš„æ“ä½œã€‚æœ€åŽçœ‹æ•ˆæžœï¼Œç¨å¾®çŒœæµ‹æŽ¨ä¸€ä¸‹ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;unordered_set&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;// æ¯”è¾ƒç®€å• ï¼Œåˆ†æˆ name å’Œ domain ä¸¤ä¸ªæ–¹é¢è¿›è¡Œå¤„ç†int numUniqueEmails(vector&lt;string&gt; emails)&#123; unordered_set&lt;string&gt; hash; for(auto email: emails) &#123; int at =email.find("@"); string name =email.substr(0, at); // å†™æˆ email.begin() å§ string domain =email.substr(at +1);// é»˜è®¤æ˜¯åˆ°æœ€åŽçš„ï¼Œå¦‚æžœåªæ˜¯æœ‰ä¸€ä¸ªå‚æ•°çš„è¯ string tmp; for(auto ch : name) &#123; if (ch =='+') break; else if(ch != '.') tmp += ch; &#125; string res =tmp+'@'+ domain; hash.insert(res); &#125; return hash.size()-1;&#125;int main()&#123; //vector&lt;string&gt; emails=&#123;"a@a.com", "b@b.com"&#125;; vector&lt;string&gt; emails; // å¯¹äºŽå­—ç¬¦ä¸² æ•°ç»„çš„è¾“å…¥æ˜¯ä¸ä¸ä¼šçš„ int n ; cin &gt;&gt; n; n ++; while(n --) &#123; string tmp; getline(cin, tmp); emails.push_back(tmp); &#125; cout &lt;&lt; numUniqueEmails(emails)&lt;&lt; endl; return 0;&#125; longest palindromic substring é©¬æ‹‰è½¦ç®—æ³•å¯ä»¥åœ¨ $O(n)$ æ—¶é—´å¤æ‚åº¦ï¼Œä½†åªæ˜¯è§£å†³å›žæ–‡ä¸²é—®é¢˜ï¼Œæ‰€ä»¥å°±ä¸å»ºè®®å­¦ï¼Œå¤ªå±€é™ã€‚ä¸åƒæ˜¯kmp ç®—æ³•ã€‚é€‰å®šä¸€ä¸ªä¸­å¿ƒç‚¹ï¼Œç„¶åŽåˆ†åˆ«å·¦å³è¿›è¡ŒéåŽ†ã€‚è¿˜éœ€è¦è€ƒè™‘å›žæ–‡ä¸²ä¸­çš„å¥‡å¶æ€§çš„é—®é¢˜ã€‚ä½¿ç”¨åŒæŒ‡é’ˆç®—æ³•å°±å¯ä»¥æžå®šçš„ã€‚ 12345678910111213141516171819202122class Solution &#123;public: // æœ€é•¿å›žæ–‡ä¸²ï¼ŒåŒæŒ‡é’ˆç®—æ³•ï¼Œæœ€åŽçš„æ—¶é—´å¤æ‚åº¦æ˜¯O(n^2) // å…ˆæ˜¯æžšä¸¾ä¸­å¿ƒå¯¹ç§°ç‚¹ï¼Œç„¶åŽå‘ç€å·¦å³è¿›è¡Œæ‰©å±• string longestPalindrome(string s) &#123; string res; for(int i =0; i&lt; s.size() ; i++) &#123; // ç„¶åŽåŒæŒ‡é’ˆè¿›è¡Œæ‰©å±•, å¦‚æžœæœ‰å¥‡æ•°ä¸ª for(int j =i, k =i; j&gt;=0 &amp;&amp; k&lt; s.size() &amp;&amp; s[k] ==s[j]; j --, k++) &#123; if( res.size() &lt; k -j +1) res =s.substr(j, k -j +1); &#125; // å¦‚æžœæœ‰å¶æ•°ä¸ª for(int j =i, k =i +1; j&gt;=0 &amp;&amp; k&lt; s.size() &amp;&amp; s[k] ==s[j]; j --, k++) if(res.size() &lt; k-j +1) res =s.substr(j, k -j +1); &#125; return res; &#125;&#125;; zigzag conversion å¥½å¥½ç†è§£ä¸€ä¸‹ï¼Œå½“for å¾ªçŽ¯çš„æ—¶å€™ï¼Œ ç¬¬ä¸‰ä¸ªå‚æ•°å°±æ˜¯ç­‰å·®æ•°åˆ—ä¸­å…¬å·®ã€‚for å¾ªçŽ¯æ˜¯å¯ä»¥æ¨¡æ‹Ÿ ç­‰å·®æ•°åˆ—å’Œç­‰æ¯”æ•°åˆ—çš„ï¼Œåˆå§‹åŒ–ï¼Œåˆ¤åˆ«æ¡ä»¶å’Œæ­¥ä¼æ˜¯èƒ½å¤Ÿå’Œå…¬å·®å…¬æ¯”ç›¸å¯¹åº”çš„ã€‚ 12345678910111213141516171819202122232425262728class Solution &#123;public: // æ‰¾è§„å¾‹çš„é¢˜ç›® // å¦‚æžœæ˜¯é¦–è¡Œå’Œå°¾è¡Œï¼Œå…¬å·®æ˜¯ 2(n -1)ï¼Œ // å¦‚æžœæ˜¯ä¸­é—´è¡Œ, é‚£ä¹ˆæ˜¯ä¸¤ä¸ªäº¤é”™çš„ç­‰å·®æ•°åˆ— string convert(string s, int n) &#123; if (n ==1) return s; string res; for(int i =0; i&lt; n; i++) &#123; if(! i || i ==n-1 ) &#123; for(int j =i; j&lt; s.size(); j += 2*(n -1)) res += s[j]; &#125; else &#123; // ä¸¤ä¸ªäº¤å‰çš„æ•°åˆ—, åªæ˜¯åˆå§‹åŒ–çš„å€¼éœ€è¦æ³¨æ„ä¸€ä¸‹ for(int j =i, k =2*(n-1) -i ; j &lt; s.size() || k &lt; s.size() ; j += 2*(n -1) , k += 2*(n -1) ) &#123; if(j &lt; s.size()) res += s[j]; if(k &lt; s.size() ) res += s[k]; &#125; &#125; &#125; return res; &#125;&#125;; longest substring without repeating characters è¿™é‡Œæœ‰ä¸€ä¸ªé€šç”¨çš„â€œæ»‘åŠ¨çª—å£ + å“ˆå¸Œè¡¨â€ çš„åšæ³•ã€‚ç”±äºŽ $i$, $j$ æœ€å¤šå¢žåŠ  $n$ æ¬¡ï¼Œä¸”hash è¡¨çš„æ’å…¥å’Œæ›´æ–°æ—¶é—´å¤æ‚åº¦æ˜¯$O(1)$ï¼Œ æ‰€ä»¥æ€»çš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(n)$ã€‚ 123456789101112131415class Solution &#123;public: // ä½¿ç”¨åŒæŒ‡é’ˆ + hashè¡¨ int lengthOfLongestSubstring(string s) &#123; unordered_map&lt;char, int&gt; hash; int res =0; for(int i =0, j =0; j&lt; s.size() ; j++) &#123; hash[s[j]] ++; while(hash[s[j]] &gt; 1) hash[s[i++]] --; res =max(res, j -i +1); &#125; return res; &#125;&#125;; implement Trie(Predix Tree) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Trie &#123;public: // ä½¿ç”¨ä¸€ä¸ªç»“æž„ä½“å­˜å‚¨ä¸€ä¸ªç»“ç‚¹ struct Node&#123; bool is_end; Node * son[26]; // è¿™ä¸ªç±»ä¼¼æž„é€ å‡½æ•°ï¼Œæ˜¯å¯¹ç»“æž„ä½“è¿›è¡Œåˆå§‹åŒ– Node() &#123; is_end =false; for(int i=0; i&lt; 26; i++) son[i] =NULL; &#125; &#125;*root; // è¿™ä¸ªæ˜¯ç»“æž„ä½“å˜é‡ /** Initialize your data structure here. */ Trie() &#123; root =new Node(); &#125; /** Inserts a word into the trie. */ void insert(string word) &#123; auto p = root; for(auto c: word) &#123; auto u =c -'a'; if(p-&gt;son[u] ==NULL) p -&gt;son[u] =new Node(); p =p-&gt;son[u]; &#125; p-&gt;is_end =true; &#125; /** Returns if the word is in the trie. */ bool search(string word) &#123; auto p =root; for(auto c : word) &#123; auto u =c -'a'; if(p -&gt;son[u] ==NULL) return false; p =p-&gt;son[u]; &#125; return p-&gt;is_end; &#125; /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) &#123; auto p =root; for(auto c :prefix) &#123; auto u =c -'a'; if(p -&gt;son[u] ==NULL) return false; p =p-&gt;son[u]; &#125; return true; &#125;&#125;;/** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj-&gt;insert(word); * bool param_2 = obj-&gt;search(word); * bool param_3 = obj-&gt;startsWith(prefix); */ å…³äºŽtrie çš„ç†è®ºè®²è§£å¯ä»¥å‚è€ƒè¿™ç¯‡åšå®¢, è¿™é‡Œä¸»è¦è®²è§£å®žçŽ°ã€‚ integer to English Words 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: string small[20] =&#123;"Zero", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"&#125;; string mid[10] =&#123;"", "", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"&#125;; string big[4] =&#123;"Billion", "Million", "Thousand", ""&#125;; string numberToWords(int num) &#123; if(! num) return small[0]; string res; for(int i =1000000000,j =0; i&gt;0; i /=1000, j++) &#123; if(num &gt;=i) &#123; res += get_part(num /i) +big[j] +" "; num %= i; &#125; &#125; while(res.back() ==' ') res.pop_back(); return res; &#125; string get_part(int n) &#123; string res; if(n &gt;=100) &#123; res += small[n /100] +" Hundred "; n %= 100; &#125; if(!n) return res; if(n &gt;=20) &#123; res += mid[n/10] +' '; n %=10; &#125; if(!n) return res; res += small[n]+' '; return res; &#125;&#125;; KMP ä¸“é¢˜é¦–å…ˆæœ€ç®€å•çš„æ˜¯å­—ç¬¦ä¸²çš„åŒ¹é…é—®é¢˜ï¼Œ å¦‚æžœæš´åŠ›æžšä¸¾ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦æ˜¯ $O(mn) $ï¼Œå…¶ä¸­ $m$ å’Œ$n$ åˆ†åˆ«è¡¨ç¤ºä¸¤ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦ã€‚å¦‚æžœä½¿ç”¨kmp ç®—æ³•ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦æ˜¯ $O(m +n)$ è¿™ä¸ªæ˜¯æ¨¡æ¿ï¼š1234567891011121314151617181920æ±‚Nextæ•°ç»„ï¼š// s[]æ˜¯æ¨¡å¼ä¸²ï¼Œp[]æ˜¯æ¨¡æ¿ä¸², næ˜¯sçš„é•¿åº¦ï¼Œmæ˜¯pçš„é•¿åº¦for (int i = 2, j = 0; i &lt;= m; i ++ )&#123; while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j;&#125;// åŒ¹é…for (int i = 1, j = 0; i &lt;= n; i ++ )&#123; while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == m) &#123; j = ne[j]; // åŒ¹é…æˆåŠŸåŽçš„é€»è¾‘ &#125;&#125; è¿™ä¸ªæ˜¯æŠ•æœºå–å·§çš„æ–¹å¼ï¼Œ ä½†æ˜¯å¯ä»¥æŽŒæ¡å…³äºŽ string:: npos è¿™ç§åˆ¤æ–­æ¡ä»¶ 1234567891011121314151617#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; int n, m; string p, s; cin &gt;&gt; n&gt;&gt; p&gt;&gt; m&gt;&gt; s; auto found =s.find(p); while(found != string::npos) &#123; cout &lt;&lt; found &lt;&lt; " "; found =s.find(p, found+1); &#125; return 0;&#125; ä½¿ç”¨ kmp ç®—æ³•çš„æ­£è§£ã€‚(KMPå­—ç¬¦ä¸²)(https://www.acwing.com/problem/content/description/833/)12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;const int N =1e4+11;const int N1 =1e5+11;int nex[N];char p[N];char s[N1];int n, m;void get_next()&#123; for(int i =2,j =0; i&lt;=n; i++) &#123; while(j &amp;&amp; p[i] != p[j+1]) j =nex[j]; if(p[i ] ==p[j+1]) j ++; nex[i] =j; &#125;&#125;int main()&#123; // è¿™ç§å†™æ³•å¯¹äºŽä¸€æ¬¡æ€§çš„è¯»å…¥ï¼Œè¿˜æ˜¯éžå¸¸æœ‰æ•ˆçŽ‡çš„ï¼Œå­¦ä¹  cin &gt;&gt; n &gt;&gt; p+1&gt;&gt; m &gt;&gt; s+1; get_next(); for(int i =1, j =0; i&lt;=m; i++) &#123; while(j &amp;&amp; s[i] != p[j+1]) j =nex[j]; if( s[i] ==p[j+1]) j +=1; if(j ==n) &#123; printf("%d ", i-n); j =nex[j]; &#125; &#125; return 0;&#125; å‘¨æœŸ next[n] çš„å«ä¹‰ï¼š è¡¨ç¤ºä»¥ n ä¸ºç»“å°¾çš„åŽç¼€å’Œä»¥ 1ä½èµ·ç‚¹çš„å‰ç¼€ï¼Œç›¸åŒçš„string ï¼Œ æœ€å¤§é•¿åº¦ã€‚ n-next[n] è¡¨ç¤ºæœ€å°çš„å¾ªçŽ¯èŠ‚ï¼Œé‚£ä¹ˆ n/(n -next[n]) å°±æ˜¯æœ€å¤šçš„ä¸ªæ•°ã€‚ ä»¥i ä¸ºç»“ç‚¹çš„æœ€å¤§çš„åŽç¼€å’Œå‰ç¼€ç›¸ç­‰ï¼Œè¿™ä¸ªåŽç¼€çš„é•¿åº¦å°±æ˜¯next[i] 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;const int N =1e6+11;int nex[N];char str[N];int n;//åœ¨æ‰€æœ‰çš„å‰ç¼€ä¸­ æœ€å°å¾ªçŽ¯èŠ‚çš„æœ€å¤§é‡å¤ä¸ªæ•°// è€ƒå¯Ÿ n-next[n] æ˜¯è¡¨ç¤ºæœ€å°çš„å¾ªçŽ¯èŠ‚void get_next()&#123; for(int i =2, j =0; i&lt;=n ; i++) &#123; // while å’Œ nex[i] æ˜¯å®¹æ˜“å‡ºç²— while(j &amp;&amp; str[i] != str[j+1]) j =nex[j]; if(str[i] ==str[j+1]) j++; nex[i] =j; &#125;&#125;int main()&#123; int T =1; // å¦‚æžœn ==0ï¼Œé‚£ä¹ˆå°±è·³å‡ºäº† while(scanf("%d", &amp;n), n) &#123; scanf("%s\n", str+1); // è¿™ç§ \n åœ¨è¯»å…¥å­—ç¬¦ä¸²ä¸­è¿˜æ˜¯éžå¸¸æœ‰ç”¨ï¼Œå¯¹äºŽcin å‡½æ•°ï¼Œä½ å°±çŸ¥é“å¤šæœ‰ç”¨äº† get_next(); printf("Test case #%d\n", T++); for(int i =1; i&lt;=n; i++) &#123; int t =i -nex[i]; if(t != i &amp;&amp; i%t ==0) printf("%d %d\n", i, i/t); &#125; puts(""); &#125; return 0;&#125; å¯¹äºŽstring çš„é¢˜ç›®ï¼Œä¸€èˆ¬å¯ä»¥hash æˆ–è€… kmp ç®—æ³•æ±‚è§£ã€‚ 160. åŒ¹é…ç»Ÿè®¡ è§†é¢‘è®²è§£ æˆ‘è§‰å¾—å¯ä»¥ç†è§£çš„åœ°æ–¹æ˜¯ï¼Œkmp ç®—æ³•æ±‚è§£next æ•°ç»„ï¼Œkmp ç®—æ³•è¿›è¡Œå­—ç¬¦ä¸²åŒ¹é…ï¼Œn-next[n] è¡¨ç¤ºæœ€å¤§çš„å¾ªçŽ¯èŠ‚çš„ä¸ªæ•° 12345678910111213141516171819202122232425262728293031323334353637383940// f[i] è¡¨ç¤ºåŒ¹é…é•¿åº¦è‡³å°‘æ˜¯ içš„æƒ…å†µä¸‹ï¼Œ è¿™æ ·çš„åŽç¼€æœ‰å¤šå°‘ä¸ª// æœ€å°‘æ˜¯ x -æœ€å°‘æ˜¯x+1 çš„ï¼Œé‚£ä¹ˆå¾—åˆ°çš„å°±æ˜¯ x#include&lt;iostream&gt;using namespace std;const int N =2e5+11;int n, m, q;char a[N], b[N];int ne[N];int f[N];// next æ•°ç»„æœ¬è´¨ä¸Šå°±æ˜¯å‰ç¼€å’ŒåŽç¼€çš„åŒ¹é…çš„æœ€å¤§é•¿åº¦// next æ•°ç»„ä¸æ­¢å¯ä»¥æ“ä½œåŒä¸€ä¸ªstringï¼Œè¿˜æ˜¯å¯ä»¥æ“ä½œå¦å¤–çš„æ•°ç»„int main()&#123; cin &gt;&gt;n &gt;&gt;m&gt;&gt; q; scanf("%s%s", a+1, b+1); // è¯»å…¥äº†ä¸¤ä¸ªå­—ç¬¦ä¸²æ•°ç»„ //å¯¹äºŽ b æ±‚è§£kmp æ•°ç»„ for(int i =2, j =0;i &lt;=m; i++) &#123; while(j &amp;&amp; b[i] != b[j+1]) j =ne[j]; if(b[i] ==b[j+1]) j++; ne[i] =j; &#125; // æ±‚è§£a çš„åŽç¼€å’Œb çš„å‰ç¼€çš„åŒ¹é…, for(int i =1, j =0; i&lt;=n; i++) &#123; while(j &amp;&amp; a[i] != b[j+1]) j =ne[j]; if(a[i] ==b[j+1]) j ++; // è¿™é‡Œæ˜¯ä¸ç†è§£çš„ f[j] ++; &#125; // è¿™é‡Œä¹Ÿæ˜¯ä¸æ‡‚çš„ for(int i=m; i; i--) f[ne[i]] += f[i]; while( q--) &#123; int x ; cin &gt;&gt;x; cout &lt;&lt; f[x]- f[x+1] &lt;&lt;endl; &#125; return 0;&#125; å¥¶ç‰›çŸ©é˜µ è§†é¢‘è®²è§£ å¤ªéš¾äº† 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;const int N =10010, M =80;int n, m;char str[N][M];int ne[N];bool st[M];int main()&#123; cin &gt;&gt;n&gt;&gt;m; memset(st, true, sizeof st); for(int i =1 ;i&lt;=n; i++) &#123; scanf("%s", str[i]); for(int j =1; j&lt;=m; j++) &#123; if(st[j]) &#123; for(int k =j; k&lt;m; k+=j) &#123; for(int u =0; u&lt;j &amp;&amp; k+ u&lt; m; u++) &#123; if(str[i][u] != str[i][k+u]) &#123; st[j] =false; break; &#125; &#125; if(!st[j]) break; &#125; &#125; &#125; &#125; int width; for(int i =1; i&lt;=m; i++) &#123; if(st[i]) &#123; width =i; break; &#125; &#125; for(int i =1; i&lt;=n; i++) str[i][width] =0; // strcmp(str1, str2) å¦‚æžœç›¸ç­‰è¿”å›ž 0ï¼Œ å¦‚æžœstr1&lt; str2 è¿”å›ž-1ï¼Œ å¦‚æžœå¤§äºŽ è¿”å›ž+1 for(int i =2, j =0; i&lt;=n; i++) &#123; while(j &amp;&amp; strcmp(str[i], str[j+1])) j =ne[j]; if(!strcmp(str[i], str[j+1])) j++; ne[i] =j; &#125; int height =n -ne[n]; //cout &lt;&lt; width &lt;&lt;" "&lt;&lt; height&lt;&lt; endl; cout &lt;&lt; width *height &lt;&lt;endl; return 0;&#125; è¶…å¸‚ ä¸»è¦æ˜¯ç»ƒä¹  å°æ ¹å †å’Œpair çš„ç»„åˆä½¿ç”¨ã€‚æ˜¯ä¸€ä¸ªè´ªå¿ƒç®—æ³•ï¼Œå¾ˆç»å…¸çš„ã€æ—¶é—´å¤æ‚åº¦æ˜¯ $nlogn$ 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;typedef pair&lt;int, int&gt; PAIR;// ä½¿ç”¨pair è¿™ç§ç»“æž„æ˜¯å¯ä»¥æŒ‰ç…§ç¬¬ä¸€å…³é”®å­—å…ˆæŽ’åºï¼Œç„¶åŽæŒ‰ç…§ç¬¬äºŒå…³é”®å­—æŽ’åº// æŒ‰ç…§è¿‡æœŸæ—¶é—´æŽ’åºï¼Œç»´æŠ¤ä¸€ä¸ªå°æ ¹å †ï¼Œæ¯æ¬¡æŠŠåˆ©æ¶¦å°çš„ç»™ popå‡ºåŽ»int main()&#123; int n; while(cin &gt;&gt;n) &#123; vector&lt;PAIR&gt; products(n); // è¿™ç§å†™æ³•ï¼ŒçœŸæ˜¯éžå¸¸çš„ç®€æ´ï¼Œä½¿ç”¨vector&lt;pair&lt;int, int&gt;&gt; çš„æ ¼å¼ï¼Œlist ä¸­åµŒå¥—äº† pair // å…ˆæ˜¯æŒ‰ç…§è¿‡æœŸæ—¶é—´è¿›è¡ŒæŽ’åºï¼Œå¦‚æžœç›¸åŒï¼Œé‚£ä¹ˆæŒ‰ç…§é‡‘é¢è¿›è¡ŒæŽ’åº,éƒ½æ˜¯ä»Žå°åˆ°å¤§è¿›è¡ŒæŽ’åºï¼Œå› ä¸ºsort() é»˜è®¤çš„æŒ‰ç…§å¢žåºè¿›è¡ŒæŽ’åºçš„ for(int i =0; i&lt;n; i++) cin &gt;&gt; products[i].second &gt;&gt; products[i].first; sort(products.begin(), products.end()); // å®šä¹‰å°æ ¹å † // ä½¿ç”¨greater&lt;int&gt; ,less&lt;int&gt; ï¼Œå¤´æ–‡ä»¶ä¸å†™ä¹Ÿè¡Œçš„ priority_queue&lt;int , vector&lt;int&gt; , greater&lt;int&gt;&gt; heap; for(auto p: products) &#123; heap.push(p.second); if(heap.size() &gt; p.first) heap.pop(); &#125; int res =0; while(heap.size() ) res += heap.top(), heap.pop(); cout &lt;&lt; res&lt;&lt; endl; &#125; return 0;&#125; ç¬¬äºŒæ¬¡å†™ã€‚1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PAIR;int main()&#123; int n ; while(cin &gt;&gt;n) &#123; vector&lt;PAIR&gt; products(n); // ä¸‹é¢æ˜¯index è®¿é—®ï¼Œé‚£ä¹ˆå°±éœ€è¦åˆå§‹åŒ–ï¼Œå¦åˆ™æ˜¯æ®µé”™è¯¯ï¼›æˆ–è€…ä½¿ç”¨ push_back() è¿›è¡Œè®¿é—® for(int i =0; i&lt; n; i++) &#123; cin &gt;&gt; products[i].second &gt;&gt; products[i].first; &#125; sort(products.begin(), products.end()); priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap; for(auto product: products) &#123; // å…ˆæ˜¯æ— è„‘æ”¾ï¼Œå¦‚æžœå‘çŽ°ä¸æ»¡è¶³æ¡ä»¶ï¼Œé‚£ä¹ˆå¼¹å‡º heap.push(product.second); if(heap.size() &gt; product.first) heap.pop(); &#125; int res =0; while(heap.size()) &#123; res +=heap.top(); heap.pop(); &#125; cout &lt;&lt; res&lt;&lt; endl; &#125; return 0;&#125; Implement strStr() æ³¨æ„è¿™ä¸ªä¸æ˜¯ä»Ž 1 å¼€å§‹è®¡æ•°çš„ï¼Œè¿™ä¸ªä½¿ç”¨è¾¹ç•Œæ¡ä»¶æ˜¯éœ€è¦è®°å½•ä¸€ä¸‹çš„ã€‚ 1234567891011121314151617181920212223242526class Solution &#123;public: int strStr(string s, string p) &#123; int n =s.size() , m =p.size(); if(m ==0) return 0; // next æ•°ç»„ vector&lt;int&gt; nex(m); nex[0] =-1; // å¿…é¡»è¦æœ‰ä¸€ä¸ªåˆå§‹å€¼ for(int i =1, j =-1; i&lt; m ; i++) &#123; while( j&gt; -1 &amp;&amp; p[i] != p[j+1]) j =nex[j]; if(p[i] == p[j+1]) j++; nex[i] =j; &#125; for(int i =0, j =-1; i&lt; n; i++) &#123; while(j &gt; -1 &amp;&amp; s[i] != p[j+1]) j =nex[j]; if(s[i ] ==p[j+1]) j ++; if(j ==m -1) &#123; return i-m +1; &#125; &#125; return -1; &#125;&#125;; 459. Repeated Substring Pattern 1234567891011121314151617181920class Solution &#123;public: // è€ƒå¯Ÿkmp ä¸­ i -nex[i] æ˜¯å¾ªçŽ¯èŠ‚çš„é•¿åº¦ã€‚æ›´åŠ å…·ä½“çš„æ˜¯ åœ¨è¿™ä¸ªé¢˜ç›®ä¸­ n -nex[n] æ˜¯æœ€å°å¾ªçŽ¯èŠ‚çš„é•¿åº¦ï¼Œ // è¿™ä¸ªæ˜¯å¯ä»¥ç”¨æ¥åˆ¤æ–­æ˜¯å¦å®Œç¾Žåˆ‡åˆ† bool repeatedSubstringPattern(string s) &#123; int n = s.size(); vector&lt;int&gt; nex(n); nex[0] =-1; for(int i =1, j =-1; i&lt; n; i++) &#123; while(j &gt; -1 &amp;&amp; s[i] != s[j+1]) j =nex[j]; if(s[i] ==s[j+1]) j ++; nex[i] =j; &#125; int t =n-1 -nex[n-1]; return t !=n&amp;&amp; n%t ==0; // å­—ç¬¦ä¸²æœ¬èº«ä¸èƒ½ä½œä¸ºä¸€ä¸ªå¾ªçŽ¯èŠ‚ &#125;&#125;; 214. Shortest Palindrome 123456789101112131415161718192021222324252627class Solution &#123;public: // è€ƒå¯Ÿkmp çš„å‰åŽç¼€çš„ç†è§£ string shortestPalindrome(string s) &#123; int n =s.size(); // è¿™ç§æƒ…å†µä¸“é—¨å°±æ˜¯æŒ‡çš„æ˜¯ s =="" æ²¡æœ‰å…¶ä»–çš„æƒ…å†µäº† if (n ==0) return s; string t(s.rbegin(), s.rend()); vector&lt;int&gt; nex(n); nex[0] =-1; for(int i =1, j =-1; i&lt; n; i++) &#123; while(j &gt; -1 &amp;&amp; s[i] != s[j+1]) j =nex[j]; if(s[i] ==s[j+1]) j ++; nex[i] =j; &#125; // åšçš„kmp çš„åŒ¹é… int j =-1; // æ¯”è¾ƒçš„æ˜¯ t çš„å‰ç¼€å’Œ s çš„åŽç¼€çš„ç›¸åŒçš„æœ€å¤§çš„é•¿åº¦ for(int i =0; i&lt;n; i++) &#123; while(j &gt; -1 &amp;&amp; t[i] != s[j+1]) j =nex[j]; if(t[i] ==s[j+1]) j ++; &#125; return t +s.substr(j +1, n -j -1); &#125;&#125;;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Beyond Word Embedding]]></title>
    <url>%2F2019%2F05%2F22%2Fbeyond-word-embedding%2F</url>
    <content type="text"><![CDATA[ä»Žone-hot åˆ° word2vecï¼Œ åˆ°elmoï¼Œç®€å•ä»‹ç»ä¸€ä¸‹ NLPä¸­è¯å‘é‡çš„è¿‡ç¨‹ã€‚ è¿›å…¥æ­£é¢˜ä¹‹å‰ï¼Œæ€è€ƒä¸ºä»€ä¹ˆè¦å°†è¯ç”¨å‘é‡æ¥è¡¨ç¤ºå‘¢ï¼Ÿè¿™æ ·å¯ä»¥ç»™è¯è¯­ä¸€ä¸ªæ•°å­¦ä¸Šçš„è¡¨ç¤ºï¼Œä½¿ä¹‹å¯ä»¥é€‚ç”¨äºŽæŸäº›ç®—æ³•æˆ–æ•°å­¦æ¨¡åž‹ã€‚é€šå¸¸å°†è¯è¯­è¡¨ç¤ºæˆå‘é‡æœ‰å¦‚ä¸‹ä¸¤ç§æ–¹æ³•: one-hot and distributed è¡¨ç¤ºæ³•ã€‚one-hot åªæœ‰ä¸€ä¸ªä½ç½®æ˜¯1 å…¶ä»–çš„ä½ç½®éƒ½æ˜¯0ï¼Œæœ€å¤§çš„ç‰¹ç‚¹å°±æ˜¯æ•°æ®å˜å¾—ç¨€ç–ï¼Œè€ŒåŽè€…å±žäºŽç¨ å¯†å‘é‡ã€‚å‰è€…çš„ç¼ºç‚¹å‘é‡æ˜¯ç›¸äº’ç‹¬ç«‹çš„ï¼Œæ— æ³•é€šè¿‡è·ç¦»å‡½æ•°æ¯”å¦‚ cosine è¿›è¡Œç›¸ä¼¼åº¦çš„æ¯”è¾ƒï¼Œå¹¶ä¸”å¦‚æžœç»´åº¦ Néžå¸¸å¤§ï¼Œé‚£ä¹ˆé«˜çº¬åº¦çš„è¡¨ç¤ºä¹Ÿå¯èƒ½å¼•å‘ç»´åº¦ç¾éš¾ã€‚äºŽæ˜¯æŽ¥ç€å¾€ä¸‹çœ‹å§â€¦ Traditional Word VectorsBefore diving directly into Word2Vec itâ€™s worth while to do a brief overview of some of the traditional methods that pre-date neural embeddings. è¿™ä¸ªæ˜¯ç”¨æ¥æè¿°æ–‡ç« çš„ï¼Œæœ‰ä¸€ä¸ªå¤§çš„dictï¼Œç„¶åŽä¸€ç‰‡æ–‡ç« æ˜¯å¦‚ä½•è¿›è¡Œè¡¨ç¤ºã€Bag of Words or BoW vector representations are the most common used traditional vector representation. Each word or n-gram is linked to a vector index and marked as 0 or 1 depending on whether it occurs in a given document. An example of a one hot bag of words representation for documents with one word. å±€é™æ€§: ä¸€æ–¹é¢åªæ˜¯ä¸€ç§counterï¼Œæ²¡æœ‰è€ƒè™‘è¯­ä¹‰ä¿¡æ¯ï¼›å¦ä¸€æ–¹é¢æœ‰äº› words æ˜¯æ˜Žæ˜¾çš„ relevant than others.BoW representations are often used in methods of document classification where the frequency of each word, bi-word or tri-word is a useful feature for training classifiers. One challenge with bag of word representations is that they donâ€™t encode any information with regards to the meaning of a given word.In BoW word occurrences are evenly weighted independently of how frequently or what context they occur. However in most NLP tasks some words are more relevant than others. è¿™ä¸ªæ˜¯å¯ä»¥è®¤è¯†æ˜¯å¯¹äºŽ bag of words â€œrelevantâ€ ä¸Šçš„æ”¹è¿›ï¼šä½¿å¾— é€‰æ‹©çš„words æ›´åŠ çš„ â€œrepresentativeâ€ æ–‡ç« çš„è°ƒæ€§ã€‚TF-IDF, short for term frequencyâ€“inverse document frequency, is a numerical statistic that is intended to reflect how important a word or n-gram is to a document in a collection or corpus. They provide some weighting to a given word based on the context it occurs.The tfâ€“idf value increases proportionally to the number of times a word appears in a document and is offset by the number of documents in the corpus that contain the word, which helps to adjust for the fact that some words appear more frequently than others. ä½†æ˜¯å¯¹äºŽ bag of words ä¸­â€œæ²¡æœ‰ä½“çŽ°è¯­ä¹‰â€ çš„ç¼ºé™·è¿˜æ˜¯æ²¡æœ‰ deal withã€‚However even though tf-idf BoW representations provide weights to different words they are unable to capture the word meaning. è¿™ä¸ªåå­—åªæ˜¯å› ä¸ºæœ‰å®šä¹‰è€Œå­˜åœ¨çš„åå­—ï¼ˆç½‘ç»œæ¨¡åž‹ or æ·±åº¦ç½‘ç»œçš„å‡ºçŽ°å°±æ˜¯ä¸ºäº† handle è¯­ä¹‰ä¿¡æ¯ï¼‰Distributional Embeddings enable word vectors to encapsulate contextual context. Each embedding vector is represented based on the mutual information it has with other words in a given corpus.é‡ç‚¹å°±æ˜¯è¿™ç§æ–¹å¼æ˜¯è¦ predict a target word from context wordsï¼Œä¸€å®šæ˜¯è¦èƒ½å¤Ÿä½“çŽ°è¯­å¢ƒçš„ã€‚Predictive models learn their vectors in order to improve their predictive ability of a loss such as the loss of predicting the vector for a target word from the vectors of the surrounding context words. word2vec ä¸¤ç§ç±»åž‹ word2vec æ˜¯ä¸€ç§æ€æƒ³ï¼Œæœ‰ä¸¤ç§CBOW å’Œskip-gram ä¸¤ç§å®žçŽ°ã€‚Word2Vec is a predictive embedding model. There are two main Word2Vec architectures that are used to produce a distributed representation of words: Continuous bag-of-words (CBOW) â€” The order of context words does not influence prediction (bag-of-words assumption). Continuous skip-gram weighs nearby context words more heavily than more distant context words. While order still is not captured each of the context vectors are weighed and compared independently vs CBOW which weighs against the average context. word2vec å°±æ˜¯2 ç§ç®—æ³•+ 2ç§æ¨¡åž‹ï¼Œæ€»å…±æ˜¯å››ç§å®žçŽ°ã€‚ å±•ç¤ºä¸€ä¸‹ç»“æž„å›¾ï¼š word2vec çš„è®­ç»ƒè¿‡ç¨‹ï¼š ä¸­æ–‡åˆ†è¯ï¼Œç„¶åŽä¿å­˜æ‰€æœ‰çš„è¯­æ–™åˆ°ä¸€ä¸ªæ–‡ä»¶ä¸­ï¼Œå¯ä»¥ä½¿ç”¨ æ¢è¡Œç¬¦è¿›è¡Œåˆ†å¼€ æ‰«æè¯­æ–™åº“ç»Ÿè®¡è¯é¢‘ï¼Œå–è¯é¢‘æœ€é«˜çš„V ä¸ªè¯ï¼Œæž„æˆè¯æ±‡è¡¨ï¼Œone-hot ç¼–ç ï¼Œ è¯çš„ç»´åº¦å°±æ˜¯è¯å…¸çš„å¤§å°ï¼Œå…¶ä½™ï¼ˆå‡ºçŽ°é¢‘çŽ‡å¾ˆä½Žï¼‰çš„è¯éƒ½ç”¨ä¸€ä¸ªç‰¹æ®Šç¬¦å·ä»£æ›¿æŽ‰ã€‚ è¯å‘é‡æ˜¯ä»Žè¾“å…¥å±‚åˆ°éšè—å±‚çš„weightsï¼Œéšç€åˆå§‹åŒ–è€Œå­˜åœ¨ï¼Œç„¶åŽä¹‹åŽæ˜¯ä¸æ–­ä¼˜åŒ–çš„äº§ç‰© è®­ç»ƒçš„ç›®æ ‡çš„ï¼Œä»¥skip-gram ä¸ºä¾‹ï¼Œè¾“å…¥ä¸­å¿ƒè¯ç„¶åŽæœ€å¤§åŒ–è¾“å‡ºå‘¨å›´çš„è¯ (context )è¯æ±‡ã€‚ è¾“å…¥å±‚çš„è¾“å…¥ï¼šæ¯ä¸ªè¯å­˜åœ¨ä¸€ä¸ªone-hotå‘é‡ï¼Œå‘é‡çš„ç»´åº¦æ˜¯Vï¼ˆè¯å…¸å¤§å°ï¼‰ï¼Œå¦‚æžœè¯¥è¯åœ¨è¯æ±‡è¡¨ä¸­å‡ºçŽ°è¿‡ï¼Œåˆ™å‘é‡ä¸­è¯æ±‡è¡¨ä¸­å¯¹åº”çš„ä½ç½®ä¸º1ï¼Œå…¶ä»–ä½ç½®å…¨ä¸º0ã€‚å¦‚æžœè¯æ±‡è¡¨ä¸­ä¸å‡ºçŽ°ï¼Œåˆ™å‘é‡ä¸ºå…¨0 è´Ÿé‡‡æ ·ï¼ˆNegative Sampleï¼‰å’Œå±‚æ¬¡softmaxï¼ˆHierarchical Softmaxï¼‰åˆ™æ˜¯ä¸¤ç§åŠ é€Ÿè®­ç»ƒçš„æ–¹æ³•ã€‚éƒ½æ˜¯ä¼˜åŒ–æœ€åŽçš„softmax å±‚ï¼ˆè¾“å‡ºå±‚ï¼‰ï¼Œå› ä¸ºè¿™ä¸ªå¤§å°å°±æ˜¯è¯å…¸çš„å¤§å°ï¼Œè®¡ç®—é‡å¤ªå¤§äº†ï¼Œå¦‚æžœçŸ¥é“softmaxï¼Œæ˜¯å­˜åœ¨æŒ‡æ•°è®¡ç®—çš„ã€‚ loss function åœ¨cbowæ¨¡åž‹ä¸­ï¼Œæ‰€æœ‰çš„è¯è¢«ç¼–ç æˆont-hotå‘é‡ï¼ŒVä¸ºæ€»è¯è¯­æ•°ã€‚inputå±‚çš„one-hot vectorç»è¿‡ $W_{VXN} $çŸ©é˜µåŽï¼Œè¢«åŽ‹ç¼©ä¸ºåªæœ‰Nä¸ªå…ƒç´ çš„å‘é‡hï¼Œä¹‹åŽç»è¿‡Wâ€²çŸ©é˜µå‡ºæ¥ï¼Œå¾—åˆ°uã€‚äºŽæ˜¯æ ¹æ®å…¬å¼ï¼Œæœ‰ $$p \left( w _ { t } | w _ { \text {input} } \right) = y _ { j } = \frac { \exp \left( u _ { j } \right) } { \sum \exp \left( u _ { j } \prime \right) }$$ æœ€å¤§åŒ–è¯¥æ¡ä»¶æ¦‚çŽ‡ï¼Œå¾—åˆ° $$\max p \left( w _ { t } | w _ { \text {input} } \right) = \max \log y _ { j } = u _ { j } - \operatorname { log } \sum \exp \left( u _ { j } \right)$$äºŽæ˜¯å¾—åˆ°äº† è¯è¢‹æ¨¡åž‹çš„ loss functionï¼š ï¼ˆå…³äºŽç½‘ç»œä¸­çš„ loss function è¿˜æ˜¯è¦å¤šç•™æ„ä¸€ä¸‹çš„ï¼‰$$E = - \log p \left( w _ { t } | w _ { \text {input} } \right) = \log \sum \exp \left( u _ { j } \right) - u _ { j }$$è¿™é‡Œï¼Œ$u _ { j }$ è¡¨ç¤ºç¬¬ $j$ ä¸ªè¯å‘é‡ï¼Œ æœ‰äº† loss functionï¼Œå°±å¯ä»¥è¿›è¡Œè¯å‘é‡çš„è®­ç»ƒäº†ã€‚ å±‚æ¬¡softmax æ¯”å¦‚è¯´ä¸€ä¸ªäºŒå‰æ ‘ç»“æž„ï¼Œâ€œæˆ‘â€è‚¯å®šæ˜¯ç¬¬ä¸€å±‚å¶å­èŠ‚ç‚¹ï¼Œâ€œæ¶®ç¾Šè‚‰â€è‚¯å®šæ˜¯åœ¨æœ€åŽä¸€å±‚çš„å¶å­èŠ‚ç‚¹ã€‚åœ¨ word2vec ä¸­è¾“å…¥è¾“å‡ºçš„ç¼–ç éƒ½æ˜¯ä½¿ç”¨çš„ one-hot è¿›è¡Œæ•°å­—åŒ–è¡¨ç¤ºçš„ã€‚ è¿™ä¸ªå­˜å‚¨çš„ç›®çš„æ˜¯éåŽ†çš„æ¬¡æ•°å°‘äº†ï¼Œå› ä¸ºæ˜¯ä½¿ç”¨äºŒåˆ†ç±»åŽ»åšå¤šåˆ†ç±»ï¼Œå¦‚æžœè¯é¢‘é«˜çš„ç¼–ç å°‘ï¼Œé‚£ä¹ˆæœ€åŽçš„ç»“æžœæ˜¯æ¯”è¾ƒå°‘çš„ã€‚word2vecè®­ç»ƒçš„æ—¶å€™æŒ‰ç…§è¯é¢‘å°†æ¯ä¸ªè¯è¯­Huffmanç¼–ç ï¼Œç”±äºŽHuffmanç¼–ç ä¸­è¯é¢‘è¶Šé«˜çš„è¯è¯­å¯¹åº”çš„ç¼–ç è¶ŠçŸ­ã€‚æ‰€ä»¥è¶Šé«˜é¢‘çš„è¯è¯­åœ¨ Hierarchical Softmaxè¿‡ç¨‹ä¸­ç»è¿‡çš„äºŒåˆ†ç±»èŠ‚ç‚¹å°±è¶Šå°‘ï¼Œæ•´ä½“è®¡ç®—é‡å°±æ›´å°‘äº†ã€‚ æ€»çš„ç‰¹ç‚¹ï¼šä½¿ç”¨ context words åŽ»predict ä¸­å¿ƒè¯ or ç›¸åçš„è¿‡ç¨‹ï¼Œæœ€å¤§åŒ–è¿™ç§æ¦‚çŽ‡å…³ç³»ã€‚CBOW is faster while skip-gram is slower but does a better job for infrequent words.é‚£ä¹ˆä¸ºä»€ä¹ˆå¿«å‘¢ï¼Ÿ ç­”ï¼š cbowåªè¦ æŠŠçª—å£å†…çš„å…¶ä»–è¯ç›¸åŠ ä¸€æ¬¡ä½œä¸ºè¾“å…¥æ¥é¢„æµ‹ ä¸€ä¸ªå•è¯ã€‚ä¸ç®¡çª—å£å¤šå¤§ï¼Œåªéœ€è¦ä¸€æ¬¡è¿ç®—ã€‚è€Œskip-gramç›´æŽ¥å—çª—å£å½±å“ï¼Œçª—å£è¶Šå¤§ï¼Œéœ€è¦é¢„æµ‹çš„å‘¨å›´è¯è¶Šå¤šã€‚åœ¨è®­ç»ƒä¸­ï¼Œé€šè¿‡è°ƒæ•´çª—å£å¤§å°æ˜Žæ˜¾æ„Ÿè§‰åˆ°è®­ç»ƒé€Ÿåº¦å—åˆ°å¾ˆå¤§å½±å“ã€‚å‰è€…æ˜¯å¤æ‚åº¦å¤§æ¦‚æ˜¯O(V)ï¼ŒåŽè€…çš„æ—¶é—´çš„å¤æ‚åº¦ä¸ºO(KVï¼‰(å‡è®¾K æ˜¯çª—å£çš„å¤§å°) ä¸ºä»€ä¹ˆskip-gram çš„å‡†ç¡®çŽ‡é«˜ä¸€äº›ï¼Œå¯¹äºŽç”Ÿåƒ»è¯çš„æ•ˆæžœæ›´å¥½ä¸€äº›ï¼Ÿ åœ¨skip-gramå½“ä¸­ï¼Œæ¯ä¸ªè¯éƒ½è¦æ”¶åˆ°å‘¨å›´çš„è¯çš„å½±å“ï¼Œæ¯ä¸ªè¯åœ¨ä½œä¸ºä¸­å¿ƒè¯çš„æ—¶å€™ï¼Œéƒ½è¦è¿›è¡ŒKæ¬¡çš„é¢„æµ‹ã€è°ƒæ•´ã€‚å› æ­¤ï¼Œ å½“æ•°æ®é‡è¾ƒå°‘ï¼Œæˆ–è€…è¯ä¸ºç”Ÿåƒ»è¯å‡ºçŽ°æ¬¡æ•°è¾ƒå°‘æ—¶ï¼Œ è¿™ç§å¤šæ¬¡çš„è°ƒæ•´ä¼šä½¿å¾—è¯å‘é‡ç›¸å¯¹çš„æ›´åŠ å‡†ç¡®ã€‚å› ä¸ºå°½ç®¡cbowä»Žå¦å¤–ä¸€ä¸ªè§’åº¦æ¥è¯´ï¼ŒæŸä¸ªè¯ä¹Ÿæ˜¯ä¼šå—åˆ°å¤šæ¬¡å‘¨å›´è¯çš„å½±å“ï¼ˆå¤šæ¬¡å°†å…¶åŒ…å«åœ¨å†…çš„çª—å£ç§»åŠ¨ï¼‰ï¼Œè¿›è¡Œè¯å‘é‡çš„è·³å¸§ï¼Œä½†æ˜¯ä»–çš„è°ƒæ•´æ˜¯è·Ÿå‘¨å›´çš„è¯ä¸€èµ·è°ƒæ•´çš„ï¼Œgradçš„å€¼ä¼šå¹³å‡åˆ†åˆ°è¯¥è¯ä¸Šï¼Œ ç›¸å½“äºŽè¯¥ç”Ÿåƒ»è¯æ²¡æœ‰æ”¶åˆ°ä¸“é—¨çš„è®­ç»ƒï¼Œå®ƒåªæ˜¯æ²¾äº†å‘¨å›´è¯çš„å…‰è€Œå·²ã€‚ ç®—æ³•å‚æ•°æ€»ä½“ä¸Šå¯¹äºŽæ•ˆæžœå½±å“ä¸å¤§ï¼Œæœ€é‡è¦çš„æ˜¯è¯­æ–™ã€‚ç›¸å¯¹æ¥è¯´ï¼Œæ¯”è¾ƒé‡è¦çš„å¸¸ç”¨çš„å‚æ•°ï¼š min-countï¼š ï¼ˆè¿™ä¸ªæ€æƒ³æœ‰ç‚¹æ„æ€å‘€ï¼Œåˆ‡è¯åˆ‡é”™äº†ï¼Œé‚£ä¹ˆåœ¨è®¡ç®—çš„æ—¶å€™å°±ä¸è¦äº†ï¼‰ æœ€å°è¯é¢‘è®­ç»ƒé˜€å€¼ï¼Œè¿™ä¸ªæ ¹æ®è®­ç»ƒè¯­æ–™å¤§å°è®¾ç½®ï¼Œåªæœ‰è¯é¢‘è¶…è¿‡è¿™ä¸ªé˜€å€¼çš„è¯æ‰èƒ½è¢«è®­ç»ƒã€‚æ ¹æ®ç»éªŒï¼Œå¦‚æžœåˆ‡è¯æ•ˆæžœä¸å¥½ï¼Œä¼šåˆ‡é”™ä¸€äº›è¯ï¼Œæ¯”å¦‚ â€œåœ¨æ·±åœ³â€ï¼Œæ¯•ç«Ÿåˆ‡é”™çš„æ˜¯å°‘æ•°æƒ…å†µï¼Œä½¿å¾—è¿™ç§é”™è¯è¯é¢‘ä¸é«˜ï¼Œå¯ä»¥é€šè¿‡è®¾ç½®ç›¸å¯¹å¤§ä¸€ç‚¹çš„ min-count è¿‡æ»¤æŽ‰åˆ‡é”™çš„è¯ã€‚ï¼ˆè¿™ç§æ˜¯å¯¹äºŽæ–°è¯å¤„ç†çš„ä¸€ç§è¡¥æ•‘æ–¹æ³•ï¼‰ å‘é‡ç»´åº¦ï¼š å¦‚æžœè¯é‡å¤§ï¼Œè®­ç»ƒå¾—åˆ°çš„è¯å‘é‡è¿˜è¦åšè¯­ä¹‰å±‚é¢çš„å åŠ ï¼Œæ¯”å¦‚ å¥å­ çš„å‘é‡è¡¨ç¤º ç”¨ è¯çš„å‘é‡å åŠ ï¼Œä¸ºäº†æœ‰åŒºåˆ†åº¦ï¼Œè¯­ä¹‰ç©ºé—´åº”è¯¥è¦è®¾ç½®å¤§ä¸€äº›ï¼Œæ‰€ä»¥ç»´åº¦è¦åå¤§ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œä¸­æ–‡ 180 å°±å·®ä¸å¤šäº†ã€‚ è´Ÿé‡‡æ ·ï¼š è´Ÿé‡‡æ ·ï¼ˆnegative samplingï¼‰è§£å†³äº†è¿™ä¸ªé—®é¢˜ï¼Œå®ƒæ˜¯ç”¨æ¥æé«˜è®­ç»ƒé€Ÿåº¦å¹¶ä¸”æ”¹å–„æ‰€å¾—åˆ°è¯å‘é‡çš„è´¨é‡çš„ä¸€ç§æ–¹æ³•ã€‚ä¸åŒäºŽåŽŸæœ¬æ¯ä¸ªè®­ç»ƒæ ·æœ¬æ›´æ–°æ‰€æœ‰çš„æƒé‡ï¼Œè´Ÿé‡‡æ ·æ¯æ¬¡è®©ä¸€ä¸ªè®­ç»ƒæ ·æœ¬ä»…ä»…æ›´æ–°ä¸€å°éƒ¨åˆ†çš„æƒé‡ï¼Œè¿™æ ·å°±ä¼šé™ä½Žæ¢¯åº¦ä¸‹é™è¿‡ç¨‹ä¸­çš„è®¡ç®—é‡ã€‚ åœ¨è®ºæ–‡ä¸­ï¼Œä½œè€…æŒ‡å‡ºæŒ‡å‡ºå¯¹äºŽå°è§„æ¨¡æ•°æ®é›†ï¼Œé€‰æ‹©5-20ä¸ªnegative wordsä¼šæ¯”è¾ƒå¥½ï¼Œå¯¹äºŽå¤§è§„æ¨¡æ•°æ®é›†å¯ä»¥ä»…é€‰æ‹©2-5ä¸ªnegative wordsã€‚ ä»»ä½•é‡‡æ ·ç®—æ³•éƒ½åº”è¯¥ä¿è¯é¢‘æ¬¡è¶Šé«˜çš„æ ·æœ¬è¶Šå®¹æ˜“è¢«é‡‡æ ·å‡ºæ¥ã€‚åŸºæœ¬çš„æ€è·¯æ˜¯å¯¹äºŽé•¿åº¦ä¸º1çš„çº¿æ®µï¼Œæ ¹æ®è¯è¯­çš„è¯é¢‘å°†å…¶å…¬å¹³åœ°åˆ†é…ç»™æ¯ä¸ªè¯è¯­ï¼š$$\operatorname { len } ( w ) = \frac { \operatorname { counter } ( w ) } { \sum _ { u \in \mathcal { D } } \operatorname { counter } ( u ) }$$ åœ¨word2vecä¸­ï¼Œè¯¥â€œåˆ»åº¦å°ºâ€å¯¹åº”ç€tableæ•°ç»„ã€‚å…·ä½“å®žçŽ°æ—¶ï¼Œå¯¹è¯é¢‘å–äº†0.75æ¬¡å¹‚ï¼š$$\operatorname { len } ( w ) = \frac { [ \operatorname { counter } ( w ) ] ^ { 0.75 } } { \sum _ { u \in \mathcal { D } } [ \operatorname { counter } ( u ) ] ^ { 0.75 } }$$è¿™ä¸ªå¹‚å®žé™…ä¸Šæ˜¯ä¸€ç§â€œå¹³æ»‘â€ç­–ç•¥ï¼Œèƒ½å¤Ÿè®©ä½Žé¢‘è¯å¤šä¸€äº›å‡ºåœºæœºä¼šï¼Œé«˜é¢‘è¯è´¡çŒ®ä¸€äº›å‡ºåœºæœºä¼šï¼ŒåŠ«å¯ŒæµŽè´«ã€‚ ï¼ˆè¿™ä¸ªæ˜¯ä¸€ç§è®¡ç®—ä¸Šçš„ä¼˜åŒ–ï¼Œé€šè¿‡é€‰å–ä¸€éƒ¨åˆ†ç»“ç‚¹ï¼ˆè¯æ±‡ï¼‰æ›´æ–°æƒé‡ï¼‰è´Ÿé‡‡æ ·è¶Šä½Žï¼Œå¯¹é«˜é¢‘è¯è¶Šä¸åˆ©ï¼Œå¯¹ä½Žé¢‘è¯æœ‰åˆ©ã€‚å¯ä»¥è¿™ä¹ˆç†è§£ï¼Œæœ¬æ¥é«˜é¢‘è¯ è¯è¢«è¿­ä»£50æ¬¡ï¼Œä½Žé¢‘è¯è¿­ä»£10æ¬¡ï¼Œå¦‚æžœé‡‡æ ·é¢‘çŽ‡é™ä½Žä¸€åŠï¼Œé«˜é¢‘è¯å¤±åŽ»äº†25æ¬¡è¿­ä»£ï¼Œè€Œä½Žé¢‘è¯åªå¤±åŽ»äº†5æ¬¡ã€‚ä¸€èˆ¬è®¾ç½®æˆle-5. ( è¿™ä¸ªå°±æ˜¯ $10^{-5}$ ) åœ¨ fasttext å®žçŽ°çš„æ—¶å€™ ä½¿ç”¨ä¸‹é¢çš„è¶…å‚æ•°è®°æ€§æŽ§åˆ¶ã€‚ -neg number of negatives sampled [5] çª—å£å¤§å°ï¼š çª—å£å¤§å°å½±å“ è¯ å’Œå‰åŽå¤šå°‘ä¸ªè¯çš„å…³ç³»ï¼Œå’Œè¯­æ–™ä¸­è¯­å¥é•¿åº¦æœ‰å…³ï¼Œå»ºè®®å¯ä»¥ç»Ÿè®¡ä¸€ä¸‹è¯­æ–™ä¸­ï¼Œå¥å­é•¿åº¦çš„åˆ†å¸ƒï¼Œå†æ¥è®¾ç½®windowå¤§å°ã€‚ä¸€èˆ¬è®¾ç½®æˆ8ã€‚ï¼ˆå‚æ•°ä¹Ÿæ˜¯ä¸€ä¸ªæŠ€æœ¯æ´»ï¼Œå‚æ•°çš„è®¾ç½®å’ŒåŽŸå§‹è®­ç»ƒæ•°æ®é›† å’Œå…¶ä»–çš„å‚æ•°çš„é…åˆæ˜¯ç›¸å…³è”çš„ã€‚å¦‚æžœå¥å­æ¯”è¾ƒé•¿ï¼Œé‚£ä¹ˆwindow size å°±ä¸è¦å¤ªå°ï¼‰ è´Ÿé‡‡æ · vs çª—å£å¤§å° è´Ÿé‡‡æ ·ä¸»è¦æ˜¯ä¸ºäº†é™ä½Žæ¨¡åž‹è®¡ç®—é‡ã€‚å¦‚æžœæ²¡æœ‰è´Ÿé‡‡æ ·ï¼Œæ¨¡åž‹éœ€è¦æŠŠè¯æ±‡è¡¨ä¸­æ²¡æœ‰å‡ºçŽ°åœ¨æ»‘åŠ¨çª—å£çš„è¯è¯­å½“ä½œè´Ÿæ ·æœ¬ã€‚ç„¶è€Œåœ¨å®žé™…è®­ç»ƒè¿‡ç¨‹ä¸­ï¼Œå¹¶ä¸éœ€è¦è¿™ä¹ˆå¤šçš„è´Ÿæ ·æœ¬ï¼Œè¿‡å¤šçš„è´Ÿæ ·æœ¬ä¼šå¯¼è‡´æ¨¡åž‹å­¦åã€‚ï¼ˆçª—å£çš„å¤§å°æ˜¯æ­£é‡‡æ ·çš„ä¸ªæ•°ï¼Œé‚£ä¹ˆ è´Ÿé‡‡æ ·çš„ä¸ªæ•°å’Œçª—å£çš„å¤§å°å°½é‡æ˜¯ä¿æŒäº† 1ï¼š1 çš„å…³ç³»ï¼Œè¿™æ ·æ˜¯æ¯”è¾ƒå¥½çš„ï¼‰ è´Ÿé‡‡æ ·çš„ä¸ªæ•°å’Œæ»‘åŠ¨çª—å£çš„æ¯”ä¾‹å°½é‡æŽ§åˆ¶åœ¨0.1-10ä¹‹é—´ï¼Œæ»‘åŠ¨çª—å£å†³å®šäº†æ­£æ ·æœ¬çš„æ•°é‡ï¼Œè´Ÿé‡‡æ ·çš„ä¸ªæ•°å†³å®šäº†è´Ÿæ ·æœ¬çš„ä¸ªæ•°ï¼Œæ­£è´Ÿæ ·æœ¬å°½é‡ä¸è¦å·®è·å¤ªå¤§ï¼Œå»ºè®®è´Ÿé‡‡æ ·çš„ä¸ªæ•°å’Œæ»‘åŠ¨çª—å£çš„æ¯”ä¾‹æŽ§åˆ¶ä¸º1ï¼š1ã€‚ æ¯”è¾ƒè¯¦ç»†çš„ä»‹ç»å¯ä»¥æŸ¥çœ‹è¿™é‡Œ å¦‚ä½•è¯„ä¼° word2vec è®­ç»ƒçš„å¥½åï¼Ÿ è¯èšç±» ï¼ˆå¯ä»¥é‡‡ç”¨ kmeans èšç±»ï¼Œçœ‹èšç±»ç°‡çš„åˆ†å¸ƒï¼‰ è¯cos ç›¸å…³æ€§ï¼ˆæŸ¥æ‰¾cosç›¸è¿‘çš„è¯ï¼‰ Analogyå¯¹æ¯” ï¼ˆman-kingï¼Œ woman-queenï¼‰ ä½¿ç”¨tnseï¼Œpcaç­‰é™ç»´å¯è§†åŒ–å±•ç¤º æ›´å¤šçš„è¯„ä»·æ–¹æ³•å¯ä»¥å‚è§è¿™é‡Œ. glove ï¼ˆg lou vï¼‰ ï¼ˆå¤ä¹ åˆ°è¿™é‡Œäº†ï¼‰ Intuition: Both CBOW and Skip-Grams are â€œpredictiveâ€ models, in that they only take local contexts into account. word2vec does not take advantage of global context.(ç»†èŠ‚ èƒ½çœ‹æ‡‚å°±çœ‹)GloVe embeddings by contrast leverage the same intuition behind the co-occurrence matrix (å…±ç”ŸçŸ©é˜µ) used distributional embeddings, but uses neural methods to decompose the co-occurrence matrix into more expressive and dense word vectors. æ¨¡åž‹ç›®æ ‡ï¼šè¿›è¡Œè¯çš„å‘é‡åŒ–è¡¨ç¤ºï¼Œä½¿å¾—å‘é‡ä¹‹é—´å°½å¯èƒ½å¤šåœ°è•´å«è¯­ä¹‰å’Œè¯­æ³•çš„ä¿¡æ¯ã€‚è¾“å…¥ï¼šè¯­æ–™åº“è¾“å‡ºï¼šè¯å‘é‡æ–¹æ³•æ¦‚è¿°ï¼šé¦–å…ˆåŸºäºŽè¯­æ–™åº“æž„å»ºè¯çš„å…±çŽ°çŸ©é˜µï¼Œç„¶åŽåŸºäºŽå…±çŽ°çŸ©é˜µå’ŒGloVeæ¨¡åž‹å­¦ä¹ è¯å‘é‡ã€‚ ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š sparse vectors è¯-æ–‡æ¡£çŸ©é˜µ(Term-document matrix) å’Œ è¯å…±çŽ°çŸ©é˜µ(Term-term matrix)ã€‚Term-document matrixè¡¨ç¤ºæ¯ä¸ªå•è¯åœ¨æ–‡æ¡£ä¸­å‡ºçŽ°çš„æ¬¡æ•°(è¯é¢‘)ï¼Œæ¯ä¸€è¡Œæ˜¯ä¸€ä¸ª termï¼Œæ¯ä¸€åˆ—æ˜¯ä¸€ä¸ª documentä¸¤ç¯‡æ–‡æ¡£çš„å‘é‡ç›¸ä¼¼ =&gt; ä¸¤ç¯‡æ–‡æ¡£ç›¸ä¼¼ï¼Œå¦‚ä¸Šå›¾ doc3 å’Œ doc4ï¼Œæˆ‘ä»¬å°±è®¤ä¸ºå®ƒä»¬æ˜¯ç›¸ä¼¼çš„ã€‚ä¸¤ä¸ªå•è¯çš„å‘é‡ç›¸ä¼¼ =&gt; ä¸¤ä¸ªå•è¯ç›¸ä¼¼ï¼Œå¦‚ä¸Šå›¾çš„ fool å’Œ clownï¼Œå°±æ˜¯ç›¸ä¼¼çš„ã€‚ Term-term matrixç„¶åŽæˆ‘ä»¬å¯ä»¥è€ƒè™‘æ›´å°çš„ç²’åº¦ï¼Œæ›´å°çš„ä¸Šä¸‹æ–‡ï¼Œä¹Ÿå°±æ˜¯ä¸ç”¨æ•´ç¯‡æ–‡æ¡£ï¼Œè€Œæ˜¯ç”¨æ®µè½(paragraph)ï¼Œæˆ–è€…å°çš„çª—å£(window of Â±4 words)ï¼Œæ‰€ä»¥è¿™ä¸ªæ—¶å€™ï¼Œå‘é‡å°±æ˜¯å¯¹ä¸Šä¸‹æ–‡å•è¯çš„è®¡æ•°ï¼Œå¤§å°ä¸å†æ˜¯æ–‡æ¡£é•¿åº¦ |D|ï¼Œè€Œæ˜¯çª—å£é•¿åº¦ |V| äº†ï¼Œæ‰€ä»¥çŽ°åœ¨ word-word matrix æ˜¯ |V|*|V| è€Œ word2vec å¾—åˆ°çš„å‘é‡ dense vectorsã€‚ä¸ä½¿ç”¨ negative sampling çš„Wordvec éžå¸¸å¿«ï¼Œä½†å‡†ç¡®çŽ‡ä¸é«˜ï¼ˆ57.4\%ï¼‰,æ¯•ç«Ÿæ¨¡åž‹æ²¡æœ‰å‘Šè¯‰ä»€ä¹ˆæ˜¯æ— å…³çš„wordï¼Œæ¨¡åž‹å¾ˆéš¾å¯¹æ— å…³è¯æ±‡è¿›è¡Œæƒ©æˆ’ï¼Œæé«˜å‡†ç¡®çŽ‡ã€‚å¯¹äºŽ synonym é—®é¢˜ï¼Œword2vec æ˜¯å¥½äºŽ gloveï¼Œä½†ä»Žæœ€ç»ˆçš„æ•ˆæžœä¸Šçœ‹ï¼Œä¸¤è€…æ˜¯ä¸åˆ†å½¼æ­¤çš„ã€‚glove ä½¿ç”¨äº†æ•´ä½“çš„ä¿¡æ¯ï¼Œword2vec åªæ˜¯ä½¿ç”¨äº†å±€éƒ¨ä¿¡æ¯ï¼ˆlocal contextï¼‰ã€‚ word2vec å’Œglove çš„åŒºåˆ«ï¼šPredictiveçš„æ¨¡åž‹ï¼Œå¦‚Word2vecï¼Œæ ¹æ®contexté¢„æµ‹ä¸­é—´çš„è¯æ±‡ï¼Œè¦ä¹ˆæ ¹æ®ä¸­é—´çš„è¯æ±‡é¢„æµ‹contextï¼Œåˆ†åˆ«å¯¹åº”äº†word2vecçš„ä¸¤ç§è®­ç»ƒæ–¹å¼cbowå’Œskip-gramã€‚ Count-basedæ¨¡åž‹ï¼Œå¦‚GloVeï¼Œæœ¬è´¨ä¸Šæ˜¯å¯¹å…±çŽ°çŸ©é˜µè¿›è¡Œé™ç»´ã€‚é¦–å…ˆï¼Œæž„å»ºä¸€ä¸ªè¯æ±‡çš„å…±çŽ°çŸ©é˜µï¼Œæ¯ä¸€è¡Œæ˜¯ä¸€ä¸ªwordï¼Œæ¯ä¸€åˆ—æ˜¯contextã€‚å…±çŽ°çŸ©é˜µå°±æ˜¯è®¡ç®—æ¯ä¸ªwordåœ¨æ¯ä¸ªcontextå‡ºçŽ°çš„é¢‘çŽ‡ã€‚ç”±äºŽcontextæ˜¯å¤šç§è¯æ±‡çš„ç»„åˆï¼Œå…¶ç»´åº¦éžå¸¸å¤§ï¼Œæˆ‘ä»¬å¸Œæœ›åƒnetwork embeddingä¸€æ ·ï¼Œåœ¨contextçš„ç»´åº¦ä¸Šé™ç»´ï¼Œå­¦ä¹ wordçš„ä½Žç»´è¡¨ç¤ºã€‚è¯¥å‘é‡è¡¨ç¤ºå±žäºŽ sparse vectors å’Œword2vec çš„æ•ˆæžœæ¯”è¾ƒï¼šglove å’Œword2vec ç›¸æ¯”æ²¡æœ‰ definitively better resultsï¼Œè¿˜æ˜¯é€šè¿‡å®žéªŒè¿›è¡Œè¯´è¯å§ã€‚While GloVe vectors are faster to train, neither GloVe or Word2Vec has been shown to provide definitively better results rather they should both be evaluated for a given dataset. fasttextè¿™ä¸ªä¸»è¦æ˜¯ each word + n-gram within each wordï¼Œ æœ€åŽçš„æ•ˆæžœæ˜¯å¥½äºŽ word2vec çš„ã€‚FastText, builds on Word2Vec by learning vector representations for each word and the n-grams found within each word. The values of the representations are then averaged into one vector at each training step. While this adds a lot of additional computation to training it enables word embeddings to encode sub-word information. FastText vectors have been shown to be more accurate than Word2Vec vectors by a number of different measures. ç®€å•è¯´ fasttext å’Œword2vec æ¨¡åž‹ä¸Šçš„ä¸åŒæœ‰ä¸¤ç‚¹ï¼š æ¨¡åž‹çš„è¾“å‡ºå±‚ï¼šword2vecçš„è¾“å‡ºå±‚ï¼Œå¯¹åº”çš„æ˜¯æ¯ä¸€ä¸ªtermï¼Œè®¡ç®—æŸtermçš„æ¦‚çŽ‡æœ€å¤§ï¼›è€Œfasttextçš„è¾“å‡ºå±‚å¯¹åº”çš„æ˜¯ åˆ†ç±»çš„labelã€‚ä¸è¿‡ä¸ç®¡è¾“å‡ºå±‚å¯¹åº”çš„æ˜¯ä»€ä¹ˆå†…å®¹ï¼Œèµ·å¯¹åº”çš„vectoréƒ½ä¸ä¼šè¢«ä¿ç•™å’Œä½¿ç”¨ï¼› fasttextåˆ™å……åˆ†åˆ©ç”¨äº†h-softmaxçš„åˆ†ç±»åŠŸèƒ½ï¼ŒéåŽ†åˆ†ç±»æ ‘çš„æ‰€æœ‰å¶èŠ‚ç‚¹ï¼Œæ‰¾åˆ°æ¦‚çŽ‡æœ€å¤§çš„labelï¼ˆä¸€ä¸ªæˆ–è€…Nä¸ªï¼‰ æ¨¡åž‹çš„è¾“å…¥å±‚ï¼šword2vecçš„è¾“å‡ºå±‚ï¼Œæ˜¯ context window å†…çš„termï¼›è€Œfasttextå¯¹åº”çš„æ•´ä¸ªsentenceçš„å†…å®¹ï¼ŒåŒ…æ‹¬termï¼Œä¹ŸåŒ…æ‹¬ n-gramçš„å†…å®¹ æ›´å¤šä¿¡æ¯å¯ä»¥å‚çœ‹åšå®¢ã€‚ overview of Neural NLP ArchitecturesDeep Feed Forward Networks 1D CNNs RNNs (LSTM/GRU) encoder- decoder ç»“æž„ attention and copy mechanismsè¿™ä¸ªæ˜¯ attention æœºåˆ¶æå‡ºçš„èƒŒæ™¯ï¼šè§£å†³ å¥å­ä¸­çš„é•¿ä¾èµ–ï¼›contextual impact (specific words may carry more importance at different steps)While in theory they can capture long term dependencies they tend to struggle modeling longer sequences, this is still an open problem. One cause for sub-optimal performance standard RNN encoder-decoder models for sequence to sequence tasks such as NER or translation is that they weight the impact each input vector evenly on each output vector when in reality specific words in the input sequence may carry more importance at different time steps.Attention mechanisms provide a means of weighting the contextual impact of each input vector on each output prediction of the RNN. These mechanisms are responsible for much of the current or near current state of the art in Natural language processing. attention In sum, algorithms can allocate attention, and they can learn how to do so, by adjusting the weights they assign to various inputs. Imagine a heat map over a photo. The heat is attention. è¿™ä¸ªæ˜¯è¦å¼•å‡ºæ¥ context word embeddings.One of the limits of traditional word vectors is that they presume that a wordâ€™s meaning is relatively stable across sentences.å¹¶ä¸æ˜¯ç‰©ç†ä¸Šçš„äºŒç»´å…³ç³»èƒ½å¤Ÿè¡¨ç¤ºè¯è¯­ä¹‹é—´çš„ relationshipï¼Œæœ‰æ—¶å€™æ˜¯éœ€è¦é«˜çº¬ç©ºé—´è¿›è¡Œè¡¨ç¤ºçš„ã€‚In fact, the strongest relationships binding a given word to the rest of the sentence may be with words quite distant from it.ä»Ž credit assignmentçš„è§’åº¦é˜è¿°äº† neural networks å°±æ˜¯ allocating importance to input featuresã€‚The fundamental task of all neural networks is credit assignment. Credit assignment is allocating importance to input features through the weights of the neural networkâ€™s model. Learning is the process by which neural networks figure out which input features correlate highly with the outcomes the net tries to predict, and their learnings are embodied in the adjusted quantities of the weights that result in accurate decisions about the data theyâ€™re exposed to.è¿™ä¸ªæ˜¯ä¼ ç»Ÿçš„ LSTM ï¼ˆencoder -decoderï¼‰ æ¨¡åž‹ï¼Œé—®é¢˜åœ¨äºŽå½“å¥å­è¿‡é•¿ï¼ˆæ¯”å¦‚è¯´å¤§äºŽ20 wordsï¼‰ä¹‹åŽï¼Œencoder æ˜¯æ— æ³• memory ä¹‹å‰çš„æ‰€æœ‰ wordsï¼Œæ‰€ä»¥æ•ˆæžœå°±ä¼šå˜å¾—å·®ä¸€äº›ã€‚ ä½†æ˜¯ attention å°±æ˜¯æ¨¡ä»¿äº†äººç¿»è¯‘è¿‡ç¨‹ï¼Œä¸€æ®µä½œä¸ºä¸€ä¸ªå•ä½ï¼Œç„¶åŽè¿›è¡Œç¿»è¯‘ã€‚è¿™æ ·å°±å¯ä»¥æŒç»­ä¿è¯è¾ƒé«˜ä¸­ç¡®çŽ‡çš„è¾“å‡ºã€‚In neural networks, attention primarily serves as a memory-access mechanism. æ¯æ¬¡çš„è¾“å‡ºéƒ½æ˜¯å…³æ³¨ä¸åŒçš„åœ°æ–¹ï¼Œä½†æ˜¯è‡³äºŽå“ªé‡Œæ›´åŠ é‡è¦ï¼Œè¿™ä¸ªäº¤ç»™äº† feedback mechanism åå‘ä¼ æ’­ã€‚ä¸‹é¢çš„å›¾ç‰‡ååˆ†æ¸…æ™°çš„å±•ç¤ºäº† åœ¨ç¿»è¯‘çš„è¿‡ç¨‹ä¸­ â€œfocusâ€ æ˜¯ä¸æ–­åœ°å˜åŒ–çš„ã€‚Above, a model highlights which pixels it is focusing on as it predicts the underlined word in the respective captions. Below, a language model highlights the words from one language, French, that were relevant as it produced the English words in the translation. As you can see, attention provides us with a route to interpretability. We can render attention as a heat map over input data such as words and pixels, and thus communicate to human operators how a neural network made a decision. (This could be the basis of a feedback mechanism whereby those humans tell the network to pay attention to certain features and not others.) (This could be the basis of a feedback mechanism whereby those humans tell the network to pay attention to certain features and not others.) Additionally in Machine Reading Comprehension and Summarization systems RNNs often tend to generate results, that while on first glance look structurally correct are in reality hallucinated or incorrect. One mechanism that helps mitigate some of these issues is the Copy Mechanism.copy mechanism ç®€å•è¯´æ¥å°±æ˜¯ word embedding or raw text.The copy mechanism is an additional layer applied during decoding that decides whether it is better to generate the next word from the source sentence or from the general embedding vocabulary. reading comprehension and summary ä¸Šé¢æ˜¯è¯´çš„åœ¨ machine translationï¼Œä¸‹é¢è¯´çš„æ˜¯ é˜…è¯»ç†è§£ å’Œ summaryé¢†åŸŸã€‚Additionally in Machine Reading Comprehension and Summarization systems RNNs often tend to generate results, that while on first glance look structurally correct are in reality hallucinated or incorrect. One mechanism that helps mitigate some of these issues is the Copy Mechanism.copy mechanism ç®€å•è¯´æ¥å°±æ˜¯ decide word embedding from model or raw text.The copy mechanism is an additional layer applied during decoding that decides whether it is better to generate the next word from the source sentence or from the general embedding vocabulary. Taming Recurrent Neural Networks for Better Summarizationæœ‰ä¸¤ç§ä¸åŒçš„ summarization:Two types of summarizationï¼šExtractive ï¼ˆYou might think of these approaches as like a highlighter.ï¼‰ Abstractiveï¼ˆBy the same analogy, these approaches are like a pen.ï¼‰The great majority of existing approaches to automatic summarization are extractive â€“ mostly because it is much easier to select text than it is to generate text from scratch.ä½†æ˜¯ä¸€ä¸ªé—®é¢˜åœ¨äºŽï¼Œåªæ˜¯ä½¿ç”¨ extrative way å¯èƒ½å¾—åˆ°ç›¸åŒçš„wordsï¼ŒProblem 1: The summaries sometimes reproduce factual details inaccurately (e.g. Germany beat Argentina 3-2). This is especially common for rare or out-of-vocabulary words such as 2-0.Problem 2: The summaries sometimes repeat themselves (e.g. Germany beat Germany beat Germany beatâ€¦)Easier Copying with Pointer-Generator Networksã€‚è¿™ä¸ªè·Ÿ attention ä¸æ˜¯å¾ˆç›¸å…³ï¼Œç®€å•è¯´å°±æ˜¯In this way, the pointer-generator network is a best of both worlds, combining both extraction (pointing) and abstraction (generating). To tackle Problem 2 (repetitive summaries), we use a technique called coverage. The idea is that we use the attention distribution to keep track of whatâ€™s been covered so far, and penalize the network for attending to same parts again. elmo (e l mo)elmo äº§ç”Ÿä¸€ä¸ª embedding æ˜¯æ ¹æ® context äº§ç”Ÿçš„ã€‚ELMo is a model generates embeddings for a word based on the context it appears thus generating slightly different embeddings for each of its occurrence.ï¼ˆæ„Ÿè§‰ç†è§£ä¸€ä¸ªæ¦‚å¿µéƒ½æ˜¯ æ ¹æ®å…¶ for example è¿›è¡Œç†è§£çš„ï¼‰For example, the word â€œplayâ€ in the sentence above using standard word embeddings encodes multiple meanings such as the verb to play or in the case of the sentence a theatre production. In standard word embeddings such as Glove, Fast Text or Word2Vec each instance of the word play would have the same representation. å‚è€ƒblog:https://towardsdatascience.com/beyond-word-embeddings-part-2-word-vectors-nlp-modeling-from-bow-to-bert-4ebd4711d0ec http://www.abigailsee.com/2017/04/16/taming-rnns-for-better-summarization.html https://skymind.ai/wiki/word2vec å¤ä¹ ç¬”è®° è¯„ä»· word embeddingçš„æ–¹é¢ï¼šæ˜¯å¦èƒ½ä½“çŽ°è¯­ä¹‰ä¿¡æ¯ï¼›æ˜¯å¦æ¯”å…¶ä»–è¯è¯­æ›´åŠ å…·æœ‰ä»£è¡¨æ€§ï¼› word2vec(æˆ–è€…è¯´ CBOW or Skip-gram )çš„ç‰¹ç‚¹ï¼Œè¾“å…¥å’Œè¾“å‡ºéƒ½æ˜¯ one-hot çš„è¡¨ç¤ºï¼Œé•¿åº¦éƒ½æ˜¯å­—å…¸çš„é•¿åº¦ï¼Œåœ¨æŸä¸€ä¸ªä½ç½®æ˜¯1ï¼Œå…¶ä»–çš„ä½ç½®éƒ½æ˜¯0. è®­ç»ƒè¿‡ç¨‹ï¼šåˆ†è¯ä¹‹åŽç»„æˆé¢„æ–™åº“ï¼Œæ‰«ææ‰€æœ‰çš„è¯é¢‘ï¼Œå–è¯é¢‘æœ€é«˜çš„Vä¸ªè¯è¯­ï¼Œæž„æˆè¯æ±‡è¡¨ï¼Œè¯é¢‘ä½Žçš„å°±ä¼šè¢«ä¸¢å¼ƒï¼ˆæ‰€ä»¥è¯è¯­çš„å­¦ä¹ éœ€è¦å¤šæ¬¡çš„ï¼Œæœ‰ä¸Šä¸‹æ–‡çš„ï¼‰ï¼Œ éƒ½è¢«ç”¨ä¸€ä¸ªç‰¹æ®Šç¬¦å·ä»£æ›¿æŽ‰ã€‚æŸå¤±å‡½æ•°æ˜¯æ¦‚çŽ‡æ¨¡åž‹ï¼Œç»™å®šä¸Šä¸‹æ–‡ç„¶åŽä¸­å¿ƒè¯å‡ºçŽ°çš„æ¦‚çŽ‡ï¼Œæ¦‚çŽ‡æ˜¯éœ€è¦åŠ ä¸Šlogï¼Œå°±ç»„æˆäº†loss functionï¼Œè®­ç»ƒçš„è¿‡ç¨‹ä¸­æ˜¯æœ€å¤§åŒ–æ¦‚çŽ‡æ¨¡åž‹ï¼ˆæœ€å°åŒ–lossï¼‰ã€‚CBOWå’ŒSkip-gram çš„åŒºåˆ«ï¼šCBOWåœ¨è®­ç»ƒçš„è¿‡ç¨‹ä¸­å°†ä¸Šä¸‹æ–‡åŠ å’Œæˆä¸€ä¸ªå‘é‡è¡¨ç¤ºï¼Œæ‰€ä»¥æœ€åŽçš„è®­ç»ƒé€Ÿåº¦æ˜¯å¿«äºŽskip-gram ä½†æ˜¯æ•ˆæžœæ²¡æœ‰skip-gramã€‚åŽè€…æ˜¯ä¸€ä¸ªä¸ªå•è¯è¿›è¡Œè®­ç»ƒçš„ï¼ˆå½“ç„¶è®­ç»ƒæ—¶é—´ä¹Ÿæ˜¯æ¯”è¾ƒé•¿çš„ï¼‰ã€‚å¯¹äºŽä¸­æ–‡çš„embedding sizeï¼Œä¸€èˆ¬180 å°±OKäº†ã€‚åœ¨è´Ÿé‡‡æ ·ä¸­è´Ÿæ ·æœ¬æ˜¯æ ¹æ®è¯é¢‘æŒ‘é€‰çš„ï¼Œä½†å…¬å¼ä¸­ä½¿ç”¨äº†ä¸€ç§å¹³æ»‘æœºåˆ¶ï¼Œä½¿å¾—ä½Žé¢‘è¯ä¹Ÿæœ‰äº†ä¸€äº›æœºä¼šï¼Œå¯¹é«˜é¢‘è¯è¯­è¿›è¡Œäº†ä¸€äº›çº¦æŸã€‚ word2vec å’Œglove çš„åŒºåˆ«ï¼šå‰è€…æ˜¯é¢„æµ‹ç±»çš„æ¨¡åž‹ï¼ŒåŽè€…æ˜¯cout-baseçš„æ¨¡åž‹ï¼Œæœ¬è´¨ä¸Šæ˜¯å¯¹å…±çŽ°çŸ©é˜µçš„é™ç»´å¤„ç†ã€‚æ¯ä¸€è¡Œè¡¨ç¤ºä¸€ä¸ªwordï¼Œæ¯ä¸€åˆ—è¡¨ç¤ºcontextï¼Œå…±çŽ°çŸ©é˜µå°±æ˜¯è®¡ç®—æ¯ä¸ªword åœ¨æ¯ä¸ªcontext ä¸­å‡ºçŽ°çš„é¢‘çŽ‡ã€‚ fasttext å’Œword2vec çš„åŒºåˆ«ï¼šè¾“å…¥å±‚ï¼Œword2vec æ˜¯ä¸€ä¸ªtermï¼Œè€Œfasttextä¸­åŒ…å«çš„æ˜¯termå’Œå¯¹åº”çš„n-gramçš„ç‰¹å¾ï¼›è¾“å‡ºå±‚ï¼Œ åœ¨åˆ†ç±»ä¸­fasttextçš„è¾“å‡ºæ˜¯label ä¿¡æ¯ã€‚]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hyper-parameter Optimization for Machine Learning]]></title>
    <url>%2F2019%2F05%2F22%2FHyperparameter-optimization-for-machine-learning%2F</url>
    <content type="text"><![CDATA[Following are four common methods of hyper-parameter optimization for machine learning in order of increasing efficiency: Manual Grid search Random search Bayesian model-based optimization ç®€å•è¯´ä¸€ä¸‹å‰ä¸¤ç§ï¼Œ manual é€‚åˆæ¯”è¾ƒæœ‰ç»éªŒçš„äººè¿›è¡Œè°ƒå‚ï¼Œæ•´ä¸€ä¸ªæ¨¡åž‹å¥½ä¹…äº†ï¼Œå¯¹å‚æ•°çš„è®¾ç½®æ¯”è¾ƒç†Ÿæ‚‰ï¼›Grid Search æœ€å¥½çš„ç†è§£æ–¹å¼å°±æ˜¯ æžšä¸¾ï¼Œå¦‚æžœæ—¶é—´å……è¶³é‚£ä¹ˆå¯ä»¥æ‰¾åˆ° search space ä¸­çš„æœ€ä¼˜è§£ã€‚ä½†å¦‚æžœæ˜¯ limited time and spaceï¼Œ é‚£ä¹ˆè¯·ä½¿ç”¨ random search æˆ–è€…åŸºäºŽè´å¶æ–¯çš„å¼€æºåŒ…ã€‚ Random SearchFirst we will implement a common technique for hyper-parameter optimization: random search. Each iteration, we choose a random set of model hyper-parameters from a search space. Random search uses the following four parts: Domain: values over which to search Optimization algorithm: pick the next values at random! (yes this qualifies as an algorithm) Objective function to minimize: in this case our metric is cross validation ROC AUC Results history that tracks the hyper-parameters tried and the cross validation metric Random search can be implemented in the Scikit-Learn library using RandomizedSearchCV, however, because we are using Early Stopping (to determine the optimal number of estimators), we will have to implement the method ourselves (more practice!). This is pretty straightforward, and many of the ideas in random search will transfer over to Bayesian hyper-parameter optimization. Empirically, random search is very effective, returning nearly as good results as grid search with a significant reduction in time spent searching. However, it is still an uninformed method in the sense that it does not use past evaluations of the objective function to inform the choices it makes for the next evaluation. Case Study of random search 123456789101112131415161718192021222324252627282930313233343536373839# Load librariesfrom scipy.stats import uniformfrom sklearn import linear_model, datasetsfrom sklearn.model_selection import RandomizedSearchCV# data and model# Load datairis = datasets.load_iris()X = iris.datay = iris.target# Create logistic regressionlogistic = linear_model.LogisticRegression()# Create hyper-parameter Search Space# Create regularization penalty space# å¦‚æžœæ¯”è¾ƒå°‘ï¼Œé‚£ä¹ˆä¹…æžšä¸¾å‡ºæ¥penalty = ['l1', 'l2']# å¦‚æžœæ˜¯æœ‰è§„å¾‹çš„è¿žç»­çš„ï¼Œå°±ä½¿ç”¨è¿™ç§æ–¹å¼åˆ—ä¸¾å‡ºæ¥# Create regularization hyper-parameter distribution using uniform distributionC = uniform(loc=0, scale=4)# Create hyper-parameter optionshyper-parameters = dict(C=C, penalty=penalty)# cv: cross validation, This approach involves randomly dividing the set of observations into k groups, or folds, of approximately equal size. The first fold is treated as a validation set, and the method is fit on the remaining k âˆ’ 1 folds.# Create randomized search 5-fold cross validation and 100 iterationsclf = RandomizedSearchCV(logistic, hyper-parameters, random_state=1, n_iter=100, cv=5, verbose=0, n_jobs=-1)# Fit randomized searchbest_model = clf.fit(X, y)# View best hyper-parameters# æ³¨æ„è¿™ç§èŽ·å–best params çš„æ–¹å¼print('Best Penalty:', best_model.best_estimator_.get_params()['penalty'])print('Best C:', best_model.best_estimator_.get_params()['C'])# Predict target vectorbest_model.predict(X) Comparison between Grid Search and Random Search 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import numpy as npfrom time import timefrom scipy.stats import randint as sp_randintfrom sklearn.model_selection import GridSearchCVfrom sklearn.model_selection import RandomizedSearchCVfrom sklearn.datasets import load_digitsfrom sklearn.ensemble import RandomForestClassifier# get some datadigits = load_digits()X, y = digits.data, digits.target# build a classifierclf = RandomForestClassifier(n_estimators=20)# Utility function to report best scoresdef report(results, n_top=3): for i in range(1, n_top + 1): candidates = np.flatnonzero(results['rank_test_score'] == i) for candidate in candidates: print("Model with rank: &#123;0&#125;".format(i)) print("Mean validation score: &#123;0:.3f&#125; (std: &#123;1:.3f&#125;)".format( results['mean_test_score'][candidate], results['std_test_score'][candidate])) print("Parameters: &#123;0&#125;".format(results['params'][candidate])) print("")# specify parameters and distributions to sample fromparam_dist = &#123;"max_depth": [3, None], "max_features": sp_randint(1, 11), "min_samples_split": sp_randint(2, 11), "bootstrap": [True, False], "criterion": ["gini", "entropy"]&#125;# run randomized searchn_iter_search = 20random_search = RandomizedSearchCV(clf, param_distributions=param_dist, n_iter=n_iter_search, cv=5, iid=False)start = time()random_search.fit(X, y)print("RandomizedSearchCV took %.2f seconds for %d candidates" " parameter settings." % ((time() - start), n_iter_search))report(random_search.cv_results_)# use a full grid over all parametersparam_grid = &#123;"max_depth": [3, None], "max_features": [1, 3, 10], "min_samples_split": [2, 3, 10], "bootstrap": [True, False], "criterion": ["gini", "entropy"]&#125;# run grid searchgrid_search = GridSearchCV(clf, param_grid=param_grid, cv=5, iid=False)start = time()grid_search.fit(X, y)print("GridSearchCV took %.2f seconds for %d candidate parameter settings." % (time() - start, len(grid_search.cv_results_['params'])))report(grid_search.cv_results_) Random search without in-built function: An example of Random Search all by yourself Bayesian hyper-parameter OptimizationThe one-sentence summary of Bayesian hyper-parameter optimization is: build a probability model of the objective function and use it to select the most promising hyper-parameters to evaluate in the true objective function. The basic idea is: spend a little more time selecting the next hyper-parameters in order to make fewer calls to the objective function. In the case of hyper-parameter optimization, the objective function is the validation error of a machine learning model using a set of hyper-parameters. The aim is to find the hyper-parameters that yield the lowest error on the validation set in the hope that these results generalize to the testing set. Evaluating the objective function is expensive because it requires training the machine learning model with a specific set of hyper-parameters. Ideally, we want a method that can explore the search space while also limiting evaluations of poor hyper-parameter choices. Bayesian hyper-parameter tuning uses a continually updated probability model to â€œconcentrateâ€ on promising hyper-parameters by reasoning from past results. æœ‰å¾ˆå¤šåŸºäºŽè¿™ç§æ€æƒ³çš„å®žçŽ°ï¼Œhyperopt åªæ˜¯å…¶ä¸­ä¸€ç§There are several Bayesian optimization libraries in Python which differ in the algorithm for the surrogate of the objective function. In this article, we will work with Hyperopt, which uses the Tree Parzen Estimator (TPE) Other Python libraries include Spearmint (Gaussian Process surrogate) and SMAC (Random Forest Regression). There are four parts to a Bayesian Optimization problem: Objective Function: what we want to minimize, in this case the validation error of a machine learning model with respect to the hyper-parameters ï¼ˆåŽŸæ¥model ä¸­çš„ objective functionï¼‰ Domain Space: hyper-parameter values to search over ï¼ˆè°ƒå‚ç©ºé—´ï¼‰ Optimization algorithm: method for constructing the surrogate model and choosing the next hyper-parameter values to evaluate ï¼ˆloss å’Œè°ƒå‚ç©ºé—´çš„ æ–°çš„å…³ç³»ï¼‰ Result history: stored outcomes from evaluations of the objective function consisting of the hyper-parameters and validation loss ï¼ˆresult æ²¡æœ‰ä»€ä¹ˆå¥½è¯´çš„ï¼‰ å…¶ä¸­çš„ Bayesian hyper-parameter Optimization using Hyperoptæ˜¯å¯ä»¥å¥½å¥½å­¦ä¹ çš„ã€‚ data scientists è¿™ç§ä¸œè¥¿æ›´åŠ è´´è¿‘äºŽ data scientist çœŸçš„ã€‚ ç»™å‡ºä¸¤ä¸ªå‚è€ƒä»£ç :é“¾æŽ¥ä¸€é“¾æŽ¥äºŒ]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Introduction to Natural Language Processing for Text]]></title>
    <url>%2F2019%2F05%2F21%2FIntroduction-to-Natural-Language-Processing-for-Text%2F</url>
    <content type="text"><![CDATA[Natural Language Processing is used to apply machine learning algorithms to text and speech. For example, we can use it to create systems like speech recognition, document summarization, machine translation, spam detection, named entity recognition, question answering, autocomplete, predictive typing and so on. NLTK (Natural Language Toolkit) is a leading platform for building Python programs to work with human language data. It provides easy-to-use interfaces to many corpora and lexical resources. Also, it contains a suite of text processing libraries for classification, tokenization, stemming, tagging, parsing, and semantic reasoning. Best of all, NLTK is a free, open source, community-driven project. In this article, weâ€™ll cover the following topics.è¿™äº›åŠŸèƒ½éƒ½æ˜¯å¯ä»¥ä½¿ç”¨nltk è¿›è¡Œå®žçŽ°çš„ã€‚text Lemmatization æ¯”å¦‚ï¼Œå•è¯â€œcarsâ€è¯å½¢è¿˜åŽŸåŽçš„å•è¯ä¸ºâ€œcarâ€ï¼Œå•è¯â€œateâ€è¯å½¢è¿˜åŽŸåŽçš„å•è¯ä¸ºâ€œeatâ€ã€‚ Sentence Tokenization æ®µè½æˆå¥ã€‚Sentence tokenization (also called sentence segmentation) is the problem of dividing a string of written language into its component sentences. The idea here looks very simple. In English and some other languages, we can split apart the sentences whenever we see a punctuation mark.ï¼ˆæ ‡ç‚¹ç¬¦å·ï¼‰ Word Tokenization å¥å­æˆè¯ï¼Œé¢—ç²’åº¦å˜å¾—æ›´å°ã€‚Word tokenization (also called word segmentation) is the problem of dividing a string of written language into its component words. In English and many other languages using some form of Latin alphabet, space is a good approximation of a word divider. Text Lemmatization è¯æ€§è¿˜åŽŸ and Stemming è¯å¹²æå– è¿™ç§æ“ä½œå¦‚æžœè¢«è®¤ä¸ºæ˜¯ä¸€ç§ normalizationï¼Œé‚£ä¹ˆä¸€ä¸ªä¼˜ç‚¹å°±æ˜¯åŠ å¿«äº†è¿è¡Œçš„é€Ÿåº¦ã€‚ä»Žä¸åŒçš„å½¢å¼åˆ°ç»Ÿä¸€çš„å½¢å¼ï¼Œè¿™å¯ä»¥è®¤ä¸ºå‡å°‘äº†å˜é‡ã€‚æ„Ÿè§‰è¿™ä¸ªæ›´åŠ æ¶‰åŠè¯­æ³•ï¼Œè¯­æ³•æ ‘ä¹‹ç±»çš„ä¸œè¥¿ã€‚For grammatical reasons, documents can contain different forms of a word such as drive, drives, driving. Also, sometimes we have related words with a similar meaning, such as nation, national, nationality. Stemming and lemmatization are special cases of normalization. However, they are different from each other. Stemming usually refers to a crude heuristic process that chops off the ends of words in the hope of achieving this goal correctly most of the time, and often includes the removal of derivational affixes.Lemmatization usually refers to doing things properly with the use of a vocabulary and morphological analysis of words, normally aiming to remove inflectional endings only and to return the base or dictionary form of a word, which is known as the lemma. Stop Wordså› ä¸º stop wordså¾€å¾€æ˜¯å¸¦äº† noise rather than useful informationï¼Œæ‰€ä»¥è¿™ä¸ªæ˜¯è¦åŽ»æŽ‰çš„ã€‚Stop words are words which are filtered out before or after processing of text. When applying machine learning to text, these words can add a lot of noise. Thatâ€™s why we want to remove these irrelevant words. stop words dictionary å¯ä»¥ç†è§£æˆä¸€ç§è¿‡æ»¤è¯è¡¨ï¼Œæ˜¯å¯ä»¥æ ¹æ®åº”ç”¨çš„ä¸åŒï¼Œç„¶åŽ changeçš„ã€‚Stop words usually refer to the most common words such as â€œandâ€, â€œtheâ€, â€œaâ€ in a language, but there is no single universal list of stopwords. The list of the stop words can change depending on your application. åœ¨å­˜å‚¨ stopword çš„æ—¶å€™ä½¿ç”¨ set rather than list ä¸»è¦åŽŸå› æ˜¯ much faster than search operations in a set.You might wonder why we convert our list into a set. Set is an abstract data type that can store unique values, without any particular order. The search operation in a set is much faster than the search operation in a list. For a small number of words, there is no big difference, but if you have a large number of words itâ€™s highly recommended to use the set type. Regex A kind of search pattern. A regular expression, regex, or regexp is a sequence of characters that define a search pattern. Letâ€™s see some basics. 12345678910. - match any character except newline\w - match word\d - match digit\s - match whitespace\W - match not word\D - match not digit\S - match not whitespace[abc] - match any of a, b, or c[^abc] - not match a, b, or c[a-g] - match a character between a &amp; g è¿™ä¸ªè§£é‡Šè¯´æ˜Žäº†ä¸ºä»€ä¹ˆåœ¨æ­£åˆ™è¡¨è¾¾å¼ ä¸­ä½¿ç”¨ râ€â€ ä½œä¸ºä¸€ç§å‰ç¼€ã€‚å› ä¸ºæ­£åˆ™è¡¨è¾¾æ˜¯ä¸­ â€\â€œ çš„ä½¿ç”¨å’Œ python ä¸­çš„â€\â€ ä½¿ç”¨æœ‰å†²çªã€‚ç®€è€Œè¨€ä¹‹ï¼Œå¦‚æžœåŠ ä¸Šäº† râ€â€ é‚£ä¹ˆè¿™ä¸ªå°±æ˜¯ä¸€ç§å®Œå…¨çš„ æ­£åˆ™è¡¨è¾¾å¼çš„è¯­æ³•äº†ã€‚ Regular expressions use the backslash character (â€˜\â€™) to indicate special forms or to allow special characters to be used without invoking their special meaning. This collides with Pythonâ€™s usage of the same character for the same purpose in string literals; for example, to match a literal backslash, one might have to write â€˜\\â€˜ as the pattern string, because the regular expression must be \, and each backslash must be expressed as \ inside a regular Python string literal.The solution is to use Pythonâ€™s raw string notation for regular expression patterns; backslashes are not handled in any special way in a string literal prefixed with â€˜râ€™. So râ€\nâ€ is a two-character string containing â€˜\â€™ and â€˜nâ€™, while â€œ\nâ€ is a one-character string containing a newline. Usually, patterns will be expressed in Python code using this raw string notation. An example, 1234import resentence = "The development of snowboarding was inspired by skateboarding, sledding, surfing and skiing."pattern = r"[^\w]"print(re.sub(pattern, " ", sentence)) Bag of words Machine learning algorithms cannot work with raw text directly, we need to convert the text into vectors of numbers. This is called feature extraction.The bag-of-words model is a popular and simple feature extraction technique used when we work with text. It describes the occurrence of each word within a document. è¿™ä¸ªæ˜¯ bag of wordsçš„â€ç‰¹ç‚¹â€œï¼š order or structure of words æ²¡æœ‰ä½“çŽ°å‡ºæ¥ã€‚Any information about the order or structure of words is discarded. Thatâ€™s why itâ€™s called a bag of words. This model is trying to understand whether a known word occurs in a document, but donâ€™t know where is that word in the document. The intuition is that similar documents have similar contents. Also, from a content, we can learn something about the meaning of the document. To use this model, we need to: Design a vocabulary of known words (also called tokens) Choose a measure of the presence of known words 1) æœ€ç®€å•çš„æ–¹å¼æ˜¯ â€œoccurrenceâ€ ï¼Œå¦‚æžœå‡ºçŽ°äº† æ ‡ä¸º1 å¦åˆ™æ ‡ä¸º0ï¼›è¿™ç§æ˜¯æœ€ä¸ºç®€å•çš„ bag of words æœ€çš„æ–¹å¼ï¼Œè¿™å››ä¸ªæ˜¯ä¸€ä¸€å¯¹åº”çš„ã€‚æ³¨æ„ä½“ä¼šã€‚ The complexity of the bag-of-words model comes in deciding how to design the vocabulary of known words (tokens) and how to score the presence of known words. bag of words ä¸­ä½¿ç”¨ â€œoccurrenceâ€ çš„æ–¹å¼çš„ç¼ºç‚¹ï¼šç¨€ç–çŸ©é˜µï¼ˆå½“dict å¾ˆå¤§çš„æ—¶å€™ï¼Œæ–‡ç« çš„ representationä¸­æœ‰ç›¸å½“æˆåˆ†çš„0ï¼‰ã€‚ In some cases, we can have a huge amount of data and in this cases, the length of the vector that represents a document might be thousands or millions of elements. Furthermore, each document may contain only a few of the known words in the vocabulary.Therefore the vector representations will have a lot of zeros. These vectors which have a lot of zeros are called sparse vectors. They require more memory and computational resources.We can decrease the number of the known words when using a bag-of-words model to decrease the required memory and computational resources. We can use the text cleaning techniques weâ€™ve already seen in this article before we create our bag-of-words model: å‡å°‘ dictionary size çš„æ–¹å¼ã€‚ Ignoring punctuationRemoving the stop words from our documentsReducing the words to their base form (Text Lemmatization and Stemming)Fixing misspelled words n-gram çš„æ€æƒ³æ˜¯å¾ˆå¹¿æ³›ï¼šé€šè¿‡ sequence of wordsï¼Œè¿™ä¸ªæ˜¯å¯ä»¥å¢žåŠ æ–‡æœ¬çš„è¡¨è¾¾åŠ›çš„ã€‚An n-gram is a sequence of a number of items (words, letter, numbers, digits, etc.). In the context of text corpora, n-grams typically refer to a sequence of words. A unigram is one word, a bigram is a sequence of two words, a trigram is a sequence of three words etc. å…³äºŽå¦‚ä½•åŽ» score the presence of wordï¼š è¿™é‡Œæ˜¯æœ‰ä¸‰ç§æ–¹å¼çš„ã€‚We saw one very simple approach - the binary approach (1 for presence, 0 for absence).Some additional scoring methods are:2) Counts. Count the number of times each word appears in a document.3) Frequencies. Calculate the frequency that each word appears in document out of all the words in the document. TF-IDF è¿™ä¸ªè¯­å¢ƒ æ˜¯ç›¸å¯¹äºŽ frequency è€Œè¨€çš„ï¼Œå…³é”®è¯æ˜¯ä¸ä¸€å®šæœ‰ é¢‘çŽ‡æ‰€å†³å®šï¼Œè€Œä¸€äº› rarer or domain-specific words å¯èƒ½æ˜¯æ›´åŠ å¸¸è§çš„ã€‚One problem with scoring word frequency is that the most frequent words in the document start to have the highest scores. These frequent words may not contain as much â€œinformational gainâ€ to the model compared with some rarer and domain-specific words. One approach to fix that problem is to penalize words that are frequent across all the documents. This approach is called TF-IDF. TF-IDF çš„å…³é”®åœ¨äºŽä½“çŽ°äº†â€œè¯­æ–™åº“â€ã€‚TF-IDF, short for term frequency-inverse document frequency is a statistical measure used to evaluate the importance of a word to a document in a collection or corpus. å‚è€ƒèµ„æ–™https://towardsdatascience.com/introduction-to-natural-language-processing-for-text-df845750fb63]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-Recursion]]></title>
    <url>%2F2019%2F05%2F16%2Fleetcode-recursion%2F</url>
    <content type="text"><![CDATA[LeetCode åˆ·é¢˜æ€»ç»“ï¼ˆä¸‰ï¼‰ï¼Œ ä½¿ç”¨Python å®žçŽ°ã€‚è¯¥ç¯‡é¢˜ç›®ç±»åž‹ä¸»è¦åŒ…æ‹¬ï¼šrecursion, iteration å’Œdynamic programmingã€‚ Regular Expression Matching Given an input string (s) and a pattern (p), implement regular expression matching with support for â€˜.â€™ and â€˜ * â€˜ .â€˜.â€™ Matches any single character.â€˜*â€˜ Matches zero or more of the preceding element. Tipsï¼šå…¸åž‹çš„dpï¼ŒäºŒç»´æ•°ç»„æ˜¯å¸¸è§çš„æ–¹å¼ã€‚ å¦‚æžœçœ‹ä¸æ‡‚æ³¨é‡Šï¼Œå¯ä»¥çœ‹è¿™é‡Œ 1234567891011121314151617181920212223242526272829303132333435class Solution(object): """ dp, dp[i][j] means the match status between p[:i] and s[:j] """ def isMatch(self, s, p): dp =[[False]*(len(s)+1) for _ in range(len(p) +1)] dp[0][0]= True # case, of when s is an empty string but p is not, # since each * can eliminate character before it for i in range(2, len(p)+1): dp[i][0] =dp[i-2][0] and p[i-1] =="*" for i in range(1, len(p)+1): for j in range(1, len(s)+1): if p[i-1] =='*': # elimination or propagations dp[i][j] =dp[i-2][j] or dp[i-1][j] # another case, propagations if p[i-2] ==s[j-1] or p[i-2] =='.': # ä¸‹é¢ä¸¤ç§å†™æ³•éƒ½æ˜¯å¯ä»¥ # dp[i][j] = dp[i][j] or dp[i][j-1] dp[i][j] |= dp[i][j-1] else: # å¯¹äºŽand è¿™ä¸ªè¯­å¥å°±ç±»ä¼¼ if è¯­å¥, ä¸‹é¢ä¸¤ç§å†™æ³•éƒ½æ˜¯å¯ä»¥çš„ #dp[i][j] =dp[i-1][j-1] and (p[i-1] ==s[j-1] or p[i-1] =='.') if p[i-1] ==s[j-1] or p[i-1] =='.': dp[i][j] =dp[i-1][j-1] return dp[-1][-1] Wildcard Matching Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for â€˜?â€™ and â€˜*â€˜.â€˜?â€™ Matches any single character.â€˜*â€˜ Matches any sequence of characters (including the empty sequence). Input:s = â€œaaâ€p = â€œaâ€Output: falseExplanation: â€œaâ€ does not match the entire string â€œaaâ€. Tips: Wildcard é€šé…ç¬¦ï¼Œè¿™ä¸ªå’Œä¸Šä¸€ä¸ªåŸºæœ¬ç›¸åŒå•Šï¼Œ 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution(object): """ è¿™ä¸ªæ›´åŠ ç®€å•ï¼Œwhile å°±æ˜¯èƒ½å¤Ÿæžå®šçš„ï¼Œç„¶åŽå¯¹äºŽ ç‰¹æ®Šç¬¦å·ç‰¹æ®Šåˆ¤æ–­ã€‚ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆè¿›è¡Œæ“ä½œ. s[i] ==p[j] å’Œ p[j] =='?' ï¼Œè¿™ä¸ªæ˜¯å¯ä»¥æ”¾åˆ°åŒä¸€ä¸ª if æ¡ä»¶ä¸‹çš„ã€‚ä¸¤è€…æ˜¯ç­‰ä»·çš„ã€‚ å…³é”®æ˜¯ * çš„åŒ¹é… 2ï¼Œåœ¨ p ä¸­å‡ºçŽ° * æ—¶ï¼Œè®°å½• p ä¸­ * çš„ä½ç½®ï¼ŒåŒæ—¶è®°å½•æ­¤æ—¶ s çš„ä½ç½®ã€‚ 3ï¼Œä»Ž * çš„åŽé¢çš„ç¬¬ä¸€ä¸ªå­—ç¬¦å¼€å§‹åŒ¹é…ã€‚å¦‚æžœåŒ¹é…å¤±è´¥ï¼Œè¿”å›ž s å¤„ï¼Œä»Ž s++ å¼€å§‹é‡æ–°åŒ¹é…ã€‚ """ def isMatch(self, s, p): """ :type s: str :type p: str :rtype: bool """ j = i = ss = 0; star = -1 # é¦–å…ˆæŠŠ string ä¸­çš„å­—ç¬¦æ¯”å®Œ while i &lt; len(s): if j &lt; len(p) and (s[i] == p[j] or p[j] == '?'): i += 1; j += 1 continue # star è®°å½•çš„æ˜¯ j çš„ä½ç½®ï¼Œç›¸åº”çš„ ss æ˜¯è®°å½•çš„i (string) ä¸­çš„ä½ç½® if j &lt; len(p) and p[j] == '*': star = j; j += 1; ss = i; continue # å¦‚æžœå·²ç»æœ‰äº† star çš„å‡ºçŽ°ï¼Œ åˆ°è¿™é‡Œå·²ç»è¯´æ˜Ž starçš„ä¸‹ä¸€ä¸ªå’Œ string ä¸­çš„ä½ç½®å…ƒç´ ä¸æ˜¯exact çš„åŒ¹é… # æ‰€ä»¥è¿™é‡Œè¿›è¡Œäº† ss +=1 çš„æ“ä½œæ˜¯ä¸ºäº†ï¼Œç›¸å½“äºŽæŠŠ string ä¸­çš„char ä½¿ç”¨ * è¿›è¡Œäº†ä»£æ›¿ # å¥½å¥½ç†è§£ä¸€ä¸‹ if star != -1: j = star + 1; ss += 1; i = ss continue return False # string å·²ç»æ¯”è¾ƒå®Œäº†ï¼Œå¦‚æžœåªå‰©ä¸‹ * é‚£ä¹ˆæ˜¯å¯ä»¥è¡Œçš„ï¼Œå¦åˆ™æ˜¯ä¸å¯è¡Œçš„ while j &lt; len(p) and p[j] == '*': j += 1 if j == len(p): return True return False Valid Parentheses Given a string containing just the characters â€˜(â€˜, â€˜)â€™, â€˜{â€˜, â€˜}â€™, â€˜[â€˜ and â€˜]â€™, determine if the input string is valid. Tips: å¿…é¡»è¦ä½¿ç”¨ len(stack) è¿›è¡Œæ£€æµ‹ï¼Œå› ä¸ºä¸­é—´çš„æ—¶å€™ä¹Ÿå¯èƒ½ len(stack) æ˜¯ç­‰äºŽ0çš„ï¼Œè¿™æ—¶å€™åªèƒ½æ˜¯ append() ï¼Œä¸èƒ½è®¿é—® stack[-1] 123456789101112131415161718192021class Solution(object): def isMatch(self, l, r): return l =='[' and r==']' or l =='(' and r ==')' or l =='&#123;' and r =='&#125;' def isValid(self, s): len_s =len(s) if len_s ==0: return True stack =[] for ch in s: if len(stack) ==0 or not self.isMatch(stack[-1], ch): stack.append(ch) else: stack.pop() return len(stack) ==0 Generate Parentheses Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: [ â€œ((()))â€, â€œ(()())â€, â€œ(())()â€, â€œ()(())â€, â€œ()()()â€] Tips: dfs, left_count è¡¨ç¤ºæ˜¯ â€˜(â€˜ çš„æ€»æ•°ï¼Œ left_remain è¡¨ç¤º left- right çš„å·®å€¼. 12345678910111213141516171819202122232425class Solution(object): def DogenerateParenthesis(self, n, left_count, left_remain, prefix): if n ==left_count and left_remain ==0: return [prefix] left =[] right =[] if left_count &lt;n: left =self.DogenerateParenthesis(n, left_count+1, left_remain+1, prefix+'(') if left_remain&gt;0: right =self.DogenerateParenthesis(n, left_count, left_remain-1, prefix+')') return left +right def generateParenthesis(self, n): """ :type n: int :rtype: List[str] """ if n ==0: return [] else: list =self.DogenerateParenthesis(n ,0, 0, "") return list Combination Sum Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.The same repeated number may be chosen from candidates unlimited number of times. Tips: è¿™ç§æ‰¾åˆ°æ‰€æœ‰ç¬¦åˆé¢˜ç›®è¦æ±‚çš„è§£ï¼Œåä¹‹å…«ä¹éƒ½æ˜¯è¦ä½¿ç”¨é€’å½’ã€‚æœ€ä¼˜è§£ï¼ˆæœ€å€¼ï¼‰ä¸€èˆ¬æ˜¯ä½¿ç”¨dpï¼Œå‡å°‘å­é—®é¢˜çš„è¿ç®—ã€‚è¿™é‡Œç»™å‡ºäº† list å’Œdfs çš„ç»“åˆä½¿ç”¨ï¼Œé€šè¿‡ä¼ å…¥ start indexæ¥è§£å†³æ˜¯å¦éåŽ†è¿‡çš„é—®é¢˜ã€‚ ç¤ºæ„å›¾ï¼š 12345678910111213141516171819202122class Solution(object): def dfs(self, candidates, target, start, intermedia, res): # target è¿™ä¸ªå˜é‡è°ƒèŠ‚äº†æ˜¯ ç»§ç»­deeper or returnï¼Œ æ¯ä¸€æ¬¡éƒ½æ˜¯åœ¨å˜åŒ–çš„ã€‚å¦‚æžœ ==0ï¼Œé‚£ä¹ˆå°±return äº† if target ==0: res.append(intermedia) return for i in range(start, len(candidates)): if target &lt; candidates[i]: return self.dfs(candidates, target-candidates[i], i, intermedia+[candidates[i]], res) def combinationSum(self, candidates, target): """ :type candidates: List[int] :type target: int :rtype: List[List[int]] """ candidates.sort() res =[] self.dfs(candidates, target, 0, [], res) return res Combination Sum II Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.Each number in candidates may only be used once in the combination. Tipsï¼š è¿™é‡Œç»™å‡ºäº†å¦å¤–ä¸€ç§éåŽ†list å’Œdfs çš„æ–¹æ³•ï¼Œä¼ å…¥çš„æ˜¯éƒ¨åˆ† listï¼Œä¸Šé¢é‚£é“é¢˜ä¼ å…¥äº†å®Œæ•´çš„listã€‚ 123456789101112131415161718192021222324252627class Solution(object): # @param &#123;integer[]&#125; candidates # @param &#123;integer&#125; target # @return &#123;integer[][]&#125; def combinationSum2(self, candidates, target): candidates.sort() # æŽ’åºä¸å½±å“ æ—¶é—´å¤æ‚åº¦çš„ï¼Œå› ä¸ºæ—¶é—´å¤æ‚åº¦å¤§äºŽæŽ’åºçš„æ—¶é—´å¤æ‚åº¦ #res=set() res =[] self.findcombination(candidates,target,[],res) #return [list(i) for i in res] return res def findcombination(self,candidates,target,ls,res): if target==0 and ls not in res: # å¯¹äºŽ set() ä¸­ä½¿ç”¨ add() ï¼Œlist ä¸­ä½¿ç”¨ append() #res.add(tuple(ls)) res.append(ls) return # ä¸‹é¢è¿™ä¸ªåˆ¤æ–­ç”¨å’Œä¸ç”¨ éƒ½æ˜¯ç›¸åŒçš„æ•ˆæžœ(æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦ä¸Š) if target&lt;0: return # not use: c72 ms,11.7M for i in range(len(candidates)): if target&lt;candidates[i]: return self.findcombination(candidates[i+1:],target-candidates[i],ls+[candidates[i]],res) Permutations Given a collection of distinct integers, return all possible permutations. Input: [1,2,3]Output:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] Tips : extend æ˜¯å› ä¸ºlist of list ï¼Œè€Œä¸æ˜¯å•ç‹¬çš„listï¼Œè¿™æ ·èƒ½ä¿è¯æœ€åŽçš„ç»“æžœè¿˜æ˜¯ list of list 123456789101112131415161718192021class Solution(object): def permute(self, nums): return self.doPermute(nums) def doPermute(self, num_list): if len(num_list) ==1: return [num_list] res_list =[] for i in range(len(num_list)): num_list[0], num_list[i] =num_list[i], num_list[0] sub_list =self.doPermute(num_list[1:]) list_head =[num_list[0]] #new_list =list_head+ sub_list new_list = [list_head + list1 for list1 in sub_list] # å¯ä»¥ç†è§£è¿™ä¸ªæ˜¯ sub_list æ˜¯æœ‰ä¸€ç³»åˆ—çš„è§£ï¼Œ ç„¶åŽå†æ¯ä¸ªè§£ä¸Šéƒ½åŠ ä¸Šä¸€ä¸ªå¤´å…ƒç´  res_list.extend(new_list) # extendï¼ŒThe list.extend method extends a list by appending elements from an iterable # append æ˜¯å½“åšä¸€ä¸ªæ•´ä½“è¿›è¡Œæ“ä½œ return res_list Permutations II Given a collection of numbers that might contain duplicates, return all possible unique permutations. Tipsï¼š è¿™ä¸ª duplicates æ˜¯é€šè¿‡ sort å‡½æ•°ï¼Œç„¶åŽåœ¨é€‰æ‹© æŸä¸ªindex æ—¶å€™ï¼Œè¿›è¡Œåˆ¤æ–­ä¸€ä¸‹æ˜¯å¦å’Œç¬¬ä¸€ä¸ªé‡åˆï¼Œè¿™æ ·çš„æ–¹å¼åŽ»handleã€‚ 12345678910111213141516171819202122232425262728class Solution(object): def doPermuteUnique(self, nums): if len(nums) ==1: return [nums] res_list =[] for i in range(len(nums)): if i&gt;0 and nums[0] ==nums[i]: continue nums[0], nums[i] =nums[i], nums[0] sub_list =self.doPermuteUnique(nums[1:]) list_head =[nums[0]] new_list =[list_head +list1 for list1 in sub_list] res_list.extend(new_list) return res_list def permuteUnique(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ nums.sort() return self.doPermuteUnique(nums) Climbing Stairs You are climbing a stair case. It takes n steps to reach to the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?Note: Given n will be a positive integer. Tipsï¼š æ•°å­¦é¢˜ï¼Œæ–æ³¢é‚£å¥‘æ•°åˆ—ã€‚ è§£æ³•ä¸€ï¼š 12345678910111213141516171819202122class Solution(object): # å¯ä»¥æ¢æˆæ•°å­¦æ¨¡åž‹ï¼Œå‘çŽ°å°±æ˜¯ æ–æ³¢é‚£å¥‘æ•°åˆ— # ä¸ä½¿ç”¨æ•°å­—ï¼Œä½¿ç”¨ä¸‰ä¸ªå˜é‡ä¹Ÿæ˜¯å¯ä»¥çš„é¢ def climbStairs(self, n): """ :type n: int :rtype: int """ if n ==1: return 1 elif n ==2: return 2 arr = [0] *(n+1) arr[1] =1 arr[2] =2 for i in range(3, n+1): arr[i] =arr[i-1] +arr[i-2] return arr[n] è§£æ³•äºŒ123456789101112def climbStairs(self, n): if n ==1: return 1 elif n ==2: return 2 a, b =1,2 c =0 for i in range(3, n+1): c = a+b a, b =b,c return c Combinations Given two integers n and k, return all possible combinations of k numbers out of 1 â€¦ n. Tipsï¼š è¿™ä¸ªæ˜¯å¤„ç†çš„list å’Œ dfs()çš„é—®é¢˜ï¼Œç„¶åŽä½¿ç”¨çš„ä¼ å…¥ indexå’Œå®Œæ•´çš„ list æ¥æŽ§åˆ¶è¿›åº¦ã€‚ 12345678910111213141516171819202122class Solution(object): """ å¥½å¥½ç†è§£é€’å½’è¿™ç§é€æ¸åŠ æ·±çš„å±‚æ¬¡ """ def combine(self, n, k): res =[] self.dfs(list(range(1, n+1)), k, 0, [], res) return res def dfs(self, nums, k, index, path, res): # backtracking #if k &lt;0: #return # è¿™ç§ return å’Œresult ç»“åˆä½¿ç”¨çš„æ“ä½œæ˜¯ç»å¸¸å¸¸è§çš„ if k ==0: res.append(path) return # è¿™ä¸ªindex æ˜¯å¾ˆé‡è¦çš„ï¼Œ åœ¨è¿™ä¸ªindex çš„åŸºç¡€ä¸Šé€‰æ‹©çš„ for i in range(index, len(nums)): self.dfs(nums, k-1, i +1, path+ [nums[i]], res) Subsets Given a set of distinct integers, nums, return all possible subsets (the power set). Tips: ä½¿ç”¨çš„æ˜¯ç¬¬äºŒç§æ–¹å¼ï¼Œä¼ å…¥éƒ¨åˆ†listï¼Œä»Žè€Œç”±å¤§é—®é¢˜è½¬ç§»æˆå°é—®é¢˜ã€‚ 12345678910111213141516class Solution(object): # è¿™ç§æ˜¯æœ€ç®€å•çš„æ·±åº¦ä¼˜å…ˆçš„æœç´¢äº†ï¼Œ def subsets(self, nums): res =[] self.dfs(nums, [], res) return res def dfs(self, nums, path, res): # ä¸€èˆ¬æ¥è¯´è¿™ä¸ªæ˜¯æœ‰è·³å‡ºæ¡ä»¶ï¼Œå›žæº¯çš„ï¼Œä½†æ˜¯è¿™ç§æƒ…å†µæ˜¯æ²¡æœ‰çš„ï¼Œåªæœ‰æœ€åŽä¸€ä¸ª # [[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]ï¼Œ å½“è¾“å‡º [1, 2,3] çš„æ—¶å€™ï¼Œreturnï¼Œä½†æ˜¯è¿™ä¸ªreturn åˆ°äº† [1, 3] è¿™ä¸ªå±‚æ¬¡ res.append(path) for i in range(len(nums)): self.dfs(nums[i+1:], path+[nums[i]], res) Subsets II Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Tipsï¼š è¿™ä¸ªå«æœ‰duplicatesï¼Œä½¿ç”¨åŠŸèƒ½sort ç„¶åŽåœ¨ for å¾ªçŽ¯ çš„æ—¶å€™è¿›è¡Œåˆ¤æ–­ä¸€ä¸‹ã€‚ 123456789101112131415161718192021222324class Solution(object): # é€’å½’ def subsetsWithDup(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ res =[] nums.sort() self.dfs(nums, 0, [], res) return res def dfs(self, nums, index, path, res): if path not in res: res.append(path) #res.append(path) for i in range(index, len(nums)): if i &gt; index and nums[i] ==nums[i-1]: continue self.dfs(nums, i+1, path+[nums[i]], res) # ä¸‹é¢çš„ä»£ç æ˜¯é”™è¯¯çš„ memory ä½†æ˜¯ä¸çŸ¥é“ä¸ºä»€ä¹ˆ Decode Ways A message containing letters from A-Z is being encoded to numbers using the following mapping: &apos;A&apos; -&gt; 1 &apos;B&apos; -&gt; 2 ... &apos;Z&apos; -&gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it. Tipsï¼š å¤šå°‘ç§è§£ç æ–¹å¼ã€‚æœ¬è´¨æ˜¯è£´æ³¢æ‹‰å¥‘æ•°åˆ—, æ„Ÿè§‰è‡ªå·±å¹¶æ²¡æœ‰get åˆ°è¿™ä¸ªæœ¬è´¨ä¸Šæ˜¯ è¯¥æ•°åˆ— 1234567891011121314151617181920212223242526class Solution(object): """ DP[i] = DP[i-1] + DP[i-2] \ \___________(if str[i-2] exists and 10&lt;= int(str[i-1] + str[i]))&lt;=26 ) \___________(If str[i-1] exists and str[i] != '0' ) """ def numDecodings(self, s): """ :type s: str :rtype: int """ if not s: return 0 if s =='10': return 1 dp =[0] *(len(s) +1) dp[0] =1 for i in range(1, len(s)+1): if s[i-1] !='0': dp[i] +=dp[i-1] if i &gt;1 and '10' &lt;=s[i-2:i] &lt;='26': dp[i] += dp[i-2] return dp[-1] Binary Tree Inorder Traversal Given a binary tree, return the inorder traversal of its nodesâ€™ values. Tipsï¼š é€’å½’ã€‚ 1234567891011121314151617# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): # inorder ä¸­åºéåŽ†, recursive é€’å½’ï¼Œ iterative è¿­ä»£ # è¿™ä¸ªæ˜¯é€’å½’çš„ recursively def helper(self, root, res): if root: self.helper(root.left, res) res.append(root.val) self.helper(root.right, res) Tipsï¼š é€’å½’çš„å®¹æ˜“å†™ï¼Œå¾ªçŽ¯çš„ä¹Ÿå¥½ä¼šï¼Œä½¿ç”¨çš„stack å…ˆä¿å­˜å·¦å­æ ‘ï¼Œç„¶åŽä¸æ–­çš„node å…¶å³å­æ ‘ã€‚ 12345678910111213141516def inorderTraversal(self, root): # å¦‚æžœä½¿ç”¨ è¿­ä»£ï¼Œé‚£ä¹ˆå°±æ˜¯ stackç»“æž„äº† res, stack =[], [] while True: while root: stack.append(root) root =root.left if not stack: return res node =stack.pop() res.append(node.val) root =node.right Validate Binary Search Tree Given a binary tree, determine if it is a valid binary search tree (BST).Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the nodeâ€™s key. The right subtree of a node contains only nodes with keys greater than the nodeâ€™s key. Both the left and right subtrees must also be binary search trees. Tipsï¼š äºŒå‰æœç´¢æ ‘çš„ç‰¹ç‚¹ï¼Œä¸­åºéåŽ†ï¼Œå…ˆå¾—åˆ°éåŽ†ç»“æžœï¼Œç„¶åŽåˆ¤æ–­æ˜¯å¦æ˜¯ä¸å‡çš„ï¼ˆåªæ˜¯éœ€è¦O(N)ï¼‰. 1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isValidBST(self, root): """ :type root: TreeNode :rtype: bool """ output =[] self.inOrder(root, output) for i in range(1, len(output)): if output[i-1] &gt;= output[i]: return False return True def inOrder(self, root, output): if not root: return self.inOrder(root.left, output) output.append(root.val) self.inOrder(root.right, output) Same Tree Given two binary trees, write a function to check if they are the same or not.Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Tips: å¯¹åº”çš„å€¼ç›¸åŒï¼Œå¯¹åº”çš„ç»“æž„ç›¸åŒã€‚ 1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): # æ ¹æ®ä¸Šä¸€ä¸€ä¸ªé¢˜ç›®çš„è¦æ±‚ï¼Œè¿™ä¸ªæ˜¯ä¹Ÿæ˜¯å¯ä»¥å…ˆè¿›è¡ŒéåŽ†ï¼Œç„¶åŽå†æ¯”è¾ƒæœ€åŽçš„éåŽ†ç»“æžœå— def isSameTree(self, p, q): """ :type p: TreeNode :type q: TreeNode :rtype: bool """ if not p and not q: return True elif not p or not q: return False if p.val ==q.val: return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) else: return False Symmetric Tree Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). Tipï¼š å¯¹ç§°å’Œ same æ˜¯åœ¨äºŽæ¯”è¾ƒçš„æ–¹å¼æ˜¯ä¸ä¸€æ ·çš„ã€‚ 1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): # è¯¥é¢˜ç›®å’Œ isSameTree æ˜¯æœ‰ç‚¹ç›¸ä¼¼çš„ï¼Œåªæ˜¯ä¿®æ”¹éƒ¨åˆ†ä»£ç å°±å¯ä»¥ def isSymmetric(self, root): """ :type root: TreeNode :rtype: bool """ # è¿™ä¸ªå¦‚æžœæ˜¯ [] æˆ–è€… Noneï¼Œ æ˜¯è¿”å›žtrueï¼Œ å› ä¸ºè¾“å…¥çš„å½¢å¼æ˜¯ list ï¼Œæ‰€ä»¥åˆ¤æ–­æ¡ä»¶æ˜¯ if root ==[], è¿™æ ·å½¢å¼ if not root: return True return self.dfs(root.left, root.right) def dfs(self, p, q): if not p and not q: return True elif not p or not q: return False if p.val == q.val: return self.dfs(p.left, q.right) and self.dfs(p.right, q.left) else: return False Binary Tree Zigzag Level Order Traversal Given a binary tree, return the zigzag level order traversal of its nodesâ€™ values. (ie, from left to right, then right to left for the next level and alternate between). For example:Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7ç»“æžœæ˜¯è¿™æ ·çš„ï¼š[ [3], [20,9], [15,7]] Tipsï¼š ä¸€è¡Œæ˜¯ä»Žå·¦å¾€å³ï¼Œä¸€è¡Œæ˜¯ä»Žå³å¾€å·¦ã€‚å±‚åºéåŽ†çš„å˜ä½“ã€‚ä»Žå·¦å‘å³ä½¿ç”¨ append() ï¼Œç„¶åŽä»Žå³å‘å·¦ä½¿ç”¨ insert()ï¼Œè¿™ä¸ªæ˜¯æ²¡æœ‰é—®é¢˜çš„ã€‚ 12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): # å±‚æ¬¡éåŽ† + å¥‡å¶æ€§æ¥å†³å®šæ˜¯å¦ reverse def zigzagLevelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ res = [] self.dfs(root, 0, res) return res def dfs(self, root, level, res): if root: if len(res) &lt; level + 1: res.append([]) if level % 2 == 0: res[level].append(root.val) else: res[level].insert(0, root.val) self.dfs(root.left, level+1, res) self.dfs(root.right, level+1, res) Maximum Depth of Binary Tree Given a binary tree, find its maximum depth.The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.Note: A leaf is a node with no children. Tips: å·¦å³å­æ ‘çš„max+1ï¼Œè¿™ä¸ªæ˜¯æ ‘çš„æ·±åº¦ã€‚ 12345678910111213141516171819# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): # é€’å½’ï¼Œ æœ€ç®€å•çš„æ–¹å¼ def maxDepth(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 # è¿™ä¸ªæ˜¯æœ€ç®€å•çš„ä»£ç äº† return 1 +max(self.maxDepth(root.left), self.maxDepth(root.right)) Binary Tree Level Order Traversal II Given a binary tree, return the bottom-up level order traversal of its nodesâ€™ values. (ie, from left to right, level by level from leaf to root). Tips: å±‚åºéåŽ†ï¼Œä½†æ˜¯ res éœ€è¦å­˜å‚¨æˆlist of listï¼Œè¿™æ ·æœ€åŽè¿›è¡Œreverseï¼Œèƒ½å¤Ÿè¡¨ç¤ºå‡º å±‚æ•°çš„ä¿¡æ¯ã€‚ 1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): # éœ€è¦æœ‰ä¸€ä¸ª levelçš„indexï¼Œ ç„¶åŽç¿»è½¬å°±è¡Œäº† def levelOrderBottom(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ res =[] self.dfs(root, 0, res) #res è¿™ä¸ªæ˜¯æ•´ä½“çš„å¯¼è‡´ï¼Œä¸€å±‚ elementçš„å€’ç½®ï¼Œä¸æ¶‰åŠ elementå†…éƒ¨çš„å€’ç½® return res[::-1] def dfs(self, root, level, res): if root: if len(res) &lt; level+1: res.append([]) # è¿™ä¸ªæ˜¯append ä¸€ä¸ªç©ºçš„ [] è¿™ç§ç»“æž„ï¼Œç„¶åŽä¸‹é¢ä½¿ç”¨è¯¥ listï¼›å¦åˆ™çš„è¯ ç›´æŽ¥è¿›è¡Œappend res[level].append(root.val) # è¿™ä¸ªå¾ˆé‡è¦å“¦ self.dfs(root.left, level+1, res) self.dfs(root.right, level +1, res) Convert Sorted Array to Binary Search Tree Given an array where elements are sorted in ascending order, convert it to a height balanced BST.For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Tipsï¼š ä¸å‡çš„array å°±æ˜¯ binary search tree ä¸­çš„ä¸­åºéåŽ†çš„ç»“æžœã€‚é€’å½’æ€æƒ³ï¼Œå…ˆè¦æ‰¾åˆ° rootï¼Œç„¶åŽåˆ’åˆ†å·¦å³å­æ ‘ã€‚é€’å½’è¿›è¡Œã€‚ 1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): # balance tree è¿™ç§æ˜¯é€’å½’è¿›è¡Œå®šä¹‰çš„ï¼Œå·¦å³å­æ ‘ç›¸å·®æœ€å¤šä¸º1 # ä¸»è¦æ˜¯ä¸å¤ªæ¸…æ¥š å¦‚ä½•ä¿è¯è¿™ç§ balanced tree def sortedArrayToBST(self, nums): """ :type nums: List[int] :rtype: TreeNode """ if not nums: return None mid =len(nums)//2 root =TreeNode(nums[mid]) root.left =self.sortedArrayToBST(nums[:mid]) root.right =self.sortedArrayToBST(nums[mid+1:]) return root Balanced Binary Tree Given a binary tree, determine if it is height-balanced.For this problem, a height-balanced binary tree is defined as:a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Tipï¼šå·¦å³å­æ ‘çš„å·®å€¼ä¸èƒ½å¤§äºŽ1 ä¸ºbalancedï¼Œè¿™ä¸ªç›˜åˆ«é¢˜ç›®ï¼Œæ¯”è¾ƒå®¹æ˜“ï¼Œé‡ç‚¹æ˜¯ getHeight() çš„å®žçŽ°ã€æ ¹èŠ‚ç‚¹æ˜¯ balancedï¼Œå·¦å³å­æ ‘ä¹Ÿæ˜¯balanced 1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): # ä½¿ç”¨äº†ä¹‹å‰çš„ æ±‚è§£ æ ‘çš„height çš„ä¸œè¥¿ï¼Œç„¶åŽä½¿ç”¨å®šä¹‰è¿›è¡Œåšé¢˜ def isBalanced(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True return abs(self.getHeight(root.left) -self.getHeight(root.right))&lt;2 and self.isBalanced(root.left) and self.isBalanced(root.right) def getHeight(self, root): if not root: return 0 return 1 +max(self.getHeight(root.left), self.getHeight(root.right)) Minimum Depth of Binary Tree Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.Note: A leaf is a node with no children. Tipï¼šæ±‚ heightçš„å˜å½¢ï¼Œå¦‚æžœæ˜¯å¶å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆè¿”å›ž 1+max(left, right) å¦åˆ™çš„è¯ï¼Œè¿”å›žå·¦å³å­æ ‘ä¸­è¾ƒå°çš„é«˜åº¦ã€‚å¦‚æžœæ˜¯æ±‚é«˜åº¦ï¼Œé‚£ä¹ˆå°±ä¸ç®¡äº†ä»€ä¹ˆæƒ…å†µä¸‹éƒ½æ˜¯è¿”å›ž max()+1 1234567891011121314151617181920212223# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): # æ±‚è§£æ ¹èŠ‚ç‚¹çš„å·¦å³å­æ ‘çš„æœ€å°é«˜åº¦ # å¦‚æžœå·¦å³å­æ ‘éƒ½æœ‰ï¼Œé‚£ä¹ˆå°±æ˜¯è°ƒç”¨è¯¥å‡½æ•°ï¼Œ å¦‚æžœæœ‰ä¸€ä¸ªåˆï¼Œé‚£ä¹ˆç›´æŽ¥æ±‚è§£é«˜åº¦å°±è¡Œäº† def minDepth(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 if not root.left or not root.right: # è¿™ä¸ªæ˜¯æ±‚è§£é«˜åº¦çš„ return 1 +max(self.minDepth(root.left), self.minDepth(root.right)) else: return min(self.minDepth(root.left), self.minDepth(root.right))+1 Path Sum Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.Note: A leaf is a node with no children. Tips: æœ‰æ¡ä»¶çš„dfs(), æœ‰æ¡ä»¶çš„è¿›è¡Œæ ‘çš„è·¯å¾„ï¼Œæ ‘åœ¨åŠ æ·±çš„åŒæ—¶ï¼Œtarget æ•°å­—ä¹Ÿæ˜¯ä¸æ–­çš„å‡å°‘ï¼Œæœ€åŽå¦‚æžœç›¸ç­‰ï¼Œé‚£ä¹ˆå°±æ˜¯ä¸€ä¸ªåˆé€‚çš„è§£ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): # æ ‘çš„è·¯å¾„ # æ€»ç»“ä¸€ä¸‹ any all è¿™ç§åˆ°è‡ªå·±çš„åšå®¢ """ any: Returns true if any of the items is True. It returns False if empty or all are false. Any can be thought of as a sequence of OR operations on the provided iterables. all: Returns true if all of the items are True (or if the iterable is empty). All can be thought of as a sequence of AND operations on the provided iterables. It also short circuit the execution i.e. stop the execution as soon as the result is known. """ def hasPathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: bool """ res =[] self.dfs(root, sum, res) return any(res) def dfs(self, root, target, res): if not root: return False # å¯¹äºŽå¶å­ç»“ç‚¹çš„å®šä¹‰ if not root.left and not root.right: if root.val == target: res.append(True) if root.left: self.dfs(root.left, target-root.val, res) if root.right: self.dfs(root.right, target-root.val, res) Path Sum II Given a binary tree and a sum, find all root-to-leaf paths where each pathâ€™s sum equals the given sum.Note: A leaf is a node with no children. Tipsï¼š è¿™ä¸ªå’Œä¸Šé¢çš„åŒºåˆ«åœ¨äºŽï¼Œä¸€ä¸ªæ˜¯ true or falseï¼Œä¸€ä¸ªfind all pathsï¼Œæ‰€ä»¥éœ€è¦æœ‰ä¸€ä¸ªå˜é‡åŽ»å­˜å‚¨æ­£ç¡®çš„è·¯å¾„ã€‚ 12345678910111213141516171819202122232425262728293031# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): # ä¸Šä¸€é“é¢˜ç›®æ˜¯ return true or falseï¼Œè¿™ä¸ªæ˜¯æ‰¾åˆ°æ‰€æœ‰çš„è·¯å¾„ def pathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: List[List[int]] """ res =[] self.dfs(root, sum, [], res) return res def dfs(self, root, target, path, res): if not root: return [] if not root.left and not root.right: if root.val == target: res.append(path+[root.val]) if root.left: #è¿™ç§æ¡ä»¶æ˜¯å¯ä»¥å‡å°‘è¿­ä»£çš„æ¬¡æ•° self.dfs(root.left, target-root.val, path+[root.val], res) if root.right: self.dfs(root.right, target-root.val, path+[root.val], res) Flatten Binary Tree to Linked List Given a binary tree, flatten it to a linked list in-place. Tipsï¼š æ¯”è¾ƒæœ‰æ„æ€ï¼Œå°† tree çš„å·¦å³å­æ ‘ flatten æˆ linked listçš„å·¦å³ç»“ç‚¹ã€‚å…¶ä¸­çš„ self.pre å°±ç±»ä¼¼ä¸€ç§å…¨å±€å˜é‡ï¼Œå°†æ•´ä¸ªéåŽ†ï¼Œ 1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): # è¿™ç§ flatten å°±æ˜¯ æ‹‰å¹³ï¼ˆå…ˆåºéåŽ†ï¼‰ï¼Œ ç„¶åŽè½¬æˆlinkedlist # å¹¶ä¸”è¿™ç§æ“ä½œæ˜¯è¦æ±‚ in-placeçš„ def __init__(self): self.pre =TreeNode('dummy') def flatten(self, root): """ :type root: TreeNode :rtype: None Do not return anything, modify root in-place instead. """ if not root: return tmp =root.right # è¿™ä¸ªä¿å­˜ä¸‹æ¥ï¼Œæ˜¯ä¸ºäº†ä¸‹é¢çš„flatten ä½¿ç”¨ self.pre.right =root self.pre.left =None self.pre =root self.flatten(root.left) self.flatten(tmp) Populating Next Right Pointers in Each Node You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: Tipï¼Œå±žäºŽæ ‘çš„ç»“æž„çš„ä¼˜åŒ–ï¼Œå¤šäº†ä¸€ä¸ªnext æŒ‡é’ˆæŒ‡å‘çš„æ˜¯åŒå±‚çš„å³èŠ‚ç‚¹ã€‚è¿™ä¸ªæ ‘çš„æ“ä½œä¸€èˆ¬æ˜¯ in-placeï¼Œæ‰€ä»¥åœ¨æŸä¸ªé€’å½’è¿‡ç¨‹ä¸­ return æ˜¯ä¸å¿…return valueï¼Œæœ¬ç”Ÿå°±æ˜¯åœ¨ä¿®æ”¹ã€‚ 123456789101112131415161718192021222324252627282930"""# Definition for a Node.class Node(object): def __init__(self, val, left, right, next): self.val = val self.left = left self.right = right self.next = next"""class Solution(object): # perfect binary tree, # é¢˜ç›®çš„è¦æ±‚ï¼Œ populate each next pointer to its next right node def helper(self, left, right): if not left or not right: return left.next = right # ä¸‰ç§å…³ç³»ï¼Œå…ˆåŽé¡ºåºæ˜¯æ²¡æœ‰å…³ç³»çš„ self.helper(left.left, left.right) self.helper(left.right, right.left) self.helper(right.left, right.right) def connect(self, root): if not root: return self.helper(root.left, root.right) return root Populating Next Right Pointers in Each Node II Given a binary tree struct Node { int val; Node left; Node right; Node *next; }Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Tipsï¼šæ³¨æ„ä»Žå›¾ç‰‡ä¸Šè§‚å¯Ÿè¿™ä¸€é¢˜å’Œä¸Šä¸€é¢˜çš„åŒºåˆ«ï¼Œè¿™å›¾ä¸­è¡¨æ°‘ä¸€ä¸ªå­æ ‘çš„å·¦å­æ ‘æ˜¯å¯ä»¥æŒ‡å‘å¦ä¸€ä¸ªå­æ ‘çš„å³å­æ ‘ï¼Œè¯´æ˜Žè¿™ä¸ªæ˜Žæ˜¾ç±»ä¼¼å±‚æ¬¡éåŽ†ï¼Œè€Œä¸åƒä¸Šä¸€é¢˜é‚£æ ·ã€‚ 123456789101112131415161718192021222324252627282930313233"""# Definition for a Node.class Node(object): def __init__(self, val, left, right, next): self.val = val self.left = left self.right = right self.next = next"""class Solution(object): # è¿™ä¸ªæ˜¯ä¸å¤ªæ˜Žç™½çš„ # è¿™ä¸ªç›¸å¯¹äºŽä¸Šä¸€é“é¢˜ç›®ï¼Œåªæ˜¯å°‘äº† perfect binary tree, ç¿»è¯‘æˆä¸­æ–‡ï¼Œæ»¡äºŒå‰æ ‘ï¼ˆå®Œç¾ŽäºŒå‰æ ‘ï¼‰ï¼ŒåŒ…æ‹¬æœ€åŽä¸€å±‚éƒ½æ˜¯æ»¡çš„ def connect(self, root): if root is None: return None queue = [root] while queue: prev,curr = None,None size = len(queue) # æœ‰ç‚¹ç±»ä¼¼å±‚æ¬¡éåŽ†çš„æ„æ€ for i in range(size): curr = queue.pop(0) # è¿™ä¸ª if åªæœ‰åœ¨for ä¹‹å†…æ‰æ˜¯æœ‰æ•ˆçš„ï¼Œç¬¬ä¸€æ¬¡æ˜¯æ— æ•ˆçš„ if prev : prev.next = curr if curr.left: queue.append(curr.left) if curr.right: queue.append(curr.right) prev = curr curr.next = None return root Binary Tree Maximum Path Sum Given a non-empty binary tree, find the maximum path sum.For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Input: [-10,9,20,null,null,15,7] -10 / \ 9 20 / \ 15 7Output: 42 Tipsï¼š è¿™ä¸ªçš„éš¾ç‚¹åœ¨äºŽï¼Œå¯ä»¥ä»Žä»»æ„ç‚¹å¼€å§‹ï¼Œç„¶åŽå†ä»»æ„ç‚¹ç»“æŸï¼Œå¹¶ä¸”è¿‡ä¸è¿‡æ ¹èŠ‚ç‚¹éƒ½æ˜¯å¯ä»¥çš„ã€‚ åˆ†åˆ¶åˆ°åº•éƒ¨ï¼Œåœ¨è¿”å›žçš„æ—¶å€™ä¼ å…¥å·¦å³ä»»æ„ä¸€éæœ€å¤§å€¼åŠ ä¸Šç›®å‰root.val:cur = max(left, right) + root.val è¿™ç§æƒ…å†µå¤„ç†äº†ä»ŽRootåˆ°å·¦å³ä»»æ„ä¸€è¾¹çš„æœ€å¤§å€¼ï¼Œä¹Ÿå°±æ˜¯ root.val + left å’Œ root.val + rightï¼› è¿˜æœ‰ä¸€ç§æƒ…å†µå°±æ˜¯å½“æœ€å¤§å€¼ = root.val + left + rightï¼Œ æˆ‘ä»¬åœ¨æ”¾å…¥globalå˜é‡çš„æ—¶å€™ä½•å…¶æ¯”è¾ƒã€‚ å¯¹äºŽæœ€åº•éƒ¨å¶å­èŠ‚ç‚¹ä¼ ä¸Šæ¥çš„å€¼ï¼Œæˆ‘ä»¬å°†å…¶è®¾ç½®æˆ0: return cur if cur &gt; 0 else 0 12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): # æ ¹æ®ä»¥å¾€çš„ç»éªŒï¼Œæ ‘çš„é€’å½’è§£æ³•ä¸€èˆ¬éƒ½æ˜¯é€’å½’åˆ°å¶èŠ‚ç‚¹ï¼Œç„¶åŽå¼€å§‹è¾¹å¤„ç†è¾¹å›žæº¯åˆ°æ ¹èŠ‚ç‚¹ã€‚ # ä½†æ˜¯è¿™ä¸ªé¢˜ç›®ä¸æ˜¯ï¼Œ è¿™ä¸ªæ˜¯å¯ä»¥ä»»æ„ startï¼Œ ä»»æ„ endï¼Œç„¶åŽä¸ä¸€å®šè¦ç»è¿‡æ ¹èŠ‚ç‚¹ def maxPathSum(self, root): """ :type root: TreeNode :rtype: int """ # ä½¿ç”¨ self æ ‡å¿— å°±æ„å‘³è¿™ä¸ªæ˜¯ä¸€ç§å…¨å±€çš„å˜é‡ï¼Œ ç±»ä¼¼åœ¨ init ä¸­è¿›è¡Œåˆå§‹åŒ–çš„ self.res = - float('inf') self.dfs(root) return self.res def dfs(self, root): if not root: return 0 left = self.dfs(root.left) right = self.dfs(root.right) self.res = max(self.res, left + right + root.val) cur = max(left, right) + root.val return cur if cur &gt; 0 else 0 Sum Root to Leaf Numbers Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123.Find the total sum of all root-to-leaf numbers.Note: A leaf is a node with no children. Input: [1,2,3] 1 / \ 2 3Output: 25Explanation:The root-to-leaf path 1-&gt;2 represents the number 12.The root-to-leaf path 1-&gt;3 represents the number 13.Therefore, sum = 12 + 13 = 25. Tips: è·¯å¾„ç»„æˆçš„æ•°å­—ä»£è¡¨ä¸€ä¸ªæ•°å­—ï¼Œç„¶åŽæ‰€æœ‰çš„è·¯å¾„å’Œç›¸åŠ èµ·æ¥ã€‚å…³é”®ä»£ç åªè¦ cur =pre*10 + root.valï¼Œ è¿˜æ˜¯æ ‘çš„è·¯å¾„çš„éåŽ†å§ã€‚ 123456789101112131415161718192021222324252627282930313233343536# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): # å¯¹äºŽæ ‘çš„ ç±»åž‹ï¼Œå¤§æ¦‚å°±æ˜¯è¿™æ ·äº†ï¼Œ é€’å½’ï¼Œæ‰¾å‡ºé€’å½’çš„è·³å‡ºçš„æ¡ä»¶ï¼Œç„¶åŽå¤„ç†ä¿å­˜ç»“æžœ def sumNumbers(self, root): """ :type root: TreeNode :rtype: int """ self.result =0 self.sumNum(root, 0) return self.result def sumNum(self, root, pre): if not root: return cur = pre *10 +root.val if not root.left and not root.right: self.result += cur return if root.left: self.sumNum(root.left, cur) if root.right: self.sumNum(root.right, cur) Binary Tree Preorder Traversal Given a binary tree, return the preorder traversal of its nodesâ€™ values. Tipsï¼šéžé€’å½’ç‰ˆæœ¬ï¼ˆè¿­ä»£ï¼‰ï¼Œä½¿ç”¨æ ˆï¼ˆé€’å½’çš„æ€æƒ³å°±æ˜¯æ ˆçš„æ€æƒ³ï¼‰ã€‚ 1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): # Recursive solution is trivial, could you do it iteratively? def preorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res, queue =[], [root] while queue: cur =queue.pop() if cur: res.append(cur.val) queue.append(cur.right) queue.append(cur.left) #queue.append(cur.right) return res LRU Cache Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.The cache is initialized with a positive capacity. Tipsï¼šè¿™ä¸ªé¢˜ç›®çº¯ç²¹æ‰‹è§£ï¼Œå¤ªéº»çƒ¦äº†ï¼Œåœ¨python3 ä¸­æœ‰ collections.OrderedDict() çš„å®žçŽ°ï¼Œè¿™æ˜¯ä½œå¼Šçš„å†™æ³•ã€‚ç‰¹ç‚¹åœ¨äºŽdict +é˜Ÿåˆ—ï¼ˆä¸å®Œå…¨æ˜¯é˜Ÿåˆ—ï¼Œå› ä¸ºè®¿é—®ä¹‹åŽè¿˜ä¼šæ”¾åˆ°é˜Ÿåˆ—çš„æœ€åŽï¼Œè€Œä¸æ˜¯å¼¹å‡ºï¼‰ã€‚å› ä¸ºä¸€èˆ¬çš„dict å­˜å‚¨çš„æ—¶å€™æ˜¯æ— åºï¼ˆä¸æ˜¯æŒ‰ç…§æ”¾å…¥çš„å…ˆåŽä¹¦åºï¼‰ï¼Œordereddict æ˜¯æŒ‰ç…§æ”¾å…¥çš„å…ˆåŽé¡ºåºè¿›è¡Œå­˜å‚¨çš„ã€‚é¢˜ç›®æœ¬èº«å°±æ˜¯å…ˆè¿›å…ˆå‡ºçš„é˜Ÿåˆ—ï¼Œåªä¸è¿‡å­˜å‚¨çš„æ˜¯ (key, value) è¿™æ ·çš„é”®å€¼å¯¹ã€‚ä½¿ç”¨get çš„æ—¶å€™ï¼Œgetåˆ°ä¸€ä¸ªä¸èƒ½åˆ é™¤ï¼Œåº”è¯¥æ”¾åˆ°æœ€åŽï¼›putçš„æ—¶å€™åœ¨ OrderedDict.popitem()æœ‰ä¸€ä¸ªå¯é€‰å‚æ•°lastï¼ˆé»˜è®¤ä¸ºTrueï¼‰ï¼Œå½“lastä¸ºTrueæ—¶å®ƒä»ŽOrderedDictä¸­åˆ é™¤æœ€åŽä¸€ä¸ªé”®å€¼å¯¹å¹¶è¿”å›žè¯¥é”®å€¼å¯¹ï¼Œå½“lastä¸ºFalseæ—¶å®ƒä»Ž OrderedDictä¸­åˆ é™¤ç¬¬ä¸€ä¸ªé”®å€¼å¯¹å¹¶è¿”å›žè¯¥é”®å€¼å¯¹ã€‚ 123456789101112131415161718192021222324252627282930class LRUCache(object): # python3 environment def __init__(self, capacity): self.size =capacity self.cache = collections.OrderedDict() def get(self, key): if key not in self.cache: return -1 val =self.cache[key] self.cache.move_to_end(key) # Python &gt;= 3.2 return val def put(self, key, val): if key in self.cache: del self.cache[key] self.cache[key] =val if len(self.cache) &gt; self.size: self.cache.popitem(last= False) # Your LRUCache object will be instantiated and called as such:# obj = LRUCache(capacity)# param_1 = obj.get(key)# obj.put(key,value) Insertion Sort List Sort a linked list using insertion sort. Tipsï¼š linkedlist æ“…é•¿äºŽä¿®æ”¹å…ƒç´ ï¼ˆç›´æŽ¥ä¿®æ”¹æŒ‡å‘ï¼‰ï¼Œå…¶ä¸­çš„ if while æ˜¯ç»å¸¸æ­é…ä½¿ç”¨ï¼Œå‘çŽ°.. ç„¶åŽå°±å¤„ç†â€¦ 1234567891011121314151617181920212223242526272829303132# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): # å‰æ’ def insertionSortList(self, head): """ :type head: ListNode :rtype: ListNode """ p =dummy =ListNode(0) cur =dummy.next =head while cur and cur.next: next_val =cur.next.val if cur.val &lt;= next_val: cur =cur.next continue # the sequence is not sorted inorder # find the proper situation # ä»Žå¤´å¼€å§‹æ‰¾ if p.next.val &gt; next_val: p =dummy while p.next.val &lt;= next_val: p =p.next p.next, cur.next.next, cur.next =cur.next, p.next, cur.next.next return dummy.next Sort List Sort a linked list in O(n log n) time using constant space complexity. Input: 4-&gt;2-&gt;1-&gt;3 Output: 1-&gt;2-&gt;3-&gt;4 Tips: mergesort çš„æ€æƒ³ï¼Œæ˜¾ç¤ºæŠŠlist åˆ†æˆleft and rightï¼ˆåˆ†ï¼‰ï¼Œç„¶åŽæœ€åŽmerge ç®—æ³• 1234567891011121314151617181920212223242526272829303132333435# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def merge(self, h1,h2): dummy =tail =ListNode(-1) while h1 and h2: if h1.val &lt; h2.val: tail.next, h1 =h1, h1.next else: tail.next, h2 =h2, h2.next tail =tail.next tail.next =h1 or h2 return dummy.next def sortList(self, head): if not head or not head.next: return head pre, slow, fast =None, head, head # slow fast ç›´æŽ¥æ˜¯ä¸¤ç§å¿«æ…¢çš„ä¸å½±å“çš„index éåŽ†æ–¹å¼ï¼Œslow æ˜¯ä¸‹ä¸€ä¸ªé“¾è¡¨çš„ç»“ç‚¹ while fast and fast.next: pre, slow, fast =slow, slow.next, fast.next.next pre.next =None # ä¸‹é¢çš„ä¸¤ç§å†™æ³•æ˜¯ç­‰ä»·çš„ return self.merge(self.sortList(head), self.sortList(slow)) # return self.merge(*map(self.sortList, (head, slow))) Number of Islands Given a 2d grid map of â€˜1â€™s (land) and â€˜0â€™s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Tips: è¿™ä¸ªdfs è·Ÿä¹‹å‰çš„ä¸ä¸€æ ·ä¹‹å¤„åœ¨äºŽï¼Œéœ€è¦å¯¹äºŽæ¯ä¸ªç‚¹è¿›è¡Œ dfs() ï¼Œå…¶ä»–çš„è¿˜å¥½ã€‚æä¾›äº†ä¸¤ç§è§£æ³•ï¼Œç¬¬ä¸€ç§æ¯”è¾ƒä»£ç æ¯”è¾ƒå°‘ã€‚æ¯”è¾ƒå–œæ¬¢ç¬¬ä¸€ç§ä»£ç çš„é£Žæ ¼ï¼Œè¿™æ ·ä¸¤ä¸ªå‡½æ•°çœ‹èµ·æ¥æ¯”è¾ƒå‡è¡¡ã€‚ https://leetcode.com/problems/number-of-islands/ è§£æ³•ä¸€ï¼š1234567891011121314151617181920212223242526272829class Solution(object): def numIslands(self, grid): """ :type grid: List[List[str]] :rtype: int """ if not grid: return 0 count =0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] =='1': self.dfs(grid, i,j) # å†™æ³•æ¯”è¾ƒå·§å¦™ count +=1 return count def dfs(self, grid, i,j): if i &lt;0 or j&lt;0 or i&gt;=len(grid) or j&gt;= len(grid[0]) or grid[i][j] !='1': return grid[i][j] ='0' self.dfs(grid, i+1, j) self.dfs(grid, i-1, j) self.dfs(grid, i, j+1) self.dfs(grid, i, j-1) è§£æ³•äºŒï¼šä¸¤ç§æ€æƒ³ä¸€æ ·ï¼Œå†™æ³•ä¸ä¸€æ ·ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940class Solution(object): def numIslands(self, grid): """ :type grid: List[List[str]] :rtype: int """ if not grid: return 0 used =[ [False]* len(grid[0]) for _ in range(len(grid))] count =0 for i in range(len(grid)): for j in range(len(grid[0])): num =self.dfs(grid, used, len(grid)-1, len(grid[0])-1, i, j) if num&gt;0: count +=1 return count def dfs(self, grid, used, row, col, x, y): if grid[x][y] =='0' or used[x][y]: return 0 used[x][y] =True num =1 if x!=0: num += self.dfs(grid, used, row, col, x -1, y) if x !=row: num += self.dfs(grid, used, row, col, x +1,y) if y!=0: num += self.dfs(grid, used, row, col, x, y-1) if y !=col: num += self.dfs(grid, used, row, col, x, y+1) return num Super Egg Drop You are given K eggs, and you have access to a building with N floors from 1 to N.Each egg is identical in function, and if an egg breaks, you cannot drop it again.You know that there exists a floor F with 0 &lt;= F &lt;= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break. 1234567891011121314151617181920212223class Solution(object): def gameOfLife(self, board): # çº¯ç²¹çš„countï¼Œä¹‹åŽçš„åˆ¤æ–­æ˜¯ä¸‹é¢å†³å®šçš„ def count(x, y): res =0 # éåŽ† ç‚¹çš„å››å‘¨ for r in range(x-1, x+2): for c in range(y-1, y+2): if (r!= x or c!=y) and 0&lt;= r &lt; len(board) and 0&lt;= c &lt; len(board[0]) and board[r][c] &gt;0: res +=1 return res for x in range(len(board)): for y in range(len(board[0])): board[x][y] =count(x, y) +1 if board[x][y] ==1 else -count(x, y) # if board[x][y] == 1, change its value to count(x,y) + 1, the reason I add 1 is to keep it positive for x in range(len(board)): for y in range(len(board[0])): board[x][y] = 1 if board[x][y] in &#123;3, 4, -3&#125; else 0 # &#123;2, 3, -3&#125; Kth Smallest Element in a BST Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Tips: äºŒåˆ†æŸ¥æ‰¾æ ‘ï¼Œä¸­åºéåŽ†å°±æ˜¯ä¸å‡çš„list .æœ‰é€’å½’ï¼Œè¿­ä»£ä¸¤ä¸ªç‰ˆæœ¬ï¼Œå…±ä¸‰ç§å®žçŽ°ã€‚å€¾å‘äºŽä½¿ç”¨ç¬¬äºŒä¸ªç‰ˆæœ¬ã€‚è¿­ä»£ï¼Œç„¶åŽä½¿ç”¨k è¿›è¡ŒåŠæ—¶çš„è·³å‡ºã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# Definition for a binary tree node.class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution(object): # BST ä¸­åºéåŽ† å¾—åˆ°ä¸€ä¸ªä¸å‡çš„listï¼Œç„¶åŽå°±å¯å¾—ç¬¬k å°çš„å…ƒç´  # ä¸‹é¢æ˜¯é€’å½’ç‰ˆæœ¬ ''' def kthSmallest(self, root, k): """ :type root: TreeNode :type k: int :rtype: int """ if not root: return res =[] self.dfs(root, res) if len(res) +1&lt;k: return return res[k-1] def dfs(self, root, res): if not root: return #res.append(root.val) self.dfs(root.left, res) res.append(root.val) self.dfs(root.right, res) ''' ''' # ç›¸æ¯”äºŽç¬¬ä¸€ç§æ–¹å¼ï¼Œæ—¶é—´ä¸Šæ˜¯æœ‰å‡å°‘çš„ def kthSmallest(self, root,k ): stack =[] node =root while True: if node: stack.append(node) node =node.left else: node =stack.pop() # ä½¿ç”¨è®¡æ•°çš„æ–¹å¼è¿›è¡Œè®¿é—®ï¼Œå‡å°‘äº†ç©ºé—´å¤æ‚åº¦ k -=1 if not k: break node =node.right return node.val ''' # è¿™ä¸ªä»£ç å°±æ˜¯æœ‰ç‚¹ æŠ–æœºçµçš„é‚£ç§ï¼Œå¦‚æžœä½¿ç”¨äº† try ..catch.. é‚£ä¹ˆexception å°±ä¸ä¼šæŠ¥é”™ def kthSmallest(self, root, k): def inorder(root, k): if root: inorder(root.left, k) if k ==1: raise Exception(root.val) inorder(root.right, k-1) #return k try: inorder(root, k) except Exception as e: return e.message Lowest Common Ancestor of a Binary Tree Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.According to the definition of LCA on Wikipedia: â€œThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).â€ Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4] Tips: è¿™é“Follow Upæ²¡æœ‰BSTçš„ç‰¹æ€§ï¼Œæ‰€ä»¥è¦å¯¹å‡ ç§caseä¸€ä¸ªä¸€ä¸ªè¿›è¡Œæµ‹è¯•ã€‚Conditionä¸ºä¸¤ç§ï¼šå¦‚æžœæ²¡æ‰¾åˆ°ï¼Œè¿”å›žNoneï¼Œæ‰¾åˆ°åˆ™è¿”å›žå½“å‰çš„root(å› ä¸ºæ‰¾åˆ°ä¸€ä¸ªrootå°±ä¸éœ€è¦ç»§ç»­æ·±å…¥)æ¯”å¯¹æ–¹å¼ï¼š å¦‚æžœparentçš„å·¦å³å­©å­éƒ½æœ‰è¿”å›žï¼Œè¯´æ˜Žparentå°±æ˜¯LCA å¦‚æžœå·¦è¾¹æ²¡æœ‰è¿”å›žï¼šåˆ™å³è¾¹è¿”å›žçš„å°±æ˜¯LCA å¦‚æžœå³è¾¹æ²¡æœ‰è¿”å›žï¼šåˆ™å·¦è¾¹è¿”å›žçš„å°±æ˜¯LCA è®²è§£ https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/ 1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def lowestCommonAncestor(self, root, p, q): """ :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode """ if not root: return None if p ==root or q ==root: return root left =self.lowestCommonAncestor(root.left, p, q) right =self.lowestCommonAncestor(root.right, p, q) if left and right: return root if not left: return right if not right: return left Serialize and Deserialize Binary Tree Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Tips: åºåˆ—åŒ–ä¸»è¦æ˜¯ç”¨åœ¨ å­˜å‚¨å’Œä¼ è¾“ä¸Šå§. åŸºäºŽ é˜Ÿåˆ—è¿›è¡Œå®žçŽ°ã€‚é˜Ÿåˆ—å¯ä»¥ä¸¤è¾¹è¿›è¡Œä¿®æ”¹ã€‚å…ˆåºéåŽ† https://leetcode.com/problems/serialize-and-deserialize-binary-tree/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Codec: # å…ˆåºéåŽ† def serialize(self, root): if not root: return "" queue =collections.deque([root]) res =[] # è¿™ä¸ªå°±æ˜¯ä¸€ç§å¾ªçŽ¯å…ˆåºéåŽ†äºŒå‰æ ‘ while queue: # ä½¿ç”¨ pop å’Œ append() æ“ä½œå³è¾¹ node =queue.popleft() # åœ¨é˜Ÿåˆ—ä¸­ä½¿ç”¨ popleft å’Œappendleft() ç›´æŽ¥æ“ä½œé˜Ÿåˆ—çš„å·¦è¾¹çš„å¢žå‡ if node: queue.append(node.left) queue.append(node.right) res.append(str(node.val) if node else '#') # ä½¿ç”¨ # è¡¨ç¤ºæ˜¯ä¸€ç§none return ','.join(res) # ä½¿ç”¨, éš”å¼€æ¯ä¸ªnode def deserialize(self, data): if not data: return None nodes =data.split(',') root =TreeNode(int(nodes[0])) queue =collections.deque([root]) index =1 # ä½œä¸ºstring çš„index while queue: node =queue.popleft() if nodes[index] != "#": # nodes[index] is not '#' è¿™æ ·å†™ä¹Ÿæ˜¯å¯ä»¥çš„ node.left =TreeNode(int(nodes[index])) queue.append(node.left) index +=1 if nodes[index] != "#": node.right =TreeNode(int(nodes[index])) queue.append(node.right) index +=1 return root # Your Codec object will be instantiated and called as such:# codec = Codec()# codec.deserialize(codec.serialize(root)) Binary Tree Maximum Path Sum Given a non-empty binary tree, find the maximum path sum.For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Tips: è¿™ä¸ªä¸æ˜¯æ ‘çš„è·¯å¾„ï¼Œå¯ä»¥ä»Žä»»æ„éžæ ¹èŠ‚ç‚¹å‡ºå‘ã€‚ 1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): # æ ¹æ®ä»¥å¾€çš„ç»éªŒï¼Œæ ‘çš„é€’å½’è§£æ³•ä¸€èˆ¬éƒ½æ˜¯é€’å½’åˆ°å¶èŠ‚ç‚¹ï¼Œç„¶åŽå¼€å§‹è¾¹å¤„ç†è¾¹å›žæº¯åˆ°æ ¹èŠ‚ç‚¹ã€‚ # ä½†æ˜¯è¿™ä¸ªé¢˜ç›®ä¸æ˜¯ï¼Œ è¿™ä¸ªæ˜¯å¯ä»¥ä»»æ„ startï¼Œ ä»»æ„ endï¼Œç„¶åŽä¸ä¸€å®šè¦ç»è¿‡æ ¹èŠ‚ç‚¹ def maxPathSum(self, root): """ :type root: TreeNode :rtype: int """ # è¿™ç§å…¨å±€å˜é‡çš„è®¾ç½®ç¡®å®žæ˜¯å¿…é¡»çš„ï¼Œå½“æºå¸¦å˜é‡çš„æ—¶å€™å°±å‡ºé”™äº† self.res = - float('inf') self.dfs(root) return self.res def dfs(self, root): if not root: return 0 left = self.dfs(root.left) right = self.dfs(root.right) self.res = max(self.res, left + right + root.val) cur = max(left, right) + root.val return cur if cur &gt; 0 else 0 Number of Islands Given a 2d grid map of â€˜1â€™s (land) and â€˜0â€™s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Tips: dfs 12345678910111213141516171819202122232425262728293031class Solution(object): # dfs æ˜¯ä¸€ä¸ªä¸­è§„ä¸­çŸ©çš„ç®—æ³• # è¿™ç§æ–¹å¼æ›´åŠ ç®€æ´ä¸€ç‚¹ï¼Œç›´æŽ¥ä½¿ç”¨ grid[i][j] æ˜¯å¦ç­‰äºŽ1 è¿›è¡Œæ“ä½œï¼Œ # ç„¶åŽå¦‚æžœèƒ½è¿”å›žï¼Œåœ¨ä¸»ç¨‹åºä¸­è¿›è¡Œè®¡æ•°ï¼Œæœ€åŽçš„ç»“æžœæ¯”è¾ƒnice def numIslands(self, grid): """ :type grid: List[List[str]] :rtype: int """ if not grid: return 0 count =0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] =='1': self.dfs(grid, i,j) count +=1 return count def dfs(self, grid, i, j): if i&lt;0 or j&lt;0 or i&gt;=len(grid) or j &gt;=len(grid[0]) or grid[i][j]!='1': return grid[i][j] ='#' self.dfs(grid, i+1, j) self.dfs(grid, i-1, j) self.dfs(grid, i,j +1) self.dfs(grid, i, j-1) Course Schedule There are a total of n courses you have to take, labeled from 0 to n-1.Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Tips: dfs å…ˆä¿®è¯¾ç¨‹ 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution(object): """ è¿™ç§è§£é‡Šæ˜¯æ¯”è¾ƒniceçš„ï¼Œä½¿ç”¨ 0 -1 å’Œ1 åˆ†åˆ«è¡¨ç¤ºåˆå§‹åŒ–ï¼Œæ­£åœ¨è®¿é—®å’Œå·²ç»å®Œæˆ if node v has not been visited, then mark it as 0. if node v is being visited, then mark it as -1. If we find a vertex marked as -1 in DFS, then their is a ring. if node v has been visited, then mark it as 1. If a vertex was marked as 1, then no ring contains v or its successors. """ def canFinish(self, numCourses, prerequisites): """ :type numCourses: int :type prerequisites: List[List[int]] :rtype: bool """ graph = [[] for _ in range(numCourses)] visited = [0 for _ in range(numCourses)] # create graph for pair in prerequisites: x, y = pair graph[x].append(y) # visit each node for i in range(numCourses): if not self.dfs(graph, visited, i): return False return True def dfs(self, graph, visited, i): # if ith node is marked as being visited, then a cycle is found if visited[i] == -1: return False # if it is done visted, then do not visit again if visited[i] == 1: return True # mark as being visited visited[i] = -1 # visit all the neighbours for j in graph[i]: if not self.dfs(graph, visited, j): return False # after visit all the neighbours, mark it as done visited visited[i] = 1 return True Course Schedule II There are a total of n courses you have to take, labeled from 0 to n-1.Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. Tips: å’Œä¸Šä¸€é¢˜ç›¸ä¼¼ï¼Œdfs æ±‚è§£çš„æ˜¯è·¯å¾„é—®é¢˜ï¼Œè€Œä¸æ˜¯æœ€å€¼ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): # ä¸Šä¸€é¢˜æ˜¯true or false è¿™ä¸ªé¢˜ç›®è¦æ±‚ç»™ä¸ªèƒ½å¤Ÿå®Œæˆçš„è·¯å¾„ï¼Œå“Ž # ä¸å¾—ä¸è¯´è¿™ä¸ªæ˜¯å›¾çš„çŸ¥è¯†ç‚¹å‘€ def findOrder(self, numCourses, prerequisites): """ :type numCourses: int :type prerequisites: List[List[int]] :rtype: List[int] """ def dfs(i, visited, graph, res): if visited[i] ==1: return True if visited[i] ==-1: return False visited[i] =-1 for n in graph[i]: if not dfs(n, visited, graph, res): return False res.append(i) visited[i] =1 return True visited =[0] * numCourses graph =&#123;x :[] for x in range(numCourses)&#125; # æ³¨æ„è¿™ä¸ªé¡ºåºï¼Œå› ä¸ºæœ€åŽè¦çš„æ˜¯è·¯å¾„ï¼Œæ‰€ä»¥è¿™æ ·æ˜¯æ›´åŠ åˆç†çš„ for p in prerequisites: graph[p[1]].append(p[0]) res =[] for i in range(numCourses): if not dfs(i, visited, graph, res): return [] return res[::-1]]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++ ç¼–ç¨‹è¯­è¨€ï¼ˆ2ï¼‰]]></title>
    <url>%2F2019%2F05%2F06%2Fcpp2%2F</url>
    <content type="text"><![CDATA[C++ è¯­è¨€å­¦ä¹ ç¬”è®°2 å­—ç¬¦ä¸²æ‹¼æŽ¥é—®é¢˜ å¤§é‡æ‹¼æŽ¥å­—ç¬¦ä¸²çš„æ•ˆçŽ‡ä»Žé«˜åˆ°ä½Žä¾æ¬¡ä¸ºï¼š+=ã€append()ã€stringstreamã€sprintf()ã€‚ å¸¸ç”¨çš„æ–¹æ³• operator += æ“ä½œç¬¦ append() æ“ä½œç¬¦ reserve &amp;&amp; operator += stringstream çš„ç”¨æ³• é’ˆå¯¹è¾ƒçŸ­å­—ç¬¦ä¸²ï¼Œä½¿ç”¨reserveæå‰åˆ†é…ç©ºé—´å¯¹æ€§èƒ½æå‡æ„ä¹‰ä¸å¤§ï¼Œå½“å­—ç¬¦ä¸²çš„é•¿åº¦å¾ˆé•¿æ˜¯ï¼Œä½¿ç”¨reserveæ–¹æ³•æå‰åˆ†é…ç©ºé—´å¯ä»¥å¸¦æ¥æ¯”è¾ƒå¤§çš„æ€§èƒ½æå‡ã€‚operator+= å’Œ append æ–¹æ³•åœ¨è¿›è¡Œå­—ç¬¦ä¸²æ‹¼æŽ¥æ—¶æ€§èƒ½è¡¨çŽ°å‡ ä¹Žä¸€è‡´ã€‚åŽŸå› æ˜¯stl å®žçŽ°çš„operator+= æ–¹å¼å®žé™…æ˜¯ç›´æŽ¥è°ƒç”¨äº†append æ–¹æ³•ã€‚ç»¼ä¸Šï¼Œæ‹¼æŽ¥é•¿å­—ç¬¦ä¸²æ—¶æœ€ä¼˜æ–¹å¼æ˜¯ reserve &amp;&amp; appendã€‚ vector ä¸­ä¸¤ä¸ªå’Œå†…å­˜ç›¸å…³çš„ä¸¤ä¸ªå‡½æ•°ï¼š resize()å‡½æ•°å’Œå®¹å™¨çš„sizeæ¯æ¯ç›¸å…³ã€‚è°ƒç”¨resize(n)åŽï¼Œå®¹å™¨çš„sizeå³ä¸ºnã€‚reserve()å‡½æ•°å’Œå®¹å™¨çš„capacityæ¯æ¯ç›¸å…³ã€‚reserve(n)é¢„åˆ†é…nä¸ªå…ƒç´ çš„å­˜å‚¨ç©ºé—´ã€‚ä»Žä¸¤ä¸ªå‡½æ•°çš„ç”¨é€”å¯ä»¥å‘çŽ°ï¼Œå®¹å™¨è°ƒç”¨resize()å‡½æ•°åŽï¼Œæ‰€æœ‰çš„ç©ºé—´éƒ½å·²ç»åˆå§‹åŒ–äº†ï¼Œæ‰€ä»¥å¯ä»¥ç›´æŽ¥è®¿é—®ã€‚è€Œreserve()å‡½æ•°é¢„åˆ†é…å‡ºçš„ç©ºé—´æ²¡æœ‰è¢«åˆå§‹åŒ–ï¼Œæ‰€ä»¥ä¸å¯è®¿é—®ã€‚ 123456789101112vector&lt;int&gt; a;a.reserve(100);a.resize(50);cout&lt;&lt;a.size()&lt;&lt;" "&lt;&lt;a.capacity()&lt;&lt;endl;a.resize(150);cout&lt;&lt;a.size()&lt;&lt;" "&lt;&lt;a.capacity()&lt;&lt;endl;a.reserve(50);cout&lt;&lt;a.size()&lt;&lt;" "&lt;&lt;a.capacity()&lt;&lt;endl;a.resize(50);cout&lt;&lt;a.size()&lt;&lt;" "&lt;&lt;a.capacity()&lt;&lt;endl;a.resize(210);cout&lt;&lt;a.size()&lt;&lt;" "&lt;&lt;a.capacity()&lt;&lt;endl; stringä¸­æœ‰ä¸¤ä¸ªå‡½æ•°ï¼šreserve()å’Œresize()ï¼Œå’Œvector ä¸­ä¸¤ä¸ªå‡½æ•°ä¹Ÿæ˜¯ç±»ä¼¼çš„ã€‚è‡ªåŠ¨å¢žé•¿â€çš„è¿‡ç¨‹å¾ˆè€—æ—¶ï¼Œå¹¶ä¸”ä¼šå¯¼è‡´æ‰€æœ‰çš„æŒ‡é’ˆã€è¿­ä»£å™¨å’Œå¼•ç”¨å¤±æ•ˆã€‚æ‰€ä»¥é¿å…é¢‘ç¹çš„å†…å­˜é‡æ–°åˆ†é…å°±æ˜¾å¾—å¾ˆé‡è¦ã€‚]]></content>
      <categories>
        <category>CSåŸºç¡€</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[æ–°è¯å‘çŽ°å’Œé©¬å°”ç§‘å¤«æ¨¡åž‹]]></title>
    <url>%2F2019%2F05%2F06%2Fhmm%2F</url>
    <content type="text"><![CDATA[ä»‹ç»éšé©¬å°”ç§‘å¤«æ¨¡åž‹ï¼ˆHMMï¼‰ å’Œæ–°è¯å‘çŽ°ã€‚ HMMç½‘ç»œæ–°è¯å……åˆ†åº”ç”¨äº†è‹±è¯­ã€æ±‰è¯­ã€æ•°å­—å’Œç¬¦å·ç­‰ç›¸äº’ç»“åˆçš„æ–¹å¼ï¼Œç»“æž„æ–°é¢–è‡ªç”±ã€‚ åŸºäºŽè§„åˆ™ åŸºäºŽè§„åˆ™çš„æ–¹æ³•æ˜¯ä»Žè¯­è¨€å­¦çš„è§’åº¦å¯¹æ–°è¯çš„æž„è¯è§„åˆ™è¿›è¡Œå½’çº³æ€»ç»“å¹¶å»ºç«‹æ­£åˆ™è¡¨è¾¾å¼è§„åˆ™åº“ã€‚è¯¥æ–¹æ³•å¯¹äºŽé«˜é¢‘æ–°è¯æœ‰å¾ˆå¥½çš„è¯†åˆ«æ•ˆæžœï¼Œå¯¹ç‰¹å®šçš„é¢†åŸŸæœ‰å¾ˆå¥½çš„å‡†ç¡®çŽ‡ï¼Œä½†æ˜¯äººå·¥åˆ¶å®šè§„åˆ™éœ€è¦å¤§é‡äººåŠ›æˆæœ¬ï¼Œå­˜åœ¨è§„åˆ™é¢†åŸŸé€‚åº”èƒ½åŠ›ä¸‹é™ç­‰é—®é¢˜ã€‚ æ¯”å¦‚åœ¨å¾®åšä¸­çš„æ–°è¯å‘çŽ°çš„ä¸€ç§è§„åˆ™ï¼š å¯ä»¥æå–ç›¸åº”çš„è§„åˆ™ï¼š æ¥æº åŸºäºŽä¿¡æ¯ç†µ ä½¿ç”¨è¯é¢‘,å†…éƒ¨å‡å›ºç¨‹åº¦,è‡ªç”±ç¨‹åº¦ä¸‰ä¸ªè€ƒå¯Ÿçº¬åº¦è¿›è¡Œæ–°è¯ç­›é€‰. è¯é¢‘å¾ˆå¥½ç†è§£ï¼Œè¯çš„å‡ºçŽ°é¢‘çŽ‡ä¸€èˆ¬æ¯”è¾ƒé«˜ï¼Œéœ€è¦è®¾ç½®ä¸€ä¸ªé˜ˆå€¼ï¼Œå¦‚æžœé«˜äºŽè¿™ä¸ªé˜ˆå€¼é‚£ä¹ˆå°±åˆ¤å®šä¸ºä¸€ä¸ªæ–°è¯ã€‚ å†…éƒ¨å‡å›ºåº¦ï¼ˆäº’ä¿¡æ¯ï¼‰ç”¨æ¥è¡¡é‡å€™é€‰å­ä¸²ä¹‹é—´çš„ç»“åˆç¨‹åº¦ã€‚ä¸»è¦æ˜¯ç”¨æ¥æé«˜å¯¹äºŽä½Žé¢‘æ–°è¯çš„è¯†åˆ«ç²¾åº¦ã€‚å½“ä½Žé¢‘æ–°è¯çš„å­ä¸²å‡ºçŽ°é¢‘çŽ‡ä¹Ÿè¾ƒä½Žï¼Œå­ä¸²ä¹‹é—´çš„é¢ç»“åˆç¨‹åº¦ç´§å¯†æ—¶ï¼Œå…¶äº’ä¿¡æ¯ä»ç„¶æ˜¯è¾ƒé«˜çš„ï¼Œä»Žè€Œè¾¾åˆ°ç²¾ç¡®è¯†åˆ«è¯¥ç±»æ–°è¯çš„æ•ˆæžœã€‚ è‡ªç”±ç¨‹åº¦åˆ©ç”¨ä¿¡æ¯ç†µæ¥è¡¡é‡å€™é€‰æ–°è¯çš„å·¦é‚»å­—ç¬¦å’Œå³ä¸´å­—ç¬¦çš„ä¸ç¡®å®šæ€§ï¼Œå€™é€‰æ–°è¯çš„é‚»æŽ¥ç†µè¶Šå¤§ï¼Œè¯´æ˜Žé‚»æŽ¥å­—ç¬¦çš„ä¸ç¡®å®šæ€§è¶Šå¤§ï¼Œæˆä¸ºæ–°è¯è¾¹ç•Œçš„å¯èƒ½æ€§å°±è¶Šå¤§ã€‚å¯ä»¥å¾ˆå¥½çš„è§£å†³æ–°è¯è¾¹ç•Œçš„é—®é¢˜ã€‚ åœ¨äººäººç½‘ç”¨æˆ·çŠ¶æ€ä¸­ï¼Œâ€œçš„ç”µå½±â€å‡ºçŽ°äº† 389 æ¬¡ï¼Œâ€œç”µå½±é™¢â€åªå‡ºçŽ°äº† 175 æ¬¡ï¼Œç„¶è€Œæˆ‘ä»¬å´æ›´å€¾å‘äºŽæŠŠâ€œç”µå½±é™¢â€å½“ä½œä¸€ä¸ªè¯ï¼Œå› ä¸ºç›´è§‰ä¸Šçœ‹ï¼Œâ€œç”µå½±â€å’Œâ€œé™¢â€å‡å›ºå¾—æ›´ç´§ä¸€äº›ã€‚ç»è¿‡è®¡ç®—â€œçš„ç”µå½±â€ å’Œâ€œç”µå½±é™¢â€çš„è”åˆæ¦‚çŽ‡ï¼Œè®¡ç®—ç»“æžœè¡¨æ˜Žï¼Œâ€œç”µå½±é™¢â€æ›´å¯èƒ½æ˜¯ä¸€ä¸ªæœ‰æ„ä¹‰çš„æ­é…ï¼Œè€Œâ€œçš„ç”µå½±â€åˆ™æ›´åƒæ˜¯â€œçš„â€å’Œâ€œç”µå½±â€è¿™ä¸¤ä¸ªæˆåˆ†å¶ç„¶æ‹¼åˆ°ä¸€èµ·çš„ã€‚å¯ä»¥æƒ³åˆ°ï¼Œå‡åˆç¨‹åº¦æœ€é«˜çš„æ–‡æœ¬ç‰‡æ®µå°±æ˜¯è¯¸å¦‚â€œè™è â€ã€â€œèœ˜è››â€ã€â€œå½·å¾¨â€ã€â€œå¿å¿‘â€ã€â€œçŽ«ç‘°â€ä¹‹ç±»çš„è¯äº†ï¼Œè¿™äº›è¯é‡Œçš„æ¯ä¸€ä¸ªå­—å‡ ä¹Žæ€»æ˜¯ä¼šå’Œå¦ä¸€ä¸ªå­—åŒæ—¶å‡ºçŽ°ï¼Œä»Žä¸åœ¨å…¶ä»–åœºåˆä¸­ä½¿ç”¨ã€‚ å…‰çœ‹æ–‡æœ¬ç‰‡æ®µå†…éƒ¨çš„å‡åˆç¨‹åº¦è¿˜ä¸å¤Ÿï¼Œæˆ‘ä»¬è¿˜éœ€è¦ä»Žæ•´ä½“æ¥çœ‹å®ƒåœ¨å¤–éƒ¨çš„è¡¨çŽ°ã€‚è€ƒè™‘â€œè¢«å­â€å’Œâ€œè¾ˆå­â€è¿™ä¸¤ä¸ªç‰‡æ®µã€‚å¦‚æžœä¸€ä¸ªæ–‡æœ¬ç‰‡æ®µèƒ½å¤Ÿç®—ä½œä¸€ä¸ªè¯çš„è¯ï¼Œå®ƒåº”è¯¥èƒ½å¤Ÿçµæ´»åœ°å‡ºçŽ°åœ¨å„ç§ä¸åŒçš„çŽ¯å¢ƒä¸­ï¼Œå…·æœ‰éžå¸¸ä¸°å¯Œçš„å·¦é‚»å­—é›†åˆå’Œå³é‚»å­—é›†åˆã€‚ åœ¨å®žé™…è¿ç”¨ä¸­ä½ ä¼šå‘çŽ°ï¼Œæ–‡æœ¬ç‰‡æ®µçš„å‡å›ºç¨‹åº¦å’Œè‡ªç”±ç¨‹åº¦ï¼Œä¸¤ç§åˆ¤æ–­æ ‡å‡†ç¼ºä¸€ä¸å¯ã€‚åªçœ‹å‡å›ºç¨‹åº¦çš„è¯ï¼Œç¨‹åºä¼šæ‰¾å‡ºâ€œå·§å…‹â€ã€â€œä¿„ç½—â€ã€â€œé¢œå…­è‰²â€ã€â€œæŸ´å¯å¤«â€ç­‰å®žé™…ä¸Šæ˜¯â€œåŠä¸ªè¯â€çš„ç‰‡æ®µï¼›åªçœ‹è‡ªç”±ç¨‹åº¦çš„è¯ï¼Œç¨‹åºåˆ™ä¼šæŠŠâ€œåƒäº†ä¸€é¡¿â€ã€â€œçœ‹äº†ä¸€éâ€ã€â€œç¡äº†ä¸€æ™šâ€ã€â€œåŽ»äº†ä¸€è¶Ÿâ€ä¸­çš„â€œäº†ä¸€â€æå–å‡ºæ¥ï¼Œå› ä¸ºå®ƒçš„å·¦å³é‚»å­—éƒ½å¤ªä¸°å¯Œäº†ã€‚ æˆ‘ä»¬æŠŠæ–‡æœ¬ä¸­å‡ºçŽ°è¿‡çš„æ‰€æœ‰é•¿åº¦ä¸è¶…è¿‡ d çš„å­ä¸²éƒ½å½“ä½œæ½œåœ¨çš„è¯ï¼ˆå³å€™é€‰è¯ï¼Œå…¶ä¸­ d ä¸ºè‡ªå·±è®¾å®šçš„å€™é€‰è¯é•¿åº¦ä¸Šé™ï¼Œæˆ‘è®¾å®šçš„å€¼ä¸º 5 ï¼‰ï¼Œå†ä¸ºå‡ºçŽ°é¢‘æ•°ã€å‡å›ºç¨‹åº¦å’Œè‡ªç”±ç¨‹åº¦å„è®¾å®šä¸€ä¸ªé˜ˆå€¼ï¼Œç„¶åŽåªéœ€è¦æå–å‡ºæ‰€æœ‰æ»¡è¶³é˜ˆå€¼è¦æ±‚çš„å€™é€‰è¯å³å¯ã€‚ä¸ºäº†æé«˜æ•ˆçŽ‡ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠè¯­æ–™å…¨æ–‡è§†ä½œä¸€æ•´ä¸ªå­—ç¬¦ä¸²ï¼Œå¹¶å¯¹è¯¥å­—ç¬¦ä¸²çš„æ‰€æœ‰åŽç¼€æŒ‰å­—å…¸åºæŽ’åºã€‚ä¸‹è¡¨å°±æ˜¯å¯¹â€œå››æ˜¯å››åæ˜¯ååå››æ˜¯åå››å››åæ˜¯å››åâ€çš„æ‰€æœ‰åŽç¼€è¿›è¡ŒæŽ’åºåŽçš„ç»“æžœã€‚å®žé™…ä¸Šæˆ‘ä»¬åªéœ€è¦åœ¨å†…å­˜ä¸­å­˜å‚¨è¿™äº›åŽç¼€çš„å‰ d + 1 ä¸ªå­—ï¼Œæˆ–è€…æ›´å¥½åœ°ï¼Œåªå‚¨å­˜å®ƒä»¬åœ¨è¯­æ–™ä¸­çš„èµ·å§‹ä½ç½®ã€‚ 12345678910111213141516 åååå››æ˜¯åå››å››åæ˜¯å››ååæ˜¯ååå››æ˜¯åå››å››åæ˜¯å››ååæ˜¯å››ååå››æ˜¯åå››å››åæ˜¯å››ååå››å››åæ˜¯å››åæ˜¯ååå››æ˜¯åå››å››åæ˜¯å››åæ˜¯åå››å››åæ˜¯å››åæ˜¯å››åæ˜¯å››åæ˜¯ååå››æ˜¯åå››å››åæ˜¯å››åå››åå››åæ˜¯ååå››æ˜¯åå››å››åæ˜¯å››åå››åæ˜¯å››åå››æ˜¯åå››å››åæ˜¯å››åå››æ˜¯å››åæ˜¯ååå››æ˜¯åå››å››åæ˜¯å››åå››å››åæ˜¯å››å è¿™æ ·çš„è¯ï¼Œç›¸åŒçš„å€™é€‰è¯ä¾¿éƒ½é›†ä¸­åœ¨äº†ä¸€èµ·ï¼Œä»Žå¤´åˆ°å°¾æ‰«æä¸€éä¾¿èƒ½ç®—å‡ºå„ä¸ªå€™é€‰è¯çš„é¢‘æ•°å’Œå³é‚»å­—ä¿¡æ¯ç†µã€‚å°†æ•´ä¸ªè¯­æ–™é€†åºåŽé‡æ–°æŽ’åˆ—æ‰€æœ‰çš„åŽç¼€ï¼Œå†æ‰«æä¸€éåŽä¾¿èƒ½ç»Ÿè®¡å‡ºæ¯ä¸ªå€™é€‰è¯çš„å·¦é‚»å­—ä¿¡æ¯ç†µã€‚å¦å¤–ï¼Œæœ‰äº†é¢‘æ•°ä¿¡æ¯åŽï¼Œå‡å›ºç¨‹åº¦ä¹Ÿéƒ½å¾ˆå¥½è®¡ç®—äº†ã€‚è¿™æ ·ï¼Œæˆ‘ä»¬ä¾¿å¾—åˆ°äº†ä¸€ä¸ªæ— éœ€ä»»ä½•çŸ¥è¯†åº“çš„æŠ½è¯ç®—æ³•ï¼Œè¾“å…¥ä¸€æ®µå……åˆ†é•¿çš„æ–‡æœ¬ï¼Œè¿™ä¸ªç®—æ³•èƒ½ä»¥å¤§è‡´ O(n Â· logn) çš„æ•ˆçŽ‡æå–å‡ºå¯èƒ½çš„è¯æ¥ã€‚ æ›´å¤šè¯¦ç»†çš„ä¿¡æ¯å¯ä»¥æŸ¥çœ‹è¿™ç¯‡åšå®¢ ä¸­â€æ–°è¯å‘çŽ°â€œéƒ¨åˆ†è®²è§£ã€‚ jiebaåˆ†è¯ä¼šä¾ç…§è¿™ä¸ªå­—å…¸,å°†å‡ºçŽ°åœ¨è¯å…¸ä¸­çš„è¯ç”Ÿæˆä¸€ä¸ªæ— å‘å›¾DAG: ç»Ÿè®¡æ–¹æ³•æœ‰å¾ˆå¼ºçš„é¢†åŸŸé€‚åº”èƒ½åŠ›å’Œå¯æ‰©å±•æ€§ï¼Œä½†å­˜åœ¨éœ€è¦å¤§è§„æ¨¡è¯­æ–™åº“å’Œæ•°æ®ç¨€ç–ç­‰é—®é¢˜ã€‚ åŸºäºŽåˆ†è¯çš„çƒ­è¯æŒ–æŽ˜ ä¸€ä¸ªé—®é¢˜æ‘†åœ¨äº†æˆ‘ä»¬é¢å‰ï¼šæˆ‘ä»¬å¦‚ä½•åŽ»é‡åŒ–ä¸€ä¸ªè¯çš„â€œå½“æ—¥çƒ­åº¦â€ï¼Ÿç¬¬ä¸€æƒ³æ³•å½“ç„¶æ˜¯ç®€å•åœ°çœ‹ä¸€çœ‹æ¯ä¸ªè¯çš„å½“æ—¥é¢‘æ•°å’Œæ˜¨æ—¥é¢‘æ•°ä¹‹é—´çš„å€æ•°å…³ç³»ï¼Œä¸è¿‡ç»†æƒ³ä¸€ä¸‹ä½ å°±å‘çŽ°é—®é¢˜äº†ï¼šå®ƒä¸èƒ½è§£å†³æ ·æœ¬è¿‡å°‘å¸¦æ¥çš„å¶ç„¶æ€§ã€‚ å¿½ç•¥æ‰€æœ‰æ ·æœ¬è¿‡å°‘çš„è¯ï¼Ÿè¿™ä¼¼ä¹Žä¹Ÿä¸å¤ªå¥½ï¼Œæ ·æœ¬å°‘çš„è¯ä¹Ÿæœ‰å¯èƒ½çœŸçš„æ˜¯çƒ­è¯ã€‚ è®©è®¡ç®—æœºä¹Ÿèƒ½èªæ˜Žåœ°æŽ’é™¤å¶ç„¶å› ç´ ï¼Œè¿™æ˜¯æˆ‘ä»¬åœ¨æ•°æ®æŒ–æŽ˜è¿‡ç¨‹ä¸­ç»å¸¸é‡åˆ°çš„é—®é¢˜ã€‚æˆ‘ä»¬ç»å¸¸éœ€è¦å¯¹æ ·æœ¬è¿‡å°‘çš„é¡¹ç›®è¿›è¡Œâ€œå¹³æ»‘â€æ“ä½œï¼Œä»¥é¿å…åˆ†æ¯è¿‡å°å¸¦æ¥çš„å¥‡ç‚¹ã€‚è¿™é‡Œï¼Œæˆ‘é‡‡ç”¨çš„æ˜¯ä¸€ä¸ªéžå¸¸å®¹æ˜“ç†è§£çš„æ–¹æ³•ï¼šä¸€ä¸ªè¯çš„æ ·æœ¬å¤ªå°‘ï¼Œå°±ç»™è¿™ä¸ªè¯çš„çƒ­åº¦æ‰“æŠ˜æ‰£ã€‚ æ€Žä¹ˆåšå‘¢ï¼Ÿæˆ‘ä»¬æŠŠæ¯ä¸ªè¯çš„å¾—åˆ†éƒ½å’Œå…¨å±€å¹³å‡åˆ†å–ä¸€ä¸ªåŠ æƒå¹³å‡ï¼é¦–å…ˆè®¡ç®—å‡ºè¿™å››ä¸ªè¯çš„å¹³å‡æ€»é¢‘æ•°ï¼Œä¸º 313.75 ï¼›å†è®¡ç®—å‡ºè¿™å››ä¸ªè¯çš„å¹³å‡å¾—åˆ†ï¼Œä¸º 0.719 ã€‚æŽ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å‡è®¾å·²ç»æœ‰ 313.75 ä¸ªäººé¢„å…ˆç»™æ¯ä¸ªè¯éƒ½æ‰“äº† 0.719 åˆ†ï¼Œæ¢å¥è¯è¯´æ¯ä¸ªè¯éƒ½å·²ç»æ”¶åˆ°äº† 313.75 æ¬¡è¯„åˆ†ï¼Œå¹¶ä¸”æ‰€æœ‰è¿™ 313.75 ä¸ªè¯„åˆ†éƒ½æ˜¯ 0.719 åˆ†ã€‚â€œä¸‹é›ªâ€è¿™ä¸ªè¯åˆ™è¿˜æœ‰é¢å¤–çš„ 125 ä¸ªäººè¯„åˆ†ï¼Œå…¶ä¸­æ¯ä¸ªäººéƒ½ç»™äº† 0.736 åˆ†ã€‚å› æ­¤ï¼Œâ€œä¸‹é›ªâ€ä¸€è¯çš„æœ€ç»ˆå¾—åˆ†å°±æ˜¯ï¼š å®¹æ˜“çœ‹å‡ºï¼Œæ­¤æ—¶æ ·æœ¬è¶Šå¤§çš„è¯ï¼Œå°±è¶Šæœ‰èƒ½åŠ›æŠŠæœ€ç»ˆå¾—åˆ†æ‹‰å‘è‡ªå·±æœ¬æ¥çš„å¾—åˆ†ï¼Œæ ·æœ¬å¤ªå°çš„è¯ï¼Œæœ€ç»ˆå¾—åˆ†å°†ä¼šä¸Žå…¨å±€å¹³å‡åˆ†éžå¸¸æŽ¥è¿‘ã€‚ç»è¿‡è¿™ä¹ˆä¸€ç•ªè°ƒæ•´ï¼Œâ€œä¸‹é›ªâ€ä¸€è¯çš„å¾—åˆ†ä¾¿é«˜äºŽäº†â€œæŽå®‡æ˜¥â€ã€‚å®žé™…è¿ç”¨ä¸­ï¼Œ 313.75 è¿™ä¸ªæ•°ä¹Ÿå¯ä»¥ç”±ä½ è‡ªå·±æ¥å®šï¼Œå®šå¾—è¶Šé«˜å°±è¡¨æ˜Žä½ è¶Šåœ¨æ„æ ·æœ¬è¿‡å°‘å¸¦æ¥çš„è´Ÿé¢å½±å“ã€‚è¿™ç§ä¸Žå…¨å±€å¹³å‡å–åŠ æƒå¹³å‡çš„æ€æƒ³å«åš Bayesian average ï¼Œä»Žä¸Šé¢çš„è‹¥å¹²å¼å­é‡Œå¾ˆå®¹æ˜“çœ‹å‡ºï¼Œå®ƒå®žé™…ä¸Šæ˜¯æœ€å¸¸è§çš„å¹³æ»‘å¤„ç†æ–¹æ³•ä¹‹ä¸€â€”â€”åˆ†å­åˆ†æ¯éƒ½åŠ ä¸Šä¸€ä¸ªå¸¸æ•°â€”â€”çš„ä¸€ç§ç‰¹æ®Šå½¢å¼ã€‚ åˆ©ç”¨ä¹‹å‰çš„æŠ½è¯ç¨‹åºæŠ½å–å‡ºäººäººç½‘æ¯ä¸€å¤©å†…ç”¨æˆ·çŠ¶æ€æ‰€å«çš„è¯ï¼ŒæŠŠå®ƒä»¬çš„é¢‘æ•°éƒ½ä¸Žå‰ä¸€å¤©çš„ä½œå¯¹æ¯”ï¼Œå†åˆ©ç”¨åˆšæ‰çš„æ–¹æ³•åŠ ä»¥å¹³æ»‘ï¼Œä¾¿èƒ½å¾—å‡ºæ¯ä¸€å¤©çš„çƒ­è¯äº†ã€‚ æ³¨æ„ï¼Œç”±äºŽæˆ‘ä»¬ä»…ä»…å¯¹æ¯”äº†ç›¸é‚»ä¸¤å¤©çš„çŠ¶æ€ï¼Œå› è€Œäº§ç”Ÿäº†ä¸ªåˆ«å®žé™…ä¸Šæ˜¯ç”±å·¥ä½œæ—¥/ä¼‘æ¯æ—¥çš„åŒºåˆ«é€ æˆçš„â€œçƒ­è¯â€ï¼Œæ¯”å¦‚â€œæ•™å®¤â€ã€â€œè€å¸ˆâ€ã€â€œæ˜ŸæœŸäºŒâ€ç­‰ã€‚æŠŠè¿™æ ·çš„è¯å½“ä½œçƒ­è¯å¯èƒ½å¹¶ä¸å¤ªå¦¥ã€‚ç»“åˆä¸Šå‘¨åŒæ—¥çš„æ•°æ®ï¼Œæˆ–è€…å¹²è„†ç›´æŽ¥ä¸Žä¹‹å‰æ•´ä¸ªä¸€å‘¨çš„æ•°æ®æ¥å¯¹æ¯”ï¼Œæˆ–è®¸å¯ä»¥éƒ¨åˆ†åœ°è§£å†³è¿™ä¸€é—®é¢˜ã€‚ äº‹å®žä¸Šï¼Œæœ‰äº†ä¸Šè¿°å·¥å…·ï¼Œæˆ‘ä»¬å¯ä»¥ä»»æ„æ¯”è¾ƒä¸¤æ®µä¸åŒæ–‡æœ¬ä¸­çš„ç”¨è¯ç‰¹ç‚¹ã€‚æ›´æœ‰è¶£çš„æ˜¯ï¼Œäººäººç½‘çŠ¶æ€çš„å¤§å¤šæ•°å‘å¸ƒè€…éƒ½å¡«å†™äº†æ€§åˆ«å’Œå¹´é¾„çš„ä¸ªäººä¿¡æ¯ï¼Œæˆ‘ä»¬ä¸ºä½•ä¸æŠŠçŠ¶æ€é‡æ–°åˆ†æˆç”·æ€§å’Œå¥³æ€§ä¸¤ç»„ï¼Œæˆ–è€… 80 åŽå’Œ 90 åŽä¸¤ç»„ï¼ŒæŒ–æŽ˜å‡ºä¸åŒå±žæ€§çš„äººéƒ½çˆ±è¯´ä»€ä¹ˆï¼Ÿè¦çŸ¥é“ï¼Œåœ¨è¿‡åŽ»ï¼Œè¿™æ ·çš„é—®é¢˜éœ€è¦è¿›è¡Œå¤§è§„æ¨¡è¯­è¨€ç»Ÿè®¡è°ƒæŸ¥æ‰èƒ½å›žç­”ï¼ç„¶è€Œï¼Œåœ¨äº’è”ç½‘æµ·é‡ç”¨æˆ·ç”Ÿæˆå†…å®¹çš„æ”¯æŒä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥è½»è€Œæ˜“ä¸¾åœ°æŒ–æŽ˜å‡ºç­”æ¡ˆæ¥ã€‚ ä¸ä»…å¦‚æ­¤ï¼Œä¸å°‘çŠ¶æ€è¿˜å¸¦æœ‰åœ°ç†ä½ç½®ä¿¡æ¯ï¼Œå› è€Œæˆ‘ä»¬å¯ä»¥ç«™åœ¨ç©ºé—´çš„ç»´åº¦å¯¹ä¿¡æ¯è¿›è¡Œè§‚å¯Ÿã€‚è¿™ä¸ªåœ°æ–¹çš„äººéƒ½çˆ±è¯´äº›ä»€ä¹ˆï¼Ÿçˆ±è¯´è¿™ä¸ªè¯çš„äººéƒ½åˆ†å¸ƒåœ¨å“ªé‡Œï¼Ÿå€ŸåŠ©è¿™äº›åŒ…å«åœ°ç†ä½ç½®çš„ç­¾åˆ°ä¿¡æ¯ï¼Œæˆ‘ä»¬ä¹Ÿèƒ½æŒ–æŽ˜å‡ºå¾ˆå¤šæœ‰æ„æ€çš„ç»“æžœæ¥ã€‚ä¾‹å¦‚ï¼Œå¯¹åŒ—äº¬ç”¨æˆ·çš„ç­¾åˆ°ä¿¡æ¯è¿›è¡ŒæŠ½è¯ï¼Œç„¶åŽå¯¹äºŽæ¯ä¸€ä¸ªæŠ½å‡ºæ¥çš„è¯ï¼Œç­›é€‰å‡ºæ‰€æœ‰åŒ…å«è¯¥è¯çš„ç­¾åˆ°ä¿¡æ¯å¹¶æŒ‰åœ°ç†åæ ‡çš„ä½ç½®èšç±»ï¼Œè¿™æ ·æˆ‘ä»¬ä¾¿èƒ½æ‰¾å‡ºé‚£äº›åœ°ç†åˆ†å¸ƒæœ€é›†ä¸­çš„è¯ã€‚ç»“æžœéžå¸¸æœ‰è¶£ï¼šâ€œè€ƒè¯•â€ä¸€è¯é›†ä¸­åˆ†å¸ƒåœ¨æµ·æ·€ä¼—é«˜æ ¡åŒºï¼Œâ€œå¤©æ´¥â€ä¸€è¯é›†ä¸­å‡ºçŽ°åœ¨åŒ—äº¬å—ç«™ï¼Œâ€œé€›è¡—â€ä¸€è¯åˆ™å…¨éƒ½åœ¨è¥¿å•é™„è¿‘æ‰Žå †ã€‚åŒ—äº¬é¦–éƒ½å›½é™…æœºåœºä¹Ÿæ˜¯ä¸€ä¸ªéžå¸¸ç‰¹åˆ«çš„åœ°ç‚¹ï¼Œâ€œåŒ—äº¬â€ã€â€œç™»æœºâ€ã€â€œç»ˆäºŽâ€ã€â€œå†è§â€ç­‰è¯åœ¨è¿™é‡Œå‡ºçŽ°çš„å¯†åº¦æžé«˜ã€‚ ä»Žå…¨å›½èŒƒå›´æ¥çœ‹ï¼Œä¸åŒåŒºåŸŸçš„äººä¹Ÿæœ‰æ˜Žæ˜¾çš„ç”¨è¯åŒºåˆ«ã€‚æˆ‘ä»¬å¯ä»¥å°†å…¨å›½åœ°å›¾åˆ’åˆ†æˆç½‘æ ¼ï¼Œç»Ÿè®¡å‡ºæ‰€æœ‰ç­¾åˆ°ä¿¡æ¯åœ¨å„ä¸ªå°æ ¼å†…å‡ºçŽ°çš„é¢‘æ•°ï¼Œä½œä¸ºæ ‡å‡†åˆ†å¸ƒï¼›ç„¶åŽå¯¹äºŽæ¯ä¸€ä¸ªæŠ½å‡ºæ¥çš„è¯ï¼Œç»Ÿè®¡å‡ºåŒ…å«è¯¥è¯çš„ç­¾åˆ°ä¿¡æ¯åœ¨å„ä¸ªå°æ ¼å†…å‡ºçŽ°çš„é¢‘æ•°ï¼Œå¹¶ä¸Žæ ‡å‡†åˆ†å¸ƒè¿›è¡Œå¯¹æ¯”ï¼ˆå¯ä»¥é‡‡ç”¨ä½™å¼¦è·ç¦»ç­‰å…¬å¼ï¼‰ï¼Œä»Žè€Œæ‰¾å‡ºé‚£äº›åˆ†å¸ƒæœ€åå¸¸çš„è¯ã€‚ç¨‹åºè¿è¡ŒåŽå‘çŽ°ï¼Œè¿™æ ·çš„è¯è¿˜çœŸä¸å°‘ã€‚ä¸€äº›æ˜Žæ˜¾å…·æœ‰å—åŒ—å·®å¼‚çš„è¯ï¼Œåˆ†å¸ƒå°±ä¼šä¸Žæ•´ä¸ªèƒŒæ™¯ç›¸å·®ç”šè¿œã€‚ä¾‹å¦‚ï¼Œåœ¨èŠ‚å‡æ—¥çš„æ—¶å€™ï¼Œâ€œæ»‘é›ªâ€ä¸€è¯ä¸»è¦åœ¨åŒ—æ–¹å‡ºçŽ°ï¼Œâ€œç™»å±±â€ä¸€è¯åˆ™ä¸»è¦åœ¨å—æ–¹å‡ºçŽ°ã€‚åœ°æ–¹ç‰¹è‰²ä¹Ÿæ˜¯é€ æˆè¯è¯­åˆ†å¸ƒå·®å¼‚çš„ä¸€å¤§åŽŸå› ï¼Œä¾‹å¦‚â€œä¸‰é‡Œå±¯â€ä¸€è¯å‡ ä¹Žåªåœ¨åŒ—äº¬å‡ºçŽ°ï¼Œâ€œçƒ­å¹²é¢â€ä¸€è¯é›†ä¸­å‡ºçŽ°åœ¨æ­¦æ±‰åœ°åŒºï¼Œâ€œåœ°é“â€ä¸€è¯æ˜Žæ˜¾åªæœ‰ä¸ªåˆ«åŸŽå¸‚æœ‰æ‰€æ¶‰åŠã€‚è¿™ç§ç”±å½“åœ°äººçš„ç”¨è¯ç‰¹å¾åæ˜ å‡ºæ¥çš„çœŸå®žçš„åœ°æ–¹ç‰¹è‰²ï¼Œå¾ˆå¯èƒ½æ˜¯è®¸å¤šæ—…æ¸¸çˆ±å¥½è€…æ¢¦å¯ä»¥æ±‚çš„ä¿¡æ¯ã€‚å¦å¤–ï¼Œæ–¹è¨€ä¹Ÿä¼šå¯¼è‡´ç”¨è¯åˆ†å¸ƒå·®å¼‚ï¼Œä¾‹å¦‚â€œå’‹è¿™ä¹ˆâ€ä¸»è¦åˆ†å¸ƒåœ¨åŒ—æ–¹åœ°åŒºï¼Œâ€œæžä¸æ‡‚â€ä¸»è¦åˆ†å¸ƒåœ¨å—æ–¹åŸŽå¸‚ï¼Œâ€œä¼â€åˆ™éžå¸¸é›†ä¸­åœ°å‡ºçŽ°åœ¨ä¸Šæµ·åœ°åŒºã€‚å½“æ•°æ®è§„æ¨¡è¶³å¤Ÿå¤§æ—¶ï¼Œæˆ–è®¸æˆ‘ä»¬èƒ½é€šè¿‡è®¡ç®—çš„æ–¹æ³•ï¼Œè‡ªåŠ¨å¯¹ä¸­å›½çš„æ–¹è¨€åŒºè¿›è¡Œåˆ’åˆ†ã€‚ å…¶å®žï¼Œä¸ä»…ä»…æ˜¯å‘å¸ƒæ—¶é—´ã€ç”¨æˆ·å¹´é¾„ã€ç”¨æˆ·æ€§åˆ«ã€åœ°ç†ä½ç½®è¿™å››ä¸ªç»´åº¦ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥å¯¹æµè§ˆå™¨ã€ç”¨æˆ·èŒä¸šã€ç”¨æˆ·æ´»è·ƒåº¦ã€ç”¨æˆ·è¡Œä¸ºåå¥½ç­‰å„ç§å„æ ·çš„ç»´åº¦è¿›è¡Œåˆ†æžï¼Œç”šè‡³å¯ä»¥ç»¼åˆè€ƒè™‘ä»¥ä¸Šç»´åº¦ï¼Œåœ¨æŸä¸ªç‰¹å®šèŒƒå›´å†…æŒ–æŽ˜çƒ­ç‚¹äº‹ä»¶ï¼Œæˆ–è€…æ ¹æ®è¯­è¨€ä¹ æƒ¯åŽ»å¯»æ‰¾å‡ºæŸä¸ªç‰¹å®šçš„äººç¾¤ã€‚æˆ–è®¸è¿™å¬ä¸ŠåŽ»å¤ªè¿‡ç†æƒ³åŒ–ï¼Œä¸è¿‡æˆ‘åšä¿¡ï¼Œæœ‰äº†åˆé€‚çš„ç®—æ³•ï¼Œè¿™äº›æƒ³æ³•ç»ˆç©¶ä¼šè¢«ä¸€ä¸€å®žçŽ°ã€‚ ä¸Šé¢çš„ç§°è¿°åªæ˜¯æŠ›è½¬å¼•çŽ‰ï¼Œè¯¦ç»†çš„åŸºäºŽSNSçš„æ–‡æœ¬æ•°æ®æŒ–æŽ˜ åŸºäºŽHMM å¯¹äºŽæœªç™»å½•è¯,è¯å…¸ä¸­æ²¡æœ‰,æ‰€ä»¥ä½¿ç”¨ä¸Šè¿°æ–¹æ³•ä¼šè¢«åˆ†ä¸ºå•å­—è¯,è¿˜æ˜¯ä¸Šé¢çš„ä¾‹å­: ç»“å©šï¼çš„ï¼å’Œï¼å°šæœªï¼ç»“å©šï¼çš„ å¯¹äºŽjiebaåˆ†è¯æ¥è¯´,è¿™é‡Œçš„è¿žç»­å•å­—è¯â€çš„å’Œâ€å°±å¾ˆæœ‰å¯èƒ½æ˜¯ä¸€ä¸ªæ–°è¯,ä¼šè¢«é€å…¥éšé©¬å°”ç§‘å¤«æ¨¡åž‹æ¥åšè¿›ä¸€æ­¥çš„è¯†åˆ«. å®žé™…ä¸Šå½“æˆ‘ä»¬æŠŠdict.txtä¸­çš„è¯è¯­å…¨éƒ¨åˆ é™¤ï¼Œjiebaä¾ç„¶èƒ½å¤Ÿè¿›è¡Œåˆ†è¯ï¼Œå…¶å®žè¿™ä¸ªæ—¶å€™ä½¿ç”¨çš„å°±æ˜¯HMMæ¥è¿›è¡Œåˆ†è¯äº†ã€‚ è‡ªç„¶è¯­è¨€å¤„ç†ä¸­çš„åºåˆ—æ ‡æ³¨é—®é¢˜, åœ¨ç›®å‰, æ¯”è¾ƒä¸»æµçš„æŠ€æœ¯æ˜¯è¯­è¨€æ¨¡åž‹(å¦‚LSTM, BERT)+CRF(æ¡ä»¶éšæœºåœº)ã€‚ä¸ºä»€ä¹ˆå•å•ä½¿ç”¨è¯­è¨€æ¨¡åž‹æ˜¯ä¸å¯ä»¥çš„ï¼ŒåŽé¢éœ€è¦åŠ ä¸Šæ¦‚çŽ‡å›¾æ¨¡åž‹ï¼Ÿæ¯”å¦‚è¯´â€è‡ªè´¸åŒºâ€å¯¹åº”çš„æ ‡æ³¨æ˜¯: è‡ª(B-LOC)è´¸(I-LOC)åŒº(I-LOC), è¿™ä¸‰ä¸ªå­—éƒ½å¯¹åº”ä¸€ä¸ªâ€åœ°åâ€çš„æ ‡ç­¾, ä½†æ˜¯ç¬¬ä¸€ä¸ªå­—å±žäºŽå®žä½“å¼€å¤´çš„å­—, æ‰€ä»¥ä½¿ç”¨â€Bâ€å¼€å¤´çš„æ ‡ç­¾, åŽé¢ä¸¤ä¸ªå­—çš„æ ‡ç­¾éƒ½æ˜¯â€Iâ€å¼€å¤´. æ¯”å¦‚è¯´æ­å»ºå¥½æ¨¡åž‹ä¹‹åŽï¼Œä½¿ç”¨äº¤å‰ç†µæ¥è®­ç»ƒæ¨¡åž‹ï¼Œå¾ˆæœ‰å¯èƒ½å¾—åˆ°argmax æ˜¯ä¸Šé¢çš„ç»„åˆï¼›ä¸Šé¢çš„åŽŸå› å°±æ˜¯æˆ‘ä»¬è¦ä»Žè¯­è¨€æ¨¡åž‹(ä¾‹å¦‚BERT, LSTM)åŽé¢å†åŠ ä¸Šæ¦‚çŽ‡å›¾æ¨¡åž‹, ä¾‹å¦‚æ¡ä»¶éšæœºåœº, ç”¨æ¥çº¦æŸæ¨¡åž‹çš„è¾“å‡º, é˜²æ­¢å‡ºçŽ°ä¸åˆè§„çš„æ ‡æ³¨è¾“å‡º. å¦‚æžœä½¿ç”¨æ¡ä»¶éšæœºåœºï¼Œé‚£ä¹ˆæ¡ä»¶éšæœºåœºçš„æŸå¤±æ˜¯å¯ä»¥åä¼ åˆ°æ¨¡åž‹ä¸­åŽ»ï¼Œå¸®åŠ©æ¨¡åž‹åšæ›´å¥½çš„å»ºç«‹åºåˆ—ä¹‹é—´çš„ä¾èµ–å…³ç³»ã€‚ ä»€ä¹ˆæ˜¯HMMï¼Ÿ HMMæ¨¡åž‹æ˜¯æ¦‚çŽ‡å›¾æ¨¡åž‹çš„ä¸€ç§, å±žäºŽç”Ÿæˆæ¨¡åž‹, ç¬¼ç»Ÿçš„è¯´, æˆ‘ä»¬ä¸Šé¢è¯´çš„â€BIOâ€çš„å®žä½“æ ‡ç­¾, å°±æ˜¯ä¸€ä¸ªä¸å¯è§‚æµ‹çš„éšçŠ¶æ€, è€ŒHMMæ¨¡åž‹æè¿°çš„å°±æ˜¯ç”±è¿™äº›éšçŠ¶æ€åºåˆ—(å®žä½“æ ‡è®°)ç”Ÿæˆå¯è§‚æµ‹çŠ¶æ€(å¯è¯»æ–‡æœ¬)çš„è¿‡ç¨‹. HMMæ¨¡åž‹æœ‰ä¸¤ä¸ªåŸºæœ¬å‡è®¾(éžå¸¸é‡è¦): ç¬¬$t$ä¸ªéšçŠ¶æ€(å®žä½“æ ‡ç­¾)åªè·Ÿå‰ä¸€æ—¶åˆ»çš„$t-1$éšçŠ¶æ€(å®žä½“æ ‡ç­¾)æœ‰å…³, ä¸Žé™¤æ­¤ä¹‹å¤–çš„å…¶ä»–éšçŠ¶æ€(å¦‚$t-2,\ t+3$)æ— å…³.ä¾‹å¦‚ä¸Šå›¾ä¸­: è“è‰²çš„éƒ¨åˆ†æŒ‡çš„æ˜¯$i_t$åªä¸Ž$i_{t-1}$æœ‰å…³, è€Œä¸Žè“è‰²åŒºåŸŸä¹‹å¤–çš„æ‰€æœ‰å†…å®¹éƒ½æ— å…³, è€Œ$P(i_{t}|i_{t-1})$æŒ‡çš„æ˜¯éšçŠ¶æ€$i$ä»Ž$t-1$æ—¶åˆ»è½¬å‘$t$æ—¶åˆ»çš„æ¦‚çŽ‡, å…·ä½“è½¬æ¢æ–¹å¼ä¸‹é¢ä¼šç»†è®². è§‚æµ‹ç‹¬ç«‹çš„å‡è®¾, æˆ‘ä»¬ä¸Šé¢è¯´è¿‡, HMMæ¨¡åž‹ä¸­æ˜¯ç”±éšçŠ¶æ€åºåˆ—(å®žä½“æ ‡è®°)ç”Ÿæˆå¯è§‚æµ‹çŠ¶æ€(å¯è¯»æ–‡æœ¬)çš„è¿‡ç¨‹,è§‚æµ‹ç‹¬ç«‹å‡è®¾æ˜¯æŒ‡åœ¨ä»»æ„æ—¶åˆ»è§‚æµ‹$o_t$åªä¾èµ–äºŽå½“å‰æ—¶åˆ»çš„éšçŠ¶æ€$i_t$, ä¸Žå…¶ä»–æ—¶åˆ»çš„éšçŠ¶æ€æ— å…³.ä¾‹å¦‚ä¸Šå›¾ä¸­: ç²‰çº¢è‰²çš„éƒ¨åˆ†æŒ‡çš„æ˜¯$i_{t+1}$åªä¸Ž$o_{t+1}$æœ‰å…³, è·Ÿç²‰çº¢è‰²åŒºåŸŸä¹‹å¤–çš„æ‰€æœ‰å†…å®¹éƒ½æ— å…³. æˆ‘ä»¬çŽ°åœ¨å·²ç»äº†è§£äº†HMMçš„ä¸‰å¤§å‚æ•°$A, \ B, \ \pi$, å‡è®¾æˆ‘ä»¬å·²ç»é€šè¿‡å»ºæ¨¡å­¦ä¹ , å­¦åˆ°äº†è¿™äº›å‚æ•°, å¾—åˆ°äº†æ¨¡åž‹çš„æ¦‚çŽ‡, æˆ‘ä»¬æ€Žä¹ˆä½¿ç”¨è¿™äº›å‚æ•°æ¥è§£å†³åºåˆ—æ ‡æ³¨é—®é¢˜å‘¢?è®¾ç›®å‰åœ¨æ—¶åˆ»$t$, æˆ‘ä»¬æœ‰å½“å‰æ—¶åˆ»çš„è§‚æµ‹åˆ°çš„ä¸€ä¸ªæ±‰å­—$o_t=v_k$(æŒ‡çš„ç¬¬$t$æ—¶åˆ»è§‚æµ‹åˆ°$v_k$), å‡è®¾æˆ‘ä»¬è¿˜çŸ¥é“åœ¨$t-1$æ—¶åˆ»(å‰ä¸€æ—¶åˆ»)å¯¹åº”çš„å®žä½“æ ‡è®°ç±»åž‹$i_{t-1} = \hat{q}^{t-1}_i$(æŒ‡çš„$t-1$æ—¶åˆ»æ ‡è®°ä¸º$\hat{q}^{t-1}i$). æˆ‘ä»¬è¦åšçš„ä»…ä»…æ˜¯åˆ—ä¸¾æ‰€æœ‰$i{t}$å¯èƒ½çš„å®žä½“æ ‡è®°$\hat{q}^{t}{j}$, å¹¶æ±‚å¯ä»¥ä½¿ä¸‹å¼è¾“å‡ºå€¼æœ€å¤§çš„é‚£ä¸ªå®žä½“ç±»åž‹$q^{t}{j}$(ä¹Ÿå°±æ˜¯éšçŠ¶æ€ç±»åž‹):$$\hat{q}j^{t} = argmax{\hat{q}j^{t} \in Q{hidden}}P(i_t = \hat{q}j^{t} | i{t-1} = \hat{q}^{t-1}_i) P(o_t=v_k| i_t = \hat{q}_j^{t})$$å°†æ‰€æœ‰$t$æ—¶åˆ»å½“å‰å¯å–çš„å®žä½“æ ‡ç­¾å¸¦å…¥ä¸‹å¼ä¸­, æ‰¾å‡ºä¸€ä¸ªå¯ä»¥ä½¿ä¸‹å¼å–å€¼æœ€å¤§çš„é‚£ä¸ªå®žä½“æ ‡ç­¾ä½œä¸ºå½“å‰å­—çš„æ ‡æ³¨:$$P(å½“å‰å¯å–å®žä½“æ ‡ç­¾|ä¸Šä¸€æ—¶åˆ»å®žä½“æ ‡ç­¾)P(æµ‹åˆ°çš„æ±‰å­—|å½“å‰å¯å–å®žä½“æ ‡ç­¾)$$æ³¨æ„: æˆ‘ä»¬è¿™é‡Œåªè®²åˆ°äº†æ€Žæ ·æ±‚ç¬¬$t$æ—¶åˆ»çš„æœ€ä¼˜æ ‡æ³¨, ä½†æ˜¯åœ¨æ¯ä¸€æ—¶åˆ»è¿›è¡Œè¿™æ ·çš„è®¡ç®—, å¹¶ä¸ä¸€å®šèƒ½ä¿è¯æœ€åŽèƒ½å¾—å‡ºå…¨å±€æœ€ä¼˜åºåˆ—è·¯å¾„, ä¾‹å¦‚åœ¨ç¬¬$t$æ—¶åˆ»æœ€ä¼˜å®žä½“æ ‡ç­¾æ˜¯$q_j$, ä½†åˆ°äº†ä¸‹ä¸€æ­¥, ç”±äºŽä»Ž$q_j$è½¬ç§»åˆ°å…¶ä»–æŸäº›å®žä½“æ ‡ç­¾çš„è½¬ç§»æ¦‚çŽ‡æ¯”è¾ƒä½Ž, è€Œé™ä½Žäº†ç»è¿‡$q_j$çš„è·¯å¾„çš„æ•´ä½“æ¦‚çŽ‡, æ‰€ä»¥åˆ°äº†ä¸‹ä¸€æ—¶åˆ»æœ€ä¼˜è·¯å¾„å°±æœ‰å¯èƒ½åœ¨ç¬¬$t$æ—¶åˆ»ä¸ç»è¿‡$q_j$äº†, æ‰€ä»¥æ¯ä¸€æ­¥çš„å±€éƒ¨æœ€ä¼˜å¹¶ä¸ä¸€å®šå¯ä»¥è¾¾æˆå…¨å±€æœ€ä¼˜, æ‰€ä»¥æˆ‘ä»¬ä¹‹åŽä¼šç”¨åˆ°ç»´ç‰¹æ¯”ç®—æ³•æ¥æ‰¾åˆ°å…¨å±€æœ€ä¼˜çš„æ ‡æ³¨åºåˆ—, è¿™ä¸ªåŽé¢ä¼šæœ‰è¯¦ç»†è®²è§£. HMMå‚æ•°å­¦ä¹ (ç›‘ç£å­¦ä¹ ): æˆ‘ä»¬ä»Šå¤©è¦ç”¨HMMè§£å†³çš„æ˜¯åºåˆ—æ ‡æ³¨é—®é¢˜, æ‰€ä»¥æˆ‘ä»¬è§£å†³çš„æ˜¯ç›‘ç£å­¦ä¹ çš„é—®é¢˜. ä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬çŽ°åœ¨æœ‰ä¸€äº›æ–‡æœ¬å’Œä¸Žä¹‹å¯¹åº”çš„æ ‡æ³¨æ•°æ®, æˆ‘ä»¬è¦è®­ç»ƒä¸€ä¸ªHMMæ¥æ‹Ÿåˆè¿™äº›æ•°æ®, ä»¥ä¾¿ä¹‹åŽç”¨è¿™ä¸ªæ¨¡åž‹è¿›è¡Œæ•°æ®æ ‡æ³¨ä»»åŠ¡, æœ€ç®€å•çš„æ–¹å¼æ˜¯ç›´æŽ¥ç”¨æžå¤§ä¼¼ç„¶ä¼°è®¡æ¥ä¼°è®¡å‚æ•°: åˆå§‹éšçŠ¶æ€æ¦‚çŽ‡$\pi$çš„å‚æ•°ä¼°è®¡:$$\hat{\pi}_{q_i}=\frac{count(q^{1}_{i})}{count(o_1)}$$ä¸Šå¼æŒ‡çš„æ˜¯, è®¡ç®—åœ¨ç¬¬$1$æ—¶åˆ», ä¹Ÿå°±æ˜¯æ–‡æœ¬ä¸­ç¬¬ä¸€ä¸ªå­—, $q^{1}_{i}$å‡ºçŽ°çš„æ¬¡æ•°å æ€»ç¬¬ä¸€ä¸ªå­—$o_1$è§‚æµ‹æ¬¡æ•°çš„æ¯”ä¾‹, $q^{1}_{i}$ä¸Šæ ‡1æŒ‡çš„æ˜¯ç¬¬1æ—¶åˆ», ä¸‹æ ‡$i$æŒ‡çš„æ˜¯ç¬¬$i$ç§æ ‡ç­¾(éšçŠ¶æ€), $count$æ˜¯çš„æ˜¯è®°å½•æ¬¡æ•°. è½¬ç§»æ¦‚çŽ‡çŸ©é˜µ$A$çš„å‚æ•°ä¼°è®¡:æˆ‘ä»¬ä¹‹å‰æåˆ°è¿‡$transition \ matrix$é‡Œé¢$A_{ij}$(çŸ©é˜µçš„ç¬¬iè¡Œç¬¬jåˆ—)æŒ‡çš„æ˜¯åœ¨$t$æ—¶åˆ»å®žä½“æ ‡ç­¾ä¸º$q_i$, è€Œåœ¨$t+1$æ—¶åˆ»å®žä½“æ ‡ç­¾è½¬æ¢åˆ°$q_j$çš„æ¦‚çŽ‡, åˆ™è½¬ç§»æ¦‚çŽ‡çŸ©é˜µçš„å‚æ•°ä¼°è®¡ç›¸å½“ä¸Žä¸€ä¸ªäºŒå…ƒæ¨¡åž‹$bigram$, ä¹Ÿå°±æ˜¯æŠŠæ‰€æœ‰çš„æ ‡æ³¨åºåˆ—ä¸­æ¯ç›¸é‚»çš„ä¸¤ä¸ªå®žä½“æ ‡ç­¾åˆ†æˆä¸€ç»„, ç»Ÿè®¡ä»–ä»¬å‡ºçŽ°çš„æ¦‚çŽ‡:$$\hat{A}{ij}=P(i{t+1}= q_j | i_{t} = q_i)=\frac{count(q_iåŽé¢å‡ºçŽ°q_jçš„æ¬¡æ•°)}{count(q_içš„æ¬¡æ•°)}$$ è”åˆæ¦‚çŽ‡ é™¤ä»¥è¾¹ç¼˜æ¦‚çŽ‡ å‘å°„æ¦‚çŽ‡çŸ©é˜µ$B$çš„å‚æ•°ä¼°è®¡:æˆ‘ä»¬æåˆ°è¿‡$emission \ matrix$ä¸­çš„$B_{jk}$(çŸ©é˜µç¬¬jè¡Œç¬¬kåˆ—)æŒ‡çš„æ˜¯åœ¨$t$æ—¶åˆ»ç”±å®žä½“æ ‡ç­¾(éšçŠ¶æ€)$q_j$ç”Ÿæˆæ±‰å­—(è§‚æµ‹ç»“æžœ)$v_k$çš„æ¦‚çŽ‡.$$\hat{B}{jk}=P(o{t}= v_k | i_{t} = q_j)=\frac{count(q_jä¸Žv_kåŒæ—¶å‡ºçŽ°çš„æ¬¡æ•°)}{count(q_jå‡ºçŽ°çš„æ¬¡æ•°)}$$åˆ°æ­¤ä¸ºæ­¢, æˆ‘ä»¬å°±å¯ä»¥éåŽ†æ‰€æœ‰è¯­æ–™, æ ¹æ®ä¸Šé¢çš„æ–¹å¼å¾—åˆ°æ¨¡åž‹çš„å‚æ•°$A, \ B, \ \pi$çš„ä¼°è®¡. è§†é¢‘è®²è§£ åŸºäºŽéšé©¬å°”ç§‘å¤«æ¨¡åž‹çš„æ–°è¯å‘çŽ° äº’è”ç½‘ä¸­ç»å¸¸ä¼šå‡ºçŽ°å¾ˆå¤šç½‘çº¢è¯,æ¯”å¦‚æœ€è¿‘çš„â€ä½›ç³»é’å¹´â€,â€œé£Ÿè‰ç”·â€.è¿™äº›è¯å¹¶ä¸åœ¨è¯å…¸ä¸­,è¢«ç§°ä¸ºæœªç™»å½•è¯,å‰é¢å†™è¿‡ä¸€ç¯‡æ–‡ç« ä¿¡æ¯ç†µåœ¨æ–°è¯å‘çŽ°ä¸­çš„è¿ç”¨åˆ©ç”¨ç®€å•çš„æ¦‚çŽ‡çŸ¥è¯†å°±å¯ä»¥è¯†åˆ«è¿™ç§æ–°è¯,ä¸è¿‡jiebaåˆ†è¯å¹¶æ²¡æœ‰é‡‡ç”¨è¿™ç§æ–¹æ³•,è€Œæ˜¯ç”¨æ›´ä¸ºå¼ºå¤§çš„éšé©¬å°”ç§‘å¤«æ¨¡åž‹è¿›è¡Œæ–°è¯å‘çŽ°. å¯¹äºŽæœªç™»å½•è¯,è¯å…¸ä¸­æ²¡æœ‰,æ‰€ä»¥ä½¿ç”¨ä¸Šè¿°æ–¹æ³•ä¼šè¢«åˆ†ä¸ºå•å­—è¯,è¿˜æ˜¯ä¸Šé¢çš„ä¾‹å­: ç»“å©šï¼çš„ï¼å’Œï¼å°šæœªï¼ç»“å©šï¼çš„ å¯¹äºŽjiebaåˆ†è¯æ¥è¯´,è¿™é‡Œçš„è¿žç»­å•å­—è¯â€çš„å’Œâ€å°±å¾ˆæœ‰å¯èƒ½æ˜¯ä¸€ä¸ªæ–°è¯,ä¼šè¢«é€å…¥éšé©¬å°”ç§‘å¤«æ¨¡åž‹æ¥åšè¿›ä¸€æ­¥çš„è¯†åˆ«. å®žé™…ä¸Šå½“æˆ‘ä»¬æŠŠdict.txtä¸­çš„è¯è¯­å…¨éƒ¨åˆ é™¤ï¼Œjiebaä¾ç„¶èƒ½å¤Ÿè¿›è¡Œåˆ†è¯ï¼Œå…¶å®žè¿™ä¸ªæ—¶å€™ä½¿ç”¨çš„å°±æ˜¯HMMæ¥è¿›è¡Œåˆ†è¯äº†ã€‚ é©¬å°”ç§‘å¤«æ¨¡åž‹ç”¨æ¥åˆ†è¯æ—¶,ä½¿ç”¨BMES,ä½œä¸ºæ¯ä¸ªå­—çš„çŠ¶æ€,Bä»£è¡¨è¯å¤´,Mä»£è¡¨è¯ä¸­,Eä»£è¡¨è¯å°¾è¯,Sä»£è¡¨å•ä¸ªå­—çš„è¯.æ ¹æ®é¢„å…ˆè®­ç»ƒå¥½çš„èµ·å§‹çŠ¶æ€,è½¬ç§»æ¦‚çŽ‡å’Œè§‚æµ‹æ¦‚çŽ‡,å°±å¯ä»¥ä¼°è®¡å‡ºæ¯ä¸ªå•è¯çŠ¶æ€: æ–°è¯å‘çŽ°å’Œåˆ†è¯åŒæ ·çš„é“ç†,ä¼°è®¡æ¯ä¸ªå­—çš„éšçŠ¶æ€å°±å¯ä»¥åˆ¤æ–­æ˜¯å¦ä¸ºä¸€ä¸ªè¯. æŒ–æŽ˜æ–°è¯çš„ä¼ ç»Ÿæ–¹æ³•æ˜¯ï¼Œå…ˆå¯¹æ–‡æœ¬è¿›è¡Œåˆ†è¯ï¼Œç„¶åŽçŒœæµ‹æœªèƒ½æˆåŠŸåŒ¹é…çš„å‰©ä½™ç‰‡æ®µå°±æ˜¯æ–°è¯ã€‚è¿™ä¼¼ä¹Žé™·å…¥äº†ä¸€ä¸ªæ€ªåœˆï¼šåˆ†è¯çš„å‡†ç¡®æ€§æœ¬èº«å°±ä¾èµ–äºŽè¯åº“çš„å®Œæ•´æ€§ï¼Œå¦‚æžœè¯åº“ä¸­æ ¹æœ¬æ²¡æœ‰æ–°è¯ï¼Œæˆ‘ä»¬åˆæ€Žä¹ˆèƒ½ä¿¡ä»»åˆ†è¯ç»“æžœå‘¢ï¼Ÿæ­¤æ—¶ï¼Œä¸€ç§å¤§èƒ†çš„æƒ³æ³•æ˜¯ï¼Œé¦–å…ˆä¸ä¾èµ–äºŽä»»ä½•å·²æœ‰çš„è¯åº“ï¼Œä»…ä»…æ ¹æ®è¯çš„å…±åŒç‰¹å¾ï¼Œå°†ä¸€æ®µå¤§è§„æ¨¡è¯­æ–™ä¸­å¯èƒ½æˆè¯çš„æ–‡æœ¬ç‰‡æ®µå…¨éƒ¨æå–å‡ºæ¥ï¼Œä¸ç®¡å®ƒæ˜¯æ–°è¯è¿˜æ˜¯æ—§è¯ã€‚ç„¶åŽï¼Œå†æŠŠæ‰€æœ‰æŠ½å‡ºæ¥çš„è¯å’Œå·²æœ‰è¯åº“è¿›è¡Œæ¯”è¾ƒï¼Œä¸å°±èƒ½æ‰¾å‡ºæ–°è¯äº†å—ï¼Ÿ äº’è”ç½‘æ—¶ä»£çš„ç¤¾ä¼šè¯­è¨€å­¦ï¼šåŸºäºŽSNSçš„æ–‡æœ¬æ•°æ®æŒ–æŽ˜ hmm çš„è¿‡ç¨‹æ˜¯ç”±éšçŠ¶æ€ç”Ÿæˆå¯è§‚æµ‹çŠ¶æ€çš„è¿‡ç¨‹ã€‚æ¯”å¦‚æ˜¯ç”±æ ‡ç­¾ç”Ÿæˆæ–‡æœ¬ã€‚ hmm çš„å‡è®¾ ä¸¤å¤§å‡è®¾ HMMæ¨¡åž‹æœ‰ä¸¤ä¸ªåŸºæœ¬å‡è®¾(éžå¸¸é‡è¦): ç¬¬$t$ä¸ªéšçŠ¶æ€(å®žä½“æ ‡ç­¾)åªè·Ÿå‰ä¸€æ—¶åˆ»çš„$t-1$éšçŠ¶æ€(å®žä½“æ ‡ç­¾)æœ‰å…³, ä¸Žé™¤æ­¤ä¹‹å¤–çš„å…¶ä»–éšçŠ¶æ€(å¦‚$t-2,\ t+3$)æ— å…³.ä¾‹å¦‚ä¸Šå›¾ä¸­: è“è‰²çš„éƒ¨åˆ†æŒ‡çš„æ˜¯$i_t$åªä¸Ž$i_{t-1}$æœ‰å…³, è€Œä¸Žè“è‰²åŒºåŸŸä¹‹å¤–çš„æ‰€æœ‰å†…å®¹éƒ½æ— å…³, è€Œ$P(i_{t}|i_{t-1})$æŒ‡çš„æ˜¯éšçŠ¶æ€$i$ä»Ž$t-1$æ—¶åˆ»è½¬å‘$t$æ—¶åˆ»çš„æ¦‚çŽ‡, å…·ä½“è½¬æ¢æ–¹å¼ä¸‹é¢ä¼šç»†è®². è§‚æµ‹ç‹¬ç«‹çš„å‡è®¾, æˆ‘ä»¬ä¸Šé¢è¯´è¿‡, HMMæ¨¡åž‹ä¸­æ˜¯ç”±éšçŠ¶æ€åºåˆ—(å®žä½“æ ‡è®°)ç”Ÿæˆå¯è§‚æµ‹çŠ¶æ€(å¯è¯»æ–‡æœ¬)çš„è¿‡ç¨‹,è§‚æµ‹ç‹¬ç«‹å‡è®¾æ˜¯æŒ‡åœ¨ä»»æ„æ—¶åˆ»è§‚æµ‹$o_t$åªä¾èµ–äºŽå½“å‰æ—¶åˆ»çš„éšçŠ¶æ€$i_t$, ä¸Žå…¶ä»–æ—¶åˆ»çš„éšçŠ¶æ€æ— å…³.ä¾‹å¦‚ä¸Šå›¾ä¸­: ç²‰çº¢è‰²çš„éƒ¨åˆ†æŒ‡çš„æ˜¯$i_{t+1}$åªä¸Ž$o_{t+1}$æœ‰å…³, è·Ÿç²‰çº¢è‰²åŒºåŸŸä¹‹å¤–çš„æ‰€æœ‰å†…å®¹éƒ½æ— å…³. hmm çš„å‚æ•° ä¸‰å¤§å‚æ•° è½¬ç§»æ¦‚çŽ‡ æ˜¯ $n * n$ çš„çŸ©é˜µï¼Œ $n$ è¡¨ç¤ºæ ‡ç­¾çš„æ•°é‡ã€‚ å‘å°„æ¦‚çŽ‡ æ˜¯ $n * m$ çš„æ¦‚çŽ‡ï¼Œå…¶ä¸­ $n$ è¡¨ç¤ºæ ‡ç­¾çš„æ•°é‡ï¼Œ $m$ è¡¨ç¤ºå­—å…¸çš„å¤§å°ï¼Œå…±æœ‰$m $ ä¸­å¯èƒ½æ€§ã€‚ HMMçš„åˆå§‹éšçŠ¶æ€æ¦‚çŽ‡: åˆç§°ä¸º$initial \ probabilities$, æˆ‘ä»¬é€šå¸¸ç”¨$\pi$æ¥è¡¨ç¤º, æ³¨æ„è¿™é‡Œå¯ä¸æ˜¯åœ†å‘¨çŽ‡:$$\pi=P(i_1=q_i) \quad q_i \in Q_{hidden} = { q_0, q_1, â€¦ , q_{N-1}}$$ä¸Šå¼æŒ‡çš„æ˜¯è‡ªç„¶è¯­è¨€åºåˆ—ä¸­ç¬¬ä¸€ä¸ªå­—$o_1$çš„å®žä½“æ ‡è®°æ˜¯$q_i$çš„æ¦‚çŽ‡, ä¹Ÿå°±æ˜¯åˆå§‹éšçŠ¶æ€æ¦‚çŽ‡. æœ‰ç›‘ç£çš„å­¦ä¹ ï¼Œä½¿ç”¨hmm æ¥æ‹Ÿåˆè¿™äº›æ•°æ®ï¼Œç„¶åŽä½¿ç”¨è¿™ä¸ªæ¨¡åž‹è¿›è¡Œæ•°æ®æ ‡æ³¨ä»»åŠ¡ï¼Œæœ€ç®€å•çš„æ–¹å¼æ˜¯ç›´æŽ¥ç”¨æžå¤§ä¼¼ç„¶ä¼°è®¡æ¥ä¼°è®¡è¿™äº›å‚æ•°ã€‚ ä½¿ç”¨ argmax å¾—åˆ°çš„æ¯ä¸€æ­¥çš„å±€éƒ¨æœ€ä¼˜è§£ä¸ä¸€å®šæ˜¯ lead to å…¨å±€æœ€ä¼˜è§£ã€‚ è®­ç»ƒå¾ˆå¿«ï¼Œ2 -3sï¼Œå› ä¸ºåšçš„æ˜¯ä¸€ä¸ªæ¦‚çŽ‡ç»Ÿè®¡ï¼Œæžå¤§ä¼¼ç„¶ï¼Œå¾ˆç®€å•çš„ã€‚ ç»´ç‰¹æ¯”ç®—æ³•æ˜¯ç”¨æ¥æ±‚è§£å…¨å±€æœ€ä¼˜çš„æ ‡æ³¨åºåˆ—ã€‚ å®žé™…çš„è¿ç®—ï¼Œéƒ½æ˜¯æ±‚è§£logï¼Œä»Žä¹˜æ³•è½¬æˆåŠ æ³•ï¼Œé˜²æ­¢å› ä¸ºæ¦‚çŽ‡è¿‡å°è€Œé€ æˆä¸‹æº¢ã€‚ ç»´ç‰¹æ¯”ç®—æ³•ä½¿ç”¨äº†åŠ¨æ€è§„åˆ’ç®—æ³•æ¥è§£å†³ç±»ä¼¼HMM å’ŒCRF çš„é¢„æµ‹é—®é¢˜ã€‚ä½¿ç”¨ç»´ç‰¹æ¯”ç®—æ³•å¯ä»¥æ‰¾åˆ°æ¦‚çŽ‡æœ€å¤§è·¯å¾„ï¼Œä¹Ÿå°±æ˜¯æœ€ä¼˜è·¯å¾„ã€‚ ä¸€ä¸ªè¡¨æ ¼è®°å½•æœ€å¤§çš„æ¦‚çŽ‡ï¼Œ å¦ä¸€ä¸ªè¡¨æ ¼è®°å½•æœ€å¤§æ¦‚çŽ‡æ˜¯ä»Žå“ªä¸ªéšçŠ¶æ€è½¬ç§»è¿‡æ¥çš„ã€‚ æœ€ä¼˜è·¯å¾„çš„ç‰¹ç‚¹ï¼šæœ€ä¼˜è·¯å¾„æœ‰ä»¥ä¸‹ç‰¹æ€§: å‡è®¾æˆ‘ä»¬æœ‰ä¸€æ¡æœ€ä¼˜è·¯å¾„åœ¨$t$æ—¶åˆ»é€šè¿‡ä¸€ä¸ªéšçŠ¶æ€$i_t$, é‚£ä¹ˆè¿™ä¸€è·¯å¾„ä»Ž$i_t$åˆ°æœ€ä¼˜è·¯å¾„çš„ç»ˆç‚¹$i_T$ç›¸å¯¹äºŽåœ¨è¿™æ®µè·ç¦»é‡Œæ‰€æœ‰å¯èƒ½å‡ºçŽ°çš„è·¯å¾„é‡Œ, ä¹Ÿå¿…é¡»æ˜¯æœ€ä¼˜çš„. å¦åˆ™ä»Ž$i_t$åˆ°$i_T$å°±ä¼šæœ‰æ›´ä¼˜çš„ä¸€æ¡è·¯å¾„, å¦‚æžœæŠŠä»–å’Œä»Ž$i_1$åˆ°$i_t$çš„è·¯å¾„(æœ€ä¼˜è·¯å¾„$i_t$ä¹‹å‰çš„éƒ¨åˆ†)è¿žèµ·æ¥, ç­‰äºŽæˆ‘ä»¬åˆæœ‰ä¸€æ¡æ›´ä¼˜è·¯å¾„, è¿™æ˜¯çŸ›ç›¾çš„. æ—¶é—´å¤æ‚åº¦åˆ†æžï¼šå‡è®¾æˆ‘ä»¬æœ‰ $N$ ä¸­éšçŠ¶æ€ï¼Œåœ¨æ¯ä¸ªæ—¶åˆ»ä¹‹é—´ï¼Œä¸€å…±å¯èƒ½çš„è·¯å¾„æœ‰ $N^2$ ä¸­ï¼Œå‡è®¾æˆ‘ä»¬æœ‰$T$ ä¸ªæ—¶åˆ»ï¼Œé‚£ä¹ˆç»´ç‰¹æ¯”ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(TN^2)$ ner HMM å¯ä»¥ä½¿ç”¨åœ¨ æœ‰ç›‘ç£çš„å­¦ä¹ ä¸­ï¼ˆçŸ¥é“äº†éšçŠ¶æ€ å’Œè§‚æµ‹çŠ¶æ€ï¼Œ æœªçŸ¥å˜é‡æ˜¯æ¨¡åž‹çš„å‚æ•°ï¼‰ï¼Œå’Œæ— ç›‘ç£å­¦ä¹ ä¸­ï¼ˆåªæ˜¯çŸ¥é“è§‚æµ‹çŠ¶æ€ï¼Œéœ€è¦æ±‚è§£ æ¨¡åž‹çš„å‚æ•°å’ŒéšçŠ¶æ€ï¼Œè¿™ä¸ªæ—¶å€™éœ€è¦ä½¿ç”¨ç±»ä¼¼ EM ç®—æ³•çš„æ€æƒ³ï¼‰ å‘½åå®žä½“è¯†åˆ«ï¼ˆName Entity Recognition,NERï¼‰ å‘½åå®žä½“è¯†åˆ«ï¼ˆName Entity Recognition,NERï¼‰,ä¹Ÿç§°ä½œâ€œä¸“åè¯†åˆ«â€ï¼Œæ˜¯æŒ‡è¯†åˆ«æ–‡æœ¬ä¸­å…·æœ‰ç‰¹å®šæ„ä¹‰çš„å®žä½“ï¼ŒåŒ…æ‹¬äººåã€åœ°åã€æœºæž„åã€ä¸“æœ‰åè¯ç­‰ã€‚ NER çš„è¯„ä»·æŒ‡æ ‡ï¼Œ acc precision, recall å’ŒF1å€¼ å‘½åå®žä½“è¯†åˆ«æ˜¯å°†æ–‡æœ¬ä¸­çš„å…ƒç´ åˆ†æˆé¢„å…ˆå®šä¹‰çš„ç±»ï¼Œå¦‚äººåã€åœ°åã€ æœºæž„åã€æ—¶é—´ã€è´§å¸ç­‰ç­‰ã€‚ä½œä¸ºè‡ªç„¶è¯­è¨€çš„æ‰¿è½½ä¿¡æ¯å•ä½ï¼Œå‘½åå®žä½“è¯†åˆ« å±žäºŽæ–‡æœ¬ä¿¡æ¯å¤„ç†çš„åŸºç¡€çš„ç ”ç©¶é¢†åŸŸï¼Œæ˜¯ä¿¡æ¯æŠ½å–ã€ä¿¡æ¯æ£€ç´¢ã€æœºå™¨ç¿»è¯‘ã€ é—®ç­”ç³»ç»Ÿç­‰å¤šç§è‡ªç„¶è¯­è¨€å¤„ç†æŠ€æœ¯ä¸­å¿…ä¸å¯å°‘çš„ç»„æˆéƒ¨åˆ†ã€‚ å‘½åå®žä½“è¯†åˆ«ä¸»è¦åˆ†ç±»ï¼Œä¸€èˆ¬åŒ…æ‹¬ 3 å¤§ç±»ï¼ˆå®žä½“ç±»ã€æ—¶é—´ç±»å’Œæ•°å­—ç±»ï¼‰å’Œ 7 å°ç±»ï¼ˆäººåã€åœ°åã€ç»„ç»‡åã€æœºæž„åã€æ—¶é—´ã€æ—¥æœŸã€è´§å¸å’Œç™¾åˆ†æ¯”ï¼‰ã€‚ä½†éšç€ NLP ä»»åŠ¡çš„ä¸æ–­æ‰©å……ï¼Œåœ¨ç‰¹å®šé¢†åŸŸä¸­ä¼šå‡ºçŽ°ç‰¹å®šçš„ç±»åˆ«ï¼Œæ¯”å¦‚åŒ»è¯é¢†åŸŸä¸­ï¼Œè¯åã€ç–¾ç—…ç­‰ç±»åˆ«ã€‚ ä¸»æµçš„æ–¹æ³•ï¼š è¿™ä¸ªæ˜¯ä¹‹å‰ä¸€ä¸ªäººå›žç­”çš„ï¼Œå¤§æ¦‚è°ˆäº†NER ä¸­æ¨¡åž‹å‘å±•çš„åŽ†å²ï¼šæœ‰ä¸€äº›ï¼Œå¤§è‡´å¦‚ä¸‹ï¼šMLP-&gt;LSTM-&gt;LSTM/CNN+CRF-&gt;BiLSTM+CRF- &gt;BiLSTM+CNN+CRFã€‚æåˆ°æŠ€æœ¯ï¼Œæ˜¯ä¸æ˜¯å¤§å®¶éƒ½æ˜¯ç”¨çš„ CRFï¼Œé™¤äº†ç›®å‰æœ€æ–°çš„æ·±åº¦å­¦ä¹ ã€‚ï¼ˆCRF+ æ·±åº¦å­¦ä¹ ï¼‰ è¯æ€§éœ€è¦æœ‰ä¸€å®šçš„è§„èŒƒï¼Œå¦‚å°†è¯åˆ†ä¸ºåè¯ã€å½¢å®¹è¯ã€åŠ¨è¯ï¼Œç„¶åŽç”¨â€™nâ€™ â€˜adjâ€™ â€˜vâ€™æ¥è¡¨ç¤ºã€‚åŒ—å¤§è¯æ€§æ ‡æ³¨é›†éƒ¨åˆ†æ ‡æ³¨è¯æ€§å¦‚ä¸‹è¡¨æ‰€ç¤ºï¼š 123456789101112131415161718192021222324252627282930313233343536373839Ag å½¢è¯­ç´  å½¢å®¹è¯æ€§è¯­ç´ ã€‚å½¢å®¹è¯ä»£ç ä¸ºaï¼Œè¯­ç´ ä»£ç ï½‡å‰é¢ç½®ä»¥Aã€‚ a å½¢å®¹è¯ å–è‹±è¯­å½¢å®¹è¯adjectiveçš„ç¬¬1ä¸ªå­—æ¯ã€‚ ad å‰¯å½¢è¯ ç›´æŽ¥ä½œçŠ¶è¯­çš„å½¢å®¹è¯ã€‚å½¢å®¹è¯ä»£ç aå’Œå‰¯è¯ä»£ç då¹¶åœ¨ä¸€èµ·ã€‚ an åå½¢è¯ å…·æœ‰åè¯åŠŸèƒ½çš„å½¢å®¹è¯ã€‚å½¢å®¹è¯ä»£ç aå’Œåè¯ä»£ç nå¹¶åœ¨ä¸€èµ·ã€‚ b åŒºåˆ«è¯ å–æ±‰å­—â€œåˆ«â€çš„å£°æ¯ã€‚ c è¿žè¯ å–è‹±è¯­è¿žè¯conjunctionçš„ç¬¬1ä¸ªå­—æ¯ã€‚ Dg å‰¯è¯­ç´  å‰¯è¯æ€§è¯­ç´ ã€‚å‰¯è¯ä»£ç ä¸ºdï¼Œè¯­ç´ ä»£ç ï½‡å‰é¢ç½®ä»¥Dã€‚ d å‰¯è¯ å–adverbçš„ç¬¬2ä¸ªå­—æ¯ï¼Œå› å…¶ç¬¬1ä¸ªå­—æ¯å·²ç”¨äºŽå½¢å®¹è¯ã€‚ e å¹è¯ å–è‹±è¯­å¹è¯exclamationçš„ç¬¬1ä¸ªå­—æ¯ã€‚ f æ–¹ä½è¯ å–æ±‰å­—â€œæ–¹â€ çš„å£°æ¯ã€‚ g è¯­ç´  ç»å¤§å¤šæ•°è¯­ç´ éƒ½èƒ½ä½œä¸ºåˆæˆè¯çš„â€œè¯æ ¹â€ï¼Œå–æ±‰å­—â€œæ ¹â€çš„å£°æ¯ã€‚ h å‰æŽ¥æˆåˆ† å–è‹±è¯­headçš„ç¬¬1ä¸ªå­—æ¯ã€‚ i æˆè¯­ å–è‹±è¯­æˆè¯­idiomçš„ç¬¬1ä¸ªå­—æ¯ã€‚ j ç®€ç§°ç•¥è¯­ å–æ±‰å­—â€œç®€â€çš„å£°æ¯ã€‚ k åŽæŽ¥æˆåˆ† l ä¹ ç”¨è¯­ ä¹ ç”¨è¯­å°šæœªæˆä¸ºæˆè¯­ï¼Œæœ‰ç‚¹â€œä¸´æ—¶æ€§â€ï¼Œå–â€œä¸´â€çš„å£°æ¯ã€‚ m æ•°è¯ å–è‹±è¯­numeralçš„ç¬¬3ä¸ªå­—æ¯ï¼Œnï¼Œuå·²æœ‰ä»–ç”¨ã€‚ Ng åè¯­ç´  åè¯æ€§è¯­ç´ ã€‚åè¯ä»£ç ä¸ºnï¼Œè¯­ç´ ä»£ç ï½‡å‰é¢ç½®ä»¥Nã€‚ n åè¯ å–è‹±è¯­åè¯nounçš„ç¬¬1ä¸ªå­—æ¯ã€‚ nr äººå åè¯ä»£ç nå’Œâ€œäºº(ren)â€çš„å£°æ¯å¹¶åœ¨ä¸€èµ·ã€‚ ns åœ°å åè¯ä»£ç nå’Œå¤„æ‰€è¯ä»£ç så¹¶åœ¨ä¸€èµ·ã€‚ nt æœºæž„å›¢ä½“ â€œå›¢â€çš„å£°æ¯ä¸ºtï¼Œåè¯ä»£ç nå’Œtå¹¶åœ¨ä¸€èµ·ã€‚ nz å…¶ä»–ä¸“å â€œä¸“â€çš„å£°æ¯çš„ç¬¬1ä¸ªå­—æ¯ä¸ºzï¼Œåè¯ä»£ç nå’Œzå¹¶åœ¨ä¸€èµ·ã€‚ o æ‹Ÿå£°è¯ å–è‹±è¯­æ‹Ÿå£°è¯onomatopoeiaçš„ç¬¬1ä¸ªå­—æ¯ã€‚ p ä»‹è¯ å–è‹±è¯­ä»‹è¯prepositionalçš„ç¬¬1ä¸ªå­—æ¯ã€‚ q é‡è¯ å–è‹±è¯­quantityçš„ç¬¬1ä¸ªå­—æ¯ã€‚ r ä»£è¯ å–è‹±è¯­ä»£è¯pronounçš„ç¬¬2ä¸ªå­—æ¯,å› på·²ç”¨äºŽä»‹è¯ã€‚ s å¤„æ‰€è¯ å–è‹±è¯­spaceçš„ç¬¬1ä¸ªå­—æ¯ã€‚ Tg æ—¶è¯­ç´  æ—¶é—´è¯æ€§è¯­ç´ ã€‚æ—¶é—´è¯ä»£ç ä¸ºt,åœ¨è¯­ç´ çš„ä»£ç gå‰é¢ç½®ä»¥Tã€‚ t æ—¶é—´è¯ å–è‹±è¯­timeçš„ç¬¬1ä¸ªå­—æ¯ã€‚ u åŠ©è¯ å–è‹±è¯­åŠ©è¯auxiliary çš„ç¬¬2ä¸ªå­—æ¯,å› aå·²ç”¨äºŽå½¢å®¹è¯ã€‚ Vg åŠ¨è¯­ç´  åŠ¨è¯æ€§è¯­ç´ ã€‚åŠ¨è¯ä»£ç ä¸ºvã€‚åœ¨è¯­ç´ çš„ä»£ç gå‰é¢ç½®ä»¥Vã€‚ v åŠ¨è¯ å–è‹±è¯­åŠ¨è¯verbçš„ç¬¬ä¸€ä¸ªå­—æ¯ã€‚ vd å‰¯åŠ¨è¯ ç›´æŽ¥ä½œçŠ¶è¯­çš„åŠ¨è¯ã€‚åŠ¨è¯å’Œå‰¯è¯çš„ä»£ç å¹¶åœ¨ä¸€èµ·ã€‚ vn ååŠ¨è¯ æŒ‡å…·æœ‰åè¯åŠŸèƒ½çš„åŠ¨è¯ã€‚åŠ¨è¯å’Œåè¯çš„ä»£ç å¹¶åœ¨ä¸€èµ·ã€‚ w æ ‡ç‚¹ç¬¦å· x éžè¯­ç´ å­— éžè¯­ç´ å­—åªæ˜¯ä¸€ä¸ªç¬¦å·ï¼Œå­—æ¯xé€šå¸¸ç”¨äºŽä»£è¡¨æœªçŸ¥æ•°ã€ç¬¦å·ã€‚ y è¯­æ°”è¯ å–æ±‰å­—â€œè¯­â€çš„å£°æ¯ã€‚ z çŠ¶æ€è¯ å–æ±‰å­—â€œçŠ¶â€çš„å£°æ¯çš„å‰ä¸€ä¸ªå­—æ¯ã€‚ NER çš„åº”ç”¨åœºæ™¯ï¼š æ–°é—»æ ‡æ³¨ï¼šå’Œæ–‡æœ¬åˆ†ç±»ä¸åŒ, è¿™é‡Œå¯ä»¥ä½¿ç”¨NERæŠ€æœ¯å°†ä¸Žæ–‡ç« ç›¸å…³çš„äººç‰©, åœ°ç‚¹éƒ½ä»¥æ ‡ç­¾çš„å½¢å¼æ ‡æ³¨å‡ºæ¥, æ–¹ä¾¿ç”¨æˆ·å¯¹æŸä¸ªäººç‰©æˆ–åœ°ç‚¹è¿›è¡Œç´¢å¼•ã€‚ æœç´¢å¼•æ“Žï¼šå¯ä»¥é€šè¿‡ä½¿ç”¨å‘½åå®žä½“è¯†åˆ«æ¥æŠ½å–webé¡µé¢ä¸­çš„å®žä½“, åŽç»­å¯ä»¥ä½¿ç”¨è¿™äº›ä¿¡æ¯æ¥æé«˜æœç´¢æ•ˆçŽ‡å’Œå‡†ç¡®åº¦ã€‚ ä»Žå•†å“æè¿°ä¸­è‡ªåŠ¨æå–å•†å“ç±»åˆ«, å“ç‰Œç­‰ä¿¡æ¯, æé«˜è´§ç‰©ä¸Šæž¶æ•ˆçŽ‡, åœ¨å’¸é±¼ç­‰åº”ç”¨ä¸Šå·²ç»å®žçŽ°äº†ç±»ä¼¼åŠŸèƒ½ã€‚ å·¥å…·æ˜“ç”¨æ€§æå‡, ä¾‹å¦‚ä»ŽçŸ­ä¿¡æ¯æˆ–é‚®ä»¶ä¸­æå–æ—¶é—´å’Œåœ°ç‚¹ç­‰å®žä½“, ä»Žè€Œå®žçŽ°ç‚¹å‡»æ—¶é—´ç›´æŽ¥åˆ›å»ºæ—¥åŽ†, ç‚¹å‡»åœ°å€ç›´æŽ¥è·³è½¬åˆ°åœ°å›¾Appç­‰ä¾¿æ·æ“ä½œã€‚ ä¸€èˆ¬æ¥è¯´ NER æ˜¯ä¸ä½¿ç”¨åœ¨æ–‡æœ¬åˆ†ç±»é¢†åŸŸçš„ã€‚ è§†é¢‘è®²è§£ HMMä¸ŽCRFéšå½¢é©¬å°”å¯å¤«é“¾ä¸Žæ¡ä»¶éšæœºåœº-attention is all you need CRF (conditional random field )å®šä¹‰å’ŒintuitionCRF åˆ©ç”¨äº†label (åœ¨HMM ä¸­çš„hidden layer) çš„ä¿¡æ¯ï¼Œå› ä¸ºä¸Šä¸€ä¸ªæ ‡ç­¾æ˜¯æœ‰åŠ©äºŽä¸‹ä¸€ä¸ªæ ‡ç­¾çš„é¢„æµ‹ã€‚æ¯”å¦‚ä¸Šä¸€ä¸ªæ˜¯åŠ¨è¯ï¼Œé‚£ä¹ˆä¸‹ä¸€ä¸ªè¯è¯­çš„label ä¹Ÿæ˜¯åŠ¨è¯çš„æ¦‚çŽ‡æ˜¯éžå¸¸å°çš„ã€‚ we should incorporate the labels of nearby photos, and this is precisely what a conditional random field does. ç‰¹å¾å‡½æ•° ç‰¹å¾å‡½æ•°çš„è¾“å…¥ï¼š a sentence s the position $i $of a word in the sentence the label $l_i$ of the current word the label $l_iâˆ’1$ of the previous word è¿™é‡Œçº¦æŸçš„æ˜¯ linear-chain CRF (Note: by restricting our features to depend on only the current and previous labels, rather than arbitrary labels throughout the sentence, Iâ€™m actually building the special case of a linear-chain CRF. For simplicity, Iâ€™m going to ignore general CRFs in this post.) ç‰¹å¾çš„æ¦‚çŽ‡ è®¡ç®—æŸä¸ª feature functionçš„æ¡ä»¶ä¸‹å¾—åˆ°çš„scoreï¼š$$score (l | s)=\sum_{j=1}^{m} \sum_{i=1}^{n} \lambda_{j} f_{j}\left(s, i, l_{i}, l_{i-1}\right)$$ æ­£åˆ™åŒ–åˆ°åŒºé—´ $[0, 1]$$$p(l | s)=\frac{\exp [ {scorells})]}{\sum_{l^{\prime}} \exp \left[\operatorname{score}\left(l^{\prime} | s\right)\right]}=\frac{\exp \left[\sum_{j=1}^{m} \sum_{i=1}^{n} \lambda_{i} f_{j}\left(s, i, l_{i-1}\right)\right]}{\sum_{l^{\prime}} \exp \left[\sum_{j=1}^{m} \sum_{i=1}^{n} \lambda_{i} f_{j}\left(s, i_{l}^{\prime} l_{i-1}^{\prime}\right)\right]}$$ feature functionsä¾‹å­ï¼ˆè¿™ä¸ªå°±ç±»ä¼¼äººå·¥çš„æå–ç‰¹å¾ï¼‰ $f1(s,i,l_i,l_{iâˆ’1})=1 $if$ l_i= ADVERB $and the ith word ends in â€œ-lyâ€; 0 otherwise. ** If the weight Î»1 associated with this feature is large and positive, then this feature is essentially saying that we prefer labelings where words ending in -ly get labeled as ADVERB.å¦‚æžœä»¥ -ly ç»“å°¾ï¼Œå¹¶ä¸”æƒé‡æ¯”è¾ƒå¤§ï¼Œé‚£ä¹ˆå°±æ˜¯ adj å¦‚æžœå¥å­çš„ç»“å°¾æ˜¯ ?ï¼Œé‚£ä¹ˆå¼€å¤´çš„å•è¯å°±å¯èƒ½æ˜¯ä¸€ä¸ªåŠ¨è¯ å’Œ HMM çš„æ¯”è¾ƒ CRF æ›´åŠ å¼ºå¤§ï¼Œä»»ä½•ä¸€ä¸ª HMM éƒ½æ˜¯å¯ä»¥çœ‹åšæ˜¯æŸä¸ª CRFã€‚è¿™ä¸ªæ˜¯å› ä¸ºï¼š CRFs can define a much larger set of features. CRFs can have arbitrary weights. learning weights å½“ç„¶æ˜¯ä½¿ç”¨ gradient descent çš„æ€æƒ³ã€‚ Finding the optimal labeling å’ŒHMM ä¸€æ ·ï¼Œ ä½¿ç”¨ Viterbi algorithmã€‚ ç†è®ºè®²è§£Introduction to Conditional Random Fields To identify entities in text, one must be able to identify the pattern. For example, if we need to identify the claim number, we can look at the words around it such as â€œmy id isâ€ or â€œmy number isâ€, etc. Let us examine a few approaches mentioned below for identifying the patterns. Regular expressions: Regular expressions (RegEx) are a form of finite state automaton. They are very helpful in identifying patterns that follow a certain structure. For example, email ID, phone number, etc. can be identified well using RegEx. However, the downside of this approach is that one needs to be aware of all the possible exact words that occur before the claim number. This is not a learning approach, but rather a brute force one Hidden Markov Model (HMM): This is a sequence modelling algorithm that identifies and learns the pattern. Although HMM considers the future observations around the entities for learning a pattern, it assumes that the features are independent of each other. This approach is better than regular expressions as we do not need to model the exact set of word(s). But in terms of performance, it is not known to be the best method for entity recognition MaxEnt Markov Model (MEMM): This is also a sequence modelling algorithm. This does not assume that features are independent of each other and also does not consider future observations for learning the pattern. In terms of performance, it is not known to be the best method for identifying entity relationships either Conditional Random Fields (CRF): This is also a sequence modelling algorithm. This not only assumes that features are dependent on each other, but also considers the future observations while learning a pattern. This combines the best of both HMM and MEMM. In terms of performance, it is considered to be the best method for entity recognition problem The bag of words (BoW) approach works well for multiple text classification problems. This approach assumes that presence or absence of word(s) matter more than the sequence of the words. However, there are problems such as entity recognition, part of speech identification where word sequences matter as much, if not more. Conditional Random Fields (CRF) comes to the rescue here as it uses word sequences as opposed to just words. Broadly speaking, there are 2 components to the CRF formula: Normalization: You may have observed that there are no probabilities on the right side of the equation where we have the weights and features. However, the output is expected to be a probability and hence there is a need for normalization. The normalization constant Z(x) is a sum of all possible state sequences such that the total becomes 1. You can find more details in the reference section of this article to understand how we arrived at this value. Weights and Features: This component can be thought of as the logistic regression formula with weights and the corresponding features. The weight estimation is performed by maximum likelihood estimation and the features are defined by us. Complete tutorial on Text Classification using Conditional Random Fields Model (in Python) å‘å±•çš„è„‰ç»œ éšé©¬å°”å¯å¤«æ¨¡åž‹ï¼ˆHidden Markov Modelï¼ŒHMMï¼‰ NERæœ¬è´¨ä¸Šå¯ä»¥çœ‹æˆæ˜¯ä¸€ç§åºåˆ—æ ‡æ³¨é—®é¢˜ï¼ˆé¢„æµ‹æ¯ä¸ªå­—çš„BIOESæ ‡è®°ï¼‰ï¼Œåœ¨ä½¿ç”¨HMMè§£å†³NERè¿™ç§åºåˆ—æ ‡æ³¨é—®é¢˜çš„æ—¶å€™ï¼Œæˆ‘ä»¬æ‰€èƒ½è§‚æµ‹åˆ°çš„æ˜¯å­—ç»„æˆçš„åºåˆ—ï¼ˆè§‚æµ‹åºåˆ—ï¼‰ï¼Œè§‚æµ‹ä¸åˆ°çš„æ˜¯æ¯ä¸ªå­—å¯¹åº”çš„æ ‡æ³¨ï¼ˆçŠ¶æ€åºåˆ—ï¼‰ã€‚ è§£ç é—®é¢˜ï¼Œæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯ç»´ç‰¹æ¯”ï¼ˆviterbiï¼‰ç®—æ³•ã€‚ æ¡ä»¶éšæœºåœºï¼ˆConditional Random Field, CRF) ä¸Šé¢è®²çš„HMMæ¨¡åž‹ä¸­å­˜åœ¨ä¸¤ä¸ªå‡è®¾ï¼Œä¸€æ˜¯è¾“å‡ºè§‚å¯Ÿå€¼ä¹‹é—´ä¸¥æ ¼ç‹¬ç«‹ï¼ŒäºŒæ˜¯çŠ¶æ€è½¬ç§»è¿‡ç¨‹ä¸­å½“å‰çŠ¶æ€åªä¸Žå‰ä¸€çŠ¶æ€æœ‰å…³ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨å‘½åå®žä½“è¯†åˆ«çš„åœºæ™¯ä¸‹ï¼ŒHMMè®¤ä¸ºè§‚æµ‹åˆ°çš„å¥å­ä¸­çš„æ¯ä¸ªå­—éƒ½æ˜¯ç›¸äº’ç‹¬ç«‹çš„ï¼Œè€Œä¸”å½“å‰æ—¶åˆ»çš„æ ‡æ³¨åªä¸Žå‰ä¸€æ—¶åˆ»çš„æ ‡æ³¨ç›¸å…³ã€‚ä½†å®žé™…ä¸Šï¼Œå‘½åå®žä½“è¯†åˆ«å¾€å¾€éœ€è¦æ›´å¤šçš„ç‰¹å¾ï¼Œæ¯”å¦‚è¯æ€§ï¼Œè¯çš„ä¸Šä¸‹æ–‡ç­‰ç­‰ï¼ŒåŒæ—¶å½“å‰æ—¶åˆ»çš„æ ‡æ³¨åº”è¯¥ä¸Žå‰ä¸€æ—¶åˆ»ä»¥åŠåŽä¸€æ—¶åˆ»çš„æ ‡æ³¨éƒ½ç›¸å…³è”ã€‚ç”±äºŽè¿™ä¸¤ä¸ªå‡è®¾çš„å­˜åœ¨ï¼Œæ˜¾ç„¶HMMæ¨¡åž‹åœ¨è§£å†³å‘½åå®žä½“è¯†åˆ«çš„é—®é¢˜ä¸Šæ˜¯å­˜åœ¨ç¼ºé™·çš„ã€‚ è€Œæ¡ä»¶éšæœºåœºå°±æ²¡æœ‰è¿™ç§é—®é¢˜ï¼Œå®ƒé€šè¿‡å¼•å…¥è‡ªå®šä¹‰çš„ç‰¹å¾å‡½æ•°ï¼Œä¸ä»…å¯ä»¥è¡¨è¾¾è§‚æµ‹ä¹‹é—´çš„ä¾èµ–ï¼Œè¿˜å¯è¡¨ç¤ºå½“å‰è§‚æµ‹ä¸Žå‰åŽå¤šä¸ªçŠ¶æ€ä¹‹é—´çš„å¤æ‚ä¾èµ–ï¼Œå¯ä»¥æœ‰æ•ˆå…‹æœHMMæ¨¡åž‹é¢ä¸´çš„é—®é¢˜ã€‚ è§£ç çš„æ—¶å€™ä¸ŽHMMç±»ä¼¼ï¼Œä¹Ÿå¯ä»¥é‡‡ç”¨ç»´ç‰¹æ¯”ç®—æ³•ã€‚ Bi-LSTM é™¤äº†ä»¥ä¸Šä¸¤ç§åŸºäºŽæ¦‚çŽ‡å›¾æ¨¡åž‹çš„æ–¹æ³•ï¼ŒLSTMä¹Ÿå¸¸å¸¸è¢«ç”¨æ¥è§£å†³åºåˆ—æ ‡æ³¨é—®é¢˜ã€‚å’ŒHMMã€CRFä¸åŒçš„æ˜¯ï¼ŒLSTMæ˜¯ä¾é ç¥žç»ç½‘ç»œè¶…å¼ºçš„éžçº¿æ€§æ‹Ÿåˆèƒ½åŠ›ï¼Œåœ¨è®­ç»ƒæ—¶å°†æ ·æœ¬é€šè¿‡é«˜ç»´ç©ºé—´ä¸­çš„å¤æ‚éžçº¿æ€§å˜æ¢ï¼Œå­¦ä¹ åˆ°ä»Žæ ·æœ¬åˆ°æ ‡æ³¨çš„å‡½æ•°ï¼Œä¹‹åŽä½¿ç”¨è¿™ä¸ªå‡½æ•°ä¸ºæŒ‡å®šçš„æ ·æœ¬é¢„æµ‹æ¯ä¸ªtokençš„æ ‡æ³¨ã€‚ LSTMæ¯”èµ·CRFæ¨¡åž‹æœ€å¤§çš„å¥½å¤„å°±æ˜¯ç®€å•ç²—æš´ï¼Œä¸éœ€è¦åšç¹æ‚çš„ç‰¹å¾å·¥ç¨‹ï¼Œç›´æŽ¥è®­ç»ƒå³å¯ï¼ŒåŒæ—¶æ¯”èµ·HMMï¼ŒLSTMçš„å‡†ç¡®çŽ‡ä¹Ÿæ¯”è¾ƒé«˜ã€‚ Bi-LSTM+CRF ç®€å•çš„LSTMçš„ä¼˜ç‚¹æ˜¯èƒ½å¤Ÿé€šè¿‡åŒå‘çš„è®¾ç½®å­¦ä¹ åˆ°è§‚æµ‹åºåˆ—ï¼ˆè¾“å…¥çš„å­—ï¼‰ä¹‹é—´çš„ä¾èµ–ï¼Œåœ¨è®­ç»ƒè¿‡ç¨‹ä¸­ï¼ŒLSTMèƒ½å¤Ÿæ ¹æ®ç›®æ ‡ï¼ˆæ¯”å¦‚è¯†åˆ«å®žä½“ï¼‰è‡ªåŠ¨æå–è§‚æµ‹åºåˆ—çš„ç‰¹å¾ï¼Œä½†æ˜¯ç¼ºç‚¹æ˜¯æ— æ³•å­¦ä¹ åˆ°çŠ¶æ€åºåˆ—ï¼ˆè¾“å‡ºçš„æ ‡æ³¨ï¼‰ä¹‹é—´çš„å…³ç³»ï¼Œè¦çŸ¥é“ï¼Œåœ¨å‘½åå®žä½“è¯†åˆ«ä»»åŠ¡ä¸­ï¼Œæ ‡æ³¨ä¹‹é—´æ˜¯æœ‰ä¸€å®šçš„å…³ç³»çš„ï¼Œæ¯”å¦‚Bç±»æ ‡æ³¨ï¼ˆè¡¨ç¤ºæŸå®žä½“çš„å¼€å¤´ï¼‰åŽé¢ä¸ä¼šå†æŽ¥ä¸€ä¸ªBç±»æ ‡æ³¨ï¼Œæ‰€ä»¥LSTMåœ¨è§£å†³NERè¿™ç±»åºåˆ—æ ‡æ³¨ä»»åŠ¡æ—¶ï¼Œè™½ç„¶å¯ä»¥çœåŽ»å¾ˆç¹æ‚çš„ç‰¹å¾å·¥ç¨‹ï¼Œä½†æ˜¯ä¹Ÿå­˜åœ¨æ— æ³•å­¦ä¹ åˆ°æ ‡æ³¨ä¸Šä¸‹æ–‡çš„ç¼ºç‚¹ã€‚ ç›¸åï¼ŒCRFçš„ä¼˜ç‚¹å°±æ˜¯èƒ½å¯¹éšå«çŠ¶æ€å»ºæ¨¡ï¼Œå­¦ä¹ çŠ¶æ€åºåˆ—çš„ç‰¹ç‚¹ï¼Œä½†å®ƒçš„ç¼ºç‚¹æ˜¯éœ€è¦æ‰‹åŠ¨æå–åºåˆ—ç‰¹å¾ã€‚æ‰€ä»¥ä¸€èˆ¬çš„åšæ³•æ˜¯ï¼Œåœ¨LSTMåŽé¢å†åŠ ä¸€å±‚CRFï¼Œä»¥èŽ·å¾—ä¸¤è€…çš„ä¼˜ç‚¹ã€‚ NLPå®žæˆ˜-ä¸­æ–‡å‘½åå®žä½“è¯†åˆ«]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>hmm</tag>
        <tag>crf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LSTM]]></title>
    <url>%2F2019%2F05%2F04%2Flstm%2F</url>
    <content type="text"><![CDATA[ä¸»è¦ä»‹ç» LSTM çš„æ¦‚å¿µå’Œç½‘ç»œç»“æž„ã€‚ å¾ªçŽ¯ç¥žç»ç½‘ç»œ(RNN)ä¸€ä¸ªRNNå¯ä»¥çœ‹ä½œæ˜¯åŒä¸€ä¸ªç½‘ç»œçš„å¤šä»½å‰¯æœ¬ï¼Œæ¯ä¸€ä»½éƒ½å°†ä¿¡æ¯ä¼ é€’åˆ°ä¸‹ä¸€ä¸ªå‰¯æœ¬ã€‚å¦‚æžœæˆ‘ä»¬å°†çŽ¯å±•å¼€çš„è¯ï¼š è¿™ç§é“¾å¼ç»“æž„å±•ç¤ºäº†RNNä¸Žåºåˆ—å’Œåˆ—è¡¨çš„å¯†åˆ‡å…³ç³»ã€‚RNNçš„è¿™ç§ç»“æž„èƒ½å¤Ÿéžå¸¸è‡ªç„¶åœ°ä½¿ç”¨è¿™ç±»æ•°æ®ã€‚ RNN çš„ä¸»è¦åº”ç”¨å¦‚ä¸‹ï¼š æ–‡æœ¬ç›¸å…³ã€‚ä¸»è¦åº”ç”¨åœ¨è‡ªç„¶è¯­è¨€å¤„ç†æ–¹é¢ï¼ˆNLPï¼‰ã€å¯¹è¯ç³»ç»Ÿã€æƒ…æ„Ÿåˆ†æžã€æœºå™¨ç¿»è¯‘ æ—¶åºç›¸å…³ã€‚å°±æ˜¯åœ¨åšæ—¶åºé¢„æµ‹é—®é¢˜ï¼Œæ¯”å¦‚é¢„æµ‹å¤©æ°”ã€æ¸©åº¦ï¼ŒåŒ…æ‹¬æœ‰å¾ˆå¤šäººä½¿ç”¨å…¶åœ¨åšé¢„æµ‹è‚¡ç¥¨ä»·æ ¼çš„é—®é¢˜ é•¿æœŸä¾èµ–(Long Term Dependencies)çš„é—®é¢˜å¯¹äºŽRNN æ¥è¯´ï¼Œå¯ä»¥å¤„ç†éžå¸¸çŸ­çš„æ–‡æœ¬åºåˆ—ï¼ˆæ¯”å¦‚ä¸‹æ–‡ç¬¬ä¸€ç§æƒ…å†µï¼‰ä½†æ˜¯ä¸å¯ä»¥å¤„ç†æ¯”è¾ƒé•¿çš„åºåˆ—ï¼ˆæ¯”å¦‚ä¸‹æ–‡ç¬¬äºŒç§æƒ…å†µï¼‰ æœ‰æ—¶å€™ï¼Œæˆ‘ä»¬åªéœ€è¦çœ‹æœ€è¿‘çš„ä¿¡æ¯ï¼Œå°±å¯ä»¥å®Œæˆå½“å‰çš„ä»»åŠ¡ã€‚æ¯”å¦‚ï¼Œè€ƒè™‘ä¸€ä¸ªè¯­è¨€æ¨¡åž‹ï¼Œé€šè¿‡å‰é¢çš„å•è¯æ¥é¢„æµ‹æŽ¥ä¸‹æ¥çš„å•è¯ã€‚å¦‚æžœæˆ‘ä»¬æƒ³é¢„æµ‹å¥å­â€œthe clouds are in the skyâ€ä¸­çš„æœ€åŽä¸€ä¸ªå•è¯ï¼Œæˆ‘ä»¬ä¸éœ€è¦æ›´å¤šçš„ä¸Šä¸‹æ–‡ä¿¡æ¯â€”â€”å¾ˆæ˜Žæ˜¾ä¸‹ä¸€ä¸ªå•è¯åº”è¯¥æ˜¯skyã€‚ RNN æ˜¯å¯ä»¥è¢«ç”¨æ¥è¿›è¡Œè¿™æ ·é—®é¢˜çš„è®­ç»ƒå­¦ä¹ ã€‚ ç„¶è€Œï¼Œæœ‰æ—¶å€™æˆ‘ä»¬éœ€è¦æ›´å¤šçš„ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚æ¯”å¦‚ï¼Œæˆ‘ä»¬æƒ³é¢„æµ‹å¥å­â€œI grew up in Franceâ€¦ I speak fluent Frenchâ€ä¸­çš„æœ€åŽä¸€ä¸ªå•è¯ã€‚ä¸å¹¸çš„æ˜¯ï¼Œéšç€è·ç¦»çš„å¢žå¤§ï¼ŒRNNå¯¹äºŽå¦‚ä½•å°†è¿™æ ·çš„ä¿¡æ¯è¿žæŽ¥èµ·æ¥æ— èƒ½ä¸ºåŠ›ã€‚ LSTM ä¸­çš„åŸºæœ¬æ¦‚å¿µLSTM æ˜¯ç”¨æ¥è§£å†³RNN ä¸­çš„æ¢¯åº¦æ¶ˆå¤±/ æ¢¯åº¦çˆ†ç‚¸é—®é¢˜çš„ï¼Œå¯ä»¥å¤„ç† long-term sequenceäº†ã€‚ é—¨ï¼ˆgate ï¼‰å®šä¹‰ï¼š gate å®žé™…ä¸Šå°±æ˜¯ä¸€å±‚å…¨è¿žæŽ¥å±‚ï¼Œè¾“å…¥æ˜¯ä¸€ä¸ªå‘é‡ï¼Œè¾“å‡ºæ˜¯ä¸€ä¸ª 0åˆ°1 ä¹‹é—´çš„å®žæ•°å‘é‡ã€‚å…¬å¼å¦‚ä¸‹ï¼š$$g ( \mathbf { x } ) = \sigma ( W \mathbf { x } + \mathbf { b } )$$ é—å¿˜é—¨ï¼ˆforget gateï¼‰å®ƒå†³å®šäº†ä¸Šä¸€æ—¶åˆ»çš„å•å…ƒçŠ¶æ€ $c_{t-1} $æœ‰å¤šå°‘ä¿ç•™åˆ°å½“å‰æ—¶åˆ»$ c_t$è¾“å…¥é—¨ï¼ˆinput gateï¼‰å®ƒå†³å®šäº†å½“å‰æ—¶åˆ»ç½‘ç»œçš„è¾“å…¥ $x_t$ æœ‰å¤šå°‘ä¿å­˜åˆ°å•å…ƒçŠ¶æ€ $c_t$è¾“å‡ºé—¨ï¼ˆoutput gateï¼‰æŽ§åˆ¶å•å…ƒçŠ¶æ€$ c_t $æœ‰å¤šå°‘è¾“å‡ºåˆ° LSTM çš„å½“å‰è¾“å‡ºå€¼ $h_t$ LSTMç½‘ç»œåœ¨æ™®é€šçš„RNNä¸­ï¼Œé‡å¤æ¨¡å—ç»“æž„éžå¸¸ç®€å•ï¼Œä¾‹å¦‚åªæœ‰ä¸€ä¸ªtanhå±‚ã€‚ LSTMä¹Ÿæœ‰è¿™ç§é“¾çŠ¶ç»“æž„ï¼Œä¸è¿‡å…¶é‡å¤æ¨¡å—çš„ç»“æž„ä¸åŒã€‚LSTMçš„é‡å¤æ¨¡å—ä¸­æœ‰4ä¸ªç¥žç»ç½‘ç»œå±‚ï¼Œå¹¶ä¸”ä»–ä»¬ä¹‹é—´çš„äº¤äº’éžå¸¸ç‰¹åˆ«ã€‚ LSTMåˆ†æ­¥è¯¦è§£LSTMçš„ç¬¬ä¸€æ­¥æ˜¯å†³å®šæˆ‘ä»¬å°†è¦ä»Žå…ƒèƒžçŠ¶æ€ä¸­æ‰”æŽ‰å“ªäº›ä¿¡æ¯ã€‚é—å¿˜é—¨è§‚å¯Ÿ$h_{tâˆ’1}$å’Œ $x_t$ï¼Œå¯¹äºŽå…ƒèƒžçŠ¶æ€ $C_{tâˆ’1} $ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ ï¼Œè¾“å‡ºä¸€ä¸ª0-1ä¹‹é—´çš„æ•°ã€‚1è¡¨ç¤ºâ€œå®Œå…¨ä¿ç•™è¯¥ä¿¡æ¯â€ï¼Œ0è¡¨ç¤ºâ€œå®Œå…¨ä¸¢å¼ƒè¯¥ä¿¡æ¯â€ã€‚ ä¸‹ä¸€æ­¥æ˜¯å†³å®šæˆ‘ä»¬å°†ä¼šæŠŠå“ªäº›æ–°ä¿¡æ¯å­˜å‚¨åˆ°å…ƒèƒžçŠ¶æ€ä¸­ã€‚è¿™æ­¥åˆ†ä¸ºä¸¤éƒ¨åˆ†ã€‚é¦–å…ˆï¼Œæœ‰ä¸€ä¸ªå«åšâ€œè¾“å…¥é—¨(Input Gate)â€çš„Sigmoidå±‚å†³å®šæˆ‘ä»¬è¦æ›´æ–°å“ªäº›ä¿¡æ¯ã€‚æŽ¥ä¸‹æ¥ï¼Œä¸€ä¸ªtanhå±‚åˆ›é€ äº†ä¸€ä¸ªæ–°çš„å€™é€‰å€¼ï¼Œ$\tilde { C } _ { t }$ï¼Œè¯¥å€¼å¯èƒ½è¢«åŠ å…¥åˆ°å…ƒèƒžçŠ¶æ€ä¸­ã€‚åœ¨ä¸‹ä¸€æ­¥ä¸­ï¼Œæˆ‘ä»¬å°†ä¼šæŠŠè¿™ä¸¤ä¸ªå€¼ç»„åˆèµ·æ¥ç”¨äºŽæ›´æ–°å…ƒèƒžçŠ¶æ€ã€‚ çŽ°åœ¨æˆ‘ä»¬è¯¥æ›´æ–°æ—§å…ƒèƒžçŠ¶æ€ $C_{tâˆ’1} $åˆ°æ–°çŠ¶æ€ $C_t$äº†ã€‚ä¸Šé¢çš„æ­¥éª¤ä¸­å·²ç»å†³å®šäº†è¯¥æ€Žä¹ˆåšï¼Œè¿™ä¸€æ­¥æˆ‘ä»¬åªéœ€è¦å®žé™…æ‰§è¡Œå³å¯ã€‚ æœ€åŽï¼Œæˆ‘ä»¬éœ€è¦å†³å®šæœ€ç»ˆçš„è¾“å‡ºã€‚è¾“å‡ºå°†ä¼šåŸºäºŽç›®å‰çš„å…ƒèƒžçŠ¶æ€ï¼Œå¹¶ä¸”ä¼šåŠ å…¥ä¸€äº›è¿‡æ»¤ã€‚é¦–å…ˆæˆ‘ä»¬å»ºç«‹ä¸€ä¸ªSigmoidå±‚çš„è¾“å‡ºé—¨(Output Gate)ï¼Œæ¥å†³å®šæˆ‘ä»¬å°†è¾“å‡ºå…ƒèƒžçš„å“ªäº›éƒ¨åˆ†ã€‚ç„¶åŽæˆ‘ä»¬å°†å…ƒèƒžçŠ¶æ€é€šè¿‡tanhä¹‹åŽï¼ˆä½¿å¾—è¾“å‡ºå€¼åœ¨-1åˆ°1ä¹‹é—´ï¼‰ï¼Œä¸Žè¾“å‡ºé—¨ç›¸ä¹˜ï¼Œè¿™æ ·æˆ‘ä»¬åªä¼šè¾“å‡ºæˆ‘ä»¬æƒ³è¾“å‡ºçš„éƒ¨åˆ†ã€‚ ä¼˜ç‚¹ï¼š è§£å†³äº†RNN ä¸­çš„æ¢¯åº¦æ¶ˆå¤±çš„é—®é¢˜ï¼Œå¯ä»¥å¤„ç† é•¿ä¾èµ– ç¼ºç‚¹ï¼š è®¡ç®—å¤æ‚åº¦é«˜ï¼Œè¿è¡Œæ—¶é—´é•¿ LSTMä¸­å‚æ•°çš„è®¡ç®— é¦–å…ˆå‚æ•°çš„ä¸ªæ•°å’Œ æ—¶é—´steps æ— å…³ $h_t$ å’Œ $c_t$ çš„ç»´åº¦æ˜¯ç›¸åŒçš„ æ€»å…±å››ç»„ [w, b] å‚æ•° ç›´æŽ¥ç»™å‡ºå…¬å¼$$ 4(n(m +n) +n)$$å…¶ä¸­ $m$ è¡¨ç¤ºè¾“å…¥ $x$ çš„ç»´åº¦ï¼Œ $n$ è¡¨ç¤º hidden æˆ–è€…è¯´ context çš„ç»´åº¦ã€‚ $(m+n)$ è¡¨ç¤ºåœ¨å¤„ç†ä¸‹ä¸€å±‚çš„ è¾“å…¥æ—¶å€™ï¼ŒæŠŠå½“å‰å±‚æ•°æ® $x$ çš„ç»´åº¦ $m$ å’Œ hidden ä¸­ç»´åº¦ $n$ ç»™é“¾æŽ¥èµ·æ¥ï¼Œå…·ä½“å¯ä»¥çœ‹ä¸€ä¸‹ lstm ä¸­çš„ç¤ºæ„å›¾ã€‚ LSTMå‚æ•°è®¡ç®—çš„ä¾‹å­ GRUGRU (gated recurrent unit) æ˜¯å¯¹äºŽ LSTM é€Ÿåº¦ä¸Šçš„æå‡ï¼Œä½†æ˜¯ç›¸åº”çš„è¡¨è¾¾èƒ½åŠ›ä¹Ÿå—åˆ°äº†é™åˆ¶ GRU ä¸­ä¸€å…±æœ‰ä¸¤ä¸ªé—¨ã€‚GRU æŠŠLSTM ä¸­é—å¿˜é—¨(forget gate) å’Œè¾“å…¥é—¨(input gate) ä½¿ç”¨ æ›´æ–°é—¨(update gate) è¿›è¡Œä»£æ›¿ã€‚è¿˜æœ‰ä¸€ä¸ªé‡ç½®é—¨(reset gate)ï¼Œ é‡ç½®é—¨ä¸»è¦å†³å®šäº†å¤šå°‘è¿‡åŽ»çš„ä¿¡æ¯éœ€è¦é—å¿˜ã€‚GRU ä¸ä¼šä¿å­˜å†…éƒ¨è®°å¿† contextï¼Œè€Œä¸”æ²¡æœ‰è¾“å‡ºé—¨ã€‚ å¤ä¹  RNNçš„åº”ç”¨åœºæ™¯ï¼š æ–‡æœ¬ç›¸å…³å’Œæ—¶åºç›¸å…³ï¼ˆæ¯”å¦‚ é¢„æµ‹å¤©æ°”ã€æ¸©åº¦ï¼‰ LSTM ä¸»è¦æ˜¯è§£å†³RNN ä¸­çš„æ¢¯åº¦æ¶ˆå¤±/ æ¢¯åº¦çˆ†ç‚¸é—®é¢˜ï¼Œä½¿ç”¨é—å¿˜é—¨ã€è¾“å…¥é—¨ å’Œè¾“å‡ºé—¨åˆ†åˆ«æŽ§åˆ¶ä¸Šä¸€æ—¶åˆ»ä¿¡æ¯åˆ°contextçš„ä¿ç•™ç¨‹åº¦ã€å½“å‰æ—¶åˆ»è¾“å…¥åˆ°contextçš„ç¨‹åº¦å’Œcontextä¿¡æ¯è¾“å‡ºç¨‹åº¦ã€‚å¯ä»¥å¤„ç†å¸¸ä¾èµ–çš„é—®é¢˜ã€‚ LSTM ä¸­å‚æ•°çš„è®¡ç®— å‚è€ƒæ–‡çŒ®Understanding LSTM Networks]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NLP Papers Reading- BERT (***)]]></title>
    <url>%2F2019%2F04%2F27%2Fpaper-reading-bert%2F</url>
    <content type="text"><![CDATA[attention is all you needSelf-attention, sometimes called intra-attention is an attention mechanism relating different positions of a single sequence in order to compute a representation of the sequence. An attention function can be described as mapping a query and a set of key-value pairs to an output, where the query, keys, values, and output are all vectors. The output is computed as a weighted sum of the values, where the weight assigned to each value is computed cy a compatibility function of the query with the corresponding key. ä¸­æ–‡çš„ç†è§£ï¼šæ·±åº¦å­¦ä¹ é‡Œçš„Attention modelå…¶å®žæ¨¡æ‹Ÿçš„æ˜¯äººè„‘çš„æ³¨æ„åŠ›æ¨¡åž‹ï¼Œä¸¾ä¸ªä¾‹å­æ¥è¯´ï¼Œå½“æˆ‘ä»¬è§‚èµä¸€å¹…ç”»æ—¶ï¼Œè™½ç„¶æˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ•´å¹…ç”»çš„å…¨è²Œï¼Œä½†æ˜¯åœ¨æˆ‘ä»¬æ·±å…¥ä»”ç»†åœ°è§‚å¯Ÿæ—¶ï¼Œå…¶å®žçœ¼ç›èšç„¦çš„å°±åªæœ‰å¾ˆå°çš„ä¸€å—ï¼Œè¿™ä¸ªæ—¶å€™äººçš„å¤§è„‘ä¸»è¦å…³æ³¨åœ¨è¿™ä¸€å°å—å›¾æ¡ˆä¸Šï¼Œä¹Ÿå°±æ˜¯è¯´è¿™ä¸ªæ—¶å€™äººè„‘å¯¹æ•´å¹…å›¾çš„å…³æ³¨å¹¶ä¸æ˜¯å‡è¡¡çš„ï¼Œæ˜¯æœ‰ä¸€å®šçš„æƒé‡åŒºåˆ†çš„ã€‚è¿™å°±æ˜¯æ·±åº¦å­¦ä¹ é‡Œçš„AttentionModelçš„æ ¸å¿ƒæ€æƒ³ã€‚æ‰€è°“æ³¨æ„åŠ›æœºåˆ¶ï¼Œå°±æ˜¯è¯´åœ¨ç”Ÿæˆæ¯ä¸ªè¯çš„æ—¶å€™ï¼Œå¯¹ä¸åŒçš„è¾“å…¥è¯ç»™äºˆä¸åŒçš„å…³æ³¨æƒé‡ã€‚é€šè¿‡æ³¨æ„åŠ›æœºåˆ¶ï¼Œæˆ‘ä»¬å°†è¾“å…¥å¥å­ç¼–ç ä¸ºä¸€ä¸ªå‘é‡åºåˆ—ï¼Œå¹¶è‡ªé€‚åº”åœ°é€‰æ‹©è¿™äº›å‘é‡çš„ä¸€ä¸ªå­é›†ï¼ŒåŒæ—¶å¯¹è¯‘æ–‡è¿›è¡Œè¯‘ç ï¼Œä¾‹å¦‚where are youâ€”â€”&gt;ä½ åœ¨å“ªï¼ŸçŽ°åœ¨æˆ‘ä»¬åœ¨ç¿»è¯‘â€œä½ â€çš„æ—¶å€™ç»™â€youâ€æ›´å¤šçš„æƒé‡ï¼Œé‚£ä¹ˆå°±å¯ä»¥æœ‰æ•ˆçš„è§£å†³å¯¹é½é—®é¢˜ã€‚ Background: ä¸»è¦æ˜¯é¢ä¸´çš„ä¸‰ä¸ªé—®é¢˜ã€‚ Transformer çš„ç»“æž„ç¤ºæ„å›¾:(transformer å°±æ˜¯è®¨è®ºäº†å¦‚ä½•å®žçŽ°ä¸Šè¿°çš„ self-attention ç»“æž„) Encoder: encoderç”±6ä¸ªç›¸åŒçš„å±‚å †å è€Œæˆï¼Œæ¯ä¸ªå±‚æœ‰ä¸¤ä¸ªå­å±‚ã€‚ç¬¬ä¸€ä¸ªå­å±‚æ˜¯å¤šå¤´è‡ªæˆ‘æ³¨æ„åŠ›æœºåˆ¶(multi-head self-attention mechanism)ï¼Œç¬¬äºŒå±‚æ˜¯ç®€å•çš„ä½ç½®çš„å…¨è¿žæŽ¥å‰é¦ˆç½‘ç»œ(position-wise fully connected feed-forward network)ã€‚åœ¨ä¸¤ä¸ªå­å±‚ä¸­ä¼šä½¿ç”¨ä¸€ä¸ªæ®‹å·®è¿žæŽ¥ï¼ŒæŽ¥ç€è¿›è¡Œå±‚æ ‡å‡†åŒ–(layer normalization)ã€‚ä¹Ÿå°±æ˜¯è¯´æ¯ä¸€ä¸ªå­å±‚çš„è¾“å‡ºéƒ½æ˜¯LayerNorm(x + sublayer(x))ã€‚ç½‘ç»œè¾“å…¥æ˜¯ä¸‰ä¸ªç›¸åŒçš„å‘é‡q, kå’Œvï¼Œæ˜¯word embeddingå’Œposition embeddingç›¸åŠ å¾—åˆ°çš„ç»“æžœã€‚ä¸ºäº†æ–¹ä¾¿è¿›è¡Œæ®‹å·®è¿žæŽ¥ï¼Œæˆ‘ä»¬éœ€è¦å­å±‚çš„è¾“å‡ºå’Œè¾“å…¥éƒ½æ˜¯ç›¸åŒçš„ç»´åº¦ã€‚ Decoder: decoderä¹Ÿæ˜¯ç”±Nï¼ˆN=6ï¼‰ä¸ªå®Œå…¨ç›¸åŒçš„Layerç»„æˆï¼Œdecoderä¸­çš„Layerç”±encoderçš„Layerä¸­æ’å…¥ä¸€ä¸ªMulti-Head Attention + Add&amp;Normç»„æˆã€‚è¾“å‡ºçš„embeddingä¸Žè¾“å‡ºçš„position embeddingæ±‚å’Œåšä¸ºdecoderçš„è¾“å…¥ï¼Œç»è¿‡ä¸€ä¸ªMulti-HeadAttention + Add&amp;Normï¼ˆï¼ˆMA-1ï¼‰å±‚ï¼ŒMA-1å±‚çš„è¾“å‡ºåšä¸ºä¸‹ä¸€Multi-Head Attention + Add&amp;Normï¼ˆMA-2ï¼‰çš„queryï¼ˆQï¼‰è¾“å…¥ï¼ŒMA-2å±‚çš„Keyå’ŒValueè¾“å…¥ï¼ˆä»Žå›¾ä¸­çœ‹ï¼Œåº”è¯¥æ˜¯encoderä¸­ç¬¬iï¼ˆi = 1,2,3,4,5,6ï¼‰å±‚çš„è¾“å‡ºå¯¹äºŽdecoderä¸­ç¬¬iï¼ˆi = 1,2,3,4ï¼Œ5,6ï¼‰å±‚çš„è¾“å…¥ï¼‰ã€‚MA-2å±‚çš„è¾“å‡ºè¾“å…¥åˆ°ä¸€ä¸ªå‰é¦ˆå±‚ï¼ˆFFï¼‰ï¼Œç»è¿‡ANæ“ä½œåŽï¼Œç»è¿‡ä¸€ä¸ªçº¿æ€§+softmaxå˜æ¢å¾—åˆ°æœ€åŽç›®æ ‡è¾“å‡ºçš„æ¦‚çŽ‡ã€‚ å¯¹äºŽdecoderä¸­çš„ç¬¬ä¸€ä¸ªå¤šå¤´æ³¨æ„åŠ›å­å±‚ï¼Œéœ€è¦æ·»åŠ maskingï¼Œç¡®ä¿é¢„æµ‹ä½ç½®içš„æ—¶å€™ä»…ä»…ä¾èµ–äºŽä½ç½®å°äºŽiçš„è¾“å‡ºã€‚ å±‚ä¸Žå±‚ä¹‹é—´ä½¿ç”¨çš„Position-wise feed forward networkã€‚ transformer çš„ç»“æž„è°ˆåŠ transformerï¼Œé¦–å…ˆåº”è¯¥æåˆ°æ˜¯ è®¡ç®—æ•ˆçŽ‡çš„å¤§å¤§æé«˜ï¼Œä»ŽåŽŸå…ˆçš„RNN çš„çº¿æ€§O(N)æå‡çš„å¾ˆå¤šï¼Œè¿™ä¸ªçš„å®žçŽ°æ˜¯åŸºäºŽå¤šçº¿ç¨‹çš„ã€‚è€ŒåŽè€…æ˜¯å› ä¸ºæ˜¯æœ‰é¡ºåºçš„çº¿æ€§æ¨¡åž‹ï¼Œæ‰€ä»¥æ˜¯æ— æ³•ä½¿ç”¨å¹¶è¡Œè¿ç®—çš„ã€‚ å¯¹äºŽ RNN æ¥è¯´ï¼Œå¥é¦–çš„ä¿¡æ¯è¦ä¼ é€’åˆ°å¥å°¾ï¼Œéœ€è¦ç»è¿‡ n æ¬¡ RNN çš„è®¡ç®—ï¼›è€Œ Self-Attention å¯ä»¥ç›´æŽ¥è¿žæŽ¥ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹. ä»Žæ•´ä½“ä¸Šæ¥çœ‹ï¼ŒTransformerä¾æ—§æ˜¯ä¸€ä¸ªâ€œSequence to Sequenceâ€æ¡†æž¶ï¼Œæ‹¥æœ‰Encoderå’ŒDecoderä¸¤éƒ¨åˆ†ï¼š transformer çš„ç»“æž„ è®ºæ–‡ä¸­encoderå±‚ç”±6ä¸ªencoderå †å åœ¨ä¸€èµ·ï¼Œdecoderå±‚ä¹Ÿä¸€æ ·ã€‚ æ¯ä¸€ä¸ª encoder å’Œ decoder çš„å†…éƒ¨ç®€å›¾å¦‚ä¸‹ï¼š encoder éƒ¨åˆ† å¯¹äºŽencoderï¼ŒåŒ…å«ä¸¤å±‚ï¼Œä¸€ä¸ªself-attentionå±‚å’Œä¸€ä¸ªå‰é¦ˆç¥žç»ç½‘ç»œï¼Œself-attentionèƒ½å¸®åŠ©å½“å‰èŠ‚ç‚¹ä¸ä»…ä»…åªå…³æ³¨å½“å‰çš„è¯ï¼Œä»Žè€Œèƒ½èŽ·å–åˆ°ä¸Šä¸‹æ–‡çš„è¯­ä¹‰ã€‚decoderä¹ŸåŒ…å«encoderæåˆ°çš„ä¸¤å±‚ç½‘ç»œï¼Œä½†æ˜¯åœ¨è¿™ä¸¤å±‚ä¸­é—´è¿˜æœ‰ä¸€å±‚attentionå±‚ï¼Œå¸®åŠ©å½“å‰èŠ‚ç‚¹èŽ·å–åˆ°å½“å‰éœ€è¦å…³æ³¨çš„é‡ç‚¹å†…å®¹ã€‚ self-attention å…ˆè¯´ä¸€ä¸‹ attention æœºåˆ¶çš„å®žçŽ°ï¼š å½“ä½¿ç”¨ selfçš„æ—¶å€™ï¼Œquery, key and value è¿™ä¸‰ä¸ªå°±éƒ½æ˜¯ç›¸åŒçš„ã€‚ç»è¿‡softmax() å¾—åˆ°å°±æ˜¯ä¸€ä¸ªæƒé‡ï¼Œç”¨äºŽæ ‡è®°å’Œ å½“å‰å¤„ç†çš„è¯è¯­çš„å…³ç³»ã€‚self-attentionæ˜¯Transformerç”¨æ¥å°†å…¶ä»–ç›¸å…³å•è¯çš„â€œç†è§£â€è½¬æ¢æˆæˆ‘ä»¬æ­£åœ¨å¤„ç†çš„å•è¯çš„ä¸€ç§æ€è·¯ï¼Œattention å°±æ˜¯ä¸€ç§åŠ æƒå¹³å‡æ•°ï¼Œself-attention å¯ä»¥è¿›ä¸€æ­¥ä¸‹æ”¾ï¼Œå½“å‰å¥å­ä¸­å¯¹å½“å‰å¤„ç†çš„è¯è¯­æœ€é‡è¦çš„æ˜¯å“ªäº›éƒ¨åˆ†ã€‚ Multi-Headed Attention æˆ‘çš„ç†è§£å°±æ˜¯ åœ¨CNNä¸­ä½¿ç”¨å¤šä¸ªfilter çš„ç±»ä¼¼äº§ç‰©ã€‚è¯¥æœºåˆ¶ç†è§£èµ·æ¥å¾ˆç®€å•ï¼Œå°±æ˜¯è¯´ä¸ä»…ä»…åªåˆå§‹åŒ–ä¸€ç»„Qã€Kã€Vçš„çŸ©é˜µï¼Œè€Œæ˜¯åˆå§‹åŒ–å¤šç»„ï¼Œtranformeræ˜¯ä½¿ç”¨äº†8ç»„ï¼Œæ‰€ä»¥æœ€åŽå¾—åˆ°çš„ç»“æžœæ˜¯8ä¸ªçŸ©é˜µã€‚ è¿™æ ·åšçš„ä¸»è¦ç›®çš„æ˜¯ä»Žä¸åŒçš„è¯­ä¹‰ç©ºé—´æŠ•å°„åŽŸæ–‡æœ¬ï¼Œèƒ½å¤Ÿä»Žæ›´å¤šçš„è§’åº¦è¡¨å¾ï¼Œå¹¶ä¸”èƒ½å¤Ÿæ‹“å±•æ¨¡åž‹å¯¹ä¸åŒä½ç½®çš„å…³æ³¨èƒ½åŠ›ã€‚ è¿™ç»™æˆ‘ä»¬ç•™ä¸‹äº†ä¸€ä¸ªå°çš„æŒ‘æˆ˜ï¼Œå‰é¦ˆç¥žç»ç½‘ç»œæ²¡æ³•è¾“å…¥8ä¸ªçŸ©é˜µå‘€ï¼Œè¿™è¯¥æ€Žä¹ˆåŠžå‘¢ï¼Ÿæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¸€ç§æ–¹å¼ï¼ŒæŠŠ8ä¸ªçŸ©é˜µé™ä¸º1ä¸ªï¼Œé¦–å…ˆï¼Œæˆ‘ä»¬æŠŠ8ä¸ªçŸ©é˜µè¿žåœ¨ä¸€èµ·ï¼Œè¿™æ ·ä¼šå¾—åˆ°ä¸€ä¸ªå¤§çš„çŸ©é˜µï¼Œå†éšæœºåˆå§‹åŒ–ä¸€ä¸ªçŸ©é˜µå’Œè¿™ä¸ªç»„åˆå¥½çš„çŸ©é˜µç›¸ä¹˜ï¼Œæœ€åŽå¾—åˆ°ä¸€ä¸ªæœ€ç»ˆçš„çŸ©é˜µã€‚è¿™ä¸ªå°±æ˜¯ multi-head attention æœºåˆ¶çš„å…¨éƒ¨çš„æµç¨‹äº†ã€‚ Positional Encoding transformerç»™encoderå±‚å’Œdecoderå±‚çš„è¾“å…¥æ·»åŠ äº†ä¸€ä¸ªé¢å¤–çš„å‘é‡Positional Encodingï¼Œç»´åº¦å’Œembeddingçš„ç»´åº¦ä¸€æ ·ï¼Œè¿™ä¸ªå‘é‡é‡‡ç”¨äº†ä¸€ç§å¾ˆç‹¬ç‰¹çš„æ–¹æ³•æ¥è®©æ¨¡åž‹å­¦ä¹ åˆ°è¿™ä¸ªå€¼ï¼Œè¿™ä¸ªå‘é‡èƒ½å†³å®šå½“å‰è¯çš„ä½ç½®ï¼Œæˆ–è€…è¯´åœ¨ä¸€ä¸ªå¥å­ä¸­ä¸åŒçš„è¯ä¹‹é—´çš„è·ç¦»ã€‚è¿™ä¸ªä½ç½®å‘é‡çš„å…·ä½“è®¡ç®—æ–¹æ³•æœ‰å¾ˆå¤šç§ï¼Œè®ºæ–‡ä¸­çš„è®¡ç®—æ–¹æ³•å¦‚ä¸‹ï¼š $$P E ( p o s , 2 i ) = \sin \left( p o s / 10000 ^ { 2 i } / d _ { m } \text {odel} \right)$$ $$P E ( p o s , 2 i + 1 ) = \cos \left( p o s / 10000 ^ { 2 i } / d _ { m } o d e l \right)$$å…¶ä¸­posæ˜¯æŒ‡å½“å‰è¯åœ¨å¥å­ä¸­çš„ä½ç½®ï¼Œiæ˜¯æŒ‡å‘é‡ä¸­æ¯ä¸ªå€¼çš„indexï¼Œå¯ä»¥çœ‹å‡ºï¼Œåœ¨å¶æ•°ä½ç½®ï¼Œä½¿ç”¨æ­£å¼¦ç¼–ç ï¼Œåœ¨å¥‡æ•°ä½ç½®ï¼Œä½¿ç”¨ä½™å¼¦ç¼–ç . æœ€åŽæŠŠè¿™ä¸ªPositional Encodingä¸Žembeddingçš„å€¼ç›¸åŠ ï¼Œä½œä¸ºè¾“å…¥é€åˆ°ä¸‹ä¸€å±‚ã€‚ layer normalization Normalizationæœ‰å¾ˆå¤šç§ï¼Œä½†æ˜¯å®ƒä»¬éƒ½æœ‰ä¸€ä¸ªå…±åŒçš„ç›®çš„ï¼Œé‚£å°±æ˜¯æŠŠè¾“å…¥è½¬åŒ–æˆå‡å€¼ä¸º0æ–¹å·®ä¸º1çš„æ•°æ®ã€‚æˆ‘ä»¬åœ¨æŠŠæ•°æ®é€å…¥æ¿€æ´»å‡½æ•°ä¹‹å‰è¿›è¡Œnormalizationï¼ˆå½’ä¸€åŒ–ï¼‰ï¼Œå› ä¸ºæˆ‘ä»¬ä¸å¸Œæœ›è¾“å…¥æ•°æ®è½åœ¨æ¿€æ´»å‡½æ•°çš„é¥±å’ŒåŒºã€‚ batch normalization å’Œlayer normalization çš„åŒºåˆ«ï¼Œç®€å•æ¥è¯´å‰è€…ä¾èµ–äºŽ batch sizeï¼Œæ˜¯åœ¨ä¸åŒçš„æ ·æœ¬çš„åŒä¸€ä¸ªç‰¹å¾ä¸Šè¿›è¡Œå½’ä¸€åŒ–ï¼Œåœ¨CNN ä¸Šçš„æ•ˆæžœæ›´å¥½ï¼ŒåŽè€…åœ¨ä¸€ä¸ªæ ·æœ¬ä¸Šè¿›è¡Œå½’ä¸€åŒ–ï¼Œ åœ¨ RNNçš„ç½‘ç»œç»“æžœä¸­æ•ˆæžœæ›´å¥½ã€‚æ›´å¤šè¯¦ç»†çš„å†…å®¹å¯ä»¥å‚è€ƒè¿™ç¯‡åšå®¢. BNçš„ä¸»è¦æ€æƒ³å°±æ˜¯ï¼šåœ¨æ¯ä¸€å±‚çš„æ¯ä¸€æ‰¹æ•°æ®ä¸Šè¿›è¡Œå½’ä¸€åŒ–ã€‚æˆ‘ä»¬å¯èƒ½ä¼šå¯¹è¾“å…¥æ•°æ®è¿›è¡Œå½’ä¸€åŒ–ï¼Œä½†æ˜¯ç»è¿‡è¯¥ç½‘ç»œå±‚çš„ä½œç”¨åŽï¼Œæˆ‘ä»¬çš„æ•°æ®å·²ç»ä¸å†æ˜¯å½’ä¸€åŒ–çš„äº†ã€‚éšç€è¿™ç§æƒ…å†µçš„å‘å±•ï¼Œæ•°æ®çš„åå·®è¶Šæ¥è¶Šå¤§ï¼Œæˆ‘çš„åå‘ä¼ æ’­éœ€è¦è€ƒè™‘åˆ°è¿™äº›å¤§çš„åå·®ï¼Œè¿™å°±è¿«ä½¿æˆ‘ä»¬åªèƒ½ä½¿ç”¨è¾ƒå°çš„å­¦ä¹ çŽ‡æ¥é˜²æ­¢æ¢¯åº¦æ¶ˆå¤±æˆ–è€…æ¢¯åº¦çˆ†ç‚¸ã€‚å¯ä»¥çœ‹åˆ°ï¼Œå³åŠè¾¹æ±‚å‡å€¼æ˜¯æ²¿ç€æ•°æ® batch_sizeçš„æ–¹å‘è¿›è¡Œçš„ ä¸è¿‡ LN æ˜¯åœ¨æ¯ä¸€ä¸ªæ ·æœ¬ä¸Šè®¡ç®—å‡å€¼å’Œæ–¹å·®ï¼Œè€Œä¸æ˜¯BNé‚£ç§åœ¨æ‰¹æ–¹å‘è®¡ç®—å‡å€¼å’Œæ–¹å·®ï¼ decoder éƒ¨åˆ† decoderéƒ¨åˆ†å…¶å®žå’Œencoderéƒ¨åˆ†å¤§åŒå°å¼‚ï¼Œä¸è¿‡åœ¨æœ€ä¸‹é¢é¢å¤–å¤šäº†ä¸€ä¸ªmasked mutil-head attetionï¼Œè¿™é‡Œçš„maskä¹Ÿæ˜¯transformerä¸€ä¸ªå¾ˆå…³é”®çš„æŠ€æœ¯ã€‚ Transformer æ¨¡åž‹é‡Œé¢æ¶‰åŠä¸¤ç§ maskï¼Œåˆ†åˆ«æ˜¯ padding mask å’Œ sequence maskã€‚å…¶ä¸­ padding mask åœ¨æ‰€æœ‰çš„ scaled dot-product attention é‡Œé¢éƒ½éœ€è¦ç”¨åˆ°ï¼Œè€Œ sequence mask åªæœ‰åœ¨ decoder çš„ self-attention é‡Œé¢ç”¨åˆ°ã€‚å‰è€…å°±æ˜¯ä¸€ç§å¡«å……æŠ€æœ¯ï¼Œä½¿å¾— ä¸å®šé•¿çš„sequence å˜æˆå®šé•¿çš„sequenceä¹‹åŽåšå‡ºçš„ä¸€äº›å¤„ç†ã€‚ Padding Mask ä»€ä¹ˆæ˜¯ padding mask å‘¢ï¼Ÿå› ä¸ºæ¯ä¸ªæ‰¹æ¬¡è¾“å…¥åºåˆ—é•¿åº¦æ˜¯ä¸ä¸€æ ·çš„ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬è¦å¯¹è¾“å…¥åºåˆ—è¿›è¡Œå¯¹é½ã€‚å…·ä½“æ¥è¯´ï¼Œå°±æ˜¯ç»™åœ¨è¾ƒçŸ­çš„åºåˆ—åŽé¢å¡«å…… 0ã€‚ä½†æ˜¯å¦‚æžœè¾“å…¥çš„åºåˆ—å¤ªé•¿ï¼Œåˆ™æ˜¯æˆªå–å·¦è¾¹çš„å†…å®¹ï¼ŒæŠŠå¤šä½™çš„ç›´æŽ¥èˆå¼ƒã€‚å› ä¸ºè¿™äº›å¡«å……çš„ä½ç½®ï¼Œå…¶å®žæ˜¯æ²¡ä»€ä¹ˆæ„ä¹‰çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬çš„attentionæœºåˆ¶ä¸åº”è¯¥æŠŠæ³¨æ„åŠ›æ”¾åœ¨è¿™äº›ä½ç½®ä¸Šï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦è¿›è¡Œä¸€äº›å¤„ç†ã€‚å…·ä½“çš„åšæ³•æ˜¯ï¼ŒæŠŠè¿™äº›ä½ç½®çš„å€¼åŠ ä¸Šä¸€ä¸ªéžå¸¸å¤§çš„è´Ÿæ•°(è´Ÿæ— ç©·)ï¼Œè¿™æ ·çš„è¯ï¼Œç»è¿‡ softmaxï¼Œè¿™äº›ä½ç½®çš„æ¦‚çŽ‡å°±ä¼šæŽ¥è¿‘0ï¼ Sequence masksequence mask æ˜¯ä¸ºäº†ä½¿å¾— decoder ä¸èƒ½çœ‹è§æœªæ¥çš„ä¿¡æ¯ã€‚ä¹Ÿå°±æ˜¯å¯¹äºŽä¸€ä¸ªåºåˆ—ï¼Œåœ¨ time_step ä¸º t çš„æ—¶åˆ»ï¼Œæˆ‘ä»¬çš„è§£ç è¾“å‡ºåº”è¯¥åªèƒ½ä¾èµ–äºŽ t æ—¶åˆ»ä¹‹å‰çš„è¾“å‡ºï¼Œè€Œä¸èƒ½ä¾èµ– t ä¹‹åŽçš„è¾“å‡ºã€‚å› æ­¤æˆ‘ä»¬éœ€è¦æƒ³ä¸€ä¸ªåŠžæ³•ï¼ŒæŠŠ t ä¹‹åŽçš„ä¿¡æ¯ç»™éšè—èµ·æ¥ã€‚é‚£ä¹ˆå…·ä½“æ€Žä¹ˆåšå‘¢ï¼Ÿä¹Ÿå¾ˆç®€å•ï¼šäº§ç”Ÿä¸€ä¸ªä¸Šä¸‰è§’çŸ©é˜µï¼Œä¸Šä¸‰è§’çš„å€¼å…¨ä¸º1ã€‚æŠŠè¿™ä¸ªçŸ©é˜µä½œç”¨åœ¨æ¯ä¸€ä¸ªåºåˆ—ä¸Šï¼Œå°±å¯ä»¥è¾¾åˆ°æˆ‘ä»¬çš„ç›®çš„ã€‚ ç¼ºç‚¹ï¼š é—®é¢˜ä¸€ï¼š é•¿è¾“å…¥ åœ¨æ–‡æœ¬åªè¦ç­‰ç¯‡ç« çº§åˆ«çš„ä»»åŠ¡é‡ï¼Œ transformer å› ä¸ºè®¡ç®—é‡çš„å¤æ‚æ€§ï¼Œæ‰€ä»¥é€Ÿåº¦å›žæ€¥é€Ÿå˜æ…¢ã€‚æ‰€ä»¥çŸ­æœŸå†…ï¼Œè¿™äº›æ–¹é¢ä»ç„¶æ˜¯RNN æˆ–è€…CNNçš„åº”ç”¨åœºæ™¯ï¼ˆè™½ç„¶ä¸¤è€…åšçš„ä¹Ÿä¸æ˜¯å¾ˆå¥½ï¼‰ã€‚ transformer çš„æ”¹è¿›æ€è·¯ï¼š æ¯”å¦‚å¯ä»¥æŠŠé•¿è¾“å…¥åˆ‡æ–­åˆ†æˆKä»½ï¼Œå¼ºåˆ¶æŠŠé•¿è¾“å…¥åˆ‡çŸ­ï¼Œå†å¥—ä¸ŠTransformerä½œä¸ºç‰¹å¾æŠ½å–å™¨ï¼Œé«˜å±‚å¯ä»¥ç”¨RNNæˆ–è€…å¦å¤–ä¸€å±‚Transformeræ¥æŽ¥åŠ›ï¼Œå½¢æˆTransformerçš„å±‚çº§ç»“æž„ï¼Œè¿™æ ·å¯ä»¥æŠŠnå¹³æ–¹çš„è®¡ç®—é‡æžå¤§å‡å°‘ã€‚ï¼ˆåˆ†è€Œæ²»ä¹‹çš„æ€è·¯æ˜¯çœŸçš„æ¯”è¾ƒå¸¸è§å‘€ï¼‰ é—®é¢˜äºŒï¼š ç½‘ç»œç»“æž„è¿‡äºŽå¤æ‚ å¦‚ä½•æ›´æ·±åˆ»è®¤è¯†å®ƒçš„ä½œç”¨æœºç†ï¼Œç„¶åŽè¿›ä¸€æ­¥ç®€åŒ–å®ƒï¼Œè¿™ä¹Ÿæ˜¯ä¸€ä¸ªå¥½çš„æŽ¢ç´¢æ–¹å‘ã€‚ ä¸Šé¢åœ¨åšè¯­ä¹‰ç‰¹å¾æŠ½å–èƒ½åŠ›æ¯”è¾ƒæ—¶ï¼Œç»“è®ºæ˜¯å¯¹äºŽè·ç¦»è¿œä¸Ž13çš„é•¿è·ç¦»ç‰¹å¾ï¼ŒTransformeræ€§èƒ½å¼±äºŽRNN åˆ†ç•Œçº¿ - - - - - â€“ - - - - - - - - - - - åˆ† ç•Œçº¿ï¼ˆå¦å¤–çš„è§£è¯»æ–¹å¼ï¼‰ Encoderå’ŒDecoderçš„å†…éƒ¨ç»“æž„ï¼š æ¨¡åž‹çš„ç‰¹ç‚¹ï¼šPositional embeddingï¼›ï¼ˆä½ç½®åµŒå…¥å‘é‡â€”â€”å…¶å®žç±»ä¼¼word2vecï¼Œå¤„ç†çš„è¯­åºçš„ä¿¡æ¯ï¼‰ã€‚multi-head attention; (å¤šå¤´æ³¨æ„åŠ›æœºåˆ¶â€”â€”ç‚¹ä¹˜æ³¨æ„åŠ›çš„å‡çº§ç‰ˆæœ¬ï¼Œ è¿™ä¸ªå°±ç±»ä¼¼ensembleçš„æ€æƒ³ï¼Œä¸åŒçš„å­ç©ºé—´çš„attention è¿›è¡Œèžåˆï¼‰Position-wise Feed-Forward Networksï¼ˆä½ç½®å…¨é“¾æŽ¥å‰é¦ˆç½‘ç»œâ€”â€”MLPå˜å½¢ï¼‰ æœ‰ä¸¤ç§å¸¸ç”¨çš„æ³¨æ„åŠ›å‡½æ•°ï¼Œä¸€ç§æ˜¯åŠ æ³•æ³¨æ„åŠ›(additive attention)ï¼Œå¦å¤–ä¸€ç§æ˜¯ç‚¹ä¹˜æ³¨æ„åŠ›(dot-productattention)ï¼Œè®ºæ–‡æ‰€é‡‡ç”¨çš„å°±æ˜¯ç‚¹ä¹˜æ³¨æ„åŠ›ï¼Œè¿™ç§æ³¨æ„åŠ›æœºåˆ¶å¯¹äºŽåŠ æ³•æ³¨æ„åŠ›è€Œè¨€ï¼Œæ›´å¿«ï¼ŒåŒæ—¶æ›´èŠ‚çœç©ºé—´ã€‚ åŠ æ³•æ³¨æ„åŠ›è¿˜æ˜¯ä»¥ä¼ ç»Ÿçš„RNNçš„seq2seqé—®é¢˜ä¸ºä¾‹å­ï¼ŒåŠ æ€§æ³¨æ„åŠ›æ˜¯æœ€ç»å…¸çš„æ³¨æ„åŠ›æœºåˆ¶ï¼Œå®ƒä½¿ç”¨äº†æœ‰ä¸€ä¸ªéšè—å±‚çš„å‰é¦ˆç½‘ç»œï¼ˆå…¨è¿žæŽ¥ï¼‰æ¥è®¡ç®—æ³¨æ„åŠ›åˆ†é…ï¼š å…¬å¼:$$\alpha _ { i j } = \frac { \exp \left( e _ { i j } \right) } { \sum _ { k = 1 } ^ { L } e _ { i k } }$$ Scaled Dot-Productè¿™ç¯‡è®ºæ–‡è®¡ç®—queryå’Œkeyç›¸ä¼¼åº¦ä½¿ç”¨äº†dot-product attentionï¼Œå³queryå’Œkeyè¿›è¡Œç‚¹ä¹˜ï¼ˆå†…ç§¯ï¼‰æ¥è®¡ç®—ç›¸ä¼¼åº¦ã€‚ Multi-Head Attention:ï¼ˆå°†å•ä¸ªè®¡ç®—ç»„æˆçŸ©é˜µè¿ç®—ï¼Œæœ‰åˆ©äºŽå¹¶è¡Œè¿ç®—ï¼‰åœ¨å®žé™…ä¸­ä¸ºäº†å¹¶è¡Œè®¡ç®—ï¼Œå¯ä»¥åœ¨ä¸€ç»„queriesä¸Šè®¡ç®—æ³¨æ„åŠ›å‡½æ•°ï¼Œå°†å¤šä¸ªqueryå †å æˆQï¼ŒåŒç†keyså’Œvaluesä¹Ÿè¢«å †å æˆKå’ŒVï¼Œé€šè¿‡ä¸‹é¢çš„å…¬å¼æ¥è®¡ç®—çŸ©é˜µè¾“å‡º:self-attention æ¨¡åž‹å°±æ˜¯è‡ªå·±å¯¹è‡ªå·±æ±‚attentionï¼Œå³ð‘„=ð¾=ð‘‰$$\text { Attention } ( Q , K , V ) = \operatorname { softmax } \left( \frac { Q K ^ { T } } { \sqrt { d _ { k } } } \right) V$$ä¹‹æ‰€ä»¥ç”¨å†…ç§¯é™¤ä»¥ç»´åº¦çš„å¼€æ–¹ï¼Œè®ºæ–‡ç»™å‡ºçš„è§£é‡Šæ˜¯ï¼šå‡è®¾Qå’ŒKéƒ½æ˜¯ç‹¬ç«‹çš„éšæœºå˜é‡ï¼Œæ»¡è¶³å‡å€¼ä¸º0ï¼Œæ–¹å·®ä¸º1ï¼Œåˆ™ç‚¹ä¹˜åŽç»“æžœå‡å€¼ä¸º0ï¼Œæ–¹å·®ä¸ºdkã€‚ä¹Ÿå³æ–¹å·®ä¼šéšç»´åº¦dkçš„å¢žå¤§è€Œå¢žå¤§ï¼Œè€Œå¤§çš„æ–¹å·®å¯¼è‡´æžå°çš„æ¢¯åº¦(æˆ‘è®¤ä¸ºå¤§æ–¹å·®å¯¼è‡´æœ‰çš„è¾“å‡ºå•å…ƒaï¼ˆaæ˜¯softmaxçš„ä¸€ä¸ªè¾“å‡ºï¼‰å¾ˆå°ï¼Œsoftmaxåå‘ä¼ æ’­æ¢¯åº¦å°±å¾ˆå°ï¼ˆæ¢¯åº¦å’Œaæœ‰å…³ï¼‰ï¼‰ã€‚ä¸ºäº†é¿å…è¿™ç§å¤§æ–¹å·®å¸¦æ¥çš„è®­ç»ƒé—®é¢˜ï¼Œè®ºæ–‡ä¸­ç”¨å†…ç§¯é™¤ä»¥ç»´åº¦çš„å¼€æ–¹ï¼Œä½¿ä¹‹å˜ä¸ºå‡å€¼ä¸º0ï¼Œæ–¹å·®ä¸º1ã€‚ é™¤äº†è®¡ç®—ä¸€ä¸ªå•ç‹¬çš„æ³¨æ„åŠ›å‡½æ•°ï¼Œè®ºæ–‡æå‡ºå¯¹queriesï¼Œkeyså’Œvaluesåšhæ¬¡ä¸åŒçš„æŠ•å½±, ç„¶åŽéƒ½ç»è¿‡Scaled Dot-Product Attentionï¼Œå°†ç»“æžœæ‹¼æŽ¥åœ¨ä¸€èµ·ï¼Œæœ€åŽé€šè¿‡ä¸€ä¸ªçº¿æ€§æ˜ å°„è¾“å‡ºï¼Œé€šè¿‡å¤šå¤´æ³¨æ„åŠ›ï¼Œæ¨¡åž‹èƒ½å¤ŸèŽ·å¾—ä¸åŒå­ç©ºé—´ä¸‹çš„ä½ç½®ä¿¡æ¯ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œå…¬å¼å¦‚ä¸‹:$$\text {MultiHead} ( Q , K , V ) =Concat(head_1, head_2, â€¦, head_h) W ^ { o }$$ Self-Attentioné‚£ä¹ˆé¦–å…ˆè¦æ˜Žç™½ä»€ä¹ˆæ˜¯Attentionã€‚ä»Žè¯­è¨€å­¦çš„è§’åº¦ï¼Œå®ƒæ˜¯è¡¨ç¤ºè¯ä¸Žè¯ä¹‹é—´çš„å…³è”å…³ç³»ï¼ˆè¿™ç§å…³ç³»æ˜¯é€šè¿‡åå‘ä¼ æ’­å­¦ä¹ åˆ°çš„ï¼‰ã€‚è€Œ self-attention è¡¨ç¤ºå¥å­å†…éƒ¨è¯äºŽè¯ä¹‹é—´çš„å…³è”å…³ç³»ï¼Œå¦‚ä¸‹å›¾ä¸­çš„it å’Œå…¶ä»–ä½ç½®è¯çš„å…³ç³»ï¼Œé¢œè‰²è¶Šæ·±è¡¨ç¤ºå…³ç³»è¶Šç´§å¯†ï¼Œ ä»Žå›¾ä¸­å¯ä»¥çœ‹åˆ° it æ­£ç¡®çš„å…³è”åˆ°äº† animal å®ƒæ‰€æŒ‡ä»£çš„ä¸€ä¸ªè¯ã€‚ Positional Encodingtransformeræ˜¯ä½¿ç”¨ positional encoding åŠ å…¥äº†ä½ç½®ä¿¡æ¯ï¼Œä¿æŒäº†è¯è¯­ä¹‹é—´çš„ä¸Šä¸‹æ–‡å…³ç³»ã€‚å®žçŽ°çš„çš„æ—¶å€™ï¼Œåœ¨å¶æ•°ä½ç½®ï¼Œä½¿ç”¨æ­£å¼¦ç¼–ç ï¼Œåœ¨å¥‡æ•°ä½ç½®ï¼Œä½¿ç”¨ä½™å¼¦ç¼–ç . Residual connectionå’Œlayer-normalization å¯¹äºŽå­¦ä¹ CVçš„äººä¼°è®¡å¯¹è¿™ä¸ªç»“æž„ä¸€ç‚¹ä¹Ÿä¸é™Œç”Ÿï¼ŒResidual connectionæ˜¯å¯¹äºŽè¾ƒä¸ºæ·±å±‚çš„ç¥žç»ç½‘ç»œæœ‰æ¯”è¾ƒå¥½çš„ä½œç”¨ï¼Œæ¯”å¦‚ç½‘ç»œå±‚å¾ˆæ·±æ—¶ï¼Œæ•°å€¼çš„ä¼ æ’­éšç€weightä¸æ–­çš„å‡å¼±ï¼ŒResidual connectionæ˜¯ä»Žè¾“å…¥çš„éƒ¨åˆ†ï¼Œå°±æ˜¯å›¾ä¸­è™šçº¿çš„éƒ¨åˆ†ï¼Œå®žé™…è¿žåˆ°å®ƒè¾“å‡ºå±‚çš„éƒ¨åˆ†ï¼ŒæŠŠè¾“å…¥çš„ä¿¡æ¯åŽŸå°ä¸åŠ¨copyåˆ°è¾“å‡ºçš„éƒ¨åˆ†ï¼Œå‡å°‘ä¿¡æ¯çš„æŸå¤±ã€‚ layer-normalizationè¿™ç§å½’ä¸€åŒ–å±‚æ˜¯ä¸ºäº†é˜²æ­¢åœ¨æŸäº›å±‚ä¸­ç”±äºŽæŸäº›ä½ç½®è¿‡å¤§æˆ–è€…è¿‡å°å¯¼è‡´æ•°å€¼è¿‡å¤§æˆ–è¿‡å°ï¼Œå¯¹ç¥žç»ç½‘ç»œæ¢¯åº¦å›žä¼ æ—¶æœ‰è®­ç»ƒçš„é—®é¢˜ï¼Œä¿è¯è®­ç»ƒçš„ç¨³å®šæ€§ï¼Œè¿™æ˜¯ç¥žç»ç½‘ç»œè®¾è®¡æ¯”è¾ƒå¸¸ç”¨çš„caseã€‚ ç»“è®ºï¼šself-attentionå±‚çš„å¥½å¤„æ˜¯èƒ½å¤Ÿä¸€æ­¥åˆ°ä½æ•æ‰åˆ°å…¨å±€çš„è”ç³»ï¼Œè§£å†³äº†é•¿è·ç¦»ä¾èµ–ï¼Œå› ä¸ºå®ƒç›´æŽ¥æŠŠåºåˆ—ä¸¤ä¸¤æ¯”è¾ƒï¼ˆä»£ä»·æ˜¯è®¡ç®—é‡å˜ä¸º O(n2)ï¼Œå½“ç„¶ç”±äºŽæ˜¯çº¯çŸ©é˜µè¿ç®—ï¼Œè¿™ä¸ªè®¡ç®—é‡ç›¸å½“ä¹Ÿä¸æ˜¯å¾ˆä¸¥é‡ï¼‰ï¼Œè€Œä¸”æœ€é‡è¦çš„æ˜¯å¯ä»¥è¿›è¡Œå¹¶è¡Œè®¡ç®—ï¼Œå› ä¸ºè¿™ä¸ªæ“ä½œæ˜¯å¯ä»¥ä½¿ç”¨çŸ©é˜µè¿ç®—çš„ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼ŒRNN éœ€è¦ä¸€æ­¥æ­¥é€’æŽ¨æ‰èƒ½æ•æ‰åˆ°ï¼Œå¹¶ä¸”å¯¹äºŽé•¿è·ç¦»ä¾èµ–å¾ˆéš¾æ•æ‰ã€‚è€Œ CNN åˆ™éœ€è¦é€šè¿‡å±‚å æ¥æ‰©å¤§æ„Ÿå—é‡Žï¼ˆæ„Ÿå—é‡Žçš„æ¦‚å¿µï¼Œæ›´åƒæ˜¯ æœ€åŽç»è¿‡CNN çš„ä¸€ä¸ªç‚¹åœ¨åŽŸå§‹çš„å›¾åƒä¸­æ˜¯å¤šå¤§çš„é¢ç§¯ï¼Œè¿™ç§ç®¡ä¸­çª¥è±¹çš„æ„Ÿè§‰ï¼‰ï¼Œè¿™æ˜¯ Attention å±‚çš„æ˜Žæ˜¾ä¼˜åŠ¿ã€‚ Deep Contextualized Word Representationsï¼ˆå¯ä»¥å¾—åˆ°æœ‰ä¸Šä¸‹æ–‡å…³ç³»çš„è¯å‘é‡ï¼Œ è¿™ä¸ªç‰¹ç‚¹æ˜¯ç›¸å¯¹äºŽ word2vec æˆ–è€… glove çš„ï¼‰è¿™ç¯‡è®ºæ–‡çš„æƒ³æ³•å…¶å®žéžå¸¸éžå¸¸ç®€å•ï¼Œä½†æ˜¯å–å¾—äº†éžå¸¸å¥½çš„æ•ˆæžœã€‚å®ƒçš„æ€è·¯æ˜¯ç”¨æ·±åº¦çš„åŒå‘RNN(LSTM)åœ¨å¤§é‡æœªæ ‡æ³¨æ•°æ®ä¸Šè®­ç»ƒè¯­è¨€æ¨¡åž‹ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ç„¶åŽåœ¨å®žé™…çš„ä»»åŠ¡ä¸­ï¼Œå¯¹äºŽè¾“å…¥çš„å¥å­ï¼Œæˆ‘ä»¬ä½¿ç”¨è¿™ä¸ªè¯­è¨€æ¨¡åž‹æ¥å¯¹å®ƒå¤„ç†ï¼Œå¾—åˆ°è¾“å‡ºçš„å‘é‡ï¼Œå› æ­¤è¿™å¯ä»¥çœ‹æˆæ˜¯ä¸€ç§ç‰¹å¾æå–ã€‚ä½†æ˜¯å’Œæ™®é€šçš„Word2Vecæˆ–è€…GloVeçš„pretrainingä¸åŒï¼ŒELMoå¾—åˆ°çš„Embeddingæ˜¯æœ‰ä¸Šä¸‹æ–‡çš„ã€‚æ¯”å¦‚æˆ‘ä»¬ä½¿ç”¨Word2Vecä¹Ÿå¯ä»¥å¾—åˆ°è¯â€bankâ€çš„Embeddingï¼Œæˆ‘ä»¬å¯ä»¥è®¤ä¸ºè¿™ä¸ªEmbeddingåŒ…å«äº†bankçš„è¯­ä¹‰ã€‚ä½†æ˜¯bankæœ‰å¾ˆå¤šæ„æ€ï¼Œå¯ä»¥æ˜¯é“¶è¡Œä¹Ÿå¯ä»¥æ˜¯æ°´è¾¹ï¼Œä½¿ç”¨æ™®é€šçš„Word2Vecä½œä¸ºPretrainingçš„Embeddingï¼Œåªèƒ½åŒæ—¶æŠŠè¿™ä¸¤ç§è¯­ä¹‰éƒ½ç¼–ç è¿›å‘é‡é‡Œï¼Œç„¶åŽé åŽé¢çš„æ¨¡åž‹æ¯”å¦‚RNNæ¥æ ¹æ®ä¸Šä¸‹æ–‡é€‰æ‹©åˆé€‚çš„è¯­ä¹‰â€”â€”æ¯”å¦‚ä¸Šä¸‹æ–‡æœ‰moneyï¼Œé‚£ä¹ˆå®ƒæ›´å¯èƒ½æ˜¯é“¶è¡Œï¼›è€Œå¦‚æžœä¸Šä¸‹æ–‡æ˜¯riverï¼Œé‚£ä¹ˆæ›´å¯èƒ½æ˜¯æ°´è¾¹çš„æ„æ€ã€‚ä½†æ˜¯RNNè¦å­¦åˆ°è¿™ç§ä¸Šä¸‹æ–‡çš„å…³ç³»ï¼Œéœ€è¦è¿™ä¸ªä»»åŠ¡æœ‰å¤§é‡ç›¸å…³çš„æ ‡æ³¨æ•°æ®ï¼Œè¿™åœ¨å¾ˆå¤šæ—¶å€™æ˜¯æ²¡æœ‰çš„ã€‚è€ŒELMoçš„ç‰¹å¾æå–å¯ä»¥çœ‹æˆæ˜¯ä¸Šä¸‹æ–‡ç›¸å…³çš„ï¼Œå¦‚æžœè¾“å…¥å¥å­æœ‰moneyï¼Œé‚£ä¹ˆå®ƒå°±(æˆ–è€…æˆ‘ä»¬æœŸæœ›)åº”è¯¥èƒ½çŸ¥é“bankæ›´å¯èƒ½çš„è¯­ä¹‰ï¼Œä»Žè€Œå¸®æˆ‘ä»¬é€‰æ‹©æ›´åŠ åˆé€‚çš„ç¼–ç ã€‚ æˆ‘ä»¬æŠŠè¿™ä¸¤ä¸ªæ–¹å‘çš„RNNåˆå¹¶èµ·æ¥å°±å¾—åˆ°Bi-LSTMã€‚æˆ‘ä»¬ä¼˜åŒ–çš„æŸå¤±å‡½æ•°æ˜¯ä¸¤ä¸ªLSTMçš„äº¤å‰ç†µåŠ èµ·æ¥æ˜¯æœ€å°çš„ï¼š ä¸»è¦è´¡çŒ®ï¼š æå‡ºäº†ä¸€ä¸ªåŒå‘è®­ç»ƒçš„ language modelï¼Œä½¿ç”¨å‰K-1 ä¸ªè¯è¯­è®­ç»ƒ ç¬¬K ä¸ªè¯è¯­ï¼Œç„¶åŽä½¿ç”¨åŽ N-K+1 ä¸ªè¯è¯­è®­ç»ƒç¬¬K ä¸ªè¯è¯­ï¼Œæ‰€ä»¥ç¬¬ K ä¸ªè¯è¯­æ˜¯combine äº†ä¸Šä¸‹æ–‡çš„ä¿¡æ¯çš„ã€‚ word embedding çš„è¡¨ç¤ºæ˜¯ä¸åŒlayer ç´¯åŠ çš„ç»“æžœï¼Œweights çš„è®¾å®šæ˜¯å­¦ä¹ è€Œå¾—ã€‚ Why do we need contextualized representations? è¯è¯­çš„æ„æ€æ˜¯ç”±ä¸Šä¸‹æ–‡æ‰€å†³å®šçš„ã€‚æ‰€ä»¥ä¸€ä¸ªå›ºå®šçš„ word embedding ä¸èƒ½å‡†ç¡®çš„è¡¨ç¤ºä¸åŒåœºæ™¯ä¸‹ word çš„å«ä¹‰ã€‚ As an illustrative example, take the following two sentences: â€œThe bank on the other end of the street was robbedâ€â€œWe had a picnic on the bank of the riverâ€ Both sentences use the word â€œbankâ€, but the meaning of the word differs completely between them. This phenomenon where two identical words change meaning depending on the context is known as â€œpolysemyâ€œ, and has been an issue in the NLP deep learning community ever since word embeddings really took off. Most current neural networks are bad at handling polysemy because they use a single vector to represent the meaning of the word â€œbankâ€, regardless of the context. In reality, the vector representing any word should change depending on the words around it. ä¹‹å‰çš„åšæ³•çš„ç¼ºç‚¹æ˜¯å¯¹äºŽæ¯ä¸€ä¸ªå•è¯éƒ½æœ‰å”¯ä¸€çš„ä¸€ä¸ªembeddingè¡¨ç¤º, è€Œå¯¹äºŽå¤šä¹‰è¯æ˜¾ç„¶è¿™ç§åšæ³•ä¸ç¬¦åˆç›´è§‰, è€Œå•è¯çš„æ„æ€åˆå’Œä¸Šä¸‹æ–‡ç›¸å…³, ELMoçš„åšæ³•æ˜¯æˆ‘ä»¬åªé¢„è®­ç»ƒlanguage model, è€Œword embeddingæ˜¯é€šè¿‡è¾“å…¥çš„å¥å­å®žæ—¶è¾“å‡ºçš„, è¿™æ ·å•è¯çš„æ„æ€å°±æ˜¯ä¸Šä¸‹æ–‡ç›¸å…³çš„äº†, è¿™æ ·å°±å¾ˆå¤§ç¨‹åº¦ä¸Šç¼“è§£äº†æ­§ä¹‰çš„å‘ç”Ÿ. è¿™ç§ç®—æ³•çš„ç‰¹ç‚¹æ˜¯ï¼šæ¯ä¸€ä¸ªword representationéƒ½æ˜¯æ•´ä¸ªè¾“å…¥è¯­å¥çš„å‡½æ•°ã€‚å…·ä½“åšæ³•å°±æ˜¯å…ˆåœ¨å¤§è¯­æ–™ä¸Šä»¥language modelä¸ºç›®æ ‡è®­ç»ƒå‡ºbidirectional LSTMæ¨¡åž‹ï¼Œç„¶åŽåˆ©ç”¨LSTMäº§ç”Ÿè¯è¯­çš„è¡¨å¾ã€‚ELMoæ•…è€Œå¾—å(Embeddings from Language Models)ã€‚ä¸ºäº†åº”ç”¨åœ¨ä¸‹æ¸¸çš„NLPä»»åŠ¡ä¸­ï¼Œä¸€èˆ¬å…ˆåˆ©ç”¨ä¸‹æ¸¸ä»»åŠ¡çš„è¯­æ–™åº“(æ³¨æ„è¿™é‡Œå¿½ç•¥æŽ‰label)è¿›è¡Œlanguage modelçš„å¾®è°ƒ,è¿™ç§å¾®è°ƒç›¸å½“äºŽä¸€ç§domain transfer; ç„¶åŽæ‰åˆ©ç”¨labelçš„ä¿¡æ¯è¿›è¡Œsupervised learningã€‚ ELMoè¡¨å¾æ˜¯â€œæ·±â€çš„ï¼Œå°±æ˜¯è¯´å®ƒä»¬æ˜¯biLMçš„æ‰€æœ‰å±‚çš„å†…éƒ¨è¡¨å¾çš„å‡½æ•°ã€‚è¿™æ ·åšçš„å¥½å¤„æ˜¯èƒ½å¤Ÿäº§ç”Ÿä¸°å¯Œçš„è¯è¯­è¡¨å¾ã€‚é«˜å±‚çš„LSTMçš„çŠ¶æ€å¯ä»¥æ•æ‰è¯è¯­æ„ä¹‰ä¸­å’Œè¯­å¢ƒç›¸å…³çš„é‚£æ–¹é¢çš„ç‰¹å¾(æ¯”å¦‚å¯ä»¥ç”¨æ¥åšè¯­ä¹‰çš„æ¶ˆæ­§)ï¼Œè€Œä½Žå±‚çš„LSTMå¯ä»¥æ‰¾åˆ°è¯­æ³•æ–¹é¢çš„ç‰¹å¾(æ¯”å¦‚å¯ä»¥åšè¯æ€§æ ‡æ³¨)ã€‚å¦‚æžœæŠŠå®ƒä»¬ç»“åˆåœ¨ä¸€èµ·ï¼Œåœ¨ä¸‹æ¸¸çš„NLPä»»åŠ¡ä¸­ä¼šä½“çŽ°ä¼˜åŠ¿ã€‚ æ‰€ä»¥ï¼Œæœ€åŽçš„ embedding ä½¿ç”¨ä¸åŒå±‚è¿›è¡Œweights çš„ç´¯åŠ ï¼Œè¿™ç§ç†è®ºä¸Šæ˜¯ç«™å¾—ä½è„šçš„ã€‚ä¸Šé¢çš„æè¿°å’Œ CV æ˜¯æƒŠäººçš„ç›¸ä¼¼ã€‚ Salient featuresELMo representations are: Contextual: The representation for each word depends on the entire context in which it is used. Deep: The word representations combine all layers of a deep pre-trained neural network. Character based: ELMo representations are purely character based, allowing the network to use morphological clues to form robust representations for out-of-vocabulary tokens unseen in training. related work: é’ˆå¯¹ä¼ ç»Ÿè¯å‘é‡æ˜¯å›ºå®šçš„ï¼Œä¸Žä¸Šä¸‹æ–‡è¯­å¢ƒæ— å…³çš„ç¼ºç‚¹ï¼Œå…ˆå‰çš„å·¥ä½œå¤šé€šè¿‡ä¸¤ç§æ–¹å¼æ¥è§£å†³ï¼š (1) é€šè¿‡å¼•å…¥å­—ç¬¦çº§(subword)ä¿¡æ¯ä¸°å¯Œè¯å‘é‡è¡¨è¾¾ï¼› (2) å­¦ä¹ æ¯ä¸ªå•è¯ä¸åŒå«ä¹‰çš„ç‹¬ç«‹å‘é‡ï¼› ELMoä¹Ÿåˆ©ç”¨äº†å­—ç¬¦å·ç§¯ï¼ˆCharacter-Convolutionsï¼‰å¼•å…¥å­—ç¬¦çº§ä¿¡æ¯ï¼Œå¹¶åŒæ—¶ç»“åˆäº†æ·±åº¦åŒå‘è¯­è¨€æ¨¡åž‹çš„å„å±‚éšçŠ¶æ€æ¥ä¸°å¯Œè¯å‘é‡è¡¨è¾¾ã€‚ P.s.ï¼šåŸºäºŽå­—ç¬¦çš„æ¨¡åž‹ä¸ä»…èƒ½å¤Ÿé€šè¿‡å¼•å…¥å­—ç¬¦çº§ä¿¡æ¯ä¸°å¯Œè¯å‘é‡è¡¨è¾¾ï¼Œä¹Ÿèƒ½å¤Ÿåœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šè§£å†³NLPé¢†åŸŸçš„OOVï¼ˆOut-Of-Vocabularyï¼‰é—®é¢˜ã€‚ ELMoç”¨åˆ°ä¸Šæ–‡æåˆ°çš„åŒå‘çš„language model, ç»™å®šNä¸ªtokens (t1, t2,â€¦,tN), language modelé€šè¿‡ç»™å®šå‰é¢çš„k-1ä¸ªä½ç½®çš„tokenåºåˆ—è®¡ç®—ç¬¬kä¸ªtokençš„å‡ºçŽ°çš„æ¦‚çŽ‡:$$p \left( t _ { 1 } , t _ { 2 } , \ldots , t _ { N } \right) = \prod _ { k = 1 } ^ { N } p \left( t _ { k } | t _ { 1 } , t _ { 2 } , \ldots , t _ { k - 1 } \right)$$åŽå‘çš„è®¡ç®—æ–¹æ³•ä¸Žå‰å‘ç›¸ä¼¼:$$p \left( t _ { 1 } , t _ { 2 } , \ldots , t _ { N } \right) = \prod _ { k = 1 } ^ { N } p \left( t _ { k } | t _ { k + 1 } , t _ { k + 2 } , \ldots , t _ { N } \right)$$biLMè®­ç»ƒè¿‡ç¨‹ä¸­çš„ç›®æ ‡å°±æ˜¯æœ€å¤§åŒ–:$$\sum _ { k = 1 } ^ { N } \left( \log p \left( t _ { k } | t _ { 1 } , \ldots , t _ { k - 1 } ; \Theta _ { x } , \vec { \Theta } _ { L S T M } , \Theta _ { s } \right) + \log p \left( t _ { k } | t _ { k + 1 } , \ldots , t _ { N } ; \Theta _ { x } , \overline { \Theta } _ { L S T M } , \Theta _ { s } \right) \right)$$ELMoå¯¹äºŽæ¯ä¸ªtoken $t_k$, é€šè¿‡ä¸€ä¸ªLå±‚çš„biLMè®¡ç®—å‡º2L+1ä¸ªè¡¨ç¤º:$$R_{ k } = { x _ { k } ^ { L M } , \vec { h } _ { k , j } ^ { L M } , h _ { k , j } ^ { L M } | j = 1 , \ldots , L } = { h _ { k , j } ^ { L M } | j = 0 , \ldots , L }$$å…¶ä¸­$h _ { k , 0 } ^ { L M }$æ˜¯å¯¹tokenè¿›è¡Œç›´æŽ¥ç¼–ç çš„ç»“æžœ(è¿™é‡Œæ˜¯å­—ç¬¦é€šè¿‡CNNç¼–ç ), $h _ { k , j } ^ { L M } = \left[ \vec { h } _ { k , j } ^ { L M } ; \overline { h } _ { k , j } \right]$ æ˜¯æ¯ä¸ªbiLSTMå±‚è¾“å‡ºçš„ç»“æžœ. åœ¨å®žéªŒä¸­è¿˜å‘çŽ°ä¸åŒå±‚çš„biLMçš„è¾“å‡ºçš„tokenè¡¨ç¤ºå¯¹äºŽä¸åŒçš„ä»»åŠ¡æ•ˆæžœä¸åŒ. åº”ç”¨ä¸­å°†ELMoä¸­æ‰€æœ‰å±‚çš„è¾“å‡ºRåŽ‹ç¼©ä¸ºå•ä¸ªå‘é‡, ELMok=E(Rk;Î˜Ïµ), æœ€ç®€å•çš„åŽ‹ç¼©æ–¹æ³•æ˜¯å–æœ€ä¸Šå±‚çš„ç»“æžœåšä¸ºtokençš„è¡¨ç¤º:$E \left( R _ { k } \right) = h _ { k , L } ^ { L M }$ æ›´é€šç”¨çš„åšæ³•æ˜¯é€šè¿‡ä¸€äº›å‚æ•°æ¥è”åˆæ‰€æœ‰å±‚çš„ä¿¡æ¯:$$E L M o _ { k } ^ { t a s k } = E \left( R _ { k } ; \Theta ^ { t a s k } \right) = \gamma ^ { t a s k } \sum _ { j = 0 } ^ { L } s _ { j } ^ { t a s k } h _ { k , j } ^ { L M }$$ å…¶ä¸­$s_j$æ˜¯ä¸€ä¸ªsoftmaxå‡ºæ¥çš„ç»“æžœ, $Î³$æ˜¯ä¸€ä¸ªä»»åŠ¡ç›¸å…³çš„scaleå‚æ•°, æˆ‘è¯•äº†å¹³å‡æ¯ä¸ªå±‚çš„ä¿¡æ¯å’Œå­¦å‡ºæ¥$s_j$å‘çŽ°å­¦ä¹ å‡ºæ¥çš„æ•ˆæžœä¼šå¥½å¾ˆå¤š. æ–‡ä¸­æåˆ°$Î³$åœ¨ä¸åŒä»»åŠ¡ä¸­å–ä¸åŒçš„å€¼æ•ˆæžœä¼šæœ‰è¾ƒå¤§çš„å·®å¼‚, éœ€è¦æ³¨æ„, åœ¨SQuADä¸­è®¾ç½®ä¸º0.01å–å¾—çš„æ•ˆæžœè¦å¥½äºŽè®¾ç½®ä¸º1æ—¶. ELMo: Context Matters Instead of using a fixed embedding for each word, ELMo looks at the entire sentence before assigning each word in it an embedding. It uses a bi-directional LSTM trained on a specific task to be able to create those embeddings. ELMo provided a significant step towards pre-training in the context of NLP. The ELMo LSTM would be trained on a massive dataset in the language of our dataset, and then we can use it as a component in other models that need to handle language. Whatâ€™s ELMoâ€™s secret? ELMo gained its language understanding from being trained to predict the next word in a sequence of words - a task called Language Modeling. This is convenient because we have vast amounts of text data that such a model can learn from without needing labels. We can see the hidden state of each unrolled-LSTM step peaking out from behind ELMoâ€™s head. Those come in handy in the embedding proecss after this pre-training is done. ELMo actually goes a step further and trains a bi-directional LSTM â€“ so that its language model doesnâ€™t only have a sense of the next word, but also the previous word.ELMo comes up with the contextualized embedding through grouping together the hidden states (and initial embedding) in a certain way (concatenation followed by weighted summation). lstm-based language modelIn case you are unfamiliar with language models, a language model is simply a model that can predict how â€œlikelyâ€ a certain sequence of words is to be a real piece of text. This is generally done by training a model to take a part of sentence (say, the first n words) and predict the next word â€“ or more precisely, output the probability of each word in the vocabulary being the next word (In this blog post, weâ€™ll focus on LSTM-based language models which are the focus of this paper). One trick that this paper uses is to train a language model with reversed sentences that the authors call the â€œbackwardâ€ language model.è¿™ç§æ¨¡åž‹ï¼šä¸Šä¸€ä¸ªæ¨¡åž‹çš„è¾“å‡ºåˆ°ä¸‹ä¸€ä¸ªæ¨¡åž‹è¾“å…¥Furthermore, instead of using a single-layer LSTM, this paper uses a stacked, multi-layer LSTM. Whereas a single-layer LSTM would take the sequence of words as input, a multi-layer LSTM trains multiple LSTMs to take the output sequence of the LSTM in the previous layer as input (of course, the first layer takes the sequence of words as input). This is best illustrated in the following illustration: æœ€åŽçš„embedding æ˜¯æ˜¯å°†ä¸åŒçš„å±‚ combinationèµ·æ¥ï¼Œè¿™ä¸ªç³»æ•°æ˜¯é€šè¿‡å­¦ä¹ å‡ºæ¥çš„ã€‚In ELMo, the part that is task specific is the combination of the task-agnostic representations. The weight is learned for each task and normalized using the softmax function. The parameter $\gamma$ is a task-dependent value that allows for scaling the entire vector, which is important during optimization. ä¼˜ç¼ºç‚¹ï¼š åœ¨ELMoä¸­ï¼ŒåµŒå…¥åŸºäºŽä¸€ä¸ªåŒå±‚çš„åŒå‘è¯­è¨€æ¨¡åž‹ï¼ˆbiLMï¼‰çš„å†…éƒ¨çŠ¶æ€è®¡ç®—ï¼ŒELMoä¹Ÿæ˜¯å› æ­¤å¾—åçš„ï¼šEmbeddings from Language Modelsï¼ˆæ¥è‡ªè¯­è¨€æ¨¡åž‹çš„åµŒå…¥ï¼‰ã€‚ELMoçš„ç‰¹æ€§ï¼šELMoçš„è¾“å…¥æ˜¯å­—ç¬¦è€Œä¸æ˜¯å•è¯ã€‚è¿™ä½¿å¾—å®ƒå¯ä»¥åˆ©ç”¨å­å­—ï¼ˆsub-wordï¼‰å•å…ƒä¸ºè¯æ±‡è¡¨ä»¥å¤–çš„å•è¯è®¡ç®—æœ‰æ„ä¹‰çš„è¡¨ç¤ºï¼ˆå’ŒFastTextç±»ä¼¼ï¼‰ã€‚ELMoæ˜¯biLMçš„å¤šå±‚æ¿€æ´»çš„è¿žæŽ¥ï¼ˆconcatenationï¼‰ã€‚è¯­è¨€æ¨¡åž‹çš„ä¸åŒå±‚ç¼–ç äº†å•è¯çš„ä¸åŒä¿¡æ¯ã€‚è¿žæŽ¥æ‰€æœ‰å±‚ä½¿å¾—ELMoå¯ä»¥ç»„åˆå¤šç§è¯è¡¨ç¤ºï¼Œä»¥æå‡ä¸‹æ¸¸ä»»åŠ¡çš„è¡¨çŽ°ã€‚ OpenAI GPTå®ƒçš„æ€æƒ³å…¶å®žä¹Ÿå¾ˆç®€å•ï¼Œä½¿ç”¨Transformeræ¥å­¦ä¹ ä¸€ä¸ªè¯­è¨€æ¨¡åž‹ï¼Œå¯¹å¥å­è¿›è¡Œæ— ç›‘ç£çš„Embeddingï¼Œç„¶åŽæ ¹æ®å…·ä½“ä»»åŠ¡å¯¹Transformerçš„å‚æ•°è¿›è¡Œå¾®è°ƒã€‚ è¿™ç¯‡è®ºæ–‡ä¸­çš„ å¤šä»»åŠ¡å­¦ä¹ æ˜¯å¦‚ä½•ä½“çŽ°çš„å‘¢ï¼Ÿé¦–å…ˆæ˜¯æ— ç›‘ç£çš„pretraining ä¸­æœ‰ä¸€ä¸ªè¯­è¨€æ¨¡åž‹ï¼Œéœ€è¦ä¼˜åŒ–ä¸€ä¸ªæœ€å¤§ä¼¼ç„¶ä¼°è®¡ L1ï¼Œç„¶åŽå†ç›‘ç£çš„fine-tuning ä¸­æœ‰ä¸€ä¸ªäº¤å‰ç†µæŸå¤±å‡½æ•°ï¼Œè¿™é‡Œä¹Ÿæ˜¯æœ‰ä¸€ä¸ªloss ï¼Œè®°ä¸ºL2ã€‚æ­£å¸¸æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬åº”è¯¥è°ƒæ•´å‚æ•°æœ€å¤§åŒ–L2ï¼Œ ä½†æ˜¯æˆ‘ä»¬ä½¿ç”¨çš„æ˜¯å¤šä»»åŠ¡å­¦ä¹ ï¼ŒåŒæ—¶è®©å®ƒæœ€å¤§ä¼¼ç„¶L1 å’ŒL2ã€‚$$L_{3}(\mathcal{C})=L_{2}(\mathcal{C})+\lambda \times L_{1}(\mathcal{C})$$ BERT: Pre-training of Deep Bidirectional Transformers for Language UnderstandingåµŒå…¥ï¼ˆEmbeddingï¼‰çš„æ–°æ—¶ä»£åˆ°ç›®å‰ä¸ºæ­¢ï¼Œè¯åµŒå…¥ä¸€ç›´æ˜¯å½±å“NLPæ¨¡åž‹å¤„ç†è¯­è¨€çš„ä¸»è¦åŠ›é‡ã€‚ä½†æ˜¯æˆ‘ä»¬ä½¿ç”¨GloVeï¼Œé‚£ä¹ˆâ€œstickâ€è¿™ä¸ªè¯å°†ç”±ä¸€ä¸ªå‘é‡è¡¨ç¤ºï¼Œæ— è®ºä¸Šä¸‹æ–‡æ˜¯ä»€ä¹ˆã€‚æ‰€ä»¥è¯åµŒå…¥çš„æ–¹å¼å¹¶æ²¡æœ‰è§£å†³ä¸Šä¸‹æ–‡çš„é—®é¢˜ã€‚ELMo è§£å†³äº†è¿™ä¸ªé—®é¢˜ï¼šæ•æ‰å•è¯çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚ELMoä¸æ˜¯å¯¹æ¯ä¸ªå•è¯ä½¿ç”¨å›ºå®šåµŒå…¥ï¼Œè€Œæ˜¯åœ¨ä¸ºå…¶ä¸­çš„æ¯ä¸ªå•è¯åˆ†é…åµŒå…¥ä¹‹å‰æŸ¥çœ‹æ•´ä¸ªå¥å­ï¼Œå®ƒä½¿ç”¨åœ¨ç‰¹å®šä»»åŠ¡ä¸Šè®­ç»ƒçš„åŒå‘LSTMæ¥åˆ›å»ºè¿™äº›åµŒå…¥ã€‚ BERTå…¨ç§°æ˜¯Bidirectional Encoder Representations from Transformersï¼Œå–äº†æ ¸å¿ƒå•è¯çš„é¦–å­—æ¯è€Œå¾—åï¼Œä»Žåå­—æˆ‘ä»¬èƒ½çœ‹å‡ºè¯¥æ¨¡åž‹ä¸¤ä¸ªæ ¸å¿ƒç‰¹è´¨ï¼šä¾èµ–äºŽTransformerä»¥åŠåŒå‘ã€‚ é¦–å…ˆä»‹ç»BERTçš„ä¸¤ç§åž‹å·ï¼š BERT BASEï¼šä¸ŽOpenAI Transformerçš„å°ºå¯¸ç›¸å½“ï¼Œæ€§ä»·æ¯”å¾ˆé«˜ï¼› BERT LARGEï¼šä¸€ä¸ªéžå¸¸åºžå¤§çš„æ¨¡åž‹ï¼Œå®ƒçš„æ€§èƒ½æœ€å¥½ï¼› ä¸€èˆ¬æ¥è¯´ä½¿ç”¨BASE ç‰ˆæœ¬å°±è¶³ä»¥ã€‚ é¢„è®­ç»ƒè¿‡ç¨‹BERTä¸ºäº†èƒ½å¤Ÿåœ¨å¤§è§„æ¨¡è¯­æ–™ä¸Šè¿›è¡Œæ— ç›‘ç£å­¦ä¹ ï¼Œéžå¸¸å·§å¦™çš„è®¾è®¡äº†ä¸¤ä¸ªé¢„è®­ç»ƒä»»åŠ¡ï¼šä¸€ä¸ªæ˜¯éšæœºé®è”½ï¼ˆmaskï¼‰æŽ‰ä¸€ä¸ªå¥å­ä¸­çš„è¯ï¼Œåˆ©ç”¨ä¸Šä¸‹æ–‡è¿›è¡Œé¢„æµ‹ ï¼ˆæ¢å¥è¯è¯´ï¼Œä¸ºäº†è®­ç»ƒæ·±åº¦åŒå‘Transformerè¡¨ç¤ºï¼‰ï¼›å¦ä¸€ä¸ªæ˜¯é¢„æµ‹ä¸‹ä¸€ä¸ªå¥å­ï¼ˆç±»ä¼¼QAåœºæ™¯ï¼‰ BERT çš„ç›®æ ‡æ˜¯ç”Ÿæˆè¯­è¨€æ¨¡åž‹ï¼Œæ‰€ä»¥åªéœ€è¦ encoder æœºåˆ¶ã€‚Transformer çš„ encoder æ˜¯ä¸€æ¬¡æ€§è¯»å–æ•´ä¸ªæ–‡æœ¬åºåˆ—ï¼Œè€Œä¸æ˜¯ä»Žå·¦åˆ°å³æˆ–ä»Žå³åˆ°å·¦åœ°æŒ‰é¡ºåºè¯»å–ï¼Œè¿™ä¸ªç‰¹å¾ä½¿å¾—æ¨¡åž‹èƒ½å¤ŸåŸºæ–¼å•è¯çš„ä¸¤ä¾§å­¦ä¹ ï¼Œç›¸å½“äºŽæ˜¯ä¸€ä¸ªåŒå‘çš„åŠŸèƒ½ã€‚è¿™ä¸ªæ˜¯è§£å†³äº† word embeddingçš„é—®é¢˜ï¼Œä½†æ˜¯åœ¨å…¶ä»–çš„ä»»åŠ¡ä¸­ word2vec çš„ä½œç”¨æ˜¯æœ‰é™çš„ã€‚æ‰€ä»¥BERT æä¾›äº†ä¸¤ç§ç­–ç•¥ï¼š è’™é¢è¯­è¨€æ¨¡åž‹ï¼ˆNLMï¼šMasked Language Modelï¼‰å’Œ ä¸¤ä¸ªå¥å­çš„ä»»åŠ¡ï¼ˆTwo-sentence Tasksï¼‰ã€‚ æ¯”è¾ƒ ELMO å’ŒBERT: ä»Žç»“æž„ä¸Šæˆ‘ä»¬å¯ä»¥çœ‹å‡ºELMoçš„åŸºç¡€æ˜¯ä½¿ç”¨äº†LSTMï¼Œè€ŒBERTä½¿ç”¨äº†Transformerä½œä¸ºåŸºæœ¬æ¨¡åž‹ æ ¸å¿ƒçš„æ˜¯ä¸¤è€…çš„ç›®æ ‡å‡½æ•°æ˜¯ä¸ä¸€è‡´çš„ ELMO: $P \left( w _ { i } | w _ { 1 } , \ldots , w _ { i - 1 } \right) $ å’Œ $P \left( w _ { i } | w _ { i + 1 } , \ldots , w _ { n } \right)$ BERTï¼š$$P \left( w _ { i } | w _ { 1 } , \ldots , w _ { i - 1 } , w _ { i + 1 } , \ldots , w _ { n } \right)$$ æ‰€ä»¥BERT åœ¨è®­ç»ƒçš„æ—¶å€™å’Œ ELMO æ˜¯ä¸å¤ªä¸€æ ·çš„ï¼Œå‰è€…ä½¿ç”¨äº† masked LM tricks. Masked LM (MLM) Input:the man [MASK1] to [MASK2] storeLabel:[MASK1] = went; [MASK2] = store è¯¥ä»»åŠ¡å°±æ˜¯BERTä¸ºäº†åšåˆ°åŒå‘æ·±åº¦ä¸Šä¸‹æ–‡è¡¨ç¤ºè®¾è®¡çš„é¢„è®­ç»ƒtrickä»»åŠ¡ï¼Œè€Œåœ¨maskå•è¯çš„æ—¶å€™ï¼Œä½œè€…ä¹Ÿé‡‡ç”¨äº†ä¸€äº›æŠ€å·§ï¼ŒéšæœºmaskæŽ‰15%çš„tokenï¼Œæœ€ç»ˆçš„æŸå¤±å‡½æ•°åªè®¡ç®—maskæŽ‰çš„tokenã€‚è€Œå¯¹äºŽè¢«maskæŽ‰çš„è¯ä¹Ÿå¹¶éžç®€å•ç²—æš´çš„å°†å…¨éƒ¨æ›¿æ¢æˆ[MASK]æ ‡ç­¾å®Œäº‹ï¼Œä¼šéµå¾ªå¦‚ä¸‹æ­¥éª¤ï¼š 80%å³å¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼Œè¢«maskæŽ‰çš„è¯ä¼šè¢«[MASK]æ ‡ç­¾ä»£æ›¿ï¼› 10%çš„æƒ…å†µä¸‹ï¼Œå°†è¯¥è¯ç”¨ä¸€ä¸ªéšæœºçš„è¯æ›¿æ¢æŽ‰ï¼› 10%çš„æƒ…å†µä¸‹ï¼Œä¿ç•™è¯¥è¯åœ¨åŽŸä½ç½®ã€‚ è¿™æ ·åšçš„ç›®çš„æ˜¯åå‘ä»£è¡¨å®žé™…è§‚å¯Ÿåˆ°çš„è¯ã€‚å¦å¤–æ¨¡åž‹åœ¨é¢„è®­ç»ƒæ—¶ï¼ŒTransformerç¼–ç å™¨å¹¶ä¸çŸ¥é“å“ªäº›è¯è¢«maskæŽ‰äº†ï¼Œæ‰€ä»¥æ¨¡åž‹å¯¹æ¯ä¸ªè¯éƒ½ä¼šå…³æ³¨ã€‚åŒæ—¶ï¼Œå› ä¸ºéšæœºæ›¿æ¢ä»…å‘ç”Ÿåœ¨æ‰€æœ‰è¯çš„1.5ï¼…ï¼ˆå³15ï¼…*10ï¼…ï¼‰ï¼Œå¯¹æ¨¡åž‹çš„è¯­è¨€ç†è§£èƒ½åŠ›å½±å“å¾ˆå°ã€‚Transformerç¼–ç å™¨ä¸çŸ¥é“å®ƒå°†è¢«è¦æ±‚é¢„æµ‹å“ªäº›å•è¯ï¼Œæˆ–è€…å“ªäº›å·²ç»è¢«éšæœºå•è¯æ›¿æ¢ï¼Œå› æ­¤å®ƒå¿…é¡»å¯¹æ¯ä¸ªè¾“å…¥è¯ä¿æŒåˆ†å¸ƒå¼çš„ä¸Šä¸‹æ–‡è¡¨ç¤ºã€‚æ­¤å¤–ï¼Œç”±äºŽéšæœºæ›¿æ¢åœ¨æ‰€æœ‰è¯ä¸­åªå‘ç”Ÿ1.5%ï¼Œæ‰€ä»¥å¹¶ä¸ä¼šå½±å“æ¨¡åž‹å¯¹äºŽè¯­è¨€çš„ç†è§£ã€‚ Next Sentence Prediction (NSP) Input:the man went to the store [SEP] he bought a gallon of milkLabel:IsNextInput:the man went to the store [SEP] penguins are flightless birdsLabel:NotNext ç”±äºŽåœ¨LMçš„ä¸‹æ¸¸ä»»åŠ¡è¿˜ä¼šæ¶‰åŠåˆ°é—®ç­”ï¼ˆQuestion Answering (QA) ï¼‰å’ŒæŽ¨ç†ï¼ˆ Natural Language Inference (NLI)ï¼‰çš„ä»»åŠ¡ï¼Œè¿™éœ€è¦LMæœ‰ç†è§£å¥å­é—´å…³ç³»çš„èƒ½åŠ›ï¼Œæ‰€ä»¥ä½œè€…æ–°å¢žäº†ä¸€ä¸ªé¢„è®­ç»ƒä»»åŠ¡ï¼Œè¾“å…¥å¥å­Aå’ŒBï¼Œé¢„æµ‹Bæ˜¯å¦ä¸ºAçš„ä¸‹ä¸€ä¸ªå¥å­ï¼Œä»¥50%çš„æ¦‚çŽ‡é…å¯¹Aå’ŒBï¼Œå³50%Bæ˜¯çœŸçš„ï¼Œ50%Bæ˜¯éšæœºé€‰å–çš„ä¸€ä¸ªå¥å­ã€‚ æ‰€ä»¥ä½œè€…æç¤ºåœ¨é€‰å–é¢„è®­ç»ƒè¯­æ–™æ—¶ï¼Œè¦å°½å¯èƒ½é€‰å–document-levelçš„è¯­æ–™è€Œéžsegment-levelæ··åˆåœ¨ä¸€èµ·çš„è¯­æ–™ åœ¨ BERT çš„è®­ç»ƒè¿‡ç¨‹ä¸­ï¼Œæ¨¡åž‹æŽ¥æ”¶æˆå¯¹çš„å¥å­ä½œä¸ºè¾“å…¥ï¼Œå¹¶ä¸”é¢„æµ‹å…¶ä¸­ç¬¬äºŒä¸ªå¥å­æ˜¯å¦åœ¨åŽŸå§‹æ–‡æ¡£ä¸­ä¹Ÿæ˜¯åŽç»­å¥å­ã€‚åœ¨è®­ç»ƒæœŸé—´ï¼Œ50ï¼… çš„è¾“å…¥å¯¹åœ¨åŽŸå§‹æ–‡æ¡£ä¸­æ˜¯å‰åŽå…³ç³»ï¼Œå¦å¤– 50ï¼… ä¸­æ˜¯ä»Žè¯­æ–™åº“ä¸­éšæœºç»„æˆçš„ï¼Œå¹¶ä¸”æ˜¯ä¸Žç¬¬ä¸€å¥æ–­å¼€çš„ã€‚ åœ¨è®­ç»ƒ BERT æ¨¡åž‹æ—¶ï¼ŒMasked LM å’Œ Next Sentence Prediction æ˜¯ä¸€èµ·è®­ç»ƒçš„ï¼Œç›®æ ‡å°±æ˜¯è¦æœ€å°åŒ–ä¸¤ç§ç­–ç•¥çš„ç»„åˆæŸå¤±å‡½æ•°ã€‚ BERT æ¨¡åž‹çš„è¾“å…¥ è¾“å…¥è¡¨ç¤ºå¯ä»¥åœ¨ä¸€ä¸ªè¯åºåˆ—ä¸­è¡¨ç¤ºå•ä¸ªæ–‡æœ¬å¥æˆ–ä¸€å¯¹æ–‡æœ¬(ä¾‹å¦‚ï¼Œ[é—®é¢˜ï¼Œç­”æ¡ˆ])ã€‚å¯¹äºŽç»™å®šçš„è¯ï¼Œå…¶è¾“å…¥è¡¨ç¤ºæ˜¯å¯ä»¥é€šè¿‡ä¸‰éƒ¨åˆ†Embeddingæ±‚å’Œç»„æˆã€‚Embeddingçš„å¯è§†åŒ–è¡¨ç¤ºå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š token Embeddingsè¡¨ç¤ºçš„æ˜¯è¯å‘é‡ï¼Œç¬¬ä¸€ä¸ªå•è¯æ˜¯CLSæ ‡å¿—ï¼Œå¯ä»¥ç”¨äºŽä¹‹åŽçš„åˆ†ç±»ä»»åŠ¡ï¼Œå¯¹äºŽéžåˆ†ç±»ä»»åŠ¡ï¼Œå¯ä»¥å¿½ç•¥è¯å‘é‡ï¼› Segment Embeddingsç”¨æ¥åŒºåˆ«ä¸¤ç§å¥å­ï¼Œå› ä¸ºé¢„è®­ç»ƒä¸åªåšè¯­è¨€æ¨¡åž‹è¿˜è¦åšä»¥ä¸¤ä¸ªå¥å­ä¸ºè¾“å…¥çš„åˆ†ç±»ä»»åŠ¡ï¼› Position Embeddingsæ˜¯é€šè¿‡æ¨¡åž‹å­¦ä¹ å¾—åˆ°çš„ã€‚ åº”ç”¨BERT å¯ä»¥ä½¿ç”¨åœ¨å„ç§NLP ä»»åŠ¡ä¸­ï¼Œåªéœ€è¦åœ¨æ ¸å¿ƒæ¨¡åž‹ä¸­æ·»åŠ ä¸€ä¸ªå±‚ï¼Œæ¯”å¦‚ï¼š åœ¨åˆ†ç±»ä»»åŠ¡ä¸­ï¼Œä¾‹å¦‚æƒ…æ„Ÿåˆ†æžç­‰ï¼Œåªéœ€è¦åœ¨ Transformer çš„è¾“å‡ºä¹‹ä¸ŠåŠ ä¸€ä¸ªåˆ†ç±»å±‚ åœ¨é—®ç­”ä»»åŠ¡ï¼ˆä¾‹å¦‚SQUAD v1.1ï¼‰ä¸­ï¼Œé—®ç­”ç³»ç»Ÿéœ€è¦æŽ¥æ”¶æœ‰å…³æ–‡æœ¬åºåˆ—çš„ questionï¼Œå¹¶ä¸”éœ€è¦åœ¨åºåˆ—ä¸­æ ‡è®° answerã€‚ å¯ä»¥ä½¿ç”¨ BERT å­¦ä¹ ä¸¤ä¸ªæ ‡è®° answer å¼€å§‹å’Œç»“å°¾çš„å‘é‡æ¥è®­ç»ƒQï¼†Aæ¨¡åž‹ã€‚ åœ¨å‘½åå®žä½“è¯†åˆ«ï¼ˆNERï¼‰ä¸­ï¼Œç³»ç»Ÿéœ€è¦æŽ¥æ”¶æ–‡æœ¬åºåˆ—ï¼Œæ ‡è®°æ–‡æœ¬ä¸­çš„å„ç§ç±»åž‹çš„å®žä½“ï¼ˆäººå‘˜ï¼Œç»„ç»‡ï¼Œæ—¥æœŸç­‰ï¼‰ã€‚ å¯ä»¥ç”¨ BERT å°†æ¯ä¸ª token çš„è¾“å‡ºå‘é‡é€åˆ°é¢„æµ‹ NER æ ‡ç­¾çš„åˆ†ç±»å±‚ã€‚ å¥å­åˆ†ç±»å¦‚æžœä½¿ç”¨B ERT æ¨¡åž‹è¿›è¡Œå¥å­åˆ†ç±»ï¼Œé‚£ä¹ˆåœ¨è®­ç»ƒé˜¶æ®µæ¨¡åž‹å‘ç”Ÿçš„å˜åŒ–å¾ˆå°ï¼Œè¿™ä¸ªè¿‡ç¨‹ç§°ä¸ºå¾®è°ƒã€‚ æœºå™¨ç¿»è¯‘ äº‹å®žä¸ŠTransformeræ¯”LSTMæ›´å¥½åœ°å¤„ç†é•¿æœŸä¾èµ–æ€§ï¼Œä½¿å…¶éžå¸¸é€‚åˆæœºå™¨ç¿»è¯‘ã€‚ä»Žä¸€ç§è¯­è¨€åˆ°å¦ä¸€ç§è¯­è¨€çš„è½¬æ¢ã€‚ å‚è€ƒæ–‡çŒ® Transformer &amp; BERTBERTè§£æžåŠæ–‡æœ¬åˆ†ç±»åº”ç”¨ A simple but tough-to-beat baseline for sentence embeddingsTaking the average of the word embeddings in a sentence tends to give too much weight to words that are quite irrelevant, semantically speaking. Smooth Inverse Frequency tries to solve this problem in two ways: Weighting: like our tf-idf baseline above, SIF takes the weighted average of the word embeddings in the sentence. Every word embedding is weighted by a/(a + p(w)), where a is a parameter that is typically set to 0.001 and p(w) is the estimated frequency of the word in a reference corpus. (ä½¿ç”¨æ–°çš„è¯æƒé‡è®¡ç®—æ–¹æ³•ï¼Œä¸æ˜¯tf-idf, é¢‘çŽ‡è¶Šé«˜ï¼Œæƒé‡è¶Šä½Žï¼ŒæŠ‘åˆ¶é«˜é¢‘è¯) Common component removal: next, SIF computes the principal component of the resulting embeddings for a set of sentences. It then subtracts from these sentence embeddings their projections on their first principal component. This should remove variation related to frequency and syntax that is less relevant semantically.As a result, SIF downgrades unimportant words such as but, just, etc., and keeps the information that contributes most to the semantics of the sentence. ç¬¬ä¸€æ­¥ä¸­çš„$p(w) $ æ˜¯åœ¨è¯­æ–™ä¸­çš„è¯é¢‘ï¼Œç¬¬äºŒæ­¥ä¸­å¯¹æ•´ä¸ªå¥å­é›†åˆè¿›è¡Œä¸€æ¬¡PCAï¼Œç„¶åŽå¯¹æ¯ä¸ªå¥å­ä¸Šé¢å¾—åˆ°çš„å‘é‡å‡åŽ»å®ƒåœ¨ç¬¬ä¸€å¥‡å¼‚å‘é‡æˆ–è€…è¯´ä¸»æˆåˆ†ä¸Šçš„æŠ•å½±ã€‚æœ€åŽåˆæ­¥çš„å¥å­å‘é‡å‡åŽ»å¯¹åº”å¥å­å‘é‡çš„å…±æ€§æˆåˆ†(èµ·åˆ°å¹³æ»‘ä½œç”¨),å¾—åˆ°æœ€åŽçš„ç‹¬æœ‰çš„å¥å­å‘é‡(ä½¿å¾—å„ä¸ªå¥å­å‘é‡é—´çš„è€¦åˆåº¦é™ä½Ž,å¢žå¼ºå¥å­çš„é²æ£’æ€§).è€¦åˆæ€§è¶Šä½Žï¼ˆæ¨¡å—ä¹‹é—´çš„å…³è”æ€§è¶Šå°ï¼‰ ä½œç”¨ï¼š ç¬¬ä¸€æ­¥éª¤ä¸­çš„è¶…å‚æ•° $a $ æ˜¯ä¸€ç§å¹³æ»‘é¡¹ï¼Œå¯¹äºŽä½Žé¢‘è¯çš„æ”¯æŒï¼Œå‡ºçŽ°çš„æ¬¡æ•°å°‘ï¼Œåè€Œæƒé‡æ˜¯æ¯”è¾ƒå¤§çš„ï¼Œé™ä½Žå¸¸è§è¯çš„æƒé‡ã€‚$ ( \alpha p(w)) $,å…¶ä¸­$(p(w))$æ˜¯å•è¯ $(w) $åœ¨æ•´ä¸ªè¯­æ–™ä¸­å‡ºçŽ°çš„æ¦‚çŽ‡(è¯é¢‘è§’åº¦), $ (\alpha) $æ˜¯ä¸€ä¸ªè¶…å‚æ•°. è¿™æ ·, å³ä½¿å’Œ $ (c_s) $çš„å†…ç§¯å¾ˆå°, è¿™ä¸ªå•è¯ä¹Ÿæœ‰æ¦‚çŽ‡å‡ºçŽ°. ç¬¬äºŒæ­¥éª¤ä¸­çš„å‡åŽ» ä¸»æˆåˆ†ï¼Œå¯ä»¥ç†è§£ä¸ºè®©å„ä¸ªè¯å‘é‡æ›´å¥½çš„åˆ†å¼€ï¼Œå‡åŽ»å…¬å…±çš„éƒ¨åˆ†ï¼Œå‡å°‘è€¦åˆæ€§ï¼Œä½¿å¾—ç›¸ä¼¼çš„å¥å­èšç±»åœ¨ä¸€èµ·ã€‚å› ä¸ºè¿™ä¸ªä¸»æˆåˆ†æ˜¯æ•´ä¸ªè¯­æ–™åº“ä¸­çš„ä¸»æˆåˆ†. å¦å¤–è®ºæ–‡ä¸­è¿˜æåˆ°äº†è¿™ç§æ–¹æ³•çš„é²æ£’æ€§: ä½¿ç”¨ä¸åŒè¯­æ–™(å¤šç§é¢†åŸŸ)è®­ç»ƒå¾—åˆ°çš„ä¸åŒçš„word embedding, å‡å–å¾—äº†å¾ˆå¥½çš„æ•ˆæžœ, è¯´æ˜Žäº†å¯¹å„ç§è¯­æ–™çš„å‹å¥½. ä½¿ç”¨ä¸åŒè¯­æ–™å¾—åˆ°çš„è¯é¢‘, ä½œä¸ºè®¡ç®—è¯æƒé‡çš„å› ç´ , å¯¹æœ€ç»ˆçš„ç»“æžœå½±å“å¾ˆå°. å¯¹äºŽæ–¹æ³•ä¸­çš„è¶…å‚æ•°, åœ¨å¾ˆå¤§èŒƒå›´å†…, èŽ·å¾—çš„ç»“æžœéƒ½æ˜¯åŒºåŸŸä¸€ç›´çš„, å³è¶…å‚æ•°çš„é€‰æ‹©æ²¡æœ‰å¤ªå¤§çš„å½±å“. å°½ç®¡é•¿æœŸä»¥æ¥å¥å­çš„æ— ç›‘ç£è¡¨ç¤ºå­¦ä¹ æ˜¯ä¸»æµï¼Œæœ€è¿‘å‡ ä¸ªæœˆï¼ˆ2017å¹´æœ«/2018å¹´åˆï¼‰ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†è®¸å¤šéžå¸¸æœ‰è¶£çš„å·¥ä½œï¼Œæ˜¾ç¤ºäº†å‘ç›‘ç£å­¦ä¹ å’Œå¤šä»»åŠ¡å­¦ä¹ ï¼ˆä¸åŒçš„ä»»åŠ¡å­¦ä¹ åˆ°ä¸åŒçš„ç»´åº¦ï¼Œç„¶åŽç»„åˆï¼‰è½¬å‘çš„è¶‹åŠ¿ã€‚ å¼ºåŠ›/è¿…é€Ÿçš„åŸºçº¿ï¼šFastTextã€è¯è¢‹ï¼ˆBag-of-Wordsï¼‰ å½“å‰æœ€å…ˆè¿›æ¨¡åž‹ï¼šELMoã€Skip-Thoughtsã€Quick-Thoughtsã€ InferSentã€MILA/MSRçš„General Purpose Sentence Representationsã€Googleçš„Universal Sentence Encoder å…³äºŽnlp ä¸­çš„word embedding æ˜¯å¯ä»¥æœ‰ phrases, sentences, and paragraphs ä¸‰ä¸ªä¸åŒç±»åˆ«çš„ embeddingï¼Œæ‰€ä»¥è¿˜æ˜¯æŒºå¥½çš„ã€‚ ä¼˜ç‚¹ï¼š ç¨‹åºçš„è¿è¡Œåªéœ€è¦åå‡ åˆ†é’Ÿï¼Œæ•ˆæžœå’Œç¥žç»ç½‘ç»œæ˜¯ç›¸å½“çš„ å±žäºŽæ— ç›‘ç£çš„å­¦ä¹ ï¼Œå¯ä»¥å¯¹å¤§è§„æ¨¡çš„è¯­æ–™è¿›è¡Œåˆ©ç”¨ï¼Œç›¸å¯¹äºŽæœ‰ç›‘ç£çš„å­¦ä¹ æ–¹å¼ï¼Œè¿™ä¸ªæ˜¯ä¼˜åŠ¿ ç¼ºç‚¹ï¼š ç¼ºç‚¹å°±æ˜¯æ²¡æœ‰è€ƒè™‘å¥å­çš„è¯­åº,å¯¼è‡´ä¸èƒ½è¾¨åˆ«(â€œæˆ‘çˆ±ä½ â€è¿˜æ˜¯â€ä½ çˆ±æˆ‘â€), åªæ˜¯å­—æ„çš„è¡¨è¾¾ï¼Œå¹¶æ²¡æœ‰ä½“çŽ°äº†å¥æ„ å¯¹äºŽçŸ­æ–‡æœ¬ä¸Šçš„word2vecï¼Œ SIF æ•ˆæžœå¾ˆå¥½ï¼Œä½†æ˜¯æ¶‰åŠåˆ°è¯­æ„ç†è§£çš„æ—¶å€™ï¼Œè¿™ç§æ–¹å¼æ•ˆæžœå°±ä¸€èˆ¬äº†ï¼Œè€Œè¿™ä¸ªæ—¶å€™å°±åº”è¯¥ä½¿ç”¨ elmoï¼Œtransformer or bert ç­‰æ¨¡åž‹äº† Supervised Learning of Universal Sentence Representations from Natural Language Inference Dataæ–‡ç« æˆåŠŸçš„æ‰¾åˆ°äº†NLPé¢†åŸŸçš„ImageNet â€” SNLI (Stanford Natural Language Inference dataset), å¹¶ä¸”è¯•éªŒäº†ä¸åŒçš„æ·±åº¦å­¦ä¹ æ¨¡åž‹ï¼Œæœ€ç»ˆç¡®å®šbi-LSTM max pooled ä¸ºæœ€ä½³æ¨¡åž‹ã€‚ åŸŸ æ•°æ® ä»»åŠ¡ æ¨¡åž‹(ç¼–ç å™¨) CV ImageNet image classification Le-Net, VGG-Net, Google-Net, ResNet, DenseNet NLP SNLI NLI ? åŸºäºŽç›‘ç£å­¦ä¹ æ–¹æ³•å­¦ä¹ sentence embeddingså¯ä»¥å½’çº³ä¸ºä¸¤ä¸ªæ­¥éª¤ï¼šç¬¬ä¸€æ­¥é€‰æ‹©ç›‘ç£è®­ç»ƒæ•°æ®ï¼Œè®¾è®¡ç›¸åº”çš„åŒ…å«å¥å­ç¼–ç å™¨Encoderçš„æ¨¡åž‹æ¡†æž¶ï¼›ç¬¬äºŒæ­¥é€‰æ‹©ï¼ˆè®¾è®¡ï¼‰å…·ä½“çš„å¥å­ç¼–ç å™¨ï¼ŒåŒ…æ‹¬DANã€åŸºäºŽLSTMã€åŸºäºŽCNNå’ŒTransformerç­‰ã€‚ æ•°æ®é›†ï¼š æœ¬æ–‡é‡‡ç”¨çš„æ˜¯Stanford Natural Language Inference Datasetsï¼Œç®€ç§°SNLI ï¼ˆNLPé¢†åŸŸçš„ImageNet ï¼‰ã€‚SNLIåŒ…å«570Kä¸ªäººç±»äº§ç”Ÿçš„å¥å­å¯¹ï¼Œæ¯ä¸ªå¥å­å¯¹éƒ½å·²ç»åšå¥½äº†æ ‡ç­¾ï¼Œæ ‡ç­¾æ€»å…±åˆ†ä¸ºä¸‰ç±»ï¼šè•´å«ã€çŸ›ç›¾å’Œä¸­ç«‹ï¼ˆEntailmentã€contradiction and neutralï¼‰ã€‚ä¸‹é¢æ˜¯è¿™äº›æ•°æ®é›†çš„ä¸€ä¸ªä¾‹å­ï¼š ä»Žä¸Šå›¾å¯ä»¥çœ‹å‡ºï¼Œæ¯ä¸ªå¥å­å¯¹ä¸ºï¼ˆtext, hypothesisï¼‰,ä¸­é—´çš„judgmentsä¸ºå®ƒä»¬çš„æ ‡ç­¾ã€‚å¯ä»¥çœ‹åˆ°æ ‡ç­¾æ˜¯ç»¼åˆäº†5ä¸ªä¸“å®¶çš„æ„è§ï¼Œæ ¹æ®å°‘æ•°æœä»Žå¤šæ•°çš„åŽŸåˆ™å¾—åˆ°çš„ã€‚ 7ç§ä¸åŒçš„architecturesï¼š standard recurrent encoders with LSTM ï¼Œå–æœ€åŽä¸€ä¸ªéšçŠ¶æ€ standard recurrent encoders with GRU ï¼Œå–æœ€åŽä¸€ä¸ªéšçŠ¶æ€ä¸Šè¿°ä¸¤ç§æ˜¯åŸºç¡€çš„recurrent encoderï¼Œåœ¨å¥å­å»ºæ¨¡ä¸­é€šå¸¸å°†ç½‘ç»œä¸­çš„æœ€åŽä¸€ä¸ªéšè—çŠ¶æ€ä½œä¸ºsentence representationï¼› conncatenation of last hidden states of forward and backward GRUè¿™ç§æ–¹æ³•æ˜¯å°†å•å‘çš„ç½‘ç»œå˜æˆäº†åŒå‘çš„ç½‘ç»œï¼Œç„¶åŽç”¨å°†å‰å‘å’ŒåŽå‘çš„æœ€åŽä¸€ä¸ªçŠ¶æ€è¿›è¡Œè¿žæŽ¥ï¼Œå¾—åˆ°å¥å­å‘é‡ï¼› Bi-directional LSTMs (BiLSTM) with mean pooling Bi-directional LSTMs (BiLSTM) with max poolingè¿™ä¸¤ç§æ–¹æ³•ä½¿ç”¨äº†åŒå‘LSTMç»“åˆä¸€ä¸ªpoolingå±‚çš„æ–¹æ³•æ¥èŽ·å–å¥å­è¡¨ç¤ºï¼Œå…·ä½“å…¬å¼å¦‚ä¸‹ï¼š self-attentive networkè¿™ä¸ªç½‘ç»œåœ¨åŒå‘LSTMçš„åŸºç¡€ä¸ŠåŠ å…¥äº†attentionæœºåˆ¶ï¼Œå…·ä½“ç½‘ç»œç»“æž„å¦‚ä¸‹ï¼š hierarchical convolutional networks Now that we have discussed the various sentence encoding architectures used in the paper, letâ€™s go through the part of the network which takes these sentence embeddings and predicts the output label. After the sentence vectors are fed as input to this model, 3 matching methods are applied to extract relations between the text, u and hypothesis, v â€“ concatenation of the two representations (u, v) element-wise product u * v and, absolute element-wise difference |u â€“ v | The resulting vector captures information from both the text, u and the hypothesis, v, and is fed into a 3-class classifier consisting of multiple fully connected layers followed by a softmax layer. Universal Sentence Encoderè¿™ç¯‡æ–‡ç« åŸºäºŽInferSentï¼Œ ä¹Ÿæ˜¯æƒ³æ‰¾åˆ°ä¸€ä¸ªuniversal encoderã€‚ä¸åŒä¹‹å¤„åœ¨äºŽæ–‡ç« æŠŠInferSentçš„bi-lstmæ¢æˆäº†DANï¼ˆæˆ–è€…Transformer)ï¼Œè€Œä½¿ç”¨DANè¿™æ ·â€œç®€å•â€çš„encoderçš„æ•ˆæžœç«Ÿç„¶ç›¸å½“å¥½ï¼ˆå°¤å…¶æ˜¯æ—¶é—´å’Œå†…å­˜æ¶ˆè€—å’Œå…¶ä»–ç®—æ³•æ¯”å°å¾ˆå¤šã€‚ï¼‰ The Google Sentence Encoder is Googleâ€™s answer to Facebookâ€™s InferSent. It comes in two forms: an advanced model that takes the element-wise sum of the context-aware word representations produced by the encoding subgraph of a Transformer model. a simpler Deep Averaging Network (DAN) where input embeddings for words and bigrams are averaged together and passed through a feed-forward deep neural network.The Transformer-based model tends to give better results, but at the time of writing, only the DAN-based encoder was available. In contrast to InferSent, the Google Sentence Encoder was trained on a combination of unsupervised data (in a skip-thought-like task) and supervised data (the SNLI corpus). DANå…¶å®žDAN(Deep Averaging Networks)åº”è¯¥å±žäºŽBag of Wordsç±»çš„ç®—æ³•ã€‚å› ä¸ºæ¯”è¾ƒç‰¹æ®Šï¼Œå•ç‹¬åˆ—å‡ºæ¥ã€‚ å®ƒæ˜¯åœ¨å¯¹æ‰€æœ‰è¯è¯­å–å¹³å‡åŽï¼Œåœ¨ä¸Šé¢åŠ ä¸Šå‡ å±‚ç¥žç»ç½‘ç»œã€‚ç‰¹æ®Šçš„åœ°æ–¹åœ¨äºŽå®ƒåœ¨sentiment analysisä¸­è¡¨çŽ°ä¹Ÿä¸é”™ï¼Œè¿™åœ¨BOWç±»æ–¹æ³•ä¸­æ¯”è¾ƒç½•è§ã€‚ æ–°æ–¹æ³• ç±»åž‹ åŸºäºŽçš„æ—§ç®—æ³• è´¡çŒ® SIF æ— ç›‘ç£ BOW ä¸€ä¸ªç®€å•è€Œæœ‰æ•ˆçš„baselineç®—æ³• InferSent ç›‘ç£ NA æ‰¾åˆ°äº†NLPé¢†åŸŸçš„ImageNet â€“ SNLIï¼Œ å¹¶ç»™å‡ºäº†ä¸€ä¸ªstate-of-art ç®—æ³• P-mean æ— ç›‘ç£ BOW æ¯”SIFæ›´ç®€å•ä¸”æœ‰æ•ˆçš„ä¸€ä¸ªç®—æ³•ä¸”é€‚ç”¨äºŽcross-lingual Universal-sentence-encoder ç›‘ç£ InferSent æ›´åŠ ç®€å•çš„encoder æ–‡ç« å…±æå‡ºä¸¤ç§åŸºäºŽä¸åŒç½‘ç»œæž¶æž„çš„Universal Sentence Encoderï¼šTransformer and Deep Averaging Network (DAN).Our two encoders have different design goals. One based on the transformer architecture targets high accuracy at the cost of greater model complexity and resource consumption. The other targets efficient inference with slightly reduced accuracy. NLP æ˜¯å¦‚ä½•ä½“çŽ°äº†å¤šä»»åŠ¡è®­ç»ƒçš„ï¼Ÿ è¯¥ç¯‡è®ºæ–‡åœ¨å‰äººçš„ç ”ç©¶åŸºç¡€ä¸Šï¼Œç»¼åˆåˆ©ç”¨æ— ç›‘ç£è®­ç»ƒæ•°æ®å’Œæœ‰ç›‘ç£è®­ç»ƒæ•°æ®ï¼Œè¿›è¡Œå¤šä»»åŠ¡è®­ç»ƒï¼Œä»Žè€Œå­¦ä¹ ä¸€ä¸ªé€šç”¨çš„å¥å­ç¼–ç å™¨ã€‚æ— ç›‘ç£è®­ç»ƒæ•°æ®åŒ…æ‹¬é—®ç­”(QA)åž‹ç½‘é¡µå’Œè®ºå›ï¼ŒWikipedia, web newsï¼Œæœ‰ç›‘ç£è®­ç»ƒæ•°æ®ä¸ºSNLIã€‚å¤šä»»åŠ¡æ¨¡åž‹è®¾è®¡å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œå…¶ä¸­ç°è‰²çš„encoderä¸ºå…±äº«å‚æ•°çš„å¥å­ç¼–ç å™¨ã€‚ è®ºæ–‡å¯¹æ¯”äº†DANå’ŒTransfomerè¿™ä¸¤ç§ç¼–ç å™¨ã€‚å¾—å‡ºå¦‚ä¸‹ç»“è®ºï¼š Transformer æ¨¡åž‹åœ¨å„ç§ä»»åŠ¡ä¸Šçš„è¡¨çŽ°éƒ½ä¼˜äºŽç®€å•çš„ DAN æ¨¡åž‹ï¼Œä¸”åœ¨å¤„ç†çŸ­å¥å­æ—¶åªç¨æ…¢ä¸€äº›ã€‚ï¼ˆæ›´é«˜çš„ç²¾åº¦ï¼‰ DANæ¨¡åž‹ä¹Ÿèƒ½å…·æœ‰å¾ˆä¸é”™çš„è¡¨çŽ°ï¼Œå¹¶ä¸”ç›¸è¾ƒäºŽTransformeræ¨¡åž‹ï¼Œè®­ç»ƒæ—¶é—´å’Œå†…å­˜çš„å¼€é”€éƒ½æ›´å°ï¼Œå°¤å…¶æ˜¯å½“å¥å­è¾ƒé•¿æ—¶ã€‚ï¼ˆæ›´å¿«çš„é€Ÿåº¦ï¼‰ æ€»ç»“ï¼š Sentence Embeddingçš„è´¨é‡å¾€å¾€ç”±è®­ç»ƒæ•°æ®å’ŒEncoderå…±åŒå†³å®šã€‚Encoderä¸ä¸€å®šæ˜¯è¶Šå¤æ‚è¶Šå¥½ï¼Œéœ€è¦ä¾æ®ä¸‹æ¸¸ä»»åŠ¡ã€è®¡ç®—èµ„æºã€æ—¶é—´å¼€é”€ç­‰å¤šæ–¹é¢å› ç´ ç»¼åˆè€ƒè™‘ã€‚ BERTçš„ç†è§£è¯æ±‡æ‰©å±•ï¼š å¯¹äºŽè¯å‘é‡ä¸­ OOV é—®é¢˜çš„å¤„ç†æ–¹æ³•ï¼š å¦‚æžœä½¿ç”¨è¯å‘é‡åˆ†è¯çš„è¯ï¼Œä¸€ç§å¸¸è§çš„æ˜¯å­—èŠ‚ç»´åº¦ n-gram æ¨¡åž‹ï¼Œä¹Ÿå°±æ˜¯æŠŠä¸€ä¸ªå•è¯åˆ†æˆå¤šä¸ªéƒ¨åˆ†ï¼Œæ¯”å¦‚è¯´playing åˆ†æˆplay he ##ing ä¸¤ä¸ªtokenï¼Œè¿™ç§æ›´åŠ ç»†ç²’åº¦çš„åˆ’åˆ†æ˜¯ä¸€ç§å¸¸è§çš„å¤„ç†oov çš„æ–¹å¼ã€‚ ä½†æ˜¯åœ¨å·¥ä¸šç•Œï¼Œç»å¸¸ä½¿ç”¨å¤šä¸ªä¸åŒçš„è¯­è¨€æ¨¡åž‹å¾—åˆ°word2vecï¼Œ å¯ä»¥åˆ†æˆä¸¤ç±»ï¼Œä¸€ç±»æ˜¯é’ˆå¯¹è¯¥ä»»åŠ¡è®­ç»ƒçš„word2vecï¼Œä¸€ç±»æ˜¯åœ¨é€šç”¨çš„æ¨¡åž‹ä¸‹è¿›è¡Œè®­ç»ƒçš„word2vecï¼Œ å¹¶ä¸”å½“è¿™ç§è®­ç»ƒæ–¹æ³•ä¸åŒçš„æ—¶å€™ï¼Œæœ€åŽå¾—åˆ°çš„ç»“æžœä¹Ÿæ˜¯ä¸åŒçš„ã€‚é€šè¿‡ä¸åŒçš„ä»»åŠ¡è¿›è¡Œè¡¥å……ã€‚åœ¨ä¸€å®šç¨‹åº¦ä¸Šæ˜¯å¯ä»¥ç¼“è§£ oov é—®é¢˜çš„ã€‚ åœ¨å¥å­å‘é‡ä¸­è¿›è¡Œè¯æ±‡æ‰©å±•çš„æ–¹å¼ï¼šå¸¸è§çš„æ˜¯ä½¿ç”¨ word2vecçš„è¯å‘é‡æ¥è¿›è¡Œæ‰©å±•å¥å­å‘é‡ä¸­çš„è¯å‘é‡ã€‚ ELMo æ€è·¯æ˜¯ä½¿ç”¨åŒå‘RNN åœ¨å¤§é‡æœªæ ‡æ³¨æ•°æ®ä¸Šè®­ç»ƒè¯­è¨€æ¨¡åž‹ï¼Œå¯¹äºŽä¹‹åŽç‰¹å®šçš„ä»»åŠ¡ï¼Œæˆ‘ä»¬ä½¿ç”¨è¿™ä¸ªè¯­è¨€æ¨¡åž‹è¿›è¡Œç‰¹å¾æå–å¾—åˆ°è¾“å‡ºçš„å‘é‡ã€‚å’Œ word2vec ä¸åŒçš„æ˜¯ï¼Œè¿™ä¸ªembedding æ˜¯æœ‰ä¸Šä¸‹æ–‡çš„ã€‚æ¯”å¦‚è¯´ bankçš„embedding çš„ä¸Šä¸‹æ–‡å¦‚æžœæœ‰river é‚£ä¹ˆå°±æ˜¯æ°´è¾¹çš„æ„æ€ï¼›å¦‚æžœä¸Šä¸‹æ–‡æœ‰money é‚£ä¹ˆæ›´å¯èƒ½æ˜¯é“¶è¡Œçš„æ„æ€ã€‚ å®žçŽ°ï¼š åŸºäºŽlstm è¿›è¡Œå®žçŽ°çš„ï¼Œæ€»çš„loss æ˜¯å‰åŽä¸¤ä¸ªlossçš„ç›¸åŠ ï¼Œä¼˜åŒ–çš„æ—¶å€™ï¼Œä¸¤ä¸ªlstmçš„äº¤å‰ç†µåŠ èµ·æ¥æ˜¯æœ€å°çš„ã€‚ openai å‡ºçš„ GPT (generative pre-training)ï¼Œ å¾—åˆ°çš„è¯­è¨€æ¨¡åž‹ä¸­çš„å‚æ•°ä¸æ˜¯å›ºå®šçš„ï¼Œæ˜¯å¯ä»¥æ ¹æ®ç‰¹å®šçš„ä»»åŠ¡è¿›è¡Œå¾®è°ƒï¼Œä½¿å¾—è¯å‘é‡æ›´åŠ åŒ¹é…ç‰¹å®šçš„ä»»åŠ¡ã€‚æ€æƒ³ä¹Ÿæ˜¯å¾ˆç®€å•ï¼Œä½¿ç”¨transformerå­¦ä¹ ä¸€ä¸ªè¯­è¨€æ¨¡åž‹ï¼Œå¯¹å¥å­è¿›è¡Œæ— ç›‘ç£çš„embeddingï¼Œç„¶åŽæ ¹æ®ç‰¹å®šçš„ä»»åŠ¡å¯¹transformerçš„å‚æ•°è¿›è¡Œå¾®è°ƒã€‚ æ— ç›‘ç£çš„é¢„è®­ç»ƒï¼šæœ€åˆçš„æ—¶å€™ transformeræ˜¯ç”¨æ¥è¿›è¡Œæœºå™¨ç¿»è¯‘çš„ï¼Œencoder å¾—åˆ°çš„è¾“å‡ºè¾“å…¥åˆ°decoderä¸­åŽ»ã€‚ä½†æ˜¯åœ¨GPT ä¸­çš„æ¨¡åž‹ï¼Œencoder æ˜¯ç”¨æ¥é¢„æµ‹ä¸‹ä¸€ä¸ªè¯çš„ã€‚ä½†æ˜¯åŸºäºŽself-attentionçš„åŸºæœ¬ç»“æž„ï¼Œå®ƒæ˜¯èƒ½å¤Ÿçœ‹ä¸­å¿ƒè¯æ±‡å·¦å³ä¸¤è¾¹çš„ä¸Šä¸‹æ–‡ï¼Œè¿™ä¸ªç‰¹ç‚¹å’Œæƒ³è¦è¾¾åˆ°çš„ä»»åŠ¡æ˜¯ä¸ç¬¦åˆè¦æ±‚çš„ã€‚æ‰€ä»¥è¿™é‡Œä½¿ç”¨åˆ°äº† maskçš„åŽŸç†ï¼Œå°†ä¸­å¿ƒè¯åŽé¢çš„è¯æ±‡é®ä½ï¼Œç„¶åŽè¿›è¡Œè®­ç»ƒã€‚ æœ‰ç›‘ç£çš„fine-tuningå½“åªæœ‰ä¸€ä¸ªå¥å­ï¼ˆåˆ†ç±»é—®é¢˜ï¼‰ ä½¿ç”¨ç®€å•çš„åˆ†ç±»é—®é¢˜ä½œä¸ºä¸€ä¸ªä¾‹å­ï¼Œç»™å®šä¸€ä¸ªå¥å­(x1, â€¦xn)ï¼Œç„¶åŽç»™å®šæ ‡ç­¾ã€‚ç„¶åŽå†æœ€ä¸Šå±‚åŠ ä¸Šä¸€ä¸ªsoftmaxï¼Œä½¿ç”¨äº¤å‰ç†µæŸå¤±å‡½æ•°è®¡ç®—lossï¼Œä»Žè€Œæ ¹æ®æ•°æ®è°ƒæ•´ä¹‹å‰ transformer å’Œsoftmax ä¸­weights çš„å‚æ•°ã€‚ æœ¬æ¥æŒ‰ç…§elmo çš„æ€æƒ³ï¼Œæˆ‘ä»¬å¯ä»¥fixedï¼ˆå›ºå®šï¼‰encoder è¿™ä¸ªè¯­è¨€æ¨¡åž‹ä¸­çš„å‚æ•°ï¼Œç„¶åŽåªæ˜¯è®­ç»ƒæœ€åŽsoftmax ä¸­weights çš„å‚æ•°ï¼Œä½†æ˜¯è¿™é‡ŒåŒæ—¶åŽ»ä¼˜åŒ– encoder å’Œæœ€åŽsoftmax çš„å‚æ•°ï¼Œå°±ç±»ä¼¼ä¸€ç§å¤šä»»åŠ¡å­¦ä¹ ï¼ŒåŒæ—¶ä¼˜åŒ–äº†ä¸¤ä¸ªlossï¼Œå¹¶ä¸”è¿™ä¸¤ä¸ªloss ä¸­æ˜¯å¯ä»¥è®¾ç½®æƒé‡çš„ï¼Œæ‰€ä»¥ä»Žç†è®ºä¸Šè®²æ¨¡åž‹æ˜¯å…·æœ‰æ›´å¥½çš„æ³›åŒ–æ€§èƒ½çš„ã€‚ï¼ˆå¯¹äºŽå‰ä¸€ä¸ªloss çš„è®­ç»ƒï¼Œå› ä¸ºå‰è€…æ˜¯æ— ç›‘ç£çš„ï¼Œæ‰€ä»¥è¿™é‡Œåªæ˜¯ä½¿ç”¨äº†å…¶ä¸­çš„xï¼Œè€Œæ²¡æœ‰ä½¿ç”¨å…¶ä¸­çš„yï¼‰å¹¶ä¸”è®­ç»ƒé€Ÿåº¦ä¹Ÿä¼šæé«˜ï¼Œä¸ºä»€ä¹ˆè¿™ä¹ˆè¯´å‘¢ï¼Ÿå› ä¸ºæ˜¯åŸºäºŽå¤§çš„å·²ç»è®­ç»ƒå¥½çš„æ•°æ®é›†ä¸Šè¿›è¡Œfine tuneï¼Œå¾—åˆ°çš„ç»“æžœå¯ä»¥ç”¨ä¸ä¼šå¤ªå·®æ¥è¿›è¡Œæè¿°ï¼Œé‚£ä¹ˆä½ çš„loss ä¹Ÿä¼šç›¸åº”çš„ä¸ä¼šå¤ªå¤§ï¼Œæ‰€ä»¥éœ€è¦çš„è¿­ä»£çš„æ¬¡æ•°ä¹Ÿä¸ä¼šå¾ˆå¤šã€‚ å½“æœ‰ä¸¤ä¸ªå¥å­çš„æ—¶å€™ï¼ˆæ¯”å¦‚ç›¸ä¼¼åº¦çš„è®¡ç®—æˆ–è€…é—®ç­”ç³»ç»Ÿï¼‰ã€‚éœ€è¦ä½¿ç”¨ç‰¹æ®Šçš„æŠ€å·§å°†ä¸¤ä¸ªåºåˆ—å˜æˆä¸€ä¸ªè¾“å…¥åºåˆ—ã€‚ï¼ˆä¸Šé¢æœ‰ä¸ªå›¾æ˜¯å¯ä»¥éžå¸¸æ¸…æ¥šçš„å±•ç¤ºå¦‚ä½•å¤„ç†å¤šç§ä¸åŒè¾“å…¥ï¼‰ å¯¹äºŽåªæœ‰ä¸€ä¸ªåºåˆ—çš„ä»»åŠ¡ï¼Œå¯ä»¥åœ¨å‰åŽåŠ ä¸Šä¸¤ä¸ªç‰¹æ®Štokenï¼Œâ€startâ€ å’Œâ€extractâ€ï¼Œåˆ†åˆ«è¡¨ç¤ºå¼€å§‹å’Œç»“æŸï¼›å¯¹äºŽä¸¤ä¸ªåºåˆ—ï¼Œå¯ä»¥åœ¨ä¸­é—´åŠ ä¸Šä¸€ä¸ªç‰¹æ®Šçš„token, â€œdelimâ€ï¼Œè¾“å‡ºæ˜¯ä¸‰åˆ†ç±»æ ‡ç­¾ä¸­çš„ä¸€ä¸ªã€‚å¦‚æžœæ˜¯ç›¸ä¼¼åº¦è®¡ç®—ï¼Œå› ä¸ºå¯¹ç§°æ€§ï¼Œå¯ä»¥æŠŠä»–ä»¬äº¤æ¢é¡ºåºï¼Œç„¶åŽè¾“å…¥ä¸¤ä¸ªtransformerã€‚ å¥½ç»ˆäºŽè¿›å…¥äº†bert çš„å­¦ä¹ ï¼š é—®é¢˜ï¼š ä¼ ç»Ÿçš„ELMo æˆ–è€…GPT æœ€å¤§çš„é—®é¢˜æ˜¯è¯­è¨€æ¨¡åž‹æ˜¯å•å‘ï¼Œä¸åŒåŒæ—¶å¾—åˆ°å‰åŽä¸¤ä¸ªæ–¹å‘çš„ä¿¡æ¯ã€‚æ³¨æ„transformerä¸­çš„self-attention ä»Žç†è®ºä¸Šæ˜¯å¯ä»¥åŒæ—¶handle å‰åŽä¸Šä¸‹æ–‡çš„ï¼Œä½†æ˜¯è¿™é‡Œä½¿ç”¨äº†mask æœºåˆ¶ï¼Œæ‰€ä»¥è¿™ç§æ–¹å¼ä¹Ÿæ˜¯ä¸è¡Œçš„ã€‚é˜²æ­¢è¿‡æ‹Ÿåˆçš„æ–¹æ³•ï¼šé€šè¿‡å¯¹ç½‘ç»œç»“æž„çš„çº¦æŸï¼Œæ¯”å¦‚CNNçš„å±€éƒ¨ç‰¹æ•ˆï¼ŒRNNçš„æ—¶åºç‰¹æ•ˆï¼Œå¤šå±‚ç½‘ç»œçš„å±‚æ¬¡ç»“æž„ï¼Œå¯¹å®ƒè¿›è¡Œäº†å¾ˆå¤šçº¦æŸï¼Œä»Žè€Œä½¿å¾—èƒ½å¤Ÿæ”¶æ•›åˆ°æœ€ä½³çš„å‚æ•°ã€‚ è§£å†³æ–¹æ¡ˆï¼šåœ¨BERTä¹‹å‰ï¼ŒLM é€šå¸¸æ˜¯å•å‘çš„ï¼Œå¸¸è§çš„åšæ³•æ˜¯åˆ†åˆ«è®­ç»ƒæ­£å‘å’Œåå‘çš„LMï¼Œç„¶åŽå†åšä¸€ä¸ªensembleå¾—åˆ°çš„ä¸Šä¸‹æ–‡ç›¸å…³è¡¨ç¤ºã€‚è¿™æ ·çš„åšæ³•æ˜¯ä¼šæœ‰ä¿¡æ¯ç¼ºå¤±çš„é—®é¢˜çš„ã€‚ BERT æ˜¯ â€œBidirectional Encoder Representations from Transformersâ€ çš„ç¼©å†™ï¼ŒBè¡¨ç¤ºæ¨¡åž‹èƒ½å¤ŸåŒæ—¶åˆ©ç”¨å‰åŽä¸¤ä¸ªæ–¹å‘çš„ä¿¡æ¯ï¼Œè€ŒELMoå’ŒGPT åªèƒ½æ˜¯å•ä¸ªæ–¹å‘çš„ã€‚ è€Œbert ä»ç„¶ä½¿ç”¨çš„æ˜¯ transformeræ¨¡åž‹ï¼Œé‚£ä¹ˆæ˜¯å¦‚ä½•è§£å†³è¯­è¨€æ¨¡åž‹ä¸­çš„åªåˆ©ç”¨ä¸€ä¸ªæ–¹å‘çš„é—®é¢˜å‘¢ï¼Ÿå› ä¸ºbert ä¸æ˜¯æ™®é€šçš„è¯­è¨€æ¨¡åž‹ï¼Œè€Œæ˜¯ä¸€ç§mask è¯­è¨€æ¨¡åž‹ã€‚ bert çš„è¾“å…¥è¡¨ç¤ºï¼šè¾“å…¥æ˜¯ä¸¤ä¸ªå¥å­ï¼Œç„¶åŽæ˜¯å¯¹äºŽæ¯ä¸ªtoken è¿›è¡Œ3 ä¸ªembeddingï¼šè¯çš„embeddingï¼Œ ä½ç½®çš„embeddingå’Œsegment çš„embeddingã€‚è¯è¯­çš„embedding æ˜¯éžå¸¸å¸¸è§çš„ï¼Œä½ç½®embeddingå¼•å…¥äº†è¯è¯­çš„é¡ºåºä¿¡æ¯ï¼Œsegment çš„embeddingå¯ä»¥å­¦ä¹ åˆ°ä¸åŒçš„segmentçš„ä¿¡æ¯ã€‚ä½ç½®å‘é‡æ˜¯å› ä¸ºtransformer ä¸åƒä¼ ç»Ÿçš„RNN é‚£æ ·èƒ½å¤Ÿå¾ˆå¥½çš„å¤„ç†æ—¶åºï¼Œæ‰€ä»¥äººä¸ºåŠ å…¥äº†è¡¨ç¤ºä½ç½®çš„å‘é‡ã€‚ è¿™ç§æµ·é‡æ•°æ®è¿˜æ˜¯å¾ˆé‡è¦çš„ã€‚ bert æ¨¡åž‹æ˜¯éœ€è¦æœ‰ä¸€ä¸ªå›ºå®šçš„sequenceçš„é•¿åº¦ï¼Œæ¯”å¦‚è¯´æ˜¯128ï¼Œå¦‚æžœä¸å¤Ÿäº†ä¼špaddingï¼Œå¦‚æžœå¤šäº†ä¼šè¿›è¡Œè£å‰ªã€‚ Mask LM å’ŒNSP åˆ†åˆ«å¯¹åº”çš„æ˜¯è¯çº§åˆ«å’Œå¥å­çº§åˆ«çš„ä»»åŠ¡ï¼Œæ•ˆæžœå¾ˆå¥½ã€‚bertä¹Ÿæ˜¯ä¸€ç§è¯­è¨€æ¨¡åž‹ï¼Œåœ¨è¯­æ–™è®­ç»ƒè¿‡ç¨‹ä¸­ï¼Œæ˜¯æŠŠè¿™ä¸¤ä¸ªä»»åŠ¡çš„æŸå¤±å‡½æ•°ç›¸åŠ ï¼ŒåŒæ—¶å­¦ä¹ è¿™ä¸¤ä¸ªä»»åŠ¡ã€‚æ‰€ä»¥è¿™ä¸ªå°±æ˜¯ä¸€ç§å¤šä»»åŠ¡å­¦ä¹ æ–¹å¼ã€‚BERTæ˜¯é€šè¿‡ä¸¤ä¸ªè¾…åŠ©ä»»åŠ¡è®­ç»ƒè¯­è¨€æ¨¡åž‹ã€‚ Mask LMï¼ˆbert çš„ç¬¬ä¸€ä¸ªé‡ç‚¹ç»ˆäºŽæ¥äº†ï¼‰ maskè¯­è¨€æ¨¡åž‹ç±»ä¼¼å®Œå½¢å¡«ç©ºï¼Œç»™å®šä¸€ä¸ªå¥å­ï¼Œç„¶åŽæŠŠå…¶ä¸­çš„æŸä¸ªè¯é®æŒ¡èµ·æ¥ï¼Œè®©äººçŒœæµ‹å¯èƒ½çš„è¯è¯­ã€‚è¿™ä¸ªä¼šéšæœºmask 15%çš„è¯ï¼Œ ç„¶åŽè®©bert æ¥é¢„æµ‹è¿™äº›mask çš„è¯ï¼ŒåŒå½’è°ƒæ•´æ¨¡åž‹çš„å‚æ•°ä½¿å¾—æ¨¡åž‹é¢„æµ‹æ­£ç¡®çš„æ¦‚çŽ‡å°½å¯èƒ½çš„å¤§ï¼Œè¿™ä¸ªç­‰ä»·äºŽäº¤å‰ç†µçš„æŸå¤±å‡½æ•°ã€‚è¿™æ ·çš„transformeråœ¨ç¼–ç ä¸€ä¸ªè¯çš„æ—¶å€™ï¼ˆå¿…é¡»ï¼‰å‚è€ƒä¸Šä¸‹æ–‡çš„ä¿¡æ¯ã€‚ ä½†æ˜¯è¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯åœ¨pretraineing mask LM æ—¶å€™ä¼šå‡ºçŽ°ä¸€äº›ç‰¹æ®Šçš„tokenï¼Œä½†æ˜¯åœ¨fine-tuning æ—¶å€™å¹¶ä¸ä¼šå‡ºçŽ°ï¼Œè¿™ä¸ªæ—¶å€™å°±å‡ºçŽ°äº†mismatch çš„é—®é¢˜ã€‚å› æ­¤åœ¨bertä¸­ï¼Œå¦‚æžœæŸä¸ªtoken è¢«é€‰ä¸­ä¹‹åŽï¼Œ ä¼šéšæœºæŒ‰ç…§ä»¥ä¸‹çš„æ–¹å¼éšæœºçš„æ‰§è¡Œï¼š 80%éšæœºæ›¿æ¢æˆmask 10%æ›¿æ¢æˆéšæœºçš„ä¸€ä¸ªè¯ 10%æ¦‚çŽ‡æ›¿æ¢æˆå•è¯æœ¬èº« å› æ­¤ï¼Œå½“ä»–çœ‹åˆ°äº† [maskæˆ–è€…apple çš„æ—¶å€™ï¼Œå¼ºè¿«æ¨¡åž‹åœ¨ç¼–ç çš„æ—¶å€™ä¸èƒ½å¤ªä¾èµ–å½“æœŸçš„è¯ï¼Œè€Œæ˜¯è¦è€ƒè™‘ä¸Šä¸‹æ–‡ï¼Œç”šè‡³è¿›è¡Œä¸Šä¸‹æ–‡çš„â€œçº é”™â€ã€‚ é¢„æµ‹å¥å­å…³ç³»ï¼ˆbertæ¨¡åž‹ä¸­ç¬¬äºŒä¸ªè®­ç»ƒä»»åŠ¡ï¼‰ åœ¨é—®ç­”ä¸­ï¼Œå‰åŽä¸¤ä¸ªå¥å­æœ‰ä¸€å®šçš„å…³è”å…³ç³»ï¼Œæˆ‘ä»¬å¸Œæœ›bert pretraining çš„æ¨¡åž‹èƒ½å¤Ÿå­¦ä¹ åˆ°è¿™ç§å…³ç³»ã€‚å› æ­¤bert å¢žåŠ äº†ä¸€ç§æ–°çš„é¢å­¦ä¹ ä»»åŠ¡â€“é¢„æµ‹ä¸¤ä¸ªå¥å­æ˜¯å¦æœ‰å…³è”å…³ç³»ã€‚è¿™ä¸ªè®­ç»ƒé›†è¦æ±‚æ˜¯æ–‡ç« ï¼ˆæœ‰ä¸Šä¸‹æ–‡å…³ç³»çš„å¥å­ï¼‰ã€‚å¯¹äºŽè¿™ä¸ªä»»åŠ¡ï¼Œbert ä»¥50%çš„æ¦‚çŽ‡éšæœºæŠ½å–ä¸¤ä¸ªæ— å…³çš„å¥å­ï¼Œ50%çš„æ¦‚çŽ‡æŠ½å–æœ‰å…³è”çš„å¥å­ã€‚ï¼ˆè¿™ä¸ªå¥å­æ˜¯ç»è¿‡tokenå¤„ç†çš„å¥å­ï¼‰ å®žéªŒè¯æ˜Žè¯¥é¡¹ä»»åŠ¡æ˜¯å¯ä»¥æ˜Žæ˜¾ç»™QAå’ŒNLI ç±»ä»»åŠ¡å¸¦æ¥æå‡çš„ã€‚ fine-tuning å…±æœ‰å››ç§ä»»åŠ¡ï¼Œ ï¼ˆä½¿ç”¨è¿‡çš„æ˜¯ä¸¤ç§ä»»åŠ¡ï¼Œaå’Œbï¼Œåˆ†åˆ«è¿›è¡Œ sentence pair classification å’Œsingle sentence classificationï¼‰å¯¹äºŽæ™®é€šçš„åˆ†ç±»ä»»åŠ¡ï¼Œè¾“å…¥æ˜¯ä¸€ä¸ªåºåˆ—ï¼Œå¦‚å›¾å³ä¸Šæ‰€ç¤ºï¼Œæ‰€æœ‰çš„token éƒ½æ˜¯å±žäºŽåŒä¸€ä¸ªsegmentï¼Œç„¶åŽå†æ¨¡åž‹çš„æœ€åŽä¸€å±‚æŽ¥ä¸Šä¸€ä¸ªsoftmaxè¿›è¡Œåˆ†ç±»ï¼Œ ç”¨åˆ†ç±»æ•°æ®è¿›è¡Œfine tuning å¯¹äºŽç›¸ä¼¼åº¦è®¡ç®—ç­‰è¾“å…¥ä¸ºä¸¤ä¸ªåºåˆ—çš„ä»»åŠ¡ï¼Œè¿‡ç¨‹å¦‚å·¦ä¸Šæ‰€ç¤ºï¼›ä¸¤ä¸ªåºåˆ—çš„token æ˜¯å¯¹åº”ç€ä¸åŒçš„segment(id =0/1)ã€‚åœ¨æœ€åŽä¸€å±‚åŠ ä¸Šsoftmax è¿›è¡Œåˆ†ç±»ï¼Œç„¶åŽä½¿ç”¨åˆ†ç±»æ•°æ®è¿›è¡Œfine-tuning ç¬¬ä¸‰ç±»ä»»åŠ¡æ˜¯åºåˆ—æ ‡æ³¨ï¼Œæ¯”å¦‚å‘½åå®žä½“è¯†åˆ«ï¼Œä½¿ç”¨å³ä¸‹çš„æ–¹å¼è¿›è¡Œè®­ç»ƒã€‚ ç¬¬å››ç±»æ˜¯é—®ç­”ç±»é—®é¢˜ï¼Œè¾“å…¥æ˜¯ä¸€ä¸ªé—®é¢˜å’Œä¸€æ®µå¾ˆé•¿åŒ…å«ç­”æ¡ˆæ–‡å­—ï¼ˆparagraphï¼‰ï¼Œè¾“å‡ºåœ¨è¿™æ®µæ–‡å­—é‡Œæ‰¾åˆ°çš„é—®é¢˜çš„ç­”æ¡ˆã€‚ åœ¨å‚æ•°è®¾ç½®ä¸Šï¼Œä½œè€…å»ºè®®å¤§éƒ¨åˆ†çš„å‚æ•°ä¸ç”¨å˜ï¼Œåªæ˜¯ä¿®æ”¹batch sizeï¼Œ learning rate å’Œ number of epochs å°±å¯ä»¥äº†ï¼šbatch size: 16,32learning rate(adam): 5e-5, 3e-5, 2e-5number of epochs: 3, 4å¹¶ä¸”è®­ç»ƒæ•°æ®é›†è¶Šå¤§ï¼Œå¯¹è¶…å‚æ•°å°±è¶Šä¸æ•æ„Ÿï¼Œè€Œä¸”fine tune ä¸€èˆ¬æ¥è¯´æ”¶æ•›çš„æ˜¯æ¯”è¾ƒå¿«çš„ã€‚ å¯¹äºŽä¸­æ–‡æ¥è¯´ï¼Œbertå¯¹ä¸­æ–‡æä¾›çš„æ¨¡åž‹æ˜¯åŸºäºŽå­—çš„ï¼Œè€Œword2vec æ˜¯åŸºäºŽè¯çš„ï¼Œæ‰€ä»¥å½“word2vecçš„è¯å‘é‡æ•ˆæžœè¶Šå¥½ï¼Œé‚£ä¹ˆè¿™ä¸ªå·®è·æ˜¯è¶Šå¤§çš„ã€‚ æœ‰ç›‘ç£çš„æ¨¡åž‹æ•ˆæžœå¥½ï¼Œä½†æ˜¯æœ‰æ ‡ç­¾çš„æ•°æ®èŽ·å–éžå¸¸éš¾ã€‚ä¸€ç§æœ‰æ•ˆçš„è§£å†³æ–¹æ¡ˆæ˜¯é‡‡ç”¨å¤šä»»åŠ¡å­¦ä¹ (multi task learning MLT), ä¸€æ–¹é¢å¯ä»¥åœ¨æ•°æ®é›†æ ‡æ³¨è¾ƒå°‘çš„æƒ…å†µä¸‹åˆ©ç”¨å…¶å®ƒç›¸ä¼¼ä»»åŠ¡çš„æ ‡æ³¨æ•°æ®ï¼Œå¦ä¸€æ–¹é¢å¯ä»¥é™ä½Žé’ˆå¯¹ç‰¹å®šä»»åŠ¡çš„è¿‡æ‹Ÿåˆï¼Œèµ·åˆ°æ­£åˆ™åŒ–çš„ä½œç”¨ã€‚ Resnet, BERTéƒ½å‘Šè¯‰æˆ‘ä»¬ï¼š æ›´å¤§çš„æ•°æ®è§„æ¨¡ï¼Œæ›´å¤šæ ·æ€§çš„æ•°æ®å’Œæ›´é«˜çš„æ•°æ®è´¨é‡ã€‚æ•°æ®è¿˜æ˜¯æ¯”è¾ƒå…³é”®çš„ã€‚ bert æ¨¡åž‹çš„ç¼ºç‚¹ï¼š å¯¹äºŽç¯‡ç« çº§åˆ«çš„ä»»åŠ¡ï¼Œtransformerçš„è®¡ç®—é‡å¤æ‚ï¼Œé€Ÿåº¦æ˜¯å˜å¾—å¾ˆæ…¢ã€‚è§£å†³æ–¹æ¡ˆæ˜¯è¿›è¡Œé•¿è¾“å…¥çš„åˆ‡åˆ† ç½‘ç»œç»“æž„çš„è¿‡äºŽå¤æ‚ å¯¹äºŽä¸­æ–‡çš„æ”¹è¿›ï¼ˆä»Žå­—åˆ°è¯è¯­ çš„maskï¼‰ è¿™å‡ ç¯‡æ–‡ç« éƒ½æ˜¯å¯¹BERTæ¨¡åž‹çš„Pretrainingé˜¶æ®µçš„Maskè¿›è¡Œäº†ä¸åŒæ–¹å¼çš„æ”¹è¿›ã€‚ä¸ºäº†è§£å†³OOVçš„é—®é¢˜ï¼Œæˆ‘ä»¬é€šå¸¸ä¼šæŠŠä¸€ä¸ªè¯åˆ‡åˆ†æˆæ›´ç»†ç²’åº¦çš„WordPiece(ä¸ç†Ÿæ‚‰çš„è¯»è€…å¯ä»¥å‚è€ƒæœºå™¨ç¿»è¯‘Â·åˆ†è¯å’ŒWordpieceTokenizer)ã€‚BERTåœ¨Pretrainingçš„æ—¶å€™æ˜¯éšæœºMaskè¿™äº›WordPieceçš„ï¼Œè¿™å°±å¯èƒ½å‡ºçŽ°åªMaskä¸€ä¸ªè¯çš„ä¸€éƒ¨åˆ†çš„æƒ…å†µã€‚ ç®€å•è¯´åŽŸæ¥çš„bert æ¨¡åž‹å¯¹äºŽä¸­æ–‡æ˜¯åŸºäºŽå­—çš„ï¼Œ æ¯”å¦‚å¦‚ä½•mask æŽ‰çµç¶ä¸­çš„ä¸€ä¸ªå­—ï¼Œé‚£ä¹ˆæ¨¡åž‹æ˜¯å¾ˆå®¹æ˜“é¢„æµ‹ä¸‹ä¸€ä¸ªå­—çš„ã€‚æ‰€ä»¥ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå¾ˆè‡ªç„¶çš„æƒ³æ³•å°±æ˜¯æŠŠè¯ä½œä¸ºä¸€ä¸ªæ•´ä½“ï¼Œè¦ä¹ˆéƒ½mask æŽ‰ï¼Œè¦ä¹ˆä¸maskã€‚å½“ç„¶å‰ä¸ä¹…å“ˆå·¥å¤§å’Œç§‘å¤§è®¯é£žæ˜¯åšäº†è¿™æ–¹é¢çš„å·¥ä½œçš„ã€‚ ä½†æ˜¯å¯¹äºŽBERTæ¨¡åž‹æœ¬èº«(åŸºäºŽMask LMçš„Pretrainingã€Transformeræ¨¡åž‹å’ŒFine-tuning)æ²¡æœ‰åšä»»ä½•ä¿®æ”¹ã€‚ åŽŸæ–‡é“¾æŽ¥ transformer çš„ç†è§£Transformer å…¶é‡‡ç”¨ Self Attention æ¥å­¦ä¹ åºåˆ—çš„è¡¨ç¤º, å…·ä½“çš„æ˜¯: Scaled Dot-Product Attention. ä¸ºè§£å†³ä½ç½®ä¿¡æ¯ (Position Information) ä¸¢å¤±é—®é¢˜, æ¨¡åž‹å°† Positional Encpding ä¸Ž Input Embedding ç»“åˆï¼›ä¸ºé˜²æ­¢ decoder ä¸­åŽç»­ä½ç½® (æ¨¡åž‹å¯å¹¶è¡Œè®¡ç®—) å¯¹å‰é¢ä½ç½®çš„å½±å“, æ¨¡åž‹åœ¨ decoder ä¸­ä½¿ç”¨äº† Mask ä»¥ä½¿ä½ç½® ii å¤„çš„é¢„æµ‹åªä¾èµ–äºŽå‰é¢çš„è¾“å‡º. Transformerç”±ä¸”ä»…ç”±self-Attenionå’ŒFeed Forward Neural Networkç»„æˆã€‚ä¸€ä¸ªåŸºäºŽTransformerçš„å¯è®­ç»ƒçš„ç¥žç»ç½‘ç»œå¯ä»¥é€šè¿‡å †å Transformerçš„å½¢å¼è¿›è¡Œæ­å»º.ä½œè€…çš„å®žéªŒæ˜¯é€šè¿‡æ­å»ºç¼–ç å™¨å’Œè§£ç å™¨å„6å±‚ï¼Œæ€»å…±12å±‚çš„Encoder-Decoder(è¿™ä¸ªåªæ˜¯ä¸€ä¸ªé€šç”¨çš„æ¡†æž¶ï¼Œå®žé™…ä¸Šæ˜¯å¯ä»¥æ ¹æ®è‡ªå·±çš„éœ€æ±‚è¿›è¡Œä¸åŒçš„å±‚çš„å¢žå‡) Multi-Head Attentionç›¸å½“äºŽ å¤šä¸ªä¸åŒçš„self-attentionçš„é›†æˆï¼ˆensembleï¼‰ã€‚ å¦‚ä½•è¡¨ç¤ºä½ç½®ä¿¡æ¯ï¼Ÿ å¸¸è§çš„æ¨¡å¼æœ‰ï¼ša. æ ¹æ®æ•°æ®å­¦ä¹ ï¼›b. è‡ªå·±è®¾è®¡ç¼–ç è§„åˆ™ã€‚åœ¨è¿™é‡Œä½œè€…é‡‡ç”¨äº†ç¬¬äºŒç§æ–¹å¼ã€‚ç¼–ç å…¬å¼å¦‚ä¸‹ï¼š $$P E(\text { pos, } 2 i)=\sin \left(\frac{\text { pos }}{10000^{\frac{2 i}{\text { model }}}}\right)$$ $$P E(p o s, 2 i+1)=\cos \left(\frac{p o s}{10000^{\frac{2 i}{d_{m o d e l}}}}\right)$$ å…¬å¼ä¸­ï¼š pos è¡¨ç¤ºè¿™ä¸ªword åœ¨å¥å­ä¸­çš„ä½ç½® $i $è¡¨ç¤º embeddingç»´åº¦ï¼Œæ¯”å¦‚ $d_{model}$ æ˜¯512ï¼Œé‚£ä¹ˆ $i$ å°±ä»Ž 1 åˆ°512. ä¸Šå¼ä¸­ï¼Œ$pos$ è¡¨ç¤ºå½“å‰å•è¯åœ¨å¥å­ä¸­çš„ä½ç½®ï¼Œå¯ä»¥çœ‹å‡ºå¯¹äºŽå¶æ•°ä½ï¼Œä½¿ç”¨æ­£å¼¦ç¼–ç ï¼Œå¯¹äºŽå¥‡æ•°ä½ä½¿ç”¨ä½™å¼¦ç¼–ç .ã€‚$d$ è¡¨ç¤ºæ¨¡åž‹çš„ç»´åº¦ã€‚é™¤äº†å•è¯çš„ç»å¯¹ä½ç½®ï¼Œå•è¯çš„ç›¸å¯¹ä½ç½®ä¹Ÿéžå¸¸é‡è¦ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆä½¿ç”¨æ­£å¼¦å’Œä½™å¼¦å‡½æ•°ã€‚æ ¹æ®å…¬å¼$\sin (\alpha+\beta)=\sin \alpha \cos \beta+\cos \alpha \sin \beta$ å’Œ$\cos (\alpha+\beta)=\cos \alpha \cos \beta-\sin \alpha \sin \beta$ï¼Œè¿™è¡¨æ˜Žä½ç½®$k+p$ çš„ä½ç½®å‘é‡å¯ä»¥è¡¨ç¤ºä¸ºä½ç½® $k$çš„ç‰¹å¾å‘é‡çš„çº¿æ€§å˜åŒ–ï¼Œè¿™ä¸ºæ¨¡åž‹æ•æ‰å•è¯ä¹‹é—´çš„ç›¸å¯¹ä½ç½®å…³ç³»æä¾›äº†éžå¸¸å¤§çš„ä¾¿åˆ©ã€‚ è°·æ­Œè¿˜ç‰¹æ„å°†è¿™ç§æ–¹å¼æž„é€ çš„å‘é‡å’Œå­¦ä¹ å¾—åˆ°çš„å‘é‡ä½œå¯¹æ¯”ï¼Œå‘çŽ°æ•ˆæžœæŽ¥è¿‘ï¼Œç„¶åŽè°·æ­Œå°±ç”¨è¿™ä¸ªæž„é€ å¼çš„ï¼Œå› ä¸ºè™½ç„¶æ•ˆæžœæŽ¥è¿‘ï¼Œä½†è¿™ç§æž„é€ å¼çš„æ›´èƒ½åœ¨ä½¿ç”¨ä¸­é€‚åº”ä¸åŒé•¿åº¦åºåˆ—ã€‚ å°†ä½ç½®å‘é‡å’Œè¯å‘é‡è¿›è¡ŒåŠ å’Œå¾—åˆ°æœ€ç»ˆè¾“å…¥å‘é‡ï¼Œæ‰€ä»¥å‰é¢æˆ‘ä»¬çœ‹åˆ°è¯å‘é‡å’Œä½ç½®å‘é‡ç»´åº¦æ˜¯ç›¸åŒçš„ã€‚ ä¸¤ç§mask æŠ€æœ¯ padding maskï¼šmaskå¯¹æŸäº›å€¼è¿›è¡ŒæŽ©ç›–ï¼Œä½¿å…¶ä¸äº§ç”Ÿæ•ˆæžœã€‚æˆ‘ä»¬æ¯æ¬¡æ‰¹å¤„ç†åºåˆ—çš„é•¿åº¦æ˜¯ä¸ä¸€æ ·çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦å¯¹é½ï¼Œå…·ä½“æ¥è¯´æ˜¯åœ¨è¾ƒçŸ­åºåˆ—ä¸­å¡«å……0. è€Œattentionæœºåˆ¶ä¸åº”è¯¥æŠŠæ³¨æ„åŠ›æ”¾åœ¨è¿™äº›ä½ç½®ä¸Šã€‚å…·ä½“åšæ³•æ˜¯è¿™äº›ä½ç½®ä¸ŠåŠ ä¸Šä¸€ä¸ªéžå¸¸å¤§çš„è´Ÿæ•°ï¼Œè¿™æ ·ç»è¿‡softmaxï¼Œè¿™äº›ä½ç½®çš„æ¦‚çŽ‡å°±ä¼šæŽ¥è¿‘0. åœ¨ encoder å’Œdecoder ä¸­éƒ½ä½¿ç”¨ã€‚ sequence maskï¼šæ˜¯ä¸ºäº†decoder ä¸èƒ½çœ‹è§æœªæ¥çš„ä¿¡æ¯ï¼Œè¿›è¡Œé¢„æµ‹çš„æ—¶å€™åªæ˜¯ä¾èµ–å‰$i$ ä¸ªå•è¯çš„ä¿¡æ¯ã€‚å…·ä½“åšæ³•ï¼Œäº§ç”Ÿä¸€ä¸ªä¸Šä¸‰è§’å½¢ï¼Œä¸Šä¸‰è§’å½¢å€¼å…¨éƒ¨ä¸º1ï¼Œä¸‹ä¸‰è§’å½¢å’Œå¯¹è§’çº¿éƒ½æ˜¯0ï¼Œä½œç”¨åœ¨åºåˆ—ä¸Šå°±å¯ä»¥è¾¾åˆ°ç›®çš„ã€‚åªæ˜¯åœ¨decoder ä¸­ä½¿ç”¨ã€‚ å¯¹äºŽ attention æœºåˆ¶çš„åˆ†ç±» å¯ä»¥ä»Žå¤šè§’åº¦å¯¹ Attention è¿›è¡Œåˆ†ç±»ï¼Œå¦‚ä»Žä¿¡æ¯é€‰æ‹©çš„æ–¹å¼ä¸Šï¼Œå¯ä»¥åˆ†ä¸º Soft attention å’Œ Hard attentionã€‚ä»Žä¿¡æ¯æŽ¥æ”¶çš„èŒƒå›´ä¸Šå¯åˆ†ä¸º Global attention å’Œ Local attentionã€‚ global attention ä¸­æ‰€æœ‰çš„ä¿¡æ¯éƒ½è¦å‚ä¸Žè®¡ç®—ï¼Œè¿™æ ·è®¡ç®—çš„å¼€é”€å°±æ¯”è¾ƒå¤§ï¼Œè€Œåˆ«å½“encoder çš„å¥å­æ¯”è¾ƒé•¿æ—¶ï¼Œå¦‚ä¸€æ®µè¯æˆ–ä¸€ç¯‡æ–‡ç« ã€‚æ‰€ä»¥æå‡ºäº† local attentionçš„æ¦‚å¿µ transformerä¸­æ˜¯æœ‰ä¸‰ç§attention æœºåˆ¶ Encoder ç”± 6 ä¸ªç›¸ä¹˜çš„ Layer å †å è€Œæˆï¼ˆ6å¹¶ä¸æ˜¯å›ºå®šçš„ï¼Œå¯ä»¥åŸºäºŽå®žé™…æƒ…å†µä¿®æ”¹ï¼‰ã€‚ ä»Žå›¾ä¸­å¯ä»¥çŸ¥é“ decoder æ˜¯æœ‰ä¸‰ç§ç½‘ç»œç»“æž„çš„ï¼Œ Diff_1ï¼šDecoder SubLayer-1 ä½¿ç”¨çš„æ˜¯ â€œmaskedâ€ Multi-Headed Attention æœºåˆ¶ï¼Œé˜²æ­¢ä¸ºäº†æ¨¡åž‹çœ‹åˆ°è¦é¢„æµ‹çš„æ•°æ®ï¼Œé˜²æ­¢æ³„éœ²ã€‚Diff_2ï¼šSubLayer-2 æ˜¯ä¸€ä¸ª encoder-decoder multi-head attentionã€‚Diff_3ï¼šLinearLayer å’Œ SoftmaxLayer ä½œç”¨äºŽ SubLayer-3 çš„è¾“å‡ºåŽé¢ï¼Œæ¥é¢„æµ‹å¯¹åº”çš„ word çš„ probabilities ã€‚ encoder-decoder multi-head attention ä¸­ 123456789101112131415class DecoderLayer(nn.Module): "Decoder is made of self-attn, src-attn, and feed forward (defined below)" def __init__(self, size, self_attn, src_attn, feed_forward, dropout): super(DecoderLayer, self).__init__() self.size = size self.self_attn = self_attn self.src_attn = src_attn self.feed_forward = feed_forward self.sublayer = clones(SublayerConnection(size, dropout), 3) def forward(self, x, memory, src_mask, tgt_mask): m = memory x = self.sublayer[0](x, lambda x: self.self_attn(x, x, x, tgt_mask)) x = self.sublayer[1](x, lambda x: self.src_attn(x, m, m, src_mask)) return self.sublayer[2](x, self.feed_forward) é‡ç‚¹åœ¨äºŽ x = self.sublayer1 self.src_attn æ˜¯ MultiHeadedAttention çš„ä¸€ä¸ªå®žä¾‹ã€‚query = xï¼Œkey = m, value = m, mask = src_maskï¼Œè¿™é‡Œxæ¥è‡ªä¸Šä¸€ä¸ª DecoderLayerï¼Œmæ¥è‡ª Encoderçš„è¾“å‡ºã€‚ï¼ˆm æ˜¯encoderçš„è¾“å‡ºï¼Œ x æ ‘decoder ä¸­çš„è¾“å‡ºï¼Œä¸»çº¿è¿˜æ˜¯è·Ÿç€m èµ°ï¼Œattentionæ˜¯æ±‚è§£çš„ m å’Œx çš„ç›¸å…³æ€§ï¼‰ åˆ°ç›®å‰ä½ç½® transformer ä¸­ä¸‰ç§ä¸åŒçš„attention éƒ½å·²ç»ä»‹ç»å®Œæ¯•ã€‚ æœ€åŽè¿˜æœ‰ä¸€ä¸ªå…¨è¿žæŽ¥åŠ ä¸Šä¸€ä¸ªsoftmax æ±‚probablyï¼Œç”¨æ¥çœ‹å“ªäº›è¯å‡ºçŽ°çš„æ¦‚çŽ‡æ˜¯æœ€å¤§çš„ã€‚ beam search or greedy searchï¼š å‰è€…æ˜¯ä¿ç•™k ä¸ªå€™é€‰é›†ï¼ŒåŽè€…åªä¿ç•™ä¸€ä¸ªã€‚ teacher forcing or scheduled samplingï¼š å‰è€…åœ¨ä¸‹ä¸€ä¸ªçš„è¾“å…¥ä½¿ç”¨çœŸå®žçš„æ ·æœ¬ï¼›åŽè€…æ˜¯å¼€å§‹çš„æ—¶å€™ä½¿ç”¨çœŸå®žçš„æ ·æœ¬ï¼Œåˆ°åŽæ¥åŠ ä¸Šäº†ç”Ÿæˆçš„æ ·æœ¬ã€‚ ç¬”è®°attention æœºåˆ¶æ˜¯å¯¹äºŽä¸åŒçš„è¯ï¼Œåœ¨å¤„ç†çš„æ—¶å€™ç»™äºˆä¸åŒçš„æƒé‡ã€‚æœ€åˆæ˜¯ä½¿ç”¨åœ¨æœºå™¨ç¿»è¯‘ä¸Šï¼Œå¯ä»¥ç”¨æ¥è§£å†³å¯¹é½é—®é¢˜ã€‚å¤šå¤´æ³¨æ„åŠ›æœºæ˜¯ç‚¹ä¹˜çš„å‡çº§ç‰ˆæœ¬ï¼Œç±»ä¼¼é›†æˆï¼ˆensembleï¼‰ çš„æ€æƒ³ï¼Œ ä¸åŒå­ç©ºé—´çš„èžåˆã€‚attention æœºåˆ¶å°±æ˜¯ä¸€ç§åŠ æƒå¹³å‡å’Œã€‚ SIF ä¸­ç¬¬ä¸€ä¸ªå…¬å¼ä¸­ $ \alpha$ æ˜¯ä¸€ä¸ªè¶…å‚æ•°ï¼Œä¸€ç§å¹³æ»‘é¡¹ï¼Œå¯¹äºŽä½Žé¢‘è¯çš„æ”¯æŒï¼Œå³ä½¿å‡ºçŽ°çš„æ¬¡æ•°å°‘ï¼Œä¹Ÿè¿˜æ˜¯æœ‰æƒé‡çš„ã€‚ è¯­åºã€è¯­ä¹‰å’Œä½ç½®ä¿¡æ¯ï¼Œè¿™ä¸ªéƒ½æ˜¯ç›¸åŒçš„å«ä¹‰çš„ä¸åŒè¡¨è¾¾ã€‚ transformer ç›¸å…³æ€»ç»“ transformer çš„ç»“æž„ï¼šencoder æ˜¯ç”±ç›¸åŒçš„6 ä¸ªå±‚ç»„æˆï¼Œæ¯ä¸ªå±‚æ˜¯ç”±å¤šå¤´è‡ªæˆ‘æ³¨æ„åŠ›æœºåˆ¶å’Œå…¨è¿žæŽ¥ç½‘ç»œç»„æˆï¼›å±‚å’Œå±‚ä¹‹é—´ä½¿ç”¨æ®‹å·®ç½‘ç»œè¿žæŽ¥ã€‚decoder ä¹Ÿæ˜¯ç”±ç›¸åŒçš„6ä¸ªå±‚ç»„æˆï¼Œdecoder æ˜¯ç”±masked å¤šå¤´æœºåˆ¶ï¼Œç”¨æ¥ä¿è¯é¢„æµ‹ç¬¬ $i$ ä¸ªä½ç½®çš„æ—¶å€™ï¼Œåªæ˜¯ä¾èµ–å°äºŽ$i$ çš„è¾“å…¥ã€‚å¤šå¤´attention æœºåˆ¶ï¼ŒåŽŸç†å¾ˆç®€å•ï¼Œæƒ³è¦ä»Žä¸åŒçš„æ–¹é¢ç»´åº¦å¤„ç†ä¿¡æ¯ï¼Œç±»ä¼¼CNNä¸­çš„filter çš„æ¦‚å¿µï¼Œå¯ä»¥å¾—åˆ°ä¸åŒè¯­ä¹‰ç©ºé—´æŠ•å°„æ–‡æœ¬ï¼Œç„¶åŽå°†å¤šä¸ªçŸ©é˜µè¿žåœ¨ä¸€èµ·ã€‚transformerä¸­ä½¿ç”¨padding mask å’Œsequence mask ä¸¤ç§mask æŠ€æœ¯ï¼Œå…¶ä¸­padding mask æ˜¯ä¸€ç§å¡«å……æŠ€æœ¯ï¼Œä½¿å¾—ä¸å®šé•¿çš„sequenceå˜æˆå®šé•¿çš„sequenceã€‚ï¼ˆä¸€ç§è§£è¯»æ–¹å¼æ˜¯è§„èŒƒåŒ–ï¼Œå¯ä»¥å¹¶è¡Œè®¡ç®—ï¼‰sequence mask æ˜¯ä¸ºäº†ä½¿å¾— decoder ä¸èƒ½çœ‹è§æœªæ¥çš„ä¿¡æ¯ã€‚ä¹Ÿå°±æ˜¯å¯¹äºŽä¸€ä¸ªåºåˆ—ï¼Œåœ¨ time_step ä¸º t çš„æ—¶åˆ»ï¼Œæˆ‘ä»¬çš„è§£ç è¾“å‡ºåº”è¯¥åªèƒ½ä¾èµ–äºŽ t æ—¶åˆ»ä¹‹å‰çš„è¾“å‡ºï¼Œè€Œä¸èƒ½ä¾èµ– t ä¹‹åŽçš„è¾“å‡ºã€‚å®žçŽ°çš„æ—¶å€™äº§ç”Ÿä¸€ä¸ªä¸Šä¸‰è§’çŸ©é˜µï¼Œä¸Šä¸‰è§’çš„å€¼å…¨ä¸º1ã€‚æŠŠè¿™ä¸ªçŸ©é˜µä½œç”¨åœ¨æ¯ä¸€ä¸ªåºåˆ—ä¸Šï¼Œå°±å¯ä»¥è¾¾åˆ°æˆ‘ä»¬çš„ç›®çš„ã€‚ transformer çš„è¾“å…¥å’Œè¾“å‡ºéƒ½æ˜¯è¯å‘é‡+ä½ç½®å‘é‡ã€‚å¯¹äºŽä½ç½®ä¿¡æ¯æœ‰ä¸¤ç§å¤„ç†æ‰‹æ®µï¼Œä¸€ç§æ˜¯é€šè¿‡ç½‘ç»œå­¦ä¹ ï¼Œä¸€ç§æ˜¯è®¾è®¡ç¼–ç è§„åˆ™ã€‚ä½œè€…ä½¿ç”¨çš„æ˜¯åŽè€…ã€‚ä½¿ç”¨å•è¯åœ¨å½“å‰å¥å­çš„ä½ç½®å’Œå•è¯çš„ç»´åº¦å¯¹å•è¯è¿›è¡Œä½ç½®ç¼–ç ï¼Œå¶æ•°ä½ç½®ä½¿ç”¨ $\sin$ ( å¥‡å‡½æ•°)å’Œå¥‡æ•°ä½ç½®ä½¿ç”¨ $\cosin$ (å¶å‡½æ•°)å‡½æ•°è®¡ç®—ä½ç½®ä¿¡æ¯ï¼Œç¼–ç æ˜¯ä¸€ä¸ªé•¿åº¦ä¸º$d_{\text {model}}$ çš„ç‰¹å¾å‘é‡ã€‚è¯¥å‘é‡é™¤äº†è€ƒè™‘ç»å¯¹ä½ç½®ï¼Œè¿˜å¯ä»¥è€ƒè™‘åˆ°å•è¯çš„ç›¸å¯¹ä½ç½®ã€‚å¤šå¤´attentionäº§ç”Ÿçš„å¤šä¸ªç»“æž„æ˜¯éœ€è¦å’Œ weightsçŸ©é˜µ ç›¸ä¹˜å¾—åˆ°åŽŸå§‹å¤§å°çš„çŸ©é˜µï¼Œç„¶åŽå†è¾“å…¥åˆ°ç½‘ç»œä¸­ã€‚ transformer çš„è®¡ç®—ä¸Šçš„ä¼˜åŠ¿ï¼Œä¹‹å‰çš„RNN æ˜¯åºåˆ—çº¿æ€§ç»“æž„ï¼Œå¥é¦–çš„ä¿¡æ¯è¦ç»è¿‡n æ¬¡RNN æ‰èƒ½åˆ°è¾¾å¥å°¾ï¼Œæ— æ³•å¹¶è¡Œè¿ç®—ã€‚è€Œself-attentionå¯ä»¥è¿žæŽ¥ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œæ‰€ä»¥å¯ä»¥è¿›è¡Œå¹¶è¡Œè¿ç®—ã€‚ batch normalization å’Œ layer normalization çš„åŒºåˆ«ï¼Ÿå‰è€…ä¾èµ–äºŽ batch sizeï¼Œç»å¸¸ä½¿ç”¨åœ¨CNN ä¸­ï¼Œæ˜¯ä¸åŒæ ·æœ¬åœ¨åŒä¸€ä¸ªç‰¹å¾ä¸Šçš„å½’ä¸€åŒ–ï¼›åŽè€…æ˜¯åœ¨æ ·æœ¬ä¸Šä¸åŒç‰¹å¾è¿›è¡Œçš„å½’ä¸€åŒ–ï¼Œç»å¸¸åœ¨RNNä¸­ä½¿ç”¨ã€‚æŠŠè¾“å…¥è½¬åŒ–æˆå‡å€¼ä¸º0æ–¹å·®ä¸º1çš„æ•°æ®ã€‚æˆ‘ä»¬åœ¨æŠŠæ•°æ®é€å…¥æ¿€æ´»å‡½æ•°ä¹‹å‰è¿›è¡Œnormalizationï¼ˆå½’ä¸€åŒ–ï¼‰ï¼Œå› ä¸ºæˆ‘ä»¬ä¸å¸Œæœ›è¾“å…¥æ•°æ®è½åœ¨æ¿€æ´»å‡½æ•°çš„é¥±å’ŒåŒºã€‚ ELMo (1 ) å¾—åˆ°çš„ç‰¹å¾æ˜¯æœ‰ä¸Šä¸‹æ–‡çš„ï¼Œæ¨¡åž‹ä¸Šä½¿ç”¨çš„æ˜¯bi-lstm è¿›è¡Œè®­ç»ƒã€‚å¥½å¤„ï¼Œå¯¹äºŽå¤šä¹‰è¯æœ‰ä¸åŒçš„embeddingï¼Œç¼“è§£äº†æ­§ä¹‰çš„å‘ç”Ÿã€‚å®žçŽ°ï¼šæ­£å‘ä¸€ä¸ªlossï¼Œåå‘ä¸€ä¸ªlossï¼Œç›¸åŠ ï¼Œç„¶åŽä¸€èµ·è¿›è¡Œæœ€å°åŒ–ã€‚ (2 ) ELMo ä¹Ÿå¼•å…¥äº†å­—ç¬¦çº§ä¿¡æ¯ï¼Œä¸ä»…ä¸°å¯Œäº†è¯å‘é‡çš„è¡¨è¾¾ï¼Œä¹Ÿå¾ˆå¤§ç¨‹åº¦ä¸Šè§£å†³äº†NLP é¢†åŸŸä¸­OOV é—®é¢˜ã€‚ OpenAI GPT åŸºäºŽ transformerå­¦ä¹ ä¸€ä¸ªè¯­è¨€æ¨¡åž‹ï¼Œå¯¹å¥å­è¿›è¡Œæ— ç›‘ç£çš„embeddingï¼Œç„¶åŽæ ¹æ®å…·ä½“çš„ä»»åŠ¡å¯¹å‚æ•°è¿›è¡Œå¾®è°ƒã€‚ BERT ä¸¤ä¸ªæ¯”è¾ƒå·§å¦™çš„é¢„è®­ç»ƒæ¨¡åž‹ï¼šmask learning (15% çš„æ¦‚çŽ‡æ˜¯è¢« mask æŽ‰çš„ï¼Œ 80%, 10%, 10% ) å’Œ predicting next sentence (50%)ã€‚é€šè¿‡è¿™ä¸¤ä¸ªæ¨¡åž‹åœ¨å¤§è¯­æ–™ä¸­è¿›è¡Œæ— ç›‘ç£çš„å­¦ä¹ ã€‚ bert çš„è¾“å…¥ï¼š (1) è¯å‘é‡ (2) segment embeddingç”¨æ¥åŒºåˆ«ä¸¤ä¸ªå¥å­ï¼Œå› ä¸ºbert è¯­è¨€æ¨¡åž‹è¿˜è¦åšä¸¤ä¸ªå¥å­è¾“å…¥çš„åˆ†ç±»æ¨¡åž‹ (3) position embedding é€šè¿‡å…¬å¼è®¡ç®—çš„ã€‚bert å’ŒELMo çš„åŒºåˆ«: (1) ELMo çš„åŸºç¡€æ˜¯LSTMï¼Œè€ŒBERTä½¿ç”¨ transformer ä½œä¸ºåŸºæœ¬æ¨¡åž‹(2) ç›®æ ‡å‡½æ•°ä¸åŒï¼ŒELMoæ˜¯ä¸¤ä¸ªå•ä¸ªloss çš„ç›¸åŠ ï¼ŒåŽè€…æ˜¯ç»™å®šä¸Šä¸‹æ–‡ï¼Œç„¶åŽé¢„æµ‹ä¸­å¿ƒè¯ï¼Œè¿™ç§æ˜¯åŒæ—¶çš„ã€‚ bert çš„ç¼ºç‚¹ï¼š bert å› ä¸ºè®¡ç®—é‡çš„å¤æ‚æ€§ï¼ˆç½‘ç»œç»“æž„è¿‡äºŽå¤æ‚ï¼‰ï¼Œæ‰€ä»¥é€Ÿåº¦ä¸Šä¼šå˜æ…¢ã€‚å› æ­¤å¯¹äºŽç¯‡ç« çº§åˆ«çš„å¤§æ–‡æœ¬ï¼Œé‚£ä¹ˆè‡³å°‘ä»Žæ•ˆçŽ‡ä¸Šä¸ä¼šå¾ˆé«˜ã€‚ï¼ˆä¸€ç§è§£å†³æ€è·¯æ˜¯å°†é•¿æ–‡æœ¬è¿›è¡Œåˆ‡åˆ†ï¼‰ æ•°æ®é›†è¶Šå¤§ï¼Œå¯¹äºŽè¶…å‚æ•°çš„é€‰æ‹©å°±å˜å¾—æ²¡æœ‰é‚£ä¹ˆæ•æ„Ÿã€‚]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pygen]]></title>
    <url>%2F2019%2F04%2F24%2Fpygen%2F</url>
    <content type="text"><![CDATA[pygenåŠŸèƒ½ï¼šæœ‰å…³è”çš„éšæœºç”Ÿæˆäººåï¼Œé‚®ç®±ï¼ŒID Card (ssn)ï¼Œç”µè¯ï¼Œåœ°å€ç­‰ä¿¡æ¯ï¼Œå¹¶ä¸”å¯ä»¥é€‰æ‹©ä¿å­˜ä¸º pandas dataframeæ ¼å¼, æ•°æ®åº“â€.dbâ€ æ–‡ä»¶, Excel æ–‡ä»¶å’Œcsv æ–‡ä»¶æ ¼å¼ï¼Œç”¨äºŽæœºå™¨å­¦ä¹ è®­ç»ƒã€‚é¡¹ç›®åœ°å€githubã€‚ éšæœºç”Ÿæˆè™šå‡ä¸ªäººä¿¡æ¯å…·æœ‰å¾ˆå¤§çš„åº”ç”¨ç©ºé—´ã€‚é¦–å…ˆï¼Œè™šå‡çš„ç”Ÿæˆæ•°æ®å¯ä»¥ç”¨äºŽæœºå™¨å­¦ä¹ æ¨¡åž‹çš„â€œå‡†å¤‡æ•°æ®â€ï¼Œå½“çœŸå®žçš„æ•°æ®æ¯”è¾ƒå°‘æˆ–è€…éš¾ä»¥èŽ·å¾—çš„æ—¶å€™ï¼Œå¯ä»¥ä½¿ç”¨ç”Ÿæˆæ•°æ®è¿›è¡Œè®­ç»ƒæ¨¡åž‹ï¼Œå¾…æ¨¡åž‹è°ƒé€šä¹‹åŽï¼Œç„¶åŽä½¿ç”¨çœŸå®žçš„æ¨¡åž‹ã€‚å¹¶ä¸”ï¼Œå½“çœŸå®žçš„æ•°æ®é›†ä¸­ç¼ºå°‘æŸäº›ç‰¹å¾æ—¶å€™ï¼Œå¯ä»¥ä½¿ç”¨è¿™ç§æ–¹æ³•è¿›è¡Œç‰¹å¾çš„å¡«å……ã€‚æ¯”å¦‚å¤§çš„æ•°æ®é›†ä¸­ç¼ºå°‘çŽ°å±…åŸŽå¸‚åœ°å€çš„æ—¶å€™ï¼Œå¯ä»¥è°ƒç”¨è¯¥åº“ä¸­çš„ â€œcity_realâ€ è¿›è¡Œå¡«å……ã€‚ å½“å‰ä½¿ç”¨æœ€ä¸ºå¹¿æ³›çš„æ˜¯ Faker å¼€æºåº“ç”¨äºŽä¸ªäººä¿¡æ¯çš„ç”Ÿæˆï¼Œå¯¹äºŽä¸­æ–‡å§“åã€é‚®ç®±ç”µè¯ç­‰ä¿¡æ¯æ”¯æŒæœ‰é™ã€‚å¹¶ä¸”ç”Ÿæˆçš„æ•°æ®æ˜¯å•åˆ—çš„ï¼Œæ•°æ®ä¹‹é—´æ²¡æœ‰è”ç³»ã€‚æ¯”å¦‚ç”Ÿæˆçš„èº«ä»½è¯ (ssn) å’Œå§“åæ‰€èƒ½ä½“çŽ°çš„æ€§åˆ«æ˜¯ä¸åŒ¹é…(äº†è§£æ›´å¤šå¯ä»¥å‚è€ƒè¿™é‡Œ)ã€ç”Ÿæˆçš„å§“åä¸­ç¼ºå°‘å¤å§“å’Œç”µè¯é‚®ç®±ç­‰ä¿¡æ¯ä¸ç¬¦åˆæˆ‘ä»¬çš„ä½¿ç”¨ä¹ æƒ¯ç­‰ç­‰ã€‚æ‰€ä»¥æˆ‘å°†ä»Žä»¥ä¸‹å‡ ç‚¹æ”¹è¿›ï¼š å¢žå¼ºæ•°æ®ä¹‹é—´ç›¸å…³æ€§ ç”Ÿæˆåå­—çš„å¤šæ ·æ€§ ç¬¦åˆå›½äººä½¿ç”¨ä¹ æƒ¯çš„é‚®ç®±ç”µè¯ æä¾›ä¿å­˜å¤šç§ä¿å­˜æ–‡ä»¶æ ¼å¼ï¼Œæ›´åŠ é€‚åˆæœºå™¨å­¦ä¹ çš„è®­ç»ƒ ä¸­æ–‡åå­—æœ‰å¾ˆå¼ºçš„æ€§åˆ«å±žæ€§ã€‚ä¾‹å¦‚åå­—ä¸­å¸¦æœ‰â€œæ°â€â€œå¿—â€â€œå®â€ç­‰å­—çš„ä¸€èˆ¬ä¸ºç”·æ€§ï¼Œå¸¦æœ‰â€œç¬â€â€œä½©â€â€œæ¢…â€ç­‰å­—çš„ä¸€èˆ¬ä¸ºå¥³æ€§ã€‚å½“ç„¶ä¹Ÿæœ‰ä¸€äº›æ¯”è¾ƒä¸­æ€§çš„å­—ï¼Œä¾‹å¦‚â€œæ–‡â€â€œå®‰â€â€œæ¸…â€ç­‰ï¼Œæ¯”è¾ƒéš¾çŒœæµ‹æ€§åˆ«ï¼Œå…³äºŽè¿™ç‚¹ä¼šåœ¨å¦ä¸€ä¸ªåšå®¢ä¸­å±•å¼€ï¼Œè¯·æœŸå¾…ã€‚ faker å¯¹ä¸­æ–‡çš„æ”¯æŒæœ‰é™ï¼Œæ¯”å¦‚ä¸‹é¢è¿™ç§æƒ…å†µã€‚ 1234from faker import Fakerfake = Faker('zh_CN')for _ in range(10): print(fake.name(),fake.ssn(),fake.phone_number()) ä»Žå›¾ä¸­å¯ä»¥æ˜Žæ˜¾çš„çœ‹å‡º â€œçŽ‹çŽ‰æ¢…â€å’Œ â€œæŽæ¡‚èŠ±â€éƒ½æ˜¯ä¸¤ä¸ªå¥³æ€§ï¼Œä½†æ˜¯è¿™ç§èº«ä»½è¯ä¿¡æ¯ï¼ˆssnï¼‰éƒ½æ²¡æœ‰ä½“çŽ°è¿™ç‚¹ã€‚å…³äºŽèº«ä»½è¯çš„ç§‘æ™®ä¿¡æ¯å¯ä»¥ä»Žè¿™é‡ŒèŽ·å¾—ã€‚ç®€å•æ¥è¯´å€’æ•°ç¬¬äºŒä½è¡¨ç¤ºæ€§åˆ«ä¿¡æ¯ï¼Œå¦‚æžœæ˜¯ç”·æ€§å°±æ˜¯å¥‡æ•°å¦‚æžœæ˜¯å¥³æ€§å°±æ˜¯å¶æ•°ã€‚faker ç”Ÿæˆçš„æ•°æ®æ˜¯ä¸å…·æœ‰æ•°æ®ä¹‹é—´çš„ç›¸å…³æ€§çš„ã€‚ åŸºäºŽæ­¤ï¼Œæˆ‘ä»¬è¿›è¡Œäº†æ”¹è¿›ã€‚é¦–å…ˆæ˜¯å§“åçš„ç”Ÿæˆï¼Œç„¶åŽæ˜¯æ€§åˆ«çš„åˆ¤æ–­ï¼Œæœ€åŽå†ç”Ÿæˆç›¸åº”æ€§åˆ«çš„èº«ä»½è¯å·ç ã€‚ 123from pygen import pygendb =pygen()db.gen_dataframe(fields =['name', 'ssn', 'phone', 'email']) æ•ˆæžœå¦‚ä¸‹ï¼š çº¢è‰²çº¿æ¡è¡¨ç¤ºå§“åå’Œæ€§åˆ«å¯¹åº”ä¸€è‡´ï¼Œè“è‰²çº¿æ¡è¡¨ç¤ºç»“æžœä¸ç¡®å®šï¼ˆâ€œé•œé˜³ç‚Žâ€ åƒæ˜¯ä¸€ä¸ªä¸­æ€§çš„åå­—ï¼‰ï¼Œç»¿è‰²è¡¨ç¤ºç”Ÿæˆäº†å«æœ‰å¤å§“çš„åå­—ï¼Œå¢žå¼ºäº†æ•°æ®çš„å¤šæ ·æ€§ã€‚ ä»Žä¸Šå›¾çš„ â€œmailâ€ ä¸€åˆ—å¯ä»¥çœ‹å‡ºé‚®ç®±å‰ç¼€çš„å‘½ååŸºæœ¬ä¸Šæ˜¯ä¸­æ–‡åå­—ä¸­â€œå§“â€ å’Œâ€œæ°‘â€çš„æ‹¼éŸ³ç»„åˆï¼ŒåŠ å¼ºäº†æ•°æ®ä¹‹é—´çš„ç›¸å…³æ€§å’ŒçœŸå®žåº¦ã€‚ å¦å¤–ï¼Œç”µè¯å·ç æŒ‰ç…§è¿è¥å•†åˆ†ä¸ºä¸‰ç±»ï¼š0 è¡¨ç¤ºç§»åŠ¨ï¼Œ1è¡¨ç¤ºè”é€šï¼Œ2è¡¨ç¤ºç”µä¿¡ã€‚ print(&apos;ç§»åŠ¨å­—æ®µ:&apos;) for _ in range(5): print(db.simple_ph_num(types =0)) print(&apos;è”é€šå­—æ®µ:&apos;) for _ in range(5): print(db.simple_ph_num(types =1)) print(&apos;ç”µä¿¡å­—æ®µï¼š&apos;) for _ in range(5): print(db.simple_ph_num(types =2)) è¾“å‡ºï¼š ç§»åŠ¨å­—æ®µ: 15023689929 16771753917 16790223946 15950129353 15271129554è”é€šå­—æ®µ: 13869739303 13786227031 13950354445 15137578545 15240836142ç”µä¿¡å­—æ®µï¼š 17172983067 15658567011 18562313243 17073127396 15543448286 æœ€åŽæä¾›äº†å¤šç§æ–‡ä»¶ä¿å­˜æ ¼å¼ï¼ŒåŒ…æ‹¬â€.csvâ€, â€œ.dbâ€ å’Œâ€.xlsxâ€ç­‰æ ¼å¼ã€‚å¯ä»¥ä½¿ç”¨å¦‚ä¸‹ï¼š12345from pygen import pygendb =pygen()db.gen_table(filename =filename, fields =[&apos;name&apos;, &apos;ssn&apos;, &apos;phone&apos;, &apos;email&apos;])db.gen_excel(filename =filename, fields =[&apos;name&apos;, &apos;ssn&apos;, &apos;phone&apos;, &apos;email&apos;])db.gen_csv(filename =filename, fields =[&apos;name&apos;, &apos;ssn&apos;, &apos;phone&apos;, &apos;email&apos;])]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>Data Enhancement</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mode Collapse in GANs]]></title>
    <url>%2F2019%2F04%2F18%2Fmode-collapse-in-gan%2F</url>
    <content type="text"><![CDATA[Mode collapse, a failure case for GANs where the generator generate a limited diversity of samples, regardless of the input. But what causes the mode collapse? There are four reasons for that. The objective of GANs The generator, generates new data, while the discriminator evaluates it for authenticity but not for the diversity of generated instances. the generator can win by producing a polynomial number of training examples. And a low capacity discriminator cannot detect this process, thus, it cannot guide the generator to approximate the target distribution. Even if a high discriminator identifies and assigns the collapse part a low probability, then the generator will simply move from its collapsed output to focus on another fixed output point. Generator No matter the objective function is, if it only considers individual samples (without looking forward or backward) then the generator is not directly incentivised to produce diverse examples. From [1], standard GAN training corresponds exactly to updating the generator parameters using only the first term in this gradient because of a fixed discriminator during GAN training. Therefore, in standard GAN training, each generator update step is a partial collapse towards a delta function. $$\frac { \mathrm { d } f _ { K } \left( \theta _ { G } , \theta _ { D } \right) } { \mathrm { d } \theta _ { G } } = \frac { \partial f \left( \theta _ { G } , \theta _ { D } ^ { K } \left( \theta _ { G } , \theta _ { D } \right) \right) } { \partial \theta _ { G } } + \frac { \partial f \left( \theta _ { G } , \theta _ { D } ^ { K } \left( \theta _ { G } , \theta _ { D } \right) \right) } { \partial \theta _ { D } ^ { K } \left( \theta _ { G } , \theta _ { D } \right) } \frac { \mathrm { d } \theta _ { D } ^ { K } \left( \theta _ { G } , \theta _ { D } \right) } { \mathrm { d } \theta _ { G } }$$ Some methods have been proposed. Multiple generators and weight-sharing generators are developed to capture more modes of the distribution. Discriminator The mode collapse is often explained as gradient exploding of discriminator, which comes from the imbalance between the discriminator and the generator. For example, the technique of TTUR could help discriminator to keep its optimality. But some researchers believe that this is a desirable goal since a good discriminator can give good feedback and ignore the fact. In addition, the discriminator process each example independently, the generator depends on discriminator, thus no mechanism to tell the outputs of the generator to become more similar to each other. The idea from [2], that we could use mini-batch discrimination to help generator give better feedback A straightforward approach to handle multimodality is to take random noise vectors along with the conditional contexts as inputs, where the contexts determine the main content and noise vectors are responsible for variations.The noise vectors are ignored or of minor impacts, since cGANs pay more attention to learn from the high-dimensional and structured conditional contexts. Another question Mode collapse may happen only partially?since training is stochastic progress, the input of generator network will vary and the sample drawn from the real distribution will also vary But sometimes mode collapse is not all bad news. In style transfer using GAN, we are happy to convert one image to just a good one, rather than finding all variants. Indeed, the specialization in the partial mode collapse sometimes creates higher quality images. referrences [1]. Section 2.4 of Unrolled Generative Adversarial Networks[2]. Section 3.2 of Improved Techniques for Training GANs[3]. Mode Seeking Generative Adversarial Networks for Diverse Image Synthesis[4]. Improving Generalization and Stability of Generative Adversarial Networks]]></content>
      <categories>
        <category>Deep learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[A Not-So-Gentle Introduction to Hyper-parameters Tuning]]></title>
    <url>%2F2019%2F04%2F17%2Fa-not-so-gentle-introduction-to-hyperparameters-tuning%2F</url>
    <content type="text"><![CDATA[Setting the hyper-parameters seems like a black art that requires years of experience to acquire. Currently, there are no simple and easy ways to set hyper-parameters, especifically, batch size, learning rate, momentum, and weight decay. A grid search or random search maybe sounds like a good idea. In this blog, Iâ€™d like to share you my idea from reading papers and my projects. Hyper-parametersBatch SizeLearning rate is maybe the most important hyper-parameters, but we choose batch size firstly because large batch size needs a large learning rate in most circumstances. A general principle is: use as a large batch size as possible to fit your CPU memory or/both GPU memory. There are several reasons: larger batch sizes permit the use of larger learning rates A constant number of iterations favors larger batch sizes However, small batch sizes add regularization while large batch sizes add less. So utilize it while balancing the proper amount of regularization. Learning RateWe will introduce the idea from [Cyclical Learning Rates for Training Neural Networks][1]: Cyclical Learning Rates. Instead of monotonically decreasing the learning rate, this method lets the learning rate cyclically vary between reasonable boundary values. The essence of this learning rate policy comes from the observation that increasing the learning rate might have a short term negative effect and yet achieve a longer term beneficial effect. This observation leads to the idea of letting the learning rate vary within a range of values rather than adopting a stepwise fixed or exponentially decreasing value. That is, one sets minimum and maximum boundaries and the learning rate cyclically varies between these bounds.%From Cyclical Learning Rates for Training Neural Networks An intuitive understanding of why CLR methods work comes from considering the loss function topology. Dauphin et al. argue that the difficulty in minimizing the loss arises from saddle points rather than poor local minima. Saddle points have small gradients that slow the learning process. However, increasing the learning rate allows for more rapid traversal of saddle point plateaus. But the question is that how can we find the Minimum bound and Maximum bound. There is a simple way to estimate the reasonable minimum and maximum boundary values with one training run of the network for a few epochs. It is a â€œLR range testâ€; run your model for several epochs while letting the learning rate increase linearly between low and high LR values. For example, set both the step size and maxiter to the same number of iterations. In this case, the learning rate will increase linearly from the minimum value to the maximum value during this short run. Next, plot the accuracy versus learning rate. Note the learning rate value when the accuracy starts to increase and when the accuracy slows, becomes ragged, or starts to fall. These two learning rates are good choices for bounds; that is, set $ lr_{base}$ to the first value and set $ lr_{max} $ to the latter value. MomentumSince learning rate is regarded as the most important hyper-parameter to tune then momentum is also important. Like learning rates, it is valuable to set momentum as large as possible without causing instabilities during training. The large learning rate can deal with local minimum but works fail when it comes to saddle point where momentum comes to rescue. The local minimum is like the following picture.In mathematics, a saddle point or minimax point is a point on the surface of the graph of a function where the slopes (derivatives) in orthogonal directions are all zero (a critical point), but which is not a local extremum of the function. Your first step from the very top would likely take you down, but then youâ€™d be on a flat rice terrace. The gradient would be zero, and youâ€™d have nowhere to go. To remedy this, we employ momentum - the algorithm remembers its last step and adds some psroportion of it to the current step. This way, even if the algorithm is stuck in a flat region, or a small local minimum, it can get out and continue towards the true minimum. In summary: when performing gradient descent, learning rate measures how much the current situation affects the next step, while momentum measures how much past steps affect the next step. Weights DecayWhen training neural networks, it is common to use â€œweight decay,â€ where after each update, the weights are multiplied by a factor slightly less than 1. This prevents the weights from growing too large and can be seen as gradient descent on a quadratic regularization term. But why? Large weights might correlate with certain patterns in the input data (x), this means that the model almost hard codes certain values. This then makes our training data fit well but our test data fit less well. The idea of weight decay is simple: to prevent overfitting, every time we update a weight $w$ with the gradient $âˆ‡J$ in respect to $w$, we also subtract from it $Î»âˆ™w$. This gives the weights a tendency to decay towards zero, hence the name. L2 is a type of weights decay.$$J ( W ; X , y ) + \frac { 1 } { 2 } \lambda \cdot | W | ^ { 2 }$$ But weights decay is not necessarily true for all gradient-base algorithms and was recently shown to not be the case for adaptive gradient algorithms, such as Adam. In addition, weight decay is not the only regularization technique. In the past few years, some other approaches have been introduced such as Dropout, Bagging, Early Stop, and Parameter Sharing which work very well in NNs. Takeoff Batch Size Use as a large batch size as possible to fit your memory Learning Rate Perform a learning rate range test to identify a â€œlargeâ€ learning rate. Momentum Test with short runs of momentum values 0.99, 0.97, 0.95, and 0.9 to get the best value for momentum. If using the 1-cycle learning rate schedule, it is better to use a cyclical momentum (CM) that starts at this maximum momentum value and decreases with increasing learning rate to a value of 0.8 or 0.85. Weights Decay A grid search to determine the proper magnitude but usually does not require more than one significant figure accuracy.A more complex dataset requires less regularization so test smaller weight decay values, such as $10^{âˆ’4} $, $10^{âˆ’5} $, $10^{âˆ’6} $, 0.A shallow architecture requires more regularization so test larger weight decay values, such as $10^{âˆ’2} $, $10^{âˆ’3} $, $10^{âˆ’4} $. References[1]. Cyclical Learning Rates for Training Neural Networks[2]. A disciplined approach to neural network hyper-parameters]]></content>
      <categories>
        <category>Deep learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Weights Initialization]]></title>
    <url>%2F2019%2F04%2F17%2Fweights-initialization%2F</url>
    <content type="text"><![CDATA[weights initialization çŸ¥è¯†ç‚¹ å’Œåˆ†äº«ä¸¤ä¸ªå›¾åƒé¢†åŸŸçš„æž¶æž„ï¼ˆresnet å’Œ inception v3ï¼‰ã€‚ Training a neural network consists of four steps: initialize weights and biases, forward propagation, compute the loss function and backward propagation. This blog mainly focuses on the first part: weights initialization. After completing this tutorial, you will know: Four main types of weights initialization How to choose between Xavier /zivier/ initialization and He initialization Types of Weights Initialization Initializing weights with zero When you set all weights in a neural network to zero, the derivative with respect to loss function is the same for every $ w$ in the same layer, thus all the weights have the same values in the subsequent iteration, which makes your model equivalent to a linear model. Initializing weights randomly You can get weights like this (Python): w =np.random.randn(layer_size[l],layer_size[l-1]) The weighs follows standard normal distribution while it can potentially lead to two issues: vanishing gradients and exploding gradients.ä¸‹é¢çš„æƒ…å†µæ˜¯å¾ˆå®¹æ˜“å‘ç”Ÿï¼Œå› ä¸ºç½‘ç»œä¸­ç‰¹å¾è¶³å¤Ÿå¤šï¼ˆç½‘ç»œç»“æž„è¶³å¤Ÿå®½ï¼‰ï¼Œæ‰€ä»¥ random å¾—åˆ°æ•°å€¼æœ‰è¶³å¤Ÿçš„ coverageï¼Œæ‰€ä»¥å°±ä¼šå‡ºçŽ° weights too small or too large è¿™ç§æƒ…å†µã€‚ If the weights start too small, then the signal shrinks as it passes through each layer until itâ€™s too small to be useful. If the weights start too large, then the signal grows as it passes through each layer until itâ€™s too massive to be useful (big value in sigmoid function). Thus there are two necessary conditions to consider: The values of each activation layer wonâ€™t be zero The values of each activation layer wonâ€™t go into the area of saturation Xavier/Glorot Initialization For deep networks, we can use a heuristic to initialize the weights depending on the non-linear activation function. This applies to Xavier and He initialization. Xavier/Glorot Initialization initializes the weights in your network by drawing them from a distribution with zero mean and a specific variance.$$ { var } ( w _ { i } ) = \frac { 1 } { layer_{l-1}}$$ w=np.random.randn(layer_size[l],layer_size[l-1])*np.sqrt(1/layer_size[l-1]) In practice, it works better for layers with sigmoid or tanh function. He Initialization Using RELU or Leaky RELU is relatively robust to the vanishing/ exploding gradient issues compared with sigmoid function especially for networks that are not too deep. And it the case of Leaky RELU, it never has zero gradients. For RELU, we multiply the randomly generated values of $w$ by: $$\sqrt { \frac { 2 } { layer _ { [ l - 1 ] } } }$$ w=np.random.randn(layer_size[l],layer_size[l-1])*np.sqrt(2/layer_size[l-1]) Sometimes, we combine the idea of Xavier initialization and He initializaiton so the variance becomes the following: $$\sqrt { \frac { 2 } { layer _ { [ l - 1 ] } + \operatorname { layer } _ { [ l ] } } }$$ w=np.random.randn(layer_size[l],layer_size[l-1])*np.sqrt(2/(layer_size[l-1]+layer_size[l])) The idea behind this is that we set the weights neither too much bigger than 1 nor too much less than 1 so the gradients do not vanish or explode too quickly. TakeoffIn summary, the main difference in machine learning is the following: He initialization works better for layers with ReLu(s) activation. Xavier initialization works better for layers with sigmoid activation. Referrence:He initialization Xavier initialization]]></content>
      <categories>
        <category>Deep learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hadoop And Spark]]></title>
    <url>%2F2019%2F04%2F15%2Fhadoop-spark%2F</url>
    <content type="text"><![CDATA[ä¸»è¦ä»‹ç» Hadoop å’Œ Spark çš„å…³ç³»å’Œè”ç³»ã€‚ Hadoopçš„æ¡†æž¶æœ€æ ¸å¿ƒçš„è®¾è®¡å°±æ˜¯ï¼šHDFSå’ŒMapReduceã€‚HDFSä¸ºæµ·é‡çš„æ•°æ®æä¾›äº†å­˜å‚¨ï¼Œåˆ™MapReduceä¸ºæµ·é‡çš„æ•°æ®æä¾›äº†è®¡ç®—ã€‚æ‰€ä»¥ä½¿ç”¨Hadoopåˆ™å¯ä»¥æŠ›å¼€sparkï¼Œè€Œç›´æŽ¥ä½¿ç”¨Hadoopè‡ªèº«çš„mapreduceå®Œæˆæ•°æ®çš„å¤„ç†ã€‚Sparkæ˜¯ä¸æä¾›æ–‡ä»¶ç®¡ç†ç³»ç»Ÿçš„ï¼Œä½†ä¹Ÿä¸æ˜¯åªèƒ½ä¾é™„åœ¨Hadoopä¸Šï¼Œå®ƒåŒæ ·å¯ä»¥é€‰æ‹©å…¶ä»–çš„åŸºäºŽäº‘çš„æ•°æ®ç³»ç»Ÿå¹³å°ï¼Œä½†sparké»˜è®¤çš„ä¸€èˆ¬é€‰æ‹©çš„è¿˜æ˜¯hadoopã€‚ HDFSæ˜¯ä¸€ä¸ªé‡‡ç”¨Master/Slaveæ¨¡å¼çš„é«˜åº¦å®¹é”™çš„åˆ†å¸ƒå¼æ–‡ä»¶ç³»ç»Ÿï¼ŒDataNodeèŠ‚ç‚¹ç”¨äºŽå­˜å‚¨æ•°æ®ï¼ŒNameNodeèŠ‚ç‚¹ç»´æŠ¤é›†ç¾¤å†…çš„å…ƒæ•°æ®ï¼ŒMapè´Ÿè´£å¯¹æ•°æ®è¿›è¡Œæ‰“æ•£ï¼ŒReduceè´Ÿè´£å¯¹æ•°æ®è¿›è¡Œèšåˆï¼Œæ ¸å¿ƒæ­¥éª¤ä¸ºï¼šé¦–å…ˆå°†è®¡ç®—æœºä»»åŠ¡æ‹†åˆ†æˆè‹¥å¹²ä¸ªMapä»»åŠ¡ï¼Œç„¶åŽåˆ†é…åˆ°ä¸åŒçš„èŠ‚ç‚¹ä¸Šæ‰§è¡Œï¼Œæ¯ä¸€ä¸ªMapä»»åŠ¡å¤„ç†æ•°æ®ä¸­çš„ä¸€éƒ¨åˆ†ï¼Œå®ŒæˆåŽç”Ÿäº§çš„çš„ä¸­é—´ç»“æžœï¼Œä¿å­˜åœ¨ç£ç›˜ä¸­ï¼ŒReduceå°†å‰é¢çš„è‹¥å¹²ä¸ªMapçš„è¾“å‡ºæ±‡æ€»åˆ°ä¸€èµ·è¾“å‡ºã€‚ Hadoopé›†ç¾¤ç”±ä¸€ä¸ªMasterä¸»èŠ‚ç‚¹å’Œè‹¥å¹²ä¸ªSlaveèŠ‚ç‚¹ç»„æˆã€‚å…¶ä¸­ï¼ŒMasterèŠ‚ç‚¹ä¸Šè¿è¡ŒNameNodeå’ŒJobTrackerå®ˆæŠ¤è¿›ç¨‹ï¼›SlaveèŠ‚ç‚¹ä¸Šè¿è¡ŒDataNodeå’ŒTaskTrackerå®ˆæŠ¤è¿›ç¨‹ã€‚ Namenodeæ˜¯æ•´ä¸ªæ–‡ä»¶ç³»ç»Ÿçš„ç®¡ç†èŠ‚ç‚¹ã€‚å®ƒç»´æŠ¤ç€1.æ•´ä¸ªæ–‡ä»¶ç³»ç»Ÿçš„æ–‡ä»¶ç›®å½•æ ‘ï¼Œ2.æ–‡ä»¶/ç›®å½•çš„å…ƒä¿¡æ¯å’Œæ¯ä¸ªæ–‡ä»¶å¯¹åº”çš„æ•°æ®å—åˆ—è¡¨ã€‚3.æŽ¥æ”¶ç”¨æˆ·çš„æ“ä½œè¯·æ±‚ã€‚ dataNodeæä¾›çœŸå®žæ–‡ä»¶æ•°æ®çš„å­˜å‚¨æœåŠ¡ã€‚ æ–‡ä»¶å—ï¼ˆblockï¼‰ï¼šæœ€åŸºæœ¬çš„å­˜å‚¨å•ä½ã€‚å¯¹äºŽæ–‡ä»¶å†…å®¹è€Œè¨€ï¼Œä¸€ä¸ªæ–‡ä»¶çš„é•¿åº¦å¤§å°æ˜¯sizeï¼Œé‚£ä¹ˆä»Žæ–‡ä»¶çš„ï¼åç§»å¼€å§‹ï¼ŒæŒ‰ç…§å›ºå®šçš„å¤§å°ï¼Œé¡ºåºå¯¹æ–‡ä»¶è¿›è¡Œåˆ’åˆ†å¹¶ç¼–å·ï¼Œåˆ’åˆ†å¥½çš„æ¯ä¸€ä¸ªå—ç§°ä¸€ä¸ªBlockã€‚ HDFSé»˜è®¤Blockå¤§å°æ˜¯128MBï¼Œä»¥ä¸€ä¸ª256MBæ–‡ä»¶ï¼Œå…±æœ‰256/128=2ä¸ªBlock. ä¸åŒäºŽæ™®é€šæ–‡ä»¶ç³»ç»Ÿçš„æ˜¯ï¼ŒHDFSä¸­ï¼Œå¦‚æžœä¸€ä¸ªæ–‡ä»¶å°äºŽä¸€ä¸ªæ•°æ®å—çš„å¤§å°ï¼Œå¹¶ä¸å ç”¨æ•´ä¸ªæ•°æ®å—å­˜å‚¨ç©ºé—´ã€‚ (è¿™æ ·è®¾ç½®å¯ä»¥å‡è½»namenodeåŽ‹åŠ›ï¼Œå› ä¸ºnamonodeç»´æŠ¤è€…æ–‡ä»¶ä¸Žæ•°æ®å—åˆ—è¡¨çš„å¯¹åº”å¤§å°) Replicationã€‚å¤šå¤æœ¬ã€‚é»˜è®¤æ˜¯ä¸‰ä¸ªã€‚ï¼ˆhdfs-site.xmlçš„dfs.replicationå±žæ€§ï¼‰ é¦–å…ˆäº†è§£ä¸€ä¸‹Mapreduceï¼Œå®ƒæœ€æœ¬è´¨çš„ä¸¤ä¸ªè¿‡ç¨‹å°±æ˜¯Mapå’ŒReduceï¼ŒMapçš„åº”ç”¨åœ¨äºŽæˆ‘ä»¬éœ€è¦æ•°æ®ä¸€å¯¹ä¸€çš„å…ƒç´ çš„æ˜ å°„è½¬æ¢ï¼Œæ¯”å¦‚è¯´è¿›è¡Œæˆªå–ï¼Œè¿›è¡Œè¿‡æ»¤ï¼Œæˆ–è€…ä»»ä½•çš„è½¬æ¢æ“ä½œï¼Œè¿™äº›ä¸€å¯¹ä¸€çš„å…ƒç´ è½¬æ¢å°±ç§°ä½œæ˜¯Mapï¼›Reduceä¸»è¦å°±æ˜¯å…ƒç´ çš„èšåˆï¼Œå°±æ˜¯å¤šä¸ªå…ƒç´ å¯¹ä¸€ä¸ªå…ƒç´ çš„èšåˆï¼Œæ¯”å¦‚æ±‚Sumç­‰ï¼Œè¿™å°±æ˜¯Reduceã€‚ spark çš„ä¼˜åŠ¿ æ¯ä¸€ä¸ªä½œä¸šç‹¬ç«‹è°ƒåº¦ï¼Œå¯ä»¥æŠŠæ‰€æœ‰çš„ä½œä¸šåšä¸€ä¸ªå›¾è¿›è¡Œè°ƒåº¦ï¼Œå„ä¸ªä½œä¸šä¹‹é—´ç›¸äº’ä¾èµ–ï¼Œåœ¨è°ƒåº¦è¿‡ç¨‹ä¸­ä¸€èµ·è°ƒåº¦ï¼Œé€Ÿåº¦å¿«ã€‚ï¼ˆå½¢æˆäº†ä¸€ä¸ªæœ‰å‘æ— çŽ¯å›¾ï¼‰ æ‰€æœ‰è¿‡ç¨‹éƒ½åŸºäºŽå†…å­˜ï¼Œæ‰€ä»¥é€šå¸¸ä¹Ÿå°†Sparkç§°ä½œæ˜¯åŸºäºŽå†…å­˜çš„è¿­ä»£å¼è¿ç®—æ¡†æž¶ã€‚ sparkæä¾›äº†æ›´ä¸°å¯Œçš„ç®—å­ï¼Œè®©æ“ä½œæ›´æ–¹ä¾¿ã€‚ æ›´å®¹æ˜“çš„APIï¼šæ”¯æŒPythonï¼ŒScalaå’ŒJava å…¶å®žsparké‡Œé¢ä¹Ÿå¯ä»¥å®žçŽ°Mapreduceï¼Œä½†æ˜¯è¿™é‡Œå®ƒå¹¶ä¸æ˜¯ç®—æ³•ï¼Œåªæ˜¯æä¾›äº†mapé˜¶æ®µå’Œreduceé˜¶æ®µï¼Œä½†æ˜¯åœ¨ä¸¤ä¸ªé˜¶æ®µæä¾›äº†å¾ˆå¤šç®—æ³•ã€‚å¦‚Mapé˜¶æ®µçš„map, flatMap, filter, keyByï¼ŒReduceé˜¶æ®µçš„reduceByKey, sortByKey, mean, gourpBy, sortç­‰ã€‚ Spark ç®—å­å¤§è‡´å¯ä»¥åˆ†ä¸ºä»¥ä¸‹ä¸¤ç±»:1.Transformation å˜æ¢/è½¬æ¢ç®—å­ï¼šè¿™ç§å˜æ¢å¹¶ä¸è§¦å‘æäº¤ä½œä¸šï¼Œå®Œæˆä½œä¸šä¸­é—´è¿‡ç¨‹å¤„ç†ã€‚2.Action è¡ŒåŠ¨ç®—å­ï¼šè¿™ç±»ç®—å­ä¼šè§¦å‘ SparkContext æäº¤ Job ä½œä¸šã€‚æ€Žä¹ˆåŒºåˆ†transformationç®—å­å’Œactionç®—å­å‘¢?transformationç®—å­ä¸€å®šä¼šè¿”å›žä¸€ä¸ªrdd,actionå¤§å¤šæ²¡æœ‰è¿”å›žå€¼,ä¹Ÿå¯èƒ½æœ‰è¿”å›žå€¼,ä½†æ˜¯ä¸€å®šä¸æ˜¯rdd. Spark ä¸­çš„RDDå°±æ˜¯ä¸ºäº†è§£å†³è¿™ç§é—®é¢˜è€Œå¼€å‘å‡ºæ¥çš„ï¼ŒSparkä½¿ç”¨äº†ä¸€ç§ç‰¹æ®Šè®¾è®¡çš„æ•°æ®ç»“æž„ï¼Œç§°ä¸ºRDDã€‚RDDçš„ä¸€ä¸ªé‡è¦ç‰¹å¾æ˜¯ï¼Œåˆ†å¸ƒå¼æ•°æ®é›†å¯ä»¥åœ¨ä¸åŒçš„å¹¶è¡ŒçŽ¯å¢ƒå½“ä¸­è¢«é‡å¤ä½¿ç”¨ï¼Œè¿™ä¸ªç‰¹æ€§å°†Sparkå’Œå…¶ä»–å¹¶è¡Œæ•°æ®æµæ¨¡åž‹æ¡†æž¶(å¦‚MapReduce)åŒºåˆ«å¼€ã€‚ RDD çš„ç®—å­ä¸»è¦åˆ†æˆ2ç±»ï¼Œaction å’Œ transformationã€‚è¿™é‡Œçš„ç®—å­æ¦‚å¿µï¼Œå¯ä»¥ç†è§£æˆå°±æ˜¯å¯¹æ•°æ®é›†çš„å˜æ¢ã€‚action ä¼šè§¦å‘çœŸæ­£çš„ä½œä¸šæäº¤ï¼Œè€Œ transformation ç®—å­æ˜¯ä¸ä¼šç«‹å³è§¦å‘ä½œä¸šæäº¤çš„ã€‚æ¯ä¸€ä¸ª transformation æ–¹æ³•è¿”å›žä¸€ä¸ªæ–°çš„ RDDã€‚åªæ˜¯æŸäº› transformation æ¯”è¾ƒå¤æ‚ï¼Œä¼šåŒ…å«å¤šä¸ªå­ transformationï¼Œå› è€Œä¼šç”Ÿæˆå¤šä¸ª RDDã€‚è¿™å°±æ˜¯å®žé™… RDD ä¸ªæ•°æ¯”æˆ‘ä»¬æƒ³è±¡çš„å¤šä¸€äº› çš„åŽŸå› ã€‚é€šå¸¸æ˜¯ï¼Œå½“é‡åˆ° action ç®—å­æ—¶ä¼šè§¦å‘ä¸€ä¸ªjobçš„æäº¤ï¼Œç„¶åŽåæŽ¨å›žåŽ»çœ‹å‰é¢çš„ transformation ç®—å­ï¼Œè¿›è€Œå½¢æˆä¸€å¼ æœ‰å‘æ— çŽ¯å›¾ã€‚ åˆ—ä¸¾ä¸€äº› Transformation å’Œ ActionTransformantion: Map, Filter, FlatMap, Sample, GroupByKey, ReduceByKey, Union, Join, Cogroup, MapValues, Sort, PartionBy Action: Collect, Reduce, Lookup, Save RDD çš„è½¬åŒ–æ“ä½œæ˜¯è¿”å›žä¸€ä¸ªæ–°çš„ RDD çš„æ“ä½œï¼Œæ¯”å¦‚ map() å’Œ filter() ï¼Œè€Œè¡ŒåŠ¨æ“ä½œåˆ™æ˜¯å‘é©±åŠ¨å™¨ç¨‹åºè¿”å›žç»“æžœæˆ–æŠŠç»“æžœå†™å…¥å¤–éƒ¨ç³»ç»Ÿçš„æ“ä½œï¼Œä¼šè§¦å‘å®žé™…çš„è®¡ç®—ï¼Œæ¯”å¦‚ count() å’Œ first() ã€‚Spark å¯¹å¾…è½¬åŒ–æ“ä½œå’Œè¡ŒåŠ¨æ“ä½œçš„æ–¹å¼å¾ˆä¸ä¸€æ ·ï¼Œå› æ­¤ç†è§£ä½ æ­£åœ¨è¿›è¡Œçš„æ“ä½œçš„ç±»åž‹æ˜¯å¾ˆé‡è¦çš„ã€‚å¦‚æžœå¯¹äºŽä¸€ä¸ªç‰¹å®šçš„å‡½æ•°æ˜¯å±žäºŽè½¬åŒ–æ“ä½œè¿˜æ˜¯è¡ŒåŠ¨æ“ä½œæ„Ÿåˆ°å›°æƒ‘ï¼Œä½ å¯ä»¥çœ‹çœ‹å®ƒçš„è¿”å›žå€¼ç±»åž‹ï¼šè½¬åŒ–æ“ä½œè¿”å›žçš„æ˜¯ RDDï¼Œè€Œè¡ŒåŠ¨æ“ä½œè¿”å›žçš„æ˜¯å…¶ä»–çš„æ•°æ®ç±»åž‹ã€‚ RDD ä¸­æ‰€æœ‰çš„ Transformation éƒ½æ˜¯æƒ°æ€§çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒä»¬å¹¶ä¸ä¼šç›´æŽ¥è®¡ç®—ç»“æžœã€‚ç›¸åçš„å®ƒä»¬åªæ˜¯è®°ä½äº†è¿™äº›åº”ç”¨åˆ°åŸºç¡€æ•°æ®é›†ï¼ˆä¾‹å¦‚ä¸€ä¸ªæ–‡ä»¶ï¼‰ä¸Šçš„è½¬æ¢åŠ¨ä½œã€‚åªæœ‰å½“å‘ç”Ÿä¸€ä¸ªè¦æ±‚è¿”å›žç»“æžœç»™ Driver çš„ Action æ—¶ï¼Œè¿™äº› Transformation æ‰ä¼šçœŸæ­£è¿è¡Œã€‚ è¿™ä¸ªè®¾è®¡è®© Spark æ›´åŠ æœ‰æ•ˆçš„è¿è¡Œã€‚ åŒºåˆ« æ•°æ®å¤„ç†é€Ÿåº¦ spark æ˜¯æ”¯æŒè®¸å¤šæœºå™¨å­¦ä¹ çš„æ¨¡åž‹(åˆ†ç±»ã€èšç±»ã€å›žå½’ã€ååŒè¿‡æ»¤)ï¼Œè€Œ hadoop ä¸­çš„MapReduce æ˜¯ä¸æ”¯æŒçš„. æ•°æ®å®‰å…¨æ¢å¤ï¼šHadoopæ¯æ¬¡å¤„ç†çš„åŽçš„æ•°æ®æ˜¯å†™å…¥åˆ°ç£ç›˜ä¸Šï¼Œæ‰€ä»¥å…¶å¤©ç”Ÿå°±èƒ½å¾ˆæœ‰å¼¹æ€§çš„å¯¹ç³»ç»Ÿé”™è¯¯è¿›è¡Œå¤„ç†ï¼›sparkçš„æ•°æ®å¯¹è±¡å­˜å‚¨åœ¨åˆ†å¸ƒäºŽæ•°æ®é›†ç¾¤ä¸­çš„å«åšå¼¹æ€§åˆ†å¸ƒå¼æ•°æ®é›†ä¸­ï¼Œè¿™äº›æ•°æ®å¯¹è±¡æ—¢å¯ä»¥æ”¾åœ¨å†…å­˜ï¼Œä¹Ÿå¯ä»¥æ”¾åœ¨ç£ç›˜ï¼Œæ‰€ä»¥sparkåŒæ ·å¯ä»¥å®Œæˆæ•°æ®çš„å®‰å…¨æ¢å¤ã€‚ åŸºäºŽå†…å­˜çš„Sparkå’ŒåŸºäºŽç£ç›˜çš„Hadoopä¹Ÿæ˜¯ä¸€ä¸ªåŒºåˆ«ã€‚ Sparkçš„æ ¸å¿ƒåœ¨äºŽRDDï¼Œå¯ä»¥ç†è§£ä¸ºåŒ…å«è®¸å¤šæ“ä½œæŽ¥å£çš„æ•°æ®é›†åˆï¼Œä¸»è¦æœ‰Transformationï¼ˆlazyï¼‰å’Œactionä¸¤ç±»ç®—å­ã€‚sparkæ ¹æ®RDDä¹‹é—´çš„ä¾èµ–å…³ç³»åˆ‡åˆ†æˆä¸åŒçš„é˜¶æ®µstage,RDDä¹‹é—´çš„è½¬æ¢çš„æ€æƒ³æ˜¯ lazyçš„ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸æ˜¯å®žé™…å‘ç”Ÿçš„ï¼Œè€Œæ˜¯ä»¥æœ‰å‘æ— çŽ¯å›¾çš„æ–¹å¼è®°å½•ï¼Œé€šè¿‡ä¸€ä¸ªActionç®—å­ï¼Œå°†ç§¯ç´¯çš„æ‰€æœ‰ç®—å­ä¸€æ¬¡æ€§æ‰§è¡Œã€‚ spark å’Œmapreduce çš„åŒºåˆ«ï¼š æ€§èƒ½ Sparkåœ¨å†…å­˜ä¸­å¤„ç†æ•°æ®ï¼Œè€ŒMapReduceæ˜¯é€šè¿‡mapå’Œreduceæ“ä½œåœ¨ç£ç›˜ä¸­å¤„ç†æ•°æ®ã€‚æ‰€ä»¥ä»Žè¿™æ–¹é¢è®²Sparkçš„æ€§èƒ½æ˜¯è¶…è¿‡MapReduceçš„ã€‚ä½†æ˜¯å½“æ•°æ®é‡æ¯”è¾ƒå¤§ï¼Œæ— æ³•å…¨éƒ¨è¯»å…¥å†…å­˜æ—¶ï¼ŒMapReduceå°±æ¯”è¾ƒæœ‰ä¼˜åŠ¿ã€‚å½“æ¶‰åŠéœ€è¦é‡å¤è¯»å–åŒæ ·çš„æ•°æ®è¿›è¡Œè¿­ä»£å¼è®¡ç®—çš„æ—¶å€™ï¼ŒSparkæ¯”è¾ƒæœ‰ä¼˜åŠ¿ï¼›ä½†æ˜¯å½“æ¶‰åŠåˆ°å•æ¬¡è¯»å–ï¼Œç±»ä¼¼ETLæ“ä½œä»»åŠ¡æ—¶ï¼Œé€‚åˆç”¨MapReduceè¿›è¡Œå¤„ç†ã€‚ å®¹é”™ å½“æ‰§è¡Œä¸­é€”å¤±è´¥æ—¶ï¼ŒMapReduceä¼šä»Žå¤±è´¥å¤„ç»§ç»­æ‰§è¡Œï¼Œå› ä¸ºå®ƒæ˜¯ä¾èµ–äºŽç¡¬ç›˜é©±åŠ¨å™¨çš„ã€‚ä½†æ˜¯Sparkå°±å¿…é¡»ä»Žå¤´å¼€å§‹æ‰§è¡Œï¼Œè¿™æ ·MapReduceç›¸å¯¹èŠ‚çœäº†æ—¶é—´ã€‚ åº”ç”¨åœºæ™¯ MapReduceä¸»è¦æ˜¯è¿›è¡Œç¦»çº¿è®¡ç®—å¤„ç†ï¼Œè®¡ç®—ä¸€äº›å·²å­˜åœ¨çš„æ•°æ®ï¼Œæ¯”å¦‚å¯¹å·²å­˜åœ¨çš„è®¢å•æˆ–è€…æ—¥å¿—è¿›è¡Œåˆ†æžã€‚è€ŒSparkå¯ä»¥åº”ç”¨åœ¨ä¸€äº›å®žæ—¶æŸ¥è¯¢å’Œè¿­ä»£åˆ†æžçš„åœºæ™¯ï¼Œæ¯”å¦‚åƒæŽ¨èç³»ç»Ÿã€‚ sparkçš„æœ‰å‡ ç§éƒ¨ç½²æ¨¡å¼ï¼Œæ¯ç§æ¨¡å¼ç‰¹ç‚¹ï¼Ÿ æœ¬åœ°æ¨¡å¼ Sparkä¸ä¸€å®šéžè¦è·‘åœ¨hadoopé›†ç¾¤ï¼Œå¯ä»¥åœ¨æœ¬åœ°ï¼Œèµ·å¤šä¸ªçº¿ç¨‹çš„æ–¹å¼æ¥æŒ‡å®šã€‚æ–¹ä¾¿è°ƒè¯•ï¼Œæœ¬åœ°æ¨¡å¼åˆ†ä¸‰ç±»localï¼šåªå¯åŠ¨ä¸€ä¸ªexecutorlocal[k]: å¯åŠ¨kä¸ªexecutorlocal[*]ï¼šå¯åŠ¨è·Ÿcpuæ•°ç›®ç›¸åŒçš„ executor standaloneæ¨¡å¼ åˆ†å¸ƒå¼éƒ¨ç½²é›†ç¾¤ï¼Œè‡ªå¸¦å®Œæ•´çš„æœåŠ¡ï¼Œèµ„æºç®¡ç†å’Œä»»åŠ¡ç›‘æŽ§æ˜¯Sparkè‡ªå·±ç›‘æŽ§ï¼Œè¿™ä¸ªæ¨¡å¼ä¹Ÿæ˜¯å…¶ä»–æ¨¡å¼çš„åŸºç¡€ Spark on yarnæ¨¡å¼ åˆ†å¸ƒå¼éƒ¨ç½²é›†ç¾¤ï¼Œèµ„æºå’Œä»»åŠ¡ç›‘æŽ§äº¤ç»™yarnç®¡ç†ç²—ç²’åº¦èµ„æºåˆ†é…æ–¹å¼ï¼ŒåŒ…å«clusterå’Œclientè¿è¡Œæ¨¡å¼cluster é€‚åˆç”Ÿäº§ï¼Œdriverè¿è¡Œåœ¨é›†ç¾¤å­èŠ‚ç‚¹ï¼Œå…·æœ‰å®¹é”™åŠŸèƒ½client é€‚åˆè°ƒè¯•ï¼Œdirverè¿è¡Œåœ¨å®¢æˆ·ç«¯ spark on yarn çš„æ”¯æŒä¸¤ç§æ¨¡å¼1ï¼‰yarn-clusterï¼šé€‚ç”¨äºŽç”Ÿäº§çŽ¯å¢ƒï¼›2ï¼‰yarn-clientï¼šé€‚ç”¨äºŽäº¤äº’ã€è°ƒè¯•ï¼Œå¸Œæœ›ç«‹å³çœ‹åˆ°appçš„è¾“å‡º YARN æž¶æž„å­¦ä¹ æ€»ç»“ Sparkæ ¸å¿ƒæŠ€æœ¯åŽŸç†é€è§†äºŒï¼ˆSparkè¿è¡Œæ¨¡å¼è°ˆè°ˆSparkè¿è¡Œæ¨¡å¼ Spark On Mesosæ¨¡å¼ sparkæœ‰å“ªäº›ç»„ä»¶ï¼Ÿ masterï¼šç®¡ç†é›†ç¾¤å’ŒèŠ‚ç‚¹ï¼Œä¸å‚ä¸Žè®¡ç®—ã€‚workerï¼šè®¡ç®—èŠ‚ç‚¹ï¼Œè¿›ç¨‹æœ¬èº«ä¸å‚ä¸Žè®¡ç®—ï¼Œå’Œmasteræ±‡æŠ¥ã€‚Driverï¼šè¿è¡Œç¨‹åºçš„mainæ–¹æ³•ï¼Œåˆ›å»ºspark contextå¯¹è±¡ã€‚spark contextï¼šæŽ§åˆ¶æ•´ä¸ªapplicationçš„ç”Ÿå‘½å‘¨æœŸï¼ŒåŒ…æ‹¬dagshedulerå’Œtask schedulerç­‰ç»„ä»¶ã€‚clientï¼šç”¨æˆ·æäº¤ç¨‹åºçš„å…¥å£ã€‚ sparkæž¶æž„ä¸Žç”Ÿæ€ Spark Core Spark SQL Spark Streamingï¼šå¯¹å®žæ—¶æ•°æ®æµè¿›è¡Œå¤„ç†å’ŒæŽ§åˆ¶ã€‚Spark Streamingå…è®¸ç¨‹åºèƒ½å¤Ÿåƒæ™®é€šRDDä¸€æ ·å¤„ç†å®žæ—¶æ•°æ®ã€‚ MLlibï¼šä¸€ä¸ªå¸¸ç”¨æœºå™¨å­¦ä¹ ç®—æ³•åº“ï¼Œç®—æ³•è¢«å®žçŽ°ä¸ºå¯¹RDDçš„Sparkæ“ä½œã€‚è¿™ä¸ªåº“åŒ…å«å¯æ‰©å±•çš„å­¦ä¹ ç®—æ³•ï¼Œæ¯”å¦‚åˆ†ç±»ã€å›žå½’ç­‰éœ€è¦å¯¹å¤§é‡æ•°æ®é›†è¿›è¡Œè¿­ä»£çš„æ“ä½œã€‚ GraphX hadoopåˆ†ä¸º MapReduce ä¸Ž åˆ†å¸ƒå¼æ–‡ä»¶ç³»ç»Ÿ(HDFS) MapReduce: ä»…æ”¯æŒMapå’ŒReduceä¸¤ç§æ“ä½œMapä¸­é—´ç»“æžœéœ€è¦å†™ç£ç›˜ä»»åŠ¡è°ƒåº¦å’Œå¯åŠ¨å¼€é”€å¤§æ— æ³•å……åˆ†åˆ©ç”¨å†…å­˜Mapå’ŒReduceéƒ½éœ€è¦æŽ’åºä¸é€‚åˆè¿­ä»£è®¡ç®— Sparkï¼š ä¸°å¯Œçš„APIï¼ˆJavaã€Scalaã€Pythonã€Rå››ç§è¯­è¨€ï¼Œsortã€joinç­‰é«˜æ•ˆç®—å­ï¼‰DAGæ‰§è¡Œå¼•æ“Žï¼Œä¸­é—´ç»“æžœä¸è½ç›˜çº¿ç¨‹æ± æ¨¡åž‹å‡å°‘taskå¯åŠ¨å¼€é”€å……åˆ†åˆ©ç”¨å†…å­˜ï¼Œå‡å°‘ç£ç›˜IOé¿å…ä¸å¿…è¦çš„æŽ’åºæ“ä½œé€‚åˆè¿­ä»£è®¡ç®—ï¼Œæ¯”å¦‚æœºå™¨å­¦ä¹ ç®—æ³• RDD spark æ¶‰åŠçš„æ ¸å¿ƒæ¦‚å¿µå°±æ˜¯resilient distributed dataset (RDD)ï¼Œrddæ˜¯å…·æœ‰å®¹é”™æ€§çš„æ•°æ®é›†åˆï¼Œå¹¶å¯ä»¥å¹¶è¡Œæ•°æ®è®¡ç®—ã€‚æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥åˆ›å»ºrdd,ç¬¬ä¸€ç§å°±æ˜¯parallelizing æ–¹æ³•ï¼šåºåˆ—åŒ–å­˜åœ¨driver program ä¸­çš„é›†åˆï¼Œè§ä¸‹æ–¹ä»£ç  12val data = Array(1, 2, 3, 4, 5)val distData = sc.parallelize(data) å¹¶parallelize æ–¹æ³•ä¸­å¯ä»¥æŒ‡å®šæ•°æ®åˆ†åŒºå‚æ•°ï¼Œå¹¶æ¯ä¸ªåˆ†åŒºå¯¹åº”ä¸€ä¸ªtask å¦‚ä¸‹é¢ä»£ç 12val data = Array(1, 2, 3, 4, 5)val distData = sc.parallelize(data,10) çª„ä¾èµ–æ˜¯æŒ‡æ¯ä¸ªçˆ¶RDDçš„Partitionæœ€å¤šè¢«å­RDDçš„ä¸€ä¸ªPartitionæ‰€ä½¿ç”¨ï¼Œä¾‹å¦‚mapã€filterï¼Œè§ä¸Šå·¦å›¾å®½ä¾èµ–æ˜¯æŒ‡ä¸€ä¸ªçˆ¶RDDçš„Partitionä¼šè¢«å¤šä¸ªå­RDDçš„Partitionæ‰€ä½¿ç”¨ï¼Œä¾‹å¦‚groupByKeyã€reduceByKeyç­‰ RDDï¼ˆResilient Distributed Datasetï¼‰å«åšå¼¹æ€§åˆ†å¸ƒå¼æ•°æ®é›†ï¼Œæ˜¯Sparkä¸­æœ€åŸºæœ¬çš„æ•°æ®æŠ½è±¡ï¼Œå®ƒä»£è¡¨ä¸€ä¸ªä¸å¯å˜ã€å¯åˆ†åŒºã€å…ƒç´ å¯å¹¶è¡Œè®¡ç®—çš„é›†åˆã€‚ RDDçš„å¼¹æ€§è¡¨çŽ°:1ã€å¼¹æ€§ä¹‹ä¸€ï¼šè‡ªåŠ¨çš„è¿›è¡Œå†…å­˜å’Œç£ç›˜æ•°æ®å­˜å‚¨çš„åˆ‡æ¢ï¼›2ã€å¼¹æ€§ä¹‹äºŒï¼šåŸºäºŽLineageçš„é«˜æ•ˆå®¹é”™ï¼ˆç¬¬nä¸ªèŠ‚ç‚¹å‡ºé”™ï¼Œä¼šä»Žç¬¬n-1ä¸ªèŠ‚ç‚¹æ¢å¤ï¼Œè¡€ç»Ÿå®¹é”™ï¼‰ï¼›3ã€å¼¹æ€§ä¹‹ä¸‰ï¼šTaskå¦‚æžœå¤±è´¥ä¼šè‡ªåŠ¨è¿›è¡Œç‰¹å®šæ¬¡æ•°çš„é‡è¯•ï¼ˆé»˜è®¤4æ¬¡ï¼‰ï¼›4ã€å¼¹æ€§ä¹‹å››ï¼šStageå¦‚æžœå¤±è´¥ä¼šè‡ªåŠ¨è¿›è¡Œç‰¹å®šæ¬¡æ•°çš„é‡è¯•ï¼ˆå¯ä»¥åªè¿è¡Œè®¡ç®—å¤±è´¥çš„é˜¶æ®µï¼‰ï¼›åªè®¡ç®—å¤±è´¥çš„æ•°æ®åˆ†ç‰‡ï¼› RDDçš„æŒä¹…åŒ–æ˜¯sparkçš„ä¸€ä¸ªé‡è¦çš„ç‰¹æ€§ï¼Œå½“ä½ æŠŠRDDæŒä¹…åŒ–ï¼Œæ¯ä¸ªNodeä¼šå­˜å‚¨RDDçš„åˆ†åŒºåœ¨å†…å­˜ï¼Œåœ¨å…¶ä»–actionä¸­ç”¨åˆ°æ­¤rddçš„æ—¶å€™ï¼Œå°±ä¸ç”¨ä»Žå¤´è½¬åŒ–ï¼Œè€Œæ˜¯ç›´æŽ¥ä½¿ç”¨ã€‚ä½ å¯ä»¥ç”¨persistæˆ–è€…cacheæ–¹æ³•æŒä¹…åŒ–rddï¼ŒSparkçš„ ç¼“ å­˜æ˜¯ä¸€ä¸ªå®¹ é”™ çš„æŠ€ æœ¯ -å¦‚æžœRDDçš„ä»»ä½•ä¸€ä¸ªåˆ†åŒº ä¸¢ å¤±ï¼Œå®ƒ å¯ä»¥é€š è¿‡ åŽŸæœ‰çš„ è½¬æ¢ ï¼ˆ transformations ï¼‰æ“ä½œè‡ª åŠ¨ çš„é‡å¤ è®¡ ç®—å¹¶ä¸” åˆ› å»ºå‡º è¿™ ä¸ªåˆ†åŒºã€‚å¦å¤–ï¼Œæ¯ä¸€ä¸ªRDDå¯ä»¥é€‰æ‹©ä¸åŒçš„æŒä¹…åŒ–çº§åˆ«. RDD çš„åˆ›å»ºæ–¹å¼ä¸»è¦æœ‰2ç§: å¹¶è¡ŒåŒ–(Parallelizing)ä¸€ä¸ªå·²ç»å­˜åœ¨ä¸Žé©±åŠ¨ç¨‹åº(Driver Program)ä¸­çš„é›†åˆå¦‚setã€list; è¯»å–å¤–éƒ¨å­˜å‚¨ç³»ç»Ÿä¸Šçš„ä¸€ä¸ªæ•°æ®é›†ï¼Œæ¯”å¦‚HDFSã€Hiveã€HBase,æˆ–è€…ä»»ä½•æä¾›äº†Hadoop InputFormatçš„æ•°æ®æº.ä¹Ÿå¯ä»¥ä»Žæœ¬åœ°è¯»å– txtã€csv ç­‰æ•°æ®é›† RDD çš„æ“ä½œå‡½æ•°(operation)ä¸»è¦åˆ†ä¸º2ç§ç±»åž‹ Transformation å’Œ Action ç±»åˆ« å‡½æ•° åŒºåˆ« Transformation Map,filter,groupBy,join, union,reduce,sort,partitionBy è¿”å›žå€¼è¿˜æ˜¯ RDD,ä¸ä¼šé©¬ä¸Š æäº¤ Spark é›†ç¾¤è¿è¡Œ Action count,collect,take,save, show è¿”å›žå€¼ä¸æ˜¯ RDD,ä¼šå½¢æˆ DAG å›¾,æäº¤ Spark é›†ç¾¤è¿è¡Œ å¹¶ç«‹å³è¿”å›žç»“æžœ Sparkè¿è¡Œæ¨¡å¼ï¼Ÿ ï¼ˆè¿™å››ç§è¿è¡Œæ¨¡å¼æ˜¯éœ€è¦å¥½å¥½çœ‹çœ‹çš„ï¼‰Spark On LocalSpark On Local Clusterï¼ˆSpark Standaloneï¼‰Spark On YarnSpark Clusteræ¨¡å¼ å¸¸è§çš„Sparkçš„æ€§èƒ½ç“¶é¢ˆæœ‰å“ªäº›ï¼Ÿ å½±å“æ€§èƒ½çš„ä¸»è¦å› ç´ æ˜¯Shuffleï¼Œå¯ä»¥ä¼˜åŒ–ä»£ç å‡å°‘ä¸å¿…è¦çš„Stageæ•°é‡åŠShuffleæ•°æ®é‡ä»¥æ”¹è¿›Shuffleæ€§èƒ½ã€‚ç”±äºŽShuffleçš„ä¸­é—´ç»“æžœæ•°æ®éƒ½æ˜¯è¦è½ç£ç›˜çš„ï¼Œæ‰€ä»¥å¯ä»¥è€ƒè™‘ç»™æœåŠ¡å™¨åŠ SSDï¼ˆä¸€èˆ¬100Gå·¦å³å°±å¤Ÿäº†ï¼‰ï¼Œå°†Sparkçš„tmpç›®å½•è®¾ç½®ä¸ºSSDç›®å½•ï¼Œæ€§èƒ½æå‡20%å·¦å³ã€‚ å…¶æ¬¡æ˜¯IOï¼Œç½‘ç»œIOå»ºè®®ä¸Šä¸‡å…†ç½‘ç»œï¼ˆè¿™ä¹Ÿæ˜¯å½±å“Shuffleæ€§èƒ½çš„ä¸€ä¸ªå› ç´ ï¼‰ï¼Œå¯¹äºŽç£ç›˜IOï¼Œä¸€èˆ¬æ˜¯ç»™æœåŠ¡å™¨è®¾ç½®å¤šå—å•ç›˜ï¼Œä¸è¦åšRAIDï¼æŒ‚è½½ç£ç›˜æ—¶è®¾ç½®noatimeï¼Œæé«˜ç£ç›˜IOæ€§èƒ½ã€‚ æœ€åŽæ˜¯CPUï¼ŒSparkåšè®¡ç®—å¦‚æžœæ•°æ®å·²ç»åŠ è½½åˆ°å†…å­˜äº†ï¼ŒCPUå°±æ¯”è¾ƒå®¹æ˜“æˆä¸ºè®¡ç®—ç“¶é¢ˆï¼Œä»£ç æ–¹é¢ä¸»è¦æ˜¯ä¼˜åŒ–è®¡ç®—ï¼Œå‡å°‘è®¡ç®—é‡ï¼ŒåŒæ—¶ä¹Ÿè¦å…³æ³¨è®¡ç®—ä»»åŠ¡æ˜¯å¦æœ‰æ•°æ®å€¾æ–œçš„çŽ°è±¡ï¼›ç¡¬ä»¶æ–¹é¢åªèƒ½æ¢æ€§èƒ½æ›´å¼ºåŠ²çš„CPUäº†ã€‚ 12345678910111213141516æ­£å¸¸çš„æ•°æ®åˆ†å¸ƒç†è®ºä¸Šéƒ½æ˜¯å€¾æ–œçš„ï¼Œå°±æ˜¯æˆ‘ä»¬æ‰€è¯´çš„20-80åŽŸç†ï¼š80%çš„è´¢å¯Œé›†ä¸­åœ¨20%çš„äººæ‰‹ä¸­, 80%çš„ç”¨æˆ·åªä½¿ç”¨20%çš„åŠŸèƒ½ , 20%çš„ç”¨æˆ·è´¡çŒ®äº†80%çš„è®¿é—®é‡ , ä¸åŒçš„æ•°æ®å­—æ®µå¯èƒ½çš„æ•°æ®å€¾æ–œä¸€èˆ¬æœ‰ä¸¤ç§æƒ…å†µã€‚ä»€ä¹ˆæ˜¯æ•°æ®å€¾æ–œç®€å•çš„è®²ï¼Œæ•°æ®å€¾æ–œå°±æ˜¯æˆ‘ä»¬åœ¨è®¡ç®—æ•°æ®çš„æ—¶å€™ï¼Œæ•°æ®çš„åˆ†æ•£åº¦ä¸å¤Ÿï¼Œå¯¼è‡´å¤§é‡çš„æ•°æ®é›†ä¸­åˆ°äº†ä¸€å°æˆ–è€…å‡ å°æœºå™¨ä¸Šè®¡ç®—ï¼Œè¿™äº›æ•°æ®çš„è®¡ç®—é€Ÿåº¦è¿œè¿œä½ŽäºŽå¹³å‡è®¡ç®—é€Ÿåº¦ï¼Œå¯¼è‡´æ•´ä¸ªè®¡ç®—è¿‡ç¨‹è¿‡æ…¢ã€‚ä»¥Hadoopå’ŒSparkæ˜¯æœ€å¸¸è§çš„ä¸¤ä¸ªè®¡ç®—å¹³å°ï¼Œä¸‹é¢å°±ä»¥è¿™ä¸¤ä¸ªå¹³å°è¯´æ˜Žï¼šHadoopä¸­çš„æ•°æ®å€¾æ–œ- Hadoopä¸­çš„æ•°æ®å€¾æ–œä¸»è¦è¡¨çŽ°åœ¨ruduceé˜¶æ®µå¡åœ¨99.99%ï¼Œä¸€ç›´99.99%ä¸èƒ½ç»“æŸã€‚Sparkä¸­çš„æ•°æ®å€¾æ–œçš„è¡¨çŽ°- å•ä¸ªExecutoræ‰§è¡Œæ—¶é—´ç‰¹åˆ«ä¹…ï¼Œæ•´ä½“ä»»åŠ¡å¡åœ¨æŸä¸ªé˜¶æ®µä¸èƒ½ç»“æŸ- Executor lostï¼ŒOOMï¼ŒShuffleè¿‡ç¨‹å‡ºé”™æ•°æ®å€¾æ–œçš„åŽŸç†æˆ‘ä»¬ä»¥Sparkå’ŒHiveçš„ä½¿ç”¨åœºæ™¯ä¸ºä¾‹ã€‚ä»–ä»¬åœ¨åšæ•°æ®è¿ç®—çš„æ—¶å€™ä¼šè®¾è®¡åˆ°ï¼Œcountdistinctã€group byã€joinç­‰æ“ä½œï¼Œè¿™äº›éƒ½ä¼šè§¦å‘ShuffleåŠ¨ä½œï¼Œä¸€æ—¦è§¦å‘ï¼Œæ‰€æœ‰ç›¸åŒkeyçš„å€¼å°±ä¼šæ‹‰åˆ°ä¸€ä¸ªæˆ–å‡ ä¸ªèŠ‚ç‚¹ä¸Šï¼Œå°±å®¹æ˜“å‘ç”Ÿå•ç‚¹é—®é¢˜ã€‚ å¤§éƒ¨åˆ†æ•°æ®å€¾æ–œçš„åŽŸç†å°±ç±»ä¼¼äºŽä¸‹å›¾ï¼Œå¾ˆæ˜Žäº†ï¼Œå› ä¸ºæ•°æ®åˆ†å¸ƒä¸å‡åŒ€ï¼Œå¯¼è‡´å¤§é‡çš„æ•°æ®åˆ†é…åˆ°äº†ä¸€ä¸ªèŠ‚ç‚¹ã€‚ å¦‚ä½•è§£å†³è¿™ç§é—®é¢˜1.ä¸šåŠ¡é€»è¾‘ï¼Œæˆ‘ä»¬ä»Žä¸šåŠ¡é€»è¾‘çš„å±‚é¢ä¸Šæ¥ä¼˜åŒ–æ•°æ®å€¾æ–œï¼Œæ¯”å¦‚ä¸Šé¢çš„ä¾‹å­ï¼Œæˆ‘ä»¬å•ç‹¬å¯¹è¿™ä¸¤ä¸ªåŸŽå¸‚æ¥åšcountï¼Œæœ€åŽå’Œå…¶å®ƒåŸŽå¸‚åšæ•´åˆã€‚2.ç¨‹åºå±‚é¢ï¼Œæ¯”å¦‚è¯´åœ¨Hiveä¸­ï¼Œç»å¸¸é‡åˆ°countï¼ˆdistinctï¼‰æ“ä½œï¼Œè¿™æ ·ä¼šå¯¼è‡´æœ€ç»ˆåªæœ‰ä¸€ä¸ªreduceï¼Œæˆ‘ä»¬å¯ä»¥å…ˆgroup å†åœ¨å¤–é¢åŒ…ä¸€å±‚countï¼Œå°±å¯ä»¥äº†ã€‚3.è°ƒå‚æ–¹é¢ï¼ŒHadoopå’ŒSparkéƒ½è‡ªå¸¦äº†å¾ˆå¤šçš„å‚æ•°å’Œæœºåˆ¶æ¥è°ƒèŠ‚æ•°æ®å€¾æ–œï¼Œåˆç†åˆ©ç”¨å®ƒä»¬å°±èƒ½è§£å†³å¤§éƒ¨åˆ†é—®é¢˜ã€‚ ç¡¬ç›˜æœ‰æœºæ¢°ç¡¬ç›˜(HDD)å’Œå›ºæ€ç¡¬ç›˜(SSD) é’ˆå¯¹ä¸åŒçš„ä½œä¸šç±»åž‹ï¼Œåœ¨å¯¹é›†ç¾¤è¿›è¡Œè‰¯å¥½é…ç½®çš„æå‰ä¸‹ï¼Œsparkä½œä¸šæœ€è€—æ—¶çš„éƒ¨åˆ†å¾€å¾€æ˜¯å› ä¸ºé›†ç¾¤èµ„æºçš„é™åˆ¶ï¼Œä¸»è¦ä½“çŽ°åœ¨ä¸‰ä¸ªæ–¹é¢ï¼šCPUã€DISK IOã€NETWORK IOã€‚sparkå°†ä½œä¸šæ‹†åˆ†æˆçš„å•å…ƒæ˜¯stageï¼Œä¸åŒçš„stageå†…éƒ¨æ‰§è¡Œä¸åŒçš„é€»è¾‘ã€‚stageå†…éƒ¨æ—¢æœ‰ioæ“ä½œï¼Œä¹Ÿæœ‰cpuè®¡ç®—æ“ä½œï¼Œè¿˜ä¼šæœ‰networkï¼ˆä¸»è¦æ˜¯shuffleå¼•èµ·çš„ï¼‰ï¼Œå½“è¿™ä¸‰ä¸ªéƒ¨åˆ†å…¶ä¸­æŸä¸€éƒ¨åˆ†æ‰€å çš„æ¯”ä¾‹è¾ƒå¤§æ—¶ï¼Œåœ¨èµ„æºå ç”¨ä¸Šå°±ä¼šä½“çŽ°å‡ºè¿™ä¸€éƒ¨åˆ†çš„bottleneckã€‚ä¾‹å¦‚ï¼Œ è¿™æ ·ä¸€ä¸ªstageï¼Œå°±æ˜¯ç®€å•çš„ä»Žhdfsä¸­è¯»å–æ–‡æœ¬æ•°æ®è®¡ç®—æœ‰å¤šå°‘è¡Œã€‚å‡ ä¹Žæ²¡æœ‰cpuæ“ä½œï¼Œshuffleçš„é‡ä¹Ÿå¾ˆå°ï¼Œä¸»è¦çš„æ“ä½œåœ¨DISK IOä¸Šï¼Œå› æ­¤ï¼Œè¿™ä¸ªstageè€—æ—¶æœ€é•¿çš„éƒ¨åˆ†å°±æ˜¯åœ¨ç£ç›˜è¯»å†™ä¸Šã€‚å› æ­¤ï¼Œåˆ¤æ–­ä¸€ä¸ªä½œä¸šæœ€è€—æ—¶çš„éƒ¨åˆ†ï¼Œéœ€è¦å®žé™…çš„åŽ»åˆ†æžstageçš„æ‰§è¡Œé€»è¾‘ï¼Œç»“åˆå®žé™…çš„èµ„æºå ç”¨æƒ…å†µï¼Œè¿™æ ·æ‰èƒ½çš„åˆ°å‡†ç¡®å®Œæ•´çš„ç­”æ¡ˆ å¯¹äºŽä¸åŒçš„è®¡ç®—åœºæ™¯ï¼Œioï¼Œshuffleï¼Œcpuéƒ½æœ‰å¯èƒ½æˆä¸ºè®¡ç®—ç“¶é¢ˆã€‚ä¸€èˆ¬æ¥è¯´ï¼Œåšç»Ÿè®¡çš„æ—¶å€™ioæ˜¯æœ€å¤§çš„ç“¶é¢ˆï¼Œåšæ•°æ®æŒ–æŽ˜çš„æ—¶å€™æ¯”è¾ƒæ…¢çš„æ˜¯shuffleå’Œcpuã€‚ Shuffleçš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿ Shuffleçš„ä¸­æ–‡è§£é‡Šä¸ºâ€œæ´—ç‰Œæ“ä½œâ€ï¼Œå¯ä»¥ç†è§£æˆå°†é›†ç¾¤ä¸­æ‰€æœ‰èŠ‚ç‚¹ä¸Šçš„æ•°æ®è¿›è¡Œé‡æ–°æ•´åˆåˆ†ç±»çš„è¿‡ç¨‹ã€‚å…¶æ€æƒ³æ¥æºäºŽhadoopçš„mapReduce,Shuffleæ˜¯è¿žæŽ¥mapé˜¶æ®µå’Œreduceé˜¶æ®µçš„æ¡¥æ¢ã€‚ç”±äºŽåˆ†å¸ƒå¼è®¡ç®—ä¸­ï¼Œæ¯ä¸ªé˜¶æ®µçš„å„ä¸ªè®¡ç®—èŠ‚ç‚¹åªå¤„ç†ä»»åŠ¡çš„ä¸€éƒ¨åˆ†æ•°æ®ï¼Œè‹¥ä¸‹ä¸€ä¸ªé˜¶æ®µéœ€è¦ä¾èµ–å‰é¢é˜¶æ®µçš„æ‰€æœ‰è®¡ç®—ç»“æžœæ—¶ï¼Œåˆ™éœ€è¦å¯¹å‰é¢é˜¶æ®µçš„æ‰€æœ‰è®¡ç®—ç»“æžœè¿›è¡Œé‡æ–°æ•´åˆå’Œåˆ†ç±»ï¼Œè¿™å°±éœ€è¦ç»åŽ†shuffleè¿‡ç¨‹ã€‚åœ¨sparkä¸­ï¼ŒRDDä¹‹é—´çš„å…³ç³»åŒ…å«çª„ä¾èµ–å’Œå®½ä¾èµ–ï¼Œå…¶ä¸­å®½ä¾èµ–æ¶‰åŠshuffleæ“ filter map flatMapç­‰æ“ä½œå±žäºŽtransformï¼Œrddç»è¿‡è‹¥å¹²çš„transformï¼Œç›´åˆ°actionï¼ˆå¦‚take count isEmpty foreach foreachPartitionï¼‰æ‰ä¼šçœŸæ­£æ‰§è¡Œã€‚ spark ä¸­å¸¸è§çš„action ç®—å­Actionç±»ç®—å­ä¹Ÿæ˜¯ä¸€ç±»ç®—å­ï¼ˆå‡½æ•°ï¼‰å«åšè¡ŒåŠ¨ç®—å­ï¼Œå¦‚foreach,collectï¼Œcountç­‰ã€‚Transformationsç±»ç®—å­æ˜¯å»¶è¿Ÿæ‰§è¡Œï¼ŒActionç±»ç®—å­æ˜¯è§¦å‘æ‰§è¡Œã€‚ä¸€ä¸ªapplicationåº”ç”¨ç¨‹åºï¼ˆå°±æ˜¯æˆ‘ä»¬ç¼–å†™çš„ä¸€ä¸ªåº”ç”¨ç¨‹åºï¼‰ä¸­æœ‰å‡ ä¸ªActionç±»ç®—å­æ‰§è¡Œï¼Œå°±æœ‰å‡ ä¸ªjobè¿è¡Œã€‚ reduce é€šè¿‡å‡½æ•°funcèšé›†æ•°æ®é›†ä¸­çš„æ‰€æœ‰å…ƒç´ ï¼Œè¿™ä¸ªå‡½æ•°å¿…é¡»æ˜¯å…³è”æ€§çš„ï¼Œç¡®ä¿å¯ä»¥è¢«æ­£ç¡®çš„å¹¶å‘æ‰§è¡Œ collectåœ¨driverçš„ç¨‹åºä¸­ï¼Œä»¥æ•°ç»„çš„å½¢å¼ï¼Œè¿”å›žæ•°æ®é›†çš„æ‰€æœ‰å…ƒç´ ï¼Œè¿™é€šå¸¸ä¼šåœ¨ä½¿ç”¨filteræˆ–è€…å…¶å®ƒæ“ä½œåŽï¼Œè¿”å›žä¸€ä¸ªè¶³å¤Ÿå°çš„æ•°æ®å­é›†å†ä½¿ç”¨ countè¿”å›žæ•°æ®é›†çš„å…ƒç´ ä¸ªæ•° firstè¿”å›žæ•°æ®é›†çš„ç¬¬ä¸€ä¸ªå…ƒç´ (ç±»ä¼¼äºŽtake(1)) takeè¿”å›žä¸€ä¸ªæ•°ç»„ï¼Œç”±æ•°æ®é›†çš„å‰nä¸ªå…ƒç´ ç»„æˆã€‚ takeSample(withReplacement,num,seed) withReplacement:ç»“æžœä¸­æ˜¯å¦å¯é‡å¤num:å–å¤šå°‘ä¸ªseed:éšæœºç§å­ è¿”å›žä¸€ä¸ªæ•°ç»„ï¼Œåœ¨æ•°æ®é›†ä¸­éšæœºé‡‡æ ·numä¸ªå…ƒç´ ç»„æˆï¼Œå¯ä»¥é€‰æ‹©æ˜¯å¦ç”¨éšæœºæ•°æ›¿æ¢ä¸è¶³çš„éƒ¨åˆ†ï¼Œseedç”¨äºŽæŒ‡å®šçš„éšæœºæ•°ç”Ÿæˆå™¨ç§å­ saveAsTextFile saveAsTextFileç”¨äºŽå°†RDDä»¥æ–‡æœ¬æ–‡ä»¶çš„æ ¼å¼å­˜å‚¨åˆ°æ–‡ä»¶ç³»ç»Ÿä¸­ hadoop: javahive: javestorm: clojure, jstorm javakafka: scalaspark: scalaflink: scala Spark is a fast and general engine for large-scale data processing. speed, run programs up to 100x faster than hadoop mapreduce in memory, or 10x faster on disk. ease of use, Java, Scala, Python, R combine SQL(ç¦»çº¿ä»»åŠ¡), streamingï¼ˆå®žæ—¶ä»»åŠ¡ï¼‰, and complex analytics. run everywhere, Spark runs on Hadoop, Mesos, standalone(è¿™ä¸ªæ˜¯spark è‡ªå·±çš„), or in the cloud. It can access diverse data sources including HDFS, Cassandra, HBase, and S3. æœ‰ä¸‰ç§ä¸‹è½½æ–¹å¼ spark å®˜ç½‘ github æ‰˜ç®¡ arkive.apache.cn å®‰è£…æŒ‡å— collectæ˜¯æ”¶é›†èµ·æ¥ï¼Œç„¶åŽå±•ç¤ºã€‚spark ä¸­çš„æ–¹æ³•é€šå¸¸æ˜¯è¢«ç§°ä¸ºç®—å­ ä»€ä¹ˆæ˜¯ RDD? RDD( Resilient distributed dataset) å«åšåˆ†å¸ƒå¼æ•°æ®é›†ï¼Œæ˜¯Spark ä¸­æœ€åŸºæœ¬çš„æ•°æ®æŠ½è±¡ï¼Œå®ƒä»£è¡¨ä¸€ä¸ªä¸å¯å˜ï¼Œå¯åˆ†åŒºï¼Œé‡Œé¢çš„ä½ç½®å¯å¹¶è¡Œè®¡ç®—çš„é›†åˆã€‚RDD å…·æœ‰æ•°æ®æµæ¨¡åž‹çš„ç‰¹ç‚¹ï¼šè‡ªåŠ¨å®¹é”™ï¼Œä½ç½®æ„ŸçŸ¥æ€§è°ƒåº¦å’Œå¯ä¼¸ç¼©æ€§ï¼ŒRDD å…è®¸ç”¨æˆ·æ‰§è¡Œå¤šä¸ªæŸ¥è¯¢æ—¶æ˜¾å¼å°†å·¥ä½œé›†ç¼“å­˜åœ¨å†…å­˜ä¸­ï¼ŒåŽåºçš„æŸ¥è¯¢èƒ½å¤Ÿé‡ç”¨å·¥ä½œé›†ï¼Œæžå¤§çš„æä¾›äº†æŸ¥è¯¢çš„é€Ÿåº¦ã€‚ RDD çš„å±žæ€§ï¼Ÿï¼ˆå¤šçœ‹ï¼‰ ç”ŸæˆRDDçš„ä¸¤ç§æ–¹å¼ ä¸€ç§æ˜¯ä½¿ç”¨textFile()ä¸€ç§ä½¿ç”¨parallelize() ä¸¤ç§ç±»åž‹çš„ç®—æ³•ä¸»è¦æ˜¯ä»Žè¿è¡Œæ•ˆçŽ‡è§’åº¦è€ƒè™‘ transformationï¼ˆè½¬æ¢ç±»åž‹ï¼‰ï¼Œä»…ä»…è®°å½•ä¸€ä¸ªè¿ç®—è¿‡ç¨‹ï¼Œåªæœ‰å½“ actionç±»åž‹çš„åŠ¨ä½œäº§ç”Ÿï¼Œé‚£ä¹ˆæ‰ä¼šè¿è¡Œã€‚actionï¼ˆåŠ¨ä½œç±»åž‹ï¼‰ï¼Œç”Ÿæˆä¸€ä¸ªä»»åŠ¡å°±æäº¤äº†é›†ç¾¤ä¸Šè¿›è¡Œè®¡ç®—ï¼Œæ‰€ä»¥ä¸€å®šè¦è®°ä½ action ç±»åž‹çš„ç®—å­ï¼ŒåŸºäºŽä¼˜åŒ–çš„è§’åº¦ï¼Œæ…Žç”¨ã€‚ æŸ¥æ‰¾å®˜æ–¹ spark programming guide, å®˜ç½‘ä¸­çš„ transformation æ˜¯å¸¸ç”¨çš„ç±»åž‹ï¼Œä¸æ˜¯å…¨éƒ¨çš„è½¬æ¢ç±»åž‹ã€‚ å­˜å‚¨mysql æ•°æ®åº“ï¼Œä½¿ç”¨ mappartitions è€Œä¸æ˜¯ mapè¿›è¡Œæ“ä½œï¼Œå‡å°‘è°ƒç”¨çš„æ¬¡æ•°ã€‚ å¸¸è§çš„transformation ç±»åž‹ map (func) æ¯ä¸€ä¸ªå…ƒç´  ä¸€ä¸ªä¸ªæ ¹æ® func è¿›è¡Œå¤„ç† filter éœ€è¦ç»™å®šä¸€ä¸ªfilter çš„é€»è¾‘ flatmap å…ˆæ˜¯åŽ‹å¹³ï¼Œç„¶åŽå¤„ç† mappartitions å–å‡ºæ•°æ®çš„åˆ†åŒºè¿›è¡ŒéåŽ†ï¼Œä¸€ä¸ªä¸ªåˆ†åŒºè¿›è¡Œå¤„ç† sample æŠ½æ · union intersection distinct åŽ»é‡ groupbykey ä½¿ç”¨key è¿›è¡Œåˆ†ç»„ï¼Œç›¸åŒkey å°±åˆ†åˆ°ä¸€å— reducebykey ä½¿ç”¨key æ¥åšèšåˆ aggregatebykey sortbykey ä½¿ç”¨key æ¥åšæŽ’åº join å·¦è¿žæŽ¥ å’Œå³è¿žæŽ¥ repartition é‡æ–°åˆ†åŒº å¸¸è§çš„action reduce èšåˆ collect count first æ‹¿åˆ°ç¬¬ä¸€ä¸ªå…ƒç´  take (n) æ‹¿åˆ°å‰ n ä¸ªå…ƒç´  take Sample æŠ½æ · takeOrdered æŽ’åºä¹‹åŽå†åŽ»å–å…ƒç´  saveAsTextFile(path) å­˜å‚¨ foreach æ²¡æœ‰è¿”å›žå€¼ï¼ˆå’Œmap ä¸ä¸€æ ·ï¼Œmap å¤„ç†ä¹‹åŽæ˜¯æœ‰è¿”å›žå€¼çš„ï¼‰ï¼Œ æ¯”å¦‚è¯´æ‹¿åˆ°æ•°æ®å¹¶ä¸”å­˜å‚¨åˆ°æ•°æ®åº“ MapReduce 6ä¸ªè¿‡ç¨‹ å¦‚ä½•åŽ»ä¼˜åŒ– shuffle è¿‡ç¨‹ï¼Ÿè¿™ä¸ªåšå®¢è®²è§£çš„å¾ˆå¥½hadoop ä¸­çš„shuffle]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è®¡ç®—æœºåŸºç¡€]]></title>
    <url>%2F2019%2F04%2F10%2Fbasics_of_cs%2F</url>
    <content type="text"><![CDATA[è®¡ç®—æœºä¸­çš„åŸºç¡€çŸ¥è¯†ï¼Œæ¯”å¦‚æ“ä½œç³»ç»Ÿã€è®¡ç®—æœºç»„æˆã€æ•°æ®åº“ã€è®¡ç®—æœºç½‘ç»œã€è½¯ä»¶å·¥ç¨‹ã€‚ æ“ä½œç³»ç»Ÿ å¹¶å‘å’Œå¹¶è¡Œå¹¶è¡Œ(parallel)ï¼šæŒ‡åœ¨åŒä¸€æ—¶åˆ»ï¼Œæœ‰å¤šæ¡æŒ‡ä»¤åœ¨å¤šä¸ªå¤„ç†å™¨ä¸ŠåŒæ—¶æ‰§è¡Œã€‚å°±å¥½åƒä¸¤ä¸ªäººå„æ‹¿ä¸€æŠŠé“é”¨åœ¨æŒ–å‘ï¼Œä¸€å°æ—¶åŽï¼Œæ¯äººä¸€ä¸ªå¤§å‘ã€‚æ‰€ä»¥æ— è®ºä»Žå¾®è§‚è¿˜æ˜¯ä»Žå®è§‚æ¥çœ‹ï¼ŒäºŒè€…éƒ½æ˜¯ä¸€èµ·æ‰§è¡Œçš„ã€‚å¹¶å‘(concurrency)ï¼šæŒ‡åœ¨åŒä¸€æ—¶åˆ»åªèƒ½æœ‰ä¸€æ¡æŒ‡ä»¤æ‰§è¡Œï¼Œä½†å¤šä¸ªè¿›ç¨‹æŒ‡ä»¤è¢«å¿«é€Ÿçš„è½®æ¢æ‰§è¡Œï¼Œä½¿å¾—åœ¨å®è§‚ä¸Šå…·æœ‰å¤šä¸ªè¿›ç¨‹åŒæ—¶æ‰§è¡Œçš„æ•ˆæžœï¼Œä½†åœ¨å¾®è§‚ä¸Šå¹¶ä¸æ˜¯åŒæ—¶æ‰§è¡Œçš„ï¼Œåªæ˜¯æŠŠæ—¶é—´åˆ†æˆè‹¥å¹²æ®µï¼Œä½¿å¤šä¸ªè¿›ç¨‹å¿«é€Ÿäº¤æ›¿çš„æ‰§è¡Œã€‚ å¸¸è§çš„é¡µé¢ç½®æ¢ç®—æ³• æœ€ä½³ç½®æ¢ç®—æ³• (opt)è™½ç„¶è¿™ä¸ªç®—æ³•ä¸å¯èƒ½å®žçŽ°ï¼Œä½†æ˜¯æœ€ä½³é¡µé¢ç½®æ¢ç®—æ³•å¯ä»¥ç”¨äºŽå¯¹å¯å®žçŽ°ç®—æ³•çš„æ€§èƒ½è¿›è¡Œè¡¡é‡æ¯”è¾ƒã€‚ å…ˆè¿›å…ˆå‡ºç½®æ¢ç®—æ³•ï¼ˆFIFOï¼‰è¿™ç§ç®—æ³•åªæ˜¯åœ¨æŒ‰çº¿æ€§é¡ºåºè®¿é—®åœ°å€ç©ºé—´æ—¶æ‰æ˜¯ç†æƒ³çš„ï¼Œå¦åˆ™æ•ˆçŽ‡ä¸é«˜ã€‚å› ä¸ºé‚£äº›å¸¸è¢«è®¿é—®çš„é¡µï¼Œå¾€å¾€åœ¨ä¸»å­˜ä¸­ä¹Ÿåœç•™å¾—æœ€ä¹…ï¼Œç»“æžœå®ƒä»¬å› å˜â€œè€â€è€Œä¸å¾—ä¸è¢«ç½®æ¢å‡ºåŽ»ã€‚FIFOçš„å¦ä¸€ä¸ªç¼ºç‚¹æ˜¯ï¼Œå®ƒæœ‰ä¸€ç§å¼‚å¸¸çŽ°è±¡ï¼ˆbeladyï¼‰ï¼Œå³åœ¨å¢žåŠ å­˜å‚¨å—çš„æƒ…å†µä¸‹ï¼Œåè€Œä½¿ç¼ºé¡µä¸­æ–­çŽ‡å¢žåŠ äº†ã€‚å½“ç„¶ï¼Œå¯¼è‡´è¿™ç§å¼‚å¸¸çŽ°è±¡çš„é¡µé¢èµ°å‘å®žé™…ä¸Šæ˜¯å¾ˆå°‘è§çš„ã€‚ LRU (least recently used) æœ€è¿‘æœ€å°‘ä½¿ç”¨ç®—æ³•æ€æƒ³ï¼šLRUï¼ˆLeast recently usedï¼Œæœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼‰ç®—æ³•æ ¹æ®æ•°æ®çš„åŽ†å²è®¿é—®è®°å½•æ¥è¿›è¡Œæ·˜æ±°æ•°æ®ï¼Œå…¶æ ¸å¿ƒæ€æƒ³æ˜¯â€œå¦‚æžœæ•°æ®æœ€è¿‘è¢«è®¿é—®è¿‡ï¼Œé‚£ä¹ˆå°†æ¥è¢«è®¿é—®çš„å‡ çŽ‡ä¹Ÿæ›´é«˜â€ã€‚å®žçŽ°ï¼š æœ€å¸¸è§çš„å®žçŽ°æ˜¯ä½¿ç”¨é“¾è¡¨ä¿å­˜ç¼“å­˜æ•°æ®ã€‚å¸¸è§çš„æ“ä½œï¼ša. æ–°æ•°æ®æ’å…¥åˆ°é“¾è¡¨å¤´éƒ¨ï¼›b. æ¯å½“ç¼“å­˜å‘½ä¸­ï¼ˆå³ç¼“å­˜æ•°æ®è¢«è®¿é—®ï¼‰ï¼Œåˆ™å°†æ•°æ®ç§»åˆ°é“¾è¡¨å¤´éƒ¨ï¼›c. å½“é“¾è¡¨æ»¡çš„æ—¶å€™ï¼Œå°†é“¾è¡¨å°¾éƒ¨çš„æ•°æ®ä¸¢å¼ƒã€‚ æœ€å°‘ä½¿ç”¨ï¼ˆLFUï¼‰ç½®æ¢ç®—æ³•åœ¨é‡‡ç”¨æœ€å°‘ä½¿ç”¨ç½®æ¢ç®—æ³•æ—¶ï¼Œåº”ä¸ºåœ¨å†…å­˜ä¸­çš„æ¯ä¸ªé¡µé¢è®¾ç½®ä¸€ä¸ªç§»ä½å¯„å­˜å™¨ï¼Œç”¨æ¥è®°å½•è¯¥é¡µé¢è¢«è®¿é—®çš„é¢‘çŽ‡ã€‚è¯¥ç½®æ¢ç®—æ³•é€‰æ‹©åœ¨æœ€è¿‘æ—¶æœŸä½¿ç”¨æœ€å°‘çš„é¡µé¢ä½œä¸ºæ·˜æ±°é¡µã€‚LRUçš„æ·˜æ±°è§„åˆ™æ˜¯åŸºäºŽè®¿é—®æ—¶é—´ï¼Œè€ŒLFUæ˜¯åŸºäºŽè®¿é—®æ¬¡æ•°çš„ã€‚ è¿›ç¨‹çš„çŠ¶æ€è¿›ç¨‹ä¸€èˆ¬æœ‰3ç§åŸºæœ¬çŠ¶æ€ï¼šè¿è¡Œã€å°±ç»ªå’Œé˜»å¡žã€‚å°±ç»ªï¼šå½“ä¸€ä¸ªè¿›ç¨‹èŽ·å¾—äº†é™¤å¤„ç†æœºä»¥å¤–çš„ä¸€åˆ‡æ‰€éœ€èµ„æºï¼Œä¸€æ—¦å¾—åˆ°å¤„ç†æœºå³å¯è¿è¡Œï¼Œåˆ™ç§°æ­¤è¿›ç¨‹å¤„äºŽå°±ç»ªçŠ¶æ€ã€‚è¿è¡Œï¼šå½“ä¸€ä¸ªè¿›ç¨‹åœ¨å¤„ç†æœºä¸Šè¿è¡Œæ—¶ï¼Œåˆ™ç§°è¯¥è¿›ç¨‹å¤„äºŽè¿è¡ŒçŠ¶æ€ã€‚é˜»å¡žï¼šä¹Ÿç§°ä¸ºç­‰å¾…æˆ–ç¡çœ çŠ¶æ€ï¼Œä¸€ä¸ªè¿›ç¨‹æ­£åœ¨ç­‰å¾…æŸä¸€äº‹ä»¶å‘ç”Ÿï¼ˆä¾‹å¦‚è¯·æ±‚I/Oè€Œç­‰å¾…I/Oå®Œæˆç­‰ï¼‰è€Œæš‚æ—¶åœæ­¢è¿è¡Œï¼Œè¿™æ—¶å³ä½¿æŠŠå¤„ç†æœºåˆ†é…ç»™è¿›ç¨‹ä¹Ÿæ— æ³•è¿è¡Œï¼Œæ•…ç§°è¯¥è¿›ç¨‹å¤„äºŽé˜»å¡žçŠ¶æ€ã€‚ CPUè°ƒåº¦ç®—æ³•å¼•å…¥å¤šç¨‹åºè®¾è®¡ï¼Œç›®çš„æ˜¯æé«˜è®¡ç®—æœºèµ„æºåˆ©ç”¨çŽ‡ï¼Œå°¤å…¶æ˜¯CPUåˆ©ç”¨çŽ‡ï¼ˆCPU utilizationï¼‰ã€‚åˆ†ä¸º éžæŠ¢å å¼ï¼šè¿›ç¨‹è‡ªæ„¿äº¤å‡ºCPUï¼Œå¼•èµ·æ–°ä¸€è½®çš„è°ƒåº¦ã€‚æŠ¢å å¼ï¼šè¿›ç¨‹è¢«è¿«äº¤å‡ºCPUï¼Œå¼•èµ·æ–°ä¸€è½®çš„è°ƒåº¦ã€‚CPUè°ƒåº¦å™¨è¿½æ±‚ç›®æ ‡CPUåˆ©ç”¨çŽ‡ï¼ˆCPU utilizationï¼‰åžåçŽ‡ï¼ˆThroughputï¼‰å‘¨è½¬æ—¶é—´ï¼ˆTurnaround timeï¼‰ç­‰å¾…æ—¶é—´ï¼ˆWaiting timeï¼‰å“åº”æ—¶é—´ï¼ˆResponse timeï¼‰å¸¸ç”¨çš„è°ƒåº¦ç®—æ³•ï¼ša. FCFSè°ƒåº¦ç®—æ³•ï¼ˆFirst-Come,First-Served Schedulingï¼‰b. Shortest-Job-Firstï¼ˆSJFï¼‰è°ƒåº¦ç®—æ³•ï¼ˆæœ€çŸ­ä½œä¸šä¼˜å…ˆç®—æ³•ï¼‰c. ä¼˜å…ˆæƒæ³•ï¼ˆPriority Schedulingï¼‰d. è½®è½¬æ³•ï¼ˆRound Robinï¼ŒRRï¼‰å¸¸è¯´çš„æ—¶é—´ç‰‡è½®è½¬ï¼Œå¦‚æžœæ—¶é—´ç‰‡ç”¨å®Œäº†ï¼Œé‚£ä¹ˆå°±è¢«è¿«äº¤å‡º CPUèµ„æºå¯ä»¥é€šè¿‡ä¸€ä¸ªä¾‹é¢˜è®²è§£ï¼šç¼ºé¡µçŽ‡çš„è®¡ç®— è®¡ç®—æœºç»„æˆåŽŸç† åŽŸç , åç , è¡¥ç  åŽŸç å°±æ˜¯ç¬¦å·ä½åŠ ä¸ŠçœŸå€¼çš„ç»å¯¹å€¼, å³ç”¨ç¬¬ä¸€ä½è¡¨ç¤ºç¬¦å·, å…¶ä½™ä½è¡¨ç¤ºå€¼. æ¯”å¦‚å¦‚æžœæ˜¯8ä½äºŒè¿›åˆ¶:12$[+1]_åŽŸ$ = 0000 0001$[-1]_åŽŸ $= 1000 0001 ç¬¬ä¸€ä½æ˜¯ç¬¦å·ä½. æ‰€ä»¥8ä½äºŒè¿›åˆ¶æ•°çš„å–å€¼èŒƒå›´å°±æ˜¯:1[1111 1111 , 0111 1111] å³ï¼š1[-127 , 127] åç ï¼šæ­£æ•°çš„åç æ˜¯å…¶æœ¬èº«è´Ÿæ•°çš„åç æ˜¯åœ¨å…¶åŽŸç çš„åŸºç¡€ä¸Š, ç¬¦å·ä½ä¸å˜ï¼Œå…¶ä½™å„ä¸ªä½å–å.12[+1] = [00000001]åŽŸ = [00000001]å[-1] = [10000001]åŽŸ = [11111110]å è¡¥ç çš„è¡¨ç¤ºæ–¹æ³•æ˜¯:æ­£æ•°çš„è¡¥ç å°±æ˜¯å…¶æœ¬èº«è´Ÿæ•°çš„è¡¥ç æ˜¯åœ¨å…¶åŽŸç çš„åŸºç¡€ä¸Š, ç¬¦å·ä½ä¸å˜, å…¶ä½™å„ä½å–å, æœ€åŽ+1. (å³åœ¨åç çš„åŸºç¡€ä¸Š+1)12345è¡¥ç çš„è¡¨ç¤ºæ–¹æ³•æ˜¯:æ­£æ•°çš„è¡¥ç å°±æ˜¯å…¶æœ¬èº«è´Ÿæ•°çš„è¡¥ç æ˜¯åœ¨å…¶åŽŸç çš„åŸºç¡€ä¸Š, ç¬¦å·ä½ä¸å˜, å…¶ä½™å„ä½å–å, æœ€åŽ+1. (å³åœ¨åç çš„åŸºç¡€ä¸Š+1)[+1] = [00000001]åŽŸ = [00000001]å = [00000001]è¡¥[-1] = [10000001]åŽŸ = [11111110]å = [11111111]è¡¥ æ•°æ®åº“ æ•°æ®åº“äº‹åŠ¡çš„å››å¤§ç‰¹æ€§ï¼ˆACIDï¼‰ä»¥åŠäº‹åŠ¡çš„éš”ç¦»çº§åˆ«ä»€ä¹ˆæ˜¯æ•°æ®åº“çš„äº‹åŠ¡ï¼Ÿäº‹åŠ¡å…¶å®žå°±æ˜¯å•ä¸ªæ•°æ®é€»è¾‘å•å…ƒç»„æˆçš„å¯¹è±¡æ“ä½œé›†åˆï¼Œè€Œæ•°æ®åº“çš„ç»ˆæžç›®æ ‡å°±æ˜¯ä½¿æ•°æ®åº“ä»Žä¸€ä¸ªä¸€è‡´çš„çŠ¶æ€è½¬æ¢åˆ°å¦ä¸€ä¸ªä¸€è‡´çš„çŠ¶æ€ï¼Œè¿™å°±æ˜¯ACIDä¸­çš„ä¸€è‡´æ€§ï¼ˆConsistencyï¼‰ï¼Œè€ŒåŽŸå­æ€§ï¼ˆAtomicityï¼‰ã€éš”ç¦»æ€§ï¼ˆIsolationï¼‰ã€æŒä¹…æ€§ï¼ˆDurabilityï¼‰æ˜¯ä¸ºäº†å®žçŽ°è¿™ä¸ªç›®æ ‡çš„æ‰‹æ®µã€‚ åŽŸå­æ€§ï¼ˆAtomicityï¼‰åŽŸå­æ€§æ˜¯æŒ‡äº‹åŠ¡æ˜¯ä¸€ä¸ªä¸å¯å†åˆ†å‰²çš„å·¥ä½œå•ä½ï¼Œäº‹åŠ¡ä¸­çš„æ“ä½œè¦ä¹ˆéƒ½å‘ç”Ÿï¼Œè¦ä¹ˆéƒ½ä¸å‘ç”Ÿã€‚ ä¸€è‡´æ€§ï¼ˆConsistencyï¼‰ä¸€è‡´æ€§æ˜¯æŒ‡åœ¨äº‹åŠ¡å¼€å§‹ä¹‹å‰å’Œäº‹åŠ¡ç»“æŸä»¥åŽï¼Œæ•°æ®åº“çš„å®Œæ•´æ€§çº¦æŸæ²¡æœ‰è¢«ç ´åã€‚è¿™æ˜¯è¯´æ•°æ®åº“äº‹åŠ¡ä¸èƒ½ç ´åå…³ç³»æ•°æ®çš„å®Œæ•´æ€§ä»¥åŠä¸šåŠ¡é€»è¾‘ä¸Šçš„ä¸€è‡´æ€§ã€‚ éš”ç¦»æ€§ï¼ˆIsolationï¼‰å¤šä¸ªäº‹åŠ¡å¹¶å‘è®¿é—®æ—¶ï¼Œäº‹åŠ¡ä¹‹é—´æ˜¯éš”ç¦»çš„ï¼Œä¸€ä¸ªäº‹åŠ¡ä¸åº”è¯¥å½±å“å…¶å®ƒäº‹åŠ¡è¿è¡Œæ•ˆæžœã€‚ è¿™æŒ‡çš„æ˜¯åœ¨å¹¶å‘çŽ¯å¢ƒä¸­ï¼Œå½“ä¸åŒçš„äº‹åŠ¡åŒæ—¶æ“çºµç›¸åŒçš„æ•°æ®æ—¶ï¼Œæ¯ä¸ªäº‹åŠ¡éƒ½æœ‰å„è‡ªçš„å®Œæ•´æ•°æ®ç©ºé—´ã€‚ç”±å¹¶å‘äº‹åŠ¡æ‰€åšçš„ä¿®æ”¹å¿…é¡»ä¸Žä»»ä½•å…¶ä»–å¹¶å‘äº‹åŠ¡æ‰€åšçš„ä¿®æ”¹éš”ç¦»ã€‚äº‹åŠ¡æŸ¥çœ‹æ•°æ®æ›´æ–°æ—¶ï¼Œæ•°æ®æ‰€å¤„çš„çŠ¶æ€è¦ä¹ˆæ˜¯å¦ä¸€äº‹åŠ¡ä¿®æ”¹å®ƒä¹‹å‰çš„çŠ¶æ€ï¼Œè¦ä¹ˆæ˜¯å¦ä¸€äº‹åŠ¡ä¿®æ”¹å®ƒä¹‹åŽçš„çŠ¶æ€ï¼Œäº‹åŠ¡ä¸ä¼šæŸ¥çœ‹åˆ°ä¸­é—´çŠ¶æ€çš„æ•°æ®ã€‚ æŒä¹…æ€§ï¼ˆDurabilityï¼‰æ„å‘³ç€åœ¨äº‹åŠ¡å®Œæˆä»¥åŽï¼Œè¯¥äº‹åŠ¡æ‰€å¯¹æ•°æ®åº“æ‰€ä½œçš„æ›´æ”¹ä¾¿æŒä¹…çš„ä¿å­˜åœ¨æ•°æ®åº“ä¹‹ä¸­ï¼Œå¹¶ä¸ä¼šè¢«å›žæ»šã€‚ https://blog.csdn.net/qq_25448409/article/details/78110430https://blog.csdn.net/ranran0224/article/details/78427541 æ•°æ®åº“çš„ä¹è§‚é”å’Œæ‚²è§‚é”æ˜¯ä»€ä¹ˆï¼Ÿæ•°æ®åº“ç®¡ç†ç³»ç»Ÿï¼ˆDBMSï¼‰ä¸­çš„å¹¶å‘æŽ§åˆ¶çš„ä»»åŠ¡æ˜¯ç¡®ä¿åœ¨å¤šä¸ªäº‹åŠ¡åŒæ—¶å­˜å–æ•°æ®åº“ä¸­åŒä¸€æ•°æ®æ—¶ä¸ç ´åäº‹åŠ¡çš„éš”ç¦»æ€§å’Œç»Ÿä¸€æ€§ä»¥åŠæ•°æ®åº“çš„ç»Ÿä¸€æ€§ã€‚ä¹è§‚å¹¶å‘æŽ§åˆ¶(ä¹è§‚é”)å’Œæ‚²è§‚å¹¶å‘æŽ§åˆ¶ï¼ˆæ‚²è§‚é”ï¼‰æ˜¯å¹¶å‘æŽ§åˆ¶ä¸»è¦é‡‡ç”¨çš„æŠ€æœ¯æ‰‹æ®µã€‚æ‚²è§‚é”ï¼šå‡å®šä¼šå‘ç”Ÿå¹¶å‘å†²çªï¼Œå±è”½ä¸€åˆ‡å¯èƒ½è¿åæ•°æ®å®Œæ•´æ€§çš„æ“ä½œä¹è§‚é”ï¼šå‡è®¾ä¸ä¼šå‘ç”Ÿå¹¶å‘å†²çªï¼Œåªåœ¨æäº¤æ“ä½œæ—¶æ£€æŸ¥æ˜¯å¦è¿åæ•°æ®å®Œæ•´æ€§ã€‚ æ•°æ®åº“ä¸‰èŒƒå¼ç¬¬ä¸€èŒƒå¼ï¼ˆ1NFï¼‰ï¼šæ•°æ®åº“è¡¨ä¸­çš„å­—æ®µéƒ½æ˜¯å•ä¸€å±žæ€§çš„ï¼Œä¸å¯å†åˆ†ã€‚è¿™ä¸ªå•ä¸€å±žæ€§ç”±åŸºæœ¬ç±»åž‹æž„æˆï¼ŒåŒ…æ‹¬æ•´åž‹ã€å®žæ•°ã€å­—ç¬¦åž‹ã€é€»è¾‘åž‹ã€æ—¥æœŸåž‹ç­‰ã€‚ç¬¬äºŒèŒƒå¼ï¼ˆ2NFï¼‰ï¼šæ•°æ®åº“è¡¨ä¸­ä¸å­˜åœ¨éžå…³é”®å­—æ®µå¯¹ä»»ä¸€å€™é€‰å…³é”®å­—æ®µçš„éƒ¨åˆ†å‡½æ•°ä¾èµ–ï¼ˆéƒ¨åˆ†å‡½æ•°ä¾èµ–æŒ‡çš„æ˜¯å­˜åœ¨ç»„åˆå…³é”®å­—ä¸­çš„æŸäº›å­—æ®µå†³å®šéžå…³é”®å­—æ®µçš„æƒ…å†µï¼‰ï¼Œä¹Ÿå³æ‰€æœ‰éžå…³é”®å­—æ®µéƒ½å®Œå…¨ä¾èµ–äºŽä»»æ„ä¸€ç»„å€™é€‰å…³é”®å­—ã€‚ç¬¬ä¸‰èŒƒå¼ï¼ˆ3NFï¼‰ï¼šåœ¨ç¬¬äºŒèŒƒå¼çš„åŸºç¡€ä¸Šï¼Œæ•°æ®è¡¨ä¸­å¦‚æžœä¸å­˜åœ¨éžå…³é”®å­—æ®µå¯¹ä»»ä¸€å€™é€‰å…³é”®å­—æ®µçš„ä¼ é€’å‡½æ•°ä¾èµ–åˆ™ç¬¦åˆç¬¬ä¸‰èŒƒå¼ã€‚æ‰€è°“ä¼ é€’å‡½æ•°ä¾èµ–ï¼ŒæŒ‡çš„æ˜¯å¦‚ æžœå­˜åœ¨â€A â†’ B â†’ Câ€çš„å†³å®šå…³ç³»ï¼Œåˆ™Cä¼ é€’å‡½æ•°ä¾èµ–äºŽAã€‚å› æ­¤ï¼Œæ»¡è¶³ç¬¬ä¸‰èŒƒå¼çš„æ•°æ®åº“è¡¨åº”è¯¥ä¸å­˜åœ¨å¦‚ä¸‹ä¾èµ–å…³ç³»ï¼š å…³é”®å­—æ®µ â†’ éžå…³é”®å­—æ®µ x â†’ éžå…³é”®å­—æ®µy äº‹åŠ¡çš„å¹¶å‘é—®é¢˜ æœªæäº¤è¯»(Read Uncommitted)ï¼šå…è®¸è„è¯»ï¼Œä¹Ÿå°±æ˜¯å¯èƒ½è¯»å–åˆ°å…¶ä»–ä¼šè¯ä¸­æœªæäº¤äº‹åŠ¡ä¿®æ”¹çš„æ•°æ® æäº¤è¯»(Read Committed)ï¼šåªèƒ½è¯»å–åˆ°å·²ç»æäº¤çš„æ•°æ®ã€‚Oracleç­‰å¤šæ•°æ•°æ®åº“é»˜è®¤éƒ½æ˜¯è¯¥çº§åˆ« (ä¸é‡å¤è¯») å¯é‡å¤è¯»(Repeated Read)ï¼šå¯é‡å¤è¯»ã€‚åœ¨åŒä¸€ä¸ªäº‹åŠ¡å†…çš„æŸ¥è¯¢éƒ½æ˜¯äº‹åŠ¡å¼€å§‹æ—¶åˆ»ä¸€è‡´çš„ï¼ŒInnoDBé»˜è®¤çº§åˆ«ã€‚åœ¨SQLæ ‡å‡†ä¸­ï¼Œè¯¥éš”ç¦»çº§åˆ«æ¶ˆé™¤äº†ä¸å¯é‡å¤è¯»ï¼Œä½†æ˜¯è¿˜å­˜åœ¨å¹»è±¡è¯» ä¸²è¡Œè¯»(Serializable)ï¼šå®Œå…¨ä¸²è¡ŒåŒ–çš„è¯»ï¼Œæ¯æ¬¡è¯»éƒ½éœ€è¦èŽ·å¾—è¡¨çº§å…±äº«é”ï¼Œè¯»å†™ç›¸äº’éƒ½ä¼šé˜»å¡ž äº‹åŠ¡çš„å››ç§éš”ç¦»çº§åˆ«åœ¨æ•°æ®åº“æ“ä½œä¸­ï¼Œä¸ºäº†æœ‰æ•ˆä¿è¯å¹¶å‘è¯»å–æ•°æ®çš„æ­£ç¡®æ€§ï¼Œæå‡ºçš„äº‹åŠ¡éš”ç¦»çº§åˆ«ã€‚æˆ‘ä»¬çš„æ•°æ®åº“é”ï¼Œä¹Ÿæ˜¯ä¸ºäº†æž„å»ºè¿™äº›éš”ç¦»çº§åˆ«å­˜åœ¨çš„ã€‚ éš”ç¦»çº§åˆ« è„è¯»ï¼ˆDirty Readï¼‰ ä¸å¯é‡å¤è¯»ï¼ˆNonRepeatable Readï¼‰ å¹»è¯»ï¼ˆPhantom Readï¼‰ æœªæäº¤è¯»ï¼ˆRead uncommittedï¼‰ å¯èƒ½ å¯èƒ½ å¯èƒ½ å·²æäº¤è¯»ï¼ˆRead committedï¼‰ ä¸å¯èƒ½ å¯èƒ½ å¯èƒ½ å¯é‡å¤è¯»ï¼ˆRepeatable readï¼‰ ä¸å¯èƒ½ ä¸å¯èƒ½ å¯èƒ½ å¯ä¸²è¡ŒåŒ–ï¼ˆSerializable ï¼‰ ä¸å¯èƒ½ ä¸å¯èƒ½ ä¸å¯èƒ½ å¢žåˆ æ”¹æŸ¥æ“ä½œ 1). å¢žåŠ æœ‰ä¸¤ç§æ“ä½œä½¿ç”¨insertæ’å…¥å•è¡Œæ•°æ®ï¼š123 è¯­æ³•ï¼šinsert [into] &lt;è¡¨å&gt; [åˆ—å] values &lt;åˆ—å€¼&gt; ä¾‹ï¼šinsert into Strdents (å§“å,æ€§åˆ«,å‡ºç”Ÿæ—¥æœŸ) values (&apos;çŽ‹ä¼ŸåŽ&apos;,&apos;ç”·&apos;,&apos;1983/6/15&apos;) æ³¨æ„ï¼šå¦‚æžœçœç•¥è¡¨åï¼Œå°†ä¾æ¬¡æ’å…¥æ‰€æœ‰åˆ— ä½¿ç”¨insert,selectè¯­å¥å°†çŽ°æœ‰è¡¨ä¸­çš„ æ•°æ®æ·»åŠ åˆ°å·²æœ‰çš„æ–°è¡¨ä¸­123 è¯­æ³•ï¼šinsert into &lt;å·²æœ‰çš„æ–°è¡¨&gt; &lt;åˆ—å&gt; select &lt;åŽŸè¡¨åˆ—å&gt; from &lt;åŽŸè¡¨å&gt; ä¾‹ï¼šinsert into addressList (&apos;å§“å&apos;,&apos;åœ°å€&apos;,&apos;ç”µå­é‚®ä»¶&apos;)select name,address,email from Strdents æ³¨æ„ï¼šæŸ¥è¯¢å¾—åˆ°çš„æ•°æ®ä¸ªæ•°ã€é¡ºåºã€æ•°æ®ç±»åž‹ç­‰ï¼Œå¿…é¡»ä¸Žæ’å…¥çš„é¡¹ä¿æŒä¸€è‡´ 2). åˆ é™¤æœ‰ä¸¤ç§æ“ä½œä½¿ç”¨deleteåˆ é™¤æ•°æ®æŸäº›æ•°æ® 123 è¯­æ³•ï¼šdelete from &lt;è¡¨å&gt; [where &lt;åˆ é™¤æ¡ä»¶&gt;] ä¾‹ï¼šdelete from a where name=&apos;çŽ‹ä¼ŸåŽ&apos;ï¼ˆåˆ é™¤è¡¨aä¸­åˆ—å€¼ä¸ºçŽ‹ä¼ŸåŽçš„è¡Œï¼‰ æ³¨æ„ï¼šåˆ é™¤æ•´è¡Œä¸æ˜¯åˆ é™¤å•ä¸ªå­—æ®µï¼Œæ‰€ä»¥åœ¨deleteåŽé¢ä¸èƒ½å‡ºçŽ°å­—æ®µå ä½¿ç”¨truncate table åˆ é™¤æ•´ä¸ªè¡¨çš„æ•°æ®123 è¯­æ³•ï¼štruncate table &lt;è¡¨å&gt; ä¾‹ï¼štruncate table addressList æ³¨æ„ï¼šåˆ é™¤è¡¨çš„æ‰€æœ‰è¡Œï¼Œä½†è¡¨çš„ç»“æž„ã€åˆ—ã€çº¦æŸã€ç´¢å¼•ç­‰ä¸ä¼šè¢«åˆ é™¤ï¼›ä¸èƒ½ç”¨äºŽæœ‰å¤–å»ºçº¦æŸå¼•ç”¨çš„è¡¨ 3). ä¿®æ”¹æ•°æ®123è¯­æ³•ï¼šupdate &lt;è¡¨å&gt; set &lt;åˆ—å=æ›´æ–°å€¼&gt; [where &lt;æ›´æ–°æ¡ä»¶&gt;] ä¾‹ï¼šupdate addressList set å¹´é¾„=18 where å§“å=&apos;çŽ‹ä¼ŸåŽ&apos; æ³¨æ„ï¼šsetåŽé¢å¯ä»¥ç´§éšå¤šä¸ªæ•°æ®åˆ—çš„æ›´æ–°å€¼ï¼ˆéžæ•°å­—è¦å¼•å·ï¼‰ï¼›whereå­å¥æ˜¯å¯é€‰çš„ï¼ˆéžæ•°å­—è¦å¼•å·ï¼‰ï¼Œç”¨æ¥é™åˆ¶æ¡ä»¶ï¼Œå¦‚æžœä¸é€‰åˆ™æ•´ä¸ªè¡¨çš„æ‰€æœ‰è¡Œéƒ½è¢«æ›´æ–° 4). æŸ¥è¯¢æ•°æ® 1234567891011121314æ™®é€šæŸ¥è¯¢ è¯­æ³•ï¼šselect &lt;åˆ—å&gt; from &lt;è¡¨å&gt; [where &lt;æŸ¥è¯¢æ¡ä»¶è¡¨è¾¾è¯•&gt;] [order by &lt;æŽ’åºçš„åˆ— &gt;æ¨¡ç³ŠæŸ¥è¯¢ ä½¿ç”¨likeè¿›è¡Œæ¨¡ç³ŠæŸ¥è¯¢ (æ³¨æ„ï¼šlikeè¿ç®—å‰¯åªç”¨è¯­å­—ç¬¦ä¸²) ä¾‹ï¼šselect * from a where name like &apos;èµµ%&apos; è¯´æ˜Žï¼šæŸ¥è¯¢æ˜¾ç¤ºè¡¨aä¸­ï¼Œnameå­—æ®µç¬¬ä¸€ä¸ªå­—ä¸ºèµµçš„è®°å½•åˆ†ç»„æŸ¥è¯¢ ä½¿ç”¨group byè¿›è¡Œåˆ†ç»„æŸ¥è¯¢ ä¾‹ï¼šselect studentID as å­¦å‘˜ç¼–å·, AVG(score) as å¹³å‡æˆç»© (æ³¨é‡Š:è¿™é‡Œçš„scoreæ˜¯åˆ—å) from score (æ³¨é‡Š:è¿™é‡Œçš„scoreæ˜¯è¡¨å) group by studentIDå¤šè¡¨è”æŽ¥æŸ¥è¯¢ ä¾‹ï¼šselect a.name,b.mark å…·ä½“åˆ°MySQL æ•°æ®åº“ä¸­çš„å¢žåˆ æ”¹æŸ¥ï¼ˆå…¶å®žå°±æ˜¯å…³é”®å­—çš„æ”¹å˜ï¼Œå…¶ä»–çš„æ²¡æœ‰ä»€ä¹ˆå˜åŒ–ï¼‰ åˆ›å»ºè¡¨1cerate table if not existsï¼ˆåˆ¤æ–­æ˜¯å¦å­˜åœ¨ï¼‰ è¡¨åï¼ˆxsbï¼‰ å‘è¡¨ä¸­æ’å…¥è®°å½• 123insert into è¡¨å(xsl) values(â€˜081101â€™,â€™çŽ‹ç³â€™,â€™è®¡ç®—æœºâ€™,â€™å¥³â€™,â€™1990-2-10â€™,50,null,null);insert into xsl(å­¦å·ï¼Œå§“åï¼Œæ€»å­¦åˆ†)values(â€˜çŽ‹ç‡•â€™ï¼Œ50)ï¼›insert into xsl set å­¦å·=â€™081104â€™,å§“å=â€™éŸ¦è¨€å¹³â€™,æ€§åˆ«=â€™ç”·â€™,å‡ºç”Ÿæ—¥æœŸ=â€™1989-3-12â€™; ä¿®æ”¹è¡¨ç»“æž„ï¼ˆæ¯”å¦‚è¯´ä¿®æ”¹å­—æ®µã€ä¿®æ”¹ä¸»é”®ã€é»˜è®¤å€¼ç­‰ç­‰ï¼‰ 1234567891011121314151617æ·»åŠ å­—æ®µï¼šalter table xs2 add å®¶åº­ä½å€ varchar(100) after(æŒ‡å®šæ”¾åœ¨å“ªä¸ªå­—æ®µåŽé¢) æ€»å­¦åˆ†;//å‘xs2è¡¨ä¸­æ·»åŠ å­—æ®µâ€œå®¶åº­ä½å€â€ã€‚åˆ é™¤å­—æ®µï¼šAlter table xs2 drop å®¶åº­ä½å€;å°†xs2è¡¨ä¸­çš„å®¶åº­ä½å€å­—æ®µåˆ é™¤ã€‚æ·»åŠ ä¸»é”®ï¼šAlter table xs3 add primary key(å­¦å·);//åœ¨xs3è¡¨çš„å­¦å·å­—æ®µä¸Šæ·»åŠ ä¸€ä¸ªä¸»é”®ã€‚åˆ é™¤ä¸»é”®ï¼šAlter table xs3 drop primary key;//åˆ é™¤xs3è¡¨ä¸­çš„ä¸»é”®ï¼›æ³¨æ„ï¼šä¸€ä¸ªè¡¨ä¸­åªæœ‰ä¸€ä¸ªä¸»é”®ã€‚æ·»åŠ é»˜è®¤å€¼ï¼šAlter table xs3 alter ä¸“ä¸š set default â€˜æ±½è½¦ç»´ä¿®â€™;//ä¸ºä¸“ä¸šå­—æ®µè®¾ç½®ä¸€ä¸ªé»˜è®¤å€¼ä¸ºâ€œæ±½è½¦ç»´ä¿®â€ã€‚6ï¼Ž åˆ é™¤é»˜è®¤å€¼ï¼šAlter table xs3 alter ä¸“ä¸š drop default;//åˆ é™¤xs3è¡¨ä¸­ä¸“ä¸šå­—æ®µçš„é»˜è®¤å€¼ã€‚7ï¼Žä¿®æ”¹å­—æ®µçš„ç±»åž‹ã€å­—ç¬¦é›†ï¼šAlter table xs3 modify å§“å varchar(100) character set utf8;//å°†xs3è¡¨ä¸­çš„å§“åå­—æ®µç±»åž‹æ”¹ä¸ºvarchar(100),å­—ç¬¦é›†æ”¹ä¸ºutf8ã€‚8ï¼Žä¿®æ”¹å­—æ®µçš„åç§°ã€ç±»åž‹ï¼šAlter table xs3 change ä¸“ä¸š ä¸“ä¸šå varchar(100);//å°†ä¸“ä¸šå­—æ®µæ”¹åä¸ºä¸“ä¸šåã€‚ åˆ é™¤è¡¨ 1drop database if exists æ•°æ®åº“å (xsgl) ä¸»é”®ã€å¤–é”®å’Œç´¢å¼•çš„åŒºåˆ«ï¼Ÿ å®šä¹‰ï¼š ä¸»é”®â€“å”¯ä¸€æ ‡è¯†ä¸€æ¡è®°å½•ï¼Œä¸èƒ½æœ‰é‡å¤çš„ï¼Œä¸å…è®¸ä¸ºç©ºå¤–é”®â€“è¡¨çš„å¤–é”®æ˜¯å¦ä¸€è¡¨çš„ä¸»é”®, å¤–é”®å¯ä»¥æœ‰é‡å¤çš„, å¯ä»¥æ˜¯ç©ºå€¼ç´¢å¼•â€“è¯¥å­—æ®µæ²¡æœ‰é‡å¤å€¼ï¼Œä½†å¯ä»¥æœ‰ä¸€ä¸ªç©ºå€¼ ä½œç”¨ï¼š ä¸»é”®â€“ç”¨æ¥ä¿è¯æ•°æ®å®Œæ•´æ€§å¤–é”®â€“ç”¨æ¥å’Œå…¶ä»–è¡¨å»ºç«‹è”ç³»ç”¨çš„ç´¢å¼•â€“æ˜¯æé«˜æŸ¥è¯¢æŽ’åºçš„é€Ÿåº¦ ä¸ªæ•°ï¼š ä¸»é”®â€“ä¸»é”®åªèƒ½æœ‰ä¸€ä¸ªå¤–é”®â€“ä¸€ä¸ªè¡¨å¯ä»¥æœ‰å¤šä¸ªå¤–é”®ç´¢å¼•â€“ä¸€ä¸ªè¡¨å¯ä»¥æœ‰å¤šä¸ªå”¯ä¸€ç´¢å¼• ä»€ä¹ˆæ˜¯ä¸»é”®ï¼Ÿ è¡¨ä¸­çš„æ¯ä¸€è¡Œéƒ½åº”è¯¥å…·æœ‰å¯ä»¥å”¯ä¸€æ ‡è¯†è‡ªå·±çš„ä¸€åˆ—(æˆ–ä¸€ç»„åˆ—)ã€‚è€Œè¿™ä¸ªæ‰¿æ‹…æ ‡è¯†ä½œç”¨çš„åˆ—ç§°ä¸ºä¸»é”®ã€‚ä¸»é”®çš„ä¸¤ä¸ªä½œç”¨ï¼š æƒŸä¸€åœ°æ ‡è¯†ä¸€è¡Œ ä½œä¸ºä¸€ä¸ªå¯ä»¥è¢«å¤–é”®æœ‰æ•ˆå¼•ç”¨çš„å¯¹è±¡ã€‚ ä¸»é”®å’Œç´¢å¼•çš„åŒºåˆ«ï¼Ÿ ä¸»é”®ä¸€å®šæ˜¯å”¯ä¸€æ€§ç´¢å¼•ï¼Œå”¯ä¸€æ€§ç´¢å¼•å¹¶ä¸ä¸€å®šå°±æ˜¯ä¸»é”®ã€‚ ä¸€ä¸ªè¡¨ä¸­å¯ä»¥æœ‰å¤šä¸ªå”¯ä¸€æ€§ç´¢å¼•ï¼Œä½†åªèƒ½æœ‰ä¸€ä¸ªä¸»é”®ã€‚3.ä¸»é”®åˆ—ä¸å…è®¸ç©ºå€¼ï¼Œè€Œå”¯ä¸€æ€§ç´¢å¼•åˆ—å…è®¸ç©ºå€¼ï¼ˆä¸è¿‡æœ€å¥½éƒ½ä¸è¦æœ‰nullï¼‰ã€‚ ç´¢å¼•å¯ä»¥æé«˜æŸ¥è¯¢çš„é€Ÿåº¦ã€‚ ç´¢å¼•å¯ä»¥æé«˜æŸ¥è¯¢é€Ÿåº¦,å®ƒå°±ç›¸å½“äºŽå­—å…¸çš„ç›®å½•,å¯ä»¥é€šè¿‡å®ƒå¾ˆå¿«æŸ¥è¯¢åˆ°æƒ³è¦çš„ç»“æžœ,è€Œä¸éœ€è¦è¿›è¡Œå…¨è¡¨æ‰«æ. union å’Œunion allçš„åŒºåˆ« unionä¼šå¯¹ç»“æžœé›†è¿›è¡Œå¤„ç†æŽ’é™¤æŽ‰ç›¸åŒçš„ç»“æžœunion all ä¸ä¼šå¯¹ç»“æžœé›†è¿›è¡Œå¤„ç†ï¼Œä¸ä¼šå¤„ç†æŽ‰ç›¸åŒçš„ç»“æžœ preparedStatementå’Œstatementçš„åŒºåˆ« Statementçš„ä½œç”¨ä¸ºä¸€æ¡Sqlè¯­å¥ç”Ÿæˆæ‰§è¡Œè®¡åˆ’ï¼Œ å»ºç«‹è¿žæŽ¥æ•°æ®åº“ä¹‹ç±»çš„ã€‚ statementæ¯æ¬¡æ‰§è¡Œsqlè¯­å¥ï¼Œç›¸å…³æ•°æ®åº“éƒ½è¦æ‰§è¡Œsqlè¯­å¥çš„ç¼–è¯‘ï¼Œpreparedstatementæ˜¯é¢„ç¼–è¯‘å¾—,preparedstatementæ”¯æŒæ‰¹å¤„ç† PreparedStatementæ˜¯é¢„ç¼–è¯‘çš„,å¯¹äºŽæ‰¹é‡å¤„ç†å¯ä»¥å¤§å¤§æé«˜æ•ˆçŽ‡ã€‚ä½¿ç”¨ Statement å¯¹è±¡ã€‚åœ¨å¯¹æ•°æ®åº“åªæ‰§è¡Œä¸€æ¬¡æ€§å­˜å–çš„æ—¶ä¾¯ï¼Œç”¨ Statement å¯¹è±¡è¿›è¡Œå¤„ç†ã€‚PreparedStatementå¯¹è±¡çš„å¼€é”€æ¯”Statementå¤§ï¼Œå¯¹äºŽä¸€æ¬¡æ€§æ“ä½œå¹¶ä¸ä¼šå¸¦æ¥é¢å¤–çš„å¥½å¤„ã€‚ ä»»ä½•æ—¶å€™ä½¿ç”¨preparedStatementè€Œä¸æ˜¯statementPreparedStatementé¢„ç¼–è¯‘ï¼Œé˜²æ­¢SQLæ³¨å…¥PreparedStatementå¤šæ¬¡ä½¿ç”¨å¯æé«˜æ•ˆçŽ‡ dropã€truncateå’Œdeleteçš„åŒºåˆ« æ‰§è¡Œé€Ÿåº¦ drop &gt; truncate &gt; deletedeleteä¸€è¡Œä¸€è¡Œåˆ é™¤ï¼Œtruncate åˆ é™¤è¡¨å…¨éƒ¨æ•°æ®ï¼Œdrop è¿žè¡¨æ•°æ®å’Œè¡¨ç»“æž„ä¸€èµ·åˆ é™¤delete æ˜¯ DML è¯­å¥ï¼Œæ²¡æäº¤äº‹åŠ¡è¿˜å¯ä»¥å›žæ»šï¼Œtruncate å’Œ drop æ˜¯ DDL è¯­å¥ï¼Œæ“ä½œå®Œé©¬ä¸Šç”Ÿæ•ˆï¼Œä¸èƒ½å›žæ»šæœ‰FOREIGN KEY çº¦æŸå¼•ç”¨çš„è¡¨ï¼Œä¸èƒ½ä½¿ç”¨ TRUNCATE TABLEï¼Œè€Œåº”ä½¿ç”¨ä¸å¸¦ WHERE å­å¥çš„ DELETE è¯­å¥deleteåˆ é™¤è¡Œä¼šå‡ºçŽ°idä¸è”ç³»ï¼Œtruncateæ˜¯idé‡æ–°å¼€å§‹ sql è¯­å¥ join æ“ä½œ inner join å†…è¿žæŽ¥, ä¸¤è€…éƒ½æœ‰çš„æ•°æ® è¿”å›ž left join ä»¥å·¦è¾¹æ•°æ®ä½œä¸ºè¿”å›žçš„è¡Œæ•°ï¼Œå³è¾¹çš„æ•°æ®å¦‚æžœæ²¡æœ‰åˆ™ä½¿ç”¨ null å¡«å…… right join å’Œä¸Šé¢çš„ç›¸å full outer join ä¸€èˆ¬è¢«è¯‘ä½œå¤–è¿žæŽ¥ã€å…¨è¿žæŽ¥ è¯¦è§£çš„ç»†èŠ‚å¯ä»¥å‚è€ƒè¿™é‡Œï¼Œå›¾è§£ SQL é‡Œçš„å„ç§ JOIN æŸ¥è¯¢æ•°æ® a. æŸ¥è¯¢è¯­å¥çš„åŸºæœ¬è¯­æ³• 1234567891011SELECT column_1, column_2, ...FROM table_1[INNER | LEFT |RIGHT] JOIN table_2 ON conditionsWHERE conditionsGROUP BY column_1HAVING group_conditionsORDER BY column_1LIMIT offset, length; è¯¥SELECTè¯­å¥ç”±å‡ ä¸ªå­å¥ç»„æˆï¼Œå¦‚ä¸‹é¢çš„åˆ—è¡¨æ‰€è¿°ï¼š SELECTåŽé¢ä»¥é€—å·åˆ†éš”çš„å­—æ®µåç§°æˆ–æ˜Ÿå·ï¼ˆ*ï¼‰ï¼Œè¡¨ç¤ºè¦è¿”å›žçš„åˆ—ã€‚ FROMæŒ‡å®šè¦æŸ¥è¯¢æ•°æ®çš„è¡¨æˆ–è§†å›¾ã€‚ JOINåŸºäºŽæŸäº›è¿žæŽ¥æ¡ä»¶ä»Žå…¶ä»–è¡¨èŽ·å–æ•°æ®ã€‚ WHEREè¿‡æ»¤ç»“æžœé›†ä¸­çš„è¡Œã€‚ GROUP BYå°†æ•°æ®åˆ†ç»„å¹¶å¯¹æ¯ä¸ªç»„åº”ç”¨èšåˆå‡½æ•°ã€‚ HAVINGåŸºäºŽGROUP BYå­å¥å®šä¹‰çš„ç»„ç­›é€‰ç»„ã€‚ ORDER BYæŒ‡å®šç”¨äºŽæŽ’åºå­—æ®µã€‚ LIMITçº¦æŸè¿”å›žçš„è¡Œæ•°ã€‚ SELECTå’ŒFROMæŸ¥è¯¢è¯­å¥ä¸­å¿…é¡»çš„ã€‚å…¶ä»–éƒ¨åˆ†æ˜¯å¯é€‰çš„ã€‚ b. åœ¨å•ä¸ªè¡¨ä¸ŠæŸ¥è¯¢æ•°æ® 123456select * from STUDENT where STU_AGE&gt;13;select * from STUDENT where STU_AGE in(11,12);select * from STUDENT where STU_AGE between 13 and 15;select * from STUDENT where STU_AGE NOT IN(13,14,16);select * from STUDENT where STU_ID&lt;2005 OR STU_ID&gt;2015; æ¨¡ç³ŠæŸ¥è¯¢ like å…³é”®å­— 12select * from STUDENT where STU_NAME LIKE &apos;%çŽ‹&apos;; #è¡¨ç¤ºåŒ¹é…ä»»ä½•ä»¥çŽ‹ç»“å°¾çš„select * from STUDENT where STU_NAME LIKE &apos;é˜¿%&apos;; # è¡¨ç¤ºåŒ¹é…ä»»ä½•ä»¥é˜¿å¼€å¤´çš„ â€œå­—ç¬¦ä¸²â€å‚æ•°çš„å€¼å¯ä»¥æ˜¯ä¸€ä¸ªå®Œæ•´çš„å­—ç¬¦ä¸²ï¼Œä¹Ÿå¯ä»¥æ˜¯åŒ…å«ç™¾åˆ†å·(%)æˆ–è€…ä¸‹åˆ’çº¿()çš„é€šé…å­—ç¬¦ã€‚äºŒè€…æœ‰å¾ˆå¤§åŒºåˆ«â€œ%â€å¯ä»¥ä»£è¡¨ä»»æ„é•¿åº¦çš„å­—ç¬¦ä¸²ï¼Œé•¿åº¦å¯ä»¥ä¸º0;â€œâ€åªèƒ½è¡¨ç¤ºå•ä¸ªå­—ç¬¦ã€‚ c. ä½¿ç”¨èšåˆå‡½æ•°æŸ¥è¯¢æ•°æ® mysql ä¸­çš„ max min sum avg cout äº”ä¸ªç»Ÿè®¡å‡½æ•°ï¼ˆèšåˆå‡½æ•°ï¼‰ 12345select * from STUDENT group by STU_SEX;select STU_SEX,group_concat(STU_NAME) from STUDENT group by STU_SEX; #å¦‚æžœæƒ³çœ‹åˆ†ç»„çš„å†…å®¹ï¼Œå¯ä»¥åŠ groub_concat select EMP_DEP,count(*) from EMPLOYEES where EMP_SALARY&gt;=500 group by EMP_DEP; å¸¦æ¡ä»¶çš„groub by å­—æ®µ havingï¼Œåˆ©ç”¨HAVINGè¯­å¥è¿‡æ»¤åˆ†ç»„æ•°æ® æ±‚æ¯ä¸ªéƒ¨é—¨çš„å·¥èµ„å¹³å‡å€¼ 1select EMP_DEP,avg(EMP_SALARY),group_concat(EMP_NAME)from EMPLOYEES group by EMP_DEP HAVING avg(EMP_SALARY) &gt;=6000; æŸ¥æ‰¾å¹³å‡å·¥èµ„å¤§äºŽ6000çš„éƒ¨é—¨ï¼Œå¹¶æŠŠéƒ¨é—¨é‡Œçš„äººå…¨éƒ¨åˆ—å‡ºæ¥ ä¸€èˆ¬ groupby å’Œ ç»Ÿè®¡å‡½æ•°ä¸€å—ä½¿ç”¨ï¼Œè¿™æ ·æ‰æ˜¯æ¯”è¾ƒæœ‰æ„ä¹‰çš„ï¼Œ è¿™ä¸ªæ‰æ˜¯æœ‰å†…å®¹çš„ d. å¤šè¡¨ä¸Šè”åˆæŸ¥è¯¢ å¤šè¡¨ä¸Šè”åˆæŸ¥è¯¢åˆ†ä¸ºå†…è¿žæŽ¥æŸ¥è¯¢å’Œå¤–è¿žæŽ¥æŸ¥è¯¢ éšå¼å†…è¿žæŽ¥æŸ¥è¯¢ 1select STUDENT.STU_ID,STUDENT.STU_NAME,STUDENT.STU_AGE,STUDENT.STU_SEX,GRADE.STU_SCORE from STUDENT,GRADE WHERE STUDENT.STU_ID=GRADE.STU_ID AND GRADE.STU_SCORE &gt;=90; æ˜¾å¼å†…è¿žæŽ¥æŸ¥è¯¢1select STUDENT.STU_ID,STUDENT.STU_NAME,STUDENT.STU_AGE,STUDENT.STU_SEX,GRADE.STU_SCORE from STUDENT inner join GRADE on STUDENT.STU_ID=GRADE.STU_ID AND GRADE.STU_SCORE &gt;=90; e. å­æŸ¥è¯¢ ä»¥ä¸€ä¸ªæŸ¥è¯¢selectçš„ç»“æžœä½œä¸ºå¦ä¸€ä¸ªæŸ¥è¯¢çš„æ¡ä»¶ æŸ¥æ‰¾å¤§äºŽ85åˆ†çš„å­¦ç”Ÿä¿¡æ¯1select * from STUDENT where STU_ID IN(select STU_ID from GRADE where STU_SCORE&gt;85); EXISTSå’ŒNOT EXISTSæ“ä½œç¬¦åªæµ‹è¯•æŸä¸ªå­æŸ¥è¯¢æ˜¯å¦è¿”å›žäº†æ•°æ®è¡Œã€‚å¦‚æžœæ˜¯ï¼ŒEXISTSå°†æ˜¯trueï¼ŒNOT EXISTSå°†æ˜¯falseã€‚ å¦‚æžœæœ‰å­¦ç”Ÿæˆç»©å¤§äºŽ100ï¼Œæ‰æŸ¥è¯¢æ‰€æœ‰çš„å­¦ç”Ÿä¿¡æ¯1select * from STUDENT where EXISTS (select STU_ID from GRADE where STU_SCORE&gt;=100); ALLã€ANYå’ŒSOMEå­æŸ¥è¯¢anyå’Œallçš„æ“ä½œç¬¦å¸¸è§ç”¨æ³•æ˜¯ç»“åˆä¸€ä¸ªç›¸å¯¹æ¯”è¾ƒæ“ä½œç¬¦å¯¹ä¸€ä¸ªæ•°æ®åˆ—å­æŸ¥è¯¢çš„ç»“æžœè¿›è¡Œæµ‹è¯•ã€‚å®ƒä»¬æµ‹è¯•æ¯”è¾ƒå€¼æ˜¯å¦ä¸Žå­æŸ¥è¯¢æ‰€è¿”å›žçš„å…¨éƒ¨æˆ–ä¸€éƒ¨åˆ†å€¼åŒ¹é…ã€‚æ¯”æ–¹è¯´ï¼Œå¦‚æžœæ¯”è¾ƒå€¼å°äºŽæˆ–ç­‰äºŽå­æŸ¥è¯¢æ‰€è¿”å›žçš„æ¯ä¸€ä¸ªå€¼ï¼Œ&lt;=allå°†æ˜¯trueï¼Œåªè¦æ¯”è¾ƒå€¼å°äºŽæˆ–ç­‰äºŽå­æŸ¥è¯¢æ‰€è¿”å›žçš„ä»»ä½•ä¸€ä¸ªå€¼ï¼Œ&lt;=anyå°†æ˜¯trueã€‚someæ˜¯anyçš„ä¸€ä¸ªåŒä¹‰è¯ã€‚ 123select STU_ID from GRADE where STU_SCORE &lt;67;select * from STUDENT where STU_ID &gt;= any (select STU_ID from GRADE where STU_SCORE &lt;67); f. åˆå¹¶æŸ¥è¯¢ç»“æžœ union æ˜¯åŽ»é‡çš„ç»“æžœï¼Œ union all æ˜¯ä¸åŽ»é‡çš„ç»“æžœ 1234SELECTè¯­å¥1UNION | UNION ALLSELECTè¯­å¥2UNION | UNION ALL â€¦. g. æŽ’åºå’Œå–æ•° order by price //é»˜è®¤å‡åºæŽ’åˆ— order by price desc //é™åºæŽ’åˆ— order by price asc //å‡åºæŽ’åˆ—ï¼Œä¸Žé»˜è®¤ä¸€æ · order by rand() //éšæœºæŽ’åˆ—ï¼Œæ•ˆçŽ‡ä¸é«˜ 123select * from GRADE where STU_SCORE &gt;80 order by STU_SCORE;select * from GRADE where STU_SCORE &gt;80 order by STU_SCORE ASC;select * from GRADE where STU_SCORE &gt;80 order by STU_SCORE desc; g. limit limit [offset,] Noffset åç§»é‡ï¼Œå¯é€‰ï¼Œä¸å†™åˆ™ç›¸å½“äºŽlimit 0,Nï¼›N å–å‡ºæ¡ç›® å–åˆ†æ•°æŽ’ååœ¨10-15ä¹‹é—´çš„5æ¡1select * from GRADE order by STU_SCORE desc limit 10,5 g. ä¸ºè¡¨å’Œå­—æ®µé‡å‘½å 1select STU_ID as &apos;å­¦å·&apos;,STU_SCORE as &apos;åˆ†æ•°&apos; from GRADE; h. ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æŸ¥è¯¢ æ­£åˆ™è¡¨è¾¾å¼æ˜¯ç”¨æŸç§æ¨¡å¼åŽ»åŒ¹é…ä¸€ç±»å­—ç¬¦ä¸²çš„ä¸€ä¸ªæ–¹å¼ã€‚ä¾‹å¦‚ï¼Œä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼å¯ä»¥æŸ¥è¯¢å‡ºåŒ…å«Aã€Bã€Cå…¶ä¸­ä»»ä¸€å­—æ¯çš„å­—ç¬¦ä¸²ã€‚æ­£åˆ™è¡¨è¾¾å¼çš„æŸ¥è¯¢èƒ½åŠ›æ¯”é€šé…å­—ç¬¦çš„æŸ¥è¯¢èƒ½åŠ›æ›´å¼ºå¤§ï¼Œè€Œä¸”æ›´åŠ çš„çµæ´»ã€‚æ­£åˆ™è¡¨è¾¾å¼å¯ä»¥åº”ç”¨äºŽéžå¸¸å¤æ‚æŸ¥è¯¢ã€‚MySQLä¸­ï¼Œä½¿ç”¨REGEXPå…³é”®å­—æ¥åŒ¹é…æŸ¥è¯¢æ­£åˆ™è¡¨è¾¾å¼ã€‚å…¶åŸºæœ¬å½¢å¼å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425ä½¿ç”¨å­—ç¬¦â€œ^â€å¯ä»¥åŒ¹é…ä»¥ç‰¹å®šå­—ç¬¦æˆ–å­—ç¬¦ä¸²å¼€å¤´çš„è®°å½•ã€‚select * from STUDENT where STU_NAME REGEXP &apos;^é˜¿&apos;;ä»¥æ•°å­—å¼€å¤´select * from STUDENT where STU_NAME REGEXP &apos;^[0-9]&apos;;ä»¥æ•°å­—ç»“å°¾select * from STUDENT where STU_NAME REGEXP &apos;[0-9]$&apos;;ä»¥wå¼€å¤´,ä»¥æ•°å­—ç»“æŸï¼Œä¸­é—´æœ‰4ä¸ªselect * from STUDENT where STU_NAME REGEXP &apos;^w....[0-9]$&apos;;æŸ¥è¯¢æ‰€æœ‰åŒ…å«æœ‰æ•°å­—å’Œå°å†™å­—æ¯çš„select * from STUDENT where STU_NAME REGEXP &apos;[0-9a-z]&apos;;oå‡ºçŽ°2æ¬¡select * from STUDENT where STU_NAME REGEXP &apos;o&#123;2&#125;&apos;;faè‡³å°‘å‡ºçŽ°ä¸€æ¬¡select * from STUDENT where STU_NAME REGEXP &apos;(fa)+&apos;; å¤ä¹ çš„æ—¶å€™ï¼Œä¸€å®šè¦çœ‹çœ‹è¿™ä¸ªå¸–å­MySqlåŸºæœ¬æŸ¥è¯¢ã€è¿žæŽ¥æŸ¥è¯¢ã€å­æŸ¥è¯¢ã€æ­£åˆ™è¡¨è¾¾æŸ¥è¯¢è®²è§£ MySQL æŸ¥è¯¢è¯­å¥selectè®²è§£ä¸Žç»ƒä¹  æ•°å­¦ ç­‰å·®æ•°åˆ— é€šé¡¹å…¬å¼ $$1, 5, 9, 13, â€¦ d=4, \quad a_{n}=1+(n-1) \times 4=4 n-3$$æ‰€ä»¥ä¸€èˆ¬åŒ–$$a_n=a_1+ (n-1)d$$ç­‰å·®ä¸­é¡¹å¦‚æžœä¸‰ä¸ªæ•°å­— $a, b, c$æˆç­‰å·®æ•°åˆ—ï¼Œé‚£ä¹ˆ $b$ æ˜¯ $a$ å’Œ$c$ çš„ç­‰å·®ä¸­é¡¹ã€‚ ç­‰å·®æ±‚å’Œ æ•°åˆ—ï¼š $$S_n = a_1 + a_2 + a_3 + â€¦â€¦ + a_n$$é‚£ä¹ˆå¯ä»¥å¾—åˆ°, $$\begin{split}S_n &amp;= a_1 + (a_1 + d) + (a_1 + 2d) + â€¦â€¦ + [ a_1 + (n â€“ 1)d ] \\S_n &amp;= a_n + (a_n â€“ d) + (a_n â€“ 2d) + â€¦â€¦ + [ a_n â€“ (n â€“ 1)d ]\end{split}$$ä¸Šé¢ä¸¤ä¸ªå¼å­ç›¸åŠ å°±å¯ä»¥å¾—åˆ°$$2S_n = n (a_1 + a_n)$$å¦‚æžœå†åŠ ä¸Šé€šé¡¹å…¬å¼ï¼Œé‚£ä¹ˆå¯ä»¥å¾—åˆ°ä¸¤ä¸ªå¸¸è§çš„æ±‚è§£å…¬å¼ã€‚ $$\begin{split}S_n &amp;= \frac{n (a_1 + a_n)}{ 2} \\S_n &amp;= \frac{na_1 + n (n â€“ 1) d }{2}\end{split}$$ ç­‰æ¯”æ•°åˆ— é€šé¡¹å…¬å¼$$a_n =a_1q^{n-1}$$ ä¸¾ä¸ªæ —å­ $$ 4ï¼Œâ€“8ï¼Œ16ï¼Œâ€“32ï¼Œ64 â€¦ â€¦ q = â€“2ï¼Œ an = 4 (â€“2) nâ€“1 $$ç­‰æ¯”ä¸­é¡¹ å¦‚æžœ $a$, $b$, $c$ æ˜¯ç­‰æ¯”æ•°åˆ—ï¼Œé‚£ä¹ˆ $b$ å°±æ˜¯è¯¥æ•°åˆ—çš„ç­‰æ¯”ä¸­é¡¹. ç­‰æ¯”æ±‚å’Œ $$\begin{split}S_n &amp;= a_1 + a_1q + a_1q^2 + â€¦â€¦ + a_1q^{n â€“ 1} \\qS_n &amp;= a_1q + a_1q^2 + â€¦â€¦ + a_1q^{n â€“ 1} + a_1q^n\end{split}$$ä¸Šå¼ç›¸å‡ï¼Œé‚£ä¹ˆå¯ä»¥å¾—åˆ°$$(1 â€“ q) S_n = a_1 (1 â€“ q^n )$$æ•´ç†å¾—$$S_{n}=\frac{a_{1}\left(1-q^{n}\right)}{1-q}=\frac{a_{1}-a_{n} q}{1-q} \quad(q \neq 1)$$ æ•°åˆ—æ±‚å’Œ åˆ†ç»„æ±‚å’Œ é€šé¡¹è™½ä¸æ˜¯ç­‰å·®æˆ–ç­‰æ¯”æ•°åˆ—ï¼Œä½†é€šé¡¹æ˜¯å¯ä»¥ç”±ç­‰å·®æˆ–è€…ç­‰æ¯”æ•°åˆ—å’Œçš„å½¢å¼å¾—åˆ°ï¼Œé‚£ä¹ˆå¯ä»¥è¿›è¡Œæ‹†åˆ†ï¼Œåˆ©ç”¨æœ€åŸºæœ¬çš„æ•°åˆ—å…¬å¼æ±‚å’Œè®¡ç®—ã€‚æ¯”å¦‚è¯´ è£‚é¡¹ç›¸æ¶ˆ æŠŠæ•°åˆ—å’Œä¸­å„é¡¹è£‚å¼€ä¹‹åŽï¼Œå¯ä»¥æ¶ˆé™¤ä¸€éƒ¨åˆ†ä»Žè€Œè®¡ç®—æ•°åˆ—å’Œï¼Œé€‚ç”¨äºŽé€šé¡¹æ˜¯ $\frac{1}{a_n.a_{n+1}}$ çš„å‰ $n$ é¡¹å’Œï¼Œå…¶ä¸­ $a_n$ æ˜¯ç­‰å·®æ•°åˆ—ï¼Œé‚£ä¹ˆ$\frac{1}{a_n a_{n+1}} = \frac{1}{d}(\frac{1}{a_n} -\frac{1}{a_{n+1}})$ ä¸ºç­‰å·®æ•°åˆ—ã€‚æ¯”å¦‚è¯´ï¼Œå¸¸è§çš„æ‹†é¡¹çš„æ–¹æ³•æœ‰ï¼š $\frac{1}{n(n+1)}=\frac{1}{n}-\frac{1}{n+1}$ $\frac{1}{\sqrt{a}+\sqrt{b}}=\frac{1}{a-b}(\sqrt{a}-\sqrt{b})$ é”™ä½ç›¸å‡ åˆ©ç”¨ç­‰æ¯”æ•°åˆ—æ±‚å’Œå…¬å¼æŽ¨å¯¼ï¼Œä¸€èˆ¬å¯ä»¥è§£å†³ç­‰å·®ä¹˜ç­‰æ¯”æ•°åˆ—çš„æ±‚å’Œ $$= \begin{cases}S_n = a_1 + a_2 + a_3 + â€¦â€¦ + a_n&amp; \\qS_n = a_2 + a_3 + â€¦â€¦ + a_n+ a_{n+1}&amp;\end{cases}$$ ç„¶åŽå¾—åˆ°$$(1-q)S_n =a_1-a_{n+1}$$ é‚£ä¹ˆ$$S_n= \begin{cases}na_1&amp; (q =1)\\\frac{a_{1}\left(1-q^{n}\right)}{1-q}=\frac{a_{1}-a_{n} q}{1-q} &amp; (q \neq 1)\end{cases}$$ ç¼–ç¨‹è¯­è¨€ä¸­çš„å–æ¨¡å’Œå–ä½™ åœ¨matlabä¸­ï¼Œå…³äºŽå–ä½™å’Œå–æ¨¡æ˜¯è¿™ä¹ˆå®šä¹‰çš„ï¼šå½“yâ‰ 0æ—¶ï¼šå–ä½™ï¼šrem(x,y)=x-y.fix(x./y)å–æ¨¡ï¼šmod(x,y)=x-y.floor(x./y)å…¶ä¸­ï¼Œfix()å‡½æ•°æ˜¯å‘0å–æ•´ï¼Œfloor()å‡½æ•°æ˜¯å‘è´Ÿæ— ç©·å–æ•´ä»¥å‰è¾¹çš„è¿ç®—ä¸ºä¾‹ï¼š7/ï¼ˆ-3ï¼‰=-2.3ï¼Œåœ¨è¿™ä¸ªè¿ç®—ä¸­ï¼Œxä¸º7ï¼Œyä¸º-3ï¼Œåˆ†åˆ«è°ƒç”¨fix()å’Œfloor()ä¸¤ä¸ªå‡½æ•°ï¼Œå¾—åˆ°ç»“æžœæ˜¯ï¼šfixï¼ˆ-2.3ï¼‰=-2floorï¼ˆ-2.3ï¼‰=-3æ‰€ä»¥ï¼Œremï¼ˆ7ï¼Œ-3ï¼‰=1ï¼Œmodï¼ˆ7ï¼Œ-3ï¼‰=-2 å¯¹äºŽæ•´æ•° aï¼Œb æ¥è¯´ï¼Œå–æ¨¡è¿ç®—æˆ–è€…æ±‚ä½™è¿ç®—çš„æ–¹æ³•è¦åˆ†å¦‚ä¸‹ä¸¤æ­¥ï¼š1ã€æ±‚æ•´æ•°å•†ï¼šc=a/b2ã€è®¡ç®—æ¨¡æˆ–è€…ä½™æ•°ï¼šr=a-(c*b) æ±‚æ¨¡è¿ç®—å’Œæ±‚ä½™è¿ç®—åœ¨ç¬¬ä¸€æ­¥ä¸åŒå–ä½™è¿ç®—åœ¨è®¡ç®—å•†å€¼å‘0æ–¹å‘èˆå¼ƒå°æ•°ä½å–æ¨¡è¿ç®—åœ¨è®¡ç®—å•†å€¼å‘è´Ÿæ— ç©·æ–¹å‘èˆå¼ƒå°æ•°ä½ æ¯”å¦‚è¯´ 12345678910111213141516&gt;&gt; mod(5,2)ans =1 % é™¤æ•°æ˜¯æ­£ï¼Œä½™æ•°å°±æ˜¯æ­£&gt;&gt; mod(-5,2)ans =1&gt;&gt; mod(5,-2)ans =-1 % é™¤æ•°æ˜¯è´Ÿï¼Œä½™æ•°å°±æ˜¯è´Ÿ&gt;&gt; mod(-5,-2)ans =-1 % ç”¨ rem æ—¶ï¼Œä¸ç®¡é™¤æ•°æ˜¯æ­£æ˜¯è´Ÿï¼Œä½™æ•°çš„ç¬¦å·ä¸Žè¢«é™¤æ•°çš„ç¬¦å·ç›¸åŒ&gt;&gt; rem(5,2)ans =1 % è¢«é™¤æ•°æ˜¯æ­£ï¼Œä½™æ•°å°±æ˜¯æ­£&gt;&gt; rem(5,-2); ans =1&gt;&gt; rem(-5,2)ans =-1 % è¢«é™¤æ•°æ˜¯è´Ÿï¼Œ ä½™æ•°å°±æ˜¯è´Ÿ&gt;&gt; rem(-5,-2)ans =-1 å½“ä¸¤ä¸ªæ“ä½œæ•°æ˜¯åŒå·çš„æ—¶å€™ï¼Œä¸¤è€…æ˜¯æ²¡æœ‰åŒºåˆ«çš„ã€‚å¼‚å·æ—¶å€™ï¼Œè¿™ä¸¤è€…æ˜¯ä¸ä¸€æ ·çš„ç»“æžœã€‚ä¸€èˆ¬è®¡ç®—æœºä¸­ä½¿ç”¨æ±‚æ¨¡è¿ç®—ï¼Œæ•°å­¦ä¸­ä½¿ç”¨æ±‚ä½™è¿ç®—ã€‚ åœ¨Cè¯­è¨€ä¸­ï¼Œ%ç¬¦å·è¡¨ç¤ºçš„æ˜¯æ±‚ä½™è¿ç®—ï¼Œåœ¨pythonè„šæœ¬ä¸­ï¼Œ%è¡¨ç¤ºçš„æ˜¯å–æ¨¡ã€‚ï¼ˆé€šå¸¸å–æ¨¡è¿ç®—ä¸­bä¸å…è®¸æ˜¯è´Ÿæ•°ï¼Œä½†æ˜¯åœ¨python 2.5.1é‡Œå¯ä»¥åœ¨%åŽé¢è·Ÿè´Ÿæ•°ï¼Œå› ä¸ºpythonè¯­è¨€ä¸­é™¤æ³•çš„ç»“æžœæ˜¯å‘0èˆå…¥ï¼Œå› æ­¤è®¡ç®—ç»“æžœæ˜¯å–æ¨¡ï¼ï¼‰ æ¦‚çŽ‡é¢˜ ä¼¯åŠªåˆ©å®žéªŒäº‹ä»¶Eåªæœ‰ä¸¤ç§å¯èƒ½ç»“æžœï¼šå‘ç”Ÿå’Œä¸å‘ç”Ÿï¼Œæ¦‚çŽ‡åˆ†åˆ«ä¸ºpå’Œï¼ˆ1-pï¼‰ã€‚Eç‹¬ç«‹é‡å¤è¿›è¡Œnæ¬¡å¯ä»¥ç§°ä¸ºnæ¬¡ä¼¯åŠªåˆ©è¯•éªŒã€‚ äºŒé¡¹åˆ†å¸ƒnæ¬¡ä¼¯åŠªåˆ©è¯•éªŒå‘ç”Ÿkæ¬¡çš„å¯èƒ½æ€§æœä»ŽäºŒé¡¹åˆ†å¸ƒï¼š å‡ ä½•åˆ†å¸ƒä¸¾ä¾‹ï¼šä¸€ä¸ªå…­é¢çš„éª°å­ï¼Œå¹³å‡éœ€è¦æŠ•æŽ·å¤šå°‘æ¬¡å¯ä»¥æŽ·å‡ºæ•°å­—6:p = 1/6, 1-p = 5/6E(X) = 1/p = 6 æ¬¡ æŽ’åˆ— $$A_{n}^{m}=\frac{n !}{(n-m) !}$$ ç»„åˆ C(\begin{array}{c}{n} \ {m}\end{array})=\frac{n !}{m !(n-m) !} æŽ’åˆ—ç»„åˆçš„å…³ç³»$$A_{n}^{m}=m ! C_{n}^{m}$$ å¤å…¸æ¦‚åž‹ åœ¨ä¸€ä¸ªæœ‰é™çš„é›†åˆ S ä¸­éšæœºæŠ½å–ä¸€ä¸ªå…ƒç´ ï¼Œæ±‚è¯¥å…ƒç´ å±žäºŽå­é›† T çš„æ¦‚çŽ‡ï¼›æ¦‚çŽ‡ p = å­é›† T ä¸­å…ƒç´ çš„æ•°é‡ / é›†åˆ S ä¸­å…ƒç´ çš„æ•°é‡ å‡ ä½•æ¦‚åž‹ åœ¨ä¸€ä¸ªé›†åˆå½¢çŠ¶ S ä¸­éšæœºé€‰å–ä¸€ç‚¹ï¼Œæ±‚è¯¥ç‚¹å±žäºŽå­å½¢çŠ¶ T çš„æ¦‚çŽ‡ï¼›æ¦‚çŽ‡ p = T çš„é¢ç§¯ / S çš„é¢ç§¯ 54 å¼ ç‰Œï¼Œå¹³å‡åˆ†æˆ 6 ä»½ï¼Œæ±‚å¤§å°çŽ‹åœ¨ä¸€èµ·çš„æ¦‚çŽ‡ï¼Ÿ 12345å°† 54 å¼ ç‰Œæ”¾å…¥ 1-54 çš„æ–¹æ³•æ•°ï¼ša = 54!æ¯ä»½ 9 å¼ ç‰Œï¼Œå¤§å°çŽ‹åœ¨ä¸€èµ·çš„æ–¹æ³•æ•°ï¼šb = 6 * 9 * 8 * 52!å¤§å°çŽ‹åŒåœ¨ä¸€å †çš„æ¦‚çŽ‡ï¼š9 * 8 * 52!å…± 6 å †æ¦‚çŽ‡ p = b/a = 8/53 æœ‰ä¸€å¯¹å¤«å¦‡ï¼Œå…ˆåŽç”Ÿäº†ä¸¤ä¸ªå­©å­ï¼Œå…¶ä¸­ä¸€ä¸ªå­©å­æ˜¯å¥³å­©ï¼Œé—®å¦ä¸€ä¸ªå­©å­æ˜¯ç”·å­©çš„æ¦‚çŽ‡æ˜¯å¤šå¤§ï¼Ÿ 12ç­”æ¡ˆæ˜¯2/3.ä¸¤ä¸ªå­©å­çš„æ€§åˆ«æœ‰ä»¥ä¸‹å››ç§å¯èƒ½ï¼šï¼ˆç”·ç”·ï¼‰ï¼ˆç”·å¥³ï¼‰ï¼ˆå¥³ç”·ï¼‰ï¼ˆå¥³å¥³ï¼‰ï¼Œå…¶ä¸­ä¸€ä¸ªæ˜¯å¥³å­©ï¼Œå°±æŽ’é™¤äº†ï¼ˆç”·ç”·ï¼‰ï¼Œè¿˜å‰©ä¸‰ç§æƒ…å†µã€‚å…¶ä¸­å¦ä¸€ä¸ªæ˜¯ç”·å­©çš„å äº†ä¸¤ç§ï¼Œ2/3. ä¹‹æ‰€ä»¥ç­”æ¡ˆä¸æ˜¯1/2æ˜¯å› ä¸ºå¥³å­©åˆ°åº•æ˜¯ç¬¬ä¸€ä¸ªç”Ÿçš„è¿˜æ˜¯ç¬¬äºŒä¸ªç”Ÿçš„æ˜¯ä¸ç¡®å®šçš„ã€‚ä¸€ä¸ªå›½å®¶äººä»¬åªæƒ³è¦ç”·å­©ï¼Œæ¯ä¸ªå®¶åº­éƒ½ä¼šä¸€ç›´è¦å­©å­ï¼Œåªåˆ°ä»–ä»¬å¾—åˆ°ä¸€ä¸ªç”·å­©ã€‚å¦‚æžœç”Ÿçš„æ˜¯å¥³å­©ï¼Œä»–ä»¬å°±ä¼šå†ç”Ÿä¸€ä¸ªã€‚å¦‚æžœç”Ÿäº†ç”·å­©ï¼Œå°±ä¸å†ç”Ÿäº†ã€‚é‚£ä¹ˆï¼Œè¿™ä¸ªå›½å®¶é‡Œç”·å¥³æ¯”ä¾‹å¦‚ä½•ï¼Ÿ 10ä¸ªäººå‡ºåŽ»çŽ©ï¼Œé›†åˆæ—¶é—´æœ‰10åˆ†é’Ÿï¼Œæ¯ä¸ªäººéƒ½åœ¨è¯¥æ—¶é—´å†…åˆ°è¾¾ï¼Œæ¦‚çŽ‡å‡åŒ€åˆ†å¸ƒï¼Œå½¼æ­¤ç‹¬ç«‹ï¼Œé‚£ä¹ˆæœ€åŽä¸€ä¸ªäººæœ€æœ‰å¯èƒ½åˆ°è¾¾çš„æ—¶é—´æ˜¯? 1234é‡åˆ°è¿™ç§æƒ³ä¸æ˜Žç™½ï¼Œæœ€å¥½çš„æ–¹æ³•å°±æ˜¯æžšä¸¾ã€‚è‹¥æœ€åŽä¸€ä¸ªäººåœ¨10åˆ†é’Ÿåˆ°è¾¾ï¼ˆæ¦‚çŽ‡1/10ï¼‰ï¼Œå…¶ä»–äººä¹Ÿéƒ½å·²ç»åˆ°è¾¾äº†ï¼ˆæ¦‚çŽ‡æ˜¯1ï¼‰ï¼Œæ€»æ¦‚çŽ‡æ˜¯ 1919 * (1/10)è‹¥æœ€åŽä¸€ä¸ªäººåœ¨9åˆ†é’Ÿåˆ°è¾¾ï¼ˆæ¦‚çŽ‡1/10ï¼‰ï¼Œå…¶ä»–äººåˆ°è¾¾çš„æ¦‚çŽ‡æ˜¯(9/10)9(9/10)9ï¼Œæ€»æ¦‚çŽ‡æ˜¯ (9/10)9(9/10)9 * (1/10)ä¾æ­¤ç±»æŽ¨ã€‚å¯è§æ¦‚çŽ‡æœ€å¤§çš„æ˜¯ç¬¬10åˆ†é’Ÿã€‚ éšæœºæ•°é¢˜ç›® å·²çŸ¥ä¸€éšæœºå‘ç”Ÿå™¨ï¼Œäº§ç”Ÿ0çš„æ¦‚çŽ‡æ˜¯pï¼Œäº§ç”Ÿ1çš„æ¦‚çŽ‡æ˜¯1-pï¼ŒçŽ°åœ¨è¦ä½ æž„é€ ä¸€ä¸ªå‘ç”Ÿå™¨ï¼Œä½¿å¾—å®ƒäº§ç”Ÿ0å’Œ1çš„æ¦‚çŽ‡å‡ä¸º1/2 12345678910111213ç”±é¢˜ç›®æœ‰ï¼š0 : p1 : 1-pè¿žç»­äº§ç”Ÿä¸¤ä¸ªæ•°ï¼Œå…¶ç»„åˆä»¥åŠæ¦‚çŽ‡å¦‚ä¸‹ï¼š00 : p201 : p*(1-p)10 : (1-p)*p11 : (1-p)2- å¯ä»¥å‘çŽ° 01 å’Œ 10 ç»„åˆçš„æ¦‚çŽ‡æ˜¯ç›¸ç­‰çš„ï¼Œåªéœ€è¦å°†å…¶åˆ†åˆ«æ˜ å°„åˆ°0å’Œ1å³å¯ã€‚å³æ¯æ¬¡éšæœºäº§ç”Ÿä¸¤ä¸ªæ•°ï¼Œå¦‚æžœç»„åˆä¸º00æˆ–11åˆ™ä¸¢å¼ƒï¼Œè‹¥ä¸º01åˆ™æ˜ å°„åˆ°1ï¼Œè‹¥ä¸º10åˆ™æ˜ å°„åˆ°0ï¼Œè¿™æ ·ä¸€æ¥äº§ç”Ÿ0å’Œ1çš„æ¦‚çŽ‡å‡ä¸º 1/2 ã€‚ç­”æ¡ˆï¼š1/4 æ˜“çŸ¥ï¼Œå½“Aã€Bã€Cä¸‰ç‚¹éƒ½åœ¨åŒä¸€ä¸ªåŠåœ†å†…æ—¶ï¼Œä¸‰è§’å½¢ABCå¿…æ˜¯ç›´è§’æˆ–é’è§’ä¸‰è§’å½¢ï¼›åªæœ‰å½“ä¸‰ç‚¹ä¸åœ¨åŒä¸€ä¸ªåŠåœ†å†…ï¼Œæ‰å¯ä»¥ç»„æˆé”è§’ä¸‰è§’å½¢ã€‚äºŽæ˜¯é—®é¢˜ç­‰ä»·äºŽâ€œåœ¨åœ†å‘¨ä¸Šä»»å–ä¸‰ä¸ªä¸åŒçš„ç‚¹ï¼Œæ±‚å®ƒä»¬ä¸åœ¨åŒä¸€åŠåœ†å†…çš„æ¦‚çŽ‡â€ã€‚ è¿‡åœ†å¿ƒä»»å–ä¸¤æ¡ç›´çº¿ï¼Œå¹¶åœ¨åœ†ä¸Šä»»å–ä¸€ç‚¹ä½œä¸ºç‚¹ Aï¼› 1æŽ¥ç€åœ¨å€™é€‰çš„ P1~P4 ä¸­é€‰æ‹© B å’Œ Cï¼Œæœ‰å››ç§æƒ…å†µï¼š&#123;P1, P2&#125;ã€&#123;P1, P2&#125;, &#123;P2, P3&#125;, &#123;P3, P4&#125;ã€‚å½“ä¸”ä»…å½“é€‰ä¸­ &#123;P3, P4&#125; æ—¶ï¼Œèƒ½å¤Ÿæˆé”è§’ä¸‰è§’å½¢ï¼ˆæˆ–è€…è¯´åŒ…å«åœ†å¿ƒï¼‰ï¼Œæ¦‚çŽ‡ä¸º 1/4. åœ¨ 6*9 çš„æ–¹æ ¼ä¸­ï¼Œä»¥å·¦ä¸Šè§’ä¸ºèµ·ç‚¹ï¼Œä»¥å³ä¸‹è§’ä¸ºç»ˆç‚¹ï¼Œæ¯æ¬¡åªèƒ½å‘ä¸‹èµ°æˆ–è€…å‘å³èµ°ï¼Œè¯·é—®ä¸€å…±æœ‰å¤šå°‘ç§ä¸åŒçš„èµ°æ³• è§£æ³•ï¼šä¸€å…±èµ°13æ­¥ï¼Œå…¶ä¸­å¿…ç„¶æœ‰5æ­¥å‘ä¸‹ï¼Œå‰©ä¸‹çš„8æ­¥å‘å³ï¼Œæ‰€ä»¥$C_{13}^{5} = 1287$ ABCDEFG ä¸ƒä¸ªäººæŽ’é˜Ÿï¼Œè¦æ±‚A å¿…é¡»åœ¨B çš„å·¦è¾¹ï¼Œä½†ä¸è¦æ±‚ä¸€å®šç›¸é‚»ï¼Œè¯·é—®å…±æœ‰å¤šå°‘ç§æŽ’æ³•ï¼Ÿç¬¬äºŒé—®äººå¦‚æžœè¦æ±‚A å¿…é¡»åœ¨B å·¦è¾¹ï¼Œå¹¶ä¸”ç›¸é‚»ï¼Œè¯·é—®å…±æœ‰å¤šå°‘ç§æŽ’æ³•ã€‚ 1ç¬¬ä¸€é—®ç­”æ¡ˆ : 7! /2 =2520 ç§ï¼Œç¬¬äºŒé—® 6! =720 ç§ã€‚è¯¦è§£çœ‹[è¿™é‡Œ](https://www.cnblogs.com/aishanyishi/p/10915291.html) å…­ä¸ªäººæŽ’æˆä¸€æŽ’ï¼Œè¦æ±‚ç”²å’Œä¹™ä¸ç›¸é‚»ï¼Œå¹¶ä¸”ç”²å’Œä¸™ä¸ç›¸é‚»çš„æŽ’æ³•æ˜¯å¤šå°‘ï¼Ÿ 6! =720 ï¼Œ 720 -240 -240 +48 =288 ç§ã€‚è¯¦è§£çœ‹è¿™é‡Œ ç»™å‡ºä»Žnä¸ªæ•°ä¸­éšæœºé€‰æ‹©mä¸ªæ•°çš„æ–¹æ³•ã€‚nå¾ˆå¤§ï¼Œå¯ä»¥è®¤ä¸ºæ˜¯äº¿çº§åˆ«ã€‚må¯ä»¥å¾ˆå°ï¼Œå¦‚æŽ¥è¿‘1ï¼›ä¹Ÿå¯ä»¥å¾ˆå¤§ï¼Œå¦‚æŽ¥è¿‘nã€‚ æŠ›ä¸€ä¸ª6é¢çš„éª°å­ï¼Œè¿žç»­æŠ›ç›´åˆ°6ä¸ºæ­¢ï¼Œé—®æœŸæœ›çš„æŠ›çš„æ¬¡æ•°æ˜¯å¤šå°‘ è®¾æœŸæœ›æ¬¡æ•°ä¸ºE,é‚£ä¹ˆæœ‰ï¼š[1]1æ¬¡æŠ›å‡º6çš„æ¦‚çŽ‡ä¸º1/6ï¼Œé‚£ä¹ˆæœŸæœ›æ¬¡æ•°ä¸º1*1/6[2]æœ¬æ¬¡æŠ›å‡ºéž6æ•°å­—çš„æ¦‚çŽ‡ä¸º5/6ï¼Œå› ä¸ºæ²¡æœ‰æŠ›å‡º6ï¼Œå› æ­¤æœŸå¾…æŠ›å‡º6è¿˜éœ€è¦æ‰§è¡Œè¯•éªŒçš„æ¬¡æ•°ä»ä¸ºEï¼Œéœ€è¦æ³¨æ„åŠ ä¸Šæœ¬æ¬¡ï¼ˆ1æ¬¡ï¼‰å¤±æ•ˆçš„æŠ›æŽ·ï¼Œå³æœŸæœ›æ¬¡æ•°ä¸º(1+E)(5/6) ç»¼åˆå¯å¾—ï¼šE = 1*(1/6) + (1+E)(5/6) ä¸€æ ¹æœ¨æ£’ï¼Œæˆªæˆä¸‰æˆªï¼Œç»„æˆä¸‰è§’å½¢çš„æ¦‚çŽ‡æ˜¯å¤šå°‘ï¼Ÿç”»å›¾å¯çŸ¥ï¼Œ(x, y) å¿…é¡»åœ¨å•ä½æ­£æ–¹å½¢çš„å·¦ä¸‹è§’çš„åŠä¸ªç›´è§’ä¸‰è§’å½¢é‡Œï¼Œé¢ç§¯ä¸º 1 / 2ã€‚ ç„¶åŽè€ƒè™‘èƒ½å½¢æˆä¸‰è§’å½¢çš„æˆªæ³•ã€‚é¦–å…ˆè¦æ»¡è¶³åˆšæ‰çš„ä¸‰ä¸ªæ¡ä»¶ï¼š 0 &lt; x &lt; 1 0 &lt; y &lt; 1 0 &lt; 1 - x - y &lt; 1 å‡è®¾ä¸€ä¸ªæœ¨æ£’é•¿ä¸º1ï¼Œä¸‰æˆªçš„é•¿åº¦åˆ†åˆ«ä¸º x, y , 1-x-yï¼Œç”±æ­¤å¯ä»¥è½¬æ¢æˆçº¿æ€§è§„åˆ’é—®é¢˜ã€‚ x + y &gt; 1 - x - y x + 1 - x - y &gt; y y + 1 - x - y &gt; x åŒ–ç®€å³å¾—ï¼š 0 &lt; x &lt; 1/2 0 &lt; y &lt; 1/2 1/2 &lt; x + y &lt; 1 ç”»å›¾å¯çŸ¥ï¼Œæ­¤æ—¶ (x, y) å¿…é¡»åœ¨è¾¹é•¿ä¸º 1/2 çš„ä¸‰è§’å½¢çš„å³ä¸Šè§’çš„åŠä¸ªç›´è§’ä¸‰è§’å½¢é‡Œï¼Œé¢ç§¯ä¸º 1/8ã€‚äºŽæ˜¯æœ€ç»ˆæ¦‚çŽ‡ä¸º (1/8) / (1/2) = 1/4ã€‚ æœ‰ä¸€è‹¹æžœï¼Œä¸¤ä¸ªäººæŠ›ç¡¬å¸æ¥å†³å®šè°åƒè¿™ä¸ªè‹¹æžœï¼Œå…ˆæŠ›åˆ°æ­£é¢è€…åƒã€‚é—®å…ˆæŠ›è¿™åƒåˆ°è‹¹æžœçš„æ¦‚çŽ‡æ˜¯å¤šå°‘ï¼Ÿ é¢˜ç›®ä¸€çœ‹ä¼¼ä¹Žç­”æ¡ˆå°±æ˜¯ 1/2ï¼Œä½†å…¶å®žè®¤çœŸç»†æƒ³å¹¶ä¸æ˜¯è¿™ä¹ˆå›žäº‹ã€‚ ç»™æ‰€æœ‰çš„æŠ›ç¡¬å¸æ“ä½œä»Ž 1 å¼€å§‹ç¼–å·ï¼Œæ˜¾ç„¶å…ˆæ‰‹è€…åªå¯èƒ½åœ¨å¥‡æ•°ï¼ˆ1ï¼Œ3ï¼Œ5ï¼Œ7â€¦ï¼‰æ¬¡æŠ›ç¡¬å¸å¾—åˆ°è‹¹æžœï¼Œè€ŒåŽæ‰‹åªå¯èƒ½åœ¨å¶æ•°æ¬¡ï¼ˆ2ï¼Œ4ï¼Œ6ï¼Œ8â€¦ï¼‰æŠ›ç¡¬å¸å¾—åˆ°è‹¹æžœã€‚ è®¾å…ˆæ‰‹è€…å¾—åˆ°è‹¹æžœçš„æ¦‚çŽ‡ä¸º pï¼Œç¬¬ 1 æ¬¡æŠ›ç¡¬å¸å¾—åˆ°è‹¹æžœçš„æ¦‚çŽ‡ä¸º p = 1/2ï¼Œåœ¨ç¬¬ 3 æ¬¡ï¼ˆ3ï¼Œ5ï¼Œ7â€¦ï¼‰ä»¥åŽå¾—åˆ°è‹¹æžœçš„æ¦‚çŽ‡ä¸º p/4ï¼ˆè¿™æ˜¯å› ä¸ºè¿™ç§åªæœ‰åœ¨ç¬¬1æ¬¡å’Œç¬¬2æ¬¡æŠ›ç¡¬å¸éƒ½æ²¡æœ‰æŠ›åˆ°æ­£é¢ï¼Œæ¦‚çŽ‡ä¸º 1/4 = 1/2 * 1/2 çš„æ—¶å€™æ‰æœ‰å¯èƒ½å‘ç”Ÿï¼Œè€Œä¸”æ­¤æ—¶å…ˆæ‰‹è€…æ­¤åˆ»é¢ä¸´å’Œå¼€å§‹ç›¸åŒçš„å±€é¢ï¼‰ï¼›æ‰€ä»¥å¯ä»¥åˆ—å‡ºç­‰å¼ p = 1/2 + p /4ï¼Œp = 2/3ï¼ˆæ³¨æ„ p è¡¨ç¤ºå…ˆæ‰‹è€…å¾—åˆ°è‹¹æžœçš„æ¦‚çŽ‡ï¼‰ã€‚ ä¸€ä¸ªä¸‰è§’å½¢ï¼Œ ä¸‰ä¸ªç«¯ç‚¹ä¸Šæœ‰ä¸‰åªèš‚èšï¼Œèš‚èšå¯ä»¥ç»•ä»»æ„è¾¹èµ°ï¼Œé—®èš‚èšä¸ç›¸æ’žçš„æ¦‚çŽ‡æ˜¯å¤šå°‘ï¼Ÿ é¦–å…ˆï¼Œæ¯ä¸ªèš‚èšåœ¨æ–¹å‘çš„é€‰æ‹©ä¸Šæœ‰ä¸”åªæœ‰ 2 ç§å¯èƒ½ï¼Œå…±æœ‰ 3 åªèš‚èšï¼Œæ‰€ä»¥å…±æœ‰ 2 çš„ 3 æ¬¡æ–¹ç§å¯èƒ½ï¼Œè€Œä¸ç›¸æ’žæœ‰æœ‰ 2 ç§å¯èƒ½ï¼Œå³å…¨ä¸ºé¡ºæ—¶é’ˆæ–¹å‘æˆ–å…¨ä¸ºé€†æ—¶é’ˆæ–¹å‘ã€‚ä¸ç›¸æ’žæ¦‚çŽ‡ = ä¸ç›¸æ’ž / å…¨éƒ¨ = 2/8 = 1/4ã€‚]]></content>
      <categories>
        <category>CSåŸºç¡€</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CycleGAN & StyleGAN]]></title>
    <url>%2F2019%2F04%2F09%2Fcyclegan-stylegan%2F</url>
    <content type="text"><![CDATA[In the past few yeas, GANs have been used in lots of different applications such as generating synthetic data, style transfer, super-resolution and text2image generation. But we donnâ€™t aim to give a overview of what GANs are made for. There are many great and detailed blogs for your understanding. What this post is about Main ideas of CycleGAN Keypoints in StyleGAN A Gentle Introduction of GANsWe assume the reader has some prior experience with neural networks. In addition, if you are familiar with GANs you can skip this section. The famous minimax objective function can be formulated as following:$$\min _ { \theta _ { g } } \max _ { \theta _ { d } } \left[ \mathbb { E } _ { x \sim p _ { d a t a } } \log D _ { \theta _ { d } } ( x ) + \mathbb { E } _ { z \sim p ( z ) } \log \left( 1 - D _ { \theta _ { d } } \left( G _ { \theta _ { g } } ( z ) \right) \right) \right)$$But in practical, the loss function cannot work very well. So we have alternative objective function: Gradient ascent on discriminator $$\max _ { \theta _ { d } } \left[ \mathbb { E } _ { x \sim p _ { d a t a } } \log D _ { \theta _ { d } } ( x ) + \mathbb { E } _ { z \sim p ( z ) } \log \left( 1 - D _ { \theta _ { d } } \left( G _ { \theta _ { g } } ( z ) \right) \right) \right]$$ Gradient ascent on generator$$\max _ { \theta _ { g } } \mathbb { E } _ { z \sim p ( z ) } \log \left( D _ { \theta _ { d } } \left( G _ { \theta _ { g } } ( z ) \right) \right)$$ The reasoning behind this can be found in original paper. Simplily speaking, we can get higher gradient signal for bad samples, which works much better in practice.bad case çš„æ—¶å€™ï¼Œä½¿ç”¨åŽŸæ¥çš„min-max functionä¼šä½¿å¾—å­¦ä¹ çŽ‡ä¸å¤Ÿï¼Œä½¿ç”¨ gradient ascent å°±ä¼šå¥½ä¸€äº›ã€‚ From Stanford CS231 Lecture 13 â€” Generative Models Main ideas of CycleGANCycleGAN was introduced in 2017 out of Berkeley, Unpaired Image-to-Image Translation Using Cycle-Coonsistent Adversarial Networks. This task is performed on unpaired data. Recent methods such as Pix2Pix depend on the availability of training examples where the samee data is availabel in both domains. However, CycleGAN is able to learning such pair information without one-to-one mapping between training data in source and target domains. Network ArchitectureWe build three networks. A generator $F$ to convert image $y$ to image $ \hat{x}$ A generator $G$ to convert image $\hat{x}$ to image $ \hat{y}$ A discriminator $D$ to identify real image or generated picture Simplified version of CycleGAN architecture can be showed in the following.The function $F$ and $G$ are generator network, which consists of encoder, transformer and decoder. Encoder is extracting the features from an image which is done by convolution networks. Each convolution layer leads to extraction of progressively higher level features. We would like to transform the feature emebdding of an image from domain $X$ to that of domain $Y$. So for this, authors have used 6 layers of ResNet blocks. ResNet block is a neural network layer which consists of two convolutiona layers when a residue of input ia added to the output. This is done to ensure properties of input of previous layers are available for later layers as well. ResNet block can be summarized in following imageThe decoder transfer embedding from $y$ back to original embedding $x$. Loss functionï¼ˆå¯¹äºŽloss å®žé™…ä¸Šåªæœ‰ä¸¤ä¸ªï¼Œåªä¸è¿‡åœ¨ç¬¬ä¸€ä¸ªloss ä¸­ x å’Œy åˆ†åˆ«ä½¿ç”¨äº†ä¸¤æ¬¡ï¼Œæ‰€ä»¥å˜æˆäº†ä¸¤ä¸ªå…¬å¼ã€‚ï¼‰There are two types of losses in CycleGAN. Besides adversarial loss, we have another loss named reconstruction cost.Adversarial loss is similaity to original GAN.$$\operatorname { Loss } _ { a d v } \left( F , D _ { x } , Y \right) = \frac { 1 } { m } \sum _ { i = 1 } ^ { m } \left( 1 - D _ { x } \left( F \left( y _ { i } \right) \right) \right) ^ { 2 }$$$$\operatorname { Loss } _ { a d v } \left( G , D _ { y } , X \right) = \frac { 1 } { m } \sum _ { i = 1 } ^ { m } \left( 1 - D _ { y } \left( G \left( x _ { i } \right) \right) \right) ^ { 2 }$$However, the adversarial loss alone is not sufficient to produce good looking images, which can not enfore that the input and output are recognizably the same. The cycle consistency loss addresses this issue. It relies on the expectation that if you convert an image to the other domain and back again, and then you should get back something similar to what you put in. It enforces that $F ( G ( x ) ) \approx x$ and $G ( F ( y ) ) \approx y$.$$\operatorname { Loss } _ { c y c } ( G , F , X , Y ) = \frac { 1 } { m } \sum _ { i = 1 } ^ { m } \left[ F \left( G \left( x _ { i } \right) \right) - x _ { i } \right] + \left[ G \left( F \left( y _ { i } \right) \right) - y _ { i } \right]$$We can get the full objective function by putting these two together.$$\mathcal { L } \left( G , F , D _ { x} , D _ { y } \right) = \mathcal { L } _ { \text { GAN } } \left( G , D _ { y } , X , Y \right) + \mathcal { L } _ { \text { GAN } } \left( F , D _ { x } , Y , X \right) + \lambda \mathcal { L } _ { \text { cyc } } ( G , F )$$ Keypoints of StyleGAN(æƒ³è¦è§£å†³çš„é—®é¢˜ï¼ŒProGAN æ˜¯è®­ç»ƒè¿‡ç¨‹ä¸­ä¸æ˜¯ä¸€ä¸ª fine-tune çš„è¿‡ç¨‹ï¼Œè€Œæ˜¯ä»Žä¸€ç§çŠ¶æ€åˆ°å¦ä¸€ç§çŠ¶æ€çš„è¿‡ç¨‹ï¼Œæ‰€ä»¥styleGAN æƒ³è¦ control specific features during training)The StyleGAN offers an upgrade version of ProGANâ€™s image generator, with a focus on the generator. ProGAN generates high-quality images but, in most models, its ability to control specific features of the generated image is very limited. In other word, the features are entangled and therefore attempting to tweak the input, even a bit, usually affects multiple features at the same time. A good illustrations would be following pictures.Compared with first version (ProGAN), the new generator includes several additions to ProGANâ€™s generators. Mapping NetworkThe mapping networkâ€™s goal in to encode the input vector into an intermediate vector whose different elements control different visual features, which consists of 8 fully connected layers and its output $w$ is of the same size as the input. Style Modules (AdaIN)The AdaIn (Adaptive Instance Normalization) module transfers the encoded information $w$, created by the mapping network, into the generated image. Removing traditional inputSince the encoded information $w$ from mapping network was used into generator image, the traditional random input can be omitted and replaced by constant values.]]></content>
      <categories>
        <category>Deep learning</category>
      </categories>
      <tags>
        <tag>GANs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Evaluation of Sentence Similarity]]></title>
    <url>%2F2019%2F04%2F06%2FThe-evaluation-of-sentence-similarity%2F</url>
    <content type="text"><![CDATA[I am trying to write my first english blog based on two reasons: First, the data set used in this blog is english; Second, Iâ€™d like to expand my reach and attract more audiences, although I should admit that nobody cares. DataInitially I want to use chinese corpus, but I cannot find a proper one. The data should sound like this one: word1 word2 similarity scoreé˜¿æ‹‰ä¼¯äºº é˜¿æ‹‰ä¼¯ 7.2ç•œäº§ å†œä¸š 5.6åž‚æ¶Ž å´‡æ•¬ 3.4æ¬¡åº ç§©åº 4.7å®šå¿ƒä¸¸ è¯å“ 4.3æˆ¿ç§Ÿ ä»·æ ¼ 5.2ç¿¡ç¿  å®çŸ³ 6.7é«˜ç§‘æŠ€ æŠ€æœ¯ 7.5è´­å…¥ è´­ä¹° 8.5è§‚éŸ³ è©è¨ 8.2å½’å¹¶ åˆå¹¶ 7.7 not like this: ä¸ºä½•æˆ‘æ— æ³•ç”³è¯·å¼€é€šèŠ±å‘—ä¿¡ç”¨å¡æ”¶æ¬¾ æ”¯ä»˜å®å¼€é€šä¿¡ç”¨å¡èŠ±å‘—æ”¶æ¬¾ä¸ç¬¦åˆæ¡ä»¶æ€Žä¹ˆå›žäº‹ 1èŠ±å‘—åˆ†æœŸä»˜æ¬¾ä¼šå½±å“ä½¿ç”¨å— èŠ±å‘—åˆ†æœŸæœ‰ä»€ä¹ˆå½±å“å— 0ä¸ºä»€ä¹ˆæˆ‘èŠ±å‘—æ²¡æœ‰ä¸´æ—¶é¢åº¦ èŠ±å‘—æ²¡æœ‰ä¸´æ—¶é¢åº¦æ€Žä¹ˆå¯ä»¥è´Ÿ 0èƒ½ä¸èƒ½å¼€èŠ±å‘—è€å…„ èŠ±å‘—é€¾æœŸäº†è¿˜èƒ½å¼€é€š 0æˆ‘çš„æ€Žä¹ˆå¼€é€šèŠ±å‘—æ”¶é’± è¿™ä¸ªèŠ±å‘—æ˜¯ä¸ªä»€ä¹ˆå•¥ï¼Ÿæˆ‘æ²¡å¼€é€š æˆ‘æ€Žä¹ˆæœ‰è´¦å• 0èš‚èšå€Ÿå‘—å¯ä»¥åœæŽ‰ä¹ˆ èš‚èšå€Ÿå‘—ä¸ºä»€ä¹ˆç»™æˆ‘å…³æŽ‰äº† 0æˆ‘æƒ³æŠŠèŠ±å‘—åŠŸèƒ½å…³äº† æˆ‘åŽ»é¥­åº—åƒé¥­ï¼Œèƒ½ç”¨èŠ±å‘—æ”¯ä»˜å— 0ä¸ºä»€ä¹ˆæˆ‘å€Ÿå‘—å¼€é€šäº†åˆå…³é—­äº† ä¸ºä»€ä¹ˆå€Ÿå‘—å­˜åœ¨é£Žé™© 0æ”¯ä»˜å®è¢«å†»äº†èŠ±å‘—è¦æ€Žä¹ˆè¿˜ æ”¯ä»˜åŠŸèƒ½å†»ç»“äº†ï¼ŒèŠ±å‘—è¿˜ä¸äº†æ€Žä¹ˆåŠž 1 If you can find the dataset where â€˜similarity scoreâ€™ is double, please donot hesitate to email me. So, the choice has to be enlgish corpus. The dataset used in this experiment are STSbenchmark and SICK data. The SICK data contains 10,000 sentence paris labeled with semantic relatedness and entailment relation. Similarity MethodsBaselineAs the baseline, we just take the embedding of the words in sentence, and compute the average, weighted by frequency of each word. 1234567891011121314151617181920212223242526272829303132def run_avg_benchmark(sentences1, sentences2, model=None, use_stoplist=False, doc_freqs=None): if doc_freqs is not None: N = doc_freqs["NUM_DOCS"] sims = [] for (sent1, sent2) in zip(sentences1, sentences2): tokens1 = sent1.tokens_without_stop if use_stoplist else sent1.tokens tokens2 = sent2.tokens_without_stop if use_stoplist else sent2.tokens tokens1 = [token for token in tokens1 if token in model] tokens2 = [token for token in tokens2 if token in model]l if len(tokens1) == 0 or len(tokens2) == 0: sims.append(0) continue tokfreqs1 = Counter(tokens1) tokfreqs2 = Counter(tokens2) weights1 = [tokfreqs1[token] * math.log(N / (doc_freqs.get(token, 0) + 1)) for token in tokfreqs1] if doc_freqs else None weights2 = [tokfreqs2[token] * math.log(N / (doc_freqs.get(token, 0) + 1)) for token in tokfreqs2] if doc_freqs else None embedding1 = np.average([model[token] for token in tokfreqs1], axis=0, weights=weights1).reshape(1, -1) embedding2 = np.average([model[token] for token in tokfreqs2], axis=0, weights=weights2).reshape(1, -1) sim = cosine_similarity(embedding1, embedding2)[0][0] sims.append(sim) return sims Smooth Inverse FrequencyThe baseline, like we did before, is very simple and crude of computing sentence embedding. Word frequency cannot reliably reflect its importance to sentence, semantically speaking. Smooth Inverse Frequency (SIF) tries to solve this problem. SIF is very similar to the weighted average we used before, with the difference that itâ€™s weighted by this formular.$$\operatorname { SIF } ( w ) = \frac { a } { ( a + p ( w ) )}$$where $a$ is a hyper-parameter (set to 0.001 by default) and $ p(w)$ is the estimated word frequency in the corpus. (è¿™ä¸ªæƒé‡å’Œ TFæˆ–è€… IDF éƒ½æ˜¯ä¸ç›¸åŒçš„) we need to perform common component removal: subtract from the sentence embedding obtained above the first principal component of the matrix. This corrects for the influence of high-frequency words that have syntactic or dicourse function, such as â€˜butâ€™, â€˜andâ€™, etc. You can find more information from this paper. å› ä¸ºè¿™ä¸ªçš„è¾“å…¥ç›´æŽ¥æ˜¯å¥å­ï¼Œæ²¡æœ‰ç»è¿‡åˆ†è¯çš„å¤„ç†ï¼Œæ‰€ä»¥ä¸å…æœ‰ but and è¿™ç±»çš„è¯æ±‡å‡ºçŽ°ã€‚ 12345678910111213141516171819202122232425262728293031323334353637def remove_first_principal_component(X): svd = TruncatedSVD(n_components=1, n_iter=7, random_state=0) svd.fit(X) pc = svd.components_ XX = X - X.dot(pc.transpose()) * pc return XXdef run_sif_benchmark(sentences1, sentences2, model, freqs=&#123;&#125;, use_stoplist=False, a=0.001): total_freq = sum(freqs.values()) embeddings = [] # SIF requires us to first collect all sentence embeddings and then perform # common component analysis. for (sent1, sent2) in zip(sentences1, sentences2): tokens1 = sent1.tokens_without_stop if use_stoplist else sent1.tokens tokens2 = sent2.tokens_without_stop if use_stoplist else sent2.tokens tokens1 = [token for token in tokens1 if token in model] tokens2 = [token for token in tokens2 if token in model] weights1 = [a / (a + freqs.get(token, 0) / total_freq) for token in tokens1] weights2 = [a / (a + freqs.get(token, 0) / total_freq) for token in tokens2] embedding1 = np.average([model[token] for token in tokens1], axis=0, weights=weights1) embedding2 = np.average([model[token] for token in tokens2], axis=0, weights=weights2) embeddings.append(embedding1) embeddings.append(embedding2) embeddings = remove_first_principal_component(np.array(embeddings)) sims = [cosine_similarity(embeddings[idx * 2].reshape(1, -1), embeddings[idx * 2 + 1].reshape(1, -1))[0][0] for idx in range(int(len(embeddings) / 2))] return sims Google Sentence EncoderInferSent is a pre-trained encoder that produces sentence embedding, which opensourced by Facebook. The Google Sentence Encoder is Googleâ€™s answer to Facebookâ€™s InferSent. In contrast to InferSent, the Google Sentence Encoder was trained on a combination of unsupervised data and supervised data (SNLI corpus), which tends to give better results. The codes can be used in Google Jupyter Notebook 12345678910111213141516171819202122232425import tensorflow_hub as hubtf.logging.set_verbosity(tf.logging.ERROR)embed = hub.Module("https://tfhub.dev/google/universal-sentence-encoder/1")def run_gse_benchmark(sentences1, sentences2): sts_input1 = tf.placeholder(tf.string, shape=(None)) sts_input2 = tf.placeholder(tf.string, shape=(None)) sts_encode1 = tf.nn.l2_normalize(embed(sts_input1)) sts_encode2 = tf.nn.l2_normalize(embed(sts_input2)) sim_scores = tf.reduce_sum(tf.multiply(sts_encode1, sts_encode2), axis=1) with tf.Session() as session: session.run(tf.global_variables_initializer()) session.run(tf.tables_initializer()) [gse_sims] = session.run( [sim_scores], feed_dict=&#123; sts_input1: [sent1.raw for sent1 in sentences1], sts_input2: [sent2.raw for sent2 in sentences2] &#125;) return gse_sims Experiments1234567891011121314def run_experiment(df, benchmarks): sentences1 = [Sentence(s) for s in df['sent_1']] sentences2 = [Sentence(s) for s in df['sent_2']] pearson_cors, spearman_cors = [], [] for label, method in benchmarks: sims = method(sentences1, sentences2) pearson_correlation = scipy.stats.pearsonr(sims, df['sim'])[0] print(label, pearson_correlation) pearson_cors.append(pearson_correlation) spearman_correlation = scipy.stats.spearmanr(sims, df['sim'])[0] spearman_cors.append(spearman_correlation) return pearson_cors, spearman_cors Helper function: 1234567891011import functools as ftbenchmarks = [ ("AVG-GLOVE", ft.partial(run_avg_benchmark, model=glove, use_stoplist=False)), ("AVG-GLOVE-STOP", ft.partial(run_avg_benchmark, model=glove, use_stoplist=True)), ("AVG-GLOVE-TFIDF", ft.partial(run_avg_benchmark, model=glove, use_stoplist=False, doc_freqs=doc_frequencies)), ("AVG-GLOVE-TFIDF-STOP", ft.partial(run_avg_benchmark, model=glove, use_stoplist=True, doc_freqs=doc_frequencies)), ("SIF-W2V", ft.partial(run_sif_benchmark, freqs=frequencies, model=word2vec, use_stoplist=False)), ("SIF-GLOVE", ft.partial(run_sif_benchmark, freqs=frequencies, model=glove, use_stoplist=False)),] Results123import matplotlib.pyplot as pltplt.rcParams['figure.figsize'] = (20,13)spearman[['AVG-GLOVE', 'AVG-GLOVE-STOP','AVG-GLOVE-TFIDF', 'AVG-GLOVE-TFIDF-STOP','GSE']].plot(kind="bar").legend(loc="lower left") Take Off Smooth Inverse Frequency methods are better than baseline, no matter with word2vec or Glove embeddings. Google Sentence Encoder has the similar performance as Smooth Inverse Frequency. Using tf-idf weights does not help and using a stoplist looks like a reasonable choice. Pearson CorrelationSpearman Correlation Full codes can be found in here. å¤ä¹ ç¬”è®° TF-IDF å’Œ SIFä¸‰è€…çš„å·®åˆ« SIFçš„è®¡ç®—å…¬å¼ï¼š$$\operatorname { SIF } ( w ) = \frac { a } { ( a + p ( w ) )}$$$a$ æ˜¯è¶…å‚æ•°ï¼Œä¸€èˆ¬è®¾ç½®ä¸º0.001ï¼Œä¿è¯â€¦; $p(w)$ æ˜¯word åœ¨é¢„æ–™ä¸­å‡ºçŽ°çš„é¢‘æ•°ã€‚ TF çš„è®¡ç®—å…¬å¼ï¼š $$ è¯é¢‘(TF) = æŸä¸ªè¯åœ¨æ–‡ç« ä¸­å‡ºçŽ°çš„æ¬¡æ•°( é¢‘æ•°) $$ å¯ä»¥è¿›ä¸€æ­¥æ ‡å‡†åŒ–ï¼ˆå‡å°‘æ–‡ç« é•¿åº¦çš„å½±å“ï¼‰ $$ è¯é¢‘( TF) = \frac{æŸæ¬¡åœ¨æ–‡ä¸­å‡ºçŽ°çš„æ¬¡æ•°}{æ–‡ç« çš„æ€»è¯è¯­æ•°} $$ $$ é€†æ–‡æ¡£é¢‘çŽ‡ (IDF) = log(\frac{è¯­æ–™ä¸­çš„æ–‡æ¡£æ€»æ•°}{ åŒ…å«è¯¥è¯çš„æ–‡æ¡£æ•° +1}) $$]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Data Structure]]></title>
    <url>%2F2019%2F04%2F05%2Fdata_structure%2F</url>
    <content type="text"><![CDATA[ä»‹ç»é¢è¯•è¿‡ç¨‹ä¸­çš„æ•°æ®ç»“æž„ï¼Œæ ‘ã€Hashè¡¨å’Œå›¾ã€‚ æ ‘æ ‘ä¸­å¸¸è§çš„æ¦‚å¿µ èŠ‚ç‚¹çš„åº¦ï¼šæŒ‡çš„æ˜¯ç»“ç‚¹æ‹¥æœ‰çš„å­æ ‘çš„ä¸ªæ•°ï¼ŒäºŒå‰æ ‘çš„åº¦ä¸å¤§äºŽ2 é«˜åº¦ï¼šå¶å­èŠ‚ç‚¹çš„é«˜åº¦æ˜¯1ï¼Œ æ ¹ç»“ç‚¹çš„é«˜åº¦æœ€é«˜ èŠ‚ç‚¹çš„å±‚æ¬¡ï¼šä»Žæ ¹ç»“ç‚¹å¼€å§‹ï¼Œæ ¹ç»“ç‚¹ä¸ºç¬¬ä¸€å±‚ï¼Œæ ¹ç»“ç‚¹çš„å¶å­èŠ‚ç‚¹ä¸ºç¬¬äºŒå±‚ï¼Œä»¥æ­¤ç±»æŽ¨ã€‚ ä¸‰ç§æ ‘çš„æ¯”è¾ƒ full binary tree vs. complete binary tree vs. perfect binary tree ä¸­æ–‡ç¿»è¯‘çš„æ—¶å€™å¸¸å¸¸å®¹æ˜“ç¿»è¯‘ä¸å‡†ï¼Œæ‰€ä»¥ä½¿ç”¨è‹±æ–‡æ›´åŠ å®¹æ˜“è¯´æ¸…æ¥šã€‚ Full Binary Tree A Binary Tree is full if every node has 0 or 2 children. Following are examples of a full binary tree. We can also say a full binary tree is a binary tree in which all nodes except leaves have two children.full binary tree é™åˆ¶æ¯ä¸ªèŠ‚ç‚¹è¦ä¹ˆæ˜¯æœ‰ä¸¤ä¸ªå­©å­å¥½ä¹ˆæ˜¯æ²¡æœ‰å­©å­ã€‚ Complete Binary Tree: A Binary Tree is complete Binary Tree if all levels are completely filled except possibly the last level and the last level has all keys as left as possiblecomplete binary treeé™åˆ¶æœ€åŽä¸€å±‚åªèƒ½æ˜¯åœ¨æœ€åŽä¸€å±‚çš„å·¦è¾¹æœ‰å·¦å­æ ‘ã€‚ Perfect Binary Tree A Binary tree is Perfect Binary Tree in which all internal nodes have two children and all leaves are at the same level.perfect binary tree æœ€åŽä¸€å±‚ä¸€å®šæ˜¯æ»¡çš„ã€‚ æ»¡äºŒå‰æ ‘ ä¸€æ£µæ·±åº¦ä¸º $k$ ä¸”æœ‰ $2^{k+1} -1$ä¸ªç»“ç‚¹çš„äºŒå‰æ ‘è¢«ç§°ä¸ºå®Œç¾ŽäºŒå‰æ ‘ã€‚ ç‰¹ç‚¹ï¼š æ¯ä¸€å±‚ä¸Šçš„ç»“ç‚¹éƒ½æ˜¯æœ€å¤§ç»“ç‚¹æ•°ï¼ˆæ¯å±‚éƒ½æ˜¯æ»¡ï¼‰ æ•°å­¦è¡¨è¾¾ä¸ºï¼Œ$2^{k-1}$ å¶å­ç»“ç‚¹å…¨éƒ¨éƒ½æ˜¯åœ¨æœ€åº•å±‚ æœ€åŽä¸€å±‚æ˜¯ 2^{k-1}ï¼Œ æ€»çš„ç»“ç‚¹ä¸ªæ•°æ˜¯ $2^{k+1} -1$ å¯¹æ»¡äºŒå‰æ ‘ç»“ç‚¹ä½ç½®è¿›è¡Œç¼–å·ï¼ˆç¼–å·çš„å®šä¹‰å¯¹äºŽå®Œå…¨äºŒå‰æ ‘çš„ç†è§£æœ‰é‡è¦çš„æ„ä¹‰ï¼‰ ä»Žæ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œè‡ªä¸Šè€Œä¸‹ï¼Œè‡ªå·¦è€Œå³ æ¯ä¸€ç»“ç‚¹ä½ç½®ä¸Šéƒ½æœ‰å…ƒç´  å®Œå…¨äºŒå‰æ ‘ æ·±åº¦ä¸º $k$ çš„å…·æœ‰ $n$ ä¸ªç»“ç‚¹çš„äºŒå‰æ ‘ï¼Œå½“ä¸”ä»…å½“å…¶æ¯ä¸€ä¸ªç»“ç‚¹éƒ½ä¸Žæ·±åº¦ä¸º $k$ çš„æ»¡äºŒå‰æ ‘ä¸­ç¼–å·ä¸º $1 \sim n$ çš„ç»“ç‚¹ä¸€ä¸€å¯¹åº”ï¼Œç§°ä¹‹ä¸ºå®Œå…¨äºŒå‰æ ‘ã€‚ï¼ˆæ»¡äºŒå‰æ ‘åœ¨å®žé™…ä¸­ä¸æ˜¯é‚£ä¹ˆå¸¸è§ï¼Œä½†æ˜¯å®Œå…¨äºŒå‰æ ‘å°±æ¯”è¾ƒå¸¸è§ï¼Œå› ä¸ºæ²¡æœ‰çº¦æŸæœ€åŽä¸€å±‚å¿…é¡»æ˜¯æ»¡çš„ï¼Œä½†æ˜¯å­˜åœ¨çš„ç»“ç‚¹å´ä¿ç•™è¿™æ»¡äºŒå‰æ ‘çš„æ€§è´¨ï¼Œå­˜åœ¨çš„ç»“ç‚¹éƒ½æ˜¯å’Œæ»¡äºŒå‰æ ‘ä¸€ä¸€å¯¹åº”çš„ï¼‰ å¤§æ ¹å †å’Œå°æ ¹å † ç‰¹ç‚¹ï¼š å †æ˜¯ä¸€ä¸ªå®Œå…¨äºŒå‰æ ‘( å¦‚æžœæœ‰ h å±‚ï¼Œé‚£ä¹ˆ 1- h-1 å±‚éƒ½æ˜¯æ»¡çš„ï¼Œåœ¨h å±‚ç¼ºå¤±çš„è‹¥å¹²ä¸ª å³å¶å­) å°æ ¹å †çš„æ ¹èŠ‚ç‚¹çš„å€¼æ˜¯æœ€å°å€¼ï¼Œå¤§æ ¹å †çš„æ ¹èŠ‚ç‚¹æ˜¯æœ€å¤§å€¼ å †çš„ç»“æž„é€‚åˆé‡‡ç”¨é¡ºåºå­˜å‚¨ å †çš„å­˜å‚¨ç»“æž„ä¸€èˆ¬éƒ½ç”¨æ•°ç»„æ¥è¡¨ç¤ºå †ï¼Œ$i $ç»“ç‚¹çš„çˆ¶ç»“ç‚¹ä¸‹æ ‡å°±ä¸º $(iâ€“1)/2 $ã€‚å®ƒçš„å·¦å³å­ç»“ç‚¹ä¸‹æ ‡åˆ†åˆ«ä¸º $2 i + 1 $å’Œ $2 i + 2$ã€‚å¦‚ç¬¬0ä¸ªç»“ç‚¹å·¦å³å­ç»“ç‚¹ä¸‹æ ‡åˆ†åˆ«ä¸º1å’Œ2ã€‚åœ¨äºŒå‰æŽ’åºæ ‘ä¸­ï¼ŒæŸç»“ç‚¹çš„å³å­©å­ç»“ç‚¹çš„å€¼ä¸€å®šå¤§äºŽè¯¥ç»“ç‚¹çš„å·¦å­©å­ç»“ç‚¹çš„å€¼ï¼›åœ¨å †ä¸­å´ä¸ä¸€å®šï¼Œå †åªæ˜¯é™å®šäº†æŸç»“ç‚¹çš„å€¼å¤§äºŽï¼ˆæˆ–å°äºŽï¼‰å…¶å·¦å³å­©å­ç»“ç‚¹çš„å€¼ï¼Œä½†æ²¡æœ‰é™å®šå·¦å³å­©å­ç»“ç‚¹ä¹‹é—´çš„å¤§å°å…³ç³»ã€‚ å †çš„ç»“æž„å’Œå®Œå…¨äºŒå‰æ ‘çš„åŒºåˆ«ï¼šå †æ˜¯ä¸€ä¸ªå®Œå…¨äºŒå‰æ ‘ï¼Œå¹¶ä¸”æ¯ä¸ªç»“ç‚¹çš„å€¼éƒ½å¤§äºŽæˆ–ç­‰äºŽå…¶å·¦å³å­©å­ç»“ç‚¹çš„å€¼ï¼ˆè¿™é‡Œçš„è®¨è®ºä»¥å¤§æ ¹å †ä¸ºä¾‹ï¼‰ï¼Œæ‰€ä»¥ï¼Œå †æ˜¯ç»“ç‚¹ä¹‹é—´æ»¡è¶³ä¸€å®šæ¬¡åºå…³ç³»çš„å®Œå…¨äºŒå‰æ ‘ã€‚å…·æœ‰nä¸ªç»“ç‚¹çš„å †ï¼Œå…¶æ·±åº¦å³ä¸ºå †æ‰€å¯¹åº”çš„å®Œå…¨äºŒå‰æ ‘çš„æ·±åº¦$logn $ã€‚ æŽ¥ä¸‹æ¥çš„æ ‘ç»“æž„éƒ½æ˜¯ä¸€ç§é«˜æ•ˆçš„æŸ¥æ‰¾ç»“æž„ã€‚ äºŒå‰æœç´¢æ ‘ï¼ˆäºŒå‰æŽ’åºæ ‘ï¼‰ å®šä¹‰ï¼š æ˜¯ç©ºæ ‘æˆ–è€…æ»¡è¶³ä»¥ä¸‹çš„æ€§è´¨ ç‰¹ç‚¹ï¼š è‹¥å·¦å­æ ‘ä¸ä¸ºç©ºï¼Œé‚£ä¹ˆå·¦å­æ ‘ä¸Šæ‰€æœ‰ç»“ç‚¹çš„å€¼å°äºŽï¼ˆä¸å¤§äºŽï¼‰æ ¹ç»“ç‚¹çš„å€¼ è‹¥å³å­æ ‘ä¸ä¸ºç©ºï¼Œé‚£ä¹ˆå³å­æ ‘ä¸Šæ‰€æœ‰ç»“ç‚¹çš„å€¼å¤§äºŽï¼ˆä¸å°äºŽï¼‰ç»“ç‚¹çš„å€¼ æŸ¥æ‰¾ã€æ’å…¥ã€åˆ é™¤æ“ä½œçš„æœ€åæ—¶é—´å¤æ‚åº¦ äºŒå‰æŸ¥æ‰¾æ ‘ å¹³è¡¡äºŒå‰æ ‘ çº¢é»‘æ ‘ æŸ¥æ‰¾ $O(N)$ $O(logn)$ $O(logn)$ æ’å…¥ $O(N)$ $O(logn)$ $O(logn)$ åˆ é™¤ $O(N)$ $O(logn)$ $O(logn)$ æŸ¥æ‰¾ã€æ’å…¥ã€åˆ é™¤æ“ä½œçš„å¹³å‡æ—¶é—´å¤æ‚åº¦ äºŒå‰æŸ¥æ‰¾æ ‘ å¹³è¡¡äºŒå‰æ ‘ çº¢é»‘æ ‘ æŸ¥æ‰¾ $O(logn)$ $O(logn)$ $O(logn)$ æ’å…¥ $O(logn)$ $O(logn)$ $O(logn)$ åˆ é™¤ $O(logn)$ $O(logn)$ $O(logn)$ äºŒå‰æŸ¥æ‰¾æ ‘å‡ºçŽ° $O(N)$ çš„æ—¶é—´å¤æ‚åº¦åœ¨äºŽæ ‘å½¢ç»“æž„å˜æˆäº†å•é“¾è¡¨çš„å½¢å¼ã€‚ å¹³è¡¡æ ‘å’Œçº¢é»‘æ ‘çš„åŒºåˆ«ï¼šå¹³è¡¡äºŒå‰æ ‘çš„æ’å…¥/åˆ é™¤æ“ä½œå¸¦æ¥çš„æ—‹è½¬æ“ä½œå¯èƒ½ä¼šè¾¾åˆ°lognæ¬¡ï¼Œè€Œçº¢é»‘æ ‘çš„æ’å…¥/åˆ é™¤æ“ä½œå¸¦æ¥çš„æ—‹è½¬æ“ä½œæœ€å¤šä¸º2 or 3æ¬¡ã€‚ å¹³è¡¡äºŒå‰æ ‘ï¼ˆAVLæ ‘ï¼Œä¿„å›½ä¸¤ä¸ªäººåçš„é¦–å†™å­—æ¯ï¼‰ å¯ä»¥ä»‹ç»ä¸€ä¸ªæ¦‚å¿µï¼šå¹³è¡¡å› å­ã€‚è¯¥èŠ‚ç‚¹å·¦å­æ ‘çš„é«˜åº¦- è¯¥èŠ‚ç‚¹çš„å³å­æ ‘é«˜åº¦ï¼Œå³å·¦å³å­æ ‘é«˜åº¦ä¹‹å·®ï¼Œè¢«ç§°ä¸ºå¹³è¡¡å› å­ã€‚ å¹³è¡¡äºŒå‰æ ‘çš„ç‰¹ç‚¹ åœ¨AVLæ ‘ä¸­ä»»æ„èŠ‚ç‚¹çš„ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦æœ€å¤§å·®ä¸º1. æŸ¥æ‰¾ã€åˆ é™¤ã€æ’å…¥çš„å¹³å‡å’Œæœ€åæƒ…å†µä¸‹éƒ½æ˜¯$O(N)$ ä½¿ç”¨å·¦æ—‹ï¼ˆleft rotationï¼‰å’Œå³æ—‹ï¼ˆright rotationï¼‰æ¥è°ƒæ•´æ ‘çš„å¹³è¡¡ã€‚ å¦‚æžœåœ¨AVLæ ‘ä¸­è¿›è¡Œæ’å…¥æˆ–åˆ é™¤èŠ‚ç‚¹ï¼Œå¯èƒ½å¯¼è‡´AVLæ ‘å¤±åŽ»å¹³è¡¡ï¼Œè¿™ç§å¤±åŽ»å¹³è¡¡çš„äºŒå‰æ ‘å¯ä»¥æ¦‚æ‹¬ä¸ºå››ç§å§¿æ€ï¼šLLï¼ˆå·¦å·¦ï¼‰ã€RRï¼ˆå³å³ï¼‰ã€LRï¼ˆå·¦å³ï¼‰ã€RLï¼ˆå³å·¦ï¼‰ã€‚å®ƒä»¬çš„ç¤ºæ„å›¾å¦‚ä¸‹ï¼š çº¢é»‘æ ‘ æ˜¯å¹³è¡¡äºŒå‰æ ‘çš„ä¸€ç§ï¼Œè¢«ç§°ä¸ºè‡ªå¹³è¡¡äºŒå‰æ ‘ã€‚çº¢é»‘æ ‘çš„æ¯ä¸ªèŠ‚ç‚¹ä¸Šéƒ½å­˜å‚¨ç€è¡¨ç¤ºèŠ‚ç‚¹çš„é¢œè‰²ï¼Œå¯ä»¥æ˜¯çº¢è‰²æˆ–è€…æ˜¯é»‘è‰²ï¼Œæ‰€ä»¥ç§°ä¸ºçº¢é»‘æ ‘ã€‚ç›¸å¯¹äºŽ avl æ¥è¯´ï¼Œçº¢é»‘æ ‘å¹¶ä¸æ˜¯å®Œæ•´ç¬¦åˆå¹³è¡¡æ¡ä»¶ï¼ˆä»»æ„ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦æœ€å¤§å·®ä¸º1ï¼‰ï¼Œå› æ­¤æŸ¥æ‰¾æ€§èƒ½ä»Žç†è®ºä¸Šç¨å¾®ä¸å¦‚ AVL æ ‘ã€‚ä½†æ˜¯æ’å…¥å’Œåˆ é™¤çš„æ•ˆçŽ‡æ›´é«˜ã€‚ çº¢é»‘æ ‘çš„ç‰¹æ€§ï¼š èŠ‚ç‚¹æ˜¯çº¢è‰²æˆ–è€…é»‘è‰² æ ¹ç»“ç‚¹æ˜¯é»‘è‰² æ¯ä¸ªå¶èŠ‚ç‚¹ï¼ˆåŒ…æ‹¬ç©ºèŠ‚ç‚¹ï¼‰æ˜¯é»‘è‰² æ¯ä¸ªçº¢è‰²èŠ‚ç‚¹çš„ä¸¤ä¸ªå­èŠ‚ç‚¹éƒ½æ˜¯é»‘è‰²ï¼ˆä»Žæ¯ä¸ªå¶å­åˆ°æ ¹çš„æ‰€æœ‰è·¯å¾„ä¸Šä¸èƒ½æœ‰ä¸¤ä¸ªè¿žç»­çš„çº¢è‰²èŠ‚ç‚¹ï¼‰ ä»Žä»»ä¸€èŠ‚ç‚¹åˆ°å…¶æ¯ä¸ªå¶å­èŠ‚ç‚¹çš„æ‰€æœ‰è·¯å¾„éƒ½åŒ…å«ç›¸åŒæ•°ç›®çš„é»‘è‰²èŠ‚ç‚¹ è‡ªå¹³è¡¡ç­–ç•¥ å¯¹äºŽä¸€æ£µçº¢é»‘æ ‘çš„æ“ä½œæœ€åŸºæœ¬çš„æ— å¤–ä¹Žå¢žåˆ æ”¹æŸ¥ï¼Œå…¶ä¸­æŸ¥å’Œæ”¹éƒ½ä¸ä¼šæ”¹å˜æ ‘çš„ç»“æž„ï¼Œæ‰€ä»¥ä¸Žæ™®é€šå¹³è¡¡äºŒå‰æ ‘æ“ä½œæ— å¼‚ã€‚å‰©ä¸‹çš„å°±æ˜¯å¢žåˆ æ“ä½œï¼Œæ’å…¥å’Œåˆ é™¤éƒ½ä¼šç ´åæ ‘çš„ç»“æž„ï¼Œä¸è¿‡å€ŸåŠ©ä¸€å®šçš„å¹³è¡¡ç­–ç•¥èƒ½å¤Ÿè®©æ ‘é‡æ–°æ»¡è¶³å®šä¹‰ã€‚å¹³è¡¡ç­–ç•¥å¯ä»¥ç®€å•æ¦‚æ‹¬ä¸ºä¸‰ç§ï¼šå·¦æ—‹è½¬ã€å³æ—‹è½¬ï¼Œä»¥åŠ å˜è‰²ã€‚åœ¨æ’å…¥æˆ–åˆ é™¤ç»“ç‚¹ä¹‹åŽï¼Œåªè¦æˆ‘ä»¬æ²¿ç€ç»“ç‚¹åˆ°æ ¹çš„è·¯å¾„ä¸Šæ‰§è¡Œè¿™ä¸‰ç§æ“ä½œï¼Œå°±å¯ä»¥æœ€ç»ˆè®©æ ‘é‡æ–°æ»¡è¶³å®šä¹‰ã€‚ ä¸‰ç§åŸºæœ¬æ“ä½œï¼š å·¦æ—‹è½¬å¯¹äºŽå½“å‰ç»“ç‚¹è€Œè¨€ï¼Œå¦‚æžœå³å­ç»“ç‚¹ä¸ºçº¢è‰²ï¼Œå·¦å­ç»“ç‚¹ä¸ºé»‘è‰²ï¼Œåˆ™æ‰§è¡Œå·¦æ—‹è½¬ï¼Œå¦‚ä¸‹å›¾ï¼š å³æ—‹è½¬å¯¹äºŽå½“å‰ç»“ç‚¹è€Œè¨€ï¼Œå¦‚æžœå·¦å­ã€å·¦å­™å­ç»“ç‚¹å‡ä¸ºçº¢è‰²ï¼Œåˆ™æ‰§è¡Œå³æ—‹è½¬ï¼Œå¦‚ä¸‹å›¾ï¼š å˜è‰² åœºæ™¯ï¼šæœç´¢ B æ ‘ B æ ‘æ¦‚æ‹¬æ¥è¯´æ˜¯ä¸€ä¸ªæ›´åŠ ä¸€èˆ¬åŒ–çš„äºŒå‰æœç´¢æ ‘ï¼Œå³ä¸€ä¸ªèŠ‚ç‚¹å¯ä»¥æ‹¥æœ‰2 ä¸ªä»¥ä¸Šçš„å­èŠ‚ç‚¹ã€‚è¿™ç§æ ‘ç»“æž„åˆè¢«ç§°ä¸ºå¹³è¡¡å¤šè·¯ï¼ˆå³ä¸æ­¢ä¸¤ä¸ªå­æ ‘ï¼‰æŸ¥æ‰¾æ ‘ã€‚ é¦–å…ˆä»‹ç»ä¸¤ä¸ªç®€å•ç±»ä¼¼çš„æ ‘å½¢ç»“æž„ã€‚ä¸‹é¢æ˜¯ 2-3 æ ‘ã€‚å…¶ä¸­çš„2ï¼Œ3è¡¨ç¤ºçš„å¯ä»¥æœ‰2ä¸ªæˆ–è€…3 ä¸ªå­æ ‘ã€‚ï¼ˆè¿™ç§å°±æ˜¯ä¸€ç§å¤šè·¯å¹³è¡¡æ ‘ï¼‰ ç„¶åŽæ˜¯2-3-4 æ ‘ã€‚ ä¸Šé¢çš„ä¸¤ç§å¯ä»¥çœ‹åšæ˜¯B æ ‘çš„ç‰¹ä¾‹ã€‚B æ ‘ä¸­æœ€é‡è¦çš„ç‰¹æ€§æ˜¯ä¸‹é¢å›¾ç‰‡ä¸­çš„ç¬¬ä¸‰ç‚¹ï¼šé™¤æ ¹èŠ‚ç‚¹å¤–çš„éžå¶å­ç»“ç‚¹éƒ½è‡³å°‘æœ‰ $\left \lceil m/2 \right \rceil $æ£µå­æ ‘ã€‚è¿™ä¸ªæ€§è´¨æ˜¯æŽ§åˆ¶ç€è¦ä¸è¦è¿›ä¸€æ­¥çš„åˆ†è£‚ã€‚ç¬¬äº”ä¸ªæ€§è´¨æ‰€æœ‰çš„å¶å­èŠ‚ç‚¹å‡ºçŽ°åœ¨åŒä¸€å±‚æ¬¡ä¸Šï¼Œä¸å¸¦ä¿¡æ¯ã€‚ï¼ˆå‚è€ƒä¸Šé¢çš„2-3æ ‘ï¼‰ B æ ‘æœ€é‡è¦çš„æ˜¯æŸ¥æ‰¾ï¼Œç›¸å½“äºŽæ˜¯äºŒå‰æŽ’åºæ ‘çš„æ‰©å±•ã€‚ ä½¿ç”¨åœºæ™¯ï¼šé€‚åˆäºŽè¯»å†™ç›¸å¯¹å¤§çš„æ•°æ®å—çš„å­˜å‚¨ç³»ç»Ÿï¼Œæ¯”å¦‚ç¡¬ç›˜ï¼Œ å¸¸å¸¸è¢«ç”¨åœ¨æ•°æ®å—å’Œæ–‡ä»¶ç³»ç»Ÿä¸­ã€‚ å“ˆå¤«æ›¼æ ‘ï¼ˆæœ€ä¼˜äºŒå‰æ ‘ï¼‰ è¿™ä¸ªæ ‘å’Œä¸Šé¢æœ‰ç‚¹å·®åˆ«ã€‚å¦‚ä½•æ ¹æ®èŠ‚ç‚¹ä¸åŒçš„æŸ¥æ‰¾é¢‘çŽ‡æž„é€ æ›´åŠ æœ‰æ•ˆçš„æœç´¢æ ‘ï¼Ÿ æ€»çš„åŽŸåˆ™ï¼šæŸ¥è¯¢é¢‘çŽ‡é«˜çš„è·¯å¾„æ˜¯æ¯”è¾ƒçŸ­ï¼ŒæŸ¥è¯¢é¢‘çŽ‡ä½Žçš„è·¯å¾„æ¯”è¾ƒé•¿ã€‚æœ€åŽçš„å¹³å‡æŸ¥æ‰¾æ–¹å¼æœ€ä½Žã€‚ è¿™é‡Œå¼•å…¥äº†ä¸€ä¸ªæ¦‚å¿µï¼šå¸¦æƒå€¼è·¯å¾„é•¿åº¦ï¼ˆWPLï¼‰ï¼šè®¾äºŒå‰æ ‘æœ‰ $n$ ä¸ªå¶å­èŠ‚ç‚¹ï¼Œæ¯ä¸ªå¶å­èŠ‚ç‚¹å¸¦æœ‰æƒå€¼ $w_k$ï¼Œ ä»Žæ ¹ç»“ç‚¹åˆ°æ¯ä¸ªå¶å­èŠ‚ç‚¹çš„é•¿åº¦ä¸º$l_k$ï¼Œåˆ™æ¯ä¸ªå¶å­èŠ‚ç‚¹çš„å¸¦æƒè·¯å¾„é•¿åº¦çº¸ç›’å°±æ˜¯ $ WPL = \sum{w_kl_k}$ æž„é€ æ–¹å¼ï¼šæ¯æ¬¡æŠŠæƒå€¼æœ€å°çš„ä¸¤æ£µæ ‘åˆå¹¶ã€‚ä»Žè¿™ç§æž„é€ æ–¹å¼ä¸­å¯ä»¥å¾—åˆ°ä»¥ä¸‹çš„ç‰¹ç‚¹ï¼š æ²¡æœ‰åº¦ä¸º1 çš„èŠ‚ç‚¹ $n$ ä¸ªå¶å­èŠ‚ç‚¹çš„å“ˆå¤«æ›¼æ ‘æ€»å…±æœ‰ $2n-1$ ä¸ªç»“ç‚¹ å¯¹åŒä¸€ç»„æƒå€¼ ${w_1, w_2, w_3â€¦ , w_n}$ï¼Œ å­˜åœ¨ç€ä¸åŒæž„çš„ä¸¤æ£µå“ˆå¤«æ›¼æ ‘ æœ€å°ç”Ÿæˆæ ‘ç®—æ³• ç”Ÿæˆæ ‘çš„ç‰¹ç‚¹ï¼š æ²¡æœ‰çŽ¯ è¿žæŽ¥æ‰€æœ‰çš„é¡¶ç‚¹ $N $ä¸ªé¡¶ç‚¹ï¼Œ $N-1$ è¾¹ (è¿™ç§æ•°é‡å…³ç³»æ˜¯å¾ˆé‡è¦çš„) è¿˜æœ‰ä¸€ä¸ªè¦æ±‚æ˜¯è¾¹çš„æƒé‡ç›¸åŠ æ˜¯æœ€å°ã€‚ è¿™é‡Œä»‹ç»ä¸¤ç§ç®—æ³•ï¼Œkruskal ç®—æ³•å’Œprimç®—æ³•ã€‚éƒ½æ˜¯è´ªå©ªæ€æƒ³ã€‚æ–¹å¼ä¸åŒã€‚ Kruskal ç®—æ³• ï¼ˆå…‹é²æ–¯å¡å°”ï¼‰ æ­¤ç®—æ³•å¯ä»¥ç§°ä¸ºâ€œåŠ è¾¹æ³•â€ï¼Œåˆå§‹æœ€å°ç”Ÿæˆæ ‘è¾¹æ•°ä¸º0ï¼Œæ¯è¿­ä»£ä¸€æ¬¡å°±é€‰æ‹©ä¸€æ¡æ»¡è¶³æ¡ä»¶çš„æœ€å°ä»£ä»·è¾¹ï¼ŒåŠ å…¥åˆ°æœ€å°ç”Ÿæˆæ ‘çš„è¾¹é›†åˆé‡Œã€‚ æŠŠå›¾ä¸­çš„æ‰€æœ‰è¾¹æŒ‰ä»£ä»·ä»Žå°åˆ°å¤§æŽ’åºï¼› æŠŠå›¾ä¸­çš„nä¸ªé¡¶ç‚¹çœ‹æˆç‹¬ç«‹çš„næ£µæ ‘ç»„æˆçš„æ£®æž—ï¼› æŒ‰æƒå€¼ä»Žå°åˆ°å¤§é€‰æ‹©è¾¹ï¼Œæ‰€é€‰çš„è¾¹è¿žæŽ¥çš„ä¸¤ä¸ªé¡¶ç‚¹$u_i$, $v_i$åº”å±žäºŽä¸¤é¢—ä¸åŒçš„æ ‘ï¼ˆè¿™ä¸ªæ˜¯é˜²æ­¢ç”ŸæˆçŽ¯çš„æ¡ä»¶ï¼‰ï¼Œåˆ™æˆä¸ºæœ€å°ç”Ÿæˆæ ‘çš„ä¸€æ¡è¾¹ï¼Œå¹¶å°†è¿™ä¸¤é¢—æ ‘åˆå¹¶ä½œä¸ºä¸€é¢—æ ‘ã€‚ é‡å¤(3) ï¼Œç›´åˆ°æ‰€æœ‰é¡¶ç‚¹éƒ½åœ¨ä¸€æ£µæ ‘å†…æˆ–è€…æœ‰ n-1 æ¡è¾¹ä¸ºæ­¢ ï¼ˆå…¶ä¸­çš„åˆ¤æ–­æ¡ä»¶ æ‰€é€‰çš„è¾¹å±žäºŽä¸åŒçš„æ ‘ï¼Œä¹Ÿå¯ä»¥ç†è§£ä¸ºé€‰æ‹©çš„è¾¹ä¸èƒ½æž„æˆçŽ¯ï¼‰ Prim ç®—æ³•ï¼ˆæ™®é‡Œå§†ç®—æ³•ï¼‰ æ­¤ç®—æ³•å¯ä»¥ç§°ä¸ºâ€œåŠ ç‚¹æ³•â€ï¼Œæ¯æ¬¡è¿­ä»£é€‰æ‹©ä»£ä»·æœ€å°çš„è¾¹å¯¹åº”çš„ç‚¹ï¼ŒåŠ å…¥åˆ°æœ€å°ç”Ÿæˆæ ‘ä¸­ã€‚ç®—æ³•ä»ŽæŸä¸€ä¸ªé¡¶ç‚¹så¼€å§‹ï¼Œé€æ¸é•¿å¤§è¦†ç›–æ•´ä¸ªè¿žé€šç½‘çš„æ‰€æœ‰é¡¶ç‚¹ã€‚ å›¾çš„æ‰€æœ‰é¡¶ç‚¹é›†åˆä¸º $V$ï¼›åˆå§‹ä»¤é›†åˆ $u={s} $,$v=Vâˆ’u$; åœ¨ä¸¤ä¸ªé›†åˆ$u$, $v$èƒ½å¤Ÿç»„æˆçš„è¾¹ä¸­ï¼Œé€‰æ‹©ä¸€æ¡ä»£ä»·æœ€å°çš„è¾¹$(u_0,v_0)$ï¼Œå¹¶æŠŠ$v_0$å¹¶å…¥åˆ°é›†åˆ $u$ä¸­ã€‚ é‡å¤ä¸Šè¿°æ­¥éª¤ï¼Œç›´åˆ°æœ€å°ç”Ÿæˆæ ‘æœ‰ $n-1$æ¡è¾¹æˆ–è€… $n$ä¸ªé¡¶ç‚¹ä¸ºæ­¢ã€‚ åœ¨prim ç®—æ³•ä¸­ï¼Œæ²¡æœ‰åˆ¤æ–­æ˜¯å¦ä¸ºçŽ¯çš„è¿‡ç¨‹ï¼Œè·³å‡ºçš„æ¡ä»¶æ˜¯ç¬¬ä¸€ä¸ªåˆ—è¡¨å…¨éƒ¨å·²é€‰ï¼Œé‚£ä¹ˆå°±å½¢æˆäº†ä¸€ä¸ªæœ€å°ç”Ÿæˆæ ‘ã€‚ åœ¨å®žçŽ°çš„æ—¶å€™ï¼Œéœ€è¦ç»´æŒä¸‰ä¸ªåˆ—è¡¨ï¼šé¡¶ç‚¹æ˜¯å¦é€‰æ‹©åˆ—è¡¨ï¼Œé¡¶ç‚¹ä¹‹é—´çš„æœ€å°è·ç¦»åˆ—è¡¨å’Œé¡¶ç‚¹ä¹‹é—´çš„ä¿¡æ¯åˆ—è¡¨ã€‚ åº”ç”¨åœºæ™¯ï¼š è€ƒè™‘åŸŽå¸‚ä¹‹é—´é—´éš”çš„è·ç¦»ï¼Œå»ºè®¾é€šä¿¡çº¿è·¯çš„éš¾åº¦ç­‰å„ç§å› ç´ ï¼Œå°†è¿™äº›å› ç´ ç»¼åˆæˆä¸€ä¸ªæ•°å€¼è¡¨ç¤ºï¼Œç„¶åŽå¯ä»¥è®¡ç®—æœ€å°çš„å»ºè®¾æˆæœ¬ã€‚ å†™ä½œå‚è€ƒ çœ‹è§†é¢‘ç†è§£ å®Œå…¨äºŒå‰æ ‘ä¸­å¶å­èŠ‚ç‚¹æ•°é‡çš„è®¡ç®— è§£æ³•ä¸€ï¼šå¶å­èŠ‚ç‚¹ä¸º n/2 ï¼ˆå‘ä¸Šå–æ•´ï¼‰ï¼Œå…¶ä¸­n ä¸ªæ˜¯èŠ‚ç‚¹çš„æ€»ä¸ªæ•°è§£æ³•äºŒï¼šèŠ‚ç‚¹æ€»æ•°=n0+n1+n2å¯¹äºŽä»»æ„ä¸€ä¸ªä¸ºç©ºçš„å­æ ‘ n0 =n2+1å½“èŠ‚ç‚¹æ€»æ•°ä¸ºå¶æ•°æ—¶å€™ï¼Œn1 ä¸º1ï¼›å½“ç»“ç‚¹æ€»æ•°ä¸ºå¥‡æ•°ï¼Œn1 ä¸º0.æ‰€ä»¥è¿žæ–¹ç¨‹ç»„ï¼Œæ±‚è§£n2 å’Œn0 Trie æ ‘ Trieæ ‘ï¼Œåˆå«å­—å…¸æ ‘ã€å‰ç¼€æ ‘ï¼ˆPrefix Treeï¼‰ã€å•è¯æŸ¥æ‰¾æ ‘ æˆ– é”®æ ‘ï¼Œæ˜¯ä¸€ç§å¤šå‰æ ‘ç»“æž„ã€‚å¦‚ä¸‹å›¾ï¼š a. æ ¹èŠ‚ç‚¹ä¸åŒ…å«å­—ç¬¦ï¼Œé™¤æ ¹èŠ‚ç‚¹å¤–æ¯ä¸€ä¸ªèŠ‚ç‚¹éƒ½åªåŒ…å«ä¸€ä¸ªå­—ç¬¦b. ä»Žæ ¹èŠ‚ç‚¹åˆ°æŸä¸€èŠ‚ç‚¹ï¼Œè·¯å¾„ä¸Šç»è¿‡çš„å­—ç¬¦è¿žæŽ¥èµ·æ¥ï¼Œä¸ºè¯¥èŠ‚ç‚¹å¯¹åº”çš„å­—ç¬¦ä¸²c. æ¯ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰å­èŠ‚ç‚¹åŒ…å«çš„å­—ç¬¦éƒ½ä¸ç›¸åŒ å¯ä»¥çœ‹å‡ºï¼ŒTrieæ ‘çš„å…³é”®å­—ä¸€èˆ¬éƒ½æ˜¯å­—ç¬¦ä¸²ï¼Œè€Œä¸”Trieæ ‘æŠŠæ¯ä¸ªå…³é”®å­—ä¿å­˜åœ¨ä¸€æ¡è·¯å¾„ä¸Šï¼Œè€Œä¸æ˜¯ä¸€ä¸ªç»“ç‚¹ä¸­ã€‚å¦å¤–ï¼Œä¸¤ä¸ªæœ‰å…¬å…±å‰ç¼€çš„å…³é”®å­—ï¼Œåœ¨Trieæ ‘ä¸­å‰ç¼€éƒ¨åˆ†çš„è·¯å¾„ç›¸åŒï¼Œæ‰€ä»¥Trieæ ‘åˆå«åšå‰ç¼€æ ‘ï¼ˆPrefix Treeï¼‰ Trieæ ‘çš„æ ¸å¿ƒæ€æƒ³æ˜¯ç©ºé—´æ¢æ—¶é—´ï¼Œåˆ©ç”¨å­—ç¬¦ä¸²çš„å…¬å…±å‰ç¼€æ¥å‡å°‘æ— è°“çš„å­—ç¬¦ä¸²æ¯”è¾ƒä»¥è¾¾åˆ°æé«˜æŸ¥è¯¢æ•ˆçŽ‡çš„ç›®çš„ã€‚ ä¼˜ç‚¹ æ’å…¥å’ŒæŸ¥è¯¢çš„æ•ˆçŽ‡å¾ˆé«˜ï¼Œéƒ½ä¸ºO(m)O(m)ï¼Œå…¶ä¸­ mm æ˜¯å¾…æ’å…¥/æŸ¥è¯¢çš„å­—ç¬¦ä¸²çš„é•¿åº¦ã€‚ï¼ˆå…³äºŽæŸ¥è¯¢ï¼Œä¼šæœ‰äººè¯´ hash è¡¨æ—¶é—´å¤æ‚åº¦æ˜¯O(1)O(1)ä¸æ˜¯æ›´å¿«ï¼Ÿä½†æ˜¯ï¼Œå“ˆå¸Œæœç´¢çš„æ•ˆçŽ‡é€šå¸¸å–å†³äºŽ hash å‡½æ•°çš„å¥½åï¼Œè‹¥ä¸€ä¸ªåçš„ hash å‡½æ•°å¯¼è‡´å¾ˆå¤šçš„å†²çªï¼Œæ•ˆçŽ‡å¹¶ä¸ä¸€å®šæ¯”Trieæ ‘é«˜ã€‚ï¼‰ Trieæ ‘åªæœ‰åœ¨å…è®¸ä¸€ä¸ªå…³é”®å­—å…³è”å¤šä¸ªå€¼çš„æƒ…å†µä¸‹æ‰æœ‰ç±»ä¼¼hashç¢°æ’žå‘ç”Ÿã€‚ Trieæ ‘å¯ä»¥å¯¹å…³é”®å­—æŒ‰å­—å…¸åºæŽ’åºã€‚ ç¼ºç‚¹ å½“ hash å‡½æ•°å¾ˆå¥½æ—¶ï¼ŒTrieæ ‘çš„æŸ¥æ‰¾æ•ˆçŽ‡ä¼šä½ŽäºŽå“ˆå¸Œæœç´¢ã€‚ ç©ºé—´æ¶ˆè€—æ¯”è¾ƒå¤§ã€‚ åº”ç”¨åœºæ™¯ a. å‰ç¼€åŒ¹é…ä¾‹å¦‚ï¼šæ‰¾å‡ºä¸€ä¸ªå­—ç¬¦ä¸²é›†åˆä¸­æ‰€æœ‰ä»¥ â€œäº”åˆ†é’Ÿâ€ å¼€å¤´çš„å­—ç¬¦ä¸²ã€‚æˆ‘ä»¬åªéœ€è¦ç”¨æ‰€æœ‰å­—ç¬¦ä¸²æž„é€ ä¸€ä¸ª trieæ ‘ï¼Œç„¶åŽè¾“å‡ºä»¥ äº”âˆ’&gt;åˆ†âˆ’&gt;é’Ÿ å¼€å¤´çš„è·¯å¾„ä¸Šçš„å…³é”®å­—å³å¯ã€‚trieæ ‘å‰ç¼€åŒ¹é…å¸¸ç”¨äºŽæœç´¢æç¤ºã€‚å¦‚å½“è¾“å…¥ä¸€ä¸ªç½‘å€ï¼Œå¯ä»¥è‡ªåŠ¨æœç´¢å‡ºå¯èƒ½çš„é€‰æ‹©ã€‚å½“æ²¡æœ‰å®Œå…¨åŒ¹é…çš„æœç´¢ç»“æžœï¼Œå¯ä»¥è¿”å›žå‰ç¼€æœ€ç›¸ä¼¼çš„å¯èƒ½ b. å­—ç¬¦ä¸²æ£€ç´¢ç»™å‡º N ä¸ªå•è¯ç»„æˆçš„ç†Ÿè¯è¡¨ï¼Œä»¥åŠä¸€ç¯‡å…¨ç”¨å°å†™è‹±æ–‡ä¹¦å†™çš„æ–‡ç« ï¼ŒæŒ‰æœ€æ—©å‡ºçŽ°çš„é¡ºåºå†™å‡ºæ‰€æœ‰ä¸åœ¨ç†Ÿè¯è¡¨ä¸­çš„ç”Ÿè¯ã€‚æ£€ç´¢/æŸ¥è¯¢åŠŸèƒ½æ˜¯Trieæ ‘æœ€åŽŸå§‹çš„åŠŸèƒ½ã€‚ç»™å®šä¸€ç»„å­—ç¬¦ä¸²ï¼ŒæŸ¥æ‰¾æŸä¸ªå­—ç¬¦ä¸²æ˜¯å¦å‡ºçŽ°è¿‡ï¼Œæ€è·¯å°±æ˜¯ä»Žæ ¹èŠ‚ç‚¹å¼€å§‹ä¸€ä¸ªä¸€ä¸ªå­—ç¬¦è¿›è¡Œæ¯”è¾ƒï¼š å®žçŽ° å¯ä»¥å‚è€ƒè¿™é‡Œ çœ‹åŠ¨ç”»è½»æ¾ç†è§£ã€ŒTrieæ ‘ã€ Hash è¡¨ä¸€ä¸ªhash å‡½æ•° $f(x) $ hash å‡½æ•° å•å‘ç®—æ³•ï¼ˆä¸èƒ½ä»Žf(x) å¾—åˆ°x, åªèƒ½æ˜¯ä»Žx å¾—åˆ° f(x)ï¼‰ å”¯ä¸€æ€§ è¾“å‡ºé•¿åº¦å›ºå®š é‚£ä¹ˆç¬¬ä¸‰æ¡ä¼šå‡ºçŽ°hash ç¢°æ’žã€‚å¸¸ç”¨çš„å¤„ç†æ–¹æ³•ï¼š å¼€æ”¾åœ°å€æ³•ï¼ˆæ€»çš„åŽŸåˆ™æ˜¯åœ¨å†²çªçš„ä½ç½®æŸ¥æ‰¾ä¸‹ä¸€ä¸ªä½ç½®ï¼Œå¯ä»¥ä½¿ç”¨çº¿æ€§æŽ¢æŸ¥æ³•ï¼Œå¹³æ–¹æŽ¢æŸ¥æ³•ç­‰æ–¹å¼ï¼‰ å†hash æ³•ï¼ˆåŒæ—¶ä½¿ç”¨å¤šä¸ªhash å‡½æ•°ï¼Œå¦‚æžœç¬¬ä¸€ä¸ªhash å‡½æ•°å‘ç”Ÿå†²çªï¼Œé‚£ä¹ˆæŽ¥ç€ä½¿ç”¨ç¬¬äºŒä¸ªhash å‡½æ•°ï¼‰ é“¾åœ°å€æ³•ï¼ˆå°†åŒä¸€ä¸ªhash å€¼ç›¸åŒçš„å…ƒç´ ä½¿ç”¨ä¸€ä¸ªå•é“¾è¡¨è¿›è¡Œå­˜å‚¨ï¼‰ å›¾è¿žé€šå›¾ å¯¹äºŽæ— å‘å›¾ $G$è€Œè¨€ï¼Œè‹¥ $V(G)$ä¸­ä»»ä¸€ä¸¤ä¸ªä¸åŒçš„é¡¶ç‚¹ $V_i$ å’Œ$V_j$éƒ½è¿žé€šï¼ˆå³æœ‰è·¯å¾„ï¼‰ï¼Œåˆ™ç§°$G$ä¸ºè¿žé€šå›¾ã€‚ å¯¹äºŽæœ‰å‘å›¾$G$ä¸­ï¼Œ å¦‚æžœå¯¹äºŽä¸¤ä¸ªé¡¶ç‚¹ $V_i$å’Œ$V_j$æœ‰ä¸€æ¡ä»Ž $V_i$åˆ° $V_j$ çš„æœ‰å‘è·¯å¾„ï¼ŒåŒæ—¶æœ‰ä¸€æ¡ä»Ž $V_j$ åˆ°$V_i$çš„æœ‰å‘è·¯å¾„ï¼Œé‚£ä¹ˆç§°è¿™ä¸¤ä¸ªé¡¶ç‚¹å¼ºè¿žé€šã€‚å¦‚æžœæœ‰å‘å›¾ä¸­ä¸¤ä¸ªé¡¶ç‚¹éƒ½å¼ºè¿žé€šï¼Œé‚£ä¹ˆç§°è¿™ä¸ªå›¾ä¸ºå¼ºè¿žé€šå›¾ã€‚ è¿žé€šåˆ†é‡ åœ¨æ— å‘å›¾ä¸­ï¼Œè¿žé€šåˆ†é‡å³ä¸ºè¿žé€šå­å›¾ã€‚ ä¸Šå›¾ä¸­ï¼Œæ€»å…±æœ‰å››ä¸ªè¿žé€šåˆ†é‡ã€‚é¡¶ç‚¹Aã€Bã€Cã€Dæž„æˆäº†ä¸€ä¸ªè¿žé€šåˆ†é‡ï¼Œé¡¶ç‚¹Eæž„æˆäº†ä¸€ä¸ªè¿žé€šåˆ†é‡ï¼Œé¡¶ç‚¹Fï¼ŒGå’ŒHï¼ŒIåˆ†åˆ«æž„æˆäº†ä¸¤ä¸ªè¿žé€šåˆ†é‡ã€‚ å¼ºè¿žé€šåˆ†é‡ï¼šåœ¨æœ‰å‘å›¾ä¸­ï¼Œå°½å¯èƒ½å¤šçš„è‹¥å¹²é¡¶ç‚¹ç»„æˆçš„å­å›¾ä¸­ï¼Œè¿™äº›é¡¶ç‚¹éƒ½æ˜¯ç›¸äº’å¯åˆ°è¾¾çš„ï¼Œåˆ™è¿™äº›é¡¶ç‚¹ç§°ä¸ºä¸€ä¸ªå¼ºè¿žé€šåˆ†é‡ã€‚ ä¸Šå›¾ä¸­æœ‰ä¸‰ä¸ªå¼ºè¿žé€šåˆ†é‡ï¼Œåˆ†åˆ«æ˜¯aã€bã€eä»¥åŠfã€gå’Œcã€dã€hã€‚ å¹¶æŸ¥é›†ï¼šåˆ¤æ–­å›¾ä¸Šæ˜¯å¦å­˜åœ¨çŽ¯ã€‚å¯ä»¥å‚è€ƒä¹‹å‰çš„ä¸€ä¸ªåšå®¢ã€‚ KMP ç®—æ³•nextæ•°ç»„çš„å«ä¹‰ï¼šä»¥ i ä¸ºç»ˆç‚¹çš„åŽç¼€ å’Œä»¥1 ä¸ºèµ·ç‚¹çš„å‰ç¼€ç›¸ç­‰ï¼Œå¹¶ä¸”æ»¡è¶³é•¿åº¦æœ€é•¿ï¼Œé‚£ä¹ˆè¿™ä¸ªå°±æ˜¯ next[i] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;using namespace std;/** s è¡¨ç¤ºsourceï¼Œ pè¡¨ç¤ºpatternï¼Œnå’Œm åˆ†åˆ«æ˜¯å¯¹åº”çš„é•¿åº¦ get_nextæ˜¯è®¡ç®—äº† nextæ•°ç»„ï¼Œ ä¸»ç¨‹åºä¸­å†™äº†åŒ¹é…çš„æ¨¡æ¿ï¼ˆé€»è¾‘ç»“æž„ï¼‰ */const int N =1e6+10;int n, m;char s[N], p[N];int nex[N];// å› ä¸ºå­˜å‚¨å’Œè®¡ç®—çš„æ—¶å€™éƒ½æ˜¯ä»Ž 1å¼€å§‹çš„ï¼Œæ‰€ä»¥ j+1 æ‰æ˜¯çœŸæ­£æœ‰æ„ä¹‰æ¯”è¾ƒé¡¹ï¼Œè¿™ä¸ªæ¨¡æ¿å…¶å®žå¾ˆå¥½è®°çš„ã€‚void get_next()&#123; for(int i =2, j =0; i&lt;=m; i++) &#123; while(j &amp;&amp; p[i] !=p[j+1]) j=nex[j]; if(p[i] ==p[j+1]) j++; nex[i] =j; &#125; &#125;// abcd, abcdd// ddint main()&#123; cin&gt;&gt; n&gt;&gt;m; scanf("%s", s+1); scanf("%s", p+1); get_next(); //åŒ¹é… //for(int i =1; i&lt;=m; i++) cout&lt;&lt; nex[i] &lt;&lt;" "; for(int i =1, j =0; i&lt;=n; i++) &#123; while(j &amp;&amp; s[i] != p[j+1]) j =nex[j]; if(s[i] ==p[j+1]) j++; if(j ==m) &#123; j =nex[j]; cout&lt;&lt;"true"&lt;&lt;endl; &#125; &#125; return 0;&#125; æ—¶ç©ºå¤æ‚åº¦åˆ†æžå¤ä¹ ä¹‹åŽï¼Œè¿™ä¸¤ä¸ªè§†é¢‘æ˜¯éœ€è¦å†å¿«é€Ÿè¿‡ä¸€éçš„ï¼š è§†é¢‘ä¸€ï¼šhttps://www.bilibili.com/video/av32548823/?p=1è§†é¢‘äºŒï¼šhttps://www.bilibili.com/video/av32548823/?p=2 å¿«é€ŸæŽ’åºçš„æ—¶é—´å¤æ‚åº¦æœ€åæ˜¯ $O(N^2)$ï¼Œ ä½†æ˜¯è¿™ç§æƒ…å†µæ˜¯å¾ˆéš¾è¾¾åˆ°çš„ã€‚hash è¡¨ä¸­æ—¶é—´å¤æ‚åº¦æœ€åæ˜¯ $O(N)$ï¼Œ ä½†ç”±äºŽä¸çŸ¥é“è¿™ç§hash å‡½æ•°æ˜¯ä»€ä¹ˆï¼Œæ‰€ä»¥å¾ˆéš¾è¾¾åˆ°è¿™ç§æƒ…å†µã€‚ åšç¬”è¯•çš„æ—¶å€™çš„æ­¥éª¤ é¦–å…ˆçœ‹æ•°æ®èŒƒå›´ï¼Œç„¶åŽæ ¹æ®æ•°æ®èŒƒå›´çº¦èŽ«ç€ä½¿ç”¨ä»€ä¹ˆç®—æ³• ä¸‹é¢ä»‹ç»çš„æ˜¯æ ¹æ®æ•°æ®èŒƒå›´åæŽ¨ç®—æ³•å¤æ‚åº¦å’Œç®—æ³•å†…å®¹ï¼š ä¸€èˆ¬ACMæˆ–è€…ç¬”è¯•é¢˜çš„æ—¶é—´é™åˆ¶æ˜¯1ç§’æˆ–2ç§’ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒC++ä»£ç ä¸­çš„æ“ä½œæ¬¡æ•°æŽ§åˆ¶åœ¨ $10^7$ ä¸ºæœ€ä½³ã€‚ ä¸‹é¢ç»™å‡ºåœ¨ä¸åŒæ•°æ®èŒƒå›´ä¸‹ï¼Œä»£ç çš„æ—¶é—´å¤æ‚åº¦å’Œç®—æ³•è¯¥å¦‚ä½•é€‰æ‹©ï¼š $n &lt;= 30$, æŒ‡æ•°çº§åˆ«, dfs+å‰ªæžï¼ŒçŠ¶æ€åŽ‹ç¼©dp $n &lt;= 100 â€“&gt; O(n^3)$ï¼Œfloydï¼Œdp $nâ‰¤1000 =&gt; O(n^2)$ï¼Œ$O(n^2logn)$ï¼Œdpï¼ŒäºŒåˆ† $nâ‰¤10000 =&gt; O(n \times \sqrt(n)) $ï¼Œå—çŠ¶é“¾è¡¨ $nâ‰¤100000 =&gt; O(nlogn) $=&gt; å„ç§sortï¼Œset/mapã€heapã€dijkstra+heapï¼ŒäºŒåˆ† $nâ‰¤1000000 =&gt; O(n) $, ä»¥åŠå¸¸æ•°è¾ƒå°çš„ $O(nlogn)$ ç®—æ³• =&gt; hashã€åŒæŒ‡é’ˆæ‰«æã€kmpï¼Œå¸¸æ•°æ¯”è¾ƒå°çš„ $O(nlogn)$ çš„åšæ³•ï¼šsortã€æ ‘çŠ¶æ•°ç»„ã€heapã€dijkstra $nâ‰¤10000000 =&gt; O(n)$ï¼ŒåŒæŒ‡é’ˆæ‰«æã€kmp $nâ‰¤10^9 =&gt; O( \sqrt(n)) $ï¼Œåˆ¤æ–­è´¨æ•° $nâ‰¤10^{18} =&gt; O(logn)$ï¼Œæœ€å¤§å…¬çº¦æ•° ç®€å•ç‰ˆæœ¬ $n &lt;= 100 =&gt; O(n^3)$ï¼Œfloydï¼Œdp $nâ‰¤1000 =&gt; O(n^2)$ï¼Œ$O(n^2logn)$ï¼Œdpï¼ŒäºŒåˆ† $nâ‰¤100000 =&gt; O(nlogn) $=&gt; å„ç§sortï¼Œæ ‘çŠ¶æ•°ç»„ã€set/mapã€heapã€dijkstra+heapã€äºŒåˆ† $nâ‰¤1000000 =&gt; O(n) $, ä»¥åŠå¸¸æ•°è¾ƒå°çš„ $O(nlogn)$ ç®—æ³• =&gt; hashã€åŒæŒ‡é’ˆæ‰«æã€kmp å¸¸æ•°æ¯”è¾ƒå°çš„ $O(nlogn)$ çš„åšæ³•ï¼šsortã€heapã€dijkstra $nâ‰¤10000000 =&gt; O(n)$ï¼ŒåŒæŒ‡é’ˆæ‰«æã€kmp $nâ‰¤10^9 =&gt; O( \sqrt{n}) $ï¼Œåˆ¤æ–­è´¨æ•° $nâ‰¤10^{18} =&gt; O(logn)$ï¼Œæœ€å¤§å…¬çº¦æ•° æ€»çš„åŽŸåˆ™ï¼šæœ€å¥½æ˜¯ 1s èƒ½å¤Ÿè¿›è¡Œ $10^7$ æ¬¡è¿ç®—ã€‚ $ 10^2 -&gt; O( n^3) $ dpï¼Œ floyd$ 10^3 -&gt; O( n^2) $, dpï¼Œ äºŒåˆ†, æžšä¸¾$ 10^5 -&gt; O( nlogn) $ å„ç§ sort å‡½æ•°ï¼Œ set/map, heap, äºŒåˆ†$ 10^6 -&gt; O( n) $ï¼Œ å¸¸æ•°è¾ƒå°çš„ $O(n log n)$ç®—æ³• -&gt; hashï¼Œ åŒæŒ‡é’ˆï¼Œkmpï¼Œ$10^7 -&gt; O(n)$ï¼ŒåŒæŒ‡é’ˆï¼Œ kmp ç®—æ³•$ 10^18 -&gt; O( logn) $ æ¯”è¾ƒä¸€ä¸‹ $O(n^2)$ å’Œ $O(nlogn)$ çš„æ—¶é—´å¤æ‚åº¦ï¼Œ å½“n =100000 çš„è¯ $O(n) = 10^5$ $O(n^2) = 10^{10}$ $O(nlogn ) = 20n = 2 \times 10^6$ åœ¨c++ ä¸­åˆ†æžé€’å½’çš„ç©ºé—´å¤æ‚åº¦æ˜¯ä¸å®¹æ˜“åˆ†æžçš„ï¼Œå› ä¸ºéœ€è¦è¿›è¡Œ $logn$ çº§åˆ«çš„é€’å½’ï¼Œè¿™ä¸ªæ ˆç©ºé—´æ˜¯éœ€è¦åŠ åˆ°å†…å­˜çš„ç”³è¯·ä¸­åŽ»çš„ã€‚å¿«æŽ’åªæœ‰é€’å½’å†™æ³•ï¼Œæ‰€ä»¥ç©ºé—´å¤æ‚åº¦ä¸Šè‡³å°‘æ˜¯$log n$çš„ã€‚ é“¾è¡¨çš„æ—¶é—´å’Œç©ºé—´åˆ†æžæ˜¯æ¯”è¾ƒç®€å•çš„ã€‚ è¿™ä¸ªé¢˜ç›®æ˜¯å¯ä»¥å¥½å¥½çœ‹çœ‹ï¼Œä¸ºä»€ä¹ˆä¸èƒ½ä½¿ç”¨å¿«æŽ’ä½†å¯ä»¥ä½¿ç”¨å½’å¹¶ã€‚å› ä¸ºå‰è€…ä¸èƒ½å†™æˆéžé€’å½’ï¼ŒåŽè€…å¯ä»¥å†™æˆéžé€’å½’å½¢å¼ã€‚ ä¸»å®šç†ä¸€èˆ¬ç”¨äºŽç®—dfs ä¸­çš„æ—¶é—´å¤æ‚åº¦å¯¹äºŽdfs +å‰ªæžçš„é¢˜ç›®ï¼Œä¸€èˆ¬æ˜¯ä¸å¥½åˆ†æžæ—¶é—´å¤æ‚åº¦çš„ï¼Œå› ä¸ºæœ‰çš„å‰ªæžæ•ˆçŽ‡æ˜¯å¾ˆé«˜çš„ï¼Œé‚£ä¹ˆä¹…å˜å¾—ä¸å¯é¢„æµ‹äº†ã€‚ æ ‘çš„æ—¶é—´åº¦åˆ†æžä½¿ç”¨çš„ä¾‹é¢˜ï¼š leetcode 192 åŠ¨æ€è§„åˆ’ï¼š æ—¶é—´å¤æ‚åº¦ä¸¤ç§è®¡ç®—æ–¹æ³•ï¼š çŠ¶æ€ æ•°é‡$O(n^2)$, çŠ¶æ€è½¬ç§»å¤æ‚åº¦ $O(1)$ ï¼Œ æ‰€ä»¥æ€»çš„æ˜¯ä¸¤è€…çš„ç›¸ä¹˜ çœ‹å¾ªçŽ¯çš„ä¸ªæ•°ï¼Œä¸¤ä¸ªfor å¾ªçŽ¯å åŠ ï¼Œé‚£ä¹ˆå°±æ˜¯ $O(N^2)$ dp ä¸­ä¼šç”¨åˆ° memory çš„æ€æƒ³ ï¼ˆè®°å¿†åŒ–æœç´¢ï¼‰ï¼Œæœ‰å¯èƒ½æ˜¯é€’å½’çš„å½¢å¼ï¼Œå®žé™…ä¸Šæ—¶é—´å¤æ‚åº¦å¹¶ä¸æ˜¯dfs çš„å½¢å¼ã€‚ äºŒåˆ†æŸ¥æ‰¾çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(log n)$ï¼ˆå¸¸è¯†ï¼‰ å­—ç¬¦ä¸²leetcode 245 æ˜¯æ¯”è¾ƒnice çš„é¢˜ç›®ï¼Œå¥½å¥½çœ‹çœ‹ã€‚kmp ç®—æ³•æ˜¯ 214 ï¼Œå¯ä»¥çœ‹çœ‹ å•è°ƒé˜Ÿåˆ—ï¼ˆè¿™ä¸ªå¯¹äºŽä¸¤ä¸ªä¾‹é¢˜æ˜¯éœ€è¦å†çœ‹çœ‹ï¼‰ ä¸‘æ•°ï¼Œæ—¶é—´å¤æ‚åº¦æœ€ä¼˜çš„æ˜¯O(n) hash è¡¨ä¸“é¢˜ hashè¡¨çš„æœ€åæ—¶é—´å¤æ‚åº¦ä¸ç”¨è€ƒè™‘ï¼Œä¸€èˆ¬è€ƒè™‘å‡æ‘Šæ—¶é—´å¤æ‚åº¦ï¼ˆ$O(1)$ï¼‰å°±å¯ä»¥ã€‚ 149 è¿™ä¸ªé¢˜ç›®æ˜¯æ¯”è¾ƒå›°éš¾çš„ï¼Œå¯ä»¥çœ‹çœ‹çš„å“¦ å®žçŽ° two sum hash è¡¨å«ä¹‰æ˜¯å­˜å‚¨ä¹‹å‰çš„æ•°å­—ã€‚hash è¡¨çš„å¢žåˆ æ”¹æŸ¥æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ $O( 1)$ã€‚ä¸‹é¢çš„ç¨‹åºæ€»çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n)$ï¼Œç©ºé—´æ˜¯ $O(n)$ repeated DNA sequences unorderedc_map&lt;string, int&gt;ä½¿ç”¨ string.substr() å¾—åˆ°å­ä¸²ï¼Œç„¶åŽå°†å­ä¸²æ”¾åˆ° hash è¡¨ä¸­ï¼Œå¦‚æžœ count()å¤§äºŽ2ï¼Œé‚£ä¹ˆè¿™ä¸ªå°±æ˜¯æœ€åŽçš„ç»“æžœã€‚ design hashmap å®šä¹‰å¸¸é‡è¡¨ç¤ºå¤§æ•°ç»„çš„æ—¶å€™ï¼Œåº”è¯¥å¤šåŠ å‡ ä¸ªæ•°å­—ï¼Œé˜²æ­¢è¾¹ç•Œæƒ…å†µï¼Œå¹¶ä¸”å°½é‡ä½¿ç”¨è´¨æ•°ã€‚1int N =20011 ; å¯¹å¾…å†²çªæ˜¯æœ‰ä¸¤ç§æ–¹æ³•ï¼šæ‹‰é“¾æ³•å’Œå¼€æ”¾å¯»å€æ³•ã€‚å‰è€…åŠ ä¸€ä¸ªé“¾è¡¨ï¼ŒåŽè€…æ˜¯å‘ç”Ÿå†²çªçš„æ—¶å€™ï¼Œå‘ç€å‘¨å›´çš„ç©ºé—´è¿›è¡Œå¯»æ‰¾ã€‚ï¼Ÿ ç©ºé—´å¤§å°å’ŒåŽŸæ•°æ®å¤§å°çš„å…³ç³»ï¼ŸæŸ¥æ‰¾ä¸€ä¸‹ã€‚ ä½¿ç”¨åˆ°äº† è¿­ä»£å™¨ æ¦‚å¿µï¼Œè¿™ä¸ªé¢˜ç›®æ˜¯æ¯”è¾ƒéš¾çš„ã€‚ design hashmapï¼Œ è¿™ä¸ªé¢˜ç›®ç‰¹åˆ«å¥½ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class MyHashMap &#123;public: /** Initialize your data structure here. */ // å®žçŽ°è‡ªå·±çš„hashmap // å…³é”®åœ¨äºŽå¤„ç† å†²çªï¼Œæœ‰ä¸¤ç§æ–¹å¼ï¼Œé“¾è¡¨æ³• å’Œå¼€æ”¾å¯»å€æ³•ï¼› è¿™é‡Œå®žçŽ°çš„æ—¶å€™ï¼Œä½¿ç”¨é“¾è¡¨æ³• // int N =20011; vector&lt;list&lt;pair&lt;int, int&gt;&gt;&gt; h; MyHashMap() &#123; h =vector&lt;list&lt;pair&lt;int, int&gt;&gt;&gt;(N); &#125; // å¿«é€Ÿçš„ find ä¸€ä¸ªkeyçš„ä½ç½®, é¦–å…ˆæ˜¯ä¸€ä¸ª listï¼Œç„¶åŽæ˜¯ä¸€ä¸ªé“¾è¡¨ // æŸ¥æ‰¾çš„æ—¶å€™ï¼Œå·²ç»åŒ…å«äº†å¤„ç†é“¾è¡¨çš„æƒ…å†µ list&lt;pair&lt;int, int&gt;&gt; :: iterator find(int key) &#123; int t =key %N; for(auto it =h[t].begin() ; it != h[t].end(); it ++) &#123; if(it -&gt; first ==key) return it; &#125; return h[t].end(); &#125; // è¿™ç§pair çš„ç»“æž„æ˜¯éžå¸¸å®¹æ˜“æ“ä½œkey,value è¿™æ ·çš„æ•°å­— /** value will always be non-negative. */ void put(int key, int value) &#123; auto it =find(key); int t =key %N; if(it ==h[t].end()) h[t].push_back(&#123;key, value&#125;); else it -&gt; second= value; &#125; /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */ int get(int key) &#123; auto it =find(key); int t =key %N; if( it ==h[t].end()) return -1; return it-&gt;second; &#125; /** Removes the mapping of the specified value key if this map contains a mapping for the key */ void remove(int key) &#123; auto it =find(key); int t =key %N; if(it != h[t].end()) h[t].erase(it); &#125;&#125;;/** * Your MyHashMap object will be instantiated and called as such: * MyHashMap* obj = new MyHashMap(); * obj-&gt;put(key,value); * int param_2 = obj-&gt;get(key); * obj-&gt;remove(key); */ Subarray Sum Equals K é¢˜è§£æ€è·¯ä¹Ÿæ˜¯éžå¸¸çš„æƒŠå¥‡ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ $O(1)$ 123456789101112131415161718192021222324class Solution &#123;public: // å‰ç¼€å’Œ + hashçš„æ€è·¯ // hash å¤„ç†çš„æ˜¯æ’å…¥å’ŒæŸ¥è¯¢çš„é—®é¢˜ int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_map&lt;int, int&gt; hash; int res =0; int sum =0; //hash[] hash[0] =1; // å› ä¸ºåŽé¢ç”¨åˆ°çš„ sum ==k è¿™æ ·çš„å‰ç¼€å’Œ for(int i =0; i&lt;nums.size() ;i++) &#123; sum += nums[i]; res += hash[sum -k]; hash[sum] +=1; &#125; return res; &#125;&#125;; å¹¶æŸ¥é›†å¸¸ç”¨çš„ä¸¤ç§æ“ä½œ åˆå¹¶ä¸¤ä¸ªé›†åˆ åˆ¤æ–­ä¸¤ä¸ªç‚¹æ˜¯å¦åœ¨åŒä¸€ä¸ªé›†åˆä¸­ æœ‰ä¸¤ç§ä¼˜åŒ–ï¼Œè·¯å¾„åŽ‹ç¼©å’ŒæŒ‰ç§©åˆå¹¶ã€‚å‰è€…ä¼˜åŒ–ä¹‹åŽæ—¶é—´å¤æ‚åº¦å˜æˆ $O(log n)$ åŽè€…è¿›ä¸€æ­¥ä¼˜åŒ–å˜æˆ $loglog n$ã€‚å› ä¸ºåŽè€…ä¼˜åŒ–ä¹‹åŽæ”¶ç›Šä¸å¤§ï¼Œæ‰€ä»¥ä¸€èˆ¬ä½¿ç”¨å‰è€…ã€‚ leetcodeé¢˜ç›® 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;int&gt; p; int find(int x) &#123; if( p[x] !=x) p[x] =find(p[x]); return p[x]; &#125; int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; int n= M.size(); int res =n; // åˆå§‹åŒ– for(int i =0; i&lt;n; i++) p.push_back(i); for(int i =0; i&lt;n ; i++) for(int j =0; j&lt;i; j++) &#123; if(M[i][j] ==0) continue; if(find(i) != find(j)) &#123; // find(x) å‡½æ•°æ˜¯æ‰¾x çš„çˆ¶èŠ‚ç‚¹ // find(i) çš„çˆ¶èŠ‚ç‚¹æŒ‡å‘äº† find(j) p[find(i)] =find(j); res -=1; &#125; &#125; return res; &#125;&#125;; è‡ªå·±æ‰‹å†™å †çš„è¯ï¼Œå¯ä»¥å®žçŽ°ä»¥ä¸‹å››ä¸ªåŠŸèƒ½ï¼š æŸ¥æ‰¾æœ€å¤§å€¼ $O( 1) $ æ’å…¥ä¸€ä¸ªæ•° $O (log n)$ åˆ é™¤ä¸€ä¸ªæ•° $ O(log n)$ ä¿®æ”¹ä¸€ä¸ªæ•° $O(log n)$ å¦‚æžœä½¿ç”¨ c++ ä¸­ LST ä¸­ priority_queue é‚£ä¹ˆåªèƒ½ä½¿ç”¨ä¸Šé¢ 1. 2. 3. ç§åŠŸèƒ½ï¼Œå¹¶ä¸”åˆ é™¤ä¸€ä¸ªæ•°ï¼Œåªèƒ½åˆ é™¤å †é¡¶ï¼Œè€Œä¸æ˜¯åˆ é™¤ä»»æ„ä¸€ä¸ªã€‚é»˜è®¤æ˜¯å¤§æ ¹å †çš„å®žçŽ°ã€‚ Top K Frequent Words å°æ ¹å †æœ‰å¾ˆå¤šå®žçŽ°æ–¹å¼ï¼ŒC++ ä¸­é»˜è®¤æ˜¯å¤§æ ¹å †ï¼Œæ‰€ä»¥å¯ä»¥å­˜å‚¨ç›¸åæ•°ã€‚hash è¡¨å­˜å‚¨å•è¯å‡ºçŽ°çš„æ¬¡æ•°ã€‚ heap è¡¨ç¤ºå †çš„å•è¯ã€‚ åœ¨result å­˜å‚¨çš„æ—¶å€™ï¼Œå®žé™…ä¸Šæœ€å…ˆå‡ºæ¥çš„æ˜¯æœ€å·®çš„ï¼Œæ‰€ä»¥æ˜¯ä»ŽåŽå¾€å‰éåŽ†ã€‚ pair æ˜¯åŒå…³é”®å­—æ¯”è¾ƒå¤§å°ï¼Œå¦‚æžœç¬¬ä¸€å…³é”®å­—ä¸åŒï¼Œé‚£ä¹ˆæ¯”è¾ƒå‡ºæ¥å¤§å°ï¼Œå¦‚æžœç¬¬ä¸€å…³é”®å­—ç›¸åŒï¼Œé‚£ä¹ˆæ¯”è¾ƒç¬¬äºŒå…³é”®å­—å¤§å°ã€‚é¢˜ç›®ä¸­è¦æ±‚å‡ºçŽ°é¢‘çŽ‡å¤§ä¸”å­—å…¸åºå°çš„åœ¨å‰é¢ã€‚å¦‚æžœä½¿ç”¨ è´Ÿæ•°è¡¨ç¤ºï¼Œé‚£ä¹ˆå°±è½¬æ¢æˆäº†è´Ÿæ•°å°ï¼ˆæ­£æ•°å¤§ï¼‰ä¸”å­—å…¸åºå°çš„åœ¨å‰ã€‚æ‰€ä»¥ä½¿ç”¨å¤§æ ¹å †æ¯”è¾ƒå¥½å¤„ç†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;unordered_map&gt;#include&lt;queue&gt;// æ³¨æ„ priorty_queue æ˜¯å®šä¹‰åœ¨ queue é‡Œé¢çš„using namespace std;vector&lt;string&gt; topK_frequent(vector&lt;string&gt; arr, int k )&#123; typedef pair&lt;int, string&gt; PAIR; unordered_map&lt;string ,int&gt; hash; priority_queue&lt;PAIR&gt; heap; for(auto word: arr) hash[word] ++; for(auto item : hash) &#123; PAIR t(-item.second, item.first); heap.push(t); if(heap.size() &gt; k) heap.pop(); &#125; vector&lt;string&gt; res(k); for(int i =k-1; i&gt;=0 ; i--) &#123; res[i] =heap.top().second; heap.pop(); &#125; return res;&#125;int main()&#123; vector&lt;string&gt; arr=&#123;"i", "love", "leetcode", "i", "love", "coding"&#125;; int k =2; vector&lt;string&gt; res =topK_frequent(arr, k); for(auto u: res) cout &lt;&lt; u&lt;&lt; " "; cout &lt;&lt;endl; return 0;&#125; åœ¨python ä¸­é»˜è®¤æ˜¯å°æ ¹å †ï¼Œä¹Ÿæ˜¯(-val, key) è¿™æ ·ä¿æŒä¸€è‡´ï¼Œå¦‚æžœæ˜¯éƒ½å°ï¼Œé‚£ä¹ˆæŽ’åœ¨å‰é¢ã€‚æœ€åŽçš„ç»“æžœæ˜¯å…ˆå¼¹å‡ºæ¥çš„ï¼Œé‚£ä¹ˆå°±æ˜¯å‡ºçŽ°é¢‘çŽ‡æœ€å¤§ï¼Œå¹¶ä¸”å­—æ¯åºåœ¨å‰é¢çš„é‚£ç§ã€‚ 1234567891011121314151617181920class Solution(object): def topKFrequent(self, words, k): """ :type words: List[str] :type k: int :rtype: List[str] """ import collections, heapq has =collections.defaultdict(int) for word in words: has[word] +=1 heap =[] for (key, val) in has.items(): heapq.heappush(heap, (-val, key)) res =[] while k: val, key = heapq.heappop(heap) res.append(key) k -=1 return res ç±»ä¼¼çš„é¢˜ç›® 347. Top K Frequent Elements1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_map&lt;int, int&gt; hash; typedef pair&lt;int, int&gt; PAIR; priority_queue&lt;PAIR&gt; heap; for(auto num : nums) hash[num] +=1; for(auto item : hash) &#123; PAIR t(-item.second, item.first); heap.push(t); if(heap.size() &gt; k) heap.pop(); &#125; vector&lt;int&gt; res(k); for(int i =k -1; i &gt;=0; i--) &#123; res[i] =heap.top().second; heap.pop(); &#125; return res; &#125;&#125;; 123456789101112131415161718192021222324class Solution(object): """ æ˜¯å‡ºçŽ°é¢‘çŽ‡æœ€å¤§çš„k ä¸ªæ•°å­—ï¼Œé‚£ä¹ˆæƒ³åˆ°çš„æ˜¯ä½¿ç”¨å°æ ¹å †çš„æ€æƒ³ï¼Œç»´æŠ¤ k å¤§çš„å°æ ¹å † """ def topKFrequent(self, nums, k): """ :type nums: List[int] :type k: int :rtype: List[int] """ import collections, heapq has =collections.defaultdict(int) heap =[] for num in nums: has[num] +=1 # å–å è¿™æ ·ä¿è¯æ˜¯æ ¹æ® æ¬¡æ•°è¿›è¡Œé€‰æ‹©ï¼Œ for (key, val) in has.items(): heapq.heappush(heap, (-val, key)) res =[] while k: _, key =heapq.heappop(heap) res.append(key) k -=1 return res LeetCode 295åŠ¨æ€ç»´æŠ¤æœ‰åºåºåˆ— -&gt; æ‰‹å†™å¹³è¡¡æ ‘ ä½¿ç”¨å¯¹é¡¶å †çš„æ€æƒ³ã€‚æ‰¾ä¸­ä½æ•°æ˜¯ $O(1)$ï¼Œ æ’å…¥æ“ä½œæ˜¯ $O(log n)$ çš„ã€‚ æ¨¡æ¿è¯¾æ€»ç»“æŽ’åºç®—æ³•ï¼ˆå¿«æŽ’å’Œå½’å¹¶æŽ’åºï¼‰ äºŒåˆ†ï¼ˆæ•´æ•°äºŒåˆ†ï¼Œæµ®ç‚¹æ•°äºŒåˆ†ï¼‰ å­¦ä¹ æ–¹æ³•ï¼šç†è§£åªæœ‰ï¼Œå¤šå†™ 3-5éã€‚é‡å¤æ‰æ˜¯çŽ‹é“ã€‚ å¯¹äºŽè¾¹ç•Œé—®é¢˜éžå¸¸å¤æ‚çš„é—®é¢˜ï¼Œå»ºè®®å¤§å®¶èƒŒè¿‡æ¨¡æ¿ï¼Œè¿™æ ·æ˜¯æ¯”è¾ƒniceçš„ã€‚å¦‚æžœå¯¹äºŽæ•°æ®é‡å¾ˆå¤§çš„æƒ…å†µï¼Œå»ºè®®ä½¿ç”¨ scanf() è¿›è¡Œè¯»å…¥ï¼Œå› ä¸º cin ç›¸å¯¹æ¥è¯´æ˜¯æ¯”è¾ƒæ…¢çš„ã€‚ç¨³å®šæ€§ï¼Œä¸¤ä¸ªç›¸åŒçš„æ•°å­—ï¼Œå¦‚æžœå†æŽ’åºå‰åŽèƒ½å¤Ÿä¿æŒç›¸å¯¹çš„é¡ºåºï¼Œé‚£ä¹ˆå°±æ˜¯ç¨³å®šçš„ã€‚å¿«æŽ’æ˜¯ä¸ç¨³å®šçš„ï¼Œå½’å¹¶æŽ’åºæ˜¯ç¨³å®šçš„ã€‚å¿«æŽ’ä¸­çš„æ•°å­—å˜æˆ pair&lt;num, index&gt;ç±»åž‹ï¼Œé‚£ä¹ˆå°±å¯ä»¥æˆä¸ºç¨³å®šçš„æŽ’åºã€‚ ï¼ˆèƒŒè¯µä¸€ä¸ªå›ºå®šçš„æ¨¡æ¿å°±è¡Œï¼‰å¿«æŽ’çš„æ€æƒ³ï¼š åˆ†æ²»ã€‚ç®—æ³•æ­¥éª¤ï¼š ç¡®å®šåˆ†ç•Œç‚¹ï¼Œ q[l], q[r], q[l(l +r) /2] éšæœºéƒ½æ˜¯å¯ä»¥çš„ è°ƒæ•´åŒºé—´ï¼Œ ä½¿ä¸€ä¾§æ˜¯å°äºŽç­‰äºŽxï¼Œå¦å¤–ä¸€ä¾§æ˜¯å¤§äºŽç­‰äºŽx å°±æ˜¯okçš„ é€’å½’å¤„ç†å·¦å³ä¸¤æ®µ å¿«æŽ’çš„å¹³å‡æ—¶é—´å¤æ‚åº¦æ˜¯$n log_{2} n$ï¼Œ æœ€åæ˜¯ $O(n^2)$ã€‚ å½’å¹¶æŽ’åº- åˆ†æ²» ç¡®å®šåˆ†ç•Œç‚¹ï¼Œmid =(l +r) /2 é€’å½’æŽ’åº, left å’Œ right å½’å¹¶ï¼ŒåˆäºŒä¸ºä¸€ å¿«æŽ’æ˜¯å…ˆæ“ä½œåŽé€’å½’ï¼Œå½’å¹¶æ˜¯å…ˆé€’å½’ç„¶åŽå…¶ä»–æ“ä½œã€‚æ—¶é—´å¤æ‚åº¦æ˜¯(å¹³å‡å’Œæœ€å) $O(nlog_2n)$ï¼Œæ€»å…±æ˜¯æœ‰ $logn$ å±‚ï¼Œç„¶åŽæ¯å±‚è®¡ç®—æ˜¯$O(n)$ã€‚å½’å¹¶æŽ’åºç›¸å¯¹äºŽå¿«æŽ’æ˜¯éœ€è¦ä¸€ä¸ªé¢å¤–çš„$O(n)$ çš„ç©ºé—´åŽ»å­˜å‚¨æŽ’åºä¹‹åŽçš„ç»“æžœã€‚ if (l &gt;= r) å¦‚æžœæ²¡æœ‰æ•°å­—æˆ–è€…åªæœ‰ä¸€ä¸ªæ•°å­—çš„æ—¶å€™ï¼Œåšçš„æ“ä½œ.åœ¨å¸¸ç”¨çš„æ¨¡æ¿ä¸­ï¼Œå› ä¸ºä½¿ç”¨äº†ä¸€ä¸ªä¸´æ—¶æ•°ç»„ï¼Œæ‰€ä»¥æ˜¯éœ€è¦æŠŠç»“æžœæ‹¿å›žæ¥ï¼Œæ‰€ä»¥æœ€åŽæ˜¯éœ€è¦ä¸€ä¸ªå¾ªçŽ¯è¿›è¡Œæ“ä½œçš„ã€‚ äºŒåˆ† äºŒåˆ†çš„æœ¬è´¨ä¸æ˜¯å•è°ƒæ€§ï¼ˆå¦‚æžœå…·æœ‰å•è°ƒæ€§ï¼Œé‚£ä¹ˆæ˜¯å¯ä»¥äºŒåˆ†ï¼Œä½†å¦‚æžœæ²¡æœ‰å•è°ƒæ€§ï¼Œä¹Ÿæ˜¯æœ‰å¯èƒ½äºŒåˆ†çš„ï¼‰ã€‚äºŒåˆ†çš„æœ¬è´¨æ˜¯è¾¹ç•Œï¼Œå¯ä»¥æ‰¾åˆ°ä¸€ä¸ªåˆ†ç•Œç‚¹ï¼Œå·¦è¾¹æ˜¯æ»¡è¶³è¿™ä¸ªæ¡ä»¶ï¼Œå³è¾¹æ˜¯ä¸æ»¡è¶³è¿™ä¸ªæ¡ä»¶ã€‚è¿™ä¸ªæ—¶å€™å°±å¯ä»¥äºŒåˆ†ã€‚æ¯æ¬¡äºŒåˆ†çš„æ—¶å€™éƒ½ä¿è¯ç­”æ¡ˆæ˜¯åœ¨è¿™ä¸ªåŒºé—´å†…çš„ã€‚ æ•´æ•°äºŒåˆ†ç‰ˆæœ¬ä¸€ï¼šå½“æˆ‘ä»¬å°†åŒºé—´[l, r]åˆ’åˆ†æˆ[l, mid]å’Œ[mid + 1, r]æ—¶ï¼Œå…¶æ›´æ–°æ“ä½œæ˜¯r = midæˆ–è€…l = mid + 1;ï¼Œè®¡ç®—midæ—¶ä¸éœ€è¦åŠ 1ã€‚ç‰ˆæœ¬äºŒï¼šå½“æˆ‘ä»¬å°†åŒºé—´[l, r]åˆ’åˆ†æˆ[l, mid - 1]å’Œ[mid, r]æ—¶ï¼Œå…¶æ›´æ–°æ“ä½œæ˜¯r = mid - 1æˆ–è€…l = mid;ï¼Œæ­¤æ—¶ä¸ºäº†é˜²æ­¢æ­»å¾ªçŽ¯ï¼Œè®¡ç®—midæ—¶éœ€è¦åŠ 1ã€‚å¯ä»¥é€šè¿‡è¿™ä¸ªé¢˜ç›®å¥½å¥½ç†è§£ä¸¤è€…çš„åŒºåˆ«ã€‚åœ¨æŽ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åŽä¸€ä¸ªä½ç½® cpp ä¸­list å°è£…æ˜¯é“¾è¡¨ï¼Œvector å°è£…æ˜¯æ•°ç»„ã€‚ è¯¥é¢˜ç›®çš„è®²è§£å¯ä»¥ä»Žè¿™é‡Œæ‰¾æ‰¾ 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; if (nums.empty()) return vector&lt;int&gt;(&#123;-1, -1&#125;); vector&lt;int&gt; res; int l = 0, r = nums.size() - 1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (nums[mid] &gt;= target) r = mid; else l = mid + 1; &#125; if (nums[r] != target) return vector&lt;int&gt;(&#123;-1, -1&#125;); res.push_back(r); l = 0, r = nums.size() - 1; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (nums[mid] &lt;= target) l = mid; else r = mid - 1; &#125; res.push_back(r); return res; &#125;&#125;; æµ®ç‚¹æ•°äºŒåˆ†é—®é¢˜ã€‚æµ®ç‚¹æ•°ä¸å­˜åœ¨ +1ï¼Œ-1 æ“ä½œï¼Œå› ä¸ºè¿™ä¸ªæ˜¯å¯åˆ†çš„ã€‚ä½†æ˜¯å­˜åœ¨ç²¾åº¦é—®é¢˜ï¼Œå¦‚æžœé¢˜ç›®è¦æ±‚æ˜¯ 6ä½å°æ•°ï¼Œé‚£ä¹ˆè¾¹ç•Œå€¼åˆ¤æ–­æ˜¯ä½¿ç”¨ $1e-8$ å°±å¯ä»¥ä¿è¯ã€‚ï¼ˆè¦ä¿è¯æ¯”è¦æ±‚çš„ä½æ•°å¤šä¸¤ä½ï¼Œä¸€èˆ¬æ˜¯æ²¡æœ‰é—®é¢˜çš„ï¼‰ 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;int main()&#123; double x ; cin &gt;&gt;x; double l =0, r =0; while( r -l &gt; 1e-8) &#123; double mid =( l+r) /2; if(mid *mid &gt;=x) r =mid; else l =mid; &#125; printf("%lf\n", l); return 0;&#125;]]></content>
      <categories>
        <category>CSåŸºç¡€</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[æ·±åº¦ç½‘ç»œä¸­çš„ç¢Žç¢Žå¿µ]]></title>
    <url>%2F2019%2F03%2F26%2F%E6%B7%B1%E5%BA%A6%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[ä»‹ç»æ·±åº¦ç½‘ç»œä¸­å°çš„åŸºæœ¬æ¦‚å¿µï¼Œæ¯”å¦‚æƒé‡åˆå§‹åŒ–ã€æ¿€æ´»å‡½æ•°å’Œä¼˜åŒ–å™¨ å’Œå¸¸è§çš„æŠ€æœ¯æ¯”å¦‚ dropoutã€‚ Weights Initializationweights çš„åˆå§‹åŒ–åœ¨ç½‘ç»œçš„è®­ç»ƒèµ·åˆ°é‡è¦çš„ä½œç”¨ï¼Œåˆå§‹åŒ–çš„å¥½åèƒ½å¤Ÿç›´æŽ¥å½±å“åˆ°ç½‘ç»œæ˜¯å¦å¯ä»¥æ­£å¸¸æ”¶æ•›ã€‚è¿™é‡Œçš„åˆå§‹åŒ–éƒ½æ˜¯æŒ‡çš„æ˜¯weightsåˆå§‹åŒ–ã€‚bias è¡¨ç¤ºåå·®ï¼Œå™ªå£°ï¼Œä½œç”¨åœ¨äºŽä¼å›¾åŽ»æè¿°çœŸå®žçš„åˆ†å¸ƒï¼ˆé«˜æ–¯åˆ†å¸ƒï¼‰ï¼Œé€šè¿‡å¼•å…¥éšæœºæ€§æ¥è¡¨ç¤ºè¿™ä¸ªæ˜¯å…·æœ‰æŽ¨å¹¿æ€§çš„ã€‚ä¸»è¦ä»‹ç»å¸¸è§çš„ä¸‰ç§åˆå§‹åŒ–æ–¹æ³•å’Œé€‰æ‹©æ–¹æ³•ã€‚ Hereâ€™s another trick â€” before squishing our scalar value (called an activation) into the sigmoid function, we can add a little number called the bias, b. There will be two biases, one for each user and one for each movie. Random Initializationæ€»ç»“æ¥è¯´å°±æ˜¯å®¹æ˜“å‡ºçŽ°æ¢¯åº¦æ¶ˆå¤±å’Œæ¢¯åº¦çˆ†ç‚¸ï¼Œå°¤å…¶æ˜¯åœ¨layer_sizeï¼ˆç‰¹å¾æ•°é‡ï¼‰ æ¯”è¾ƒå¤§çš„æ—¶å€™ã€‚ä»Žå‡å€¼æ–¹å·®çš„è§’åº¦è¿›è¡Œåˆ†æžã€‚ a) If weights are initialized with very high values the term np.dot(W,X)+becomes significantly higher and if an activation function like sigmoid() is applied, the function maps its value near to 1 where slope of gradient changes slowly and learning takes a lot of time.b) If weights are initialized with low values it gets mapped to 0, where the case is same as above. 1w =np.random.randn(layer_size[l],layer_size[l-1]) å¦å¤–çš„è¡¨è¿°æ–¹å¼ï¼š If the weights start too small, then the signal shrinks as it passes through each layer until itâ€™s too small to be useful.If the weights start too large, then the signal grows as it passes through each layer until itâ€™s too massive to be useful (big value in sigmoid function). Xavier initialization /ËˆzeÉªvjÉ™r/sFor deep networks, we can use a heuristic to initialize the weights depending on the non-linear activation function. This applies to Xavier and He initialization. Xavier/Glorot Initialization initializes the weights in your network by drawing them from a distribution with zero mean and a specific variance.$$ { var } ( w _ { i } ) = \frac { 1 } { layer_{l-1}}$$ 1w=np.random.randn(layer_size[l],layer_size[l-1])*np.sqrt(1/layer_size[l-1]) In practice, it works better for layers with sigmoid or tanh function. æ€»çš„æ€æƒ³åŽŸåˆ™ï¼šThey set the weights neither too much bigger that 1, nor too much less than 1.å°±æ˜¯æœ¬æ¥å°±æ˜¯åœ¨ (0,1) æ ‡å‡†æ­£å¤ªåˆ†å¸ƒå‡ºæ¥ï¼Œç„¶åŽè¿›è¡Œäº†è¿›ä¸€æ­¥çš„çº¦æŸæ¡ä»¶ã€‚æ€æƒ³å½“ç‰¹å¾æ•°é‡è¶Šå¤§çš„æ—¶å€™ï¼Œweights çš„æ³¢åŠ¨æƒ…å†µæ˜¯æˆåæ¯”çš„ï¼Œæœ€åŽçš„weights æ•°å€¼è¶ŠæŽ¥è¿‘äºŽå‡å€¼é™„è¿‘ã€‚ He InitializationUsing RELU or Leaky RELU is relatively robust to the vanishing/ exploding gradient issues compared with sigmoid function especially for networks that are not too deep. And it the case of Leaky RELU, it never has zero gradients. For RELU, we multiply the randomly generated values of $w$ by: $$\sqrt { \frac { 2 } { layer _ { [ l - 1 ] } } }$$1w=np.random.randn(layer_size[l],layer_size[l-1])*np.sqrt(2/layer_size[l-1]) Sometimes, we combine the idea of Xavier initialization and He initializaiton so the variance becomes the following: $$\sqrt { \frac { 2 } { layer _ { [ l - 1 ] } + \operatorname { layer } _ { [ l ] } } }$$ 12w=np.random.randn(layer_size[l],layer_size[l-1])*np.sqrt(2/(layer_size[l-1]+layer_size[l]))# ä»£ç ä¸­ random() ä¸­çš„ä¸¤ä¸ªå‚æ•°æ˜¯ shapeï¼Œæœ€åŽçš„np.sqrt æ ‡å‡†å·® The idea behind this is that we set the weights neither too much bigger than 1 nor too much less than 1 so the gradients do not vanish or explode too quickly. æ‰€ä»¥ä¸Šè¿°çš„åˆå§‹åŒ–ä»Žæ•°å­¦çš„è§’åº¦åŽ»ç†è§£ï¼š ä»Ž(0,1) æ ‡å‡†æ­£å¤ªåˆ†å¸ƒ è½¬æ¢æˆäº† (0, np.sqrt(2/ size_l -1)) è¿™æ ·çš„åˆ†å¸ƒï¼Œå°±æ˜¯ä½ ç½‘ç»œç»“æž„æ˜¯è¶Šå®½ï¼Œé‚£ä¹ˆè¿™ä¸ªæ–¹å·®å°±æ˜¯è¶Šå°çš„ï¼Œæœ€åŽçš„ç»“æžœæ˜¯è¶Šé›†ä¸­çš„ï¼Œå°±è¶Šé›†ä¸­çš„ å‡å€¼ u å·¦å³ã€‚ä»Žå›¾åƒçš„è§’åº¦çœ‹ï¼Œæ–¹å·®è¶Šå¤§ï¼Œå›¾åƒè¶ŠçŸ®èƒ–ï¼›æ–¹å·®è¶Šå°ï¼Œå›¾åƒè¶Šç˜¦é«˜ã€‚ Takeoff In summary, the main difference in machine learning is the following: He initialization works better for layers with ReLu(s) activation. Xavier initialization works better for layers with sigmoid activation. Activation functionæ€»çš„è¯´å¯ä»¥åˆ†ä¸ºçº¿æ€§å’Œéžçº¿æ€§çš„æ¿€æ´»å‡½æ•°ï¼Œ activation function çš„ä½œç”¨ å°±æ˜¯å¯¹äºŽç½‘ç»œçš„è¾“å‡º è¯´yes or no. It maps the resulting values in between 0 to 1 or -1 to 1 etc. Sigmoid function (Logistic Activation)the only reason why we use sigmoid is because it exists between 0 to 1. è¿™ä¸ªéžå¸¸æœ‰åˆ©äºŽ predict probability. å› ä¸ºè‡ªç„¶æ˜ å°„åˆ° 0 æ˜¯ä¸å­˜åœ¨ ç„¶åŽ1 æ˜¯å­˜åœ¨ã€‚è€Œå½“å¤šåˆ†ç±»çš„æ—¶å€™ï¼Œä½¿ç”¨softmaxã€‚ Tanh function The advantage is that the negative inputs will be mapped strongly negative and the zero inputs will be mapped near zero in the tanh graph. Relu (Rectified Linear Unit) Activationæœ¬è´¨ä¸Šæ˜¯åˆ†æ®µå‡½æ•°ã€‚ range: [0, infinity]. The function and its derivative both are monotonic. Leaky Reluæ¯å½“ä¸€ä¸ªä¼Ÿå¤§çš„ä¸œè¥¿äº§å‡ºï¼Œæ€»ä¼šä¼´éšç€æ¯”è¾ƒæ˜Žæ˜¾çš„é”™è¯¯ï¼Œç„¶åŽç´§è·Ÿç€å°±æ˜¯æœ‰ä¸€ä¸ª rectified(improved) è¿™ç§ç‰ˆæœ¬ã€‚è¿™ä¸ªç›¸æ¯”ä¹‹å‰å°±æ˜¯ä¿®æ­£äº† å½“è¾“å…¥æ˜¯è´Ÿæ•°çš„æ—¶å€™ï¼Œæ€Žä¹ˆåŠžçš„é—®é¢˜ã€‚ Softmaxè¿™ä¸ªéœ€è¦ä»Žæ•°å­¦çš„è§’åº¦åŽ»ç†è§£ï¼Œæ•°å­¦å…¬å¼å°±æ˜¯ä¸‹é¢ã€‚æœ‰ä¸€ä¸ªçœŸå®žçš„ä¾‹å­ï¼š å¦‚æžœä¸€å¼ â€4â€ çš„å›¾ç‰‡ï¼Œè¾“å‡ºä¸€ä¸ªç½‘ç»œï¼Œæœ€åŽæ˜¯softmax æ¿€æ´»å‡½æ•°ï¼Œé‚£ä¹ˆæœ€åŽå¾—åˆ°çš„ â€œ4â€ çš„æ¦‚çŽ‡æ˜¯æœ€å¤§çš„ï¼Œä½†æ˜¯ä¹Ÿæ˜¯æœ‰å…¶ä»–çš„å¯èƒ½æ€§å­˜åœ¨çš„ï¼Œè¿™ä¸ªå°±æ˜¯softmax çš„æ•ˆæžœã€‚ æœ€ä¸»è¦çš„åŠŸèƒ½æ˜¯ convert number into probabilities. è¿™ç§æ•ˆæžœï¼Œä¸åƒsigmoid é‚£æ ·æœ‰å¾ˆæ˜Žç¡®çš„æ•°å­¦å…¬å¼ã€‚ $$\sigma ( z ) _ { j } = \frac { e ^ { z _ { j } } } { \sum _ { k = 1 } ^ { K } e ^ { z _ { k } } }$$ Softmax function, a wonderfulactivation function that turns numbers aka logits into probabilities that sum to one.Remember the takeaway is: the essential goal of softmax is to turn numbers into probabilities. å·ç§¯ç½‘ç»œä¸€ä¸ªå·ç§¯ç¥žç»ç½‘ç»œç”±è‹¥å¹²å·ç§¯å±‚ã€Poolingå±‚ã€å…¨è¿žæŽ¥å±‚ç»„æˆã€‚ å·ç§¯å±‚$Input \rightarrow [Conv] \times N \rightarrow [Pool] \times M \rightarrow [FK] \times K$ ä¸‹é¢çš„åŠ¨ç”»æ˜¾ç¤ºäº†åŒ…å«ä¸¤ä¸ªfilterçš„å·ç§¯å±‚çš„è®¡ç®—ã€‚æˆ‘ä»¬å¯ä»¥çœ‹åˆ° $7 \times 7 \times 3$ è¾“å…¥ï¼Œç»è¿‡ä¸¤ä¸ª$3 \times 3 \times 3 $filterçš„å·ç§¯(æ­¥å¹…ä¸º2)ï¼Œå¾—åˆ°äº†$ 3 \times 3 \times 2 $çš„è¾“å‡ºã€‚å¦å¤–æˆ‘ä»¬ä¹Ÿä¼šçœ‹åˆ°ä¸‹å›¾çš„Zero paddingæ˜¯1ï¼Œä¹Ÿå°±æ˜¯åœ¨è¾“å…¥å…ƒç´ çš„å‘¨å›´è¡¥äº†ä¸€åœˆ0ã€‚Zero paddingå¯¹äºŽå›¾åƒè¾¹ç¼˜éƒ¨åˆ†çš„ç‰¹å¾æå–æ˜¯å¾ˆæœ‰å¸®åŠ©çš„ã€‚ 100Ã—100Ã—3ï¼Œ3Ã—3 å·ç§¯æ ¸ï¼Œè¾“å‡ºæ˜¯ 50Ã—50Ã—10ï¼Œç®—è¿›è¡Œäº†å¤šå°‘æ¬¡ä¹˜-åŠ æ“ä½œï¼Ÿè¾“å‡ºçš„æ¯ä¸ªåƒç´ ç‚¹éƒ½è¦ç»è¿‡ 3Ã—3Ã—3 = 27 æ¬¡ä¹˜-åŠ æ“ä½œï¼Œå› æ­¤æ€»å…±éœ€è¦è¿›è¡Œ 50Ã—50Ã—10Ã—27 æ¬¡ä¹˜-åŠ æ“ä½œã€‚ å¯¹äºŽåŒ…å«ä¸¤ä¸ª $333 $çš„fitlerçš„å·ç§¯å±‚æ¥è¯´ï¼Œå…¶å‚æ•°æ•°é‡ä»…æœ‰ $(3 \times 3 \times3+1) \times 2 =56 $ä¸ªï¼Œä¸”å‚æ•°æ•°é‡ä¸Žä¸Šä¸€å±‚ç¥žç»å…ƒä¸ªæ•°æ— å…³ã€‚ä¸Žå…¨è¿žæŽ¥ç¥žç»ç½‘ç»œç›¸æ¯”ï¼Œå…¶å‚æ•°æ•°é‡å¤§å¤§å‡å°‘äº†ã€‚ å·ç§¯å±‚è¾“å‡ºå¤§å°è®¡ç®—ï¼šè¾“å…¥å¤§å°ï¼š $W 1 \times H 1 \times D 1$è¶…å‚æ•°ï¼ˆfilterä¿¡æ¯ +æ˜¯å¦å¡«å……ï¼‰ï¼š filter ä¸ªæ•°( K), filter å¤§å°( F), æ­¥é•¿ (S )ï¼Œè¾¹ç•Œå¡«å……( P)è¾“å‡ºï¼š$$\begin{split}W _ { 2 } &amp; = \left( W _ { 1 } - F + 2 P \right) / S + 1 \\H _ { 2 } &amp;= \left( H _ { 1 } - F + 2 P \right) / S + 1 \\D _ { 2 } &amp;= K\end{split}$$ æ³¨æ„è®¡ç®—çš„æ˜¯å®½å’Œé«˜çš„ä¸¤ä¸ªç»´åº¦ã€‚ $$\begin{split}\text {output} _ { w } &amp;= \left\lfloor \frac { i m a g e _ { w } + 2 p a d d i n g - k e r n e l _ { s i z e } } { s t r i d e } \right\rfloor + 1 \\\text {output} _ { h } &amp;= \left\lfloor \frac { i m a g e _ { h } + 2 p a d d i n g - k e r n e l _ { s i z e } } { s t r i d e } \right\rfloor + 1 \\\end{split}$$å·ç§¯å±‚å‚æ•°é‡è®¡ç®—ï¼š æƒå€¼å…±äº«ï¼š ç»™å®šä¸€å¼ å›¾ï¼Œç”¨ä¸€ä¸ª filter åŽ»æ‰«æè¿™å¼ å›¾ï¼Œ filter é‡Œé¢çš„æ•°å­—å«åšæƒé‡ï¼Œè¿™å¼ å›¾ä¹ˆä¸ªä½ç½®æ˜¯è¢«åŒæ ·çš„filter æ‰«æçš„ï¼Œæ‰€ä»¥æƒé‡æ˜¯ä¸€æ ·çš„ï¼Œä¹Ÿå°±æ˜¯å…±äº«ã€‚ï¼ˆä»Žå‡å°‘å‚æ•°é‡çš„è§’åº¦åŽ»ç†è§£ï¼‰è¿™ä¸ªæ¦‚å¿µæ˜¯å’Œå…¨è¿žæŽ¥å±‚ä¸­çš„æƒå€¼è¿›è¡Œæ¯”è¾ƒçš„ï¼Œç®€å•æ¥è¯´å°±æ˜¯é™ä½Žäº†æƒé‡çš„ä½¿ç”¨ã€‚æƒé‡å…±äº«å³ filter å€¼çš„å…±äº«ã€‚å¯¹äºŽ ä¸‰ç»´å›¾ç‰‡æ¥è¯´ï¼Œæ¯ä¸ªfilteréœ€è¦FFD1ä¸ªæƒé‡å€¼ï¼Œæ€»å…±Kä¸ªfilterï¼Œéœ€è¦FFD1*Kæƒé‡å€¼ã€‚å’Œä¸€ç»´ä¸€æ ·ï¼Œæ•´ä¸ªæ»‘åŠ¨è¿‡ç¨‹ä¸­filter W0å’ŒW1å€¼ä¿æŒä¸å˜ï¼Œå¯ç§°ä½œæƒå€¼å…±äº«ã€‚è€Œä¸”ï¼Œè¡¥å……ä¸€å¥ï¼Œå¯¹äºŽä¸‰ç»´çš„inputï¼Œæƒå€¼åªæ˜¯åœ¨inputçš„æ¯ä¸ªdepth sliceä¸Šå…±äº«çš„ã€‚å¯¹äºŽä¸€å±‚çš„ filter åªæ˜¯æœ‰ä¸€ä¸ªbiasã€‚ for example:Filterä¸ªæ•°ï¼š32åŽŸå§‹å›¾åƒshapeï¼š$224 \times 224 \times 3$å·ç§¯æ ¸å¤§å°ä¸ºï¼š$2 \times 2$ä¸€ä¸ªå·ç§¯æ ¸çš„å‚æ•°ï¼š$ 2 \times 2 \times 3=12 $16ä¸ªå·ç§¯æ ¸çš„å‚æ•°æ€»é¢ï¼š$ 16 \times 12 + 16 =192 + 16 = 208 $$ weight \times x + bias $æ ¹æ®è¿™ä¸ªå…¬å¼ï¼Œå³å¯ç®—çš„æœ€ç»ˆçš„å‚æ•°æ€»é¢ä¸ºï¼š208 Pooling å±‚Poolingå±‚ä¸»è¦çš„ä½œç”¨æ˜¯ä¸‹é‡‡æ ·ï¼Œä¸»è¦æœ‰ä¸¤ç‚¹ä½œç”¨ï¼Œä¸€ä¸ªæ˜¯æå–é‡è¦ç‰¹å¾ï¼Œä¸€ä¸ªæ˜¯ç®€åŒ–ç½‘ç»œçš„è®¡ç®—ã€‚Poolingçš„æ–¹æ³•å¾ˆå¤šï¼Œæœ€å¸¸ç”¨çš„æ˜¯Max Poolingã€‚Max Poolingå®žé™…ä¸Šå°±æ˜¯åœ¨n*nçš„æ ·æœ¬ä¸­å–æœ€å¤§å€¼ï¼Œä½œä¸ºé‡‡æ ·åŽçš„æ ·æœ¬å€¼ã€‚ä¸‹å›¾æ˜¯ max poolingï¼š é™¤äº†Max Pooingä¹‹å¤–ï¼Œå¸¸ç”¨çš„è¿˜æœ‰Mean Poolingâ€”â€”å–å„æ ·æœ¬çš„å¹³å‡å€¼ã€‚ æ± åŒ–å±‚å¾€å¾€åœ¨å·ç§¯å±‚åŽé¢ï¼Œé€šè¿‡æ± åŒ–æ¥é™ä½Žå·ç§¯å±‚è¾“å‡ºçš„ç‰¹å¾å‘é‡ï¼ŒåŒæ—¶æ”¹å–„ç»“æžœï¼ˆä¸æ˜“å‡ºçŽ°è¿‡æ‹Ÿåˆï¼‰ã€‚ æ± åŒ–å±‚å‚æ•°ä¸ªæ•°è®¡ç®—ï¼š è¿™ä¸ªå¾ˆæ˜Žæ˜¾æ˜¯æ²¡æœ‰å‚æ•°çš„ã€‚ å·ç§¯å±‚ vs pooling å±‚ä¸»è¦æ¯”è¾ƒä¸¤è€…åœ¨é™ç»´ã€ç‰¹å¾æå–æ–¹é¢çš„å·®åˆ«ã€‚ pooling å±‚å¸¸è§çš„ max pooling å’Œ average (mean ) poolingä¸¤ç§ã€‚è¯¥å±‚æ˜¯æ²¡æœ‰å‚æ•°çš„ã€‚ pooling çš„ä½œç”¨ä¸»è¦ä½“çŽ°åœ¨å‡å°‘æ¨¡åž‹åŽ»æ‹Ÿåˆçš„éš¾åº¦ï¼Œé˜²æ­¢è¿‡æ‹Ÿåˆï¼ŒèŠ‚çœè®¡ç®—åŠ›æ–¹é¢ã€‚max pooling ç›¸æ¯”äºŽ mean pooling æ›´åŠ æœ‰ æå–ç‰¹å¾çš„æ„Ÿè§‰ã€‚æŠ“ä½æ¯”è®¡è¾ƒæ˜¾è‘—çš„ç‰¹å¾ï¼ŒAVE pooling å¯ä»¥å¸¦æ¥ä¸€å®šæ„ä¹‰ä¸Šçš„å¹³æ»‘ï¼Œå¯ä»¥å‡å°å›¾åƒå°ºå¯¸å˜åŒ–çš„å¹²æ‰°ã€‚ä»Žæ•ˆæžœä¸Šè®²ï¼Œå‰è€…ä¸€åŠæ˜¯è¦å¥½äºŽåŽè€…çš„ã€‚ ä»Žä¸Šé¢å·¦å›¾å¯ä»¥çœ‹åˆ°ï¼Œä½¿ç”¨äº†poolæ“ä½œå…¶å®žå°±æ˜¯é™ä½Žå›¾ç‰‡çš„ç©ºé—´å°ºå¯¸ã€‚å³å›¾ä½¿ç”¨ä¸€ä¸ª 2 Ã— 2çš„ æ± åŒ–æ ¸ï¼ˆfilterï¼‰ï¼Œä»¥2ä¸ºæ­¥é•¿ï¼ˆstrideï¼‰ï¼Œå¯¹å›¾ç‰‡è¿›è¡Œmax poolingï¼Œé‚£ä¹ˆä¼šå›¾ç‰‡å°±ä¼šå°ºå¯¸å°±ä¼šå‡å°ä¸€åŠã€‚éœ€è¦æ³¨æ„ï¼Œè¿™é‡Œæ˜¯å› ä¸º stride = 2ï¼Œæ‰€ä»¥å›¾ç‰‡å°ºå¯¸æ‰ä¼šå‡å°‘ä¸€åŠçš„ã€‚ ä¸åŒç‚¹ï¼špooling æ˜¯æ²¡æœ‰ weights æˆ–è€… parameter æ›´æ–°ï¼Œä»…ä»…æ˜¯ä¸‹é‡‡æ ·convolution layer åˆ™ä¸ä¸€æ ·ï¼Œæå–äº†ç‰¹å¾å¹¶ä¸”è¿›è¡Œäº†ä¸‹é‡‡æ ·ã€‚ å…¨è¿žæŽ¥å±‚è¿žæŽ¥æ‰€æœ‰çš„ç‰¹å¾ï¼Œå°†è¾“å‡ºå€¼é€ç»™åˆ†ç±»å™¨ï¼ˆå¦‚softmaxåˆ†ç±»å™¨ï¼‰ æ¯”å¦‚è¯´ä¸Šä¸€å±‚ï¼ˆæ± åŒ–å±‚ï¼‰çš„è¾“å‡ºä¸ºï¼š$(111 \times 111 \times 16) $ï¼Œä»Žç¬¬ä¸€å±‚åˆ°ç¬¬äºŒå±‚ï¼Œåªæ˜¯å›¾ç‰‡å¤§å°å‘ç”Ÿäº†å˜åŒ–ï¼Œæ·±åº¦æ²¡æœ‰å‘ç”Ÿå˜åŒ–ï¼Œè€ŒDenseå¯¹åº”çš„ç¥žç»å…ƒä¸ªæ•°ä¸º133ä¸ªï¼Œé‚£ä¹ˆè¿˜æ˜¯æ ¹æ®å…¬å¼ï¼š$weight \times x + bias$ï¼Œè®¡ç®—å¾—ï¼š$133 \times16+133=2261$ Dropout æ¦‚å¿µ dropout æ˜¯æŒ‡åœ¨æ·±åº¦å­¦ä¹ ç½‘ç»œçš„è®­ç»ƒè¿‡ç¨‹ä¸­ï¼ŒæŒ‰ç…§ä¸€å®šçš„æ¦‚çŽ‡å°†ä¸€éƒ¨åˆ†ç¥žç»ç½‘ç»œå•å…ƒæš‚æ—¶ä»Žç½‘ç»œä¸­ä¸¢å¼ƒï¼Œç›¸å½“äºŽä»ŽåŽŸå§‹çš„ç½‘ç»œä¸­æ‰¾åˆ°ä¸€ä¸ªæ›´ç˜¦çš„ç½‘ç»œã€‚ why æˆ‘ä»¬åœ¨è®­ç»ƒç¥žç»ç½‘ç»œçš„æ—¶å€™ï¼Œä¼šé‡åˆ°ä¸¤å¤§ç¼ºç‚¹ï¼š å®¹æ˜“è¿‡æ‹Ÿåˆ è´¹æ—¶ dropout ä¸»è¦æ˜¯ä¸ºäº†åœ¨ä¸€å®šç¨‹åº¦ä¸Šå‡å°‘è¿‡æ‹Ÿåˆã€‚ å·¥ä½œåŽŸç† é¦–å…ˆéšæœºï¼ˆä¸´æ—¶ï¼‰åˆ æŽ‰ç½‘ç»œä¸­ä¸€åŠçš„éšè—ç¥žç»å…ƒï¼Œè¾“å…¥è¾“å‡ºç¥žç»å…ƒä¿æŒä¸å˜ï¼ˆå›¾ä¸­è™šçº¿ä¸ºéƒ¨åˆ†ä¸´æ—¶è¢«åˆ é™¤çš„ç¥žç»å…ƒï¼‰ ç„¶åŽæŠŠè¾“å…¥xé€šè¿‡ä¿®æ”¹åŽçš„ç½‘ç»œå‰å‘ä¼ æ’­ï¼Œç„¶åŽæŠŠå¾—åˆ°çš„æŸå¤±ç»“æžœé€šè¿‡ä¿®æ”¹çš„ç½‘ç»œåå‘ä¼ æ’­ã€‚ä¸€å°æ‰¹è®­ç»ƒæ ·æœ¬æ‰§è¡Œå®Œè¿™ä¸ªè¿‡ç¨‹åŽï¼Œåœ¨æ²¡æœ‰è¢«åˆ é™¤çš„ç¥žç»å…ƒä¸ŠæŒ‰ç…§éšæœºæ¢¯åº¦ä¸‹é™æ³•æ›´æ–°å¯¹åº”çš„å‚æ•°ï¼ˆwï¼Œbï¼‰ ç»§ç»­é‡å¤è¿™ä¸€è¿‡ç¨‹ï¼šæ¢å¤è¢«åˆ æŽ‰çš„ç¥žç»å…ƒï¼ˆæ­¤æ—¶è¢«åˆ é™¤çš„ç¥žç»å…ƒä¿æŒåŽŸæ ·ï¼Œè€Œæ²¡æœ‰è¢«åˆ é™¤çš„ç¥žç»å…ƒå·²ç»æœ‰æ‰€æ›´æ–°ï¼‰ã€‚ä»Žéšè—å±‚ç¥žç»å…ƒä¸­éšæœºé€‰æ‹©ä¸€ä¸ªä¸€åŠå¤§å°çš„å­é›†ä¸´æ—¶åˆ é™¤æŽ‰ï¼ˆå¤‡ä»½è¢«åˆ é™¤ç¥žç»å…ƒçš„å‚æ•°ï¼‰ã€‚ ä¸æ–­çš„é‡å¤ç€ä¸€è¿‡ç¨‹ æ€Žä¹ˆç†è§£æµ‹è¯•æ—¶æƒé‡å‚æ•°wè¦ä¹˜ä»¥æ¦‚çŽ‡pï¼Ÿ å‡è®¾æ€»å…±æœ‰100ä¸ªç¥žç»å…ƒï¼Œè®­ç»ƒçš„æ—¶å€™æˆ‘ä»¬åŠ ä¸Šdropoutï¼Œp=0.5ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±æœ‰50ä¸ªç¥žç»å…ƒå‚ä¸Žè®­ç»ƒï¼Œé‚£ä¹ˆæˆ‘ä»¬æ¯æ¬¡50ä¸ªç¥žç»å…ƒè®­ç»ƒå‡ºæ¥çš„æ¨¡åž‹å‚æ•°wæ˜¯è¦æ¯”ç›´æŽ¥100ä¸ªç¥žç»å…ƒè¦å°çš„ï¼Œå› ä¸ºå®ƒæ›´æ–°çš„æ¬¡æ•°ä¼šæ›´å°‘ã€‚æˆ‘ä»¬æµ‹è¯•çš„æ—¶å€™100ä¸ªç¥žç»å…ƒæ˜¯éƒ½ä¼šå‚ä¸Žè®¡ç®—çš„ï¼Œè¿™å°±è·Ÿè®­ç»ƒçš„æ—¶å€™æˆ‘ä»¬ä½¿ç”¨50ä¸ªç¥žç»å…ƒäº§ç”Ÿå·®å¼‚äº†ï¼Œå¦‚æžœè¦ä¿è¯æµ‹è¯•çš„æ—¶å€™æ¯ä¸ªç¥žç»å…ƒçš„å…³è”è®¡ç®—ä¸èƒ½å°‘ï¼Œåªèƒ½ä»Žé€šè¿‡æ”¹å˜wæ¥è¾¾åˆ°è·Ÿè®­ç»ƒæ—¶ä¸€æ ·è¾“å‡ºï¼Œæ‰€ä»¥æ‰ä¼šæœ‰æƒé‡å‚æ•°wä¹˜ä»¥pã€‚ ä¸ºä»€ä¹ˆ dropout å¯ä»¥æœ‰æ•ˆçš„å‡å°‘è¿‡æ‹Ÿåˆï¼Ÿï¼ˆç±»ä¼¼å–å¹³å‡çš„æ´»åŠ¨ï¼‰å› ä¸ºä¸åŒçš„ç½‘ç»œå¯èƒ½äº§ç”Ÿä¸åŒçš„è¿‡æ‹Ÿåˆï¼Œå–å¹³å‡åˆ™æœ‰å¯èƒ½è®©ä¸€äº›â€œç›¸åçš„â€æ‹Ÿåˆäº’ç›¸æŠµæ¶ˆã€‚dropoutæŽ‰ä¸åŒçš„éšè—ç¥žç»å…ƒå°±ç±»ä¼¼åœ¨è®­ç»ƒä¸åŒçš„ç½‘ç»œï¼Œéšæœºåˆ æŽ‰ä¸€åŠéšè—ç¥žç»å…ƒå¯¼è‡´ç½‘ç»œç»“æž„å·²ç»ä¸åŒï¼Œæ•´ä¸ªdropoutè¿‡ç¨‹å°±ç›¸å½“äºŽå¯¹å¾ˆå¤šä¸ªä¸åŒçš„ç¥žç»ç½‘ç»œå–å¹³å‡ã€‚ æ¢¯åº¦æ¶ˆå¤±/ æ¢¯åº¦çˆ†ç‚¸ é¦–å…ˆä¸€ä¸ªè§‚ç‚¹ï¼Œæ¢¯åº¦æ¶ˆå¤±å’Œæ¢¯åº¦çˆ†ç‚¸æœ¬è´¨ä¸Šä¸€å›žäº‹ã€‚ ç†ç”±ï¼šsigmoid å¯¼æ•°çš„æœ€å¤§å€¼ä¸º0.25ï¼Œé€šå¸¸ abs(w) &lt; 1,åˆ™ä¸Šè¿°åˆ†æžä¸­çš„æ¿€æ´»å‡½æ•°çš„å¯¼æ•°ä¸Žæƒé‡çš„ç§¯å°äºŽ0.25ï¼Œå‰é¢çš„å±‚æ¯”åŽé¢çš„å±‚æ¢¯åº¦å˜åŒ–æ›´å°ï¼Œæ•…å˜åŒ–æ›´æ…¢ï¼Œä»Žè€Œå¼•èµ·äº†æ¢¯åº¦æ¶ˆå¤±é—®é¢˜ã€‚å½“æƒå€¼è¿‡å¤§ï¼Œå‰é¢å±‚æ¯”åŽé¢å±‚æ¢¯åº¦å˜åŒ–æ›´å¿«ï¼Œåˆ™å¼•èµ·æ¢¯åº¦çˆ†ç‚¸é—®é¢˜ã€‚æ‰€ä»¥åŽé¢çš„æ¢¯åº¦æ¶ˆå¤±å’Œæ¢¯åº¦çˆ†ç‚¸åªæ˜¯å‰é¢åˆå§‹åŒ–å€¼çš„ä¸€ç§è´è¶æ•ˆåº”ï¼Œåªæ˜¯æ•°å€¼é—®é¢˜ã€‚ è§£å†³æ–¹æ³• é‡æ–°è®¾è®¡ç½‘ç»œç»“æž„ ä½¿ç”¨æ¯”è¾ƒæµ…çš„ç½‘ç»œç»“æž„ ä½¿ç”¨æ®‹å·®ç»“æž„, è¿™ç§æ–¹å¼åœ¨å›¾åƒå¤„ç†ä¸­æ›´åŠ å¸¸è§ æ¿€æ´»å‡½æ•°ä½¿ç”¨ relu or leaky relu è€Œä¸æ˜¯ sigmoid or tanh å…³äºŽweights æ–¹é¢ ä½¿ç”¨æ¢¯åº¦æˆªæ–­ï¼ˆGradient Clippingï¼‰ï¼Œæ£€æŸ¥è¯¯å·®æ¢¯åº¦çš„å€¼æ˜¯å¦è¶…è¿‡é˜ˆå€¼ï¼Œå¦‚æžœè¶…è¿‡ï¼Œåˆ™æˆªæ–­æ¢¯åº¦ï¼Œå°†æ¢¯åº¦è®¾ç½®ä¸ºé˜ˆå€¼ã€‚ ä½¿ç”¨æƒé‡æ­£åˆ™åŒ–ï¼ˆWeight Regularizationï¼‰ï¼Œå¸¸ç”¨çš„æ˜¯ ï¼Œé€šå¸¸ä½¿ç”¨çš„æ˜¯ L1 æƒ©ç½šé¡¹ï¼ˆæƒé‡ç»å¯¹å€¼ï¼‰æˆ– L2 æƒ©ç½šé¡¹ï¼ˆæƒé‡å¹³æ–¹ï¼‰è¿™ä¸ªæ˜¯åœ¨æŸå¤±å‡½æ•°ä¸Šçš„æ“ä½œ batch normalization ï¼ˆå…³äºŽBN çš„ä½ç½®æ˜¯å¯ä»¥å†æŸ¥ä¸€ä¸‹çš„ï¼ŒçŽ°åœ¨æœ‰ä¸¤ä¸ªä½ç½®ï¼Œä¸€ä¸ªæ˜¯åœ¨æ¿€æ´»å‡½æ•°ä¹‹å‰ä¸€ä¸ªæ˜¯ æ¿€æ´»å‡½æ•°ä¹‹åŽï¼Œä¸ªäººå€¾å‘äºŽæ¿€æ´»å‡½æ•°ä¹‹å‰ï¼Œå› ä¸ºè¿™æ ·æ‰æœ‰å¯ä»¥å‡å°‘æ¢¯åº¦æ¶ˆå¤±å’Œæ¢¯åº¦çˆ†ç‚¸çš„å‘ç”Ÿå‘€ï¼‰ dropoutä¸€å®šåœ¨æ¿€æ´»å‡½æ•°ä¹‹åŽ ps: CONV / FC - &gt; BatchNorm - &gt; ReLuï¼ˆæˆ–å…¶ä»–æ¿€æ´»ï¼‰ - &gt; Dropout - &gt; CONV / FCå¯¹äºŽ cnn è¿˜æœ‰ä¸€ç§å¸¸è§çš„ç»“æž„ï¼šå…ˆå·ç§¯ï¼Œå†batchnorm, ç„¶åŽæ¿€æ´»å‡½æ•°ï¼Œæœ€åŽpoolingåœ¨fully connectionä¸­çš„åº”ç”¨ï¼Œç”¨åœ¨å…¨è¿žæŽ¥å±‚ä¹‹åŽæ¿€æ´»å‡½æ•°ä¹‹å‰ ç†è§£ æ­£åˆ™åŒ–å¦‚ä½•å‡å°‘æ¨¡åž‹è¿‡æ‹Ÿåˆç¨‹åº¦ High Biasï¼ˆé«˜åå·®ï¼‰å°±æ˜¯æ¬ æ‹Ÿåˆï¼ŒHigh Varianceï¼ˆé«˜æ–¹å·®ï¼‰å°±æ˜¯è¿‡æ‹Ÿåˆã€‚ ç®€å•æ¥è¯´ï¼Œæ­£åˆ™åŒ–å°±æ˜¯åœ¨åŽŸæ¥çš„ cost function ä¸­æ·»åŠ  æ­£åˆ™é¡¹ã€‚ æ­£åˆ™åŒ–é¡¹èƒ½å‡å°‘æ¨¡åž‹çš„éžçº¿æ€§ç¨‹åº¦ï¼Œä»Žè€Œé™ä½Žæ¨¡åž‹çš„è¿‡æ‹Ÿåˆã€‚ä»Žå›¾ä¸­æ¥çœ‹ï¼Œæ­£åˆ™åŒ–é¡¹èƒ½å°†è¿‡æ‹Ÿåˆçš„æ¨¡åž‹ï¼ˆè“è‰²ï¼‰å˜ä¸ºJust Rightçš„æ¨¡åž‹ï¼ˆç²‰çº¢è‰²ï¼‰ã€‚ ä¸ºä»€ä¹ˆæ­£åˆ™åŒ–æ˜¯æœ‰æ•ˆçš„ï¼Ÿ å¯¹äºŽçº¿æ€§æ¨¡åž‹ï¼Œå…¶æ·»åŠ äº†æ­£åˆ™åŒ–é¡¹çš„Cost Functionå¦‚ä¸‹å›¾ã€‚ çŽ°åœ¨ç›®æ ‡å‡½æ•°æœ‰ä¸¤ä¸ªç›®æ ‡ï¼Œç¬¬ä¸€ä¸ªæ˜¯æˆ‘ä»¬æƒ³è¦è®­ç»ƒçš„ï¼Œä½¿å‡è®¾æ›´å¥½åœ°åŽ»æ‹Ÿåˆè®­ç»ƒæ•°æ®ï¼Œç¬¬äºŒä¸ªç›®æ ‡æ˜¯æˆ‘ä»¬æƒ³è¦ä¿æŒå‚æ•°è¾ƒå°ã€‚ $ \lambda$ ç”¨æ¥è°ƒèŠ‚ä¸¤è€…ä¹‹é—´çš„å¹³è¡¡ï¼Œè¿™æ ·ç†è§£å¦‚æžœ è¯¥å€¼è®¾ç½®çš„å¾ˆå¤§ï¼Œé‚£ä¹ˆå‰é¢çš„å‚æ•° $\theta 1 \theta 2 \theta 3 \theta 4$ å°±ä¼šè¢«éžå¸¸å¤§çš„æƒ©ç½šï¼Œè¿™äº›å€¼å°±ä¼šæŽ¥è¿‘0ã€‚å¦‚æžœå‡è®¾ç¬¬ä¸€ä¸ªç›®æ ‡æ˜¯å¤šé¡¹å¼ç»„æˆçš„ï¼Œé‚£ä¹ˆå½“ $\theta $ æ•°å€¼å˜å°çš„æ—¶å€™ï¼Œè¿™ä¸ªå¼å­å°±æ²¡æœ‰äº†ï¼Œå°±å‡å°‘äº†æ¨¡åž‹çš„å¤æ‚åº¦ã€‚ å¯¹äºŽç¥žç»ç½‘ç»œï¼Œå…¶æ¿€æ´»å‡½æ•°ï¼ˆä»¥tanhä¸ºä¾‹ï¼‰å¦‚ä¸‹å›¾ ç›´è§‚çš„ç†è§£ï¼Œå¦‚æžœæˆ‘ä»¬çš„æ­£åˆ™åŒ–ç³»æ•°ï¼ˆlambdaï¼‰æ— ç©·å¤§ï¼Œåˆ™æƒé‡wå°±ä¼šè¶‹è¿‘äºŽ0ã€‚æƒé‡å˜å°ï¼Œæ¿€æ´»å‡½æ•°è¾“å‡ºzå˜å°ã€‚zå˜å°ï¼Œå°±åˆ°äº†æ¿€æ´»å‡½æ•°çš„çº¿æ€§åŒºåŸŸï¼Œä»Žè€Œé™ä½Žäº†æ¨¡åž‹çš„éžçº¿æ€§åŒ–ç¨‹åº¦ã€‚ æ„Ÿå—é‡Žçš„è®¡ç®—åœ¨å·ç§¯ç¥žç»ç½‘ç»œä¸­ï¼Œæ„Ÿå—é‡Žï¼ˆReceptive Fieldï¼‰çš„å®šä¹‰æ˜¯å·ç§¯ç¥žç»ç½‘ç»œæ¯ä¸€å±‚è¾“å‡ºçš„ç‰¹å¾å›¾ï¼ˆfeature mapï¼‰ä¸Šçš„åƒç´ ç‚¹åœ¨è¾“å…¥å›¾ç‰‡ä¸Šæ˜ å°„çš„åŒºåŸŸå¤§å°ã€‚ è¿™ä¸ªæ˜¯ä¸€ä¸ªåå‘çš„è¿‡ç¨‹ã€‚è¿™ä¸ªå’Œ CNN çš„ ä¸åŒåœ¨äºŽï¼Œå¦‚æžœæ˜¯2 ä¸¤å±‚ï¼Œé‚£ä¹ˆè¿™ä¸ªæ˜¯è¿žç»­ï¼ˆæŒç»­ï¼‰çš„å¯¹åŒä¸€ä¸ªå›¾åƒè¿›è¡Œé‡‡æ ·ã€‚æŽ¥ç€ä¸Šä¸€ä¸ªçš„ç»“æžœè¿›è¡Œæ“ä½œã€‚ ä½¿ç”¨ä¾‹å­è¯´æ˜Žï¼šä¸¤å±‚$3 \times 3$ å·ç§¯æ“ä½œçš„æœ‰æ•ˆåŒºåŸŸ(æ„Ÿå—é‡Ž)æ˜¯ $5 \times 5 $ (æ‰€æœ‰filterçš„stride=1,pad=0)ã€‚ å·ç§¯å’Œæ± åŒ–æ“ä½œçš„è®¡ç®—ï¼ˆä¾‹é¢˜ï¼‰å·ç§¯å’Œæ± åŒ–çš„è®¡ç®—æ–¹å¼æ˜¯ä¸€æ ·çš„ï¼Œå…·ä½“å¯ä»¥å‚è€ƒä¸Šé¢å°ç»“å…³äºŽå·ç§¯æ“ä½œçš„å…¬å¼ã€‚ è¾“å…¥å›¾ç‰‡å¤§å°ä¸º200Ã—200ï¼Œä¾æ¬¡ç»è¿‡ä¸€å±‚å·ç§¯ï¼ˆkernel size 5Ã—5ï¼Œpadding 1ï¼Œstride 2ï¼‰ï¼Œpoolingï¼ˆkernel size 3Ã—3ï¼Œpadding 0ï¼Œstride 1ï¼‰ï¼Œåˆä¸€å±‚å·ç§¯ï¼ˆkernel size 3Ã—3ï¼Œpadding 1ï¼Œstride 1ï¼‰ä¹‹åŽï¼Œè¾“å‡ºç‰¹å¾å›¾å¤§å°ä¸ºï¼šA. 95B. 96C. 97D. 98E. 99F. 100 è§£ç­”ï¼š ç¬¬ä¸€æ¬¡å·ç§¯åŽå¤§å°ï¼š$$\frac { 200 + 2 - 5 } { 2 } + 1 = 99$$ ç¬¬ä¸€æ¬¡æ± åŒ–åŽå¤§å°ï¼š $$\frac { 99 + 0 - 3 } { 1 } + 1 = 97$$ ç¬¬äºŒæ¬¡å·ç§¯åŽå¤§å°ï¼š $$\frac { 97 + 2 - 3 } { 1 } + 1 = 97$$ æ‰€ä»¥æœ€åŽçš„ç»“æžœæ˜¯ 97]]></content>
      <categories>
        <category>Deep learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[siamese network]]></title>
    <url>%2F2019%2F03%2F26%2Fsiamese-network%2F</url>
    <content type="text"><![CDATA[ä¸»è¦æ˜¯ä»‹ç»è‡ªå·±è®ºæ–‡ä¸­çš„ç½‘ç»œç»“æž„ï¼šsiamese networkã€‚ ä½†å‡¡ä¼˜åŒ–ï¼Œæ— éžä¸¤æ¡è·¯ï¼šåœ¨å¥½çš„åŸºç¡€ä¸Šæ›´å¿«ï¼Œåœ¨å¿«çš„åŸºç¡€ä¸Šæ•ˆæžœæ›´å¥½ã€‚ Siamese networkè®­ç»ƒé€Ÿåº¦å¿«ï¼Œæ‰€ä»¥åªæ˜¯éœ€è¦å…¶åœ¨è®­ç»ƒæ•ˆæžœä¸Šæ›´å¥½ã€‚ å…ˆæ¥åˆ†æžä¸€ä¸‹ä¸ºä»€ä¹ˆè®­ç»ƒé€Ÿåº¦å¿«ã€‚é‚£ä¹ˆä¸å¾—ä¸åˆ†æžè¯¥ç½‘ç»œç»“æž„ã€‚æ•´ä¸ªç½‘ç»œçš„è¾“å…¥æ˜¯ (img1, img2, y) è¿™æ ·çš„ä¸‰å…ƒç»„ï¼Œimg è¡¨ç¤ºå›¾ç‰‡ï¼Œyè¡¨ç¤ºlabelã€‚å›¾ç‰‡å¯ä»¥æ˜¯åŒä¸€ç±»åˆ«çš„å›¾ç‰‡ï¼Œä¹Ÿå¯ä»¥æ˜¯ä¸åŒç±»åˆ«çš„ï¼Œyè¡¨ç¤ºä¸¤å¼ å›¾ç‰‡ä¹‹é—´çš„ç›¸ä¼¼ç¨‹åº¦ï¼Œyçš„å–å€¼ (0,1)ï¼Œ0è¡¨ç¤ºç›¸ä¼¼ï¼ˆåŒä¸€ç±»åˆ«ï¼‰ï¼Œ1 è¡¨ç¤ºä¸ç›¸ä¼¼ï¼ˆä¸åŒç±»åˆ«ï¼‰ã€‚å¹¶ä¸”y æ˜¯double ç±»åž‹ï¼Œå±žäºŽ0-1 åŒºé—´ä»»æ„çš„æ•°å­—ã€‚ç½‘è·¯ç»“æž„æœ€åŽçš„è¾“å‡ºæ˜¯ 0-1 åŒºé—´çš„ä»»æ„æ•°å­—ã€‚é€šå¸¸æ˜¯ä»¥0.5 ä½œä¸ºåˆ†ç•Œçº¿ï¼Œå¦‚æžœå°äºŽ0.5 é‚£ä¹ˆè®¤ä¸ºä¸¤ç§å›¾ç‰‡æ˜¯å±žäºŽåŒä¸€ç±»åˆ«ï¼Œæˆ–è€…è¯´æ›´ç›¸ä¼¼ï¼›åä¹‹ä¹Ÿæˆç«‹ã€‚é‡è¦çš„ä¸€ç‚¹æ˜¯ä¸­é—´çš„weights å®žçŽ°äº†æƒå€¼å…±äº«ï¼Œè¿™æ ·å¯ä»¥åŠ å¿«ç½‘ç»œçš„è®­ç»ƒé€Ÿåº¦ã€‚ loss functionè¿™ä¸ªæ˜¯å±žäºŽç»å…¸çš„ contrastive loss function (å¯¹æ¯”æŸå¤±å‡½æ•°)ã€‚å½“y æŽ¥è¿‘äºŽ0çš„æ—¶å€™ï¼Œå³åŠéƒ¨åˆ†æ¶ˆå¤±ï¼Œè¿™ä¸ªæ˜¯è¡¨ç¤ºä¸¤å¼ å›¾ç‰‡å¾ˆæ˜¯ç›¸ä¼¼ï¼Œç„¶åŽå°±ä¸æ–­ä½¿å¾— æ¬§æ°è·ç¦»å‡å°‘ï¼›å½“y æŽ¥è¿‘äºŽ1çš„æ—¶å€™ï¼Œå·¦åŠéƒ¨åˆ†æ¶ˆå¤±ï¼Œè¿™ä¸ªæ—¶å€™ä¸¤å¼ å›¾ç‰‡å¾ˆä¸ç›¸ä¼¼ï¼Œç„¶åŽå³è¾¹å°±æ˜¯ hinge loss ï¼ˆåˆé¡µæŸå¤±å‡½æ•°ï¼‰ã€‚å‚æ•°m ä½œä¸ºä¸€ç§margin æ˜¯æ˜¯å¯ä»¥è°ƒèŠ‚ï¼Œæˆ‘çš„å®žéªŒä¸­ m å–1.æ€»çš„æ€æƒ³ï¼šå°±æ˜¯ä½¿å¾—ç›¸è¿‘çš„å›¾åƒè·ç¦»ç›¸è¿‘ï¼Œä¸æƒ³è¿‘çš„å›¾åƒè·ç¦»å˜è¿œã€‚ $L ( W , ( Y , X _ { 1 } , X _ { 2 } ) ) = ( 1 - Y ) \frac { 1 } { 2 } ( D _ { W } ) ^ { 2 } + ( Y ) \frac { 1 } { 2 } { \max ( 0 , m - D _ { W } ) } ^ { 2 }$ Spectral Normalizationå›¾åƒè¾“å…¥åˆ°ç½‘ç»œä¹‹å‰ä½¿ç”¨æ­£åˆ™åŒ–ï¼Œç„¶åŽè¾“å…¥åˆ°æ¿€æ´»å‡½æ•°ä¹‹å‰ä¹Ÿæ˜¯ä½¿ç”¨æ­£åˆ™åŒ–ï¼Œæ‰€ä»¥è¿™ç§æ•ˆæžœä¹Ÿæ˜¯æ‰©å±•åˆ° weightsï¼Œç›´æŽ¥å¯¹ weights è¿›è¡Œæ­£åˆ™åŒ–ä½¿å…¶ç¬¦åˆ Lipschitz çº¦æŸï¼Œé¿å…ä½¿ç”¨å¤§çš„gradientsã€‚åœ¨GAN ç½‘ç»œä¸­çš„ discriminator æˆ–è€… generator éƒ½å‘çŽ°äº†å…¶å¯ä»¥ç¨³å®šè®­ç»ƒçš„è¿‡ç¨‹ã€‚åœ¨å®žéªŒä¸­ï¼Œæˆ‘ä»¬æ‰©å¤§äº†è¿™ç§ä½¿ç”¨èŒƒå›´ï¼ŒæŠŠå…¶åº”ç”¨åˆ°æ‰€æœ‰çš„ç½‘ç»œçš„ layerä¸Šã€‚ Lipschitz Continuity åœ¨ GAN ä¸­ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªåˆ¤åˆ«å™¨ $\mathrm { D } : 1 \rightarrow \mathrm { R }$ï¼Œ å…¶ä¸­ I æ˜¯å›¾åƒç©ºé—´. å¦‚æžœåˆ¤åˆ«å™¨æ˜¯ K-Lipschitz continuous çš„, é‚£ä¹ˆå¯¹å›¾åƒç©ºé—´ä¸­çš„ä»»æ„ x å’Œ yï¼Œæœ‰ $$| D ( x ) - D ( y ) | \leq K | x - y |$$ å…¶ä¸­ $ | \cdot | $ ä¸ºL2 normï¼Œå¦‚æžœK å–åˆ°æœ€å°å€¼ï¼Œé‚£ä¹ˆK è¢«ç§°ä¸º Lipschitz constantã€‚ ç›´è§‚æ¥è¯´ï¼ŒLipschitz æ¡ä»¶é™åˆ¶äº†å‡½æ•°å˜åŒ–çš„å‰§çƒˆç¨‹åº¦ï¼Œå³å‡½æ•°çš„æ¢¯åº¦ã€‚åœ¨ä¸€ç»´ç©ºé—´ä¸­ï¼Œå¾ˆå®¹æ˜“çœ‹å‡º y=sin(x) æ˜¯ 1-Lipschitz çš„ï¼Œå®ƒçš„æœ€å¤§æ–œçŽ‡æ˜¯ 1ã€‚ self-attention mechanismAttention æœºåˆ¶è‡ªä»Ž â€œAttention Is All You Needâ€ å¼€å§‹ç«çˆ†ï¼Œå¹¶ä¸”å®žéªŒçš„æ•ˆæžœä¹Ÿæ˜¯å¾ˆå¥½çš„ï¼Œç„¶åŽåœ¨å›¾åƒé¢†åŸŸä¹Ÿå¼€å§‹å°è¯•ä½¿ç”¨ attention æœºåˆ¶æ¥è§£å†³é•¿ä¾èµ–çš„é—®é¢˜ã€‚åº”ç”¨åˆ°å›¾åƒé¢†åŸŸä¸»è¦æ˜¯ explore spatial locality information, è¯´ç™½äº†å°±æ˜¯ç»†èŠ‚çš„ä¿¡æ¯ã€‚ If we look at the DCGAN model, we see that regular GANs are heavily based on convolution operations, which use a local receptive field (convolutional kernel) to learn representations. Simple features like edges and corners are learned in the first few layers. Also, ConvNets are able to use these simple representations to learn more complex ones. However, long-range dependency might be hard to learn. Long-range dependency (long-term dependency) is from RNN, which we can say anything larger than trigram as a long term dependency. Thus, most of the image content does not exhibit elaborated shape such as sky or the ocean looks fine. The task of creating geometrically complex forms, such as four-legged animals, is far more challenging. This is where attention comes into play. è€Œ self-attention ä¸­QKV ä¸‰ä¸ªéƒ¨åˆ†æ˜¯ç›¸åŒçš„ï¼Œå¯¹äºŽè¿™ç§å¤„ç†æ–¹æ³•å’ŒRes_block è¿˜æ˜¯æœ‰ç‚¹ç›¸ä¼¼çš„ã€‚ ç»“æžœè®­ç»ƒæ•°æ®é›†ä½¿ç”¨æ˜¯ Cifar-10ï¼Œè®°å½•äº†è®­ç»ƒè¿‡ç¨‹ä¸­ acc å’Œloss çš„å˜åŒ–æƒ…å†µã€‚é™¤äº†è®­ç»ƒçš„æ•ˆæžœæ¯”è¾ƒå¥½å¤–ï¼Œè®­ç»ƒé€Ÿåº¦ä¹Ÿæ˜¯éžå¸¸å¿«çš„ï¼Œå¯ä»¥æ¸…æ¥šçš„çœ‹åˆ°model acc åœ¨æŽ¥è¿‘25 epochesçš„æ—¶å€™å°±å¼€å§‹æ”¶æ•›ã€‚]]></content>
      <categories>
        <category>Deep learning</category>
      </categories>
      <tags>
        <tag>siamese network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fastText & faiss]]></title>
    <url>%2F2019%2F03%2F25%2FfastText-faiss%2F</url>
    <content type="text"><![CDATA[ä¸»è¦ä»‹ç» fastTextã€faiss ä¸¤ä¸ªå¸¸ç”¨çš„å·¥å…·ï¼Œç„¶åŽé¡ºå¸¦ä»‹ç»ä¸€ä¸‹å®¹æ˜“æ··æ·†çš„æ¦‚å¿µ k-means å’Œknnã€‚ fastTextfastTextç»“åˆäº†è‡ªç„¶è¯­è¨€å¤„ç†å’Œæœºå™¨å­¦ä¹ ä¸­æœ€æˆåŠŸçš„ç†å¿µã€‚è¿™äº›åŒ…æ‹¬äº†ä½¿ç”¨è¯è¢‹ä»¥åŠn-gramè¢‹è¡¨å¾è¯­å¥ï¼Œè¿˜æœ‰ä½¿ç”¨å­å­—(subword)ä¿¡æ¯ï¼Œæ•ˆæžœä¸Šçš„æå‡ã€‚å¦å¤–é‡‡ç”¨äº†ä¸€ä¸ªsoftmaxå±‚çº§(åˆ©ç”¨äº†ç±»åˆ«ä¸å‡è¡¡åˆ†å¸ƒçš„ä¼˜åŠ¿)æ¥åŠ é€Ÿè¿ç®—è¿‡ç¨‹ã€‚ fastText ä¸»è¦æ˜¯ç”¨æ¥è§£å†³ word representationså’Œ sentence classification. æœ‰è¶£çš„æ˜¯å‰è€…æ˜¯æ— ç›‘ç£çš„å­¦ä¹ æ–¹å¼ï¼ŒåŽè€…æ˜¯æœ‰ç›‘ç£çš„å­¦ä¹ æ–¹å¼ã€‚åˆ†åˆ«ä¸»è¦æ¥è‡ª â€Enriching Word Vectors with Subword Informationâ€œ å’Œ â€œBag of Tricks for Efficient Text Classificationâ€ ä¸¤ç¯‡è®ºæ–‡ã€‚å¹¶ä¸”ä½¿ç”¨çš„æ˜¯ shallow neural network è€Œä¸æ˜¯æ·±åº¦ç½‘ç»œã€‚ FastText is a library created by the Facebook Research Team for efficient learning of word representations and sentence classification. Take off:fastText æ–¹æ³•åŒ…å«ä¸‰éƒ¨åˆ†ï¼šæ¨¡åž‹æž¶æž„ã€å±‚æ¬¡ Softmax å’Œ N-gram ç‰¹å¾ã€‚fasttext æœ‰ä¸¤ä¸ªç”¨å¤„ï¼š text classification å’Œ word embedding ã€‚ä½¿ç”¨åœºæ™¯ï¼šå¤§åž‹æ•°æ®ï¼Œé«˜æ•ˆè®¡ç®— ä¸‹é¢è¿›è¡Œç»†è¯´ï¼š æ¨¡åž‹æž¶æž„è¿™ä¸ªæ˜¯æ€»çš„æ¡†æž¶å›¾ã€‚åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ä»‹ç»è¿™ä¸ªç½‘ç»œç»“æž„ï¼šä»Žinput -&gt; hidden:è¾“å…¥å±‚è¾“å…¥çš„æ˜¯ä¸€ä¸ªå·²ç»åˆ†è¯åŽçŸ­æ–‡æœ¬ã€‚çŸ­æ–‡æœ¬ä¸­æ¯ä¸ªè¯çš„è¯å‘é‡æ˜¯ç”±è¯¥çŸ­æ–‡æœ¬çš„one-hotçŸ©é˜µä¹˜ä»¥ä¸€ä¸ªåˆå§‹åŒ–çš„çŸ©é˜µwå¾—åˆ°çš„ã€‚ï¼ˆåŽŸç†å›¾ï¼šä¸‹å›¾æ˜¯fasttext è¿è¡Œçš„æ—¶å€™ï¼Œè¿™ä¸ªåˆ†è¯æ˜¯å†å¤„ç†æˆå•è¯å’Œn-gram ç»„æˆçš„ç‰¹å¾ï¼Œè¿™ä¸ªæ˜¯ä¸éœ€è¦æˆ‘ä»¬è¿›è¡Œæ˜¾æ€§çš„æ“ä½œçš„ï¼‰ä»Ž hidden -&gt; outputï¼šæ’æ’­ä¸€å¥ï¼Œæˆ‘ä»¬ç»å¸¸ä½¿ç”¨çš„é¢„è®­ç»ƒæ¨¡åž‹ä¸­çš„weights æ˜¯ä»Žinput-&gt; hiddenã€‚ Hierarchical SoftmaxHierarchical Softmax ä¸æ˜¯fasttext é¦–åˆ›ï¼Œå®ƒçš„æ”¹è¿›ä¹‹å¤„åœ¨äºŽå®žçŽ°ç»“æž„ä¸ŠåŸºäºŽ huffman æ ‘è€Œä¸æ˜¯æ™®é€šçš„äºŒå‰æ ‘ï¼Œå±žäºŽè¿ç®—ä¸Šçš„ä¼˜åŒ–ã€‚å…·ä½“è¯´æ¥ï¼šåˆ©ç”¨äº†ç±»åˆ«ï¼ˆclassï¼‰ä¸å‡è¡¡è¿™ä¸ªäº‹å®žï¼ˆä¸€äº›ç±»åˆ«å‡ºçŽ°æ¬¡æ•°æ¯”å…¶ä»–çš„æ›´å¤šï¼‰ï¼Œé€šè¿‡ä½¿ç”¨ Huffman ç®—æ³•å»ºç«‹ç”¨äºŽè¡¨å¾ç±»åˆ«çš„æ ‘å½¢ç»“æž„ã€‚å¯¹æ ‡ç­¾è¿›è¡Œç¼–ç ï¼Œèƒ½å¤Ÿæžå¤§åœ°ç¼©å°æ¨¡åž‹é¢„æµ‹ç›®æ ‡çš„æ•°é‡ã€‚ è¿™ä¸ªæ˜¯softmax çš„åŽŸå§‹çš„è®¡ç®—å…¬å¼ï¼š$$p \left( w _ { j } | w _ { I } \right) = y _ { j } = \frac { \exp \left( u _ { j } \right) } { \sum _ { j ^ { \prime } = 1 } ^ { V } \exp \left( u _ { j ^ { \prime } } \right) }$$ é‡‡ç”¨äºŒå‰æ ‘çš„ç»“æž„ä¹‹åŽï¼Œæ—¶é—´ä¸Šä¼˜åŒ–ä¸å°‘ã€‚$O ( N) \rightarrow O \left( \log _ { 2 } N \right)$ã€‚è§ä¸‹å›¾ã€‚ å’Œä¹‹å‰çš„ç¥žç»ç½‘ç»œæ¨¡åž‹ç›¸æ¯”ï¼Œè¿™é‡Œçš„huffmaxæ ‘çš„æ‰€æœ‰å†…éƒ¨èŠ‚ç‚¹å°±ç±»ä¼¼ä¹‹å‰ç¥žç»ç½‘ç»œéšè—å±‚çš„ç¥žç»å…ƒã€‚å…¶ä¸­ï¼Œæ ¹èŠ‚ç‚¹çš„è¯å‘é‡å¯¹åº”æˆ‘ä»¬çš„æŠ•å½±åŽçš„è¯å‘é‡ï¼Œè€Œæ‰€æœ‰çš„å¶å­èŠ‚ç‚¹å°±ç±»ä¼¼äºŽä¹‹å‰ç¥žç»ç½‘softmaxè¾“å‡ºå±‚çš„ç¥žç»å…ƒã€‚å¶å­èŠ‚ç‚¹çš„ä¸ªæ•°å°±æ˜¯è¯æ±‡è¡¨çš„å¤§å°. å’Œä¹‹å‰çš„ç›¸æ¯”ï¼Œä»Žéšè—å±‚åˆ°è¾“å‡ºå±‚çš„softmaxæ˜ å°„ä¸æ˜¯ä¸€ä¸‹å°±å®Œæˆçš„ï¼Œè€Œæ˜¯æ²¿ç€ huffmanæ ‘ä¸€æ­¥æ­¥å®Œæˆçš„ï¼Œå› æ­¤è¿™ç§ softmaxå–åä¸ºâ€Hierarchical softmaxâ€. N-gram ç‰¹å¾N-gramæ˜¯åŸºäºŽè¿™æ ·çš„æ€æƒ³ï¼šæŸä¸ªè¯çš„å‡ºçŽ°ä¾èµ–äºŽå…¶ä»–è‹¥å¹²ä¸ªè¯ï¼›æˆ‘ä»¬èŽ·å¾—çš„ä¿¡æ¯è¶Šå¤šï¼Œé¢„æµ‹è¶Šå‡†ç¡®ã€‚æˆ‘æƒ³è¯´ï¼Œæˆ‘ä»¬æ¯ä¸ªäººçš„å¤§è„‘ä¸­éƒ½æœ‰ä¸€ä¸ªN-gramæ¨¡åž‹ï¼Œè€Œä¸”æ˜¯åœ¨ä¸æ–­å®Œå–„å’Œè®­ç»ƒçš„ã€‚æˆ‘ä»¬çš„è§è¯†ä¸Žç»åŽ†ï¼Œéƒ½åœ¨ä¸°å¯Œç€æˆ‘ä»¬çš„é˜…åŽ†ï¼Œå¢žå¼ºç€æˆ‘ä»¬çš„è”æƒ³èƒ½åŠ›ã€‚ N-gram æ˜¯ä¸€ç§æ€æƒ³ï¼Œå¯ä»¥æœ‰ä¸¤ç§level çš„å®žçŽ°ï¼Œä¸€ç§æ˜¯åŸºäºŽ character-levelï¼Œä¸€ç§æ˜¯åŸºäºŽ word-levelï¼Œå‰è€…æ˜¯æ‰©å……äº†å¯¹äºŽâ€ä¸å¸¸è§â€œå•è¯ï¼ŒåŽè€…æ˜¯è€ƒè™‘äº†éƒ¨åˆ†çš„è¯çš„é¡ºåºï¼Œéƒ½æ˜¯è€ƒè™‘äº†â€å‘¨è¾¹â€œ ä¿¡æ¯,ç”¨æµè¡Œçš„è¯å°±æ˜¯ context çš„ä¿¡æ¯ã€‚æ‰€ä»¥æ¯”è¾ƒéš¾ç•Œå®š fasttext è®­ç»ƒå‡ºæ¥çš„æ˜¯ä¸æ˜¯æœ‰æ¯”è¾ƒå¼ºçš„è¯åºã€‚ N-gramæ¨¡åž‹æ˜¯ä¸€ç§è¯­è¨€æ¨¡åž‹ï¼ˆLanguage Modelï¼ŒLMï¼‰ï¼Œè¯­è¨€æ¨¡åž‹æ˜¯ä¸€ä¸ªåŸºäºŽæ¦‚çŽ‡çš„åˆ¤åˆ«æ¨¡åž‹ï¼Œå®ƒçš„è¾“å…¥æ˜¯ä¸€å¥è¯ï¼ˆå•è¯çš„é¡ºåºåºåˆ—ï¼‰ï¼Œè¾“å‡ºæ˜¯è¿™å¥è¯çš„æ¦‚çŽ‡ï¼Œå³è¿™äº›å•è¯çš„è”åˆæ¦‚çŽ‡ï¼ˆjoint probabilityï¼‰ã€‚ è¿™æ ·çš„ä½œç”¨ï¼Œä½¿ç”¨N-gramæ¥ç»™æ–‡æœ¬æ·»åŠ é¢å¤–çš„ç‰¹å¾èŽ·å¾—å…³äºŽå±€éƒ¨è¯é¡ºåºçš„éƒ¨åˆ†ä¿¡æ¯ã€‚ä¸¾ä¸ªæ —å­ï¼šå¯¹äºŽå¥å­ï¼šâ€œæˆ‘ å–œæ¬¢ å– å’–å•¡â€, å¦‚æžœä¸è€ƒè™‘é¡ºåºï¼Œé‚£ä¹ˆå°±æ˜¯æ¯ä¸ªè¯ï¼Œâ€œæˆ‘â€ï¼Œâ€œå–œæ¬¢â€ï¼Œâ€œå–â€ï¼Œâ€œå’–å•¡â€è¿™äº”ä¸ªå•è¯çš„word embeddingæ±‚å¹³å‡ã€‚å¦‚æžœè€ƒè™‘2-gram, é‚£ä¹ˆé™¤äº†ä»¥ä¸Šäº”ä¸ªè¯ï¼Œè¿˜æœ‰â€œæˆ‘å–œæ¬¢â€ï¼Œâ€œå–œæ¬¢å–â€ï¼Œâ€œå–å’–å•¡â€ç­‰è¯ã€‚â€œæˆ‘å–œæ¬¢â€ï¼Œâ€œå–œæ¬¢å–â€ï¼Œâ€œå–å’–å•¡â€è¿™ä¸‰ä¸ªè¯å°±ä½œä¸ºè¿™ä¸ªå¥å­çš„æ–‡æœ¬ç‰¹å¾ã€‚æˆ‘ä»¬ç»å¸¸è§åˆ°çš„åœºæ™¯ï¼šè¾“å…¥æ³•çš„é¢„é€‰è¯æ±‡ã€‚å°±æ˜¯å¯ä»¥é€šè¿‡è¿™ç§æ–¹å¼å®žçŽ°çš„ã€‚ å½“ç„¶ä½¿ç”¨äº†æ›´å¤šçš„ç‰¹å¾æ„å‘³ç€è®¡ç®—é‡çš„å¢žåŠ ï¼Œè®¡ç®—æ•ˆçŽ‡ä¸‹é™ï¼ŒäºŽæ˜¯è¯¥ä½œè€…æå‡ºäº†ä¸¤ç§è§£å†³æ–¹æ³•ï¼š è¿‡æ»¤æŽ‰ä½Žè¯é¢‘ ä½¿ç”¨è¯ç²’åº¦ä»£æ›¿å­—ç²’åº¦ã€‚ è¿˜æ˜¯ä½¿ç”¨ä¸Šé¢çš„å¥å­â€æˆ‘å–œæ¬¢å–å’–å•¡â€œï¼Œå¦‚æžœä½¿ç”¨å­ç²’åº¦çš„2-gramï¼Œé‚£ä¹ˆäº§ç”Ÿçš„ç‰¹å¾æ˜¯â€œæˆ‘å–œâ€ï¼Œâ€œå–œæ¬¢â€ï¼Œâ€œæ¬¢å–â€ï¼Œâ€œå–å’–â€ï¼Œâ€œå’–å•¡â€ã€‚å¦‚æžœä½¿ç”¨è¯ç²’åº¦ä¸º2-gramï¼Œé‚£ä¹ˆäº§ç”Ÿçš„ç‰¹å¾æ˜¯â€œæˆ‘å–œæ¬¢â€ï¼Œâ€œå–œæ¬¢å–â€ï¼Œâ€œå–å’–å•¡â€ã€‚ è¡¥å……ä¸€å¥ï¼Œsubwordså°±æ˜¯ä¸€ä¸ªè¯çš„character-levelçš„n-gramã€‚æ¯”å¦‚å•è¯â€helloâ€ï¼Œé•¿åº¦è‡³å°‘ä¸º3çš„char-levelçš„ngramæœ‰â€helâ€,â€ellâ€,â€lloâ€,â€hellâ€,â€elloâ€ä»¥åŠæœ¬èº«â€helloâ€ã€‚ Negative Samplingè¯¥ technique ä¸»è¦æ˜¯å‡è½»è®¡ç®—é‡çš„è§’åº¦è€ƒè™‘çš„ï¼Œæ¯æ¬¡è®©ä¸€ä¸ªè®­ç»ƒæ ·æœ¬ä»…ä»…æ›´æ–°ä¸€éƒ¨åˆ†çš„æƒé‡å‚æ•°ï¼Œè¿™ä¸ªæŠ€æœ¯ä¸æ˜¯ fastText é¦–åˆ›çš„ï¼Œä½†æ˜¯æœ¬ç€æ€»ç»“çŸ¥è¯†ç‚¹çš„ï¼Œä¹Ÿå°±æ”¾åœ¨è¿™é‡Œäº†ã€‚ CBOW / Skip-gramæ¨¡åž‹ ï¼ˆè¿™ä¸ªè®ºæ–‡ä¸­ï¼‰æå‡ºäº†ä¸¤ç§æ–¹æ³•ï¼Œä¸€ç§æ˜¯Hierarchical Softmaxï¼Œå¦ä¸€ç§æ˜¯Negative Samplingã€‚è®ºæ–‡ä¸­æå‡ºçš„ä¸¤ç§æ–¹æ³•éƒ½æ˜¯ç”¨æ¥æé«˜è®¡ç®—æ•ˆçŽ‡çš„ï¼Œä¸‹é¢è¯´ä¸€ä¸‹è´Ÿé‡‡æ ·ã€‚ åœ¨è®­ç»ƒç¥žç»ç½‘ç»œæ—¶ï¼Œæ¯å½“æŽ¥å—ä¸€ä¸ªè®­ç»ƒæ ·æœ¬ï¼Œç„¶åŽè°ƒæ•´æ‰€æœ‰ç¥žç»å•å…ƒæƒé‡å‚æ•°ï¼Œæ¥ä½¿ç¥žç»ç½‘ç»œé¢„æµ‹æ›´åŠ å‡†ç¡®ã€‚æ¢å¥è¯è¯´ï¼Œæ¯ä¸ªè®­ç»ƒæ ·æœ¬éƒ½å°†ä¼šè°ƒæ•´æ‰€æœ‰ç¥žç»ç½‘ç»œä¸­çš„å‚æ•°ã€‚è€Œ Negative Sampling æ¯æ¬¡è®©ä¸€ä¸ªè®­ç»ƒæ ·æœ¬ä»…ä»…æ›´æ–°ä¸€å°éƒ¨åˆ†çš„æƒé‡å‚æ•°ï¼Œä»Žè€Œé™ä½Žæ¢¯åº¦ä¸‹é™è¿‡ç¨‹ä¸­çš„è®¡ç®—é‡ã€‚å¦‚æžœ vocabulary å¤§å°ä¸º1ä¸‡æ—¶ï¼Œ å½“è¾“å…¥æ ·æœ¬ ( â€œfoxâ€, â€œquickâ€) åˆ°ç¥žç»ç½‘ç»œæ—¶ï¼Œ â€œ foxâ€ ç»è¿‡ one-hot ç¼–ç ï¼Œåœ¨è¾“å‡ºå±‚æˆ‘ä»¬æœŸæœ›å¯¹åº” â€œquickâ€ å•è¯çš„é‚£ä¸ªç¥žç»å…ƒç»“ç‚¹è¾“å‡º 1ï¼Œå…¶ä½™ 9999 ä¸ªéƒ½åº”è¯¥è¾“å‡º0ã€‚åœ¨è¿™é‡Œï¼Œè¿™9999ä¸ªæˆ‘ä»¬æœŸæœ›è¾“å‡ºä¸º0çš„ç¥žç»å…ƒç»“ç‚¹æ‰€å¯¹åº”çš„å•è¯æˆ‘ä»¬ç§°ä¸º negative wordï¼Œéšæœºé€‰æ‹©ä¸€å°éƒ¨åˆ†çš„ negative wordsï¼Œæ¯”å¦‚é€‰ 10ä¸ª negative words æ¥æ›´æ–°å¯¹åº”çš„æƒé‡å‚æ•°ã€‚ è§£å†³çš„é—®é¢˜ï¼Œåœ¨æœ€åŽä¸€å±‚ softmax çš„è®¡ç®—é‡å¤ªå¤§ï¼Œç›¸å½“äºŽæ¯ä¸€æ¬¡word éƒ½æ˜¯éœ€è¦æ•´ä¸ªdict é‡çš„çº§åˆ«çš„æ›´æ–°ã€‚ç„¶åŽé€‰æ‹© k ä¸ªnegative wordsï¼Œåªæ˜¯è®¡ç®—è¿™äº›softmax çš„å€¼ã€‚ Training a neural network means taking a training example and adjusting all of the neuron weights slightly so that it predicts that training sample more accurately. In other words, each training sample will tweak all of the weights in the neural network.As we discussed above, the size of our word vocabulary means that our skip-gram neural network has a tremendous number of weights, all of which would be updated slightly by every one of our billions of training samples!Negative sampling addresses this by having each training sample only modify a small percentage of the weights, rather than all of them. Hereâ€™s how it works.When training the network on the word pair (â€œfoxâ€, â€œquickâ€), recall that the â€œlabelâ€ or â€œcorrect outputâ€ of the network is a one-hot vector. That is, for the output neuron corresponding to â€œquickâ€ to output a 1, and for all of the other thousands of output neurons to output a 0.With negative sampling, we are instead going to randomly select just a small number of â€œnegativeâ€ words (letâ€™s say 5) to update the weights for. (In this context, a â€œnegativeâ€ word is one for which we want the network to output a 0 for). We will also still update the weights for our â€œpositiveâ€ word (which is the word â€œquickâ€ in our current example).The paper says that selecting 5-20 words works well for smaller datasets, and you can get away with only 2-5 words for large datasets.Recall that the output layer of our model has a weight matrix thatâ€™s 300 x 10,000. So we will just be updating the weights for our positive word (â€œquickâ€), plus the weights for 5 other words that we want to output 0. Thatâ€™s a total of 6 output neurons, and 1,800 weight values total. Thatâ€™s only 0.06% of the 3M weights in the output layer!In the hidden layer, only the weights for the input word are updated (this is true whether youâ€™re using Negative Sampling or not). å¯¹åº”çš„å‚æ•° 123-wordNgrams æœ€å¤§ngram 1-minn å­—ç¬¦ngramæœ€å°é•¿åº¦ 0-maxn å­—ç¬¦ngramæœ€å¤§é•¿åº¦ 0 å…¶ä¸­ wordNgrams æ˜¯å¯¹åº”è¯­åºï¼Œå­—ç¬¦minn å’Œmaxn æ˜¯è§£å†³oov é—®é¢˜ã€‚ åªç”¨unigramçš„è¯ä¼šä¸¢æŽ‰word orderä¿¡æ¯ï¼Œæ‰€ä»¥é€šè¿‡åŠ å…¥N-gram featuresè¿›è¡Œè¡¥å…… ç”¨hashingæ¥å‡å°‘N-gramçš„å­˜å‚¨ç”±äºŽn-gramçš„é‡è¿œæ¯”wordå¤§çš„å¤šï¼Œå®Œå…¨å­˜ä¸‹æ‰€æœ‰çš„n-gramä¹Ÿä¸çŽ°å®žã€‚Fasttexté‡‡ç”¨äº†Hashæ¡¶çš„æ–¹å¼ï¼ŒæŠŠæ‰€æœ‰çš„n-graméƒ½å“ˆå¸Œåˆ°bucketsä¸ªæ¡¶ä¸­ï¼Œå“ˆå¸Œåˆ°åŒä¸€ä¸ªæ¡¶çš„æ‰€æœ‰n-gramå…±äº«ä¸€ä¸ªembedding vectorã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š Positive samples and Negative samplesOne little detail thatâ€™s missing from the description above is how do we select the negative samples.ï¼ˆä¸‹é¢è¯´çš„æ˜¯å¦‚ä½•è¿›è¡Œé€‰æ‹©negative sampleçš„é—®é¢˜ï¼šåŸºæœ¬æ€è·¯æ˜¯æ ¹æ®å‡ºçŽ°é¢‘çŽ‡è¿›è¡Œé€‰æ‹©ï¼‰The negative samples are chosen using the unigram distribution. Essentially, the probability of selecting a word as a negative sample is related to its frequency, with more frequent words being more likely to be selected as negative samples. Instead of using the raw frequency in the original word2vec paper, each word is given a weight thatâ€™s equal to itâ€™s frequency (word count) raised to the 3/4 power. The probability for selecting a word is just itâ€™s weight divided by the sum of weights for all words.$$P \left( w _ { i } \right) = \frac { f \left( w _ { i } \right) ^ { 3 / 4 } } { \sum _ { i = 0 } ^ { n } \left( f \left( w _ { j } \right) ^ { 3 / 4 } \right) }$$ ä¸Šè¿°ä¸­çš„å‡½æ•°æ˜¯å¹‚å‡½æ•°ï¼Œå›¾åƒçš„å½¢çŠ¶å’Œlog å‡½æ•°å·®ä¸å¤šï¼Œéƒ½æ˜¯ä»Ž $y =x$ è¿›è¡Œäº†ä¸€ä¸‹çº¦æŸï¼Œå‡½æ•°å˜å¾—æ›´åŠ çš„å¹³ç¼“ã€‚å¯¹äºŽé«˜é¢‘è¯è¿›è¡Œäº†çº¦æŸï¼Œå¯¹äºŽä½Žé¢‘æ¬¡ä¹Ÿæœ‰æœºä¼šå‡ºçŽ°ã€‚ This decision to raise the frequency to the 3/4 power appears to be empirical; as the author claims it outperformed other functions (e.g. just using unigram distribution).Side note: The way this selection is implemented in the original word2vec C code is interesting. They have a large array with 100M elements (which they refer to as the unigram table). They fill this table with the index of each word in the vocabulary multiple times, and the number of times a wordâ€™s index appears in the table is given by Then, to actually select a negative sample, we just generate a random integer between 0 and 100M, and use the word at that index in the table. Since the higher probability words occur more times in the table, weâ€™re more likely to pick those. è¿™ä¸ªä¹Ÿæ˜¯æœ‰è®² ä»»ä½•è¿›è¡Œnegative sampleçš„é€‰æ‹©http://jalammar.github.io/illustrated-word2vec/ä¸€èˆ¬æ¥è¯´åœ¨ word2vec ä¸­context æ˜¯ä¼šé€‰æ‹©åˆ° 5ï¼Œç„¶åŽè¿™ä¸ª positive / negative sample ä¼šæ˜¯(1/6), ç„¶åŽ nagative sample æ˜¯éšæœºåœ¨ dictionaryé‡Œé¢é€‰çš„ï¼ˆæ‰€ä»¥æœ‰å¯èƒ½é€‰åˆ° positive sampleï¼‰ï¼Œ è¿™ä¸ªæ˜¯è¿™ä¸ªdictionary æ˜¯æ ¹æ®é¢‘çŽ‡ï¼Œå‡ºçŽ°æ¬¡æ•°è¶Šå¤šçš„ï¼Œè¢«é€‰ä¸­çš„å¯èƒ½æ€§ä¹Ÿè¶Šå¤§ã€‚The number of negative samples is another factor of the training process. The original paper prescribes 5-20 as being a good number of negative samples. It also states that 2-5 seems to be enough when you have a large enough dataset. The Gensim default is 5 negative samples. To address this, we need to introduce negative samples to our dataset â€“ samples of words that are not neighbors. Our model needs to return 0 for those samples. Now thatâ€™s a challenge that the model has to work hard to solve â€“ but still at blazing fast speed.This idea is inspired by Noise-contrastive estimation. We are contrasting the actual signal (positive examples of neighboring words) with noise (randomly selected words that are not neighbors). This leads to a great tradeoff of computational and statistical efficiency. Essentially, the probability for selecting a word as a negative sample is related to its frequency, with more frequent words being more likely to be selected as negative samples. They fill this table with the index of each word in the vocabulary multiple times, and the number of times a wordâ€™s index appears in the table is given by $P(wi)*P(wi)$ table_size. Then, to actually select a negative sample, you just generate a random integer between 0 and 100M, and use the word at that index in the table. Since the higher probability words occur more times in the table, youâ€™re more likely to pick those. (ps è¿™ç§æ•°é‡æ¯”ä¸æ˜¯ 1ï¼š1ï¼Œå¸¸å¸¸æ˜¯ positive ï¼š negative =1ï¼š5ï¼Œ è¿™ä¸ªæ˜¯ç»éªŒå€¼ï¼Œåœ¨ä¼ ç»Ÿæœºå™¨å­¦ä¹ ä¸­å¯èƒ½è®¤ä¸ºæ˜¯ data unbalanced)Itâ€™s now time to build out our skip-gram generator which will give us pair of words and their relevance (word, word in the same window), with label 1 (positive samples). (word, random word from the vocabulary), with label 0 (negative samples). ä½¿ç”¨ç¬¬ä¸€ä¸ªåº”ç”¨åœºæ™¯ï¼šè¯å‘é‡ã€‚fastTextä½œä¸ºè®­ç»ƒè¯å‘é‡è®¤ä¸ºå¯ä»¥æœ‰ä¸¤ç§æ¨¡å¼ï¼Œä¸€ç§æ˜¯æ ¹æ®å‘¨å›´è¯è¯­é¢„æµ‹ä¸­å¿ƒè¯æ±‡çš„CBOW ï¼ˆcontinuous bag-of-wordsï¼‰æ¨¡åž‹ï¼Œå¦ä¸€ç§æ˜¯æ ¹æ®ä¸­å¿ƒè¯æ±‡é¢„æµ‹ä¸Šä¸‹æ–‡çš„ skip-gram æ¨¡åž‹ã€‚ ./fasttext â€“ It is used to invoke the FastText library. skipgram/cbow â€“ It is where you specify whether skipgram or cbow is to be used to create the word representations. -input â€“ This is the name of the parameter which specifies the following word to be used as the name of the file used for training. This argument should be used as is. data.txt â€“ a sample text file over which we wish to train the skipgram or cbow model. Change this name to the name of the text file you have. -output â€“ This is the name of the parameter which specifies the following word to be used as the name of the model being created. This argument is to be used as is. model â€“ This is the name of the model created.Running the above command will create two files named model.bin and model.vec. model.bin contains the model parameters, dictionary and the hyperparameters and can be used to compute word vectors. model.vec is a text file that contains the word vectors for one word per line. æœ€åŽç”Ÿæˆæœ‰ä¸¤ä¸ªæ–‡ä»¶ï¼Œä¸€ä¸ª xxx.bin æ–‡ä»¶ï¼Œä¸€ä¸ªæ˜¯ xxx.vec æ–‡ä»¶ï¼Œå‰è€…æ˜¯é¢„è®­ç»ƒæ¨¡åž‹ï¼ŒåŽè€…æ˜¯è¯å‘é‡ã€‚è¿™ä¸¤ä¸ªå¯èƒ½æ˜¯æœ€é‡è¦çš„æ ¼å¼äº†ã€‚ The most important parameters of the model are its dimension and the range of size for the subwords. å¸¸è§çš„ä»£ç æ ¼å¼ï¼š ./fasttext skipgram -input data/fil9 -output result/fil9 -minn 2 -maxn 5 -dim 300 è·‘åä¸€ä¸‹è¯´ä¸€ä¸‹shellçš„å°æŠ€å·§ã€‚ä½¿ç”¨echo æˆ–è€… &lt; è¿™æ ·è¿›è¡Œå•ä¸ªè¯æˆ–è€…å¤šä¸ªè¯çš„è¯å‘é‡çš„æŸ¥è¯¢ã€‚ ./fasttext print-word-vectors model.bin &lt; queries.txtecho â€œwordâ€ | ./fasttext print-word-vectors model.bin Finding simialr words: ./fasttext nn model.bin æœ€é‡è¦çš„å‡ ä¸ªå‚æ•°ï¼š The most important parameters of the model are its dimension and the range of size for the subwords. The dimension (dim) controls the size of the vectors, the larger they are the more information they can capture but requires more data to be learned. But, if they are too large, they are harder and slower to train. By default, we use 100 dimensions, but any value in the 100-300 range is as popular. The subwords are all the substrings contained in a word between the minimum size (minn) and the maximal size (maxn). By default, we take all the subword between 3 and 6 characters, but other range could be more appropriate to different languages: 1$ ./fasttext skipgram -input data/fil9 -output result/fil9 -minn 2 -maxn 5 -dim 300 The following arguments for the dictionary are optional: -minCount è¯å‡ºçŽ°çš„æœ€å°‘æ¬¡æ•° [5] -minCountLabel æ ‡ç­¾å‡ºçŽ°çš„æœ€å°‘æ¬¡æ•° [0] -wordNgrams å•è¯ ngram çš„æœ€å¤§é•¿åº¦ [1] -bucket æ¡¶çš„ä¸ªæ•° [2000000] -minn char ngram çš„æœ€å°é•¿åº¦ [3] -maxn char ngram çš„æœ€å¤§é•¿åº¦ [6] The following arguments for training are optional -dim å­—å‘é‡çš„å¤§å° [100] -ws ä¸Šä¸‹æ–‡çª—å£çš„å¤§å° [5] -epoch è¿­ä»£æ¬¡æ•° [5] -neg è´Ÿæ ·æœ¬ä¸ªæ•° [5] -loss æŸå¤±å‡½æ•° {ns, hs, softmax} [ns] ç¬¬äºŒä¸ªåº”ç”¨åœºæ™¯ï¼šæ–‡æœ¬åˆ†ç±»ã€‚ Sentiment analysis and email classification are classic examples of text classification ï¼ˆBERT ä¹Ÿæ˜¯é‡‡ç”¨çš„è¿™ç§label çš„æ ¼å¼ï¼‰åœ¨è®­ç»ƒæ•°æ®é›†ä¸­label é»˜è®¤æ˜¯ä½¿ç”¨ â€œ__label__â€ è¿›è¡Œè¡¨ç¤ºçš„ï¼Œå½“ç„¶ä¹Ÿæ˜¯å¯ä»¥è¿›è¡Œè‡ªå®šä¹‰çš„ã€‚ ./fasttext supervised -input train.ft.txt -output model_kaggle -label __label__ -lr 0.5 å°±æ˜¯è¿›è¡Œpredictçš„æ—¶å€™ï¼Œæœ‰æ—¶å€™å¹¶ä¸æ˜¯å¾ˆèƒ½æƒ³èµ·æ¥åªæ˜¯predict top 3 è¿™æ ·çš„ä¸œè¥¿ã€‚ # Predicting on the test dataset ./fasttext predict model_kaggle.bin test.ft.txt # Predicting the top 3 labels ./fasttext predict model_kaggle.bin test.ft.txt 3 fasttext VS. CBOWåœ¨æ ‡å‡†çš„å¤šæ ¸CPUä¸Šï¼Œ èƒ½å¤Ÿè®­ç»ƒ10äº¿è¯çº§åˆ«è¯­æ–™åº“çš„è¯å‘é‡åœ¨10åˆ†é’Ÿä¹‹å†…ï¼Œèƒ½å¤Ÿåˆ†ç±»æœ‰ç€30ä¸‡å¤šç±»åˆ«çš„50å¤šä¸‡å¥å­åœ¨1åˆ†é’Ÿä¹‹å†…ã€‚ n-gram n-gram æ˜¯ä¸€ç§åŸºäºŽè¯­è¨€æ¨¡åž‹çš„ç®—æ³•ï¼ŒåŸºæœ¬æ€æƒ³æ˜¯å°†æ–‡æœ¬å†…å®¹æŒ‰ç…§å­—èŠ‚é¡ºåºè¿›è¡Œå¤§å°ä¸ºNçš„æ»‘åŠ¨çª—å£æ“ä½œï¼Œæœ€ç»ˆå½¢æˆé•¿åº¦ä¸ºNçš„å­—èŠ‚ç‰‡æ®µåºåˆ—ã€‚ CBOW æ˜¯å’Œè¯åºæ— å…³çš„ï¼Œå®žçŽ° n-gram ä½œä¸ºé¢å¤–çš„ç‰¹å¾å¯ä»¥æ•æ‰ä¸€äº›éƒ¨åˆ†çš„è¯åºã€‚fastTextæ˜¯ä¸€ç§åŸºäºŽskip-gramæ¨¡åž‹çš„æ–°æ‰©å±•ï¼Œå®ƒä¼šä½¿ç”¨subwordçš„ä¿¡æ¯ï¼Œå°†æ¯ä¸ªè¯è¢«è¡¨ç¤ºæˆä¸€ä¸ªå­—ç¬¦çº§n-gramè¯è¢‹(a bag of character n-grams)ã€‚æ¯ä¸ªå‘é‡è¡¨ç¤ºä¸Žæ¯ä¸ªå­—ç¬¦çº§n-gramç›¸å…³è”ï¼Œè€Œè¯(word)åˆ™å¯ä»¥çœ‹æˆæ˜¯è¿™äº›n-gramå‘é‡è¡¨ç¤ºçš„æ±‚å’Œ(sum)ã€‚fastTextåœ¨å¤§è¯­æ–™ä¸Šè®­ç»ƒå¾ˆå¿«ã€‚ ç½‘ç»œç»“æž„æ–¹é¢ è¾“å…¥å±‚ï¼šCBOW çš„è¾“å…¥å±‚æ˜¯ç”±ç›®æ ‡è¯æ±‡ $y$ çš„ä¸Šä¸‹æ–‡å•è¯ ${ x _ { 1 } , \ldots , x _ { c } }$ ç»„æˆï¼Œ $\boldsymbol { x } _ { i }$ æ˜¯è¢« onehot ç¼–ç è¿‡çš„ V ç»´å‘é‡ï¼Œå…¶ä¸­ V æ˜¯è¯æ±‡é‡ã€‚è€Œfasttext çš„è¾“å…¥æ˜¯å¤šä¸ªå•è¯åŠå…¶n-gramç‰¹å¾ã€‚æ¯”å¦‚è¯´ï¼Œå¯¹äºŽå•è¯â€œappleâ€ï¼Œå‡è®¾nçš„å–å€¼ä¸º3ï¼Œåˆ™å®ƒçš„trigramæœ‰: â€œ&lt;apâ€, â€œappâ€, â€œpplâ€, â€œpleâ€, â€œle&gt;â€å…¶ä¸­ï¼Œ&lt;è¡¨ç¤ºå‰ç¼€ï¼Œ&gt;è¡¨ç¤ºåŽç¼€ã€‚äºŽæ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨è¿™äº›trigramæ¥è¡¨ç¤ºâ€œappleâ€è¿™ä¸ªå•è¯ï¼Œè¿›ä¸€æ­¥ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨è¿™5ä¸ªtrigramçš„å‘é‡å åŠ æ¥è¡¨ç¤ºâ€œappleâ€çš„è¯å‘é‡ã€‚è¿™æ ·åšæœ‰ä¸¤ç‚¹å¥½å¤„ï¼š å¯¹äºŽä½Žé¢‘è¯ç”Ÿæˆçš„è¯å‘é‡æ•ˆæžœä¼šæ›´å¥½ã€‚å› ä¸ºå®ƒä»¬çš„n-gramå¯ä»¥å’Œå…¶å®ƒè¯å…±äº«ã€‚ å¯¹äºŽè®­ç»ƒè¯åº“ä¹‹å¤–çš„å•è¯ï¼Œä»ç„¶å¯ä»¥æž„å»ºå®ƒä»¬çš„è¯å‘é‡ã€‚æˆ‘ä»¬å¯ä»¥å åŠ å®ƒä»¬çš„å­—ç¬¦çº§n-gramå‘é‡ã€‚ ä»Žè¾“å…¥å±‚åˆ°éšè—å±‚ï¼ŒCBOWä¼šå°†ä¸Šä¸‹æ–‡å•è¯å‘é‡å åŠ èµ·æ¥å¹¶ç»è¿‡ä¸€æ¬¡çŸ©é˜µä¹˜æ³•ï¼ˆçº¿æ€§å˜åŒ–ï¼‰å¹¶åº”ç”¨æ¿€æ´»å‡½æ•°ï¼Œè€ŒfastTextçœç•¥äº†è¿™ä¸€è¿‡ç¨‹ï¼Œç›´æŽ¥å°†embeddingè¿‡çš„å‘é‡ç‰¹å¾æ±‚å’Œå–å¹³å‡ï¼› è¾“å‡ºå±‚ï¼Œä¸€èˆ¬çš„CBOWæ¨¡åž‹ä¼šé‡‡ç”¨Softmaxä½œä¸ºè¾“å‡ºï¼Œè€ŒfastTextåˆ™é‡‡ç”¨äº†Hierarchical Softmaxï¼Œå¤§å¤§é™ä½Žäº†æ¨¡åž‹è®­ç»ƒæ—¶é—´ï¼›CBOW çš„è¾“å‡ºå±‚æ˜¯è¢«onehotç¼–ç è¿‡çš„ç›®æ ‡è¯y CBOWçš„è¾“å‡ºæ˜¯ç›®æ ‡è¯æ±‡ï¼ŒfastTextçš„è¾“å‡ºæ˜¯æ–‡æ¡£å¯¹åº”çš„ç±»æ ‡ã€‚ ä½¿ç”¨ fasttext è¿›è¡Œæ–‡æœ¬åˆ†ç±»çš„æ—¶å€™ï¼Œå…¶æ ¸å¿ƒæ€æƒ³æ˜¯ å°†æ•´ç¯‡æ–‡æ¡£çš„è¯åŠn-gramå‘é‡å åŠ å¹³å‡å¾—åˆ°æ–‡æ¡£å‘é‡ï¼Œç„¶åŽä½¿ç”¨æ–‡æ¡£å‘é‡åšsoftmaxå¤šåˆ†ç±»ã€‚ å±‚æ¬¡softmax softmax æ˜¯åœ¨ é€»è¾‘å›žå½’ ï¼ˆlogistic regressionï¼‰ åœ¨å¤šåˆ†ç±»ä»»åŠ¡ä¸Šçš„æŽ¨å¹¿ï¼Œæ˜¯ç½‘ç»œä¸­çš„æœ€åŽä¸€å±‚ã€‚å½“ è¯æ±‡æ•°é‡V è¾ƒå¤§æ—¶å€™ï¼Œsoftmax çš„è®¡ç®—ä»£ä»·æ˜¯å¾ˆå¤§çš„ï¼Œ O(v) é‡çº§ã€‚å±‚æ¬¡softmax æ˜¯å°†å…¨å±€å¤šåˆ†ç±»è½¬åŒ–æˆäº†è‹¥å¹²ä¸ªäºŒåˆ†ç±»é—®é¢˜ï¼Œä»Žè€Œå°†æ—¶é—´å¤æ‚åº¦ä»ŽO(V) è½¬åŒ–æˆäº† O(log V)ã€‚ ç¼ºç‚¹ï¼šfastTexté€‚ç”¨ä¸Žåˆ†ç±»ç±»åˆ«éžå¸¸å¤§è€Œä¸”æ•°æ®é›†è¶³å¤Ÿå¤šçš„æƒ…å†µï¼Œå½“åˆ†ç±»ç±»åˆ«æ¯”è¾ƒå°æˆ–è€…æ•°æ®é›†æ¯”è¾ƒå°‘çš„è¯ï¼Œå¾ˆå®¹æ˜“è¿‡æ‹Ÿåˆã€‚ faissç”¨é€”ï¼šç›¸ä¼¼åº¦æ£€æµ‹å’Œç¨ å¯†å‘é‡çš„èšç±»ã€‚ Faiss is a library for efficient similarity search and clustering of dense vectors. ä¹‹å‰çš„å®žä¹ ç»åŽ†ä¸»è¦æ˜¯ç”¨faiss å¤„ç†æ–‡æœ¬çš„representationï¼Œä½†æ˜¯è¿™ä¸ªæ˜¯æœ‰åå·®çš„ï¼Œå‡¡æ˜¯èƒ½å¤Ÿæ‰“æˆè¯å‘é‡ï¼Œéƒ½æ˜¯å¯ä»¥ä½¿ç”¨faiss è¿›è¡Œè®¡ç®—çš„ï¼Œå½“ç„¶è¿™è¯å‘é‡éœ€è¦æ»¡è¶³ï¼šç›¸è¿‘å†…å®¹åœ¨ç›¸è¿‘çš„ç©ºé—´ã€‚ Once the vectors are extracted by learning machinery (from images, videos, text documents, and elsewhere), theyâ€™re ready to feed into the similarity search library. faissçš„å®žçŽ°è¿‡ç¨‹é¦–å…ˆä½¿ç”¨ indexå¯¹äºŽå‘é‡è¿›è¡Œé¢„å¤„ç†ï¼Œç„¶åŽé€‰æ‹©ä¸åŒçš„æ¨¡å¼. ä¸»è¦è®²çš„æ˜¯ä¸‰ç§æ¨¡å¼ï¼Œä¸€ä¸ªç»´åº¦æ˜¯ç®€å•æ¨¡å¼ï¼Œé€‚åˆåœ¨å°æ•°æ®ä¸Šè¿›è¡Œè®¡ç®— æ¬§æ°è·ç¦»ï¼›ä¸€ä¸ªç»´åº¦æ˜¯åŠ å¿«æ£€ç´¢é€Ÿåº¦ï¼Œè¿™ç§æ¨¡å¼ä¸‹æ˜¯éœ€è¦æå‰çš„trainï¼Œå…¶åŸºæœ¬çš„æ€è·¯å¯¹å‘é‡è¿›è¡Œèšç±»ï¼Œå½“ç„¶æ–‡ä¸­è¯´çš„æ˜¯ â€œç»†èƒžâ€ï¼Œå»ºç«‹å€’æŽ’ç´¢å¼•ï¼Œç„¶åŽæ£€ç´¢çš„æ—¶å€™ï¼Œæœç´¢è¿™ä¸ªâ€œç»†èƒžâ€å†… å’Œå‘¨å›´çš„â€œç»†èƒžâ€ çš„id çš„é›†åˆï¼Œå°±å¯ä»¥è¿”å›žå‰ K ä¸ªæœ€ç›¸è¿‘çš„ç»“æžœï¼›æœ€åŽä¸€ä¸ªç»´åº¦æ˜¯å‡å°‘å†…å­˜çš„ä½¿ç”¨ï¼Œä¸Šé¢ä¸¤ç§éƒ½æ˜¯ä½¿ç”¨çš„å®Œæ•´çš„å‘é‡ï¼Œè¿™ä¸ªæ¨¡å¼ä¸‹æ˜¯ä½¿ç”¨çš„åŽ‹ç¼©å‘é‡ï¼Œå¯ä»¥ä½¿ç”¨PCA è¿›è¡Œå®žçŽ°ï¼Œå½“ç„¶è¿™ä¸ªæ¨¡å¼ä¸‹å¾—åˆ°çš„ç»“æžœä¹Ÿæ˜¯è¿‘ä¼¼è§£ã€‚è¿˜æœ‰ä¸¤ç§è®¡ç®—çš„ä¸Šçš„ä¼˜åŒ–ï¼Œå¯¹äºŽå‘é‡è¿›è¡Œåˆ†æ®µè®¡ç®—ï¼Œè¿™ç§å¯ä»¥å®žçŽ°å¹¶è¡Œï¼Œå¹¶ä¸”æ”¯æŒä»»åŠ¡åœ¨GPU ä¸Šè¿›è¡Œè¿ç®—ã€‚ ç‰ºç‰²äº†ä¸€äº›ç²¾ç¡®æ€§æ¥ä½¿å¾—è¿è¡Œé€Ÿåº¦æ›´å¿«ã€‚ Similarity search can be made orders of magnitude faster if weâ€™re willing to trade some accuracy; that is, deviate a bit from the reference result. For example, it may not matter much if the first and second results of an image similarity search are swapped, since theyâ€™re probably both correct results for a given query. Accelerating the search involves some pre-processing of the data set, an operation that we call indexing. ( ä¸‹é¢è¿™å¥è¯çš„è§‚ç‚¹æ˜¯ä»€ä¹ˆï¼Œæ„Ÿè§‰ä¸çŸ¥é“é€»è¾‘åœ¨å“ªé‡Œå•Š)å‘é‡çš„æ¯”è¾ƒæœ‰ä¸¤ç§metricï¼šä¸€ç§æ˜¯L2 ä¸€ç§æ˜¯åŸºäºŽconsine (ç‚¹ä¹˜)è¿›è¡Œæ£€ç´¢ã€‚å‰è€…æ˜¯æ±‚è§£æœ€å°çš„å€¼ï¼ŒåŽè€…æ˜¯é€šè¿‡innerâ€”â€”product æ±‚è§£maximum. å¹¶ä¸”æ˜¯æ”¯æŒGPUçš„ï¼Œåœ¨åŽŸæ¥CPUä¸Šå»ºç«‹çš„indexï¼Œç„¶åŽå¾ˆå¥½çš„è¿ç§»åˆ° GPUä¸Šã€‚ faiss ä¸­çš„ä¸‰ç§åŸºæœ¬ç´¢å¼• IndexFlatL2 åŸºäºŽbrute-forceè®¡ç®—å‘é‡çš„L2è·ç¦»ï¼Œå°±æ˜¯æš´æœã€‚æ£€ç´¢é€Ÿåº¦æ…¢ï¼Œé€‚ç”¨äºŽå°æ•°æ®é‡ã€‚ åœ¨è®¡ç®—ä¸Šè¿›è¡Œäº†ä¼˜åŒ–ï¼Œæ¯”å¦‚ä½¿ç”¨å †å­˜å‚¨ç»“æž„ï¼Œå¯»æ‰¾æœ€æŽ¥è¿‘çš„ K ä¸ªå…ƒç´ æ—¶å€™åŽï¼Œè¿›è¡Œåˆ†æ®µè®¡ç®—ï¼ŒæŠŠ d ç»´å‘é‡åˆ†æˆå‡ æ®µåˆ†åˆ«è¿›è¡Œè®¡ç®—ï¼›å»ºç«‹å€’æŽ’ç´¢å¼•( id -contents) ï¼Œå…ˆä½¿ç”¨èšç±»ï¼Œç„¶åŽå†ç±»å†…å’Œç›¸è¿‘çš„ç±»è¿›è¡Œå¯»æ‰¾è€Œéžæ•´ä¸ªç©ºé—´ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940import numpy as npd = 64 # ç»´åº¦nb = 100000 # æ•°æ®åº“å¤§å°nq = 10000 # è¦æœç´¢çš„querynp.random.seed(1234) # ç¡®å®šç§å­ï¼Œä½¿éšæœºæ•°å¯é‡çŽ°xb = np.random.random((nb, d)).astype('float32')xb[:, 0] += np.arange(nb) / 1000. # æ¯ä¸€è¡Œçš„ç¬¬ä¸€ä¸ªåˆ—å¢žåŠ ä¸€ä¸ªç­‰å·®æ•°åˆ—çš„å¯¹åº”é¡¹æ•°xq = np.random.random((nq, d)).astype('float32')xq[:, 0] += np.arange(nq) / 1000.print(xq.shape) # (10000, 64)print(xb.shape) # (100000, 64)import faiss # make faiss availableindex = faiss.IndexFlatL2(d) # æž„å»ºFlatL2ç´¢å¼•print(index.is_trained)print(index.ntotal)index.add(xb) # å‘ç´¢å¼•ä¸­æ·»åŠ å‘é‡ã€‚addæ“ä½œå¦‚æžœæ²¡æœ‰æä¾›idï¼Œåˆ™ä½¿ç”¨å‘é‡åºå·ä½œä¸ºidã€‚print(index.ntotal)k = 4 # æœç´¢å¤šå°‘ä¸ªä¸´è¿‘å‘é‡D, I = index.search(xb[:5], k) # ç”¨xbçš„å‰äº”è¡Œæœ¬èº«è‡ªå·±æœç´¢è‡ªå·±ï¼Œå®Œæ•´æ€§æ£€æŸ¥ï¼Œç”¨äºŽæµ‹è¯•print("I=")print(I)#I=#[[ 0 393 363 78 924]# [ 1 555 277 364 617]# [ 2 304 101 13 801]# [ 3 173 18 182 484]# [ 4 288 370 531 178]]# Iè¾“å‡ºç±»ä¼¼äºŽä¸Šé¢ï¼Œæ¯è¡Œå¯¹åº”ç€ç›¸åº”å‘é‡çš„æœç´¢ç»“æžœã€‚kä¸ºå¤šå°‘å°±æœ‰å¤šå°‘åˆ—ï¼Œdistanceä½Žçš„æŽ’åœ¨å‰é¢ã€‚# å¯ä»¥çœ‹åˆ°å‰äº”è¡Œçš„ç¬¬ä¸€åˆ—ç¡®å®žæ˜¯0~4print("D=")print(D)#[[0. 7.1751733 7.207629 7.2511625]# [0. 6.3235645 6.684581 6.7999454]# [0. 5.7964087 6.391736 7.2815123]# [0. 7.2779055 7.5279865 7.6628466]# [0. 6.7638035 7.2951202 7.3688145]]# å¯ä»¥çœ‹åˆ°ç¬¬ä¸€è¡Œç¬¬ä¸€åˆ—éƒ½æ˜¯0ï¼Œæ„æ€æ˜¯å‘é‡ä¸Žè‡ªå·±æœ¬èº«çš„è·ç¦»ä¸º0D, I = index.search(xq, k) # æœç´¢print(I[:5]) # æœ€åˆäº”ä¸ªå‘é‡æŸ¥è¯¢çš„ç»“æžœprint(I[-5:]) # æœ€åŽäº”ä¸ªå‘é‡æŸ¥è¯¢çš„ç»“æžœ IndexIVFFlat (åŠ é€Ÿæœç´¢) å¯¹äºŽæš´æœæ¥è¯´ï¼Œæµ·é‡æ•°æ®æœç´¢é€Ÿåº¦å¤ªæ…¢ï¼Œé‚£ä¹ˆéœ€è¦é¢„è®­ç»ƒæŠŠå‘é‡éƒ½èšç±»ã€‚è¿™é‡Œä½¿ç”¨IndexIVFFlatæ¥åŠ å¿«æœç´¢é€Ÿåº¦ã€‚IndexIVFFlatæ˜¯faissçš„å€’æŽ’ç´¢å¼•ï¼ŒæŠŠæ•°æ®æž„æˆçš„å‘é‡ç©ºé—´åˆ‡å‰²ä¸ºVoronoiç»†èƒžï¼Œæ¯ä¸ªå‘é‡è½å…¥å…¶ä¸­ä¸€ä¸ªVoronoiç»†èƒžä¸­ã€‚åœ¨æœç´¢æ—¶ï¼Œåªæœ‰æŸ¥è¯¢xæ‰€åœ¨ç»†èƒžä¸­åŒ…å«çš„æ•°æ®åº“å‘é‡yä¸Žå°‘æ•°å‡ ä¸ªç›¸é‚»æŸ¥è¯¢å‘é‡è¿›è¡Œæ¯”è¾ƒã€‚ è®­ç»ƒçš„æ—¶å€™è¿˜éœ€è¦æœ‰ä¸€ä¸ªé‡åŒ–å™¨ï¼Œç”¨äºŽå†³å®šä»¥ä»€ä¹ˆæ–¹å¼å°†å‘é‡åˆ†é…ç»™Voronoiç»†èƒžã€‚æ¯ä¸ªç»†èƒžç”±ä¸€ä¸ªè´¨å¿ƒå®šä¹‰ï¼Œæ‰¾åˆ°ä¸€ä¸ªå‘é‡æ‰€åœ¨çš„Voronoiç»†èƒžåŒ…æ‹¬åœ¨è´¨å¿ƒé›†ä¸­æ‰¾åˆ°è¯¥å‘é‡çš„æœ€è¿‘é‚»å±…ã€‚ æœç´¢æ–¹æ³•æœ‰ä¸¤ä¸ªå‚æ•°ï¼š nlist åˆ’åˆ†Voronoiç»†èƒžçš„æ•°é‡ nprobe æ‰§è¡Œæœç´¢è®¿é—®çš„å•å…ƒæ ¼æ•°(ä¸åŒ…æ‹¬nlist)ï¼Œè¯¥å‚æ•°è°ƒæ•´ç»“æžœé€Ÿåº¦å’Œå‡†ç¡®åº¦ä¹‹é—´æŠ˜ä¸­çš„ä¸€ç§æ–¹å¼ã€‚å¦‚æžœè®¾ç½®nprobe=nliståˆ™ç»“æžœä¸Žæš´æœä¸€è‡´ã€‚ åŠ å¿«ç´¢å¼•çš„æ–¹å¼ä¹‹ä¸€ï¼Œä¸Žæš´æœå¯¹æ¯”å°±æ˜¯éœ€è¦trainï¼ŒæŠŠå‘é‡ç©ºé—´ä¸‹çš„æ•°æ®åˆ‡å‰²ä¸ºVoronoiç»†èƒžï¼Œæ£€ç´¢åªå¯¹å‘é‡æ‰€åœ¨ç»†èƒžå’Œå‘¨å›´ç»†èƒžè¿›è¡Œæ£€ç´¢ã€‚ 123456789101112131415161718192021222324252627import numpy as npd = 64 # dimensionnb = 100000 # database sizenq = 10000 # nb of queriesnp.random.seed(1234) # make reproduciblexb = np.random.random((nb, d)).astype('float32')xb[:, 0] += np.arange(nb) / 1000.xq = np.random.random((nq, d)).astype('float32')xq[:, 0] += np.arange(nq) / 1000.import faissnlist = 100k = 4quantizer = faiss.IndexFlatL2(d) # å†…éƒ¨çš„ç´¢å¼•æ–¹å¼index = faiss.IndexIVFFlat(quantizer, d, nlist, faiss.METRIC_L2)# here we specify METRIC_L2, by default it performs inner-product searchprint("before train")assert not index.is_trainedindex.train(xb)assert index.is_trainedprint("before add")index.add(xb) # add may be a bit slower as wellD, I = index.search(xq, k) # actual searchprint(I[-5:]) # neighbors of the 5 last queriesindex.nprobe = 10 # default nprobe is 1, try a few moreD, I = index.search(xq, k)print(I[-5:]) # neighbors of the 5 last queries IndexIVFPQ (å‡å°‘å†…å­˜ä½¿ç”¨) ä¸Šé¢ä¸¤ç§ç´¢å¼•éƒ½æ˜¯å­˜å‚¨çš„å®Œæ•´å‘é‡ï¼Œä¸‹é¢ä»‹ç»ä¸€ç§åŽ‹ç¼©å‘é‡çš„æ–¹æ³•ã€‚IndexIVFPQåŸºäºŽPQ (Product Quantizer)ç®—æ³•åŽ‹ç¼©å‘é‡ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç”±äºŽå‘é‡æ²¡æœ‰ç²¾ç¡®å­˜å‚¨ï¼Œæœç´¢æ–¹æ³•è¿”å›žçš„è·ç¦»ä¹Ÿæ˜¯è¿‘ä¼¼å€¼ã€‚ä¸Šé¢æˆ‘ä»¬çœ‹åˆ°çš„ç´¢å¼•IndexFlatL2å’ŒIndexIVFFlatéƒ½ä¼šå…¨é‡å­˜å‚¨æ‰€æœ‰çš„å‘é‡åœ¨å†…å­˜ä¸­ï¼Œä¸ºæ»¡è¶³å¤§çš„æ•°æ®é‡çš„éœ€æ±‚ï¼Œfaissæä¾›ä¸€ç§åŸºäºŽProduct Quantizer(ä¹˜ç§¯é‡åŒ–)çš„åŽ‹ç¼©ç®—æ³•ç¼–ç å‘é‡å¤§å°åˆ°æŒ‡å®šçš„å­—èŠ‚æ•°ã€‚æ­¤æ—¶ï¼Œå­˜å‚¨çš„å‘é‡æ—¶åŽ‹ç¼©è¿‡çš„ï¼ŒæŸ¥è¯¢çš„è·ç¦»ä¹Ÿæ˜¯è¿‘ä¼¼çš„ã€‚ åŽŸç†ï¼šç®€å•æ¥è¯´å°±æ˜¯é€šè¿‡PCAå°†é«˜çº¬ç©ºé—´è½¬æ¢æˆä½Žç»´ç©ºé—´ã€‚ åŽŸæ¥çš„æ•°æ® train å¾—åˆ°ä¸€ä¸ªè½¬æ¢çŸ©é˜µPï¼Œç„¶åŽè¿™ä¸ªçŸ©é˜µå’ŒåŽŸæ¥çš„æ•°æ®Xå¾—åˆ°æ–°çš„é™ç»´ä¹‹åŽçš„Y ($PX =Y$)ã€‚è¿™æ ·è½¬æ¢è¿‡ç¨‹ä¸­ä¿¡æ¯æŸå¤±çš„æ›´å°‘ï¼Œåœ¨faiss ä¸­ä½¿ç”¨ train() å‡½æ•°è¿›è¡Œå®žçŽ°ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839import numpy as npd = 64 # dimensionnb = 100000 # database sizenq = 10000 # nb of queriesnp.random.seed(1234) # make reproduciblexb = np.random.random((nb, d)).astype('float32')xb[:, 0] += np.arange(nb) / 1000.xq = np.random.random((nq, d)).astype('float32')xq[:, 0] += np.arange(nq) / 1000.import faissnlist = 100m = 8k = 4quantizer = faiss.IndexFlatL2(d) # å†…éƒ¨çš„ç´¢å¼•æ–¹å¼index = faiss.IndexIVFPQ(quantizer, d, nlist, m, 8)# æ¯ä¸ªå‘é‡éƒ½è¢«ç¼–ç ä¸º8ä¸ªå­—èŠ‚å¤§å°index.train(xb)index.add(xb)D, I = index.search(xb[:5], k) # sanity checkprint(I)print(D)#[[ 0 78 714 372]# [ 1 1063 555 277]# [ 2 304 134 46]# [ 3 773 64 8]# [ 4 288 531 827]]#[[1.6675376 6.1988335 6.4136653 6.4228306]# [1.4083313 6.023788 6.025648 6.284443 ]# [1.6988016 5.592166 6.139589 6.6717234]# [1.7987373 6.625978 6.7166452 6.865783 ]# [1.5371588 5.7953157 6.38059 6.4141784]]# å¯ä»¥çœ‹åˆ°ç¡®å®žæœç´¢åˆ°äº†æ­£ç¡®çš„ç»“æžœï¼Œä½†æ˜¯ç¬¬ä¸€è¡Œç¬¬ä¸€åˆ—çš„distanceä¸ä¸ºé›¶ï¼Œå±žäºŽæœ‰æŸåŽ‹ç¼©ã€‚# è™½ç„¶ä¸ŽæŽ¥ä¸‹æ¥çš„å‡ åˆ—ï¼ˆå…¶ä»–å‡ ä¸ªæœç´¢ç»“æžœï¼‰å¯¹æ¯”è¿˜æ˜¯æœ‰å‡ å€çš„ä¼˜åŠ¿ã€‚index.nprobe = 10 # ä¸Žä»¥å‰çš„æ–¹æ³•ç›¸æ¯”D, I = index.search(xq, k) # searchprint(I[-5:]) åœ¨æ¶‰åŠindexä½¿ç”¨è€ƒè™‘é€Ÿåº¦ï¼Œaccå’Œå†…å­˜å¤§å°ä¸‰ä¸ªä¸åŒçš„ç»´åº¦ã€‚ç„¶åŽä¸åŒçš„index æ˜¯æœ‰ä¸åŒçš„ä¾§é‡çš„ã€‚ å®‰è£…å‚è€ƒ Take Off(è¿™ä¸ªæ˜¯æœ‰ä¸‰æ–¹é¢éœ€è¦æƒè¡¡çš„ï¼š query timeã€ query accuracy and preprocessing time) As with anything, there is a tradeoff between improving query time versus query accuracy versus preprocessing/index build time versus data storage: no build time, high query time, high storage, exact accuracy: Faiss IndexFlat low build time, med query time, high storage, high accuracy: Faiss IndexIVFFlat med build time, low query time, low-med storage, med-high accuracy: Faiss IndexIVFPQ very high build time, low query time, low-high storage (whether stored as a k-NN graph or raw data), high accuracy: NN-Descent by Dong et al. (e.g., nmslib) IndexIVFPQ with perhaps IMI is typically what we concentrate on, seems to be a reasonable sweet spot for billion-scale datasets. product quantization ç®—æ³•è¿™é‡Œçš„ä¹˜ç§¯æ˜¯æŒ‡ç¬›å¡å°”ç§¯ï¼ˆCartesian productï¼‰ï¼Œæ„æ€æ˜¯æŒ‡æŠŠåŽŸæ¥çš„å‘é‡ç©ºé—´åˆ†è§£ä¸ºè‹¥å¹²ä¸ªä½Žç»´å‘é‡ç©ºé—´çš„ç¬›å¡å°”ç§¯ï¼Œå¹¶å¯¹åˆ†è§£å¾—åˆ°çš„ä½Žç»´å‘é‡ç©ºé—´åˆ†åˆ«åšé‡åŒ–ï¼ˆquantizationï¼‰ã€‚è¿™æ ·æ¯ä¸ªå‘é‡å°±èƒ½ç”±å¤šä¸ªä½Žç»´ç©ºé—´çš„é‡åŒ–codeç»„åˆè¡¨ç¤ºã€‚ The idea is to decomposes the space into a Cartesian product of low dimensional subspaces and to quantize each subspace separately. A vector is represented by a short code composed of its subspace quantization indices. Image Vector Dataset: å­˜å‚¨çš„æ˜¯ç¦» embedding æœ€è¿‘çš„centroid (è´¨å¿ƒ) çš„ç¼–å· è€Œéžå‘é‡æœ¬èº«ã€‚ Letâ€™s say you have a collection of 50,000 images, and youâ€™ve already performed some feature extraction with a convolutional neural network, and now you have a dataset of 50,000 feature vectors with 1,024 components each. The first thing weâ€™re going to do is compress our dataset. The number of vectors will stay the same, but weâ€™ll reduce the amount of storage required for each vector. Note that what weâ€™re going to do is not the same as â€œdimensionality reductionâ€! This is because the values in the compressed vectors are actually symbolic rather than numeric, so we canâ€™t compare the compressed vectors to one another directly. Two important benefits to compressing the dataset are that (1) memory access times are generally the limiting factor on processing speed, and (2) sheer memory capacity can be a problem for big datasets. Hereâ€™s how the compression works. For our example weâ€™re going to chop up the vectors into 8 sub-vectors, each of length 128 (8 sub vectors x 128 components = 1,024 components). This divides our dataset into 8 matrices that are [50K x 128] each. These centroids are like â€œprototypesâ€. They represent the most commonly occurring patterns in the dataset sub-vectors. Weâ€™re going to use these centroids to compress our 1 million vector dataset. Effectively, weâ€™re going to replace each subregion of a vector with the closest matching centroid, giving us a vector thatâ€™s different from the original, but hopefully still close. Doing this allows us to store the vectors much more efficientlyâ€”instead of storing the original floating point values, weâ€™re just going to store cluster ids. For each subvector, we find the closest centroid, and store the id of that centroid. Each vector is going to be replaced by a sequence of 8 centroid ids. I think you can guess how we pick the centroid idsâ€“you take each subvector, find the closest centroid, and replace it with that centroidâ€™s id. Note that we learn a different set of centroids for each subsection. And when we replace a subvector with the id of the closest centroid, we are only comparing against the 256 centroids for that subsection of the vector. Because there are only 256 centroids, we only need 8-bits to store a centroid id. Each vector, which initially was a vector of 1,024 32-bit floats (4,096 bytes) is now a sequence of eight 8-bit integers (8 bytes total per vector!). æ€»çš„æ¥è¯´faiss é«˜æ•ˆå®žçŽ°äº†PCA ç®—æ³•, k-means ç®—æ³• å’ŒPQ ç®—æ³•ã€‚ ref 1ref 2ref 3ref 4 K-means ç®—æ³•K-means æ˜¯ä¸€ç§èšç±»ç®—æ³•ï¼Œå±žäºŽæ— ç›‘ç£å­¦ä¹ ç®—æ³•ï¼Œå…ˆè¯´ä¸€ä¸‹ä»€ä¹ˆæ˜¯èšç±»ï¼šèšç±»åˆ†æžæ˜¯åœ¨æ•°æ®ä¸­å‘çŽ°æ•°æ®å¯¹è±¡ä¹‹é—´çš„å…³ç³»ï¼Œå°†æ•°æ®è¿›è¡Œåˆ†ç»„ï¼Œç»„å†…çš„ç›¸ä¼¼æ€§è¶Šå¤§ï¼Œç»„é—´çš„å·®åˆ«è¶Šå¤§ï¼Œåˆ™èšç±»æ•ˆæžœè¶Šå¥½ã€‚ K-Meansç®—æ³•æ€æƒ³ï¼šå¯¹ç»™å®šçš„æ ·æœ¬é›†ï¼Œäº‹å…ˆç¡®å®šèšç±»ç°‡æ•°K ï¼ˆè¶…å‚æ•°ï¼‰ï¼Œè®©ç°‡å†…çš„æ ·æœ¬å°½å¯èƒ½ç´§å¯†åˆ†å¸ƒåœ¨ä¸€èµ·ï¼Œä½¿ç°‡é—´çš„è·ç¦»å°½å¯èƒ½å¤§ã€‚è¯¥ç®—æ³•è¯•å›¾ä½¿é›†ç¾¤æ•°æ®åˆ†ä¸ºnç»„ç‹¬ç«‹æ•°æ®æ ·æœ¬ï¼Œä½¿nç»„é›†ç¾¤é—´çš„æ–¹å·®ç›¸ç­‰ï¼Œæ•°å­¦æè¿°ä¸ºæœ€å°åŒ–æƒ¯æ€§æˆ–é›†ç¾¤å†…çš„å¹³æ–¹å’Œã€‚K-Meansä½œä¸ºæ— ç›‘ç£çš„èšç±»ç®—æ³•ï¼Œå®žçŽ°è¾ƒç®€å•ï¼Œèšç±»æ•ˆæžœå¥½ï¼Œå› æ­¤è¢«å¹¿æ³›ä½¿ç”¨ã€‚ ç®—æ³•æ­¥éª¤ åˆ›å»ºkä¸ªç‚¹ä½œä¸ºkä¸ªç°‡çš„èµ·å§‹è´¨å¿ƒï¼ˆç»å¸¸éšæœºé€‰æ‹©ï¼‰ã€‚ åˆ†åˆ«è®¡ç®—å‰©ä¸‹çš„å…ƒç´ åˆ°kä¸ªç°‡ä¸­å¿ƒçš„ç›¸å¼‚åº¦ï¼ˆè·ç¦»ï¼‰ï¼Œå°†è¿™äº›å…ƒç´ åˆ†åˆ«åˆ’å½’åˆ°ç›¸å¼‚åº¦æœ€ä½Žçš„ç°‡ã€‚ æ ¹æ®èšç±»ç»“æžœï¼Œé‡æ–°è®¡ç®—kä¸ªç°‡å„è‡ªçš„ä¸­å¿ƒï¼Œè®¡ç®—æ–¹æ³•æ˜¯å–ç°‡ä¸­æ‰€æœ‰å…ƒç´ å„è‡ªç»´åº¦çš„ç®—æœ¯å¹³å‡å€¼ã€‚ å°†Dä¸­å…¨éƒ¨å…ƒç´ æŒ‰ç…§æ–°çš„ä¸­å¿ƒé‡æ–°èšç±»ã€‚ é‡å¤ç¬¬4æ­¥ï¼Œç›´åˆ°èšç±»ç»“æžœä¸å†å˜åŒ–ã€‚ æœ€åŽï¼Œè¾“å‡ºèšç±»ç»“æžœã€‚ K-Meansç®—æ³•ä¼˜ç¼ºç‚¹ ä¼˜ç‚¹ åŽŸç†æ˜“æ‡‚ã€æ˜“äºŽå®žçŽ°ï¼› å½“ç°‡é—´çš„åŒºåˆ«è¾ƒæ˜Žæ˜¾æ—¶ï¼Œèšç±»æ•ˆæžœè¾ƒå¥½ï¼› Trains quickly ç¼ºç‚¹ å½“æ ·æœ¬é›†è§„æ¨¡å¤§æ—¶ï¼Œæ”¶æ•›é€Ÿåº¦ä¼šå˜æ…¢ï¼› å¯¹å™ªå£°æˆ–è€…ç¦»ç¾¤ç‚¹æ¯”è¾ƒæ•æ„Ÿ kçš„å–å€¼ååˆ†å…³é”®ï¼Œå¯¹ä¸åŒæ•°æ®é›†ï¼Œké€‰æ‹©æ²¡æœ‰å‚è€ƒæ€§ï¼Œéœ€è¦å¤§é‡å®žéªŒ åˆå§‹è´¨å¿ƒçš„é€‰æ‹©ï¼Œä¸åŒçš„è´¨å¿ƒé€‰æ‹©å¯èƒ½å¾—åˆ°å®Œå…¨ä¸åŒçš„ç»“æžœï¼Œå› ä¸ºk-means å¯ä»¥ä¿è¯çš„æ˜¯å±€éƒ¨æœ€ä¼˜è§£ï¼Œè€Œä¸æ˜¯å…¨å±€æœ€ä¼˜è§£ã€‚é’ˆå¯¹è¯¥ç¼ºé™·ï¼Œå¯ä»¥ä½¿ç”¨ kmeans++ ç®—æ³•è§£å†³ã€‚k-means++ ç®—æ³•é€‰æ‹©seedsçš„åŸºæœ¬æ€è·¯æ˜¯ï¼šåˆå§‹åŒ–èšç±»ä¸­å¿ƒä¹‹é—´çš„ç›¸äº’è·ç¦»è¦å°½å¯èƒ½çš„è¿œã€‚ æ—¶é—´å¤æ‚åº¦$O(mnkt)$ï¼Œ å…¶ä¸­$t$ ä¸ºè¿­ä»£åˆºæ‰‹ï¼Œ $k$ ä¸ºç°‡çš„æ•°ç›®ï¼Œ $m$ ä¸ºæ•°æ®é‡, $n$ ä¸ºæ•°æ®çš„ç»´åº¦ã€‚å¯¹äºŽå¤§æ•°æ®æ¥è¯´ï¼Œ$t$ï¼Œ$k$å’Œ$n$ éƒ½æ˜¯å¯ä»¥çœ‹åšå¸¸æ•°ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦è¿‘ä¼¼å°±æ˜¯ $O(n)$ï¼Œæ‰€ä»¥è¯¥ç®—æ³•æ˜¯ç›¸å½“é«˜æ•ˆçš„ã€‚ ç©ºé—´å¤æ‚åº¦$O(m+k)n$ å…¶ä¸­ $k$ ä¸ºç°‡çš„æ•°ç›®ï¼Œ $m$ä¸ºæ•°æ®é‡ï¼Œ $n$ ä¸ºæ•°æ®çš„ç»´åº¦ã€‚åŒç†å¯¹äºŽç©ºé—´å¤æ‚åº¦ä¹Ÿå¯ä»¥è¿™æ ·åˆ†æžã€‚æœ€åŽçš„ç»“è®ºå¯ä»¥ç®€åŒ–ä¸ºï¼šæ—¶ç©ºå¤æ‚åº¦æ˜¯$O(n)$ Choosing K The algorithm explained above finds clusters for the number k that we chose. So, how do we decide on that number? å°è¯•æ³•ï¼š è®¡ç®—æ¯ä¸ªç‚¹åˆ°æœ€è¿‘çš„ç°‡çš„è·ç¦»çš„æ€»å’Œï¼Œå¦‚æžœå¢žåŠ  k å¯¼è‡´çš„æ€»å’Œä¸‹é™ä¸æ˜Žæ˜¾ï¼Œé‚£ä¹ˆå°±æŽ¥è¿‘ä¸´ç•Œç‚¹äº†ã€‚ To find the best k we need to measure the quality of the clusters. The most traditional and straightforward method is to start with a random k, create centroids, and run the algorithm as we explained above. A sum is given based on the distances between each point and its closest centroid. As an increase in clusters correlates with smaller groupings and distances, this sum will always decrease when k increases; as an extreme example, if we choose a k value that is equal to the number of data points that we have, the sum will be zero. The goal with this process is to find the point at which increasing k will cause a very small decrease in the error sum, while decreasing k will sharply increase the error sum. This sweet spot is called the â€œelbow point.â€ In the image below, it is clear that the â€œelbowâ€ point is at k-3.Â­ ä½¿ç”¨åœºæ™¯ï¼šä¸€èˆ¬åœ¨æ•°æ®åˆ†æžçš„å‰æœŸä½¿ç”¨ï¼Œé€‰æ‹©é€‚å½“çš„ $K$ï¼Œåˆ†æžä¸åŒèšç±»æ•°æ®ä¸‹çš„ç‰¹ç‚¹ã€‚ k-means æ˜¯ä»¥æ¬§å¼è·ç¦»ä½œä¸ºç›¸ä¼¼åº¦æµ‹é‡ï¼Œè¦æ±‚æŸä¸€åˆå§‹åŒ–èšç±»ä¸­å¿ƒåˆ†ç±»æ•ˆæžœæœ€å¥½ã€‚ç®—æ³•é‡‡ç”¨è¯¯å·®å¹³æ–¹å’Œä½œä¸ºå‡†ä¾§å‡½æ•°ï¼Œä¼˜åŒ–çš„æ˜¯è¯¥å‡½æ•°ã€‚ æ¬§å¼è·ç¦»å’Œæ›¼å“ˆé¡¿è·ç¦»ï¼ˆL1è·ç¦»ï¼‰éƒ½å¯ä»¥è¡¨ç¤ºæœ€è¿‘é‚»å±…ä¹‹é—´çš„è·ç¦»ï¼Œå¦‚ä½•è¿›è¡Œé€‰æ‹©ï¼Ÿå‰è€…é€‚åˆåœ¨å½’ä¸€åŒ–æ— é‡çº²çš„æƒ…å†µä¸‹è¿›è¡Œä½¿ç”¨ï¼Œä¸¤è€…ä¸å…·æœ‰ç›¸äº’æ›¿ä»£æ€§ã€‚ ä»£ç å®žçŽ° è‡ªå·±å®žçŽ°äº†ä¸€ä¸ª k-means è®¡ç®—è¿‡ç¨‹ï¼›ç„¶åŽä½¿ç”¨ sklearn ä¸­å®žçŽ°å¥½çš„æ¡†æž¶ã€‚æ²¡æœ‰æ¯”è¿™ä¸ªå†™å¾—æ›´å¥½çš„äº†ã€‚ä»£ç é“¾æŽ¥ ä»£ç æ‘˜è¦1234567891011121314151617181920212223242526272829## Initialisationimport pandas as pdimport numpy as npimport matplotlib.pyplot as plt%matplotlib inlinedf = pd.DataFrame(&#123; 'x': [12, 20, 28, 18, 29, 33, 24, 45, 45, 52, 51, 52, 55, 53, 55, 61, 64, 69, 72], 'y': [39, 36, 30, 52, 54, 46, 55, 59, 63, 70, 66, 63, 58, 23, 14, 8, 19, 7, 24]&#125;)np.random.seed(200)k = 3# centroids[i] = [x, y]# å­¦ä¹ å¼€æºä»£ç ï¼Œåœ¨äºŽå‘åˆ«äººå­¦ä¹ ï¼Œçœ‹äººå®¶æ˜¯å¦‚ä½•å†™ä»£ç çš„ï¼Œæ€Žä¹ˆå†™å¾—ç®€å•é«˜æ•ˆï¼Œæ¼‚äº®centroids = &#123; i+1: [np.random.randint(0, 80), np.random.randint(0, 80)] for i in range(k)&#125; fig = plt.figure(figsize=(5, 5))plt.scatter(df['x'], df['y'], color='k')colmap = &#123;1: 'r', 2: 'g', 3: 'b'&#125;for i in centroids.keys(): plt.scatter(*centroids[i], color=colmap[i])plt.xlim(0, 80)plt.ylim(0, 80)plt.show() 1234567891011121314151617def assignment(df, centroids): for i in centroids.keys(): # sqrt((x1 - x2)^2 - (y1 - y2)^2) df['distance_from_&#123;&#125;'.format(i)] = ( np.sqrt( (df['x'] - centroids[i][0]) ** 2 + (df['y'] - centroids[i][1]) ** 2 ) ) centroid_distance_cols = ['distance_from_&#123;&#125;'.format(i) for i in centroids.keys()] df['closest'] = df.loc[:, centroid_distance_cols].idxmin(axis=1)#å¾—åˆ°çš„æ˜¯id æ ‡è¯† df['closest'] = df['closest'].map(lambda x: int(x.lstrip('distance_from_'))) # è¿™ä¸ªè½¬æ¢æˆæ•°å­— df['color'] = df['closest'].map(lambda x: colmap[x]) # æ³¨æ„lambda å‡½æ•° x æ˜¯è¾“å…¥å‚æ•°ï¼Œ: ä¹‹åŽæ˜¯å¤„ç†çš„å‡½æ•° return dfdf = assignment(df, centroids)print(df.head()) 1234567891011121314151617181920212223242526## Update Stageimport copyold_centroids = copy.deepcopy(centroids)def update(k): for i in centroids.keys(): centroids[i][0] = np.mean(df[df['closest'] == i]['x']) centroids[i][1] = np.mean(df[df['closest'] == i]['y']) return kcentroids = update(centroids)# è¿™ä¸ªå¯è§†åŒ–çš„ç®­å¤´ä¹Ÿæ˜¯åšå¾—ç›¸å½“çš„æ£’fig = plt.figure(figsize=(5, 5))ax = plt.axes()plt.scatter(df['x'], df['y'], color=df['color'], alpha=0.5, edgecolor='k')for i in centroids.keys(): plt.scatter(*centroids[i], color=colmap[i])plt.xlim(0, 80)plt.ylim(0, 80)for i in old_centroids.keys(): old_x = old_centroids[i][0] old_y = old_centroids[i][1] dx = (centroids[i][0] - old_centroids[i][0]) * 0.75 dy = (centroids[i][1] - old_centroids[i][1]) * 0.75 ax.arrow(old_x, old_y, dx, dy, head_width=2, head_length=3, fc=colmap[i], ec=colmap[i])plt.show() 12345678910111213141516# Continue until all assigned categories don't change any morewhile True: closest_centroids = df['closest'].copy(deep=True) centroids = update(centroids) df = assignment(df, centroids) # ä¸åŒçš„è¯­è¨€ä¹‹é—´æ˜¯ç›¸åŒçš„ï¼Œè¦ä¹ˆæ˜¯å€¼æ¯”è¾ƒï¼Œé‚£ä¹ˆæ˜¯å¼•ç”¨æ¯”è¾ƒï¼Œæ˜¾ç„¶è¿™é‡Œæ˜¯å€¼æ¯”è¾ƒ if closest_centroids.equals(df['closest']): breakfig = plt.figure(figsize=(5, 5))plt.scatter(df['x'], df['y'], color=df['color'], alpha=0.5, edgecolor='k')for i in centroids.keys(): plt.scatter(*centroids[i], color=colmap[i]) # å¦‚æ„å¯ä»¥ä¼ å…¥ä¸€ä¸ªlistï¼Œè¡¨ç¤ºä¸¤ä¸ªå‚æ•°plt.xlim(0, 80)plt.ylim(0, 80)plt.show() KNNKæœ€è¿‘é‚»(k-Nearest Neighborï¼ŒKNN) æ˜¯æœ‰ç›‘ç£åˆ†ç±»å­¦ä¹ ï¼Œæ ¹æ®K ä¸ªæœ€è¿‘é‚»çš„ç±»åˆ«ä¿¡æ¯ï¼Œé€šè¿‡æŠ•ç¥¨çš„æ–¹å¼å†³å®šåˆšè¿›æ¥çš„æ•°æ®ç‚¹çš„ç±»åˆ«ã€‚å’ŒKNN å®¹æ˜“ç›¸æ··æ·†çš„æ˜¯K-meansç®—æ³•ï¼Œå…·ä½“å¯ä»¥å‚è€ƒä¸Šé¢çš„æè¿°ã€‚KNN ä¸­çš„K è¡¨ç¤ºKä¸ªæœ€è¿‘é‚»æ˜¯æœ‰æŠ•ç¥¨æƒçš„ï¼Œæ ¹æ®K ä¸ªæœ€è¿‘é‚»çš„æŠ•ç¥¨ç„¶åŽå†³å®šæ–°åŠ å…¥çš„ç‚¹ç±»åˆ«ä¿¡æ¯ã€‚ In short, the algorithms are trying to accomplish different goals. K-nearest neighbor is a subset of supervised learning classification (or regression) algorithms (it takes a bunch of labeled points and uses them to learn how to label other points). It is supervised because you are trying to classify a point based on the known classification of other points. In contrast, K-means is a subset of unsupervised learning clustering algorithms (it takes a bunch of unlabeled points and tries to group them into clusters). It is unsupervised because the points have no external classification. The $ k $ in each case mean different things. In K-NN, the $ k $ represents the number of neighbors who have a vote in determining a new playerâ€™s position. The $ k $ in K-means, determine the number of clusters we want to end up. In a K-NN algorithm, a test sample is given as the class of majority of its nearest neighbours. For example, if we have three classes and the goal is to find a class label for the unknown example $ x_j $ then, by using the Euclidean distance and a value of $ k=5 $ neighbors, the unknown sample is classified to the category of the most voted neighbors. How it works?Step 1: Determine the value for KStep 2: Calculate the distances between the new input (test data) and all the training data. The most commonly used metrics for calculating distance are Euclidean, Manhattan and MinkowskiStep 3: Sort the distance and determine k nearest neighbors based on minimum distance valuesStep 4: Analyze the category of those neighbors and assign the category for the test data based on majority voteStep 5: Return the predicted class The situation with K-means is that, given some data you will cluster them in k-groups or clusters. The initial step of the algorithm is to randomly spawn $ k $ centroids (centers). At every iteration the center of each cluster is moved slightly to minimize the objective function. The algorithm will terminate if the iterations are maximized or if the centroids stop to move. The objective function of K-means is $ J = \sum_{j=1}^{k}\sum_{i=1}^{n}\left |x_i^{j}-c_j \right |^{2} $ How it works?Step 1: Determine K value by Elbow method and specify the number of clusters KStep 2: Randomly assign each data point to a clusterStep 3: Determine the cluster centroid coordinatesStep 4: Determine the distances of each data point to the centroids and re-assign each point to the closest cluster centroid based upon minimum distanceStep 5: Calculate cluster centroids againStep 6: Repeat steps 4 and 5 until we reach global optima where no improvements are possible and no switching of data points from one cluster to other. ä¸Šå›¾aè¡¨è¾¾äº†åˆå§‹çš„æ•°æ®é›†ï¼Œå‡è®¾k=2ã€‚åœ¨å›¾bä¸­ï¼Œæˆ‘ä»¬éšæœºé€‰æ‹©äº†ä¸¤ä¸ªkç±»æ‰€å¯¹åº”çš„ç±»åˆ«è´¨å¿ƒï¼Œå³å›¾ä¸­çš„çº¢è‰²è´¨å¿ƒå’Œè“è‰²è´¨å¿ƒï¼Œç„¶åŽåˆ†åˆ«æ±‚æ ·æœ¬ä¸­æ‰€æœ‰ç‚¹åˆ°è¿™ä¸¤ä¸ªè´¨å¿ƒçš„è·ç¦»ï¼Œå¹¶æ ‡è®°æ¯ä¸ªæ ·æœ¬çš„ç±»åˆ«ä¸ºå’Œè¯¥æ ·æœ¬è·ç¦»æœ€å°çš„è´¨å¿ƒçš„ç±»åˆ«ï¼Œå¦‚å›¾cæ‰€ç¤ºï¼Œç»è¿‡è®¡ç®—æ ·æœ¬å’Œçº¢è‰²è´¨å¿ƒå’Œè“è‰²è´¨å¿ƒçš„è·ç¦»ï¼Œæˆ‘ä»¬å¾—åˆ°äº†æ‰€æœ‰æ ·æœ¬ç‚¹çš„ç¬¬ä¸€è½®è¿­ä»£åŽçš„ç±»åˆ«ã€‚æ­¤æ—¶æˆ‘ä»¬å¯¹æˆ‘ä»¬å½“å‰æ ‡è®°ä¸ºçº¢è‰²å’Œè“è‰²çš„ç‚¹åˆ†åˆ«æ±‚å…¶æ–°çš„è´¨å¿ƒï¼Œå¦‚å›¾4æ‰€ç¤ºï¼Œæ–°çš„çº¢è‰²è´¨å¿ƒå’Œè“è‰²è´¨å¿ƒçš„ä½ç½®å·²ç»å‘ç”Ÿäº†å˜åŠ¨ã€‚å›¾eå’Œå›¾fé‡å¤äº†æˆ‘ä»¬åœ¨å›¾cå’Œå›¾dçš„è¿‡ç¨‹ï¼Œå³å°†æ‰€æœ‰ç‚¹çš„ç±»åˆ«æ ‡è®°ä¸ºè·ç¦»æœ€è¿‘çš„è´¨å¿ƒçš„ç±»åˆ«å¹¶æ±‚æ–°çš„è´¨å¿ƒã€‚æœ€ç»ˆæˆ‘ä»¬å¾—åˆ°çš„ä¸¤ä¸ªç±»åˆ«å¦‚å›¾fã€‚ EM ç®—æ³•å…ˆéªŒæ¦‚çŽ‡å’ŒåŽéªŒæ¦‚çŽ‡ äº‹ä»¶å‘ç”Ÿå‰çš„é¢„åˆ¤æ¦‚çŽ‡ã€‚å¯ä»¥æ˜¯åŸºäºŽåŽ†å²æ•°æ®çš„ç»Ÿè®¡ï¼Œå¯ä»¥ç”±èƒŒæ™¯å¸¸è¯†å¾—å‡ºï¼Œä¹Ÿå¯ä»¥æ˜¯äººçš„ä¸»è§‚è§‚ç‚¹ç»™å‡ºã€‚ä¸€èˆ¬éƒ½æ˜¯å•ç‹¬äº‹ä»¶æ¦‚çŽ‡ï¼Œå¦‚ $P(x) $, $P(y)$ã€‚äº‹ä»¶å‘ç”ŸåŽæ±‚çš„åå‘æ¡ä»¶æ¦‚çŽ‡ï¼›æˆ–è€…è¯´ï¼ŒåŸºäºŽå…ˆéªŒæ¦‚çŽ‡æ±‚å¾—çš„åå‘æ¡ä»¶æ¦‚çŽ‡ã€‚æ¡ä»¶æ¦‚çŽ‡ï¼šä¸€ä¸ªäº‹ä»¶å‘ç”ŸåŽå¦ä¸€ä¸ªäº‹ä»¶å‘ç”Ÿçš„æ¦‚çŽ‡ã€‚ å…ˆéªŒæ¦‚çŽ‡æ˜¯æŒ‡æ ¹æ®ä»¥å¾€ç»éªŒå’Œåˆ†æžå¾—åˆ°çš„æ¦‚çŽ‡,å®ƒå¾€å¾€ä½œä¸ºâ€ç”±å› æ±‚æžœâ€é—®é¢˜ä¸­çš„â€å› â€å‡ºçŽ°ï¼Œæ¯”å¦‚å…¨æ¦‚çŽ‡å…¬å¼ã€‚ åŽéªŒæ¦‚çŽ‡æ˜¯æŒ‡ä¾æ®å¾—åˆ°â€ç»“æžœâ€ä¿¡æ¯æ‰€è®¡ç®—å‡ºçš„æœ€æœ‰å¯èƒ½æ˜¯é‚£ç§äº‹ä»¶å‘ç”Ÿ,å¦‚è´å¶æ–¯å…¬å¼ä¸­çš„,æ˜¯â€æ‰§æžœå¯»å› â€é—®é¢˜ä¸­çš„â€å› â€ï¼Œ æ¯”å¦‚è´å¶æ–¯å…¬å¼ã€‚ æžå¤§ä¼¼ç„¶ä¼°è®¡ æžå¤§ä¼¼ç„¶ä¼°è®¡æ˜¯ç”¨æ¥æ±‚è§£æ¦‚çŽ‡åˆ†å¸ƒä¸­å‚æ•°å€¼ã€‚ä¸ºä»€ä¹ˆè¦æ±‚è§£å‚æ•°å€¼ï¼Ÿå› ä¸ºå¤§å¤šæ•°æ¦‚çŽ‡åˆ†å¸ƒéƒ½æ˜¯ç”±å…³é”®çš„å‚æ•°å€¼ï¼Œ å¾—åˆ°åˆ†å¸ƒå°±å¯ä»¥è®¡ç®—æ¦‚çŽ‡å€¼ï¼Œé‚£ä¹ˆè¿›è¡Œåˆ†ç±»å’Œå›žå½’å°±æ²¡æœ‰ä»€ä¹ˆé—®é¢˜ã€‚å¸¸è§çš„æ¦‚çŽ‡åˆ†å¸ƒæ¯”å¦‚äºŒé¡¹åˆ†å¸ƒæ˜¯ç”± $p $æŽ§åˆ¶ï¼Œæ­£å¤ªåˆ†å¸ƒæ˜¯ç”± $\mu$ å’Œ$\sigma$æŽ§åˆ¶ã€‚æžå¤§ä¼¼ç„¶ä¼°è®¡ç†è®ºè®¤ä¸ºï¼Œæ¦‚çŽ‡è¶Šå¤§ï¼Œå‘ç”Ÿçš„å¯èƒ½æ€§å°±è¶Šå¤§ã€‚ è¯¥ç®—æ³•èƒŒæ™¯ï¼š æœ‰ä¸€ä¸ªç‹¬ç«‹åŒåˆ†å¸ƒçš„æ ·æœ¬é›† Dï¼Œä¸”æ ·æœ¬ä»Žæ•°æ®åˆ†å¸ƒ $p(x | \theta)$ ä¸­æŠ½å– æƒ³è¦è®¡ç®— $\theta$ è§£å†³æ€è·¯ï¼š å‡è®¾ D ä¸­æ‰€æœ‰çš„æ ·æœ¬éƒ½æ˜¯ç‹¬ç«‹ä»Ž $ p(x | \theta)$ ä¸­æŠ½å–ï¼Œé‚£ä¹ˆï¼š$$P({X=x^{1}, X=x^{2}, \cdots, X=x^{n}})=\prod_{i=1}^{n} p(x^{i} | {\theta})$$è®°ç­‰å·åŽé¢çš„å¼å­ä¸ºä¼¼ç„¶å‡½æ•° å› ä¸ºä¹˜ç§¯ä¸æ–¹ä¾¿å¤„ç†ï¼Œæ‰€ä»¥ä¸Šé¢å¼å­ä¸­å·¦å³ä¸¤è¾¹æ±‚å¯¹æ•° $$\ln l(\boldsymbol{\theta})=\ln \prod_{i=1}^{n} p\left(x^{i} | \boldsymbol{\theta}\right)=\sum_{i=1}^{n} \ln p\left(x^{i} | \boldsymbol{\theta}\right)$$ æ ¹æ®ç®—æ³•çš„æ€æƒ³ï¼Œæˆ‘ä»¬çš„ç›®æ ‡å°±æ˜¯æœ€å¤§åŒ– $L(\theta)$ï¼Œ æœ€å¤§åŒ–çš„ $\theta$ å°±æ˜¯æˆ‘ä»¬è¦æ±‚çš„ã€‚å¦‚ä½•æœ€å¤§åŒ– $L(\theta)$ï¼Ÿä¸€èˆ¬æ¥è¯´ï¼Œå¦‚æžœå¦‚æžœåªæœ‰ä¸€ä¸ªå‚æ•°ï¼Œæ¯”å¦‚äºŒé¡¹åˆ†å¸ƒï¼Œé‚£ä¹ˆæ±‚å¯¼ä»¤å¯¼æ•°ä¸º0 å°±å¯ä»¥æ±‚$\theta$ã€‚å¦‚æžœæœ‰å¤šä¸ªå‚æ•°ï¼Œæ¯”å¦‚æ­£å¤ªåˆ†å¸ƒï¼Œé‚£ä¹ˆå°±éœ€è¦æ±‚è§£åå¯¼ï¼Œ ä»¤åå¯¼æ•°ä¸º0. æžå¤§ä¼¼ç„¶ä¼°è®¡çš„å±€é™æ€§ éœ€è¦äº‹å…ˆå‡å®šæ•°æ®åˆ†å¸ƒ å‡å®šçš„æ•°æ®åˆ†å¸ƒå’ŒçœŸå®žçš„æ•°æ®åˆ†å¸ƒä¸ä¸€è‡´çš„æ—¶å€™ï¼Œå®¹æ˜“å‡ºçŽ°è¾ƒå¤§çš„è¯¯å·® ä»‹ç»å®Œäº†æœ€å¤§ä¼¼ç„¶ä¼°è®¡ï¼Œé‚£ä¹ˆåŽé¢æ˜¯çœŸæ­£ EM ï¼ˆExpectation Maximization Algorithmï¼‰ç®—æ³•ã€‚ EMç®—æ³•è§£å†³è¿™ä¸ªçš„æ€è·¯æ˜¯ä½¿ç”¨å¯å‘å¼çš„è¿­ä»£æ–¹æ³•ï¼Œæ—¢ç„¶æˆ‘ä»¬æ— æ³•ç›´æŽ¥æ±‚å‡ºæ¨¡åž‹åˆ†å¸ƒå‚æ•°ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å…ˆçŒœæƒ³éšå«æ•°æ®ï¼ˆEMç®—æ³•çš„Eæ­¥ï¼‰ï¼ŒæŽ¥ç€åŸºäºŽè§‚å¯Ÿæ•°æ®å’ŒçŒœæµ‹çš„éšå«æ•°æ®ä¸€èµ·æ¥æžå¤§åŒ–å¯¹æ•°ä¼¼ç„¶ï¼Œæ±‚è§£æˆ‘ä»¬çš„æ¨¡åž‹å‚æ•°ï¼ˆEMç®—æ³•çš„Mæ­¥)ã€‚ç”±äºŽæˆ‘ä»¬ä¹‹å‰çš„éšè—æ•°æ®æ˜¯çŒœæµ‹çš„ï¼Œæ‰€ä»¥æ­¤æ—¶å¾—åˆ°çš„æ¨¡åž‹å‚æ•°ä¸€èˆ¬è¿˜ä¸æ˜¯æˆ‘ä»¬æƒ³è¦çš„ç»“æžœã€‚ä¸è¿‡æ²¡å…³ç³»ï¼Œæˆ‘ä»¬åŸºäºŽå½“å‰å¾—åˆ°çš„æ¨¡åž‹å‚æ•°ï¼Œç»§ç»­çŒœæµ‹éšå«æ•°æ®ï¼ˆEMç®—æ³•çš„Eæ­¥ï¼‰ï¼Œç„¶åŽç»§ç»­æžå¤§åŒ–å¯¹æ•°ä¼¼ç„¶ï¼Œæ±‚è§£æˆ‘ä»¬çš„æ¨¡åž‹å‚æ•°ï¼ˆEMç®—æ³•çš„Mæ­¥)ã€‚ä»¥æ­¤ç±»æŽ¨ï¼Œä¸æ–­çš„è¿­ä»£ä¸‹åŽ»ï¼Œç›´åˆ°æ¨¡åž‹åˆ†å¸ƒå‚æ•°åŸºæœ¬æ— å˜åŒ–ï¼Œç®—æ³•æ”¶æ•›ï¼Œæ‰¾åˆ°åˆé€‚çš„æ¨¡åž‹å‚æ•°ã€‚ä»Žä¸Šé¢çš„æè¿°å¯ä»¥çœ‹å‡ºï¼ŒEMç®—æ³•æ˜¯è¿­ä»£æ±‚è§£æœ€å¤§å€¼çš„ç®—æ³•ï¼ŒåŒæ—¶ç®—æ³•åœ¨æ¯ä¸€æ¬¡è¿­ä»£æ—¶åˆ†ä¸ºä¸¤æ­¥ï¼ŒEæ­¥å’ŒMæ­¥ã€‚ä¸€è½®è½®è¿­ä»£æ›´æ–°éšå«æ•°æ®å’Œæ¨¡åž‹åˆ†å¸ƒå‚æ•°ï¼Œç›´åˆ°æ”¶æ•›ï¼Œå³å¾—åˆ°æˆ‘ä»¬éœ€è¦çš„æ¨¡åž‹å‚æ•°ã€‚ä¸€ä¸ªæœ€ç›´è§‚äº†è§£EMç®—æ³•æ€è·¯çš„æ˜¯K-Meansç®—æ³•ï¼Œè§ä¹‹å‰å†™çš„K-Meansèšç±»ç®—æ³•åŽŸç†ã€‚åœ¨K-Meansèšç±»æ—¶ï¼Œæ¯ä¸ªèšç±»ç°‡çš„è´¨å¿ƒæ˜¯éšå«æ•°æ®ã€‚æˆ‘ä»¬ä¼šå‡è®¾$ð¾$ä¸ªåˆå§‹åŒ–è´¨å¿ƒï¼Œå³EMç®—æ³•çš„Eæ­¥ï¼›ç„¶åŽè®¡ç®—å¾—åˆ°æ¯ä¸ªæ ·æœ¬æœ€è¿‘çš„è´¨å¿ƒï¼Œå¹¶æŠŠæ ·æœ¬èšç±»åˆ°æœ€è¿‘çš„è¿™ä¸ªè´¨å¿ƒï¼Œå³EMç®—æ³•çš„Mæ­¥ã€‚é‡å¤è¿™ä¸ªEæ­¥å’ŒMæ­¥ï¼Œç›´åˆ°è´¨å¿ƒä¸å†å˜åŒ–ä¸ºæ­¢ï¼Œè¿™æ ·å°±å®Œæˆäº†K-Meansèšç±»ã€‚ EMç®—æ³•èƒ½ä¿è¯æ”¶æ•›å—ï¼Ÿæœ‰å……åˆ†çš„ç†è®ºè¯´æ˜Žï¼Œè¿™ä¸ªæ˜¯èƒ½å¤Ÿä¿è¯æ”¶æ•›çš„ã€‚ EMç®—æ³•å¦‚æžœæ”¶æ•›ï¼Œé‚£ä¹ˆèƒ½ä¿è¯æ”¶æ•›åˆ°å…¨å±€æœ€å¤§å€¼å—ï¼Ÿä¸èƒ½ä¿è¯ï¼Œè¿™ä¸ªå–å†³äºŽåˆå§‹åŒ–ã€‚åˆå§‹å€¼ä¸åŒï¼Œé‚£ä¹ˆæœ€åŽçš„ç»“æžœä¸åŒã€‚æ‰€ä»¥è¿™ä¸ªæ˜¯ç»™å®šåˆå§‹å€¼ï¼Œç»è¿‡å¾ªçŽ¯è¿­ä»£ï¼Œæœ€ç»ˆé€¼è¿‘çœŸå®žå€¼ã€‚ å¦‚æžœè¦è®²è§£ EM ç®—æ³•ï¼Œå¯ä»¥è®¤ä¸º K-means æ˜¯å…¶ä¸€ä¸ªç‰¹ä¾‹ï¼Œé‚£ä¹ˆè¿›è¡Œç†è§£ã€‚ å¤ä¹ ç¬”è®° ä½¿ç”¨äºŒå‰æ ‘çš„ç»“æž„ï¼Œæ—¶é—´å¤æ‚åº¦ä»Ž $O(N) $ ä¼˜åŒ–åˆ°äº†$log_2(N)$ï¼Œå½“ä½¿ç”¨huffman æ ‘çš„æ—¶å€™ï¼Œè¿™ç§æ•ˆæžœæ›´åŠ æ˜Žæ˜¾ã€‚å±‚æ¬¡softmax ä¸æ˜¯fasttext çš„é¦–åˆ›ï¼Œå®ƒçš„æ”¹è¿›ä¹‹å¤„åœ¨å®žçŽ°çš„æ—¶å€™åŸºäºŽ huffman æ ‘è€Œä¸æ˜¯æ™®é€šçš„äºŒå‰æ ‘ï¼Œ å±žäºŽè¿ç®—ä¸Šçš„ä¼˜åŒ–ã€‚åˆ©ç”¨äº†ç±»åˆ«ä¸å‡è¡¡çš„ç‰¹ç‚¹ï¼Œç±»åˆ«å¤šçš„è·¯å¾„çŸ­ï¼Œæ•´ä½“ä¸Šçš„æ—¶é—´æ•ˆçŽ‡ä¼šæé«˜ã€‚ N-gram ä¸€ç§æ˜¯åŸºäºŽcharacter-level å¯¹äºŽä¸å¸¸è§å•è¯çš„æ‰©å……ï¼Œè§£å†³çš„æ˜¯OOVé—®é¢˜ï¼›ä¸€ç§æ˜¯word-levelï¼Œè€ƒè™‘çš„æ˜¯è¯è¯­å‘¨è¾¹çš„ä¿¡æ¯ï¼ŒåŠ å…¥äº†context çš„ä¿¡æ¯ï¼Œlocal context çš„ä¿¡æ¯ã€‚ negative sampling æ˜¯è§£å†³æœ€åŽsoftmax å±‚ä¸­ï¼Œä¸æ›´æ–°æ‰€æœ‰çš„negative wordsï¼Œåªæ˜¯æ›´æ–°å°‘éƒ¨åˆ†å•è¯ï¼Œæ ¹æ®è¯é¢‘é€‰æ‹©negative wordsï¼Œå¹¶ä¸”è¿™ç§è¯é¢‘æ˜¯ç»è¿‡çº¦æŸï¼Œä¸»è¦æ˜¯ä½¿å¾—ä½Žé¢‘è¯è¯­ä¹Ÿæœ‰å‡ºçŽ°çš„æœºä¼šã€‚ è°ƒå‚åˆ†ä¸ºå­—å…¸ç›¸å…³çš„å‚æ•°å’Œè®­ç»ƒç›¸å…³å‚æ•° fasttext çš„å’Œä¹‹å‰ CBOWçš„åŒºåˆ«ï¼šç½‘ç»œç»“æž„ä¸­çš„è¾“å…¥å±‚ï¼ŒCBOWæ˜¯ç»è¿‡one-hotçš„ä¸Šä¸‹æ–‡å•è¯ï¼Œè€Œfasttext æ˜¯å•è¯+ n-gram çš„ç‰¹å¾ï¼Œåœ¨è§£å†³OOVæ•ˆæžœæ¯”è¾ƒå¥½ï¼›å¦å¤–åœ¨æœ€åŽçš„è¾“å‡ºå±‚ï¼ŒåŸºäºŽhuffman æ ‘å®žçŽ°äº†å±‚æ¬¡softmaxï¼Œå¯¹äºŽç±»åˆ«ä¸å‡è¡¡çš„è®­ç»ƒé›†æ¥è¯´ï¼Œè®­ç»ƒæ—¶é—´ä¼šå˜å¾—æ›´çŸ­ã€‚ fasttext çš„ç¼ºç‚¹ï¼Œä½¿ç”¨æ–‡æœ¬åˆ†ç±»çš„æ—¶å€™ï¼Œå½“ç±»åˆ«æ¯”è¾ƒå¤šçš„æ—¶å€™æå‡æ•ˆæžœæ¯”è¾ƒæ˜Žæ˜¾ï¼Œå¦åˆ™æ˜¯å®¹æ˜“è¿‡æ‹Ÿåˆçš„ã€‚ faiss ä¸‰ç§æ¨¡å¼æˆ–è€…è¯´ç´¢å¼•ã€‚ä¸€ç§ç®€å•æ¨¡å¼åœ¨å°çš„æ•°æ®é›†ä¸Šè®¡ç®—æ¬§å¼è·ç¦»ï¼›ä¸€ç§åŠ å¿«æ£€ç´¢çš„é€Ÿåº¦ï¼Œä½¿ç”¨èšç±»ç®—æ³•ï¼Œæ£€ç´¢çš„æ—¶å€™åªæ˜¯æ£€ç´¢id æ‰€åœ¨çš„ç°‡å’Œå‘¨å›´çš„ç°‡ï¼Œä¸è¿‡è¿™ä¸ªè¿‡ç¨‹æ˜¯éœ€è¦é¢„è®­ç»ƒçš„ï¼›ä¸€ç§æ˜¯å‡å°‘å†…å­˜çš„æ—¶å€™ï¼Œå¦‚æžœæ˜¯æ±‚è§£è¿‘ä¼¼è§£ï¼Œé‚£ä¹ˆä¸å¿…å­˜å‚¨å®Œæ•´çš„å‘é‡ï¼Œä½¿ç”¨pca é™ç»´ã€‚è¿˜æœ‰æ¯”è¾ƒé€šç”¨çš„åŠ å¿«é€Ÿåº¦çš„æ–¹å¼ï¼Œæ¯”å¦‚åˆ†æ®µè®¡ç®—å’Œä½¿ç”¨gpu è¿›è¡Œè®¡ç®—ã€‚ å…³äºŽk-meansä¸­é€‰æ‹©èšç±»ç°‡kçš„ä¸ªæ•°çš„ç®—æ³•ï¼šå°è¯•æ³•ã€‚å¦‚æžœå¢žå¤§kï¼Œå‘çŽ°å¹¶ä¸èƒ½ä½¿å¾—æŒ‡æ ‡æ˜Žæ˜¾çš„ä¸‹é™ï¼Œè¿™ä¸ªæ—¶å€™å°±è¾¾åˆ°äº†é˜ˆå€¼ã€‚æŒ‡æ ‡ï¼šä¸€ä¸ªç°‡å†…æ‰€æœ‰çš„ç‚¹åˆ°ç°‡ç±»ä¸­å¿ƒçš„è·ç¦»çš„æ€»å’Œã€‚ knn å’Œk-means çš„åŒºåˆ«ï¼Œå‰è€…æ˜¯æœ‰ç›‘ç£çš„åˆ†ç±»ç®—æ³•ï¼Œæ ¹æ®æµ‹è¯•ç‚¹å‘¨å›´k ä¸ªç‚¹çš„ç±»åˆ«ä¿¡æ¯åˆ¤æ–­è¯¥ç‚¹çš„ä¿¡æ¯ï¼›k-means æ˜¯æ— ç›‘ç£ç®—æ³•ï¼Œå±žäºŽèšç±»ä¸­çš„ä¸€ç§ã€‚]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>k-means</tag>
        <tag>knn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NLPä¸­çš„ç¢Žç¢Žå¿µ(1)]]></title>
    <url>%2F2019%2F03%2F25%2FNLP%E4%B8%AD%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[é¡¾åæ€ä¹‰ï¼Œä¸»è¦æ•´ç†ä¸€ä¸‹è‡ªå·±åœ¨æ–‡æœ¬å¤„ç†ä¸­é‡åˆ°çš„å°çš„çŸ¥è¯†ç‚¹ï¼Œæ¯”å¦‚å…³é”®è¯æå–æŠ€æœ¯ï¼Œåˆ†è¯è½¯ä»¶åŒ…çš„åŽŸç†ã€‚ å…³é”®è¯æå–TF-IDFè¿™ä¸ªæ˜¯å¯ä»¥å‚çœ‹ä¹‹å‰è‡ªå·±å†™çš„ä¸€ä¸ªåšå®¢ å¡æ–¹åˆ†å¸ƒå¡æ–¹æ£€éªŒæ˜¯ä»¥Ï‡2åˆ†å¸ƒä¸ºåŸºç¡€çš„ä¸€ç§å¸¸ç”¨å‡è®¾æ£€éªŒæ–¹æ³•ã€‚è¯¥æ£€éªŒçš„åŸºæœ¬æ€æƒ³æ˜¯ï¼šé¦–å…ˆå‡è®¾$H_0$æˆç«‹ï¼ŒåŸºäºŽæ­¤å‰æè®¡ç®—å‡ºÏ‡2å€¼ï¼Œå®ƒè¡¨ç¤ºè§‚å¯Ÿå€¼ä¸Žç†è®ºå€¼ä¹‹é—´çš„åç¦»ç¨‹åº¦ã€‚ å®˜æ–¹å®šä¹‰ï¼š è‹¥k ä¸ªéšæœºå˜é‡$Z_1$ã€â€¦â€¦ã€$Z_k $ç›¸äº’ç‹¬ç«‹ï¼Œä¸”æ•°å­¦æœŸæœ›ä¸º0ã€æ–¹å·®ä¸º 1(å³æœä»Žæ ‡å‡†æ­£æ€åˆ†å¸ƒ)ï¼Œåˆ™éšæœºå˜é‡X$$X = \sum _ { n = 1 } ^ { k } Z _ { n } ^ { 2 }$$è¢«ç§°ä¸ºæœä»Žè‡ªç”±åº¦ä¸º k çš„å¡æ–¹åˆ†å¸ƒï¼Œè®°ä½œ$$X \sim \chi ^ { 2 } ( k )$$ ä»Žç›´è§‚çš„è§’åº¦æ„Ÿå—ä¸€ä¸‹è‡ªç”±åº¦k å’Œå›¾åƒå½¢çŠ¶çš„å…³ç³»ï¼Œè‡ªç”±åº¦è¶Šå¤§å¡æ–¹åˆ†å¸ƒè¶ŠæŽ¥è¿‘æ­£å¤ªåˆ†å¸ƒã€‚ ç”¨äºŽç‰¹å¾é€‰æ‹© å¦‚æžœæ–‡ç« æ˜¯å¦åŒ…å«â€œç¯®çƒâ€œä¸Žæ–‡ç« æ˜¯å¦å±žäºŽä½“è‚²ç±»åˆ«æ˜¯ç‹¬ç«‹æ— å…³çš„ã€‚ä¸”ä¸€ä¸ªæ–°é—»æ–‡ç« å±žäºŽä½“è‚²ç±»åˆ«çš„æ¦‚çŽ‡æ˜¯0.609ï¼Œé‚£ä¹ˆå¯ä»¥å¾—åˆ°ä¸‹é¢çš„è¡¨æ ¼ã€‚å‡è®¾æ–‡ç« æ˜¯å¦åŒ…å«â€œç¯®çƒâ€œä¸Žæ–‡ç« æ˜¯å¦å±žäºŽä½“è‚²ç±»åˆ«æ˜¯ç‹¬ç«‹æ— å…³çš„ï¼Œæ‰€ä»¥ä¸ç®¡æ–‡ç« ä¸­æ˜¯ä¸æ˜¯åŒ…å«â€ç¯®çƒâ€œï¼Œå…¶å±žäºŽä½“è‚²ç±»åˆ«çš„æ¦‚çŽ‡éƒ½æ˜¯0.609ã€‚ åˆ—è”è¡¨ ç»„åˆ« ä½“è‚² éžä½“è‚² åŒ…å«â€ç¯®çƒâ€œ 44 * 0.609 = 26.8 44 * 0.391 = 17.2 ä¸åŒ…å«â€ç¯®çƒâ€œ 43 * 0.609 = 26.2 43 * 0.391 = 16.8 å¦‚æžœä¸¤ä¸ªåˆ†ç±»å˜é‡çœŸçš„æ˜¯ç‹¬ç«‹æ— å…³çš„ï¼Œé‚£ä¹ˆå››æ ¼è¡¨çš„å®žé™…å€¼ä¸Žç†è®ºå€¼å¾—å·®å€¼åº”è¯¥éžå¸¸å°ï¼ˆæœ‰å·®å€¼çš„åŽŸå› æ˜¯å› ä¸ºæŠ½æ ·è¯¯å·®ï¼‰ã€‚é‚£ä¹ˆå¦‚ä½•è¡¡é‡å®žé™…å€¼ä¸Žç†è®ºå€¼å¾—å·®å€¼å‘¢ï¼Ÿ æ­¥éª¤ ç»Ÿè®¡æ¯ä¸ªè¯çš„æ­£æ–‡æ¡£å‡ºçŽ°é¢‘çŽ‡ï¼ˆAï¼‰ã€è´Ÿæ–‡æ¡£å‡ºçŽ°é¢‘çŽ‡ï¼ˆBï¼‰ã€æ­£æ–‡æ¡£ä¸å‡ºçŽ°é¢‘çŽ‡ï¼‰ã€è´Ÿæ–‡æ¡£ä¸å‡ºçŽ°é¢‘çŽ‡ã€‚-è®¡ç®—æ¯ä¸ªè¯çš„å¡æ–¹å€¼ å°†æ¯ä¸ªè¯æŒ‰å¡æ–¹å€¼ä»Žå¤§åˆ°å°æŽ’åºï¼Œé€‰å–å‰kä¸ªè¯ä½œä¸ºç‰¹å¾ï¼Œkå³ç‰¹å¾ç»´æ•°ã€‚$$\operatorname { CHI } ( \mathrm { x } , \mathrm { y } ) = \chi ^ { 2 } ( x , y ) = \sum \frac { ( A - T ) ^ { 2 } } { T }$$è¯¥å…¬å¼å¯ä»¥è¿›ä¸€æ­¥ç®€åŒ–æˆ ï¼ˆå…¶ä¸­ x è¡¨ç¤ºä¸€ä¸ªç‰¹å¾ï¼Œy è¡¨ç¤ºçš„targetï¼‰$$\mathrm { CHI } ( \mathrm { x } , \mathrm { y } ) = \chi ^ { 2 } ( x , y ) = \frac { N ( A D - B C ) } { ( A + B ) ( A + C ) ( B + D ) ( C + D ) }$$ ç»„åˆ« ä½“è‚² éžä½“è‚² åˆè®¡ åŒ…å«â€ç¯®çƒâ€œ 34 (A) 10 (B) 44 (A+B) ä¸åŒ…å«â€ç¯®çƒâ€œ 19 (C) 24 (D) 43 (C+D) åˆè®¡ 53(A +C) 34 (B+D) 87 (N) å¡æ–¹åˆ†å¸ƒçš„ä¸´ç•Œå€¼ è‡ªç”±åº¦F = ï¼ˆè¡Œæ•° - 1ï¼‰ * ï¼ˆåˆ—æ•° - 1ï¼‰ = 1ï¼Œå¯¹äºŽå››æ ¼è¡¨ï¼ŒF = 1ã€‚ ç”±äºŽè‡ªç”±åº¦F = 1ï¼Œæ‰€ä»¥åªéœ€è¦çœ‹åˆ†å¸ƒè¡¨çš„ç¬¬ä¸€è¡Œã€‚å¯ä»¥çœ‹åˆ°ï¼Œéšç€CHIçš„å¢žå¤§ï¼ŒåŽŸå‡è®¾æˆç«‹çš„æ¦‚çŽ‡å°±è¶Šå°ã€‚å› ä¸º10.10 &gt; 6.64ï¼Œæ‰€ä»¥åŽŸå‡è®¾æˆç«‹æ˜¯æ¦‚çŽ‡æ˜¯å°äºŽ1%ã€‚åä¹‹ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼ŒåŽŸå‡è®¾ä¸æˆç«‹ï¼ˆå³ä¸¤ä¸ªåˆ†ç±»å˜é‡ä¸æ˜¯ç‹¬ç«‹æ— å…³ï¼‰çš„æ¦‚çŽ‡å¤§äºŽ99% å¦‚ä½•åº”ç”¨äºŽç‰¹å¾é€‰æ‹© CHIå€¼è¶Šå¤§ï¼Œè¯´æ˜Žä¸¤ä¸ªå˜é‡è¶Šä¸å¯èƒ½æ˜¯ç‹¬ç«‹æ— å…³çš„ï¼Œä¹Ÿå°±æ˜¯è¯´X2è¶Šå¤§ï¼Œä¸¤ä¸ªå˜é‡çš„ç›¸å…³ç¨‹åºä¹Ÿå°±è¶Šé«˜ã€‚å¯¹äºŽç‰¹å¾å˜é‡x1,x2,â€¦,xnï¼Œä»¥åŠåˆ†ç±»å˜é‡yã€‚åªéœ€è¦è®¡ç®—CHI(x1, y)ã€CHI(x2, y)ã€â€¦ã€CHI(xn, y)ï¼Œå¹¶æŒ‰ç…§CHIçš„å€¼ä»Žå¤§åˆ°å°å°†ç‰¹å¾æŽ’åºï¼Œç„¶åŽé€‰æ‹©é˜ˆå€¼ï¼Œå¤§äºŽé˜ˆå€¼çš„ç‰¹å¾ç•™ä¸‹ï¼Œå°äºŽé˜ˆå€¼çš„ç‰¹å¾åˆ é™¤ã€‚è¿™æ ·å°±ç­›é€‰å‡ºä¸€ç»„ç‰¹å¾å­é›†äº†ï¼ŒæŽ¥ç€ä½¿ç”¨è¿™ç»„ç‰¹å¾å­é›†åŽ»è®­ç»ƒåˆ†ç±»å™¨ï¼Œç„¶åŽè¯„ä¼°åˆ†ç±»å™¨çš„æ€§èƒ½ã€‚ å› ä¸ºåªè¦æ¯”è¾ƒCHIå€¼å¾—ç›¸å¯¹å¤§å°ï¼Œæ‰€ä»¥ä¸Šè¿°çš„åˆ†å¸ƒè¡¨å°±æ²¡ç”¨äº†ã€‚ ä½¿ç”¨èŒƒå›´ï¼šä¸€èˆ¬æ˜¯åœ¨ç¦»æ•£å˜é‡ä¸Šè¿›è¡Œä½¿ç”¨ã€‚ å¦å¤–ä¸€ä¸ªä¾‹å­ In the case of classification problems where input variables are also categorical, we can use statistical tests to determine whether the output variable is dependent or independent of the input variables. If independent, then the input variable is a candidate for a feature that may be irrelevant to the problem and removed from the dataset. The Pearsonâ€™s chi-squared statistical hypothesis is an example of a test for independence between categorical variables. Contingency TableFor example, the Sex=rows and Interest=columns table with contrived counts might look as follows:ä¸‹é¢æ˜¯ä¸€ä¸ªåˆ—è”è¡¨123 Science, Math, ArtMale 20, 30, 15Female 20, 15, 30 The Pearsonâ€™s Chi-Squared test, or just Chi-Squared test for short, is named for Karl Pearson, although there are variations on the test. å¦‚ä½•åŽ»è§£è¯»è¿™ç§ä¿¡æ¯ï¼Ÿ We can interpret the test statistic in the context of the chi-squared distribution with the requisite number of degress of freedom as follows: If Statistic &gt;= Critical Value: significant result, reject null hypothesis (H0), dependent.If Statistic &lt; Critical Value: not significant result, fail to reject null hypothesis (H0), independent.The degrees of freedom for the chi-squared distribution is calculated based on the size of the contingency table as: degrees of freedom: (rows - 1) * (cols - 1) In terms of a p-value and a chosen significance level (alpha), the test can be interpreted as follows: If p-value &lt;= alpha: significant result, reject null hypothesis (H0), dependent.If p-value &gt; alpha: not significant result, fail to reject null hypothesis (H0), independent.For the test to be effective, at least five observations are required in each cell of the contingency table. case studyï¼š Chi-square Test for feature selection $$X ^ { 2 } = \frac{ {(Observed frequency - Expected frequency)} ^ 2 } { Expected frequency }$$ 12345678910111213141516171819202122# Load libraries from sklearn.datasets import load_iris from sklearn.feature_selection import SelectKBest from sklearn.feature_selection import chi2 # Load iris data iris_dataset = load_iris() # Create features and target X = iris_dataset.data y = iris_dataset.target # Convert to categorical data by converting data to integers X = X.astype(int) # Two features with highest chi-squared statistics are selected chi2_features = SelectKBest(chi2, k = 2) X_kbest_features = chi2_features.fit_transform(X, y) # Reduced features print('Original feature number:', X.shape[1]) print('Reduced feature number:', X_kbest.shape[1]) Original feature number: 4Reduced feature number : 2 è€Œå®žé™…åº”ç”¨åˆ°ç‰¹å¾é€‰æ‹©ä¸­çš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¸éœ€è¦çŸ¥é“è‡ªç”±åº¦ï¼Œä¸è¦çŸ¥é“å¡æ–¹åˆ†å¸ƒï¼Œæˆ‘ä»¬åªéœ€è¦æ ¹æ®ç®—å‡ºæ¥çš„Ï‡2 è¿›è¡ŒæŽ’åºå°±å¥½äº†ï¼Œè¶Šå¤§æˆ‘ä»¬å°±è¶Šå–œæ¬¢ï¼æŒ‘é€‰æœ€å¤§çš„ä¸€å †ï¼ŒäºŽæ˜¯å°±å®Œæˆäº†åˆ©ç”¨å¡æ–¹æ£€éªŒæ¥è¿›è¡Œç‰¹å¾æå–ã€‚å¡æ–¹åˆ†å¸ƒçš„ç¼ºç‚¹ï¼šæ²¡æœ‰è€ƒè™‘è¯é¢‘ï¼Œå®ƒåªç»Ÿè®¡æ–‡æ¡£æ˜¯å¦å‡ºçŽ°è¯ï¼Œè€Œä¸ç®¡å‡ºçŽ°äº†å‡ æ¬¡ã€‚è¿™ä¼šä½¿å¾—ä»–å¯¹ä½Žé¢‘è¯æœ‰æ‰€åè¢’ï¼ˆå› ä¸ºå®ƒå¤¸å¤§äº†ä½Žé¢‘è¯çš„ä½œç”¨ï¼‰ã€‚ å‚è€ƒä¸€å‚è€ƒäºŒ CBOWå’Œskip-gramä¸¾ä¸€ä¸ªç®€å•çš„å°ä¾‹å­è¯´æ˜Ž CBOWå’Œskip-gramçš„åŒºåˆ«ï¼šskip-gram æ˜¯æ ¹æ®ä¸­å¿ƒè¯æ±‡ç„¶åŽé¢„æµ‹ä¸Šä¸‹æ–‡è¯æ±‡ï¼Œè¿™ä¸ªä¸æ˜¯ä¸€ä¸‹å­è¾“å…¥ä¸Šä¸‹æ–‡è¯æ±‡çš„ï¼Œè€Œæ˜¯ä¸€ä¸ªè¿‡ç¨‹ï¼Œä¸­å¿ƒè¯æ±‡å’Œä¸Šä¸‹æ–‡è¯æ±‡1 ï¼Œä¸­å¿ƒè¯æ±‡å’Œä¸Šä¸‹æ–‡è¯æ±‡2ï¼Œè¿™æ ·çš„è¿›è¡Œè¾“å…¥ã€‚ cbow å’Œå…¶çš„åŒºåˆ«ï¼Œåœ¨äºŽç®€å•ç›¸åŠ äº†ä¸Šä¸‹æ–‡è¯æ±‡ä½œä¸ºä¸€ä¸ªæ•´ä½“ï¼Œç„¶åŽå’Œä¸­å¿ƒè¯æ±‡è¿›è¡Œè¾“å…¥ï¼Œæ‰€ä»¥æœ€åŽæ˜¯è¿™æ ·çš„ç»“æžœã€‚ ä½¿ç”¨skip gramè®­ç»ƒçš„æ—¶é—´æ›´é•¿ï¼Œä½†æ˜¯å¯¹äºŽå‡ºçŽ°é¢‘çŽ‡ä¸é«˜çš„è¯æ±‡ï¼Œæ•ˆæžœæ¯”è¾ƒå¥½ã€‚ä½†CBOWçš„è®­ç»ƒé€Ÿåº¦æ˜¯ç›¸å¯¹æ¥è¯´æ¯”è¾ƒå¿«ä¸€äº›ã€‚ åˆ†è¯è½¯ä»¶å¸¸è§çš„ä¸­æ–‡åˆ†è¯æœåŠ¡ åˆ†è¯æœåŠ¡ å¼€æº/å•†ä¸š æ”¯æŒè¯­è¨€ è¯æ€§æ ‡æ³¨ å‘½åå®žä½“è¯†åˆ« jieba å¼€æº Python, Java, C++ æ—  æ—  HanLP å¼€æº Pythonï¼ŒJavaï¼Œ C++ æœ‰ æœ‰ StandFord CoreNLP å¼€æº Java ç™¾åº¦NLP å•†ä¸š é˜¿é‡ŒNLP å•†ä¸š Stanford NLPæ˜¯ç”±æ–¯å¦ç¦å¤§å­¦çš„ NLP å°ç»„å¼€æºçš„ Java å®žçŽ°çš„ NLP å·¥å…·åŒ…ã€‚å¯ä»¥ä½¿ç”¨python è°ƒç”¨ Stanford NLP è¿›è¡Œä¸­æ–‡åˆ†è¯ HanLPæ˜¯ç”±ä¸€ç³»åˆ—æ¨¡åž‹ä¸Žç®—æ³•ç»„æˆçš„Javaå·¥å…·åŒ…ã€‚ä¹Ÿå¯ä»¥ä½¿ç”¨Pythonè°ƒç”¨HanLPè¿›è¡Œä¸­æ–‡åˆ†è¯ã€‚ ç»“å·´åˆ†è¯çš„ç®—æ³•ç­–ç•¥ åŸºäºŽå‰ç¼€è¯å…¸å®žçŽ°é«˜æ•ˆçš„è¯å›¾æ‰«æï¼Œç”Ÿæˆå¥å­ä¸­æ±‰å­—æ‰€æœ‰å¯èƒ½æˆè¯æƒ…å†µæ‰€æž„æˆçš„æœ‰å‘æ— çŽ¯å›¾ (DAG) é‡‡ç”¨äº†åŠ¨æ€è§„åˆ’æŸ¥æ‰¾æœ€å¤§æ¦‚çŽ‡è·¯å¾„, æ‰¾å‡ºåŸºäºŽè¯é¢‘çš„æœ€å¤§åˆ‡åˆ†ç»„åˆ å¯¹äºŽæœªç™»å½•è¯ï¼Œé‡‡ç”¨äº†åŸºäºŽæ±‰å­—æˆè¯èƒ½åŠ›çš„ HMM æ¨¡åž‹ï¼Œä½¿ç”¨äº† Viterbi ç®—æ³• å¦‚æžœæƒ³æ›´åŠ è¯¦ç»†çš„äº†è§£è¿™ç§ç­–ç•¥ï¼Œå¯ä»¥å‚è€ƒè¿™é‡Œ. ä¸­æ–‡åˆ†è¯ä¸»è¦æŽŒæ¡è§„åˆ™çš„åˆ†è¯æ–¹æ³•ï¼ˆé€†å‘æœ€å¤§åŒ¹é…æ³•ï¼ˆè¯¥æ–¹æ³•æ˜¯ä¼˜äºŽæ­£å‘çš„ï¼‰ã€æœ‰ä¸ªè¯é¢‘-å†…è¿ž-å¤– çš„åˆ†è¯ç®—æ³•ï¼Œ æ€»å…±ä¸¤ç§ç®—æ³•å°±å¯ä»¥äº†ï¼‰ ä¸­æ–‡åˆ†è¯çš„å›°éš¾ä¸»è¦ä½“çŽ°åœ¨ï¼šæ­§ä¹‰è¯çš„åˆ‡åˆ†å’Œæœªç™»å½•è¯è¯†åˆ«ã€‚å…¶ä¸­åŽè€…çš„å½±å“è¦è¿œè¿œå¤§äºŽå‰è€…çš„å½±å“ã€‚ ä¸‹é¢æ˜¯å¸¸è§çš„åˆ†è¯æ–¹å¼ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰è¯´æ˜Žå“ªä¸ªè½¯ä»¶æ˜¯ä»€ä¹ˆåˆ†è¯æ–¹æ³•ã€‚ï¼ˆéœ€è¦æŽŒæ¡ä¸¤ç§åˆ†è¯çš„æ–¹å¼ï¼Œä¸€ç§æ˜¯åŸºäºŽè¯å…¸çš„é€†å‘æœ€å¤§åŒ¹é…ï¼Œä¸€ç§æ˜¯åŽé¢æ–°è¯å‘çŽ°ä¸­çš„åŸºäºŽç»Ÿè®¡çš„ä¿¡æ¯ç†µç®—æ³•ï¼‰ åŸºäºŽè§„åˆ™çš„åˆ†è¯æ–¹æ³• è¿™ç§æ–¹æ³•åˆå«ä½œæœºæ¢°åˆ†è¯æ–¹æ³•ã€åŸºäºŽå­—å…¸çš„åˆ†è¯æ–¹æ³•ï¼Œå®ƒæ˜¯æŒ‰ç…§ä¸€å®šçš„ç­–ç•¥å°†å¾…åˆ†æžçš„æ±‰å­—ä¸²ä¸Žä¸€ä¸ªâ€œå……åˆ†å¤§çš„â€æœºå™¨è¯å…¸ä¸­çš„è¯æ¡è¿›è¡ŒåŒ¹é…ï¼Œæ¯”å¦‚è¯´æ­£å‘æœ€å¤§åŒ¹é…æ³•ã€é€†å‘æœ€å¤§åŒ¹é…æ³• åŸºäºŽç»Ÿè®¡çš„åˆ†è¯æ–¹æ³• è¯¥æ–¹æ³•çš„ä¸»è¦æ€æƒ³ï¼šè¯æ˜¯ç¨³å®šçš„ç»„åˆï¼Œå› æ­¤åœ¨ä¸Šä¸‹æ–‡ä¸­ï¼Œç›¸é‚»çš„å­—åŒæ—¶å‡ºçŽ°çš„æ¬¡æ•°è¶Šå¤šï¼Œå°±è¶Šæœ‰å¯èƒ½æž„æˆä¸€ä¸ªè¯ã€‚å› æ­¤å­—ä¸Žå­—ç›¸é‚»å‡ºçŽ°çš„æ¦‚çŽ‡æˆ–é¢‘çŽ‡èƒ½è¾ƒå¥½åœ°åæ˜ æˆè¯çš„å¯ä¿¡åº¦ã€‚å¯ä»¥å¯¹è®­ç»ƒæ–‡æœ¬ä¸­ç›¸é‚»å‡ºçŽ°çš„å„ä¸ªå­—çš„ç»„åˆçš„é¢‘åº¦è¿›è¡Œç»Ÿè®¡ï¼Œè®¡ç®—å®ƒä»¬ä¹‹é—´çš„äº’çŽ°ä¿¡æ¯ã€‚äº’çŽ°ä¿¡æ¯ä½“çŽ°äº†æ±‰å­—ä¹‹é—´ç»“åˆå…³ç³»çš„ç´§å¯†ç¨‹åº¦ã€‚å½“ç´§å¯†ç¨‹ åº¦é«˜äºŽæŸä¸€ä¸ªé˜ˆå€¼æ—¶ï¼Œä¾¿å¯ä»¥è®¤ä¸ºæ­¤å­—ç»„å¯èƒ½æž„æˆäº†ä¸€ä¸ªè¯ã€‚è¯¥æ–¹æ³•åˆç§°ä¸ºæ— å­—å…¸åˆ†è¯ã€‚ æ¯”å¦‚è¯´CRF ç®—æ³•ã€‚ åŸºäºŽè¯­ä¹‰çš„åˆ†è¯æ–¹æ³• è¯­ä¹‰åˆ†è¯æ³•å¼•å…¥äº†è¯­ä¹‰åˆ†æžï¼Œå¯¹è‡ªç„¶è¯­è¨€è‡ªèº«çš„è¯­è¨€ä¿¡æ¯è¿›è¡Œæ›´å¤šçš„å¤„ç†ï¼Œå¦‚æ‰©å……è½¬ç§»ç½‘ç»œæ³•ã€çŸ¥è¯†åˆ†è¯è¯­ä¹‰åˆ†æžæ³•ã€é‚»æŽ¥çº¦æŸæ³•ã€ç»¼åˆåŒ¹é…æ³•ã€åŽç¼€åˆ†è¯æ³•ã€ç‰¹å¾è¯åº“æ³•ã€çŸ©é˜µçº¦æŸæ³•ã€è¯­æ³•åˆ†æžæ³•ç­‰ã€‚ é€†å‘æœ€å¤§åŒ¹é…åˆ†è¯æ˜¯ä¸­æ–‡åˆ†è¯åŸºæœ¬ç®—æ³•ä¹‹ä¸€ï¼Œå› ä¸ºæ˜¯æœºæ¢°åˆ‡åˆ†ï¼Œæ‰€ä»¥å®ƒä¹Ÿæœ‰åˆ†è¯é€Ÿåº¦å¿«çš„ä¼˜ç‚¹ï¼Œä¸”é€†å‘æœ€å¤§åŒ¹é…åˆ†è¯æ¯”èµ·æ­£å‘æœ€å¤§åŒ¹é…åˆ†è¯æ›´ç¬¦åˆäººä»¬çš„è¯­è¨€ä¹ æƒ¯ã€‚é€†å‘æœ€å¤§åŒ¹é…åˆ†è¯éœ€è¦åœ¨å·²æœ‰è¯å…¸çš„åŸºç¡€ä¸Šï¼Œä»Žè¢«å¤„ç†æ–‡æ¡£çš„æœ«ç«¯å¼€å§‹åŒ¹é…æ‰«æï¼Œæ¯æ¬¡å–æœ€æœ«ç«¯çš„iä¸ªå­—ç¬¦ï¼ˆåˆ†è¯æ‰€ç¡®å®šçš„é˜ˆå€¼iï¼‰ä½œä¸ºåŒ¹é…å­—æ®µï¼Œè‹¥åŒ¹é…å¤±è´¥ï¼Œåˆ™åŽ»æŽ‰åŒ¹é…å­—æ®µæœ€å‰é¢çš„ä¸€ä¸ªå­—ï¼Œç»§ç»­åŒ¹é…ã€‚è€Œä¸”é€‰æ‹©çš„é˜ˆå€¼è¶Šå¤§ï¼Œåˆ†è¯è¶Šæ…¢ï¼Œä½†å‡†ç¡®æ€§è¶Šå¥½ã€‚è¿™ç§æ–¹æ³•ç»å¸¸è¢«ç”¨æ¥è§£å†³æ­§ä¹‰è¯çš„é—®é¢˜ï¼Œæ‰€ä»¥å•ç‹¬è¯´ä¸€ä¸‹ã€‚ ç®—æ³•ï¼šäº‹å…ˆè®¾ç½®ä¸€ä¸ªkå€¼ï¼Œä¸‹é¢çš„ç¨‹åºkå€¼è®¾ä¸º5ï¼Œç„¶åŽä»Žæœ€åŽä¸€ä¸ªå­—å¼€å§‹å‘å‰æˆªå–kä¸ªå­—ï¼Œå…ˆæŠŠè¿™kä¸ªå­—å’Œå­—å…¸åŒ¹é…ï¼Œçœ‹èƒ½å¦æ‰¾åˆ°åŒ¹é…çš„è¯è¯­ï¼Œè‹¥ä¸èƒ½ï¼Œåˆ™å‰”é™¤è¿™kä¸ªå­—æœ€å·¦è¾¹çš„å­—ï¼Œç„¶åŽå†æŠŠè¿™k-1ä¸ªå­—ä¸Žå­—å…¸åŒ¹é…â€¦ä¸€ç›´åˆ°åŒ¹é…æˆåŠŸï¼Œæˆ–è€…å‰k-1ä¸ªå­—éƒ½æ²¡åŒ¹é…æˆåŠŸï¼Œé‚£å°±æŠŠç¬¬kä¸ªå­—å½“æˆä¸€ä¸ªç‹¬ç«‹çš„è¯ï¼Œç„¶åŽå†å‘å‰ç§»åŠ¨åˆ†å‡ºæ¥çš„è¯çš„é•¿åº¦ï¼Œå†æˆªå–kä¸ªå­—â€¦â€¦ä¸€ç›´åˆ°å…¨éƒ¨åˆ†å¥½è¯ä¸ºæ­¢ã€‚â€œæˆ‘çˆ±åŒ—äº¬å¤©å®‰é—¨â€ å…ˆä»ŽåŽé¢å¼€å§‹æˆªå–k(è¿™é‡Œæ˜¯5)ä¸ªå­—ï¼Œç„¶åŽæŠŠâ€åŒ—äº¬å¤©å®‰é—¨â€äº”ä¸ªå­—ä¸Žå­—å…¸åŒ¹é…ï¼Œå­—å…¸ä¸­æ²¡æœ‰è¿™ä¸ªè¯ï¼Œç„¶åŽå°±åŽ»æŽ‰â€åŒ—â€å­—ï¼ŒæŠŠå‰©ä¸‹çš„â€äº¬å¤©å®‰é—¨â€ä¸Žå­—å…¸åŒ¹é…ï¼Œå­—å…¸ä¸­è¿˜æ˜¯æ²¡æœ‰è¿™ä¸ªè¯ï¼Œå†åŽ»æŽ‰â€äº¬â€ï¼Œç„¶åŽå†æŠŠâ€å¤©å®‰é—¨â€ä¸Žå­—å…¸åŒ¹é…ï¼Œå‘çŽ°åŒ¹é…åˆ°äº†è¿™ä¸ªè¯ï¼ŒäºŽæ˜¯å°±æŠŠâ€å¤©å®‰é—¨â€åˆ’ä¸ºä¸€ä¸ªè¯è¯­ï¼Œç„¶åŽæŒ‡é’ˆå‘å‰ç§»åŠ¨ä¸‰ä¸ªå­—ã€‚å†æˆªå–kä¸ªå­—ï¼Œè¿™é‡Œå› ä¸ºå°±å‰©ä¸‹4ä¸ªå­—äº†ï¼Œæ‰€ä»¥å°±æˆªå–4ä¸ªå­—ï¼ŒæŠŠâ€æˆ‘çˆ±åŒ—äº¬â€ä¸Žå­—å…¸åŒ¹é…ï¼Œæ²¡æˆåŠŸï¼ŒåŽ»æŽ‰â€æˆ‘â€ï¼Œå†æŠŠâ€çˆ±åŒ—äº¬â€ä¸Žå­—å…¸åŒ¹é…ï¼Œè¿˜æ˜¯æ²¡æˆåŠŸï¼Œå†åŽ»æŽ‰â€çˆ±â€ï¼Œç„¶åŽå‘çŽ°â€åŒ—äº¬â€åŒ¹é…æˆåŠŸï¼ŒæŠŠâ€åŒ—äº¬â€åˆ’ä¸ºä¸€ä¸ªè¯è¯­ï¼Œå†æŠŠæŒ‡é’ˆå‘å‰ç§»åŠ¨ä¸¤ä¸ªå­—ï¼Œ CRFç®—æ³•åŸºæœ¬æ€è·¯æ˜¯å¯¹æ±‰å­—è¿›è¡Œæ ‡æ³¨è®­ç»ƒï¼Œä¸ä»…è€ƒè™‘äº†è¯è¯­å‡ºçŽ°çš„é¢‘çŽ‡ï¼Œè¿˜è€ƒè™‘ä¸Šä¸‹æ–‡ï¼Œå…·å¤‡è¾ƒå¥½çš„å­¦ä¹ èƒ½åŠ›ï¼Œå› æ­¤å…¶å¯¹æ­§ä¹‰è¯å’Œæœªç™»å½•è¯çš„è¯†åˆ«éƒ½å…·æœ‰è‰¯å¥½çš„æ•ˆæžœã€‚ è¿‘å¹´æ¥ï¼Œéšç€ç¡¬ä»¶è®¡ç®—èƒ½åŠ›çš„å‘å±•ä»¥åŠè¯çš„åˆ†å¸ƒå¼è¡¨ç¤ºï¼ˆword embeddingï¼‰çš„æå‡ºï¼Œç¥žç»ç½‘ç»œå¯ä»¥æœ‰æ•ˆå¤„ç†è®¸å¤šNLPä»»åŠ¡ã€‚è¿™ç±»æ–¹æ³•å¯¹äºŽåºåˆ—æ ‡æ³¨ä»»åŠ¡ï¼ˆå¦‚CWSã€POSã€NERï¼‰çš„å¤„ç†æ–¹å¼æ˜¯ç±»ä¼¼çš„ï¼šå°†tokenä»Žç¦»æ•£one-hotè¡¨ç¤ºæ˜ å°„åˆ°ä½Žç»´ç©ºé—´ä¸­æˆä¸ºç¨ å¯†çš„embeddingï¼ŒéšåŽå°†å¥å­çš„embeddingåºåˆ—è¾“å…¥åˆ°RNNä¸­ï¼Œç”¨ç¥žç»ç½‘ç»œè‡ªåŠ¨æå–ç‰¹å¾ï¼ŒSoftmaxæ¥é¢„æµ‹æ¯ä¸ªtokençš„æ ‡ç­¾ã€‚è¿™ç§æ–¹æ³•ä½¿å¾—æ¨¡åž‹çš„è®­ç»ƒæˆä¸ºä¸€ä¸ªç«¯åˆ°ç«¯çš„è¿‡ç¨‹ï¼Œè€Œéžä¼ ç»Ÿçš„pipeline ï¼ˆç®¡é“ï¼ŒæŒ‡çš„æ˜¯ä¸€ä¸ªåŒ…å«å¤šæ­¥éª¤çš„æµæ°´å¼çš„å·¥ä½œï¼‰ï¼Œä¸ä¾èµ–äºŽç‰¹å¾å·¥ç¨‹ï¼Œæ˜¯ä¸€ç§æ•°æ®é©±åŠ¨çš„æ–¹æ³•ï¼Œä½†ç½‘ç»œç§ç±»ç¹å¤šã€å¯¹å‚æ•°è®¾ç½®ä¾èµ–å¤§ï¼Œæ¨¡åž‹å¯è§£é‡Šæ€§å·®ã€‚ æŽ¨èåšå®¢è®²è§£ CRFç®—æ³•ï¼Œåæ­£æˆ‘æ˜¯æ²¡æœ‰çœ‹æ‡‚ï¼Œå“ˆå“ˆå“ˆã€‚ã€ä¸­æ–‡åˆ†è¯ã€‘æ¡ä»¶éšæœºåœºCRF, æµ…è°ˆåˆ†è¯ç®—æ³•ï¼ˆ4ï¼‰åŸºäºŽå­—çš„åˆ†è¯æ–¹æ³•ï¼ˆCRFï¼‰ å’Œ CRFç®—æ³•å­¦ä¹ â€”â€”è‡ªå·±åŠ¨æ‰‹å®žçŽ°ä¸€ä¸ªç®€å•çš„CRFåˆ†è¯ åˆ†è¯ç²’åº¦ç›®å‰ï¼Œåˆ†è¯ä¸»è¦åŒ…å«ç»†ç²’åº¦åˆ†è¯å’Œç²—ç²’åº¦åˆ†è¯ä¸¤ç§ï¼Œåœ¨ä¸åŒçš„åº”ç”¨åœºæ™¯éœ€è¦ç”¨åˆ°ä¸åŒçš„ç²’åº¦ã€‚ç»†ç²’åº¦åˆ†è¯æ˜¯æŒ‡å°†åŽŸå§‹è¯­å¥åˆ‡åˆ†æˆæœ€åŸºæœ¬çš„è¯è¯­ï¼Œè€Œç²—ç²’åº¦åˆ†è¯æ˜¯æŒ‡å°†åŽŸå§‹è¯­å¥ä¸­çš„å¤šä¸ªåŸºæœ¬è¯ç»„åˆèµ·æ¥åˆ‡æˆä¸€ä¸ªè¯ï¼Œè¿›è€Œç»„æˆè¯­ä¹‰ç›¸å¯¹æ˜Žç¡®çš„å®žä½“ã€‚ åŽŸå§‹ä¸²ï¼šæµ™æ±Ÿå¤§å­¦åè½åœ¨è¥¿æ¹–æ—è¾¹ ç»†ç²’åº¦ï¼šæµ™æ±Ÿ/å¤§å­¦/åè½/åœ¨/è¥¿æ¹–/æ—è¾¹ ç²—ç²’åº¦ï¼šæµ™æ±Ÿå¤§å­¦/åè½/åœ¨/è¥¿æ¹–/æ—è¾¹ ä¸¾ä¾‹è¯´æ˜Žåˆ†è¯ç²’åº¦å’Œåº”ç”¨åœºæ™¯ï¼šå¯¹äºŽqueryä¸ºâ€œè€å…‹éž‹â€æ¥è¯´ï¼Œè¯å…¸ä¸­æ˜¯åŒ…å«è¿™ä¸ªå®žä½“è¯çš„ï¼Œåˆ†è¯çš„åˆ‡åˆ†ç»“æžœå°±æ˜¯â€œè€å…‹éž‹â€ã€‚ä½†æ˜¯ï¼Œè€ƒæ‹‰ç”¨æ¥å»ºç´¢å¼•çš„å•†å“æè¿°ä¸­ï¼Œè¿™ä¸‰ä¸ªå­—æ˜¯æ²¡æœ‰è¿žç»­å‡ºçŽ°çš„ï¼Œè‡ªç„¶å°±æ²¡æœ‰â€œè€å…‹éž‹â€å¯¹åº”çš„æ–‡æ¡£ï¼Œè¿™ä¸ªæ—¶å€™å°±æ— æ³•å¬å›žç»“æžœã€‚é‚£ä¹ˆï¼Œè¿™æ—¶å€™ä½ ä¼šè¯´é‚£å°±ä½¿ç”¨æœ€å°ç²’åº¦çš„åˆ†è¯å°±è§£å†³è¿™ä¸ªé—®é¢˜äº†ã€‚ç›¸åï¼ŒæŸä¸€æ¬¾å•†å“å¯èƒ½æœ‰â€œå‚æ•°è¡¨â€è¿™ä¸‰ä¸ªå­—ï¼Œå¦‚æžœæœ‰æœ€å°ç²’åº¦çš„åˆ†è¯ç­–ç•¥ï¼Œåˆ†è¯çš„ç»“æžœä¸ºâ€œå‚æ•°/è¡¨â€ã€‚å¾ˆä¸å¹¸ï¼Œå½“queryä¸ºâ€œè¡¨â€æ—¶ï¼Œä½ ä¼šå‘çŽ°ä¼šå¬å›žèŽ«åå…¶å¦™çš„ç»“æžœã€‚ä¸€èˆ¬æ¥è¯´ï¼Œæ˜¯ä½¿ç”¨è¯é¢‘è¡¨æ¥è¿›è¡Œç²’åº¦æŽ§åˆ¶ï¼ŒåŸºæœ¬å¯ä»¥è§£å†³ç»å¤§å¤šæ•°é—®é¢˜ã€‚ æœç´¢å¼•æ“Žå±•çŽ°ä¸Žç²’åº¦ï¼šæ˜¾è€Œæ˜“è§ï¼Œç²’åº¦è¶Šå°ï¼Œå±•çŽ°å°±è¶Šå¤šï¼Œå»ºç«‹å€’æŽ’ç´¢å¼•æ—¶ï¼Œç´¢å¼•çš„é•¿åº¦å°±è¶Šé•¿;ç²’åº¦çš„å±‚æ¬¡è¶Šå¤šï¼Œç´¢å¼•çš„æ•°é‡å°±è¶Šå¤šã€‚ä¸€ä¸ªå¤šï¼Œä¸€ä¸ªé•¿ï¼Œå°±å¯¹æœç´¢ç³»ç»Ÿçš„æ€§èƒ½æž„æˆäº†æžå¤§çš„è€ƒéªŒã€‚æœç´¢å¼•æ“Žå¹¶ä¸ä¼šå¯¹æ‰€æœ‰å°ç²’åº¦è¯éƒ½å»ºç´¢å¼•ï¼Œè€Œæ˜¯é€‰æ‹©â€œæ›´æœ‰å¯èƒ½å±•çŽ°ç›¸å…³ç»“æžœâ€çš„å°ç²’åº¦è¯ã€‚æ‰€ä»¥åœ¨ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œåˆ‡åˆ†æ–‡æœ¬ç²’åº¦è¶Šå¤§ï¼Œç´¢å¼•è¶Šå¤šï¼Œç›¸å…³æ€§è¶Šå¥½ï¼Œä½†å±•çŽ°è¶Šå°‘;åˆ‡åˆ†æ–‡æœ¬ç²’åº¦è¶Šå°ï¼Œç´¢å¼•è¶Šå°‘ï¼Œç›¸å…³æ€§è¶Šå·®ï¼Œä½†å±•çŽ°è¶Šå¥½ã€‚ è¯é¢‘å†³å®šåˆ†è¯ç²’åº¦ï¼šå…·ä½“ç®—æ³•æ˜¯ï¼Œå½“å‘çŽ°ä¸€ä¸ªç”±å¤šä¸ªçŸ­è¯ç»„æˆçš„é•¿è¯æ—¶ï¼Œåˆ¤æ–­æ¯ä¸ªçŸ­è¯ä¸­æœ€å°çš„è¯é¢‘ï¼Œå¦‚æžœè¿™ä¸ªè¯é¢‘è¿˜æ˜¯å¤§äºŽé•¿è¯çš„è¯é¢‘ï¼Œåˆ™æŒ‰è¯¥ç»„åˆè¿›è¡Œæ‹†åˆ†ã€‚å¦‚æžœå¤šç§ç»„åˆï¼ŒæŒ‰è¯é¢‘æœ€å¤§çš„ç»„åˆæ‹†åˆ†ã€‚å¦‚ä¸Šé¢ä¾‹å­ï¼Œâ€ä¸­å¤®é¥­åº—â€ï¼Œä¸­å¤®çš„è¯é¢‘ä¸º1000ï¼Œé¥­åº—ä¸º900,é¥­ä¸º200,åº—ä¸º600ï¼Œè€Œä¸­å¤®é¥­åº—ä¸º500 ã€‚ OOVé—®é¢˜ç”±æ¥ï¼šç”±äºŽè¯é¢‘è¿‡å°è¢«æ›¿æ¢æˆäº† UNK token æˆ–è€…æ˜¯åœ¨åŽŸå§‹çš„è®­ç»ƒæ•°æ®é›†ä¸­æ²¡æœ‰å‡ºçŽ°è€Œåœ¨æµ‹è¯•é›†ä¸­å‡ºçŽ°äº†ã€‚ å¸¸è§çš„è§£å†³æ–¹æ¡ˆï¼š subword (n-gram ) åˆ†å­—å’Œè¯è¯­ä¸¤ä¸ªç»´åº¦ã€‚è¥¿æ¬§è¯­ç³»ä¸­æ˜¯æœ‰å­—ç»´åº¦ï¼Œåœ¨ä¸­æ–‡ä¸­æ²¡æœ‰ã€‚å¯¹äºŽè¥¿æ¬§è¯­ç³»çš„è¯æ±‡ï¼Œæ˜¯å¯ä»¥é€šè¿‡ n-gramï¼›å¦‚æžœæŽ¨å¹¿åˆ°ä¸­æ–‡ï¼Œé‚£ä¹ˆæ›´åŠ åˆé€‚ä½¿ç”¨åˆ†è¯ä¹‹åŽçš„ç»“æžœä½œä¸ºä¸€ä¸ª wordï¼Œç„¶åŽæ¯ä¸ªå­—ä½œä¸ºä¸€ä¸ªgramåœ¨è®­ç»ƒè¿‡ç¨‹ä¸­ï¼Œæ¯ä¸ªn-graméƒ½ä¼šå¯¹åº”è®­ç»ƒä¸€ä¸ªå‘é‡ï¼Œè€ŒåŽŸæ¥å®Œæ•´å•è¯çš„è¯å‘é‡å°±ç”±å®ƒå¯¹åº”çš„æ‰€æœ‰n-gramçš„å‘é‡æ±‚å’Œå¾—åˆ°ã€‚æ‰€æœ‰çš„å•è¯å‘é‡ä»¥åŠå­—ç¬¦çº§åˆ«çš„n-gramå‘é‡ä¼šåŒæ—¶ç›¸åŠ æ±‚å¹³å‡ä½œä¸ºè®­ç»ƒæ¨¡åž‹çš„è¾“å…¥ã€‚ä¼˜ç‚¹ï¼šè§£å†³äº† ä½Žé¢‘è¯ oov é—®é¢˜ï¼›ç¼ºç‚¹ï¼šéœ€è¦ä¼°è®¡çš„å‚æ•°é‡å˜å¤š transfer learning (fine tune) ä½¿ç”¨ context embedding åŽ»è¡¨ç¤ºç¼ºçœçš„ ä¸­å¿ƒè¯ï¼ˆoovï¼‰ æ–‡çŒ® æ–°è¯å‘çŽ°è¯¥ç®—æ³•æœ€ä¸»è¦æ˜¯åŸºäºŽäº’ä¿¡æ¯å’Œå·¦å³ç†µçš„è®¡ç®—è§„åˆ™ï¼Œè€Œè¿™ä¸¤ä¸ªæ¦‚å¿µéƒ½æ˜¯å‡ºè‡ªä¿¡æ¯è®ºçš„èŒƒç•´ï¼Œå…¶ä¸€è€…ç§°å†…éƒ¨å‡å’Œåº¦ï¼Œå…¶äºŒè€…ç§°å¤–éƒ¨è‡ªç”±åº¦æˆ–è€…è¾¹ç•Œè‡ªç”±åº¦ã€‚åœ¨ä¸­æ–‡åˆ†è¯çš„ä¸–ç•Œé‡Œï¼Œæœ€ä¸»è¦çš„æŒ‘æˆ˜æœ‰ä¸¤ä¸ªï¼šæ­§ä¹‰è¯è¯†åˆ«ï¼Œæœªç™»å½•è¯ï¼ˆæ–°è¯ï¼‰è¯†åˆ«ã€‚å¯¹äºŽæ­§ä¹‰è¯ç®€å•è¯´ä¸€ä¸‹ï¼Œæ¯”å¦‚â€œä¹’ä¹“çƒæ‹å–å®Œäº†â€ï¼Œåˆ‡åˆ†ä¸ºä»¥ä¸‹ä¸¤ç§æƒ…å†µéƒ½æ˜¯åˆç†çš„ï¼Œâ€œä¹’ä¹“çƒæ‹/å–/å®Œäº†â€ï¼Œâ€œä¹’ä¹“çƒ/æ‹å–/å®Œäº†â€ã€‚è¿™ä¸ªå°±æ˜¯å…¸åž‹çš„æ­§ä¹‰è¯ã€‚è€Œå¤„ç†è¿™ç§é—®é¢˜å¸¸ç”¨çš„ä¸€ç§æ‰‹æ®µæ˜¯ä½¿ç”¨é€†å‘æœ€å¤§åŒ¹é…æ³•åŽ»å¤„ç†æ­§ä¹‰è¯ï¼Œç”±äºŽæ±‰è¯­ä¸­åæ­£ç»“æž„è¾ƒå¤šï¼Œè‹¥ä»ŽåŽå‘å‰åŒ¹é…ï¼Œå¯ä»¥é€‚å½“æé«˜ç²¾ç¡®åº¦ã€‚æ¯”å¦‚å–å‡ºâ€œå—äº¬å¸‚é•¿æ±Ÿå¤§æ¡¥â€çš„åŽå››ä¸ªå­—â€œé•¿æ±Ÿå¤§æ¡¥â€ï¼Œå‘çŽ°è¯å…¸ä¸­æœ‰åŒ¹é…ï¼Œåˆ‡å‰²ä¸‹æ¥ï¼›å¯¹å‰©ä½™çš„â€œå—äº¬å¸‚â€è¿›è¡Œåˆ†è¯ï¼Œæ•´ä½“ç»“æžœä¸ºï¼šâ€œå—äº¬å¸‚/é•¿æ±Ÿå¤§æ¡¥â€ã€‚ æ–°è¯å¯¹æœ€åŽç»“æžœçš„å½±å“ç¨‹åº¦æ˜¯å¤§äºŽæ­§ä¹‰è¯ï¼ˆ20å€å·¦å³å§ï¼‰ã€‚ soï¼Œè¿™é‡Œä¸»è¦è®²çš„æ˜¯æ–°è¯çš„å‘çŽ° è€Œéžå¤„ç†æ­§ä¹‰è¯çš„è¯†åˆ«ã€‚ ä¸­è‹±æ–‡åˆ†è¯çš„åŒºåˆ« åˆ†è¯ / è¯å¹²æå–å’Œè¯å½¢è¿˜åŽŸã€‚ ä¸­æ–‡å’Œè‹±æ–‡çš„nlpå„æœ‰å„çš„éš¾ç‚¹ï¼Œä¸­æ–‡çš„éš¾ç‚¹åœ¨äºŽéœ€è¦è¿›è¡Œåˆ†è¯ï¼Œå°†ä¸€ä¸ªä¸ªå¥å­åˆ†è§£æˆä¸€ä¸ªå•è¯æ•°ç»„ã€‚è€Œè‹±æ–‡è™½ç„¶ä¸éœ€è¦åˆ†è¯ï¼Œä½†æ˜¯è¦å¤„ç†å„ç§å„æ ·çš„æ—¶æ€ï¼Œæ‰€ä»¥è¦è¿›è¡Œè¯å¹²æå–å’Œè¯å½¢è¿˜åŽŸã€‚æ¯”å¦‚ è¯å¹²æå–ä¸»è¦é‡‡å–â€œç¼©å‡â€çš„æ–¹å¼ï¼Œâ€œcatsâ€ å¤„ç†ä¸º â€œcatâ€ï¼Œ å°†â€œeffectiveâ€ å¤„ç†ä¸ºâ€œeffectâ€ï¼› è¯æ€§è¿˜åŽŸä¸»è¦é‡‡å–è½¬å˜çš„æ–¹å¼ï¼Œâ€œdroveâ€ å¤„ç†æˆâ€œdriveâ€ï¼Œ å°†â€œdrivingâ€ å¤„ç†æˆâ€œdriveâ€ã€‚ å¯¹äºŽä¸­æ–‡ï¼Œä¸€ä¸ªWordå¯ä»¥æ˜¯ä¸€ä¸ªå•è¯ï¼Œä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªè¯ã€‚ åˆ†è¯çš„é‡è¦æ€§ åœ¨å¤„ç†æ–‡æœ¬å¯¹è±¡æ—¶ï¼Œéžå¸¸å…³é”®çš„é—®é¢˜åœ¨äºŽâ€œåˆ‡è¯â€è¿™ä¸ªçŽ¯èŠ‚ï¼Œå‡ ä¹Žæ‰€æœ‰çš„åŽç»­ç»“æžœéƒ½ä¾èµ–ç¬¬ä¸€æ­¥çš„åˆ‡è¯ã€‚å› æ­¤åˆ‡è¯çš„å‡†ç¡®æ€§åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šå½±å“ç€åŽç»­çš„å¤„ç†ï¼Œåˆ‡è¯ç»“æžœçš„ä¸åŒï¼Œä¹Ÿå°±å½±å“äº†ç‰¹å¾çš„æå–ï¼Œè·Ÿæ•°æ®æŒ–æŽ˜ä¸€æ ·ï¼Œç‰¹å¾æå–çš„å¥½åç‰¹åˆ«é‡è¦ï¼Œä¸è®ºç”¨ä»€ä¹ˆç®—æ³•ï¼Œç‰¹å¾å¥½æ•°æ®å¥½ç»“æžœæ‰ä¼šå¥½ã€‚ åˆ†è¯çš„ç›®çš„ å½“æ¨¡åž‹çš„è®°å¿†å’Œæ‹Ÿåˆèƒ½åŠ›è¶³å¤Ÿå¼ºï¼ˆæˆ–è€…ç®€å•ç‚¹ï¼Œè¶³å¤Ÿæ™ºèƒ½ï¼‰çš„æ—¶å€™ï¼Œæˆ‘ä»¬å®Œå…¨å¯ä»¥ä¸ç”¨åˆ†è¯çš„ï¼Œç›´æŽ¥åŸºäºŽå­—çš„æ¨¡åž‹å°±å¯ä»¥åšï¼Œæ¯”å¦‚åŸºäºŽå­—çš„æ–‡æœ¬åˆ†ç±»ã€é—®ç­”ç³»ç»Ÿç­‰ï¼Œæ—©å·²æœ‰äººåœ¨ç ”ç©¶ã€‚ä½†æ˜¯ï¼Œå³ä¾¿è¿™äº›æ¨¡åž‹èƒ½å¤ŸæˆåŠŸï¼Œä¹Ÿä¼šå› ä¸ºæ¨¡åž‹å¤æ‚è€Œå¯¼è‡´æ•ˆçŽ‡ä¸‹é™ï¼Œå› æ­¤ï¼Œå¾ˆå¤šæ—¶å€™ï¼ˆå°¤å…¶æ˜¯ç”Ÿäº§çŽ¯å¢ƒä¸­ï¼‰ï¼Œæˆ‘ä»¬ä¼šå¯»æ±‚æ›´ç®€å•ã€æ›´é«˜æ•ˆçš„æ–¹æ¡ˆã€‚æ¯”å¦‚ä¹‹å‰æˆ‘ä»¬ä¸€ç›´æ˜¯word embeddingï¼Œä½†æ˜¯ sentence embedding ä¹Ÿæ˜¯åœ¨å­¦æœ¯ç•Œå¾ˆæµè¡Œçš„ï¼Œæœ€åŽæ²¡æœ‰å¤§è§„æ¨¡çš„é‡‡ç”¨ï¼Œæ— éžå°±æ˜¯å·¥ä¸šçº§è¦æ±‚æ›´åŠ é«˜æ•ˆçš„æ–¹å¼ï¼Œæœ‰æ—¶å€™ä¼šç‰ºç‰²ä¸€äº›ç²¾åº¦ã€‚ ç›®å‰å¾ˆå¤šçš„åˆ‡è¯æ¨¡å—å¯ä»¥å¤„ç†å¤§éƒ¨åˆ†çš„é€šç”¨è¯­æ–™ï¼Œç„¶è€Œæœ‰ä¸¤ç±»æ–‡æœ¬é›†ä»ç„¶å¤„ç†çš„ä¸æ˜¯å¾ˆå¥½ï¼Œå°±æ˜¯ï¼š ç½‘ç»œæ–‡æ¡£ é¢†åŸŸæ–‡æ¡£ åŽè€…å¯ä»¥æœ‰å¯¹åº”çš„ä¸“å®¶ handleï¼Œä½†æ¶‰åŠåˆ°å•†ç”¨è¿™ç§äººåŠ›æˆæœ¬ä¹Ÿæ˜¯æ¯”è¾ƒé«˜çš„äº†ï¼Œæ‰€ä»¥ä¸€èˆ¬ä½¿ç”¨åŸºç¡€è¯æ±‡+ å„é¢†åŸŸçš„å¸¸ç”¨è¯æ±‡ã€‚å³ä½¿è¿™æ ·çš„æ–¹æ¡ˆä»ç„¶æ˜¯æ— æ³•å¯æŒç»­çš„ï¼Œæ‰€ä»¥éœ€è¦ä¸€ç§ç®—æ³•åŽ»åˆ¤æ–­æ˜¯å¦æ˜¯æ–°è¯ã€‚åœ¨å½“ä¸‹çš„äº’è”ç½‘æ—¶ä»£ï¼Œäººä»¬è¿˜ä¼šä¸æ–­çš„åˆ›é€ å‡ºä¸€äº›æ–°è¯å‡ºæ¥ï¼Œæ¯”å¦‚ï¼šâ€œç¥žé©¬â€ã€â€œä¸æ˜Žè§‰åŽ‰â€ç­‰ã€‚æœªç™»å½•è¯è¾¨åˆ«æœªç™»å½•è¯åŒ…æ‹¬æ˜¯ç§ç±»ç¹å¤šï¼Œå½¢æ€ç»„åˆå„å¼‚ï¼Œè§„æ¨¡å®å¤§çš„ä¸€ä¸ªé¢†åŸŸã€‚å¯¹è¿™äº›è¯è¯­çš„è‡ªåŠ¨è¾¨è¯†ï¼Œæ˜¯ä¸€ä»¶éžå¸¸å›°éš¾çš„äº‹ã€‚æ¯”å¦‚ï¼Œâ€œç¾Žçš„â€ã€â€œå¿«çš„â€ã€â€œè‹±é›„è”ç›Ÿâ€åº”è¯¥è¢«ä½œä¸ºä¸€ä¸ªè¯ï¼Œå´è¢«åˆ‡æˆäº†ä¸¤ä¸ªè¯ï¼Œå¤±åŽ»äº†åŽŸæœ‰çš„è¯­ä¹‰ã€‚æœªç™»å½•è¯ï¼ˆout-of-vocabulary, OOVï¼‰ç¬¼ç»Ÿåœ°ä¹‹æœªåœ¨è¯å…¸ä¸­å‡ºçŽ°çš„è¯ï¼Œ äººå·¥æ ‡æ³¨å¯ä»¥è§£å†³å¾ˆå¥½è¯†åˆ«ï¼Œæ¯”å¦‚æœ€å…¸åž‹çš„æœªç™»å½•è¯å°±æ˜¯äººåï¼Œå°¤å…¶æ˜¯æ˜Žæ˜Ÿï¼Œç„¶åŽæœ€ç®€å•çš„æ˜¯æ‰‹åŠ¨çš„ç»´æŠ¤ï¼Œä½†æ˜¯äººåŠ›æˆæœ¬ä¹Ÿæ˜¯æ¯”è¾ƒé«˜æ˜‚çš„ã€‚ ä»Žåˆ†è¯çš„è§’åº¦æ¥çœ‹ï¼Œæ–°è¯ä¸€èˆ¬è¡¨çŽ°ä¸ºç»†ç²’åº¦åˆ‡åˆ†åŽç›¸é‚»è¯çš„ç»„åˆã€‚ åŸºäºŽç»Ÿè®¡çš„æ–°è¯å‘çŽ° è¿™é‡Œæœ‰ä¸‰ä¸ªé˜ˆå€¼ï¼ˆéƒ½æ˜¯è¶Šå¤§è¶Šå¥½ï¼‰ï¼šç¬¬ä¸€æ˜¯æœ€å°äº’ä¿¡æ¯ï¼Œå› ä¸ºäº’ä¿¡æ¯è¶Šå¤§è¯´æ˜Žç›¸å…³åº¦è¶Šå¤§ï¼Œå°†n-gramåˆ†å¥½çš„è¯è®¡ç®—äº’ä¿¡æ¯ï¼Œå¦‚æžœä½ŽäºŽé˜ˆå€¼ï¼Œåˆ™è¯´æ˜Žä¸èƒ½æˆè¯ã€‚ç¬¬äºŒæ˜¯æœ€å°ç†µå€¼ï¼Œå› ä¸ºç†µä¹Ÿæ˜¯è¶Šå¤§è¯´æ˜Žå‘¨è¾¹è¯è¶Šä¸°å¯Œï¼Œè®¡ç®—å…¶å·¦ç†µå’Œå³ç†µçš„æœ€å°å€¼ï¼Œå¦‚æžœæœ€å°å€¼ä½ŽäºŽé˜ˆå€¼ï¼Œåˆ™è¯´æ˜Žä¸èƒ½æˆè¯ã€‚ç¬¬ä¸‰ä¸ªæ˜¯æœ€å°‘å‡ºçŽ°æ¬¡æ•°ï¼Œä¸ºä»€ä¹ˆæœ‰è¿™ä¸ªæ•°å‘¢ï¼Ÿå‡è®¾å‰åŽä¸¤ä¸ªè¯æ˜¯å®Œå…¨ç›¸å…³çš„ï¼Œå‡ºçŽ°400æ¬¡ï¼Œæ€»å…±8000è¯ï¼Œé‚£ä¹ˆäº’ä¿¡æ¯=log((400/8000)/(400/8000)(400/8000))ï¼Œçº¦æŽ‰ä¹‹åŽå‰©ä¸‹log(8000/400)ã€‚ä½†æ˜¯ä¸€ä¸ªè¯å¦‚æžœä»Žå¤´åˆ°å°¾å‡ºçŽ°äº†ä¸€æ¬¡ï¼Œä½†æ˜¯å¹¶ä¸æ˜¯å•è¯ï¼Œåˆ™äº’ä¿¡æ¯ä¸º=log((1/8000)/(1/8000)(1/8000))=log(8000/1)ï¼Œé‚£ä¹ˆå®ƒçš„äº’ä¿¡æ¯ä¼šæ›´å¤§ã€‚å–æœ€å°‘å‡ºçŽ°æ¬¡æ•°ä¹Ÿä¼šå‡ºçŽ°é—®é¢˜ï¼Œå°±æ˜¯ä¸€äº›ä½Žé¢‘çŽ‡çš„è¯ä¸èƒ½å‘çŽ°ã€‚ åŸºäºŽä¿¡æ¯ç†µçš„æ–°è¯å‘çŽ°ç®—æ³•ï¼Œä»Žäº’ä¿¡æ¯å’Œå·¦å³ä¿¡æ¯ç†µå…¥æ‰‹ï¼Œæˆè¯çš„æ ‡å‡†æœ‰ä¸¤ä¸ªï¼š å†…éƒ¨å‡å›ºåº¦ è‡ªç”±è¿ç”¨ç¨‹åº¦ å†…éƒ¨å‡å›ºåº¦å’Œè‡ªç”±è¿ç”¨ç¨‹åº¦åˆ†åˆ«è€ƒè™‘æ˜¯è¯è¯­å†…éƒ¨çš„ç´§å¯†ç¨‹åº¦å’Œå¤–éƒ¨æ­é…çš„ä¸°å¯Œæ€§ã€‚æ‰€è°“å†…éƒ¨å‡å›ºåº¦ï¼Œç”¨æ¥è¡¡é‡è¯æ­é…ï¼ˆcollocationï¼‰æ˜¯å¦åˆç†ã€‚æ¯”å¦‚ï¼Œå¯¹äºŽâ€œçš„ç”µå½±â€ã€â€œç”µå½±é™¢â€è¿™ä¸¤ä¸ªæ­é…ï¼Œç›´è§‚ä¸Šè®²â€œç”µå½±é™¢â€æ›´ä¸ºåˆç†ï¼Œå³â€œç”µå½±â€å’Œâ€œé™¢â€å‡å›ºå¾—æ›´ç´§ä¸€äº›ã€‚åœ¨è®¡ç®—è¯­è¨€å­¦ä¸­ï¼ŒPMI (Pointwise mutual information)è¢«ç”¨æ¥åº¦é‡è¯æ­é…ä¸Žå…³è”æ€§ï¼Œå®šä¹‰å¦‚ä¸‹ï¼š $$p m i ( x , y ) = \log \frac { P ( x , y ) } { P ( x ) P ( y ) }$$ è‹¥PMIé«˜ï¼Œå³ä¸¤ä¸ªè¯å…±çŽ°ï¼ˆco-occurrenceï¼‰çš„é¢‘çŽ‡è¿œå¤§äºŽä¸¤ä¸ªè¯è‡ªç”±æ‹¼æŽ¥çš„ä¹˜ç§¯æ¦‚çŽ‡ï¼Œåˆ™è¯´æ˜Žè¿™ä¸¤ä¸ªè¯æ­é…æ›´ä¸ºåˆç†ä¸€äº›ã€‚é’ˆå¯¹ä¸€ä¸ªè¯æœ‰å¤šç§æ­é…ç»„åˆï¼Œæ¯”å¦‚â€œç”µå½±é™¢â€å¯ä»¥ç”±â€œç”µå½±â€+â€œé™¢â€æž„æˆï¼Œä¹Ÿå¯ä»¥ç”±â€œç”µâ€+â€œå½±é™¢â€æž„æˆï¼Œé‚£ä¹ˆå–å…¶æ‰€æœ‰pmiæœ€å°å€¼ï¼ˆåŽ»æŽ‰logï¼‰ä½œä¸ºå†…éƒ¨å‡å›ºåº¦ï¼š$$\operatorname { solid } \left( c _ { 1 } ^ { m } \right) = \min \frac { P \left( c _ { 1 } ^ { m } \right) } { \prod P \left( c _ { i } ^ { j } \right) } = \frac { P \left( c _ { 1 } ^ { m } \right) } { \max \prod P \left( c _ { i } ^ { j } \right) }$$ å…¶ä¸­ï¼Œ $c _ { 1 } ^ { m } = c _ { 1 } c _ { 2 } \cdots c _ { m }$è¡¨ç¤ºé•¿åº¦ä¸º $m$ çš„å­—ç¬¦ä¸²ï¼Œ$P \left( c _ { 1 } ^ { m } \right)$ è¡¨ç¤º$c _ { 1 } ^ { m }$ çš„é¢‘çŽ‡ã€‚ å…‰çœ‹æ–‡æœ¬ç‰‡æ®µå†…éƒ¨çš„å‡åˆç¨‹åº¦è¿˜ä¸å¤Ÿï¼Œæˆ‘ä»¬è¿˜éœ€è¦ä»Žæ•´ä½“æ¥çœ‹å®ƒåœ¨å¤–éƒ¨çš„è¡¨çŽ°ã€‚è€ƒè™‘â€œè¢«å­â€å’Œâ€œè¾ˆå­â€è¿™ä¸¤ä¸ªç‰‡æ®µã€‚æˆ‘ä»¬å¯ä»¥è¯´â€œä¹°è¢«å­â€ã€â€œç›–è¢«å­â€ã€â€œè¿›è¢«å­â€ã€â€œå¥½è¢«å­â€ã€â€œè¿™è¢«å­â€ç­‰ï¼Œåœ¨â€œè¢«å­â€å‰é¢åŠ å„ç§å­—ï¼›ä½†â€œè¾ˆå­â€çš„ç”¨æ³•å´éžå¸¸å›ºå®šï¼Œé™¤äº†â€œä¸€è¾ˆå­â€ã€â€œè¿™è¾ˆå­â€ã€â€œä¸Šè¾ˆå­â€ã€â€œä¸‹è¾ˆå­â€ï¼ŒåŸºæœ¬ä¸Šâ€œè¾ˆå­â€å‰é¢ä¸èƒ½åŠ åˆ«çš„å­—äº†ã€‚â€œè¾ˆå­â€è¿™ä¸ªæ–‡æœ¬ç‰‡æ®µå·¦è¾¹å¯ä»¥å‡ºçŽ°çš„å­—å¤ªæœ‰é™ï¼Œä»¥è‡³äºŽç›´è§‰ä¸Šæˆ‘ä»¬å¯èƒ½ä¼šè®¤ä¸ºï¼Œâ€œè¾ˆå­â€å¹¶ä¸å•ç‹¬æˆè¯ï¼ŒçœŸæ­£æˆè¯çš„å…¶å®žæ˜¯â€œä¸€è¾ˆå­â€ã€â€œè¿™è¾ˆå­â€ä¹‹ç±»çš„æ•´ä½“ã€‚ å…ˆç®€å•çš„ä»‹ç»ç†µçš„æ¦‚å¿µï¼Œç†µæ˜¯ä¸€ç§è¡¨ç¤ºä¿¡æ¯é‡çš„æŒ‡æ ‡ï¼Œç†µè¶Šé«˜å°±æ„å‘³ç€ä¿¡æ¯å«é‡è¶Šå¤§ï¼Œä¸ç¡®å®šæ€§è¶Šé«˜ï¼Œè¶Šéš¾ä»¥é¢„æµ‹ï¼Œä¿¡æ¯ä¹Ÿå°±è¶Šä¸°å¯Œã€‚$$H ( X ) = - \sum _ { x \in X } p ( x ) \log _ { 2 } p ( x )$$ æ‰€ä»¥ï¼Œæå‡ºäº†è‡ªç”±è¿ç”¨ç¨‹åº¦ï¼Œç”¨ä»¥è¡¡é‡ä¸€ä¸ªè¯çš„å·¦é‚»å­—ä¸Žå³é‚»å­—çš„ä¸°å¯Œç¨‹åº¦ã€‚æ­£å¥½ä¿¡æ¯ç†µå¯ä»¥å®Œç¾Žåœ°è¯ é‡Šäº†è¿™ç§ä¸°å¯Œç¨‹åº¦ï¼Œç†µè¶Šå¤§åˆ™ä¸°å¯Œç¨‹åº¦è¶Šé«˜ã€‚â€œè¢«å­â€å’Œâ€œè¾ˆå­â€è¿™ä¸¤ä¸ªç‰‡æ®µçš„å·¦é‚»å­—ç†µleä¸Žå³é‚»å­—ç†µreåˆ†åˆ«å¦‚ä¸‹ le(è¢«å­) = 3.67453re(è¢«å­) = 3.8740le(è¾ˆå­) = 1.25963re(è¾ˆå­) = 4.11644 å¯ä»¥çœ‹å‡ºï¼Œâ€œè¢«å­â€çš„å·¦é‚»å­—ç†µä¸Žå³é‚»å­—ç†µéƒ½è¾ƒé«˜ï¼Œè€Œâ€œè¾ˆå­â€çš„å·¦é‚»å­—ç†µè¾ƒå°ï¼Œå³å·¦é‚»å­—éžå¸¸è´«ä¹ã€‚å› æ­¤ï¼Œâ€œè¢«å­â€è¾ƒâ€œè¾ˆå­â€æ›´æœ‰å¯èƒ½æˆè¯ã€‚è‡ªç”±è¿ç”¨ç¨‹åº¦çš„å®šä¹‰å¦‚ä¸‹ï¼š ç»™é¢‘æ•°ã€å†…éƒ¨å‡å›ºåº¦ä¸Žè‡ªç”±è¿ç”¨ç¨‹åº¦è®¾å®šä¸€ä¸ªé˜ˆå€¼ï¼Œæå–å‡ºæ¥ç¬¦åˆé˜ˆå€¼çš„å€™é€‰è¯ï¼ŒåŽ»æŽ‰è¯å…¸ä¸­å­˜åœ¨çš„è¯å³ä¸ºæ–°è¯äº†ã€‚æ‰€ä»¥ä¸¤è€…éƒ½é«˜äºŽæŸä¸ªå¯¹åº”çš„é˜ˆå€¼ï¼Œé‚£ä¹ˆè¯´æ˜Žè¿™ä¸ªæ˜¯ä¸€ä¸ªæ–°è¯ã€‚ å®žçŽ°ï¼š ä½¿ç”¨å°„é›•è‹±é›„ä¼ txt ä½œä¸ºæ–‡æœ¬ï¼Œç„¶åŽè¯é¢‘ã€å†…éƒ¨å‡å›ºåº¦ å’Œè‡ªç”±ç¨‹åº¦è¿›è¡Œæ–°è¯è¯†åˆ«ã€‚ä»£ç ã€‚ è¯é¢‘è¿™ç‚¹å¾ˆå¥½ç†è§£,å› ä¸ºä¸æ˜¯è¯çš„è¯å‡ºçŽ°çš„é¢‘çŽ‡ä¸€èˆ¬æ¯”è¾ƒä½Ž,è¯çš„å‡ºçŽ°é¢‘çŽ‡ä¼šæ¯”è¾ƒé«˜.æ‰€ä»¥å¯ä»¥è®¾ç½®ä¸€ä¸ªè¯é¢‘é˜€å€¼,é«˜äºŽè¿™ä¸ªé˜€å€¼çš„åˆ¤æ–­ä¸ºè¯,å¦åˆ™åˆ¤å®šä¸ºä¸æ˜¯è¯. å‡å›ºåº¦ åŸºäºŽä¸Šä¸€æ­¥è¯é¢‘çš„æŒ‘é€‰ã€‚ è‡ªç”±åº¦ åŸºäºŽä¸Šè¿°åˆ†è¯è¿›è¡ŒæŒ‘é€‰ã€‚ NLP ä¸­çš„ä¸‰ç±»ç‰¹å¾æå–å™¨ NLP å’Œå›¾åƒä¸­æ•°æ®çš„ç‰¹å¾ NLPçš„è¾“å…¥å¾€å¾€æ˜¯ä¸€å¥è¯æˆ–è€…ä¸€ç¯‡æ–‡ç« ï¼Œæ‰€ä»¥å®ƒæœ‰å‡ ä¸ªç‰¹ç‚¹ï¼šé¦–å…ˆï¼Œè¾“å…¥æ˜¯ä¸ªä¸€ç»´çº¿æ€§åºåˆ—ï¼Œè¿™ä¸ªå¥½ç†è§£ï¼›å…¶æ¬¡ï¼Œè¾“å…¥æ˜¯ä¸å®šé•¿çš„ï¼Œæœ‰çš„é•¿æœ‰çš„çŸ­ï¼Œè€Œè¿™ç‚¹å…¶å®žå¯¹äºŽæ¨¡åž‹å¤„ç†èµ·æ¥ä¹Ÿä¼šå¢žåŠ ä¸€äº›å°éº»çƒ¦ï¼›å†æ¬¡ï¼Œå•è¯æˆ–è€…å­å¥çš„ç›¸å¯¹ä½ç½®å…³ç³»å¾ˆé‡è¦ï¼Œä¸¤ä¸ªå•è¯ä½ç½®äº’æ¢å¯èƒ½å¯¼è‡´å®Œå…¨ä¸åŒçš„æ„æ€ã€‚ NLP ä¸­çš„å››å¤§ä»»åŠ¡ åºåˆ—æ ‡æ³¨ï¼š åˆ†è¯/ POS Tag /NER /è¯­ä¹‰æ ‡æ³¨ åˆ†ç±»ä»»åŠ¡ï¼š æ–‡æœ¬åˆ†ç±»/ æƒ…æ„Ÿè®¡ç®— å¥å­å…³ç³»åˆ¤æ–­ï¼š Entailment /QA / è‡ªç„¶è¯­è¨€æŽ¨ç† ç”Ÿæˆå¼ä»»åŠ¡ï¼š æœºå™¨ç¿»è¯‘/ æ–‡æœ¬æ‘˜å½• ä¸€ç±»æ˜¯åºåˆ—æ ‡æ³¨ï¼Œè¿™æ˜¯æœ€å…¸åž‹çš„NLPä»»åŠ¡ï¼Œæ¯”å¦‚ä¸­æ–‡åˆ†è¯ï¼Œè¯æ€§æ ‡æ³¨ï¼Œå‘½åå®žä½“è¯†åˆ«ï¼Œè¯­ä¹‰è§’è‰²æ ‡æ³¨ç­‰éƒ½å¯ä»¥å½’å…¥è¿™ä¸€ç±»é—®é¢˜ï¼Œå®ƒçš„ç‰¹ç‚¹æ˜¯å¥å­ä¸­æ¯ä¸ªå•è¯è¦æ±‚æ¨¡åž‹æ ¹æ®ä¸Šä¸‹æ–‡éƒ½è¦ç»™å‡ºä¸€ä¸ªåˆ†ç±»ç±»åˆ«ã€‚ç¬¬äºŒç±»æ˜¯åˆ†ç±»ä»»åŠ¡ï¼Œæ¯”å¦‚æˆ‘ä»¬å¸¸è§çš„æ–‡æœ¬åˆ†ç±»ï¼Œæƒ…æ„Ÿè®¡ç®—ç­‰éƒ½å¯ä»¥å½’å…¥è¿™ä¸€ç±»ã€‚å®ƒçš„ç‰¹ç‚¹æ˜¯ä¸ç®¡æ–‡ç« æœ‰å¤šé•¿ï¼Œæ€»ä½“ç»™å‡ºä¸€ä¸ªåˆ†ç±»ç±»åˆ«å³å¯ã€‚ç¬¬ä¸‰ç±»ä»»åŠ¡æ˜¯å¥å­å…³ç³»åˆ¤æ–­ï¼Œæ¯”å¦‚Entailmentï¼ŒQAï¼Œè¯­ä¹‰æ”¹å†™ï¼Œè‡ªç„¶è¯­è¨€æŽ¨ç†ç­‰ä»»åŠ¡éƒ½æ˜¯è¿™ä¸ªæ¨¡å¼ï¼Œå®ƒçš„ç‰¹ç‚¹æ˜¯ç»™å®šä¸¤ä¸ªå¥å­ï¼Œæ¨¡åž‹åˆ¤æ–­å‡ºä¸¤ä¸ªå¥å­æ˜¯å¦å…·å¤‡æŸç§è¯­ä¹‰å…³ç³»ï¼›ç¬¬å››ç±»æ˜¯ç”Ÿæˆå¼ä»»åŠ¡ï¼Œæ¯”å¦‚æœºå™¨ç¿»è¯‘ï¼Œæ–‡æœ¬æ‘˜è¦ï¼Œå†™è¯—é€ å¥ï¼Œçœ‹å›¾è¯´è¯ç­‰éƒ½å±žäºŽè¿™ä¸€ç±»ã€‚å®ƒçš„ç‰¹ç‚¹æ˜¯è¾“å…¥æ–‡æœ¬å†…å®¹åŽï¼Œéœ€è¦è‡ªä¸»ç”Ÿæˆå¦å¤–ä¸€æ®µæ–‡å­—ã€‚ æ·±åº¦å­¦ä¹ æœ€å¤§çš„ä¼˜ç‚¹æ˜¯ â€œç«¯åˆ°ç«¯â€ NLPä¸­çš„ä»»åŠ¡å¾ˆå¤šï¼Œå“ªäº›ä»»åŠ¡æ˜¯æœ€å…·æœ‰ä»£è¡¨æ€§çš„å‘¢ï¼Ÿç­”æ¡ˆæ˜¯æœºå™¨ç¿»è¯‘ã€‚ å›žå½’ä¸»é¢˜ï¼Œç‰¹å¾æå–å™¨ RNNRNNæ¨¡åž‹ç»“æž„å‚è€ƒä¸Šå›¾ï¼Œæ ¸å¿ƒæ˜¯æ¯ä¸ªè¾“å…¥å¯¹åº”éšå±‚èŠ‚ç‚¹ï¼Œè€Œéšå±‚èŠ‚ç‚¹ä¹‹é—´å½¢æˆäº†çº¿æ€§åºåˆ—ï¼Œä¿¡æ¯ç”±å‰å‘åŽåœ¨éšå±‚ä¹‹é—´é€æ­¥å‘åŽä¼ é€’ã€‚ RNNä¹Ÿå­˜åœ¨é—®é¢˜ï¼Œå®ƒé‡‡å–çº¿æ€§åºåˆ—ç»“æž„ä¸æ–­ä»Žå‰å¾€åŽæ”¶é›†è¾“å…¥ä¿¡æ¯ï¼Œä½†è¿™ç§çº¿æ€§åºåˆ—ç»“æž„åœ¨åå‘ä¼ æ’­çš„æ—¶å€™å­˜åœ¨ä¼˜åŒ–å›°éš¾é—®é¢˜ï¼Œå› ä¸ºåå‘ä¼ æ’­è·¯å¾„å¤ªé•¿ï¼Œå®¹æ˜“å¯¼è‡´ä¸¥é‡çš„æ¢¯åº¦æ¶ˆå¤±æˆ–æ¢¯åº¦çˆ†ç‚¸é—®é¢˜ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼ŒåŽæ¥å¼•å…¥äº†LSTMå’ŒGRUæ¨¡åž‹ï¼Œé€šè¿‡å¢žåŠ ä¸­é—´çŠ¶æ€ä¿¡æ¯ç›´æŽ¥å‘åŽä¼ æ’­ï¼Œä»¥æ­¤ç¼“è§£æ¢¯åº¦æ¶ˆå¤±é—®é¢˜ï¼ŒèŽ·å¾—äº†å¾ˆå¥½çš„æ•ˆæžœï¼ŒäºŽæ˜¯å¾ˆå¿«LSTMå’ŒGRUæˆä¸ºRNNçš„æ ‡å‡†æ¨¡åž‹ã€‚ ï¼ˆAttentionæœºåˆ¶æœ€æ—©æ˜¯åœ¨è§†è§‰å›¾åƒé¢†åŸŸæå‡ºæ¥çš„ï¼Œä½†æ˜¯çœŸæ­£ç«èµ·æ¥åº”è¯¥ç®—æ˜¯2014å¹´google mindå›¢é˜Ÿçš„è®ºæ–‡ã€ŠRecurrent Models of Visual Attentionã€‹ï¼Œä»–ä»¬åœ¨RNNæ¨¡åž‹ä¸Šä½¿ç”¨äº†attentionæœºåˆ¶æ¥è¿›è¡Œå›¾åƒåˆ†ç±»ï¼‰ ä¸ºä»€ä¹ˆRNNèƒ½å¤Ÿè¿™ä¹ˆå¿«åœ¨NLPæµè¡Œå¹¶ä¸”å æ®äº†ä¸»å¯¼åœ°ä½å‘¢ï¼Ÿä¸»è¦åŽŸå› è¿˜æ˜¯å› ä¸ºRNNçš„ç»“æž„å¤©ç„¶é€‚é…è§£å†³NLPçš„é—®é¢˜ï¼ŒNLPçš„è¾“å…¥å¾€å¾€æ˜¯ä¸ªä¸å®šé•¿çš„çº¿æ€§åºåˆ—å¥å­ï¼Œè€ŒRNNæœ¬èº«ç»“æž„å°±æ˜¯ä¸ªå¯ä»¥æŽ¥çº³ä¸å®šé•¿è¾“å…¥çš„ç”±å‰å‘åŽè¿›è¡Œä¿¡æ¯çº¿æ€§ä¼ å¯¼çš„ç½‘ç»œç»“æž„ï¼Œè€Œåœ¨LSTMå¼•å…¥ä¸‰ä¸ªé—¨åŽï¼Œå¯¹äºŽæ•èŽ·é•¿è·ç¦»ç‰¹å¾ä¹Ÿæ˜¯éžå¸¸æœ‰æ•ˆçš„ã€‚æ‰€ä»¥RNNç‰¹åˆ«é€‚åˆNLPè¿™ç§çº¿å½¢åºåˆ—åº”ç”¨åœºæ™¯ï¼Œè¿™æ˜¯RNNä¸ºä½•åœ¨NLPç•Œå¦‚æ­¤æµè¡Œçš„æ ¹æœ¬åŽŸå› ã€‚ é‚£ä¹ˆä¸ºä»€ä¹ˆæœ‰è¡°å¼±äº†ï¼ŸRNNæœ¬èº«çš„åºåˆ—ä¾èµ–ç»“æž„å¯¹äºŽå¤§è§„æ¨¡å¹¶è¡Œè®¡ç®—æ¥è¯´ç›¸å½“ä¹‹ä¸å‹å¥½ã€‚é€šä¿—ç‚¹è¯´ï¼Œå°±æ˜¯RNNå¾ˆéš¾å…·å¤‡é«˜æ•ˆçš„å¹¶è¡Œè®¡ç®—èƒ½åŠ›ã€‚å¦‚æžœé€‚åˆåœ¨å­¦æœ¯ç•Œå‘è®ºæ–‡ï¼Œé‚£ä¹ˆä¸å¤ªå¯èƒ½åœ¨å·¥ä¸šç•Œå¹¿æ³›çš„ä½¿ç”¨ã€‚ CNN ç‰¹å¾æå–å™¨å·ç§¯å±‚æœ¬è´¨ä¸Šæ˜¯ä¸ªç‰¹å¾æŠ½å–å±‚ï¼Œå¯ä»¥è®¾å®šè¶…å‚æ•°Fæ¥æŒ‡å®šå·ç§¯å±‚åŒ…å«å¤šå°‘ä¸ªå·ç§¯æ ¸ï¼ˆFilterï¼‰ã€‚å¯¹äºŽæŸä¸ªFilteræ¥è¯´ï¼Œå¯ä»¥æƒ³è±¡æœ‰ä¸€ä¸ªd*kå¤§å°çš„ç§»åŠ¨çª—å£ä»Žè¾“å…¥çŸ©é˜µçš„ç¬¬ä¸€ä¸ªå­—å¼€å§‹ä¸æ–­å¾€åŽç§»åŠ¨ï¼Œå…¶ä¸­kæ˜¯FilteræŒ‡å®šçš„çª—å£å¤§å°ï¼Œdæ˜¯Word Embeddingé•¿åº¦ã€‚å¯¹äºŽæŸä¸ªæ—¶åˆ»çš„çª—å£ï¼Œé€šè¿‡ç¥žç»ç½‘ç»œçš„éžçº¿æ€§å˜æ¢ï¼Œå°†è¿™ä¸ªçª—å£å†…çš„è¾“å…¥å€¼è½¬æ¢ä¸ºæŸä¸ªç‰¹å¾å€¼ï¼Œéšç€çª—å£ä¸æ–­å¾€åŽç§»åŠ¨ï¼Œè¿™ä¸ªFilterå¯¹åº”çš„ç‰¹å¾å€¼ä¸æ–­äº§ç”Ÿï¼Œå½¢æˆè¿™ä¸ªFilterçš„ç‰¹å¾å‘é‡ã€‚è¿™å°±æ˜¯å·ç§¯æ ¸æŠ½å–ç‰¹å¾çš„è¿‡ç¨‹ã€‚å·ç§¯å±‚å†…æ¯ä¸ªFilteréƒ½å¦‚æ­¤æ“ä½œï¼Œå°±å½¢æˆäº†ä¸åŒçš„ç‰¹å¾åºåˆ—ã€‚Pooling å±‚åˆ™å¯¹Filterçš„ç‰¹å¾è¿›è¡Œé™ç»´æ“ä½œï¼Œå½¢æˆæœ€ç»ˆçš„ç‰¹å¾ã€‚ä¸€èˆ¬åœ¨Poolingå±‚ä¹‹åŽè¿žæŽ¥å…¨è”æŽ¥å±‚ç¥žç»ç½‘ç»œï¼Œå½¢æˆæœ€åŽçš„åˆ†ç±»è¿‡ç¨‹ã€‚ CNN æ•æ‰åˆ°çš„æ˜¯ä»€ä¹ˆä¿¡æ¯ï¼Ÿ å…³é”®åœ¨äºŽå·ç§¯æ ¸è¦†ç›–çš„é‚£ä¸ªæ»‘åŠ¨çª—å£ï¼ŒCNNèƒ½æ•èŽ·åˆ°çš„ç‰¹å¾åŸºæœ¬éƒ½ä½“çŽ°åœ¨è¿™ä¸ªæ»‘åŠ¨çª—å£é‡Œäº†ã€‚å¤§å°ä¸ºkçš„æ»‘åŠ¨çª—å£è½»è½»çš„ç©¿è¿‡å¥å­çš„ä¸€ä¸ªä¸ªå•è¯ï¼Œè¡èµ·é˜µé˜µæ¶Ÿæ¼ªï¼Œé‚£ä¹ˆå®ƒæ•èŽ·äº†ä»€ä¹ˆ?å…¶å®žå®ƒæ•èŽ·åˆ°çš„æ˜¯å•è¯çš„k-gramç‰‡æ®µä¿¡æ¯ï¼Œè¿™äº›k-gramç‰‡æ®µå°±æ˜¯CNNæ•èŽ·åˆ°çš„ç‰¹å¾ï¼Œkçš„å¤§å°å†³å®šäº†èƒ½æ•èŽ·å¤šè¿œè·ç¦»çš„ç‰¹å¾ã€‚ å·ç§¯æ“ä½œæ˜¯é€šè¿‡åŠ æ·±å±‚æ•°ï¼Œç„¶åŽèŽ·å¾—è¿œè·ç¦»çš„ç‰¹å¾çš„ã€‚æ‰€ä»¥æœ‰ä¸¤ç§è§£é¢˜æ€è·¯ï¼š ä¸€ç§æ˜¯å¢žåŠ çª—å£å¤§å°k å¢žå¤§ï¼›ä¸€ç§æ˜¯åŠ æ·±æ·±åº¦ã€‚ ç®€å•è°ˆä¸€ä¸‹CNNçš„ä½ç½®ç¼–ç é—®é¢˜å’Œå¹¶è¡Œè®¡ç®—èƒ½åŠ›é—®é¢˜ã€‚CNNçš„å·ç§¯å±‚å…¶å®žæ˜¯ä¿ç•™äº†ç›¸å¯¹ä½ç½®ä¿¡æ¯çš„ï¼Œåªè¦ä½ åœ¨è®¾è®¡æ¨¡åž‹çš„æ—¶å€™åˆ«æ‰‹è´±ï¼Œä¸­é—´å±‚ä¸è¦éšæ‰‹çžŽæ’å…¥Poolingå±‚ï¼Œé—®é¢˜å°±ä¸å¤§ï¼Œä¸ä¸“é—¨åœ¨è¾“å…¥éƒ¨åˆ†å¯¹positionè¿›è¡Œç¼–ç ä¹Ÿè¡Œã€‚è‡³äºŽCNNçš„å¹¶è¡Œè®¡ç®—èƒ½åŠ›ï¼Œé‚£æ˜¯éžå¸¸å¼ºçš„ï¼Œè¿™å…¶å®žå¾ˆå¥½ç†è§£ã€‚æˆ‘ä»¬è€ƒè™‘å•å±‚å·ç§¯å±‚ï¼Œé¦–å…ˆå¯¹äºŽæŸä¸ªå·ç§¯æ ¸æ¥è¯´ï¼Œæ¯ä¸ªæ»‘åŠ¨çª—å£ä½ç½®ä¹‹é—´æ²¡æœ‰ä¾èµ–å…³ç³»ï¼Œæ‰€ä»¥å®Œå…¨å¯ä»¥å¹¶è¡Œè®¡ç®—ï¼›å¦å¤–ï¼Œä¸åŒçš„å·ç§¯æ ¸ä¹‹é—´ä¹Ÿæ²¡ä»€ä¹ˆç›¸äº’å½±å“ï¼Œæ‰€ä»¥ä¹Ÿå¯ä»¥å¹¶è¡Œè®¡ç®—ã€‚CNNçš„å¹¶è¡Œåº¦æ˜¯éžå¸¸è‡ªç”±ä¹Ÿéžå¸¸é«˜çš„ï¼Œè¿™æ˜¯CNNçš„ä¸€ä¸ªéžå¸¸å¥½çš„ä¼˜ç‚¹ã€‚ Transformerçœ‹çœ‹ Transformer å¯¹äºŽNLP ä»»åŠ¡ä¸­çš„è§£å†³æ–¹æ¡ˆï¼š ä¸å®šé•¿çš„è¾“å…¥ï¼šTransformer ä¸€èˆ¬è®¾ç½®æœ€å¤§çš„é•¿åº¦ï¼Œä¸å¤Ÿäº† å°±paddingï¼Œç„¶åŽå¤šäº†å°± åŽ»å°¾ã€‚ å•è¯ä¹‹é—´çš„ç›¸å¯¹ä½ç½®ï¼š Transformeræ˜¯ç”¨ä½ç½®å‡½æ•°æ¥è¿›è¡Œä½ç½®ç¼–ç çš„ï¼Œè€ŒBertç­‰æ¨¡åž‹åˆ™ç»™æ¯ä¸ªå•è¯ä¸€ä¸ªPosition embeddingï¼Œå°†å•è¯embeddingå’Œå•è¯å¯¹åº”çš„position embeddingåŠ èµ·æ¥å½¢æˆå•è¯çš„è¾“å…¥embedding é•¿ä¾èµ–é—®é¢˜ï¼š self attentionæœºåˆ¶ å¯¹äºŽTransformeræ¥è¯´ï¼ŒMulti-head attentionçš„headæ•°é‡ä¸¥é‡å½±å“NLPä»»åŠ¡ä¸­Long-rangeç‰¹å¾æ•èŽ·èƒ½åŠ›ï¼šç»“è®ºæ˜¯headè¶Šå¤šè¶Šæœ‰åˆ©äºŽæ•èŽ·long-rangeç‰¹å¾ã€‚ï¼ˆå¯¹æ ‡filter çš„ä¸ªæ•°ï¼‰ æˆ‘ä¸ªäººæ„è§æ˜¯ï¼šè¿™è¯´æ˜ŽTransformerä¹‹æ‰€ä»¥èƒ½å¤Ÿæ•ˆæžœè¿™ä¹ˆå¥½ï¼Œä¸ä»…ä»…multi-head attentionåœ¨å‘ç”Ÿä½œç”¨ï¼Œè€Œæ˜¯å‡ ä¹Žæ‰€æœ‰æž„ä»¶éƒ½åœ¨å…±åŒå‘æŒ¥ä½œç”¨ï¼Œæ˜¯ä¸€ä¸ªå°å°çš„ç³»ç»Ÿå·¥ç¨‹ã€‚ å‚è€ƒæ–‡çŒ® æ”¾å¼ƒå¹»æƒ³ï¼Œå…¨é¢æ‹¥æŠ±Transformer BLEUBLEU (bilingual evaluation understudy) è¯»éŸ³:æ³¢å‹’ not blue. å®Œç¾ŽåŒ¹é…çš„å¾—åˆ†ä¸º1.0ï¼Œè€Œå®Œå…¨ä¸åŒ¹é…åˆ™å¾—åˆ†ä¸º0.0ã€‚ è™½ç„¶æ˜¯ä¸ºæœºå™¨ç¿»è¯‘æå‡ºï¼Œä½†åŽæ¥ä¹Ÿå¹¿æ³›ç”¨äºŽNLPå…¶ä»–é¢†åŸŸã€‚ å¯ä»¥æ ¹æ®ä¸€ä¸ªæ•°å€¼æŒ‡æ ‡æ¥è¡¡é‡å…¶ä¸Žä¸€ä¸ªæˆ–å¤šä¸ªäººå·¥å‚è€ƒç¿»è¯‘çš„æŽ¥è¿‘ç¨‹åº¦ã€‚ åŽŸç†ä»‹ç»ä¸‹é¢ä¸‰ä¸ªæ¦‚å¿µï¼š N-gramï¼Œ æƒ©ç½šå› å­å’ŒBleu ç®—æ³•ã€‚ N-gram N-gramæ˜¯ä¸€ç§ç»Ÿè®¡è¯­è¨€æ¨¡åž‹ï¼Œè¯¥æ¨¡åž‹å¯ä»¥å°†ä¸€å¥è¯è¡¨ç¤ºnä¸ªè¿žç»­çš„å•è¯åºåˆ—ï¼Œåˆ©ç”¨ä¸Šä¸‹æ–‡ä¸­ç›¸é‚»è¯é—´çš„æ­é…ä¿¡æ¯ï¼Œè®¡ç®—å‡ºå¥å­çš„æ¦‚çŽ‡ï¼Œä»Žè€Œåˆ¤æ–­ä¸€å¥è¯æ˜¯å¦é€šé¡ºã€‚ é€šè¿‡ä¾‹å­å­¦ä¹  åŽŸæ–‡ï¼š çŒ«ååœ¨åž«å­ä¸Šæœºå™¨ç¿»è¯‘ï¼šThe cat sat on the mat.äººå·¥ç¿»è¯‘ï¼šThe cat is on the mat. 1 gram åŒ¹é…åº¦æ˜¯ 5/6 åŒç†å¯ä»¥å¾—åˆ° 2 gram, 3 gram, 4 gram åˆ†åˆ«æ˜¯ 3/5, 1/4 å’Œ 0. å¤„ç†ä¸€äº›ç‰¹æ®Šçš„æƒ…å†µï¼š åŽŸæ–‡ï¼šçŒ«ååœ¨åž«å­ä¸Šæœºå™¨è¯‘æ–‡ï¼š the the the the the the the.å‚è€ƒè¯‘æ–‡ï¼šThe cat is on the mat. æ‰€ä»¥å½“ 1 gram çš„æ—¶å€™ï¼ŒåŒ¹é…åº¦æ˜¯ 7/7ï¼Œä¸åˆç†çš„ã€‚ BLEUä¿®æ­£äº†è¿™ä¸ªç®—æ³•ï¼Œæå‡ºå–æœºå™¨ç¿»è¯‘è¯‘æ–‡N-gramçš„å‡ºçŽ°æ¬¡æ•°å’Œå‚è€ƒè¯‘æ–‡ä¸­N-gramæœ€å¤§å‡ºçŽ°æ¬¡æ•°ä¸­çš„æœ€å°å€¼çš„ç®—æ³•ï¼Œå…·ä½“å¦‚ä¸‹ï¼š $$Count_{clip} =min(Count, Max_Ref_Count)$$ é‚£ä¹ˆä¿®æ­£ä¹‹åŽçš„ 1 gram çš„åŒ¹é…åº¦å°±æ˜¯ 2/7 è®ºæ–‡ä¸­ N-gram çš„è®¡ç®—å…¬å¼ï¼š $$P_n =\frac{ \sum_{C \in {Candidates} } \sum_{n-gram \in C} Count_{clip}(n-gram)}{\sum_{C \in {Candidates} } \sum_{n-gram \in C^{â€˜}} Count_{clip}(n-gram^{â€˜})} $$ åˆ†å­è¡¨ç¤ºç¿»è¯‘è¯‘æ–‡ï¼ˆæœºå™¨ç¿»è¯‘ï¼‰ï¼Œç„¶åŽåˆ†æ¯è¡¨ç¤ºå‚è€ƒè¯‘æ–‡ï¼ˆäººå·¥ç¿»è¯‘ï¼‰ æƒ©ç½šå› å­ å¦‚æžœå‡ºçŽ°äº†è¿™æ ·çš„æƒ…å†µï¼š æœºå™¨è¯‘æ–‡ï¼šThe catå‚è€ƒè¯‘æ–‡ï¼šThe cat is on the mat. å¦‚æžœå‡ºçŽ°è¿™ç§çŸ­å¥å­ï¼Œä½ ä¼šå‘çŽ°è®¡ç®—n-gramçš„ç²¾åº¦ä¼šå¾—å¾ˆé«˜åˆ†ï¼Œå¾ˆæ˜¾ç„¶è¿™æ¬¡çš„å¾—åˆ†ä¸º1ï¼Œä½†å®žé™…ä¸Šå®ƒçš„å¾—åˆ†åº”è¯¥æ˜¯æ¯”è¾ƒä½Žçš„ã€‚é’ˆå¯¹ç¿»è¯‘è¯‘æ–‡é•¿åº¦æ¯”å‚è€ƒè¯‘æ–‡è¦çŸ­çš„æƒ…å†µï¼Œå°±éœ€è¦ä¸€ä¸ªæƒ©ç½šçš„æœºåˆ¶åŽ»æŽ§åˆ¶ã€‚BP ä¸»è¦æ˜¯å¤„ç†å¥å­é•¿åº¦çš„é—®é¢˜ã€‚ $$ BP = \begin{cases}1 &amp; c &gt;r \\e ^ { ( 1 - r / c ) } &amp; c &lt;= r\end{cases}$$ è¿™é‡Œçš„cæ˜¯æœºå™¨è¯‘æ–‡çš„è¯æ•°ï¼Œræ˜¯å‚è€ƒè¯‘æ–‡çš„è¯æ•° æ‰€ä»¥è®¡ç®—å¾—ï¼š$ BP = e^(1- 6 / 2) = 7.38905609893065 $ BLEU ç®—æ³• $$\mathrm { B } \mathrm { LEU } = \mathrm { BP } \cdot \exp \left( \sum _ { n = 1 } ^ { N } w _ { n } \log p _ { n } \right)$$ å¯¹äºŽBP å·²ç»çŸ¥é“ï¼ŒåŽé¢çš„å…¶å®žå°±æ˜¯ä¸€äº›æ•°å­¦è¿ç®—ï¼Œå®ƒçš„ä½œç”¨å°±æ˜¯è®©å„é˜¶n-gramå–æƒé‡æœä»Žå‡åŒ€åˆ†å¸ƒï¼Œå°±æ˜¯è¯´ä¸ç®¡æ˜¯1-gramã€2-gramã€3-gramè¿˜æ˜¯4-gramå®ƒä»¬çš„ä½œç”¨éƒ½æ˜¯åŒç­‰é‡è¦çš„ã€‚ç”±äºŽéšç€n-gramçš„å¢žå¤§ï¼Œæ€»ä½“çš„ç²¾åº¦å¾—åˆ†æ˜¯å‘ˆæŒ‡æ•°ä¸‹é™çš„ï¼Œæ‰€ä»¥ä¸€èˆ¬N-gramæœ€å¤šå–åˆ°4-gram. è®¡ç®— ç¬¬ä¸€æ­¥ï¼šè®¡ç®—å„é˜¶n-gramçš„ç²¾åº¦ç¬¬äºŒæ­¥ï¼šåŠ æƒæ±‚å’Œ (ä¸€èˆ¬å°±æ˜¯å¹³å‡)ç¬¬ä¸‰æ­¥ï¼šæ±‚BPæœ€åŽæ±‚BLEU. ä¼˜ç¼ºç‚¹BLEUåŽŸç†å…¶å®žå¹¶ä¸æ˜¯å¾ˆå¤æ‚ï¼ŒBLEUå®¹æ˜“é™·å…¥å¸¸ç”¨è¯å’ŒçŸ­è¯‘å¥çš„é™·é˜±ä¸­ï¼Œ æ‰€ä»¥æ›´å¤šçš„æ˜¯åŸºäºŽn-gram åŸºç¡€ä¸Šçš„ä¼˜åŒ–ã€‚BLEUæœ¬èº«å°±ä¸è¿½æ±‚ç™¾åˆ†ä¹‹ç™¾çš„å‡†ç¡®æ€§ï¼Œä¹Ÿä¸å¯èƒ½åšåˆ°ç™¾åˆ†ä¹‹ç™¾ï¼Œå®ƒçš„ç›®æ ‡åªæ˜¯ç»™å‡ºä¸€ä¸ªå¿«ä¸”ä¸å·®çš„è‡ªåŠ¨è¯„ä¼°è§£å†³æ–¹æ¡ˆã€‚ ä¼˜ç‚¹ï¼š è®¡ç®—é€Ÿåº¦å¿«ï¼›å®¹æ˜“ç†è§£ï¼›å·²ç»è¢«å¹¿æ³›ä½¿ç”¨ ç¼ºç‚¹ï¼š çŸ­è¯‘å¥çš„æµ‹è¯„ç²¾åº¦æœ‰æ—¶ä¼šè¾ƒé«˜ å®ƒæ²¡æœ‰è€ƒè™‘å¥å­æ„ä¹‰ å‚è€ƒæ–‡çŒ®æœºå™¨ç¿»è¯‘è´¨é‡è¯„æµ‹ç®—æ³•-BLEU å¤ä¹ è®°å½•ï¼š åˆ†è¯ä¸¤å¤§é—®é¢˜ï¼šæ­§ä¹‰è¯å’Œoovã€‚åŽè€…å¯¹äºŽæœ€åŽçš„æ•ˆæžœå½±å“æ›´å¤§ã€‚å¤„ç†OOV å¸¸ç”¨çš„æ–¹æ³•ï¼šsubwordï¼›ä½¿ç”¨å¤šä¸ªword embeddingï¼ˆtransfer learningï¼‰ï¼› ä½¿ç”¨context embeddingè¿›è¡Œåˆ†è¯å¸¸ç”¨çš„ç®—æ³•ï¼šåŸºäºŽè§„åˆ™çš„é€†å‘æœ€å¤§åŒ¹é…ï¼ˆä¸­æ–‡çš„ç‰¹ç‚¹ï¼‰ï¼Œé¢‘æ•°ï¼›åŸºäºŽä¿¡æ¯ç†µçš„å†…éƒ¨å‡å›ºåº¦å’Œè‡ªç”±è¿ç”¨ç¨‹åº¦ï¼ˆåˆ†åˆ«è€ƒè™‘è¯è¯­å†…éƒ¨çš„ç´§å¯†ç¨‹åº¦å’Œå¤–éƒ¨æ­é…çš„ä¸°å¯Œç¨‹åº¦ï¼‰ï¼›æ·±åº¦å­¦ä¹ +NERè¿›è¡Œçš„è¯æ€§æ ‡æ³¨ï¼Œæ¡ä»¶éšæœºåœºCRFä¹‹ç±»çš„ã€‚ ä¸­è‹±æ–‡è¯­æ–™é¢„å¤„ç†çš„åŒºåˆ«ï¼šä¸­æ–‡éœ€è¦åˆ†è¯ï¼Œè‹±æ–‡éœ€è¦å¤„ç†æ—¶æ€ï¼Œå¯¹äºŽåè¯å’Œå½¢å®¹è¯å¤„ç†æˆæ ‡å‡†åè¯ï¼Œå¯¹äºŽåŠ¨è¯è¿›è¡Œè¯æ€§è¿˜åŽŸã€‚ NLPä¸­æ•°æ®çš„ç‰¹å¾ï¼š è¾“å…¥æ˜¯ä¸€ç»´çº¿æ€§ è¾“å…¥æ˜¯ä¸å®šé•¿ å•è¯æˆ–è€…å­å¥çš„ç›¸å¯¹ä½ç½®å¾ˆé‡è¦ RNN çš„ç¼ºç‚¹ï¼Œé¦–å…ˆæ˜¯æ•æ‰é•¿è·ç¦»ä¾èµ–ï¼Œå¯ä»¥è¢«LSTM æ¯”è¾ƒæœ‰æ•ˆçš„è§£å†³ï¼›å¦ä¸€ä¸ªç¼ºç‚¹ï¼ŒRNN è¿™ç§åºåˆ—çš„çº¿æ€§ç»“æž„å¯¹äºŽå¹¶è¡Œè¿ç®—æ˜¯ä¸åˆ©çš„ã€‚CNN çš„ç‰¹ç‚¹å…³é”®åœ¨äºŽæ»‘åŠ¨çª—å£]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>å…³é”®è¯æå–</tag>
        <tag>oov</tag>
        <tag>ä¸­æ–‡åˆ†è¯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pythonä¸­çš„å¤šçº¿ç¨‹å’Œå¤šè¿›ç¨‹]]></title>
    <url>%2F2019%2F03%2F25%2FPython%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[å¤šçº¿ç¨‹å’Œå¤šè¿›ç¨‹é—®é¢˜æ˜¯å¯ä»¥å¯¹åº”åˆ° å¹¶å‘ ï¼ˆcncurrencyï¼‰å’Œå¹¶è¡Œ(parallelism)ä¸Šçš„ã€‚ å¹¶å‘ï¼Œå°±æ˜¯ä¸€ä¸ªå•æ ¸cpuåŒæ—¶å¼€å§‹äº†å¤šä¸ªä»»åŠ¡ï¼Œä½†æ˜¯è¿™ä¸ªä»»åŠ¡å¹¶ä¸æ˜¯åŒæ—¶ç‹¬ç«‹è¿›è¡Œçš„ï¼Œè€Œæ˜¯é€šè¿‡cpuçš„ä¸æ–­åˆ‡æ¢ï¼Œä¿å­˜çŽ°åœºï¼Œç„¶åŽé‡å¯è¿™æ ·çš„å¿«é€Ÿçš„åˆ‡æ¢ï¼Œç»™ç”¨æˆ·çš„æ„Ÿè§‰æ˜¯å¹¶å‘ï¼Œä½†æ˜¯å®žé™…ä¸Šæ˜¯cpuçš„è®¡ç®—èƒ½åŠ›å—åˆ°äº†é™åˆ¶ï¼Œç”¨æˆ·ä½“éªŒæ¯”è¾ƒå¥½ä¸€äº›ã€‚å¦‚æžœåœ¨å¤šæ ¸cpu ï¼ˆæ¯”å¦‚æˆ‘çš„mac æ˜¯ä¸€cpu 6æ ¸ï¼‰è¿™æ ·çš„è¯å®Œå…¨æ˜¯å¯ä»¥è¾¾åˆ°å¹¶è¡Œçš„ï¼Œè¿™ä¸ªæ˜¯çœŸæ­£çš„ç‹¬ç«‹æ“ä½œ(parallelism)ï¼Œå¯¹åº”çš„æ˜¯å¤šè¿›ç¨‹çš„ã€‚å¯¹åº”python ä¸­çš„å®žçŽ°å¤šçº¿ç¨‹æ˜¯ä½¿ç”¨threadingï¼Œå¤„ç†çš„æ˜¯io å“åº”ï¼›å¤šè¿›ç¨‹æ˜¯Concurrencyï¼Œä½¿ç”¨multiprocessingåŒ…ï¼Œå¤„ç†çš„æ˜¯å¤šæ ¸cpuçš„æ“ä½œã€‚ Take off: å¦‚æžœå¤„ç†io å“åº”ï¼Œé‚£ä¹ˆä½¿ç”¨å¤šçº¿ç¨‹ï¼›å¦‚æžœæ˜¯è®¡ç®—ï¼Œé‚£ä¹ˆä½¿ç”¨å¤šè¿›ç¨‹ã€‚ So, before we go deeper into the multiprocessing module, itâ€™s worthwhile ensuring you know the advantages of using multiprocessing over multithreading. The general rule of thumb is that, if you are trying to improve the performance of CPU-bound tasks, multiprocessing is what you want to use. However, if your particular task is Input/Output bound, then youâ€™ll generally want to use multithreading to improve the performance of your applications. è¿™ä¸ªæ˜¯å¤šçº¿ç¨‹çš„demo å“åº”çš„io è¯·æ±‚ã€‚ 1234567891011121314151617181920212223242526272829import threadingclass Worker(threading.Thread): # Our workers constructor, note the super() method which is vital if we want this # to function properly def __init__(self): super(Worker, self).__init__() def run(self): for i in range(10): print(i)def main(): thread1 = Worker() thread1.start() thread2 = Worker() thread2.start() thread3 = Worker() thread3.start() thread4 = Worker() thread4.start()if __name__ == "__main__": main() ä¸‹é¢æ˜¯å¤šè¿›ç¨‹çš„demoå“åº”çš„è®¡ç®—è¯·æ±‚ã€‚ 123456789101112131415161718import multiprocessing as mpdef my_func(x): print(mp.current_process()) return x ** xdef main(): pool = mp.Pool(mp.cpu_count()) # è¿™ä¸ªè¿˜æ˜¯å¾ˆå¥½çš„ pool è¿™ä¸ªçš„ä¸ªæ•°å’Œä½ çš„cpu count æ˜¯ä¿æŒä¸€è‡´çš„ result = pool.map(my_func, [4, 2, 3, 5, 3, 2, 1, 2]) result_set_2 = pool.map(my_func, [4, 6, 5, 4, 6, 3, 23, 4, 6]) print(result) print(result_set_2)if __name__ == "__main__": main()]]></content>
      <categories>
        <category>CSåŸºç¡€</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Data Pre-processing å­¦ä¹ ç¬”è®°]]></title>
    <url>%2F2019%2F03%2F25%2FData-Pre-processing%2F</url>
    <content type="text"><![CDATA[ä¸»è¦ä»‹ç»æœºå™¨å­¦ä¹ ä¸­çš„æ•°æ®é¢„å¤„ç†ï¼ˆè¿™é‡Œä¸»è¦è®²çš„æ˜¯æ•°å€¼åž‹æ•°æ®çš„é¢„å¤„ç†ï¼Œè€Œéžä¸­æ–‡æ•°æ®é¢„å¤„ç†ï¼‰ï¼ŒåŒ…æ‹¬ data cleaningã€data integrationã€ data transformationã€data reductionã€data imbalanced å’Œä¸€äº›æ¦‚å¿µã€‚ data normalization æ˜¯ç»å¸¸ç”¨åˆ°çš„ã€‚ æ•°æ®é¢„å¤„ç†çš„æ—¶å€™éœ€è¦æ³¨æ„ missing valuesã€noisy data (outlier) ï¼Œå¯¹äºŽè¿™ç§çŽ°è±¡åº”è¯¥åˆ†æˆè¦ä¸è¦å¤„ç†å’Œå¦‚ä½•å¤„ç†ä¸¤ä¸ªé—®é¢˜ã€‚ æ•°æ®æ¸…æ´— (ç¼ºçœå€¼ã€å¼‚å¸¸å€¼çš„å¤„ç†)ã€æ•°æ®æ•´åˆ (å­è¡¨ åˆå¹¶åˆ° or æˆä¸»è¡¨)ã€æ•°æ®è½¬æ¢ (one-hot or label encodingï¼Œ è¿žç»­æ•°å€¼ç¦»æ•£åŒ–)ã€å’Œæ•°æ®é™ç»´ (å¯ä»¥å•ç‹¬çš„æˆä¸€ç« )ã€‚è¿™ä¸ªå‡ ä¸ªæ­¥éª¤åº”è¯¥æ˜¯ç†Ÿè®°äºŽå¿ƒçš„ã€‚ Data Cleaningè¿™ä¸ªæ­¥éª¤ä¸»è¦å¤„ç† missing values å’Œ noisy data (outlier).å¯¹äºŽmissing values ï¼Œå¯ä»¥åˆ†æˆä¸¤ä¸ªé—®é¢˜ï¼Œè¦ä¸è¦å¤„ç† å’Œå¦‚ä½•å¤„ç†ï¼Œå…·ä½“è¯´æ¥æœ‰ä»¥ä¸‹å¤„ç†æ‰‹æ®µï¼š ignore the tuple; fill in the missing value manually use a global constant to fill in the missing value use the attribute mean to fill in the missing value (å‡å€¼) use the most probable value to fill in the missing value (mode ä¼—æ•°) æœ‰æ—¶å€™å°±æ˜¯æ ¹æ®æŸå‡ ä¸ªç‰¹å¾ç„¶åŽå¼„ä¸€ä¸ªç®€å•çš„å›žå½’æ¨¡åž‹ï¼Œæ ¹æ®æ¨¡åž‹è¿›è¡Œpredict å…³äºŽè¿™å‡ ç§æ–¹æ³•å¦‚ä½•åŽ»é€‰æ‹©ï¼Œæˆ‘å¦‚æžœè¯´ â€œit dependsâ€ï¼Œé‚£ä¹ˆå…¶ä»–äººä¸è®¤ä¸ºè¿™æ˜¯ä¸€ä¸ªå…·æœ‰è¯´æœåŠ›çš„ç­”æ¡ˆï¼Œä»–ä»¬æ›´åƒçŸ¥é“ it depends what, and when and why to use specific method? æˆ‘è®¤ä¸ºåº”è¯¥æ˜¯æ ¹æ®ç¼ºçœå€¼ç¨‹åº¦å’Œé‡è¦æ€§è¿›è¡Œç»éªŒæ€§çš„é€‰æ‹©ï¼Œè¿™ä¹ŸåŽ»å°±æ˜¯ empirical studyå§ã€‚ æŽ¥ç€æ˜¯ noisy data (outlier)ï¼Œæˆ‘çš„è§‚ç‚¹æ˜¯é¦–å…ˆå¾—è®¤è¯†åˆ°è¿™ä¸ªæ˜¯é”™è¯¯çš„æ•°æ®ï¼Œä¸æ˜¯çœŸå®žçš„æ•°æ®æ¥æºï¼Œå¯èƒ½æ˜¯æ¥è‡ªäººä¸ºçš„ç¬”è¯¯ æˆ–è€…ä»ªå™¨è®°å½•çš„é—®é¢˜ï¼Œè¿™ä¸ªæ˜¯éœ€è¦ä¿®æ”¹çš„ã€‚å¯ä»¥ä½¿ç”¨èšç±» (clustering) è¿›è¡Œnoisy data çš„æ£€æµ‹ï¼Œæ‰¾åˆ°ä¹‹åŽè¿™ä¸ªå°±ç±»ä¼¼ missing valueäº†ï¼Œå¯ä»¥é‡‡å–ä»¥ä¸Šçš„æ‰‹æ®µè¿›è¡Œæ“ä½œï¼Œåº”è¯¥æ³¨æ„åˆ°çš„è¿™ä¸ª noisy data æ‰€å æ¯”ä¾‹ä¸ä¼šå¾ˆé«˜ï¼Œå¦åˆ™å°±æˆäº†ä¸»è¦çš„æ•°æ®åˆ†å¸ƒäº†ã€‚ Data Integration:å¤„ç†æ•°æ®åº“æ•°æ®ï¼Œç»å¸¸æ˜¯éœ€è¦å¤„ç†å­è¡¨ä¿¡æ¯çš„ï¼Œé‚£ä¹ˆå¿…ç„¶å­˜åœ¨ç€ä¸»è¡¨ï¼Œè€Œå­è¡¨ç³»ä¿¡æ¯å¾€å¾€æ˜¯ä¸»è¡¨ä¿¡æ¯çš„æŸä¸€æ–¹é¢çš„ç»†åŒ–ã€‚æ‰€ä»¥æœ‰å¿…è¦å°†ä¸¤è€…è¿žæŽ¥èµ·æ¥ã€‚ Data Transformation:In data transformation, the data are transformed or consolidated into forms appropriate for mining.è¿™é‡Œæƒ³è¦æ¾„æ¸…çš„æ˜¯å¾ˆå¤šç›¸åŒçš„å†…å®¹éƒ½å¯ä»¥ç”¨ä¸åŒçš„æ–¹å¼è¡¨è¾¾ï¼Œå¹¶ä¸”å¯ä»¥æ”¾åœ¨æ•°æ®å¤„ç†çš„ä¸åŒé˜¶æ®µï¼Œå¹¶ä¸”è¿™ç§å·¥ä½œä¸æ˜¯ä¸€æ¬¡æ€§å®Œæˆçš„ï¼Œè€Œæ˜¯è¿­ä»£çš„ until you run out your patience and time.é¦–å…ˆæˆ‘æŽ¥è§¦çš„æœ€å¸¸è§çš„å°±æ˜¯ discrete variables -&gt; continuous variables. å½“ç„¶å¯¹äºŽ discrete variablesï¼ŒåŸºäºŽæ ‘ç»“æž„çš„æœºå™¨å­¦ä¹ æ¨¡åž‹æ˜¯å¯ä»¥å¤„ç†çš„ï¼Œè¿™é‡Œæƒ³è¯´çš„æ˜¯æœ‰è¿™ç§æ–¹å¼ã€‚è¿™ç§ transformation å¸¸è§çš„å¤„ç†æ–¹å¼: one-hot æˆ–è€… label encoding. å¦‚æžœæŒ‰ç…§ data transformationçš„é¢„è®¾ï¼Œé‚£ä¹ˆ normalization å°±ä¹Ÿå±žäºŽè¯¥æ¨¡å—çš„å†…å®¹ã€‚ ä¸è®ºæ˜¯åœ¨ machine learning è¿˜æ˜¯åœ¨ å›¾åƒå¤„ç†çš„æ—¶å€™ï¼Œå¯¹äºŽåŽŸå§‹çš„æ•°æ®ç»å¸¸é‡‡å– normalization. ä¸€æ–¹é¢è¿™ä¸ªæ˜¯å¯ä»¥é¢„é˜²æ¢¯åº¦æ¶ˆå¤± æˆ–è€… gradient exploding, å¦‚æžœä½ é‡‡ç”¨äº† Sigmoidçš„æ¿€æ´»å‡½æ•°çš„è¯ã€‚å¦ä¸€æ–¹é¢æˆ‘è®¤ä¸ºæ›´åŠ é‡è¦çš„åŽŸå› æ˜¯å°† ä¸åŒçš„æ•°æ®æ”¾åœ¨äº†åŒä¸€ä¸ªå°ºåº¦ä¸‹ï¼Œå¦‚æžœä½ é‡‡å–äº† normalizationä¹‹åŽã€‚ Data Reduction:ä¸€èˆ¬æ¥è¯´å¾ˆå°‘æåŠåˆ°åˆ° data reductionçš„å¿…è¦æ€§ï¼Œå¦‚æžœéžè¦ç»™å‡ºåŽŸå› ï¼Œé‚£ä¹ˆå¯ä»¥ä»Žæ—¶é—´å’Œç©ºé—´çš„è§’åº¦è¿›è¡Œè€ƒè™‘ã€‚æ›´åŠ éœ€è¦å…³æ³¨çš„æ˜¯å¦‚ä½•åšçš„é—®é¢˜ã€‚ æˆ‘çš„ç†è§£reduction å¯ä»¥ä»Žä¸¤ä¸ªç»´åº¦è¿›è¡Œè€ƒè™‘ï¼Œå‡è®¾ä¸€ä¸ª matrics A æ˜¯ m*nï¼Œè¿™ä¸ªæ˜¯ä¸€ä¸ªäºŒç»´çš„çŸ©é˜µï¼Œé‚£ä¹ˆå¯ä»¥ä»Ž è¡Œåˆ—ä¸¤æ–¹é¢å…¥æ‰‹ã€‚æ˜ å°„åˆ°æœºå™¨å­¦ä¹ ä¸­ä¸€èˆ¬è¿™æ ·æè¿° ä»Ždimension å’Œ dataä¸¤ä¸ªè§’åº¦åŽ»æè¿°ï¼Œåˆ†åˆ«ç§°ä¹‹ä¸º dimension reduction å’Œ data compression. å‰è€…æŒ‡çš„æ˜¯ç‰¹å¾çš„é€‰å–ï¼ŒåŽè€…æ˜¯æ•°æ®sizeçš„å‡å°‘ã€‚dimension reduction: where irrelevant, weakly relevant, or redundant attributes or dimensions may be detected and removed.data compression: PCA çº¿æ€§é™ç»´ to reduce the data set size. è¿™ä¸ªæ˜¯é’ˆå¯¹æŸä¸€ä¸ªç‰¹å¾å±•å¼€çš„ã€‚ Data Normalization æ˜¯ä»€ä¹ˆï¼Ÿ ä¸­å¿ƒåŒ–ï¼š å‡å€¼ä¸º0ï¼Œå¯¹æ–¹å·®æ²¡æœ‰è¦æ±‚ $$x ^ { \prime } = x - \mu$$ æ ‡å‡†åŒ–ï¼šæœä»Žæ­£å¤ªåˆ†å¸ƒ (0, 1) $$x ^ { \prime } = \frac { x - \overline { x } } { \sigma }$$ å½’ä¸€åŒ–æœ‰ä¸¤ç§ï¼š mean normalization å’Œ min-max normalization mean normalization$$x ^ { \prime } = \frac { x - \operatorname { mean } ( x ) } { \max ( x ) - \min ( x ) }$$ min-max normalization $$x ^ { \prime } = \frac { x - \operatorname { min } ( x ) } { \max ( x ) - \min ( x ) }$$ ä¸ºä»€ä¹ˆï¼Ÿ æé«˜æ¨¡åž‹çš„å‡†ç¡®çŽ‡æ¯”å¦‚è¯´ä¸¤ä¸ªç‰¹å¾ï¼Œä¸€ä¸ªç‰¹å¾çš„èŒƒå›´æ˜¯0-100ï¼Œ å¦ä¸€ä¸ªæ˜¯-2000 åˆ°2000ï¼Œ è¿™ä¸ªä½¿ç”¨ æ¬§å¼è·ç¦»è¿›è¡Œè®¡ç®—çš„æ—¶å€™ï¼Œä¸¤ä¸ªç‰¹å¾çš„å·®å€¼å¾ˆå¤§ï¼Œç‰¹å¾å¹¶æ²¡æœ‰ç«™åœ¨åŒä¸€ä¸ªç»´åº¦ä¸Šã€‚ æé«˜æ¨¡åž‹çš„é€Ÿåº¦è¿˜æ˜¯ä¸Šé¢çš„ä¾‹å­ï¼Œä¸¤ä¸ªç‰¹å¾x1 x2çš„å–å€¼èŒƒå›´æ¯”è¾ƒå¤§ï¼Œé‚£ä¹ˆå­¦ä¹ çŽ‡ä¸Šå˜å¾—æ³¢åŠ¨ï¼Œæ‰€ä»¥å­¦ä¹ æ—¶é—´ä¼šå˜é•¿ã€‚ æ·±åº¦å­¦ä¹ ä¸­æ•°æ®å½’ä¸€åŒ–å¯ä»¥é˜²æ­¢æ¨¡åž‹æ¢¯åº¦çˆ†ç‚¸ä»¥sigmoid å‡½æ•°ä¸ºä¾‹è§£é‡Šå°±è¡Œ æ€Žä¹ˆåšï¼Ÿå®šä¹‰å°±æ˜¯è¡¨ç¤ºæ€Žä¹ˆåš é€‚ç”¨èŒƒå›´ æ¦‚çŽ‡æ¨¡åž‹ä¸éœ€è¦å½’ä¸€åŒ–ï¼Œå› ä¸ºå®ƒä»¬ä¸å…³å¿ƒå˜é‡çš„å€¼ï¼Œè€Œæ˜¯å…³å¿ƒå˜é‡çš„åˆ†å¸ƒå’Œå˜é‡ä¹‹é—´çš„æ¡ä»¶æ¦‚çŽ‡ï¼Œå¦‚å†³ç­–æ ‘ã€rfã€‚è€Œåƒadaboostã€svmã€lrã€KNNã€KMeansä¹‹ç±»çš„æœ€ä¼˜åŒ–é—®é¢˜å°±éœ€è¦å½’ä¸€åŒ–ã€‚ æ˜ å°„åˆ° N(0,1) çš„è¿™ç§è¡Œä¸ºï¼Œå«åšå½’ä¸€åŒ–ã€‚Feature scaling is the method to limit the range of variables so that they can be compared on common grounds. æœ‰ä¸‰ä¸ªä¸»è¦çš„åŽŸå› ã€‚ Because most of the Machine Learning models are based on Euclidean Distance. Age- 40 and 27Salary- 72000 and 48000 è¿™ä¸¤ä¸ªç‰¹å¾ï¼Œè¿™ä¸¤ä¸ªè·ç¦»ç›¸å·®å¾ˆå¤§ï¼›ä½†æ˜¯è¿™ä¸ªå¹¶ä¸æ˜¯æˆ‘ä»¬æƒ³è¦çš„ï¼Œæˆ‘ä»¬æƒ³è¦çš„æ˜¯ç›¸å¯¹å€¼ï¼Œè€Œä¸æ˜¯ç»å¯¹å€¼ã€‚ å³ä½¿æœ€åŽçš„loss functionä¸æ˜¯ euclidean distanceï¼Œæ¯”å¦‚è¯´decision treeï¼Œå®žè·µè¯æ˜Žç»è¿‡æ­£åˆ™åŒ–çš„ä¹‹åŽçš„æ•°æ®çš„è®­ç»ƒé€Ÿåº¦æ˜¯å¿«äºŽ æ²¡æœ‰ç»è¿‡æ­£åˆ™åŒ–çš„æ•°æ®çš„ã€‚ ç»è¿‡å½’ä¸€åŒ–ä¹‹åŽï¼Œæ•°æ®æ˜¯ä¸å®¹æ˜“å‡ºçŽ°æ¢¯åº¦æ¶ˆå¤±æˆ–è€…æ¢¯åº¦çˆ†ç‚¸çš„ã€‚ å¾ˆå¤šæ¨¡åž‹çš„åŸºæœ¬å‡è®¾ å°±æ˜¯ N(0,1) é«˜æ–¯åˆ†å¸ƒã€‚ å®žçŽ°çš„ä¸‰ç§æ‰‹æ®µï¼š rescaling (min-max normalization) $$x ^ { \prime } = \frac { x - \min ( x ) } { \max ( x ) - \min ( x ) }$$ mean normalization $$x ^ { \prime } = \frac { x - \operatorname { average } ( x ) } { \max ( x ) - \min ( x ) }$$ standardization $$x ^ { \prime } = \frac { x - \overline { x } } { \sigma }$$ data imbalancedæœºå™¨å­¦ä¹ ä¸­çš„ç‰¹å¾å·¥ç¨‹æ˜¯æœ‰ä¸€å®šæŠ€å·§å¯è¨€ï¼Œå…¶ä¸­æˆ‘è§‰å¾—æœ€ä¸ºæœ‰è¶£çš„æ˜¯: generation or you can call it abstraction. å¯¹äºŽç‰¹å¾çš„æ³›çš„æå–æ‰æ˜¯å¯¹äºŽé—®é¢˜æœ¬èº«æˆ–è€…ç‰¹å¾çš„ç†è§£ï¼Œè¿™ä¸ä»…éœ€è¦ç§¯ç´¯ï¼Œæ›´éœ€è¦å¯¹äºŽè¯¥é—®é¢˜é¢†åŸŸçš„ä¸“ä¸šçŸ¥è¯†ï¼Œ thatâ€™s all.ä¸¾ä¸ªæ —å­ï¼Œåœ¨ â€œHome Credit Default Riskâ€ (kaggle ç«žèµ›)ä¸­ï¼ŒåŽŸå§‹çš„è®­ç»ƒæ•°æ®æœ‰ä¿¡è´·é‡‘é¢å’Œå®¢æˆ·çš„å¹´æ”¶å…¥ï¼Œè¿™ä¸ªæ—¶å€™ â€œcredit_income_percentâ€ å°±æ˜¯ç±»ä¼¼è¿™ç§æ€§è´¨çš„æå–ç‰¹å¾ã€‚ å¤ä¹ ç¬”è®° æ•°æ®é¢„å¤„ç†æ˜¯ä¸€ç³»åˆ—æ¯”è¾ƒçç¢Žçš„å·¥ä½œã€‚ä¸»è¦å¤„ç†çš„ç‚¹æœ‰ï¼šç¼ºçœå€¼ã€å¼‚å¸¸å€¼ã€å­è¡¨/ ä¸»è¡¨ï¼Œ æ•°æ®è½¬æ¢ï¼ˆone-hot, label encoding, è¿žç»­æ•°å€¼ç¦»æ•£åŒ–ï¼‰å’Œæ•°æ®é™ç»´ã€‚å¯¹äºŽå¼‚å¸¸å€¼çš„æ£€æµ‹ä½¿ç”¨èšç±»ï¼Œå¾ˆå®¹æ˜“å‘çŽ°è¿™äº›æ˜Žæ˜¾çš„noisy dataã€‚è¿™ä¸ªåšå®¢çš„æ€»ç»“å°±æ˜¯ä¸Šé¢çš„ä¸œè¥¿ã€‚å¤šçœ‹çœ‹ã€‚]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Finding Similar Quora Questions]]></title>
    <url>%2F2019%2F03%2F25%2Fquora-questions%2F</url>
    <content type="text"><![CDATA[ä»‹ç» kaggle ä¸Š finding similar quora quesitons ç«žèµ›ï¼Œä½œä¸ºä¸€æ¬¡æ€»ç»“ã€‚ é—®é¢˜æè¿°åˆ¤æ–­ä¸€å¯¹é—®é¢˜æ˜¯å¦é‡å¤ã€‚è¿™ç§é—®é¢˜çš„ç ”ç©¶æ˜¯éžå¸¸æœ‰ä»·å€¼ï¼Œå¦‚æžœå‘çŽ°ç”¨æˆ·æå‡ºäº†ä¸€ä¸ªé‡å¤çš„å·²ç»å›žç­”è¿‡çš„é—®é¢˜ï¼Œé‚£ä¹ˆå¯ä»¥ç›´æŽ¥è¿”å›žç»™ç”¨æˆ·ç­”æ¡ˆï¼Œæé«˜äº†ç”¨æˆ·ä½“éªŒã€‚ ç®€è¦è¯´æ˜Žä¸€ä¸‹ kaggle ä¸Šæ€»çš„è¯„åˆ†æœºåˆ¶ï¼šåœ¨è®¡ç®—å¾—åˆ†çš„æ—¶å€™ï¼ŒPublic Leaderboard (LB)å’Œ Private LB ä¹‹åˆ†ã€‚å…·ä½“è€Œè¨€ï¼Œå‚èµ›é€‰æ‰‹æäº¤æ•´ä¸ªæµ‹è¯•é›†çš„é¢„æµ‹ç»“æžœï¼ŒKaggle ä½¿ç”¨æµ‹è¯•é›†çš„ä¸€éƒ¨åˆ†è®¡ç®—å¾—åˆ†å’ŒæŽ’åï¼Œå®žæ—¶æ˜¾ç¤ºåœ¨ Public LBä¸Šï¼Œç”¨äºŽç»™é€‰æ‰‹æä¾›åŠæ—¶çš„åé¦ˆå’ŒåŠ¨æ€å±•ç¤ºæ¯”èµ›çš„è¿›è¡Œæƒ…å†µï¼›æµ‹è¯•é›†çš„å‰©ä½™éƒ¨åˆ†ç”¨äºŽè®¡ç®—å‚èµ›é€‰æ‰‹çš„æœ€ç»ˆå¾—åˆ†å’ŒæŽ’åï¼Œæ­¤å³ä¸º Private LBï¼Œåœ¨æ¯”èµ›ç»“æŸåŽä¼šæ­æ™“ã€‚ é’ˆå¯¹äºŽè¯¥é—®é¢˜ï¼Œä½¿ç”¨çš„log loss ä½œä¸ºè¯„åˆ†ä¾æ®ï¼Œæäº¤çš„æ–‡ä»¶ä¸­æ¯ä¸€å¯¹é—®é¢˜å¹¶ä¸æ˜¯ç»™å‡º {0, 1} è¿™æ ·çš„äºŒå€¼ï¼Œè€Œæ˜¯ç»™å‡ºåŒºé—´ [0,,1] çš„æµ®ç‚¹æ•°ï¼Œç„¶åŽpredict çš„ç»“æžœå’ŒçœŸå®žçš„ç»“æžœï¼Œè®¡ç®— log lossã€‚ä½œä¸ºæœ€åŽçš„å¾—åˆ†ï¼Œè¯¥loss çš„å–å€¼èŒƒå›´æ˜¯ [0, 1] ï¼Œå¦‚æžœç»“æžœè¶Šå°ï¼Œè¯´æ˜Žé¢„æµ‹è¶Šå‡†ç¡®ã€‚ æˆ‘çš„æƒ…å†µï¼š æ€»å…±æ˜¯3000å¤šä¸ªé˜Ÿä¼å§ï¼Œæœ€åŽçš„æŽ’åæ˜¯åœ¨ 5% ï¼ˆåœ¨150åä¹‹å†…ï¼‰ æ•°æ®ç‰¹ç‚¹ æ•°æ®è§„æ¨¡ æ€»ä½“ï¼š training data: 40 ä¸‡ï¼Œ 400,000 , 63M test data: å…¶ä¸­æœ‰æœºå™¨ç”Ÿæˆçš„è™šå‡çš„æ•°æ®ï¼Œä¸ä½œä¸ºæœ€åŽçš„è¯„åˆ†ï¼Œä½†æ˜¯å­˜åœ¨, 314 M è¿™ä¸ªä»Žæ•°é‡ä¸Šå……åˆ†è¯´æ˜Žäº†å†—ä½™çš„æ•°æ®ï¼Œé˜²æ­¢äººå·¥ä½œå¼Šçš„ã€‚ training data çš„å­—æ®µï¼š 1234id: Looks like a simple rowIDqid&#123;1, 2&#125;: The unique ID of each question in the pairquestion&#123;1, 2&#125;: The actual textual contents of the questions.is_duplicate: The label that we are trying to predict - whether the two questions are duplicates of each other. å¥å­çš„é¢‘æ•° ï¼šä½¿ç”¨ qid ç»Ÿè®¡åœ¨è®­ç»ƒé›†ä¸­å‡ºçŽ°çš„æ¬¡æ•°ã€‚ å‘çŽ°å¤§å¤šæ•°å¥å­çš„é‡å¤çŽ‡æ¯”è¾ƒä½Žã€‚ 1234567891011121314print('Total number of question pairs for training: &#123;&#125;'.format(len(df_train)))print('Duplicate pairs: &#123;&#125;%'.format(round(df_train['is_duplicate'].mean()*100, 2)))qids = pd.Series(df_train['qid1'].tolist() + df_train['qid2'].tolist())print('Total number of questions in the training data: &#123;&#125;'.format(len( np.unique(qids))))print('Number of questions that appear multiple times: &#123;&#125;'.format(np.sum(qids.value_counts() &gt; 1)))plt.figure(figsize=(12, 5))plt.hist(qids.value_counts(), bins=50)plt.yscale('log', nonposy='clip')plt.title('Log-Histogram of question appearance counts')plt.xlabel('Number of occurences of question')plt.ylabel('Number of questions')print() In terms of questions, everything looks as I would expect here. Most questions only appear a few times, with very few questions appearing several times (and a few questions appearing many times). One question appears more than 160 times, but this is an outlier. è®­ç»ƒæ•°æ®é›†ä¸­å¥å­word çš„ä¸ªæ•° çš„åˆ†å¸ƒï¼Œå¯ä»¥çœ‹å‡ºä¸€èˆ¬æ˜¯åœ¨20 å·¦å³çš„é•¿åº¦ word çš„å¥å­æ˜¯æœ€å¤šçš„ã€‚ è®­ç»ƒæ•°æ®é›†ä¸­ character ä¸ªæ•°çš„åˆ†å¸ƒ æ³¨æ„åˆ°ä¸¤ä¸ªåˆ†å¸ƒéƒ½æ˜¯å³åæ€åˆ†å¸ƒï¼ˆæ­£åæ€ï¼‰ï¼Œä»Žæ•°å­¦çš„è§’åº¦ç†è§£ mean &gt; median. åŒç†ä¹Ÿæœ‰å·¦åæ€åˆ†å¸ƒã€‚åæ€åˆ†å¸ƒåˆæ˜¯ç›¸å¯¹äºŽæ­£å¤ªåˆ†å¸ƒè€Œè¨€çš„ã€‚è¿™ç§åæ€çš„å®šä¹‰ï¼Œæ˜¯ä»¥å°¾éƒ¨å‘½åï¼Œå³åæ€æˆ–è€…æ­£åæ€çš„å°¾éƒ¨ï¼Œé›†ä¸­åœ¨å³ä¾§ã€‚ ç”±ä¸Šé¢çš„ä¾‹å­å¯ä»¥çœ‹å‡ºï¼Œä¸ç®¡æ˜¯æ­£åæ€åˆ†å¸ƒè¿˜æ˜¯è´Ÿåæ€åˆ†å¸ƒï¼Œç”±äºŽå—åæ€åˆ†å¸ƒçš„å½±å“ï¼Œä¼—æ•°ä¸Žå‡å€¼å€¼å‘ç”Ÿå˜åŒ–ï¼Œè€Œå‡å€¼çš„å½±å“æ›´å¤§ã€‚ ä¸­ä½æ•°ä»…ä¸Žæ ·æœ¬æ€»æ•°æœ‰å…³ï¼Œå³åœ¨æ•´ä¸ªæ ·æœ¬çš„ä¸­é—´ä½ç½®ï¼Œè€Œåœ¨æ­£åæ€åˆ†å¸ƒï¼Œå¤§éƒ¨åˆ†å€¼åœ¨å³°å€¼ï¼ˆä¼—æ•°ï¼‰çš„å³è¾¹ï¼Œæ•…ä¸­ä½æ•°åœ¨ä¼—æ•°çš„å³è¾¹ï¼ˆä¼—æ•°ï¼œä¸­ä½æ•°ï¼‰ ä¸­ä½æ•°ä¸Žå‡å€¼çš„æ¯”è¾ƒäº†ï¼Ÿç”±äºŽå‡å€¼å—æžå¤§å€¼çš„å½±å“å˜å¤§è€Œä¸­ä½æ•°ä¸å—å½±å“ï¼Œæ•…å‡å€¼å¤§äºŽä¸­ä½æ•°ï¼ˆä¸­ä½æ•°ï¼œå‡å€¼ï¼‰ æ‰€ä»¥ ä¼—æ•° &lt; ä¸­ä½æ•° &lt; å‡å€¼ é¦–å…ˆä¼—æ•°ä¸Žä¸­ä½æ•°çš„æ¯”è¾ƒ è¿™ä¸ªåˆ†å¸ƒæ˜¯å·¦åçš„ï¼Œå¤§éƒ¨åˆ†å€¼æ˜¯åœ¨å³°å€¼ï¼ˆä¼—æ•°ï¼‰çš„å·¦è¾¹ï¼Œæ•…ä¼—æ•°å¤§äºŽä¸­ä½æ•° å‡å€¼ä¸Žä¸­ä½æ•°çš„æ¯”è¾ƒ ç”±äºŽæ˜¯è´Ÿåæ€åˆ†å¸ƒï¼Œæžå°å€¼å¯¹å‡å€¼çš„å½±å“å¤§ï¼ˆæžå°å€¼å¯¹å‡å€¼æ‹‰ä½Žï¼‰ï¼Œæ•…å‡å€¼å°äºŽä¸­ä½æ•° æ‰€ä»¥ å‡å€¼ï¼œä¸­ä½æ•°ï¼œä¼—æ•° training data å’Œ test data ä¸­çš„æ­£è´Ÿæ ·æœ¬æœ‰å¾ˆå¤§çš„å·®åˆ« However, before I do this, I would like to rebalance the data that XGBoost receives, since we have 37% positive class in our training data, and only 17% in the test data. é‡‡å–çš„æŽªæ–½ Rebalancing the Data (è¿™é‡Œæ‰€è°“çš„ rebalance data å°±æ˜¯å°†åŽŸå§‹çš„ä¸€éƒ¨åˆ†æ•°æ®é›†åŽ»æŽ‰ï¼Œå‡å°‘ æ­£æ ·ä¾‹çš„ä¸ªæ•°)ã€‚ åŽŸå› æœ‰ä¸¤ç‚¹ï¼š æœºå™¨å­¦ä¹ ç®—æ³•çš„åŸºæœ¬å‡è®¾å°±æ˜¯ç‹¬ç«‹åŒåˆ†å¸ƒï¼Œå¦‚æžœ train data å’Œtest data ä¸èƒ½ä¿æŒåŒåˆ†å¸ƒï¼Œé‚£ä¹ˆæ³›åŒ–æ€§èƒ½ä¸èƒ½è¦æ±‚å¾ˆé«˜ å› ä¸ºå¯¹äºŽ log loss çš„è®¡ç®—ä¿æŒæ­£è´Ÿæ ·ä¾‹çš„æ¯”ä¾‹ï¼Œå¯¹äºŽæœ€åŽçš„ç»“æžœæ˜¯é‡è¦çš„ã€‚ ç‰¹å¾ä¸»è¦åˆ†æˆä¸¤ç±»ï¼šä¼ ç»Ÿçš„æ•°æ®æŒ–æŽ˜çš„ç‰¹å¾+ NLP embedding å‘é‡ç‰¹å¾ ä¼ ç»Ÿæ•°æ®æŒ–æŽ˜ç‰¹å¾ character of length of questions 1 and 2 number of words in question 1 and 2 number of character in question 1 and question 2 difference of length å­—ç¬¦ä¸²çš„ç²¾ç¡®åŒ¹é…å’Œéƒ¨åˆ†åŒ¹é…ï¼ˆfuzzywuzzy å·¥å…·ï¼‰ numbers of capital letters, questions marks, æ•°å­— normalized word share count (éžå¸¸å…·æœ‰ prediction çš„ç‰¹å¾)è®¡ç®—å®žçŽ°ï¼š 12345678910111213141516def word_match_share(row): q1words = &#123;&#125; q2words = &#123;&#125; for word in str(row['question1']).lower().split(): if word not in stops: q1words[word] = 1 for word in str(row['question2']).lower().split(): if word not in stops: q2words[word] = 1 if len(q1words) == 0 or len(q2words) == 0: # The computer-generated chaff includes a few questions that are nothing but stopwords return 0 shared_words_in_q1 = [w for w in q1words.keys() if w in q2words] shared_words_in_q2 = [w for w in q2words.keys() if w in q1words] R = (len(shared_words_in_q1) + len(shared_words_in_q2))/(len(q1words) + len(q2words)) return R æˆ‘è®¤ä¸ºè¿™ä¸ªå®šä¹‰åº”è¯¥æ˜¯ä¸¤ä¸ªå¥å­çš„äº¤é›†/ ä¸¤ä¸ªå¥å­çš„å¹¶é›†ã€‚ å’Œä¸Šé¢çš„å®žçŽ°ä¸çŸ¥é“æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿåæ­£è¿™ä¸ªç‰¹å¾æ˜¯éžå¸¸ preditable çš„ NLP æ–¹é¢çš„å¤„ç† åŸºäºŽè¯å‘é‡å¾—åˆ°å¾—åˆ°çš„å¥å­å‘é‡çš„ç›¸å…³è·ç¦»å‡½æ•°çš„è®¡ç®— cosine distance cityblock distance jaccard distance euclidean distance ç›´æŽ¥æ˜¯å¥å­å‘é‡çš„ä¸Šè¿°è·ç¦»çš„è®¡ç®— å¯ä»¥åšåˆ°çš„æ˜¯å¯¹æ¯”è¯•éªŒï¼Œåœ¨åªæ˜¯ä½¿ç”¨ è¯å‘é‡å¾—åˆ°çš„ç‰¹å¾æœ€åŽçš„test acc æ˜¯87%ï¼Œ è€ŒåŠ ä¸Šäº†å¥å­å‘é‡æ²¡æœ‰æå‡ï¼Œåº”è¯¥æ˜¯86.3% ä¹‹ç±»çš„ã€‚ æœ€å¥½çš„æ¨¡åž‹æ˜¯acc æ˜¯ 0.88ï¼Œ å½“ç„¶ä¸€åˆ‡æ¨¡åž‹éƒ½æ˜¯éœ€è¦æåˆ°çº¿ä¸Šçš„public è¿›è¡Œè®¡ç®—çš„ï¼Œå¯¹åº”çš„ log loss æ˜¯0.14658ã€‚æŽ’åæ˜¯ 5% ï¼ˆ150~ /3000~ï¼‰ å¥½çš„ä»£ç pandas å¯¹äºŽæ•°æ®çš„å¸¸ç”¨æ“ä½œ å®žç”¨çš„æ•°æ®é¢„åˆ†æž 123456789101112131415# Check for any null valuesprint(train.isnull().sum())print(test.isnull().sum())# Add the string 'empty' to empty stringstrain = train.fillna('empty')test = test.fillna('empty')# æ•°æ®çš„åˆ†ç±»ç»Ÿè®¡temp = df.column.value_counts() # æ˜¾ç¤ºæ•´ä½“çš„df çš„ä¿¡æ¯df.info()# ç›´æŽ¥å°±äº§ç”Ÿäº†ä¸€ä¸ªå›¾åƒï¼Œä¸æ•¢æƒ³è±¡ï¼Œ ä½¿ç”¨groupby()ï¼Œç„¶åŽé€‰æ‹© column å¯ä»¥å­¦ä¹ df.groupby("is_duplicate")['id'].count().plot.bar() å¸¸è§çš„è¡¨æ ¼çš„æ“ä½œ 123456789test_cp.rename(columns=&#123;'test_id':'id'&#125;,inplace=True)comb = pd.concat([train_cp,test_cp])ques = pd.concat([train_orig[['question1', 'question2']], \ test_orig[['question1', 'question2']]], axis=0).reset_index(drop='index') # ç­›é€‰æ“ä½œtrain_comb = comb[comb['is_duplicate'] &gt;= 0][['id','q1_hash','q2_hash','q1_freq','q2_freq','is_duplicate']]test_comb = comb[comb['is_duplicate'] &lt; 0][['id','q1_hash','q2_hash','q1_freq','q2_freq']] å°å¿ƒä½¿ç”¨ 12train_questions.drop_duplicates(subset = ['question1'],inplace=True)train_questions.reset_index(inplace=True,drop=True) å…¶ä»– 1234567891011eng_stopwords = set(stopwords.words('english'))# ä¸»è¦æŽŒæ¡set.intersection() äº¤é›†çš„ä½¿ç”¨def q1_q2_intersect(row): return(len(set(q_dict[row['question1']]).intersection(set(q_dict[row['question2']]))))# series æ˜¯å¯ä»¥ç›´æŽ¥ tolist() çš„qids = pd.Series(df_train['qid1'].tolist() + df_train['qid2'].tolist())from nltk import word_tokenize, ngrams# word_tokenize å°±æ˜¯å°†å¥å­æ‰“æ•£ï¼Œæˆä¸ºä¸€ä¸ªä¸ªå•è¯ æ‰‹å†™ TF-IDF 12345678910111213141516171819202122232425262728293031323334from collections import Counter# If a word appears only once, we ignore it completely (likely a typo)# Epsilon defines a smoothing constant, which makes the effect of extremely rare words smallerdef get_weight(count, eps=10000, min_count=2): if count &lt; min_count: return 0 else: return 1 / (count + eps)eps = 5000 words = (" ".join(train_qs)).lower().split()counts = Counter(words)weights = &#123;word: get_weight(count) for word, count in counts.items()&#125;def tfidf_word_match_share(row): q1words = &#123;&#125; q2words = &#123;&#125; for word in str(row['question1']).lower().split(): if word not in stops: q1words[word] = 1 for word in str(row['question2']).lower().split(): if word not in stops: q2words[word] = 1 if len(q1words) == 0 or len(q2words) == 0: # The computer-generated chaff includes a few questions that are nothing but stopwords return 0 shared_weights = [weights.get(w, 0) for w in q1words.keys() if w in q2words] + [weights.get(w, 0) for w in q2words.keys() if w in q1words] total_weights = [weights.get(w, 0) for w in q1words] + [weights.get(w, 0) for w in q2words] R = np.sum(shared_weights) / np.sum(total_weights) return R 123# åœ¨ä»£ç ä¸­ä½¿ç”¨ ls çš„æ“ä½œï¼Œä¹Ÿæ˜¯æ¯”è¾ƒ 666 çš„from subprocess import check_outputprint(check_output([&quot;ls&quot;, &quot;../input&quot;]).decode(&quot;utf8&quot;)) åœ¨éªŒè¯ word2vec æ—¶å€™ï¼Œ å¯ä»¥ä½¿ç”¨t-sne è¿›è¡Œå¯è§†åŒ– è®­ç»ƒå¾—åˆ°çš„model å¯ä»¥ most_similar() ,å®šä½ä¸€ä¸ªå˜é‡ï¼ŒåŽ»éªŒè¯å¥½åå°±è¡Œ å‚è€ƒèµ„æ–™ kaggle kernel 1kaggle kernel 2ä»£ç  https://towardsdatascience.com/finding-similar-quora-questions-with-word2vec-and-xgboost-1a19ad272c0d å¤ä¹ æ€»ç»“ æ•°æ®åˆ†æž æ•°æ®ï¼šè®­ç»ƒæ•°æ®é›†æ˜¯40ä¸‡ï¼Œæµ‹è¯•æ•°æ®é›†æ˜¯5 å€ training dataï¼ˆè¿™é‡Œæœ‰ç”Ÿæˆçš„è™šå‡æ•°æ®ï¼Œé˜²æ­¢ä½œå¼Šï¼‰æ•°æ®ç‰¹ç‚¹ï¼šï¼ˆ1ï¼‰å¥å­å¯¹åœ¨è®­ç»ƒé›†çš„é¢‘æ•°ï¼ˆä½¿ç”¨pid åœ¨è®­ç»ƒé›†ä¸­å‡ºçŽ°çš„æ¬¡æ•°ï¼Œå‘çŽ°å¤§å¤šæ•°å¥å­é‡å¤çŽ‡æ˜¯æ¯”è¾ƒä½Žçš„10-50ä¹‹é—´ï¼‰ï¼Œå¹¶ä¸”åœ¨è®­ç»ƒæ•°æ®é›†ä¸­è¿™ç§é‡å¤åº¦æ˜¯éšç€æ—¶é—´é€’å‡ï¼Œ æµ‹è¯•é›†ä¸­æ²¡æœ‰æ ‡æ³¨pid ï¼ˆ2ï¼‰å¥å­ä¸­å•è¯çš„é•¿åº¦æ˜¯åœ¨20ä¸ªè¯å·¦å³ï¼ˆæ­£å¤ªåˆ†å¸ƒä¸­çš„uï¼‰ ç‰¹å¾å·¥ç¨‹ æ•°æ®æŒ–æŽ˜ç‰¹å¾ + NLP embeddingç‰¹å¾ã€‚ç®€å•ä¸¾ä¾‹è¯´æ˜Žï¼Œå‰è€…æ˜¯ä¸¤ä¸ªå¥å­çš„å…±çŽ°è¯ï¼›åŽè€…æ ¹æ® word embedding è®¡ç®—çš„å­—ç¬¦ä¸²çš„åŒ¹é…ä¹‹ç±»çš„ï¼Œæ¯”å¦‚cosine distance æˆ–è€…jaccard distanceä¹‹ç±»çš„ã€‚ æ¨¡åž‹ xgboost å…¶ä»–ä¼—æ•°ã€å‡å€¼å’Œä¸­ä½æ•°å’Œåæ€åˆ†å¸ƒçš„å…³ç³»ï¼ˆç›¸å¯¹äºŽæ­£å¤ªåˆ†å¸ƒè€Œè¨€ï¼‰(1) å¯¹äºŽæ­£å¤ªåˆ†å¸ƒï¼Œä¸­ä½æ•°ã€ä¼—æ•°å’Œå‡å€¼æ˜¯ä¸€ä¸ªã€‚åæ€çš„å®šä¹‰æ˜¯æ ¹æ®å°¾éƒ¨å‘½åï¼Œå³åæ€è¡¨ç¤ºå°¾éƒ¨åœ¨å³è¾¹ã€‚ä¸­ä½æ•°æ˜¯æ ·æœ¬æ€»æ•°ä¸­é—´ä½ç½®ï¼Œå¦‚æžœæ˜¯å³åæ€ï¼Œé‚£ä¹ˆä¸­ä½æ•°åœ¨åå‘äºŽå³è¾¹ï¼›ä¼—æ•°æ˜¯åå‘äºŽå·¦è¾¹ï¼Œå› ä¸ºå°¾éƒ¨æ˜¯åœ¨å³è¾¹ï¼Œæ‰€ä»¥å¤´éƒ¨æ˜¯åœ¨å·¦è¾¹ã€‚ æ‰€ä»¥ ä¼—æ•°&lt;ä¸­ä½æ•°&lt; å‡å€¼ã€‚ï¼ˆå¯¹äºŽå‡å€¼å¯èƒ½ä¸å¤ªå¥½ç†è§£ï¼Œå¯ä»¥çœ‹ä¸Šé¢çš„è§£é‡Šï¼‰]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linear Algebra in ML]]></title>
    <url>%2F2019%2F03%2F25%2FLinear-Algebra-in-ML%2F</url>
    <content type="text"><![CDATA[æˆ‘è§‰å¾—åˆ° ML ä¸­çš„ä¸€ä¸ªéš¾ç‚¹ï¼šå°±æ˜¯ç”±åŽŸæ¥ç®€å•çš„ linear equations ç›´æŽ¥è¿‡æ¸¡åˆ°äº† matrics and vectorsã€‚è¿™ä¸ªè¿‡ç¨‹æ˜¯æ²¡æœ‰äººè·Ÿä½ è¯´çš„ã€‚ç½‘ç»œç»“æž„å¯ä»¥å½“ä½œæ˜¯ä¸€ä¸ªcomplicated å¹¶ä¸”æ˜¯æ— æ³•è¡¨ç¤ºçš„å‡½æ•°ï¼ŒäºŽæ˜¯å¾ˆå¤šä½¿ç”¨è€…æŠŠå®ƒå½“ä½œé»‘åŒ£å­ï¼Œå…³å¿ƒäºŽè¾“å…¥å’Œè¾“å‡ºï¼Œä¸­é—´è¿‡ç¨‹ donâ€™t care. å˜é‡ï¼ˆç‰¹å¾ä¸ªæ•°ï¼‰å’Œè§£çš„å…³ç³»å¤šå˜é‡å’Œæœ€åŽtargetçš„å…³ç³»æ˜¯å¯ä»¥ä½¿ç”¨ matrices è¿›è¡Œè¡¨ç¤ºçš„ï¼Œè¿™å°±æ˜¯ä¸€ç§æ•°å­¦å…¬å¼åŒ–ã€‚ Broadly speaking, in linear algebra data is represented in the form of linear equations. These linear equations are in turn represented in the form of matrices and vectors. å…ˆç›´è§‚çš„æ„Ÿå—ä¸€ä¸‹å˜é‡å’Œå›¾å½¢ï¼ˆå¯è§†åŒ–ï¼‰çš„å…³ç³»ã€‚ä¸¤ä¸ªå˜é‡ç»„æˆçš„equations æ˜¯ä¸¤æ¡çº¿çš„ç›¸äº¤æƒ…å†µã€‚è€Œä¸‰ä¸ªå˜é‡åœ¨ç©ºé—´ä¸­æœ‰ä¸‰ç§æƒ…å†µï¼š ç›¸äº¤ï¼Œå¹³è¡Œï¼Œä¸åœ¨ä¸€ä¸ªå¹³é¢ä¸Šã€‚ä¸‰ä¸ªå˜é‡ç»„æˆçš„equations æ˜¯ä¸‰ä¸ªé¢çš„ç›¸äº¤æƒ…å†µã€‚æœ‰å››ç§æƒ…å†µ (try hard to figure it out)ï¼šNo intersection at all.Planes intersect in a line.They can intersect in a plane.All the three planes intersect at a point. å½“åˆ°è¾¾4 dims çš„æ—¶å€™ï¼Œitâ€™s impossible to visulize it. terms in related to matrixè¿™äº›è¯æ±‡ (terms) ç»å¸¸åœ¨æ–‡çŒ®ä¸­å‡ºçŽ°ï¼Œéœ€è¦å¯¹äºŽå…¶å«ä¹‰æœ‰ä¸ªæ¯”è¾ƒå¥½çš„è®¤è¯†ã€‚Order of matrix â€“ If a matrix has 3 rows and 4 columns, order of the matrix is 34 i.e. rowcolumn. (ç¿»è¯‘æˆ çŸ©é˜µçš„é˜¶)Square matrix â€“ The matrix in which the number of rows is equal to the number of columns.Diagonal matrix â€“ A matrix with all the non-diagonal elements equal to 0 is called a diagonal matrix.Upper triangular matrix â€“ Square matrix with all the elements below diagonal equal to 0.Lower triangular matrix â€“ Square matrix with all the elements above the diagonal equal to 0.Scalar matrix â€“ Square matrix with all the diagonal elements equal to some constant k.Identity matrix â€“ Square matrix with all the diagonal elements equal to 1 and all the non-diagonal elements equal to 0.Column matrix â€“ The matrix which consists of only 1 column. Sometimes, it is used to represent a vector.Row matrix â€“ A matrix consisting only of row.Trace â€“ It is the sum of all the diagonal elements of a square matrix.Rank of a matrix â€“ Rank of a matrix is equal to the maximum number of linearly independent row vectors in a matrix.Determinant of a matrix - çŸ©é˜µçš„è¡Œåˆ—å¼è½¬ç½® -åœ¨å›¾å½¢ matrixä¸­è¿˜æ˜¯å¾ˆå¸¸è§çš„ã€‚$$\mathrm { A } _ { \mathrm { ij } } ^ { \mathrm{T}} = \mathrm { A } _ { \mathrm { ji } }$$ è¿™ä¸ªçŸ©é˜µä¹˜æ³•å’Œå…ƒç´ ç›¸ç§°çš„åŒºåˆ«ï¼ŒåŽè€…æ˜¯element-wise è¿›è¡Œçš„ã€‚å¯ä»¥ä»Žå¦å¤–ä¸€ä¸ªè§’åº¦åŽ»åˆ—åŠçŸ©é˜µç›¸ç§°ï¼š This operation on a vector is called linear transformation. å°±æ˜¯åŽé¢çš„vector æ˜ å°„åˆ°äº†å‰é¢çš„çŸ©é˜µç©ºé—´ã€‚ ç‰¹å¾å€¼å’Œå¥‡å¼‚å€¼ç€ä¸¤ä¸ªæ˜¯åˆ†åˆ«å¯¹åº”ç€PCA å’ŒSVDã€‚Eigenvalues and Eigenvectorså¦‚å…¬å¼æ‰€ç¤ºï¼Œç‰¹å¾å€¼å’Œç‰¹å¾å‘é‡çš„ä¹˜ç§¯å°±æ˜¯æ–¹é˜µå’Œç‰¹å¾å‘é‡çš„ä¹˜ç§¯ï¼ŒåŽŸå…ˆçš„æ–¹é˜µæ˜¯å¯ä»¥é™ç»´è¡¨ç¤ºæˆç‰¹å¾å‘é‡å’Œç‰¹å¾å€¼çš„ã€‚$ A x = \lambda x $ ç‰¹å¾å€¼å’Œç‰¹å¾å‘é‡çš„è®¡ç®—è¿‡ç¨‹ï¼Œå¦‚æžœçŸ©é˜µè®¡ç®—æ¯”è¾ƒç®€å•ï¼Œé‚£ä¹ˆè¿˜æ˜¯å®¹æ˜“è®¡ç®—çš„ã€‚ å¯¹äºŽå¥‡å¼‚å€¼åˆ†è§£ï¼Œæœ€å¸¸è§çš„å°±æ˜¯è¿™ç§è¡¨è¾¾ï¼š$A = U \Sigma V ^ { T }$ç‰¹å¾å€¼åˆ†è§£å’Œå¥‡å¼‚å€¼åˆ†è§£éƒ½æ˜¯ç»™ä¸€ä¸ªçŸ©é˜µ(çº¿æ€§å˜æ¢)æ‰¾ä¸€ç»„ç‰¹æ®Šçš„åŸºï¼Œç‰¹å¾å€¼åˆ†è§£æ‰¾åˆ°äº†ç‰¹å¾å‘é‡è¿™ç»„åŸºï¼Œåœ¨è¿™ç»„åŸºä¸‹è¯¥çº¿æ€§å˜æ¢åªæœ‰ç¼©æ”¾æ•ˆæžœã€‚è€Œå¥‡å¼‚å€¼åˆ†è§£åˆ™æ˜¯æ‰¾åˆ°å¦ä¸€ç»„åŸºï¼Œè¿™ç»„åŸºä¸‹çº¿æ€§å˜æ¢çš„æ—‹è½¬ã€ç¼©æ”¾ã€æŠ•å½±ä¸‰ç§åŠŸèƒ½ç‹¬ç«‹åœ°å±•ç¤ºå‡ºæ¥äº†ã€‚]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[å‰‘æŒ‡offer-é€’å½’ã€å›žæº¯å’ŒåŠ¨æ€è§„åˆ’]]></title>
    <url>%2F2019%2F03%2F17%2F%E5%89%91%E6%8C%87offer-%E9%80%92%E5%BD%92-%E5%9B%9E%E6%BA%AF%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[è¿™æ˜¯å‰‘æŒ‡offer ç³»åˆ—å››éƒ¨æ›²ä¸­çš„ç¬¬ä¸‰éƒ¨ï¼šé€’å½’ã€å›žæº¯å’ŒåŠ¨æ€è§„åˆ’ã€‚ç¬¬ä¸€éƒ¨å…³äºŽå­—ç¬¦ä¸²å’Œæ•°ç»„ï¼Œç¬¬äºŒéƒ¨æ˜¯æ ˆã€é˜Ÿåˆ—ã€é“¾è¡¨å’Œæ ‘ï¼Œ æœ€åŽä¸€éƒ¨åˆ†åœ¨è¿™é‡Œã€‚ æ–æ³¢é‚£å¥‘æ•°åˆ— å¤§å®¶éƒ½çŸ¥é“æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼ŒçŽ°åœ¨è¦æ±‚è¾“å…¥ä¸€ä¸ªæ•´æ•°nï¼Œè¯·ä½ è¾“å‡ºæ–æ³¢é‚£å¥‘æ•°åˆ—çš„ç¬¬né¡¹ï¼ˆä»Ž0å¼€å§‹ï¼Œç¬¬0é¡¹ä¸º0ï¼‰ã€‚n&lt;=39 Tips: ç®€å•çš„é€’å½’ï¼Œå¯ä»¥è½¬æ¢æˆå¾ªçŽ¯ã€‚ 1234567891011121314class Solution: # python ä¸­list çš„åˆå§‹åŒ–ï¼Œæœ€å¼€å§‹çš„æ˜¯ä»Ž0 å¼€å§‹ï¼Œæ‰€ä»¥æ˜¯éœ€è¦å¤šè¿›è¡Œä¸€ä¸ªåˆå§‹åŒ–çš„ def Fibonacci(self, n): # write code here if n == 0: return 0 if n == 1: return 1 arr = [0] * (n + 1) arr[0] = 0 arr[1] = 1 for i in range(2, n + 1): arr[i] = arr[i - 1] + arr[i - 2] return arr[n] è¿™ä¸ªæ˜¯å¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–åˆ°æ—¶é—´ O(N)ï¼Œç©ºé—´æ˜¯ O(1)12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;//0, 1, 1, 2, 3, 5,// ç¬¬0é¡¹æ˜¯0ï¼Œç¬¬1é¡¹æ˜¯1int fiber(int n)&#123; if (n ==1) return 1; else if(n ==2) return 1; int a =1, b =1; for(int i =3; i&lt;=n; i++) &#123; a =a+b; b =a; &#125; return b;&#125;int main()&#123; int n; cin &gt;&gt;n; cout&lt;&lt; fiber(n)&lt;&lt;endl; return 0;&#125; è·³å°é˜¶ ä¸€åªé’è›™ä¸€æ¬¡å¯ä»¥è·³ä¸Š1çº§å°é˜¶ï¼Œä¹Ÿå¯ä»¥è·³ä¸Š2çº§ã€‚æ±‚è¯¥é’è›™è·³ä¸Šä¸€ä¸ªnçº§çš„å°é˜¶æ€»å…±æœ‰å¤šå°‘ç§è·³æ³•ï¼ˆå…ˆåŽæ¬¡åºä¸åŒç®—ä¸åŒçš„ç»“æžœï¼‰ã€‚ Tipsï¼š åŒä¸Šã€‚ python ç‰ˆæœ¬123456789101112131415class Solution: def jumpFloor(self, number): # write code here if number == 1: return 1 if number == 2: return 2 arr = [0] * (number + 1) arr[1] = 1 arr[2] = 2 for i in range(3, number + 1): arr[i] = arr[i - 1] + arr[i - 2] return arr[number] c++ ç‰ˆæœ¬12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;algorithm&gt;#include "vector"using namespace std;//0, 1, 1, 2, 3, 5,// ç¬¬0é¡¹æ˜¯0ï¼Œç¬¬1é¡¹æ˜¯1vector&lt;int&gt; f;int jump(int n)&#123; if(n ==1) return 1; if (n ==2) return 2; f[1] =1,f[2] =2; for(int i =3; i&lt;=n;i++) f[i] =f[i-1] +f[i-2]; return f[n]; &#125;int main()&#123; int n; cin &gt;&gt;n; f =vector&lt;int&gt;(n+1); cout&lt;&lt;jump(n)&lt;&lt;endl; return 0;&#125; è·³å°é˜¶2 ä¸€åªé’è›™ä¸€æ¬¡å¯ä»¥è·³ä¸Š1çº§å°é˜¶ï¼Œä¹Ÿå¯ä»¥è·³ä¸Š2çº§â€¦â€¦å®ƒä¹Ÿå¯ä»¥è·³ä¸Šnçº§ã€‚æ±‚è¯¥é’è›™è·³ä¸Šä¸€ä¸ªnçº§çš„å°é˜¶æ€»å…±æœ‰å¤šå°‘ç§è·³æ³•ã€‚ Tipsï¼šåŒä¸Šã€‚ 12345678910111213class Solution: """ åœ¨ä½¿ç”¨ forå¾ªçŽ¯çš„æ—¶å€™ï¼Œæ³¨æ„ range() è¿™ç§å–å€¼ï¼Œç©¶ç«Ÿæ˜¯ä½¿ç”¨ range() ä½œä¸ºæ¬¡æ•°çš„è®¡é‡ï¼› è¿˜æ˜¯è¦ä½¿ç”¨range ä¸­çš„index ã€‚ä¸¤è€…æ˜¯ä¸ç›¸åŒçš„æ“ä½œï¼Œå°¤å…¶æ˜¯å¯¹äºŽå‰åŽçš„å–å€¼ã€‚ """ def jumpFloorII(self, number): # write code here if number == 1: return 1 nums = 1 for i in range(number - 1): nums = nums * 2 return nums çŸ©å½¢è¦†ç›– æˆ‘ä»¬å¯ä»¥ç”¨2*1çš„å°çŸ©å½¢æ¨ªç€æˆ–è€…ç«–ç€åŽ»è¦†ç›–æ›´å¤§çš„çŸ©å½¢ã€‚è¯·é—®ç”¨nä¸ª2*1çš„å°çŸ©å½¢æ— é‡å åœ°è¦†ç›–ä¸€ä¸ª2*nçš„å¤§çŸ©å½¢ï¼Œæ€»å…±æœ‰å¤šå°‘ç§æ–¹æ³•ï¼Ÿ Tips: math, æ‰¾å‡ºé€’å½’æ–¹ç¨‹ã€‚ 1234567891011121314151617"""æ—¢ç„¶ç»“æžœåªæ˜¯æœ€åŽä¸€ä¸ªè§£ï¼Œé‚£ä¹ˆå°±æ²¡æœ‰å¿…è¦ä¿å­˜ä¸­é—´å˜é‡ï¼Œæ‰€ä»¥åªæ˜¯ï¼Œæ‰€ä»¥ç©ºé—´å¤æ‚åº¦ä»ŽOï¼ˆnï¼‰ -&gt; O(1) ï¼Œè¿™ä¸ªæ˜¯è¶…çº§niceçš„"""class Solution: def rectCover(self, number): # write code here if number &lt;= 0: return 0 if number &lt;= 2: return number # åªæ˜¯ä¸¤ä¸ªå˜é‡ç½¢äº† a, b = 1, 2 while number &gt; 2: a, b = b, a + b # python ä¸­ç‹¬æœ‰çš„æ¯”è¾ƒç¥žå¥‡çš„æ“ä½œï¼Œ æ˜¯è®¡ç®—äº†å³è¾¹çš„ b, a+b ç„¶åŽå†ç»Ÿä¸€èµ‹å€¼ç»™ a, b number -= 1 return b æ³¨æ„åœ¨c++ ä¸­æ˜¯éœ€è¦ä½¿ç”¨ä¸‰ä¸ªå˜é‡çš„ã€‚è¿™æ ·æ‰èƒ½ä¸€æ­¥æ­¥çš„è¿›è¡Œè½¬ç§»ã€‚ 123456789101112131415161718192021class Solution &#123;public: int rectCover(int number) &#123; if(number &lt;=0) return 0; int&amp; n =number; if (n ==1) return 1; if (n ==2) return 2; int a =1, b =2, c; for(int i =3; i&lt;=n; i++) &#123; c =a+b; a =b; b=c; &#125; return c; &#125;&#125;; æœºå™¨äººçš„è¿åŠ¨èŒƒå›´ (c++ ä¸­ä¸€ç§’èƒ½å¤ŸéåŽ† $10^8$ï¼ŒéåŽ†ä¸€äº¿ä¸ªæ•°å­—) åœ°ä¸Šæœ‰ä¸€ä¸ªmè¡Œå’Œnåˆ—çš„æ–¹æ ¼ã€‚ä¸€ä¸ªæœºå™¨äººä»Žåæ ‡0,0çš„æ ¼å­å¼€å§‹ç§»åŠ¨ï¼Œæ¯ä¸€æ¬¡åªèƒ½å‘å·¦ï¼Œå³ï¼Œä¸Šï¼Œä¸‹å››ä¸ªæ–¹å‘ç§»åŠ¨ä¸€æ ¼ï¼Œä½†æ˜¯ä¸èƒ½è¿›å…¥è¡Œåæ ‡å’Œåˆ—åæ ‡çš„æ•°ä½ä¹‹å’Œå¤§äºŽkçš„æ ¼å­ã€‚ ä¾‹å¦‚ï¼Œå½“kä¸º18æ—¶ï¼Œæœºå™¨äººèƒ½å¤Ÿè¿›å…¥æ–¹æ ¼ï¼ˆ35,37ï¼‰ï¼Œå› ä¸º3+5+3+7 = 18ã€‚ä½†æ˜¯ï¼Œå®ƒä¸èƒ½è¿›å…¥æ–¹æ ¼ï¼ˆ35,38ï¼‰ï¼Œå› ä¸º3+5+3+8 = 19ã€‚è¯·é—®è¯¥æœºå™¨äººèƒ½å¤Ÿè¾¾åˆ°å¤šå°‘ä¸ªæ ¼å­ï¼Ÿ Tipsï¼šé€’å½’ï¼Œè½¬ç§»æ–¹ç¨‹ä¸éš¾ï¼Œåœ¨ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘è¿›è¡Œå°è¯•ï¼Œéœ€è¦åˆ¤æ–­çš„æ¡ä»¶æ¯”è¾ƒå¤šï¼Œæ¯”å¦‚æ˜¯å¦è®¿é—®è¿‡ï¼Œæ•°ä½ä¹‹å’Œç­‰ä¸€äº›æ¡ä»¶ã€‚ 123456789101112131415161718192021222324252627282930class Solution: def movingCount(self, threshold, rows, cols): # visited ä¸ä¸€å®šæ˜¯äºŒç»´çš„ï¼Œåªè¦æ˜¯èƒ½å¤Ÿ"è‡ªåœ†å…¶è¯´" å°±è¡Œã€‚ visited = [False] * (rows * cols) count = self.movingCountCore(threshold, rows, cols, 0, 0, visited) return count def movingCountCore(self, threshold, rows, cols, row, col, visited): count = 0 # å°±æ˜¯è¿™ä¸ªè®¿é—®è®°å½•æ˜¯éœ€è¦è¿›è¡Œå˜åŒ–çš„ï¼Œ å¦‚æžœæ˜¯false ï¼Œç„¶åŽè®¿é—®ä¹‹åŽ æ˜¯éœ€è¦è®¾ç½®ä¸º trueçš„ if self.check(threshold, rows, cols, row, col, visited): visited[row * cols + col] = True count = 1 + self.movingCountCore(threshold, rows, cols, row, col - 1, visited) + \ self.movingCountCore(threshold, rows, cols, row, col + 1, visited) + \ self.movingCountCore(threshold, rows, cols, row + 1, col, visited) + \ self.movingCountCore(threshold, rows, cols, row - 1, col, visited) return count def check(self, threshold, rows, cols, row, col, visited): if row &gt;= 0 and row &lt; rows and col &gt;= 0 and col &lt; cols and self.judge(threshold, row, col) and not visited[row * cols + col]: return True else: return False def judge(self, threshold, i, j): if sum(map(int, str(i) + str(j))) &lt;= threshold: return True else: return False å½“æ•°æ®é‡æ¯”è¾ƒå¤§çš„æ—¶å€™ï¼Œä¸€èˆ¬ä½¿ç”¨å®½åº¦ä¼˜å…ˆéåŽ†ï¼Œå› ä¸ºæ·±åº¦ä¼˜å…ˆéåŽ†æ¯è¿›å…¥ä¸€å±‚ï¼Œå°±ä¼šç”³è¯·ä¸€å®šçš„æ ˆç©ºé—´ï¼Œå¦‚æžœå±‚æ•°å¾ˆå¤šï¼Œé‚£ä¹ˆæ˜¯å®¹æ˜“æ ˆæº¢å‡ºçš„ã€‚æ‰€ä»¥å¯ä»¥ä½¿ç”¨bfs ï¼ˆå®½åº¦ä¼˜å…ˆéåŽ†ï¼‰ï¼Œbfs çš„æ—¶é—´å¤æ‚åº¦å°±æ˜¯æ‰€æœ‰æ ¼å­çš„ä¸ªæ•°ã€‚ æ‰©å±•æ–°èŠ‚ç‚¹æ—¶å€™éœ€è¦æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š ä¹‹å‰æ²¡æœ‰éåŽ†è¿‡ï¼Œå¯ä»¥ä½¿ç”¨ bool æ•°ç»„è¿›è¡Œåˆ¤æ–­ æ²¡æœ‰èµ°å‡ºè¾¹ç•Œ æ¨ªçºµåæ ‡çš„å„ä½æ•°å­—ä¹‹å’Œå°äºŽ $k$ ä½¿ç”¨BFS(å®½åº¦ä¼˜å…ˆæœç´¢)æ—¶é—´å¤æ‚åº¦åˆ†æžï¼šæ¯ä¸ªèŠ‚ç‚¹æœ€å¤šåªä¼šå…¥é˜Ÿä¸€æ¬¡ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦ä¸ä¼šè¶…è¿‡æ–¹æ ¼ä¸­çš„èŠ‚ç‚¹ä¸ªæ•°ã€‚æœ€åæƒ…å†µä¸‹ä¼šéåŽ†æ‰€æœ‰çš„æ–¹æ ¼çš„ç‚¹ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦æ˜¯ $O(mn)$ã€‚è¿™ä¸ªèƒ½ä¸èƒ½è¿›å…¥æŸä¸ªæ ¼å­æ˜¯ç¡®å®šçš„ï¼Œä¸æ˜¯ä¾èµ–äºŽä»Žä¸Šé¢åˆ°ä¸‹é¢ä¸èƒ½è¿›å…¥ï¼Œä½†æ˜¯ä»Žå·¦é¢åˆ°å³é¢å°±èƒ½å¤Ÿè¿›å…¥ã€‚æ‰€ä»¥å¯¹äºŽæ¯ä¸ªèŠ‚ç‚¹ï¼ŒéåŽ†ä¸€æ¬¡å°±è¶³ä»¥ã€‚ c++ å®žçŽ°çš„ BFS ä»£ç  1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int get_sum(pair&lt;int, int&gt; p) &#123; int s = 0; while (p.first) &#123; s += p.first % 10; p.first /= 10; &#125; while (p.second) &#123; s += p.second % 10; p.second /= 10; &#125; return s; &#125; int movingCount(int threshold, int rows, int cols) &#123; if (!rows || !cols) return 0; queue&lt;pair&lt;int,int&gt;&gt; q; // è¿™ç§å®šä¹‰è¿˜æ˜¯è¦å¤šç†Ÿæ‚‰ä¸€ä¸‹çš„ vector&lt;vector&lt;bool&gt;&gt; st(rows, vector&lt;bool&gt;(cols, false)); int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;; int res = 0; q.push(&#123;0, 0&#125;); while (q.size()) &#123; auto t = q.front(); q.pop(); if (st[t.first][t.second] || get_sum(t) &gt; threshold) continue; res ++ ; st[t.first][t.second] = true; for (int i = 0; i &lt; 4; i ++ ) &#123; int x = t.first + dx[i], y = t.second + dy[i]; if (x &gt;= 0 &amp;&amp; x &lt; rows &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; cols) q.push(&#123;x, y&#125;); &#125; &#125; return res; &#125;&#125;; c++ å®žçŽ°çš„ DFS ä»£ç  æ—¶é—´å¤æ‚åº¦åˆ†æžï¼Œå› ä¸ºæœ‰ visit æ•°ç»„åˆ¤é‡ï¼Œæ‰€ä»¥æ¯ä¸ªç‚¹åªä¼šéåŽ†ä¸€æ¬¡ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ $O(mn)$ 12345678910111213class Solution &#123; public int movingCount(int k, int rows, int cols)&#123; boolean[][] vis = new boolean[rows][cols] ; return dfs(k,0,0,vis) ; &#125; public int dfs(int k,int i,int j,boolean[][] vis)&#123; if(i&lt;0 || i &gt;= vis.length || j&lt;0 || j&gt;=vis[0].length || vis[i][j] || (i/10+i%10+j/10+j%10)&gt;k)&#123; return 0; &#125; vis[i][j] = true ; return dfs(k,i+1,j,vis) + dfs(k,i-1,j,vis) + dfs(k,i,j-1,vis) + dfs(k,i,j+1,vis) + 1; &#125;&#125; è¿™ä¸ªä¸éœ€è¦å›žæº¯ï¼Œå› ä¸ºæœ€åŽçš„ç»“æžœæ˜¯ä¸€ä¸ªå€¼ï¼Œæ ‡è®°æŸä¸ªç‚¹èƒ½å¦è¢«è®¿é—®ï¼Œæ˜¯ä¸éœ€è¦å›žæº¯çš„ï¼Œä¸æ˜¯è·¯å¾„é—®é¢˜ã€‚å®½åº¦ä¼˜å…ˆéåŽ†éœ€è¦ç»´æŠ¤ä¸€ä¸ªé˜Ÿåˆ—ï¼Œå¦‚æžœèƒ½å¤Ÿè¢«è®¿é—®ï¼Œé‚£ä¹ˆå°±å¯ä»¥ç»§ç»­æ‰©å±•ï¼Œå¦åˆ™ä¸èƒ½ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: // å®½åº¦ä¼˜å…ˆæœç´¢ï¼Œ ä½¿ç”¨é˜Ÿåˆ— int get_single_sum(int x) &#123; int s =0; while (x) &#123; s += x%10; x =x/10; &#125; return s; &#125; int get_sum(pair&lt;int, int&gt; p) &#123; return get_single_sum(p.first) +get_single_sum(p.second); &#125; int movingCount(int threshold, int rows, int cols) &#123; int res =0; if(!rows || !cols) return 0; vector&lt;vector&lt;bool&gt;&gt; st(rows, vector&lt;bool&gt;(cols)); int dx[4] =&#123;-1, 0, 1, 0&#125;, dy[4]=&#123;0, 1, 0, -1&#125;; queue&lt;pair&lt;int, int&gt;&gt; q; q.push(&#123;0, 0&#125;); while (q.size()) &#123; auto t =q.front(); q.pop(); if(get_sum(t)&gt; threshold || st[t.first][t.second]) continue; res ++; st[t.first][t.second] =true; for(int i =0; i&lt;4; i++) &#123; int a= t.first+ dx[i], b =t.second+ dy[i]; if(a &gt;=0 &amp;&amp; a&lt;rows &amp;&amp; b&gt;=0 &amp;&amp; b&lt;cols) q.push(&#123;a, b&#125;); &#125; &#125; return res; &#125;&#125;; çŸ©é˜µä¸­çš„è·¯å¾„ è¯·è®¾è®¡ä¸€ä¸ªå‡½æ•°ï¼Œç”¨æ¥åˆ¤æ–­åœ¨ä¸€ä¸ªçŸ©é˜µä¸­æ˜¯å¦å­˜åœ¨ä¸€æ¡åŒ…å«æŸå­—ç¬¦ä¸²æ‰€æœ‰å­—ç¬¦çš„è·¯å¾„ã€‚è·¯å¾„å¯ä»¥ä»ŽçŸ©é˜µä¸­çš„ä»»æ„ä¸€ä¸ªæ ¼å­å¼€å§‹ï¼Œæ¯ä¸€æ­¥å¯ä»¥åœ¨çŸ©é˜µä¸­å‘å·¦ï¼Œå‘å³ï¼Œå‘ä¸Šï¼Œå‘ä¸‹ç§»åŠ¨ä¸€ä¸ªæ ¼å­ã€‚å¦‚æžœä¸€æ¡è·¯å¾„ç»è¿‡äº†çŸ©é˜µä¸­çš„æŸä¸€ä¸ªæ ¼å­ï¼Œåˆ™ä¹‹åŽä¸èƒ½å†æ¬¡è¿›å…¥è¿™ä¸ªæ ¼å­ã€‚ ä¾‹å¦‚ a b c e s f c s a d e e è¿™æ ·çš„3 X 4 çŸ©é˜µä¸­åŒ…å«ä¸€æ¡å­—ç¬¦ä¸²â€bccedâ€çš„è·¯å¾„ï¼Œä½†æ˜¯çŸ©é˜µä¸­ä¸åŒ…å«â€abcbâ€è·¯å¾„ï¼Œå› ä¸ºå­—ç¬¦ä¸²çš„ç¬¬ä¸€ä¸ªå­—ç¬¦bå æ®äº†çŸ©é˜µä¸­çš„ç¬¬ä¸€è¡Œç¬¬äºŒä¸ªæ ¼å­ä¹‹åŽï¼Œè·¯å¾„ä¸èƒ½å†æ¬¡è¿›å…¥è¯¥æ ¼å­ã€‚ Tipsï¼š åœ¨äºŒç»´æ•°ç»„ä¸­æ¯ä¸ªç‚¹ä¸Šéƒ½è¿›è¡Œå°è¯•ï¼Œæ¯ä¸ªç‚¹ä¸ŠåŒæ ·æ˜¯ä¸Šä¸‹å·¦å³è¿›è¡Œå°è¯•ï¼Œè¿”å›žç¬¦åˆæ¡ä»¶çš„ã€‚ 1234567891011121314151617181920212223242526class Solution: # é€’å½’ è¿™ä¸ªæ˜¯ true or false åˆ¤æ–­ç±»åž‹çš„ã€‚ # æ€è·¯ï¼šå…ˆæ˜¯ rows* cols è¿™æ ·çš„å…¨éƒ¨éåŽ† def hasPath(self, matrix, rows, cols, path): # å¦‚æžœä½¿ç”¨ [ for _in range(rows) ] for _ in range(cols) ï¼Œ è¿™ä¸ªæ˜¯æœ‰ç»“æž„çš„ rows* cols assist = [True] * rows * cols for i in range(rows): for j in range(cols): if self.rightPath(matrix, rows, cols, i, j, path, assist): return True return False def rightPath(self, matrix, rows, cols, i, j, path, assist): if not path: return True index = i * cols + j if i &lt; 0 or i &gt;= rows or j &lt; 0 or j &gt;= cols or matrix[index] != path[0] or assist[index] == False: return False assist[index] = False if (self.rightPath(matrix, rows, cols, i + 1, j, path[1:], assist) or self.rightPath(matrix, rows, cols, i - 1, j, path[1:], assist) or self.rightPath(matrix, rows, cols, i, j - 1, path[1:], assist) or self.rightPath(matrix, rows, cols, i, j + 1, path[1:], assist)): return True assist[index] = True return False å¯¹äºŽæ·±åº¦ä¼˜å…ˆæœç´¢(DFS) ä¸­æœ€é‡è¦çš„æ˜¯è€ƒè™‘æœç´¢é¡ºåºã€‚åœ¨è¿™é‡Œï¼Œå…ˆæžšä¸¾å•è¯çš„èµ·ç‚¹ï¼Œç„¶åŽæžšä¸¾å•è¯çš„æ¯ä¸ªå­—æ¯ã€‚æ—¶é—´å¤æ‚åº¦åˆ†æžï¼Œèµ·ç‚¹ä¸€å…±æ˜¯æœ‰ $n^2$ ä¸ªï¼Œç„¶åŽæ¯ä¸ªå•è¯æ˜¯æœ‰ å››ä¸ªæ–¹å‘ï¼Œä½†æ˜¯ä¸èƒ½èµ°å›žå¤´è·¯ï¼Œæ‰€ä»¥é™¤äº†é¦–å­—æ¯å¤–ï¼Œåªæœ‰ä¸‰ç§é€‰æ‹©ã€‚æ‰€ä»¥æ€»çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n^23^k)$, å…¶ä¸­n è¡¨ç¤ºmatrix çš„é•¿æˆ–è€…å®½ï¼Œk è¡¨ç¤ºå¯»æ‰¾å­—ç¬¦ä¸²çš„é•¿åº¦ã€‚è¿™ä¸ªä»£ç ä¸­æ˜Žæ˜¾æ˜¯éœ€è¦ä½¿ç”¨åˆ°å›žæº¯çš„ï¼Œå› ä¸ºæ¯ä¸ªèŠ‚ç‚¹éƒ½æ˜¯æœ‰ 3ä¸­é€‰æ‹©çš„ã€‚ é¢˜ç›®é“¾æŽ¥ 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: // dfs ,é¦–å…ˆæ˜¯éåŽ†ç½‘æ ¼ï¼Œç„¶åŽå¯¹äºŽæ¯ä¸ªç½‘æ ¼è¿›è¡Œdfs() éåŽ† bool hasPath(vector&lt;vector&lt;char&gt;&gt;&amp; matrix, string str) &#123; for(int i =0; i&lt; matrix.size(); i++) &#123; for(int j =0; j&lt; matrix[i].size(); j++) &#123; if(dfs(matrix, str, 0, i, j)) return true; &#125; &#125; return false; &#125; bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; matrix, string str, int u, int i, int j) &#123; if(str[u] != matrix[i][j]) return false; // æ³¨æ„è¿™ä¸ªè¾¹ç•Œæ¡ä»¶ if( u ==str.size()-1) return true; char t =matrix[i][j]; // è¡¨ç¤ºä¸€ç§æ ‡è®°ï¼Œè®¿é—®è¿‡äº† matrix[i][j] ='#'; //ç„¶åŽè®¿é—®ä¸‹ä¸€ä¸ªç‚¹ int dx[4] =&#123;-1, 0, 1, 0&#125;, dy[4] =&#123;0, 1, 0, -1&#125;; for(int k=0; k&lt; 4; k++ ) &#123; int a =i +dx[k], b = j +dy[k]; if(a&gt;=0 &amp;&amp; a&lt;matrix.size() &amp;&amp; b&gt;= 0 &amp;&amp; b&lt; matrix[a].size()) if(dfs(matrix, str, u +1, a, b)) return true; // è¿™é‡Œæ˜¯æœ‰return å‡½æ•°çš„ï¼Œå…³é”®æ­¥éª¤æ³¨æ„ä¸€ä¸‹ &#125; matrix[i][j] =t; return false; &#125;&#125;;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[å‰‘æŒ‡Offer-å­—ç¬¦ä¸²å’Œæ•°ç»„]]></title>
    <url>%2F2019%2F03%2F17%2F%E5%89%91%E6%8C%87Offer-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®éƒ½æ˜¯æ¥è‡ªç‰›å®¢ç½‘åœ¨çº¿åˆ·é¢˜ä¸­çš„å‰‘æŒ‡offerã€‚åˆ·é¢˜è®°å½•ï¼Œé¡ºä¾¿ä»Žè€ƒå¯ŸçŸ¥è¯†ç‚¹çš„è§’åº¦åˆ†ç±»æ•´ç†ã€‚ä¸»è¦åˆ†æˆä»¥ä¸‹å››å¤§ç±»ï¼š å­—ç¬¦ä¸²ã€æ•°ç»„ é“¾è¡¨ã€æ ‘ é€’å½’ã€å›žæº¯ã€åŠ¨æ€è§„åˆ’ å…¶ä»–, æ¯”å¦‚ä½è¿ç®—ã€æ­£åˆ™åŒ¹é…ç­‰ è¿™æ˜¯å‰‘æŒ‡offer ç³»åˆ—å››éƒ¨æ›²ä¸­çš„ç¬¬ä¸€éƒ¨ã€‚ç¬¬ä¸€éƒ¨å…³äºŽå­—ç¬¦ä¸²å’Œæ•°ç»„ï¼Œç¬¬äºŒéƒ¨æ˜¯æ ˆã€é˜Ÿåˆ—ã€é“¾è¡¨å’Œæ ‘ï¼Œç¬¬ä¸‰éƒ¨é€’å½’ã€å›žæº¯å’ŒåŠ¨æ€è§„åˆ’ï¼Œ æœ€åŽä¸€éƒ¨åˆ†åœ¨è¿™é‡Œã€‚ äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾ åœ¨ä¸€ä¸ªäºŒç»´æ•°ç»„ä¸­ï¼ˆæ¯ä¸ªä¸€ç»´æ•°ç»„çš„é•¿åº¦ç›¸åŒï¼‰ï¼Œæ¯ä¸€è¡Œéƒ½æŒ‰ç…§ä»Žå·¦åˆ°å³é€’å¢žçš„é¡ºåºæŽ’åºï¼Œæ¯ä¸€åˆ—éƒ½æŒ‰ç…§ä»Žä¸Šåˆ°ä¸‹é€’å¢žçš„é¡ºåºæŽ’åºã€‚è¯·å®Œæˆä¸€ä¸ªå‡½æ•°ï¼Œè¾“å…¥è¿™æ ·çš„ä¸€ä¸ªäºŒç»´æ•°ç»„å’Œä¸€ä¸ªæ•´æ•°ï¼Œåˆ¤æ–­æ•°ç»„ä¸­æ˜¯å¦å«æœ‰è¯¥æ•´æ•°ã€‚ åˆ—çš„é€’å¢žä¸æ˜¯åŸºäºŽä¸Šä¸€è¡Œä¸­æœ€å¤§çš„ï¼ˆæœ€å³è¾¹ï¼‰è¿›è¡Œçš„é€’å¢žï¼Œè€Œæ˜¯åŸºäºŽä¸Šä¸€è¡Œå¯¹åº”çš„åˆ—çš„é€’å¢žã€‚æ‰€ä»¥ä¸æ˜¯å·¦ä¸Šè§’æ˜¯æœ€å°ï¼Œå³ä¸‹è§’æ˜¯æœ€å¤§çš„ã€‚ åŒæŒ‡é’ˆé—®é¢˜ï¼Œå¯¹äºŽä»»æ„çš„ä¸€ç‚¹ï¼Œä¸‹é¢çš„éƒ½æ˜¯æ¯”å…¶å¤§ï¼Œå·¦é¢çš„éƒ½æ˜¯æ¯”å…¶å°ï¼Œè¿™å°±å†³å®šäº†åšå¥½çš„å‡ºå‘ç‚¹æ˜¯ä»Žå³ä¸Šè§’å‡ºå‘ã€‚è¿™æ ·å¯ä»¥ä¸æ–­çš„è¿›è¡Œif â€¦ else çš„åˆ¤æ–­ï¼Œç„¶åŽæ‰¾åˆ° targetã€‚ 12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: # array äºŒç»´åˆ—è¡¨ def Find(self, target, array): # write code here if not array: return True n, m =len(array), len(array[0]) i , j =0, m-1 while i&lt;n and j&gt;=0: if(target ==array[i][j]): return True elif (target &gt; array[i][j]): i+=1 else: j-=1 return False c++ ç‰ˆæœ¬123456789101112131415161718class Solution &#123;public: // æ—¶é—´ O(m+n), ç©ºé—´O(1) bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; if(array.empty()) return false; int n =array.size(), m =array[0].size(); for(int i =0, j =m-1; i&lt;n &amp;&amp;j&gt;=0 ; ) &#123; if(target == array[i][j]) return true; else if(target &gt; array[i][j]) i+=1; else j-=1; &#125; return false; &#125;&#125;; æ›¿æ¢ç©ºæ ¼ è¯·å®žçŽ°ä¸€ä¸ªå‡½æ•°ï¼Œå°†ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­çš„æ¯ä¸ªç©ºæ ¼æ›¿æ¢æˆâ€œ\%20â€ã€‚ä¾‹å¦‚ï¼Œå½“å­—ç¬¦ä¸²ä¸ºWe Are Happy.åˆ™ç»è¿‡æ›¿æ¢ä¹‹åŽçš„å­—ç¬¦ä¸²ä¸ºWe\%20Are\%20Happyã€‚ Tipsï¼š å­—ç¬¦ä¸²çš„éåŽ†å¯¹äºŽ python è€Œè¨€æ˜¯æ¯”è¾ƒç®€å•çš„ã€‚ è€ƒå¯Ÿçš„å°±æ˜¯å­—ç¬¦ä¸²çš„éåŽ†ã€‚å¦‚æžœå‘çŽ°äº†ç©ºæ ¼ï¼Œé‚£ä¹ˆæ›¿æ¢æˆ â€œ%20â€ï¼Œå¦åˆ™å°±æ˜¯åŽŸå­—ç¬¦ã€‚ 12345678910111213# -*- coding:utf-8 -*-class Solution: # s æºå­—ç¬¦ä¸² # æ—¶é—´ O(n), ç©ºé—´ O(n), n =len(s) def replaceSpace(self, s): # write code here if not s: return "" res ="" for ch in s: if ch ==" ": res +="%20" else: res += ch return res åœ¨ c++ è¯»å…¥å’Œè¯»å‡º sringï¼Œä¸èƒ½ä½¿ç”¨ cinï¼Œå› ä¸ºcin è¯»å…¥æ˜¯ä»¥ç©ºæ ¼åˆ†å‰²çš„ã€‚ä½†æ˜¯è¯»å…¥çš„ä¸€ä¸ªå­—ç¬¦ä¸²ä¸èƒ½è¿™æ ·ã€‚ 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;const int N =10010;string replaceSpace(string str)&#123; string res; for(auto x: str) &#123; if (x ==' ') res += "%20"; else res += x; &#125; return res;&#125;int main()&#123; char str[N]; gets(str); cout&lt;&lt; str&lt;&lt;endl; string res =replaceSpace(str); cout&lt;&lt; res&lt;&lt;endl; return 0;&#125; æ—‹è½¬æ•°ç»„çš„æœ€å°æ•°å­— æŠŠä¸€ä¸ªæ•°ç»„æœ€å¼€å§‹çš„è‹¥å¹²ä¸ªå…ƒç´ æ¬åˆ°æ•°ç»„çš„æœ«å°¾ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºæ•°ç»„çš„æ—‹è½¬ã€‚ è¾“å…¥ä¸€ä¸ªéžå‡æŽ’åºçš„æ•°ç»„çš„ä¸€ä¸ªæ—‹è½¬ï¼Œè¾“å‡ºæ—‹è½¬æ•°ç»„çš„æœ€å°å…ƒç´ ã€‚ ä¾‹å¦‚æ•°ç»„{3,4,5,1,2}ä¸º{1,2,3,4,5}çš„ä¸€ä¸ªæ—‹è½¬ï¼Œè¯¥æ•°ç»„çš„æœ€å°å€¼ä¸º1ã€‚ NOTEï¼šç»™å‡ºçš„æ‰€æœ‰å…ƒç´ éƒ½å¤§äºŽ0ï¼Œè‹¥æ•°ç»„å¤§å°ä¸º0ï¼Œè¯·è¿”å›ž0ã€‚ å¦‚æžœæ˜¯æœ‰åºçš„æ•°ç»„ï¼Œé‚£ä¹ˆæŸ¥æ‰¾ä¸€ä¸ªæ•°å­—ï¼Œä½¿ç”¨ äºŒåˆ†æŸ¥æ‰¾å°±OKï¼Œè¿™ä¸ªæ•°å­—ä¸è¦æ±‚æ˜¯æœ€å°æ•°å­—ã€‚è¿™ä¸ªæ˜¯åœ¨æ—‹è½¬æ•°ç»„ä¸­æŸ¥æ‰¾æœ€å°å…ƒç´ ï¼Œè€Œä¸æ˜¯æŸ¥æ‰¾æŸä¸ªå…ƒç´ ï¼Œæ³¨æ„ä¸¤è€…çš„åŒºåˆ«ã€‚è¿™ä¸ªé¢˜ç›®æœ¬è´¨ä¸Šæ˜¯é€’å½’ï¼Œåªä¸è¿‡æ˜¯èƒ½å¤Ÿä½¿ç”¨å¾ªçŽ¯çš„æ–¹å¼è¿›è¡Œè¡¨è¾¾ã€‚è€Œé€’å½’çš„æœ¬è´¨åœ¨äºŽå¤§çš„é—®é¢˜èƒ½å¤Ÿè½¬æ¢æˆå°çš„é—®é¢˜ã€‚ æ—¶é—´å¤æ‚åº¦æœ€åæ˜¯$0(N)$ï¼Œ ä½†æ˜¯å¯¹äºŽä¸€èˆ¬æƒ…å†µä¸‹ï¼Œæ˜¯å¯ä»¥ä¼˜åŒ–çš„ã€‚å› ä¸ºè¿™ä¸ªæ•°æ®ç‰¹ç‚¹æ˜¯å­˜åœ¨é‡å¤çš„å…ƒç´ ã€‚ 12345678910111213141516171819# æ³¨æ„python ä¸­åˆ¤æ–­æ¡ä»¶æ˜¯éœ€è¦æœ‰ :, è€Œåœ¨c++ä¸­éœ€è¦æœ‰ &#123;&#125;def minNumber(arr): n =len(arr)-1 if n &lt;0: return 0 while(n and arr[0] ==arr[n]): n -=1 l, r =0, n while(l &lt;r): mid = l+r &gt;&gt;1 if(arr[0] &gt; arr[mid]): r =mid else: l =mid +1 print(arr[r])arr=[3, 4, 5, 1, 2]print(minNumber(arr)) c++ å•æœºç‰ˆæœ¬ã€‚æ—¶é—´å¤æ‚åº¦æœ€åæ˜¯ $O(n)$, ä½†æ˜¯ä¸€èˆ¬çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(logn)$ 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int MAX =1010;int n;vector&lt;int&gt; arr(MAX);int minNumber(vector&lt;int&gt; arr)&#123; while(n &amp;&amp; arr[n] ==arr[0]) n--; int l =0, r =n; while(l &lt;r) &#123; int mid = l+r &gt;&gt;1; if(arr[0] &gt; arr[mid]) r =mid; else l =mid +1; &#125; return arr[l];&#125;int main()&#123; cin&gt;&gt;n; for(int i =0; i&lt;n;i++) cin &gt;&gt; arr[i]; cout&lt;&lt; minNumber(arr)&lt;&lt; endl; return 0;&#125; è°ƒæ•´æ•°ç»„é¡ºåºä½¿å¥‡æ•°ä½äºŽå¶æ•°å‰é¢ è¾“å…¥ä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œå®žçŽ°ä¸€ä¸ªå‡½æ•°æ¥è°ƒæ•´è¯¥æ•°ç»„ä¸­æ•°å­—çš„é¡ºåºï¼Œä½¿å¾—æ‰€æœ‰çš„å¥‡æ•°ä½äºŽæ•°ç»„çš„å‰åŠéƒ¨åˆ†ï¼Œæ‰€æœ‰çš„å¶æ•°ä½äºŽæ•°ç»„çš„åŽåŠéƒ¨åˆ†ï¼Œå¹¶ä¿è¯å¥‡æ•°å’Œå¥‡æ•°ï¼Œå¶æ•°å’Œå¶æ•°ä¹‹é—´çš„ç›¸å¯¹ä½ç½®ä¸å˜ã€‚ å¿«æŽ’æ˜¯æ ¹æ®é˜ˆå€¼åˆ†åˆ«å·¦å³æŒ‘é€‰äº†å¤§äºŽå’Œå°äºŽé˜ˆå€¼çš„æ•°ç»„ã€‚è¿™é“é¢˜æ˜¯å¯ä»¥åˆ†åˆ«å·¦å³åˆ†åˆ«æŒ‘é€‰å¶æ•°å’Œå¥‡æ•°ï¼Œç„¶åŽäº¤æ¢ä½ç½®ï¼Œæ€è·¯æ˜¯ä¸€æ ·çš„ã€‚ æˆ‘çš„ç†è§£æ˜¯åŒæŒ‡é’ˆé—®é¢˜ï¼Œä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«æŒ‡å‘çš„æ˜¯å¶æ•°å’Œå¥‡æ•°ï¼Œå¦‚æžœå‘çŽ°äº†ä¸€å¯¹ï¼Œé‚£ä¹ˆäº¤æ¢é¡ºåºå°±okã€‚ ä¹¦ä¸­çš„åŽŸç‰ˆæœ¬æ˜¯æ²¡æœ‰â€ä¿æŒç›¸å¯¹ä½ç½®ä¸å˜â€œ è¿™ä¸ªæ¡ä»¶ã€‚åœ¨ç‰›å®¢ç½‘ä¸­ä½¿ç”¨äº†è¿™ä¸ªé™åˆ¶æ¡ä»¶ã€‚ä¸‹é¢çš„ä»£ç æ˜¯æ²¡æœ‰è¿™ä¸ªé™åˆ¶æ¡ä»¶çš„ã€‚è¿™ä¸ª swap() å‡½æ•°æ˜¯éžå¸¸å®žç”¨çš„å‡½æ•°ï¼Œä¸€å®šè¦è®°ä½ã€‚ä¸è¦åœ¨c++ ä¸­å†æ‰‹å†™swap() å‡½æ•°äº†ã€‚ 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N =1000;// å¥‡æ•°åœ¨å‰ å¶æ•°åœ¨åŽvoid reOrder(vector&lt;int&gt; &amp;arr)&#123; int i =0, j =arr.size() -1; while( i&lt;=j) &#123; while(i &lt;=j &amp;&amp; arr[j] %2 ==0) j-=1; while(i &lt;=j &amp;&amp; arr[i] %2 ==1) i+=1; if(i &lt;=j) swap(arr[i], arr[j]); &#125; &#125;int main()&#123; vector&lt;int&gt; arr(N); int n; cin &gt;&gt;n; for(int i =0; i&lt;n; i++) cin&gt;&gt; arr[i]; reOrder(arr); for(int i=0; i&lt;n; i++) cout&lt;&lt; arr[i] &lt;&lt; " "; cout&lt;&lt;endl; return 0;&#125; 123456789101112131415161718192021def partition(arr): if not arr or len(arr) ==0: return left, right =0, len(arr)-1 while left &lt; right: print(arr[left]) while arr[left] %2 ==0:# å¥‡å¶åˆ¤æ–­çš„æ—¶å€™ï¼Œå°½é‡ä¸è¦ä½¿ç”¨æ•´é™¤ï¼Œpython2 python3 çš„è¯­æ³•çŽ¯å¢ƒæ˜¯ä¸ä¸€æ ·çš„ left +=1 while arr[right] % 2 ==1: right -=1 if (left&lt; right): arr[left], arr[right] =arr[right], arr[left]if __name__ =="__main__": arr =[1,2, 3, 4, 5] partition(arr) print(arr) ä¸Šé¢ç‰ˆæœ¬ä¿ç•™äº†åŽŸå§‹æ•°å­—ç›¸å¯¹çš„é¡ºåºï¼Œä¸‹é¢è¿™ä¸ªæ²¡æœ‰ä¿ç•™ç›¸å¯¹çš„é¡ºåºã€‚å‰è€…çš„ç©ºé—´å¤æ‚åº¦æ˜¯O(N), åŽè€…çš„ç©ºé—´å¤æ‚åº¦æ˜¯O(1). 1234567891011121314151617class Solution: def reOrderArray(self, array): if len(array) ==0: return [] left =0 right =len(array)-1 while left &lt; right: # å¦‚æžœæ˜¯å¥‡æ•° key =array[left] while left &lt; right and array[right] &amp; 1 == 0: right -= 1 array[left] = array[right] # å¦‚æžœæ˜¯å¶æ•° while left &lt; right and array[left] &amp; 1 == 1: left += 1 array[right] = key return array å­—ç¬¦ä¸²çš„æŽ’åˆ— è¾“å…¥ä¸€ä¸ªå­—ç¬¦ä¸²,æŒ‰å­—å…¸åºæ‰“å°å‡ºè¯¥å­—ç¬¦ä¸²ä¸­å­—ç¬¦çš„æ‰€æœ‰æŽ’åˆ—ã€‚ä¾‹å¦‚è¾“å…¥å­—ç¬¦ä¸²abc,åˆ™æ‰“å°å‡ºç”±å­—ç¬¦a,b,cæ‰€èƒ½æŽ’åˆ—å‡ºæ¥çš„æ‰€æœ‰å­—ç¬¦ä¸²abc,acb,bac,bca,cabå’Œcbaã€‚ N è¡¨ç¤ºå­—ç¬¦ä¸²çš„é•¿åº¦ã€‚æ—¶é—´$ O(N N!)$ ç©ºé—´ $O(N N!)$ python å…·æœ‰æ›´åŠ ç®€å•çš„å†™æ³•ã€‚ 12345678910111213141516171819202122232425def permute(nums): res =[] dfs(nums, [], res) return resdef dfs(nums, path, res): if not nums: res.append(path) for i in range(len(nums)): dfs(nums[:i]+ nums[i+1:], path+[nums[i]], res )if __name__ =="__main__": n =int(input()) arr =input().split(" ") arr =[ int(a) for a in arr] print(arr) print(permute(arr)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;/* æ¯ä¸€ä¸ªé€’å½’éƒ½æ˜¯å¯¹åº”ç€ä¸€ä¸ªé€’å½’æ ‘ï¼Œæ‰€ä»¥å¥½å¥½æ€è€ƒè¿™ä¸ªè¿‡ç¨‹ã€‚ æœ‰ä¸¤ç§æ€è·¯ï¼Œä¸€ç§æ˜¯æžšä¸¾æ¯ä¸ªä½ç½®ä¸Šæ”¾å“ªäº›æ•°å­—ï¼›ä¸€ç§æ˜¯æžšä¸¾æ¯ä¸ªæ•°å­—æ”¾åˆ°å“ªäº›ä½ç½®ä¸Šã€‚å·®åˆ«åœ¨äºŽåŒä¸€å±‚ä¸­æ•°å­—çš„ä¸åŒçš„æ‘†æ”¾å½¢å¼ã€‚ */vector&lt;int&gt; arr;int n;vector&lt;vector&lt;int&gt;&gt; ans;vector&lt;int&gt; path;vector&lt;bool&gt; st;// u è¡¨ç¤ºåº•åŸºå±‚, è¿™ä¸ªä»£ç æ˜¯æžšä¸¾ä½ç½®ï¼ˆæ¯ä¸ªä½ç½®å¯ä»¥æ”¾ä»€ä¹ˆæ•°å­—ï¼‰çŠ¶æ€å°±æ˜¯ä½ç½®void dfs(vector&lt;int&gt; arr, int u)&#123; if(u ==n) &#123; ans.push_back(path); return; &#125; for(int i =0;i&lt; n; i++ ) &#123; if(!st[i]) &#123; st[i] =true; path.push_back(arr[i]); dfs(arr, u+1); st[i] =false; path.pop_back(); &#125; &#125; &#125;int main()&#123; cin&gt;&gt;n; arr =vector&lt;int&gt;(n); for(int i =0; i&lt;n; i++) cin&gt;&gt;arr[i]; st =vector&lt;bool&gt;(n); dfs(arr, 0); for(auto u: ans) &#123; for(auto v: u) cout&lt;&lt; v&lt;&lt;" "; cout&lt;&lt;endl; &#125; return 0;&#125; è¿™ä¸ªæ˜¯ permuations 2 æ—¶é—´å¤æ‚åº¦åˆ†æžï¼šæœç´¢æ ‘ä¸­æœ€åŽä¸€å±‚å…± $n! $ä¸ªèŠ‚ç‚¹ï¼Œå‰é¢æ‰€æœ‰å±‚åŠ ä¸€å—çš„èŠ‚ç‚¹æ•°é‡ç›¸æ¯”äºŽæœ€åŽä¸€å±‚èŠ‚ç‚¹æ•°æ˜¯æ— ç©·å°é‡ï¼Œå¯ä»¥å¿½ç•¥ã€‚ä¸”æœ€åŽä¸€å±‚èŠ‚ç‚¹è®°å½•æ–¹æ¡ˆçš„è®¡ç®—é‡æ˜¯ $O(n) $ï¼Œæ‰€ä»¥æ€»æ—¶é—´å¤æ‚åº¦æ˜¯ $O(nÃ—n!)$ å…³äºŽè·³è½¬æ˜¯ä¸€æ­¥ä¸€æ­¥è¿›è¡Œçš„ï¼Œå¦‚æžœæœ‰ä¸€ä¸ªé‡å¤ï¼Œèµ°å‘ä¸‹ä¸€ä¸ªï¼Œå¦‚æžœä¸‹ä¸€ä¸ªé‡å¤å†èµ°å‘ä¸‹ä¸€ä¸ªï¼Œå¦åˆ™çš„è¯æ˜¯ä»Ž 0å¼€å§‹éåŽ†çš„ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;//dfs(nums, u, s) uè¡¨ç¤ºæžšä¸¾çš„è£…å¡«ï¼Œ s è¡¨ç¤ºstartï¼Œä¸‹ä¸€ä¸ªæ•°ä»Žå“ªé‡Œå¼€å§‹æžšä¸¾int n;vector&lt;int&gt; arr;vector&lt;vector&lt;int&gt;&gt; ans;vector&lt;bool&gt; st;vector&lt;int&gt; path;void dfs(vector&lt;int&gt; arr, int u , int be)&#123; if( u == n) &#123; ans.push_back(path); return; &#125; // ç¬¬ä¸‰ä¸ªå‚æ•°æŒ‡å®š begin çš„ä½ç½®ï¼Œé‚£ä¹ˆè¿™ä¸ªå°±åº”è¯¥è¿™æ ·å†™ï¼Œå¦‚æžœä»Ž0 å¼€å§‹å°±æ²¡æœ‰æ„ä¹‰äº† for(int i =be; i&lt;n; i++) &#123; if(!st[i] ) &#123; st[i] =true; path.push_back(arr[i]); // è¿™ä¸ªæ‰æ˜¯éåŽ†ä¸‹ä¸€ä¸ªçš„ if(u+1 &lt; n &amp;&amp; arr[u+1] !=arr[u]) dfs(arr, u+1, 0); else dfs(arr, u+1, i+1); st[i] =false; path.pop_back(); &#125; &#125;&#125;int main()&#123; cin &gt;&gt;n; arr= vector&lt;int&gt;(n); for(int i =0; i&lt;n; i++) cin&gt;&gt;arr[i]; //åˆå§‹åŒ– st =vector&lt;bool&gt;(n, false); sort(arr.begin(), arr.end()); for(int i =0; i&lt;n; i++) cout&lt;&lt;arr[i] &lt;&lt;" "; cout&lt;&lt;endl; dfs(arr, 0, 0); for(auto u: ans) &#123; for(auto v: u) cout &lt;&lt; v&lt;&lt;" "; cout&lt;&lt;endl; &#125; return 0;&#125; æ•°ç»„ä¸­å‡ºçŽ°æ¬¡æ•°è¶…è¿‡ä¸€åŠçš„æ•°å­— æ•°ç»„ä¸­æœ‰ä¸€ä¸ªæ•°å­—å‡ºçŽ°çš„æ¬¡æ•°è¶…è¿‡æ•°ç»„é•¿åº¦çš„ä¸€åŠï¼Œè¯·æ‰¾å‡ºè¿™ä¸ªæ•°å­—ã€‚ä¾‹å¦‚è¾“å…¥ä¸€ä¸ªé•¿åº¦ä¸º9çš„æ•°ç»„{1,2,3,2,2,2,5,4,2}ã€‚ç”±äºŽæ•°å­—2åœ¨æ•°ç»„ä¸­å‡ºçŽ°äº†5æ¬¡ï¼Œè¶…è¿‡æ•°ç»„é•¿åº¦çš„ä¸€åŠï¼Œå› æ­¤è¾“å‡º2ã€‚å¦‚æžœä¸å­˜åœ¨åˆ™è¾“å‡º0ã€‚ Tipsï¼š å¦‚æžœæŸä¸ªæ•°å­—å‡ºçŽ°çš„æ¬¡æ•°å¤šäºŽä¸€åŠï¼Œé‚£ä¹ˆå…¶ä»–æ‰€æœ‰éžè¯¥æ•°å­—çš„å‡ºçŽ°çš„é¢‘æ•°æ˜¯å°äºŽè¯¥æ•°å­—çš„ï¼Œæ‰€ä»¥å½¢æˆä¸€ä¸ªäºŒåˆ†ç±»ã€‚ 12345678910111213141516171819class Solution:# å¦‚æžœå­˜åœ¨è¿™æ ·çš„æ•°å­—ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°å­—çš„é¢‘æ•°ä¸€å®šæ˜¯å¤§äºŽå…¶ä»–æ‰€æœ‰çš„é¢‘æ•°def MoreThanHalfNum_Solution(self, numbers): # write code here if not numbers: return 0 target = numbers[0] nums = 0 # ç»Ÿè®¡å‡ºçŽ°æ¬¡æ•°æœ€å¤šçš„æ•°å­— for i in numbers: if target == i: nums += 1 elif nums == 0: target = i nums = 1 else: nums -= 1 res = target if numbers.count(target) &gt; len(numbers) // 2 else 0 return res 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;// æ—¶é—´å¤æ‚åº¦ O(n) ç©ºé—´ O(1)int moreThanHalf(vector&lt;int&gt; &amp; nums)&#123; int cnt =0, val =-1; for(auto x : nums) &#123; if(!cnt) val =x, cnt =1; else &#123; if(x ==val) cnt++; else cnt --; &#125; &#125; return val; &#125;int main()&#123; int n ; cin&gt;&gt; n; vector&lt;int&gt; nums(n); for(int i =0; i&lt;n; i++) cin&gt;&gt; nums[i]; cout&lt;&lt; moreThanHalf(nums) &lt;&lt;endl; return 0;&#125; è¿žç»­å­æ•°ç»„çš„æœ€å¤§å’Œ HZå¶å°”ä¼šæ‹¿äº›ä¸“ä¸šé—®é¢˜æ¥å¿½æ‚ é‚£äº›éžè®¡ç®—æœºä¸“ä¸šçš„åŒå­¦ã€‚ä»Šå¤©æµ‹è¯•ç»„å¼€å®Œä¼šåŽ,ä»–åˆå‘è¯äº†:åœ¨å¤è€çš„ä¸€ç»´æ¨¡å¼è¯†åˆ«ä¸­,å¸¸å¸¸éœ€è¦è®¡ç®—è¿žç»­å­å‘é‡çš„æœ€å¤§å’Œ,å½“å‘é‡å…¨ä¸ºæ­£æ•°çš„æ—¶å€™,é—®é¢˜å¾ˆå¥½è§£å†³ã€‚ä½†æ˜¯,å¦‚æžœå‘é‡ä¸­åŒ…å«è´Ÿæ•°,æ˜¯å¦åº”è¯¥åŒ…å«æŸä¸ªè´Ÿæ•°,å¹¶æœŸæœ›æ—è¾¹çš„æ­£æ•°ä¼šå¼¥è¡¥å®ƒå‘¢ï¼Ÿä¾‹å¦‚:{6,-3,-2,7,-15,1,2,2},è¿žç»­å­å‘é‡çš„æœ€å¤§å’Œä¸º8(ä»Žç¬¬0ä¸ªå¼€å§‹,åˆ°ç¬¬3ä¸ªä¸ºæ­¢)ã€‚ç»™ä¸€ä¸ªæ•°ç»„ï¼Œè¿”å›žå®ƒçš„æœ€å¤§è¿žç»­å­åºåˆ—çš„å’Œï¼Œä½ ä¼šä¸ä¼šè¢«ä»–å¿½æ‚ ä½ï¼Ÿ(å­å‘é‡çš„é•¿åº¦è‡³å°‘æ˜¯1) è¿žç»­å­æ•°ç»„çš„æœ€å¤§å’Œå’Œæ•°ç»„ä¸­è¶…è¿‡ä¸€åŠçš„æ•°å­—ï¼Œè¿™ç§é—®é¢˜éƒ½æ˜¯å±žäºŽæ•°ç»„çš„éåŽ†é—®é¢˜ã€‚ æ—¶é—´ $O(N) $, ç©ºé—´ $O(1) $ 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;// nums ä¸­æœ‰æ­£æœ‰è´Ÿ//s çš„iå®šä¹‰ï¼Œ å½“å‰i çš„å‰ä¸€ä¸ªæ•°çš„æ‰€æœ‰æ•°ç»„çš„æœ€å¤§å’Œï¼Œ// s &gt;0 s +arr[i], s =0 if s&lt;=0int maxSubarray(vector&lt;int&gt;&amp; nums)&#123; int res =INT_MIN, s =0; for(auto num : nums) &#123; if(s &lt;=0) s =0; s += num; // å¤„ç†å½“å‰çš„å€¼ res =max(res, s); &#125; return res;&#125;int main()&#123; int n ; cin &gt;&gt;n; vector&lt;int&gt; nums(n); for(int i= 0; i&lt;n; i++) cin&gt;&gt; nums[i]; cout&lt;&lt; maxSubarray(nums); return 0;&#125; ç¬¬ä¸€ä¸ªåªå‡ºçŽ°ä¸€æ¬¡çš„å­—ç¬¦ åœ¨ä¸€ä¸ªå­—ç¬¦ä¸²(0&lt;=å­—ç¬¦ä¸²é•¿åº¦&lt;=10000ï¼Œå…¨éƒ¨ç”±å­—æ¯ç»„æˆ)ä¸­æ‰¾åˆ°ç¬¬ä¸€ä¸ªåªå‡ºçŽ°ä¸€æ¬¡çš„å­—ç¬¦,å¹¶è¿”å›žå®ƒçš„ä½ç½®, å¦‚æžœæ²¡æœ‰åˆ™è¿”å›ž -1ï¼ˆéœ€è¦åŒºåˆ†å¤§å°å†™ï¼‰. å¦‚æžœä½¿ç”¨äº† dictionaryï¼Œé‚£ä¹ˆè¿™ä¸ªåªæ˜¯æ•°æ®ç»“æž„ä¸Šçš„é—®é¢˜ï¼Œä¸å­˜åœ¨ç®—æ³•ä¸Šçš„é—®é¢˜äº†ã€‚ 1234567891011121314151617181920212223242526272829303132class Solution: """ Three ways to get dictionary of string s """ def FirstNotRepeatingChar(self, s): if not s: return -1 # get dictionary from collections import defaultdict dict1 =defaultdict(int) for string in s: dict1[string] += 1 # or this way # from collections import Counter # dict1 =Counter(s) # or do it yourself #dict1 =self.Counter_self(s) for index, val in enumerate(s): if dict1[val] == 1: return -1 def Counter_self(self, s): dict1 = &#123;&#125; for val in s: if val not in dict1: dict1[val] = 1 else: dict1[val] = dict1[val] + 1 return dict1 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;unordered_map&gt;using namespace std;char firstChar(string &amp; str)&#123; unordered_map&lt;char, int&gt; dic; for(auto ch: str) dic[ch] ++; char res ='#'; // è¿™ä¸ªèƒ½å†™æˆ "#" å— for(auto ch :str) if(dic[ch] ==1) &#123; res =ch; break; &#125; return res;&#125;int main()&#123; string str; getline(cin, str); // è¿™ç§è¯»å…¥stringçš„æ–¹å¼ cout&lt;&lt; firstChar(str)&lt;&lt;endl; return 0;&#125; æ•°ç»„ä¸­çš„é€†åºå¯¹ åœ¨æ•°ç»„ä¸­çš„ä¸¤ä¸ªæ•°å­—ï¼Œå¦‚æžœå‰é¢ä¸€ä¸ªæ•°å­—å¤§äºŽåŽé¢çš„æ•°å­—ï¼Œåˆ™è¿™ä¸¤ä¸ªæ•°å­—ç»„æˆä¸€ä¸ªé€†åºå¯¹ã€‚è¾“å…¥ä¸€ä¸ªæ•°ç»„,æ±‚å‡ºè¿™ä¸ªæ•°ç»„ä¸­çš„é€†åºå¯¹çš„æ€»æ•°Pã€‚å¹¶å°†På¯¹1000000007å–æ¨¡çš„ç»“æžœè¾“å‡ºã€‚ å³è¾“å‡ºP%1000000007 1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding:utf-8 -*-# ä¹‹å‰åœ¨ç‰›å®¢ç½‘ä¸Šæ˜¯å¯ä»¥é€šè¿‡çš„ï¼ŒçŽ°åœ¨å› ä¸ºæ—¶é—´å¤æ‚åº¦åˆæ²¡åŠžæ³•é€šè¿‡äº†class Solution: # è¿™ä¸ªä¸€æ–¤éš¾å‡ºå¤©æœºäº† å…ˆä¸çœ‹äº† def InversePairs(self, data): # write code here if not data: return 0 temp = [i for i in data] return self.mergeSort(temp, data, 0, len(data ) -1) % 1000000007 def mergeSort(self, temp, data, low, high): if low &gt;= high: temp[low] = data[low] return 0 mid = (low + high) / 2 # ä¸æ‡‚ data å’Œ temp ä¸ºä»€ä¹ˆæ˜¯é¢ å€’é¡ºåº left = self.mergeSort(data, temp, low, mid) right = self.mergeSort(data, temp, mid +1, high) count = 0 i = low j = mid +1 index = low while i &lt;= mid and j &lt;= high: if data[i] &lt;= data[j]: temp[index] = data[i] i += 1 else: temp[index] = data[j] count += mid - i +1 j += 1 index += 1 while i &lt;= mid: temp[index] = data[i] i += 1 index += 1 while j &lt;= high: temp[index] = data[j] j += 1 index += 1 return count + left + right c++ å†™æ³•ï¼Œæ³¨æ„å½’å¹¶æŽ’åºï¼Œä¸è¦è¿žå½’å¹¶éƒ½ä¸ä¼šå†™ï¼Œé‚£å°±ä¸¢äººä¸¢å¤§äº†ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯$O(nlogn)$ ç©ºé—´å¤æ‚åº¦æ˜¯$O(n)$ã€‚$log n $çš„æ—¶é—´å¤æ‚åº¦å’Œ $n$ æ˜¯æœ‰å¾ˆå¤§åŒºåˆ«çš„ï¼Œ å½“ $n=10^6 $æ—¶å€™ï¼Œ$logn =20$. 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int merge(vector&lt;int&gt; &amp; nums, int l, int r) &#123; if(l &gt;= r) return 0; int mid =(l +r) &gt;&gt;1; int res = merge(nums, l, mid) +merge(nums, mid+1, r); int i =l, j =mid+1; // åˆ«å½’å¹¶æŽ’åºéƒ½ä¸ä¼šå†™äº† vector&lt;int&gt; temp; while(i &lt;= mid &amp;&amp; j&lt;= r) &#123; if(nums[i] &lt;= nums[j]) temp.push_back(nums[i++]); // è¿™ä¸ªå†™çš„æ˜¯éžå¸¸çš„ç®€æ´çš„ else &#123; temp.push_back(nums[j++]); res += mid -i +1; &#125; &#125; while(i &lt;=mid) temp.push_back(nums[i++]); while(j &lt;= r) temp.push_back(nums[j++]); // ä¸‹é¢å°† temp æ•°ç»„è¿”å›žåˆ°numsä¸­, temp æ˜¯å·²ç»æŽ’å¥½åºçš„ i =l; for(auto x : temp) nums[i++] =x; return res; &#125; int InversePairs(vector&lt;int&gt; data) &#123; return merge(data, 0, data.size() -1); &#125;&#125;; æ•°å­—åœ¨æŽ’åºæ•°ç»„ä¸­å‡ºçŽ°çš„æ¬¡æ•°? ç»Ÿè®¡ä¸€ä¸ªæ•°å­—åœ¨æŽ’åºæ•°ç»„ä¸­å‡ºçŽ°çš„æ¬¡æ•°ã€‚ æƒ³æ³•ä¸€ï¼šåœ¨æŽ’åºæ•°ç»„ä¸­ï¼ŒæŸ¥æ‰¾æ•°å­—ï¼Œä½¿ç”¨çš„å°±æ˜¯äºŒåˆ†æŸ¥æ‰¾ï¼Œè¿™é‡Œä¸åŒçš„æ˜¯åˆ†åˆ«æ‰¾å‡ºå·¦å³ä¸¤ä¸ªè¾¹ç•Œçš„å€¼ã€‚å› ä¸ºæ˜¯è¿žç»­å‡ºçŽ°çš„ã€‚ï¼ˆå“ˆå“ˆï¼Œåœ¨ä½¿ç”¨ äºŒåˆ†æŸ¥æ‰¾å¾—åˆ°å·¦å³è¾¹ç•Œçš„æ—¶å€™ï¼Œå†™ä¸å‡ºæ¥ï¼‰ æ—¶é—´å¤æ‚åº¦ $O(n)$, ç©ºé—´$O(1)$ã€‚ è¿™é‡Œæ¶‰åŠåˆ°ä¸¤ç§ äºŒåˆ†çš„æ¨¡æ¿ï¼Œä¸»è¦åŒºåˆ«åœ¨äºŽmid çš„è®¡ç®—å’Œ l å’Œr çš„èµ‹å€¼ã€‚åŒºåˆ«ç‚¹åœ¨äºŽæŠŠmid åˆ’åˆ†æˆå·¦è¾¹è¿˜æ˜¯åˆ’åˆ†æˆå³è¾¹ã€‚å¦‚æžœåˆ’åˆ†æˆå³è¾¹ï¼Œ é‚£ä¹ˆmid çš„è®¡ç®—æ˜¯éœ€è¦åŠ  1æ“ä½œã€‚å¦‚æžœè€ƒè™‘æº¢å‡ºé—®é¢˜ï¼Œä¸€èˆ¬ä½¿ç”¨ long long l, r è¿™æ ·è¿›è¡Œå®šä¹‰ã€‚ 12345678910int bsearch_1(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; &#125; return l;&#125; 12345678910int bsearch_2(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; &#125; return l;&#125; 1234567891011121314151617181920212223242526272829class Solution &#123;public: int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123; if( data.empty()) return 0; int l =0, r =data.size() -1; while( l&lt;r) &#123; int mid = (l+r )&gt;&gt;1; if(data[mid] &gt;= k) r =mid ; else l =mid +1; &#125; if (data[l] != k) return 0; int left =l; l =0, r =data.size() -1; while(l&lt;r) &#123; int mid = (l +r +1) &gt;&gt;1; if(data[mid] &gt; k) r =mid-1; else l =mid; &#125; return l -left +1; &#125;&#125;; æƒ³æ³•äºŒï¼š ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾å¾—åˆ°ä¸€ä¸ªæ•°å­—ï¼Œå¦‚æžœç„¶åŽé¡ºåºæŸ¥æ‰¾ã€‚ä¸‹é¢æ˜¯å®žçŽ°ã€‚ 12345678910111213141516171819202122class Solution:# äºŒåˆ†æŸ¥æ‰¾ï¼Œå½“ data[mid] ==key çš„æ—¶å€™æ˜¯é¡ºåºæŸ¥æ‰¾ï¼Œæ˜¯é€’å½’è·³å‡ºçš„æ¡ä»¶def GetNumberOfK(self, data, k): # write code here # è¿™ä¸ªæ˜¯æœ‰ä¸¤ä¸ªè·³å‡ºæ¡ä»¶çš„ï¼Œä¸€ä¸ªæ˜¯æ­£ç¡®çš„è·³å‡ºï¼Œä¸€ä¸ªæ˜¯ä¸æ­£ç¡®çš„è·³å‡º if not data: return 0 mid =len(data) // 2 if data[mid] == k: left = right = mid for i in range(mid - 1, -1, -1): if data[i] == k: left -= 1 for i in range(mid + 1, len(data)): if data[i] == k: right += 1 return right - left + 1 # ä¸€åŠä¸€åŠçš„èˆåŽ»æ•°æ® elif data[mid] &lt; k: return self.GetNumberOfK(data[mid + 1:], k) else: return self.GetNumberOfK(data[:mid - 1], k) æ•°ç»„ä¸­åªå‡ºçŽ°ä¸€æ¬¡çš„æ•°å­— ** ä¸€ä¸ªæ•´åž‹æ•°ç»„é‡Œé™¤äº†ä¸¤ä¸ªæ•°å­—ä¹‹å¤–ï¼Œå…¶ä»–çš„æ•°å­—éƒ½å‡ºçŽ°äº†ä¸¤æ¬¡ã€‚è¯·å†™ç¨‹åºæ‰¾å‡ºè¿™ä¸¤ä¸ªåªå‡ºçŽ°ä¸€æ¬¡çš„æ•°å­—ã€‚ Tips: å¼‚æˆ–æ“ä½œï¼Œä¸¤ä¸ªåè¿›åˆ¶æ•°å­—ç»è¿‡å¼‚æˆ–ï¼ˆäºŒçº§åˆ¶è®¡ç®—è¿‡ç¨‹ï¼‰ï¼Œæœ€åŽçš„ç»“æžœæ˜¯10è¿›åˆ¶çš„å½¢å¼ã€‚å¦‚æžœä¸¤ä¸ªç›¸åŒçš„æ•°å­—å¼‚æˆ–ï¼Œé‚£ä¹ˆæœ€åŽçš„ç»“æžœæ˜¯0ï¼Œå¦‚æžœæ˜¯ä¸åŒçš„æ•°å­—ï¼Œæœ€åŽçš„ç»“æžœæ˜¯éž0.æ¯”å¦‚ 2^4 # 43^4 # 740^42 # 2 ç»“æžœçš„äºŒè¿›åˆ¶å½¢å¼ä¸€å®šè‡³å°‘æœ‰ä¸€ä¸ª â€œ1â€.ä½¿ç”¨index å¾—åˆ°ä¸¤ä¸ªä¸åŒçš„æ•°å­—äºŒè¿›åˆ¶å½¢å¼ä¸‹çš„ä½ç½®ï¼Œç„¶åŽä»Žè¯¥ä½ç½®å°†åŽŸæ¥çš„æ•°ç»„åˆ†æˆä¸¤ç±»ï¼Œé‚£ä¹ˆæ¯ç±»ä¸­åªå«æœ‰ä¸€ä¸ªå‡ºçŽ°ä¸€æ¬¡çš„æ•°å­—ï¼ŒæŽ¥ç€ä½¿ç”¨å¼‚æˆ–æ“ä½œã€‚ æœ€åˆçš„é¢˜ç›®ï¼šåªæœ‰ä¸€ä¸ªæ•°å­—å‡ºçŽ°äº†ä¸€æ¬¡ï¼Œå…¶ä»–çš„æ•°å­—éƒ½æ˜¯å‡ºçŽ°äº†å¶æ¬¡ï¼Œé‚£ä¹ˆä¸€ééåŽ†æ•°ï¼ˆè¿›è¡Œå¼‚æˆ–ï¼‰å°±å¯ä»¥å¾—åˆ°è¿™ä¸ªæ•°å­—ã€‚çŽ°åœ¨æ˜¯ç”±ä¸¤ä¸ªå•ç‹¬çš„æ•°å­—ã€‚ ä¸Žè¿ç®—æ˜¯ äºŒè¿›åˆ¶ä½è¿ç®—ï¼Œ ^ æ˜¯æ•´æ•°è¿ç®—ã€‚ 12345678910111213141516171819202122class Solution:# è¿”å›ž[a,b] å…¶ä¸­abæ˜¯å‡ºçŽ°ä¸€æ¬¡çš„ä¸¤ä¸ªæ•°å­—# ä½¿ç”¨å¼‚æˆ–çš„æ€§è´¨ï¼Œå¦‚æžœåªæœ‰ä¸€ä¸ªä¸åŒï¼Œå…¶ä»–çš„å¶æ¬¡å‡ºçŽ°ï¼Œé‚£ä¹ˆå…¨éƒ¨å¼‚æˆ–çš„ç»“æžœ# å°±æ˜¯é‚£ä¸ªå•ä¸€çš„æ•°å­—def FindNumsAppearOnce(self, array): # write code here remain, index =0, 1 for num in array: remain = remain ^ num # æ‰¾å‡ºç¬¬ä¸€ä¸ªæ˜¯1 çš„ä½ç½® # index éƒ½æ˜¯ while (remain &amp; index) ==0: index = index &lt;&lt;1 res1, res2 =0,0 for num in array: # è¿™ä¸ªæ¡ä»¶å¿…é¡»æ˜¯0, è¡¨ç¤ºä¸¤ä¸ªåœ¨è¿™ä¸ªä½æ•°æ˜¯ç›¸åŒçš„ï¼Œ # 234 ^0 =234 , if num &amp; index ==0: res1 =res1 ^ num else: res2 =res2 ^ num return [res1, res2] è¿™ä¸ªæ˜¯åŸºäºŽ c++ çš„å®žçŽ°ã€‚å¾ˆç®€æ´ 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int n ;vector&lt;int&gt; arr;// æ‰¾å‡ºåªå‡ºçŽ°ä¸€æ¬¡çš„ä¸¤ä¸ªæ•°å­—ï¼Œ ä½¿ç”¨å¼‚æˆ–è¿ç®—ï¼Œ æ—¶é—´å¤æ‚åº¦æ˜¯ O(n), ç©ºé—´ O(1)vector&lt;int&gt; findNumbers(vector&lt;int&gt; arr)&#123; int sum =0; for(auto a : arr) sum ^= a; int k =0; while(!( sum &gt;&gt; k &amp;1)) k++; int first =0; for(auto a : arr) &#123; if( a&gt;&gt; k &amp;1) first ^= a; &#125; return vector&lt;int&gt;&#123;first, sum ^first&#125;; &#125;int main()&#123; cin&gt;&gt; n; arr =vector&lt;int&gt;(n); for(int i =0; i&lt;n; i++) cin&gt;&gt; arr[i]; vector&lt;int&gt; res =findNumbers(arr); cout&lt;&lt; res[0] &lt;&lt;" "&lt;&lt; res[1]&lt;&lt; endl; return 0;&#125; å’Œä¸ºSçš„è¿žç»­æ­£æ•°åºåˆ— å°æ˜Žå¾ˆå–œæ¬¢æ•°å­¦,æœ‰ä¸€å¤©ä»–åœ¨åšæ•°å­¦ä½œä¸šæ—¶,è¦æ±‚è®¡ç®—å‡º9~16çš„å’Œ,ä»–é©¬ä¸Šå°±å†™å‡ºäº†æ­£ç¡®ç­”æ¡ˆæ˜¯100ã€‚ä½†æ˜¯ä»–å¹¶ä¸æ»¡è¶³äºŽæ­¤,ä»–åœ¨æƒ³ç©¶ç«Ÿæœ‰å¤šå°‘ç§è¿žç»­çš„æ­£æ•°åºåˆ—çš„å’Œä¸º100(è‡³å°‘åŒ…æ‹¬ä¸¤ä¸ªæ•°)ã€‚æ²¡å¤šä¹…,ä»–å°±å¾—åˆ°å¦ä¸€ç»„è¿žç»­æ­£æ•°å’Œä¸º100çš„åºåˆ—:18,19,20,21,22ã€‚çŽ°åœ¨æŠŠé—®é¢˜äº¤ç»™ä½ ,ä½ èƒ½ä¸èƒ½ä¹Ÿå¾ˆå¿«çš„æ‰¾å‡ºæ‰€æœ‰å’Œä¸ºSçš„è¿žç»­æ­£æ•°åºåˆ—? è¿™ä¸ªæ˜¯æ•°å­¦é—®é¢˜ï¼Œä½¿ç”¨ç­‰å·®æ•°åˆ—æ±‚å’Œã€‚è¿˜æœ‰ä¸€ç§è§£æ³•ã€‚ 12345678910111213141516def FindContinuousSequence(self, tsum): # write code here if tsum &lt; 2: return [] left = 1 right = left + 1 res = [] while left &lt; tsum // 2 + 1: if sum(range(left, right)) == tsum: res.append(range(left, right)) left += 1 elif sum(range(left, right)) &lt; tsum: right += 1 else: left += 1 return res åŒæŒ‡é’ˆé—®é¢˜ï¼Œå¯ä»¥åœ¨ O(n) æ—¶é—´å†…è§£å†³ 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;// åŒæŒ‡é’ˆé—®é¢˜i, jvector&lt;vector&lt;int&gt;&gt; find(int sum)&#123; vector&lt;vector&lt;int&gt;&gt; res; for(int i=1, j=1, s =1; i &lt;=sum; i++) &#123; while(s &lt; sum) s += ++j; if( s ==sum &amp;&amp; j -i&gt;0) &#123; vector&lt;int&gt; tmp; for(int k =i; k &lt;=j; k++) tmp.push_back(k); res.push_back(tmp); &#125; s -=i; &#125; return res;&#125;int main()&#123; int n; cin &gt;&gt;n; vector&lt;vector&lt;int&gt;&gt; res =find(n); for(auto u: res) &#123; for(auto v: u) cout&lt;&lt; v&lt;&lt; " "; cout&lt;&lt;endl; &#125; return 0;&#125; å’Œä¸ºSçš„ä¸¤ä¸ªæ•°å­— è¾“å…¥ä¸€ä¸ªé€’å¢žæŽ’åºçš„æ•°ç»„å’Œä¸€ä¸ªæ•°å­—Sï¼Œåœ¨æ•°ç»„ä¸­æŸ¥æ‰¾ä¸¤ä¸ªæ•°ï¼Œä½¿å¾—ä»–ä»¬çš„å’Œæ­£å¥½æ˜¯Sï¼Œå¦‚æžœæœ‰å¤šå¯¹æ•°å­—çš„å’Œç­‰äºŽSï¼Œè¾“å‡ºä¸¤ä¸ªæ•°çš„ä¹˜ç§¯æœ€å°çš„ã€‚ æœ‰åºåºåˆ—ï¼ŒæŸ¥æ‰¾ä¸¤ä¸ªæ•°å­—ï¼Œå¯ä»¥ä½¿ç”¨äºŒåˆ†ã€‚ 12345678910111213141516class Solution: def FindNumbersWithSum(self, array, tsum): # write code here if len(array) &lt; 2: return [] left = 0 right = len(array) - 1 while left &lt; right: if array[left] + array[right] == tsum: return [array[left], array[right]] elif array[left] + array[right] &lt; tsum: left += 1 else: right -= 1 return [] æ—¶é—´å¤æ‚åº¦æ˜¯$O(N)$, ä½†æ˜¯ç©ºé—´å¤æ‚åº¦æ˜¯ $O(1)$ 1234567891011121314151617class Solution &#123;public: // ä½¿ç”¨äºŒåˆ†çš„æ€æƒ³åŽ»åšï¼Œ O(logn) vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123; int l =0, r =array.size()-1; while( l&lt;r) &#123; int tmp =array[l] + array[r]; if(tmp == sum) return vector&lt;int&gt;&#123;array[l], array[r]&#125;; else if( tmp &gt; sum) r -=1; else l +=1; &#125; return vector&lt;int&gt;(); &#125;&#125;; è¿˜æœ‰ä¸€ç§æ€è·¯ä½¿ç”¨hash è¡¨ã€‚è¿™ç§æ—¶é—´å¤æ‚åº¦ä¹Ÿæ˜¯ $O(n)$ï¼Œä½†æ˜¯ç©ºé—´ä¸Šä½¿ç”¨äº† hash è¡¨çš„æ“ä½œã€‚ï¼ˆè¿™é‡Œä½¿ç”¨çš„set ï¼Œå› ä¸ºåªæ˜¯åˆ¤æ–­æ˜¯å¦å­˜åœ¨ï¼‰ 123456789101112 class Solution &#123;public: vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123; unordered_set&lt;int&gt; hash; for(auto a : array) &#123; if (hash.count(sum -a)) return vector&lt;int&gt;&#123;a, sum -a&#125;; hash.insert(a); &#125; return vector&lt;int&gt;(); &#125;&#125;; å·¦æ—‹è½¬å­—ç¬¦ä¸² æ±‡ç¼–è¯­è¨€ä¸­æœ‰ä¸€ç§ç§»ä½æŒ‡ä»¤å«åšå¾ªçŽ¯å·¦ç§»ï¼ˆROLï¼‰ï¼ŒçŽ°åœ¨æœ‰ä¸ªç®€å•çš„ä»»åŠ¡ï¼Œå°±æ˜¯ç”¨å­—ç¬¦ä¸²æ¨¡æ‹Ÿè¿™ä¸ªæŒ‡ä»¤çš„è¿ç®—ç»“æžœã€‚å¯¹äºŽä¸€ä¸ªç»™å®šçš„å­—ç¬¦åºåˆ—Sï¼Œè¯·ä½ æŠŠå…¶å¾ªçŽ¯å·¦ç§»Kä½åŽçš„åºåˆ—è¾“å‡ºã€‚ä¾‹å¦‚ï¼Œå­—ç¬¦åºåˆ—S=â€abcXYZdefâ€,è¦æ±‚è¾“å‡ºå¾ªçŽ¯å·¦ç§»3ä½åŽçš„ç»“æžœï¼Œå³â€œXYZdefabcâ€ã€‚æ˜¯ä¸æ˜¯å¾ˆç®€å•ï¼ŸOKï¼Œæžå®šå®ƒï¼ Tips: pythonä¸­å­—ç¬¦ä¸²çš„å¤„ç†æ˜¯æ²¡æœ‰åŽ‹åŠ›çš„ 123456class Solution: def LeftRotateString(self, s, n): # write code here if len(s) &lt; n: return '' return s[n:] + s[:n] æ—¶é—´å¤æ‚åº¦æ˜¯ $O(1)$ ç©ºé—´å¤æ‚åº¦æ˜¯ $O(N)$ã€‚ 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;string reversek(string str, int k)&#123; reverse(str.begin(), str.end()); reverse(str.begin(), str.begin() +str.size() -k); reverse(str.begin() +str.size() -k, str.end()); return str;&#125;// è¿™ä¸ªgetline() ä¸èƒ½åŒæ—¶è¾“å…¥ int å’Œ string ä¸¤ä¸ªå˜é‡int main()&#123; int k =3 ; //cin &gt;&gt;k; string str; getline(cin, str); string res = reversek(str, 3); cout&lt;&lt; res&lt;&lt; endl; return 0;&#125; ç¿»è½¬å•è¯é¡ºåº ç‰›å®¢æœ€è¿‘æ¥äº†ä¸€ä¸ªæ–°å‘˜å·¥Fishï¼Œæ¯å¤©æ—©æ™¨æ€»æ˜¯ä¼šæ‹¿ç€ä¸€æœ¬è‹±æ–‡æ‚å¿—ï¼Œå†™äº›å¥å­åœ¨æœ¬å­ä¸Šã€‚åŒäº‹Catå¯¹Fishå†™çš„å†…å®¹é¢‡æ„Ÿå…´è¶£ï¼Œæœ‰ä¸€å¤©ä»–å‘Fishå€Ÿæ¥ç¿»çœ‹ï¼Œä½†å´è¯»ä¸æ‡‚å®ƒçš„æ„æ€ã€‚ä¾‹å¦‚ï¼Œâ€œstudent. a am Iâ€ã€‚åŽæ¥æ‰æ„è¯†åˆ°ï¼Œè¿™å®¶ä¼™åŽŸæ¥æŠŠå¥å­å•è¯çš„é¡ºåºç¿»è½¬äº†ï¼Œæ­£ç¡®çš„å¥å­åº”è¯¥æ˜¯â€œI am a student.â€ã€‚Catå¯¹ä¸€ä¸€çš„ç¿»è½¬è¿™äº›å•è¯é¡ºåºå¯ä¸åœ¨è¡Œï¼Œä½ èƒ½å¸®åŠ©ä»–ä¹ˆï¼Ÿ è¿™ä¸ªæ˜¯é€šè¿‡ä¸¤æ¬¡ç¿»è½¬å°±å¯ä»¥è§£å†³ï¼Œç¬¬ä¸€æ¬¡æ˜¯å­—ç¬¦ä¸²çš„å®Œå…¨ç¿»è½¬ï¼Œç¬¬äºŒæ¬¡æ˜¯å•è¯çš„å®Œå…¨ç¿»è½¬ã€‚start, end åˆ†åˆ«æ ‡è®°ä¸€ä¸ªå•è¯çš„å¼€å§‹å’Œç»“æŸã€‚ 1234567891011121314151617181920212223242526272829class Solution: def Reverse(self, s, left, right): while left &lt;right: s[left], s[right] = s[right], s[left] left +=1 right -=1 def ReverseSentence(self, s): # write code here if not s: return s # from immutable string to mutable list # s =list(s) self.Reverse(s, 0, len(s) - 1) start, end = 0, 0 # è¿™ä¸ªå°äºŽå· æ˜¯python ä¸­ç‰¹æœ‰çš„å‘ï¼ŒçœŸæ­£èƒ½å¤Ÿè®¿é—®çš„åŒºé—´æ˜¯ [0, len(s)-1] è¿™æ ·çš„åŒºé—´ while start &lt; len(s): if s[start] == " ": start += 1 end += 1 elif end == len(s) or s[end] == " ": self.Reverse(s, start, end - 1) # update æ“ä½œ end += 1 start = end else: end += 1 return "".join(s) å…¶ä¸­ string çš„åˆ¤æ–­æ“ä½œæ˜¯éžå¸¸ç»å…¸çš„ï¼Œ i å’Œj çš„æ“ä½œï¼Œè¿™ä¸ªå°±æ˜¯ä¸€ä¸ªæ¨¡æ¿ã€‚ 123456789101112131415161718class Solution &#123;public: // æ•´ä¸ªå­—ç¬¦ä¸²ç¿»è½¬ï¼Œç„¶åŽæ¯ä¸ªå•è¯è¿›è¡Œç¿»è½¬ æ—¶é—´O(1) ç©ºé—´æ˜¯ o(N) string ReverseSentence(string str) &#123; reverse(str.begin(), str.end()); for(int i =0; i&lt; str.size(); i++) &#123; int j =i; while( j&lt; str.size() &amp;&amp; str[j] != ' ') j++; reverse(str.begin() +i, str.begin() +j); i =j; &#125; return str; &#125;&#125;; æ‰‘å…‹ç‰Œé¡ºå­ LLä»Šå¤©å¿ƒæƒ…ç‰¹åˆ«å¥½,å› ä¸ºä»–åŽ»ä¹°äº†ä¸€å‰¯æ‰‘å…‹ç‰Œ,å‘çŽ°é‡Œé¢å±…ç„¶æœ‰2ä¸ªå¤§çŽ‹,2ä¸ªå°çŽ‹(ä¸€å‰¯ç‰ŒåŽŸæœ¬æ˜¯54å¼ ^_^)â€¦ä»–éšæœºä»Žä¸­æŠ½å‡ºäº†5å¼ ç‰Œ,æƒ³æµ‹æµ‹è‡ªå·±çš„æ‰‹æ°”,çœ‹çœ‹èƒ½ä¸èƒ½æŠ½åˆ°é¡ºå­,å¦‚æžœæŠ½åˆ°çš„è¯,ä»–å†³å®šåŽ»ä¹°ä½“è‚²å½©ç¥¨,å˜¿å˜¿ï¼ï¼â€œçº¢å¿ƒA,é»‘æ¡ƒ3,å°çŽ‹,å¤§çŽ‹,æ–¹ç‰‡5â€,â€œOh My God!â€ä¸æ˜¯é¡ºå­â€¦..LLä¸é«˜å…´äº†,ä»–æƒ³äº†æƒ³,å†³å®šå¤§/å° çŽ‹å¯ä»¥çœ‹æˆä»»ä½•æ•°å­—,å¹¶ä¸”Açœ‹ä½œ1,Jä¸º11,Qä¸º12,Kä¸º13ã€‚ä¸Šé¢çš„5å¼ ç‰Œå°±å¯ä»¥å˜æˆâ€œ1,2,3,4,5â€(å¤§å°çŽ‹åˆ†åˆ«çœ‹ä½œ2å’Œ4),â€œSo Lucky!â€ã€‚LLå†³å®šåŽ»ä¹°ä½“è‚²å½©ç¥¨å•¦ã€‚ çŽ°åœ¨,è¦æ±‚ä½ ä½¿ç”¨è¿™å¹…ç‰Œæ¨¡æ‹Ÿä¸Šé¢çš„è¿‡ç¨‹,ç„¶åŽå‘Šè¯‰æˆ‘ä»¬LLçš„è¿æ°”å¦‚ä½•ï¼Œ å¦‚æžœç‰Œèƒ½ç»„æˆé¡ºå­å°±è¾“å‡ºtrueï¼Œå¦åˆ™å°±è¾“å‡ºfalseã€‚ä¸ºäº†æ–¹ä¾¿èµ·è§,ä½ å¯ä»¥è®¤ä¸ºå¤§å°çŽ‹æ˜¯0ã€‚ æ¨¡æ‹Ÿé¢˜åˆ†æˆä¸‰æ­¥éª¤ åˆ åŽ»æ‰€æœ‰çš„0 å¦‚æžœå­˜åœ¨é‡å¤çš„å…ƒç´ ï¼Œé‚£ä¹ˆä¸€å®šä¸æ˜¯é¡ºå­ å¦‚æžœæœ€å¤§å€¼å’Œæœ€å°å€¼ä¹‹é—´çš„å·®è·å¤§äºŽ4 é‚£ä¹ˆä¸æ˜¯ï¼›å¦‚æžœå°äºŽ4 é‚£ä¹ˆå°±æ˜¯ã€‚ ä¸Šé¢ä¸‰ä¸ªçš„åˆ¤æ–­æ˜¯å¯ä»¥é€šè¿‡å…ˆæŽ’åºè¿›è¡Œæ–¹ä¾¿çš„åˆ¤æ–­çš„ã€‚ ç¬¬ä¸‰ç‚¹æ˜¯æ¯”è¾ƒéš¾æƒ³åˆ°çš„ã€‚ä½¿ç”¨æœ€å€¼ä¹‹å·®åˆ¤æ–­æ˜¯å¦æ˜¯è¿žç»­çš„æ•°å­—ã€‚ Tipsï¼šlist ä¸­çš„ç©ºç¼ºæ•°é‡ éœ€è¦ä¸å¤§äºŽ å¤§å°çŽ‹æ€»æ•°ï¼Œè¿™æ ·æ‰èƒ½æž„æˆé¡ºå­ã€‚ 12345678910111213141516171819202122232425class Solution: """ ç©ºç¼ºæ˜¯1 æ„å‘³ç€è¿™ä¸¤ä¸ªæ•°å­—æ˜¯è¿žç»­çš„ æ¯”å¦‚è¯´ 1 2ï¼Œ è¿™ä¸ªbig -small ==1, æ‰€ä»¥è¿™ä¸ªç©ºç¼ºæ˜¯0ï¼Œä¸ç”¨è¿›è¡Œå¡«å……ã€‚ """ def IsContinuous(self, numbers): # write code here if not numbers: return False numbers.sort() # sort() sorted() è¿™ç§æ€Žä¹ˆä½¿ç”¨ï¼Œè¿”å›žå€¼æ˜¯ä»€ä¹ˆï¼Œè¿™äº›åŸºæœ¬çš„ä¸œè¥¿ zeros =numbers.count(0) gaps = 0 left = zeros # å› ä¸ºè¿™ä¸ªæ˜¯æŽ’åºä¹‹åŽçš„ç»“æžœï¼Œæ‰€ä»¥å¯ä»¥è¿™æ ·è¿›è¡Œæ“ä½œ right = left + 1 # å®žé™…ä¸Šè¿˜æ˜¯ä¸¤ä¸ªæŒ‡é’ˆï¼Œ æ‰€ä»¥å¯ä»¥ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆè¿›è¡Œæ“ä½œ # æœ¬è´¨ä¸Šæ˜¯ä¸¤ä¸ª ç›¸é‚»æŒ‡é’ˆåœ¨è¿›è¡Œç§»åŠ¨ï¼Œå› ä¸ºæ˜¯æŽ’åºä¹‹åŽï¼Œæ‰€ä»¥æ²¡æœ‰é—®é¢˜ while right &lt; len(numbers): if numbers[left] == numbers[right]: return False gaps += numbers[right] - numbers[left] - 1 left = right right += 1 # è¿™ç§æ˜¯çœŸçš„ å¾ˆç®€æ´ï¼Œ gaps &lt;= zeros å°‘åŽ»äº†å¾ˆå¤šif elseçš„åˆ¤æ–­ return gaps &lt;= zeros 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N =100;bool isContinuous(vector&lt;int&gt; arr)&#123; sort(arr.begin(), arr.end()); int i =0; while( !arr[i]) i++; // number of zero // åˆ¤æ–­ä¸¤ä¸ªç›¸é‚»çš„å…ƒç´ æ˜¯å¦é‡å¤ for(int j =i+1; j&lt;arr.size() ; j++) &#123; if(arr[j] == arr[j-1]) return false; &#125; //cout&lt;&lt; arr[i+1]&lt;&lt; endl; return arr.back()- arr[i] &lt;=4 ; &#125;int main()&#123; int n; vector&lt;int&gt; arr(N); cin &gt;&gt;n; for(int i =0; i&lt;n ;i++) cin&gt;&gt;arr[i]; cout&lt;&lt; isContinuous(arr)&lt;&lt; endl; return 0;&#125; å­©å­ä»¬çš„æ¸¸æˆ(åœ†åœˆä¸­æœ€åŽå‰©ä¸‹çš„æ•°) æ¯å¹´å…­ä¸€å„¿ç«¥èŠ‚,ç‰›å®¢éƒ½ä¼šå‡†å¤‡ä¸€äº›å°ç¤¼ç‰©åŽ»çœ‹æœ›å­¤å„¿é™¢çš„å°æœ‹å‹,ä»Šå¹´äº¦æ˜¯å¦‚æ­¤ã€‚HFä½œä¸ºç‰›å®¢çš„èµ„æ·±å…ƒè€,è‡ªç„¶ä¹Ÿå‡†å¤‡äº†ä¸€äº›å°æ¸¸æˆã€‚å…¶ä¸­,æœ‰ä¸ªæ¸¸æˆæ˜¯è¿™æ ·çš„:é¦–å…ˆ,è®©å°æœ‹å‹ä»¬å›´æˆä¸€ä¸ªå¤§åœˆã€‚ç„¶åŽ,ä»–éšæœºæŒ‡å®šä¸€ä¸ªæ•°m,è®©ç¼–å·ä¸º0çš„å°æœ‹å‹å¼€å§‹æŠ¥æ•°ã€‚æ¯æ¬¡å–Šåˆ°m-1çš„é‚£ä¸ªå°æœ‹å‹è¦å‡ºåˆ—å”±é¦–æ­Œ,ç„¶åŽå¯ä»¥åœ¨ç¤¼å“ç®±ä¸­ä»»æ„çš„æŒ‘é€‰ç¤¼ç‰©,å¹¶ä¸”ä¸å†å›žåˆ°åœˆä¸­,ä»Žä»–çš„ä¸‹ä¸€ä¸ªå°æœ‹å‹å¼€å§‹,ç»§ç»­0â€¦m-1æŠ¥æ•°â€¦.è¿™æ ·ä¸‹åŽ»â€¦.ç›´åˆ°å‰©ä¸‹æœ€åŽä¸€ä¸ªå°æœ‹å‹,å¯ä»¥ä¸ç”¨è¡¨æ¼”,å¹¶ä¸”æ‹¿åˆ°ç‰›å®¢åè´µçš„â€œåä¾¦æŽ¢æŸ¯å—â€å…¸è—ç‰ˆ(åé¢æœ‰é™å“¦!!^_^)ã€‚è¯·ä½ è¯•ç€æƒ³ä¸‹,å“ªä¸ªå°æœ‹å‹ä¼šå¾—åˆ°è¿™ä»½ç¤¼å“å‘¢ï¼Ÿ(æ³¨ï¼šå°æœ‹å‹çš„ç¼–å·æ˜¯ä»Ž0åˆ°n-1) Tips: çº¦ç‘Ÿå¤«çŽ¯çš„é—®é¢˜ï¼Œ è¦æ±‚æ±‚è§£çš„æ˜¯æœ€åŽèƒœåˆ©è€…çš„ç¼–å·ï¼Œæ‰€ä»¥åº”ç”¨æ•°å­¦æŠ€å·§å°±å¯ä»¥äº†ã€‚ $ f(x) = (f( x-1) + m ) % (x) $ , å…±æœ‰ m ä¸ªç¼–å·ï¼Œn ä¸ªäºº 12345678910111213class Solution:# mod æ±‚ä½™ çš„æ“ä½œï¼Œ a mod b ==c ,è¯´æ˜Ž aé™¤ä»¥b ä¹‹åŽä½™æ•°æ˜¯c# https://blog.csdn.net/gatieme/article/details/51435055ï¼Œ ä»Žåšé¢˜æ€è·¯ä¸Šè®²è§£çš„æ¯”è¾ƒå¥½# n ä¸ªå°æœ‹å‹ï¼Œç„¶åŽæ˜¯m ä¸ªç¼–å·def LastRemaining_Solution(self, n, m): # write code here if n&lt; 1 or m&lt;1: return -1 last =0 for i in range(2, n+1): # è¿™ä¸ªç›¸å½“äºŽ æ˜¯ä¸€ä¸ª â€œæŒ‘é€‰äººâ€ çš„é€†è¿‡ç¨‹ï¼Œ å› ä¸ºä½¿ç”¨çš„ mod æ“ä½œå°±æ˜¯å–ä½™çš„æ“ä½œ last =(last +m) %i return last çº¦ç‘Ÿå¤«é—®é¢˜ä½¿ç”¨é€’æŽ¨çš„æ–¹å¼æ¥åšã€‚ç›¸é‚»ä¸¤é¡¹ä¹‹é—´çš„å…³ç³»ï¼ŒæŽ¨å¯¼è¶³å¤Ÿç®€å•ï¼Œé‚£ä¹ˆå°±å¯ä»¥ä¹‹é—´è®¡ç®—äº†ã€‚å½“åŽ»æŽ‰ç¬¬m ä¸ªäººä¹‹åŽï¼Œé‡æ–°è¿›è¡Œç¼–å·ã€‚éœ€è¦å¯»æ‰¾çš„æ˜¯æ–°æ—§ç¼–å·ä¹‹é—´çš„å…³ç³»ã€‚ $f(n, m) = (f(n-1, m) +m ) % n$ å°±æ˜¯æ–°æ—§ç¼–ç ä¸­é€’æŽ¨å…³ç³»å¼ã€‚ å…¶ä¸­ n è¡¨ç¤ºæ€»å…±æœ‰n ä¸ªäººï¼Œm è¡¨ç¤ºåŽ»æŽ‰m ä¸ªäººã€‚å½“n ==1 çš„æ—¶å€™ï¼ˆå‰©ä¸‹ä¸€ä¸ªäººï¼‰ï¼Œé‚£ä¹ˆå¯ä»¥è·³å‡ºäº†ã€‚ æ±‚1+2+3+â€¦+n æ±‚1+2+3+â€¦+nï¼Œè¦æ±‚ä¸èƒ½ä½¿ç”¨ä¹˜é™¤æ³•ã€forã€whileã€ifã€elseã€switchã€caseç­‰å…³é”®å­—åŠæ¡ä»¶åˆ¤æ–­è¯­å¥ï¼ˆA?B:Cï¼‰ã€‚ Tipsï¼š ä¸ä½¿ç”¨æ¡ä»¶åˆ¤æ–­ï¼Œæ¥æŽ§åˆ¶è·³å‡ºï¼›è¿™é‡Œä½¿ç”¨çš„æ˜¯ â€œçŸ­è·¯æ¡ä»¶â€ æ¥ æŽ§åˆ¶ é€’å½’çš„è·³å‡ºã€‚ ä½¿ç”¨é€’å½’çš„æ€æƒ³ï¼Œæ¥æ±‚è§£æ•°åˆ—çš„å’Œã€‚ 12345678910111213141516class Solution: # å¦‚æžœä½ æƒ³ä½¿ç”¨å…¨å±€å˜é‡ï¼Œé‚£ä¹ˆæ”¾åœ¨ __init__ ä¸­å°±æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„æ–¹å¼ def __init__(self): self.ans =0 def Sum_Solution(self, n): # write code here self.recur(n) return self.ans # n&gt;0 å°±æ˜¯ä¸€ä¸ªçŸ­è·¯æ¡ä»¶ï¼Œè¿™ä¸ªç›´æŽ¥å†³å®šäº†åŽé¢é€’å½’ä¼šä¸ä¼šç»§ç»­æ‰§è¡Œä¸‹åŽ»ï¼Œä¹Ÿå°±æ˜¯è·³å‡ºçš„æ¡ä»¶ # è‡³äºŽä¼šä¸ä¼šå›žåˆ°åŽŸæ¥æœ€åˆçš„çŠ¶æ€ï¼Œè¿™ä¸ªæ˜¯ä¸é‡è¦çš„ï¼Œæœ€åŽçš„ç»“æžœæ˜¯ self.ans ï¼Œfalseä¹‹åŽç›´æŽ¥ä½¿ç”¨è¿™ä¸ªå°±è¡Œäº† def recur(self, n): self.ans += n n -= 1 return n &gt; 0 and self.Sum_Solution(n) ä¸ç”¨åŠ å‡ä¹˜é™¤åšåŠ æ³• å†™ä¸€ä¸ªå‡½æ•°ï¼Œæ±‚ä¸¤ä¸ªæ•´æ•°ä¹‹å’Œï¼Œè¦æ±‚åœ¨å‡½æ•°ä½“å†…ä¸å¾—ä½¿ç”¨+ã€-ã€*ã€/å››åˆ™è¿ç®—ç¬¦å·ã€‚ Tips: ä½¿ç”¨ å¼‚æˆ–å’Œä¸Ž æ¥è¿›è¡Œ â€œåŠ â€ã€â€œå‡â€çš„æ“ä½œã€‚åŠ æ³•æ˜¯åˆ†æˆå½“å‰ä½ç›¸åŠ  å’Œè¿›ä½ä¸¤ä¸ªéƒ¨åˆ†çš„ã€‚ä¸Žæ“ä½œæ˜¯ä½œä¸ºè¿›ä½æ“ä½œï¼Œåªæœ‰ 1 &amp;1 æ‰æ˜¯1ï¼Œå¼‚æˆ–ä½œä¸ºç›¸åŠ çš„æ“ä½œï¼Œ 0 ^1 æ˜¯1ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution: """ ä¸èƒ½ä½¿ç”¨å››åˆ™è¿ç®—ç¬¦ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨ä½è¿ç®—ç¬¦ã€‚å¯¹è¿™ä¸¤ä¸ªæ•°åœ¨æ›´åº•å±‚çš„è§’åº¦ä¸Šè¿›è¡Œè¿ç®—ã€‚ä¹Ÿå°±æ˜¯ä»Ž 01 è¿™ç§å­ä¸²çš„è§’åº¦è¿›è¡Œè€ƒè™‘ https://blog.csdn.net/derrantcm/article/details/46798763 è¿™ä¸ªåšå®¢å¯¹äºŽæ•°çš„è¿ç®—è¿‡ç¨‹å’Œ ä½è¿ç®—æ˜¯å¦‚ä½•ä¸€ä¸€å¯¹åº”çš„ã€‚åˆ†ä¸ºä¸è¿›ä½ç›¸åŠ å’Œè¿›ä½ç›¸åŠ ã€‚ """ def add(self, num1, num2): while num2 != 0: carry = num1 &amp; num2 num1 = num1 ^ num2 # è¿™ä¸ªåº”è¯¥ç†è§£ä¸ºåˆ°é«˜ä½ è€Œä¸æ˜¯*2 è¿™æ ·çš„æ“ä½œ num2 = carry &lt;&lt; 1 return num1 def sub(self, num1, num2): while num2 != 0: carry = (~num1) &amp; num2 num1 = num1 ^ num2 num2 = carry &lt;&lt; 1 return num1 def Add(self, num1, num2): if num1 &gt;= 0 and num2 &gt;= 0: result = self.add(num1, num2) elif num1 &gt; 0 and num2 &lt; 0: flag = 1 if num1 &gt; abs(num2) else -1 # num2 =abs(num2) # keep num1 bigger than num2 if num1 &lt; abs(num2): num1, num2 = abs(num2), num1 result = self.sub(num1, abs(num2)) result = result * flag elif num1 &lt; 0 and num2 &gt; 0: flag = 1 if abs(num1) &lt; num2 else -1 if abs(num1) &lt; num2: num1, num2 = num2, abs(num1) result = self.sub(abs(num1), num2) result = result * flag else: flag = -1 num1 = abs(num1) num2 = abs(num2) result = self.add(num1, num2) result = result * flag return result ä½¿ç”¨é€’å½’è§£æ³•ï¼Œè¿™é‡Œä½¿ç”¨äº†ä¸€ä¸ª trick 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N =100;int getSum(int n)&#123; int res =n; // ä½†æ˜¯ä¸èƒ½ç”¨ if, å¯¹äºŽ &amp;&amp; å’Œ || æ“ä½œï¼Œåœ¨ç¼–è¯‘çš„æ—¶å€™æ˜¯æœ‰æå‰è·³å‡ºï¼Œè¿™ä¹ˆä¸€è¯´çš„ï¼Œæ‰€ä»¥å¾ˆç®€å• //if(n &gt;0) res += getSum(n -1); n &gt;0 &amp;&amp; (res += getSum(n-1)); return res;&#125;int main()&#123; int n ; cin&gt;&gt;n; cout&lt;&lt; getSum(n)&lt;&lt; endl; return 0;&#125; æŠŠå­—ç¬¦ä¸²è½¬æ¢æˆæ•´æ•° å°†ä¸€ä¸ªå­—ç¬¦ä¸²è½¬æ¢æˆä¸€ä¸ªæ•´æ•°(å®žçŽ°Integer.valueOf(string)çš„åŠŸèƒ½ï¼Œä½†æ˜¯stringä¸ç¬¦åˆæ•°å­—è¦æ±‚æ—¶è¿”å›ž0)ï¼Œè¦æ±‚ä¸èƒ½ä½¿ç”¨å­—ç¬¦ä¸²è½¬æ¢æ•´æ•°çš„åº“å‡½æ•°ã€‚ æ•°å€¼ä¸º0æˆ–è€…å­—ç¬¦ä¸²ä¸æ˜¯ä¸€ä¸ªåˆæ³•çš„æ•°å€¼åˆ™è¿”å›ž0ã€‚ Tipsï¼šè¿˜æ˜¯python ä¸­å¤„ç† stringï¼Œ ä½¿ç”¨ dictionary å¤„ç†å­—ç¬¦ä¸²å’Œ æ•°å­—çš„åŒ¹é…ã€‚è¿™ä¸ªæœ‰å¥½å¤šä¸ªç‰ˆæœ¬ï¼Œæ˜¯éœ€è¦é—®æ¸…é¢˜ç›®è¦æ±‚ï¼Œç„¶åŽæ ¹æ®è¿›è¡Œä½œç­”ã€‚æ¯”å¦‚è¯´è¿™ä¸ªæ˜¯æ•´æ•°æ¯”è¾ƒç®€å•ï¼Œå¦‚æžœåŠ ä¸Šå°æ•°ï¼Œè¯¥å¦‚ä½•å¤„ç†ã€‚å¦‚æžœæ˜¯ä¸­æ–‡ï¼Œçš„è¯¥å¦‚ä½•å¤„ç†ã€‚ 12345678910111213141516171819202122class Solution:# æœ‰å¾ˆå¤šä¸åˆæ³•çš„è¾“å…¥ï¼Œæ¯”å¦‚ç©ºå­—ç¬¦ä¸²ï¼Œæ­£è´Ÿå·ï¼Œéžæ•°å­—å­—ç¬¦ æ•°æ®æº¢å‡ºï¼Œæ‰€ä»¥ä»Žåé¢è€ƒè™‘æ›´åŠ ç®€å•ä¸€äº›# åˆæ³•çš„è¾“å…¥åªæœ‰æ•°å­—å’Œç¬¦å·ä½ + å’Œ-def StrToInt(self, s): # write code here int_list=['0', '1', '2', '3', '4', '5', '6','7', '8', '9', '+', '-'] if s ==" ": return 0 sum1 =0 flag =1 # æ­£è´Ÿå· for string in s: if string not in int_list: return 0 if string =="+": flag =1 continue elif string =="-": flag = -1 continue else: sum1 =sum1 *10 +int_list.index(string) return sum1*flag æ¨¡æ‹Ÿé¢˜ï¼Œé‡ç‚¹åœ¨äºŽè€ƒè™‘å„ç§å„æ ·çš„æƒ…å†µã€‚éœ€è¦æœ‰ä¸€ä¸ªæ€»çš„ index åŽ»éåŽ†å­—ç¬¦ä¸²è¿›è¡Œé€ä¸ªçš„å¤„ç†ã€‚ é¦–å…ˆéœ€è¦å¤„ç†ç©ºæ ¼é—®é¢˜ æ­£è´Ÿå·çš„é—®é¢˜ å­—ç¬¦ä¸²çš„æ•°å­—è¿›è¡Œå¤„ç† 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;// å¤„ç†ç©ºæ ¼ï¼Œå¤„ç†æ­£è´Ÿå·ï¼Œå¤„ç†æ•°å­—å­—æ¯int str2int(string str)&#123; int k =0; while(k &lt; str.size() &amp;&amp; str[k] ==' ') k++; long long number =0; // è¿™ç§å¯¹äºŽ boolå€¼çš„åç§°çš„å®šä¹‰ bool is_minus =false; if(str[k] =='+') k ++; else if(str[k] =='-') k++, is_minus =true; for(; k&lt; str.size() &amp;&amp; str[k] &gt;'0' &amp;&amp; str[k] &lt; '9'; k++) &#123; number = number *10 + (str[k] -'0'); &#125; if(is_minus) number *= -1; if(number &gt; INT_MAX) return INT_MAX; else if(number &lt; INT_MIN) return INT_MIN; return (int)number;&#125;int main()&#123; string str; // è¿™ä¸ªè¯­å¥å¤„ç†ä¸€ä¸ª string çš„è¾“å…¥è¿˜æ˜¯ok çš„ getline(cin, str); cout&lt;&lt;str2int(str)&lt;&lt;endl; return 0;&#125; æ³¨æ„ä¸€ä¸‹ for å¾ªçŽ¯å’Œ whileå¾ªçŽ¯ä¸¤è€…çš„å·®å¼‚ï¼Œå°¤å…¶æ˜¯ for å¾ªçŽ¯ä¸­ ++i è¿™ä¸ªæ“ä½œæ˜¯ç‰¹åˆ«éœ€è¦æ³¨æ„çš„ã€‚å¦‚æžœæ˜¯æ¡ä»¶åˆ¤æ–­ï¼Œå»ºè®®ä½¿ç”¨ while ï¼Œå¦‚æžœæ˜¯æ•°ç»„çš„éåŽ†ï¼Œé‚£ä¹ˆæ˜¯å¯ä»¥ä½¿ç”¨for å¾ªçŽ¯ã€‚ 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;// å¤„ç†ç©ºæ ¼ï¼Œ å¤„ç†æ­£è´Ÿå·ï¼Œå¤„ç†string ç±»åž‹çš„æ•°å­—int str2int(string str)&#123; long long number =0; int k =0; for(; k&lt; str.size() &amp;&amp; str[k] ==' '; ) k ++; // ä½¿ç”¨ += ï¼Œ ++ è¿™ä¸ªéƒ½æ˜¯æ¯”è¾ƒæœ‰æ„æ€çš„äº‹æƒ… bool is_minus =false; if(str[k] =='-') is_minus =true, k++; else if(str[k] =='+' ) is_minus =false, k++; for(; k&lt; str.size() &amp;&amp; str[k] &gt;'0' &amp;&amp; str[k]&lt;'9' ; k++) &#123; number = (number *10 + (str[k] - '0')); &#125; if(is_minus) number *= -1; if(number &gt; INT_MAX) return INT_MAX; else if(number &lt; INT_MIN) return INT_MIN; return (int)number;&#125;int main()&#123; string str; getline(cin, str); cout &lt;&lt; str2int(str)&lt;&lt; endl; return 0;&#125; åœ¨ä¸€ä¸ªé•¿åº¦ä¸ºnçš„æ•°ç»„é‡Œçš„æ‰€æœ‰æ•°å­—éƒ½åœ¨0åˆ°n-1çš„èŒƒå›´å†…ã€‚ æ•°ç»„ä¸­æŸäº›æ•°å­—æ˜¯é‡å¤çš„ï¼Œä½†ä¸çŸ¥é“æœ‰å‡ ä¸ªæ•°å­—æ˜¯é‡å¤çš„ã€‚ä¹Ÿä¸çŸ¥é“æ¯ä¸ªæ•°å­—é‡å¤å‡ æ¬¡ã€‚è¯·æ‰¾å‡ºæ•°ç»„ä¸­ä»»æ„ä¸€ä¸ªé‡å¤çš„æ•°å­—ã€‚ ä¾‹å¦‚ï¼Œå¦‚æžœè¾“å…¥é•¿åº¦ä¸º7çš„æ•°ç»„**{2,3,1,0,2,5,3}ï¼Œé‚£ä¹ˆå¯¹åº”çš„è¾“å‡ºæ˜¯ç¬¬ä¸€ä¸ªé‡å¤çš„æ•°å­—2ã€‚ æ²¡æœ‰è¯´æ‰¾å‡ºæ‰€æœ‰é‡å¤çš„æ•°å­—ï¼Œåªæ˜¯è¯´æ‰¾å‡ºä»»æ„ä¸€ä¸ªé‡å¤çš„æ•°å­—ã€‚ä¸€ç§æ–¹æ³•å½“ç„¶æ˜¯ä½¿ç”¨dictionary çš„æ€æƒ³ï¼Œå¦‚æžœå·²ç»åœ¨dictionary ä¸­å­˜åœ¨ï¼Œé‚£ä¹ˆç›´æŽ¥è¾“å‡ºï¼›å¦åˆ™ç»§ç»­éåŽ†ã€‚è¿˜æœ‰ä¸€ç§æ–¹å¼ï¼Œæ˜¯è®­ç»ƒæ•°å€¼å’Œindex ä¹‹é—´çš„å…³ç³»ï¼Œå› ä¸ºæ•°å€¼æ˜¯åœ¨ 0åˆ°n-1 ä¹‹é—´ï¼Œé‚£ä¹ˆæ²¡æœ‰é‡å¤çš„æ—¶å€™ï¼Œindex çš„å€¼å°±æ˜¯æ•°å€¼çœŸå®žçš„å€¼ï¼Œæ‰€ä»¥å¯ä»¥è¿™æ ·è¿›è¡Œåˆ¤æ–­ã€‚ 123456789101112131415class Solution: # è¿™é‡Œè¦ç‰¹åˆ«æ³¨æ„~æ‰¾åˆ°ä»»æ„é‡å¤çš„ä¸€ä¸ªå€¼å¹¶èµ‹å€¼åˆ°duplication[0] # å‡½æ•°è¿”å›žTrue/False # ç¬¬äºŒç§æ–¹å¼ï¼Œå¦‚æžœè¿™ä¸ªæ˜¯æœ‰åºçš„ é‚£ä¹ˆ numbers[i] ==i è¿™ä¸ªæ˜¯æˆç«‹çš„ def duplicate(self, numbers, duplication): # write code here length =len(numbers) for i in range(length): while i != numbers[i]: if numbers[numbers[i]] == numbers[i]: duplication[0] = numbers[i] return True else: numbers[numbers[i]], numbers[i] = numbers[i], numbers[numbers[i]] return False æž„å»ºä¹˜ç§¯æ•°ç»„ ç»™å®šä¸€ä¸ªæ•°ç»„A[0,1,â€¦,n-1],è¯·æž„å»ºä¸€ä¸ªæ•°ç»„B[0,1,â€¦,n-1],å…¶ä¸­Bä¸­çš„å…ƒç´ B[i]=A[0]A[1]â€¦A[i-1]A[i+1]â€¦A[n-1]ã€‚ä¸èƒ½ä½¿ç”¨é™¤æ³•ã€‚ Tips: åˆ†æˆä¸Šä¸‹ä¸‰è§’å½¢è¿›è¡Œè®¡ç®—ï¼Œä¸èƒ½æ¯ä¸ªB[i] éƒ½è¿›è¡Œå•ç‹¬é‡å¤è®¡ç®—ã€‚ä¸‹ä¸‰è§’å½¢æ˜¯ä»Žä¸Šå¾€ä¸‹éåŽ†ï¼Œä¸Šä¸‰è§’å½¢æ˜¯ä»Žä¸‹å¾€ä¸ŠéåŽ†ã€‚ans å­˜å‚¨å„ä¸ªä¸åŒçš„ç»“æžœã€‚ åŠ ä¸Šé“¾æŽ¥ä¸­çš„å›¾åŽ»ç†è§£ä¸€ä¸‹è¿™ä¸ªè¿‡ç¨‹ã€‚ 12345678910111213141516171819class Solution: # æ€è·¯ï¼š è½¬æ¢æˆå›¾å½¢çš„å°±å®¹æ˜“æƒ³ä¸€äº›ï¼Œ https://blog.csdn.net/u010005281/article/details/80200398 # ä»£ç ï¼šhttps://blog.csdn.net/fuxuemingzhu/article/details/79718543 # A æ˜¯ä¸€ä¸ªlist ï¼Œåªæ˜¯è‡ªå·±æž„å»ºçš„æ˜¯ä¸€ä¸ªçŸ©é˜µ def multiply(self, A): # write code here ans =[] tmp =1 length =len(A) # å€¼å¾—æ˜¯ rows # é¦–å…ˆæ˜¯ä¸‹ä¸‰è§’å½¢ å„ä¸ªéƒ¨åˆ†çš„æ•°å€¼çš„ç›¸ä¹˜ï¼Œ ä»Žä¸Šå¾€ä¸‹éåŽ† for i in range(length): ans.append(tmp) tmp *= A[i] tmp =1 # ä¸Šä¸‰è§’å½¢ ä»Žä¸‹å¾€ä¸Šè¿›è¡ŒéåŽ† for i in range(length-1, -1, -1): ans[i] *= tmp tmp *= A[i] return ans è¿™ä¸ªé¢˜ç›®çš„é™åˆ¶æ¡ä»¶ã€‚ åªèƒ½å¼€è¾Ÿä¸€ä¸ªæ•°ç»„ç©ºé—´çš„é•¿åº¦ ä¸èƒ½ä½¿ç”¨é™¤æ³• ä»”ç»†è§‚å¯Ÿä¸¤ä¸ªfor å¾ªçŽ¯ï¼Œå¥½çš„ä»£ç å¯è¯»æ€§ä¹Ÿæ˜¯å¾ˆå¼ºçš„ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;// å¤„ç†ç©ºæ ¼ï¼Œ å¤„ç†æ­£è´Ÿå·ï¼Œå¤„ç†string ç±»åž‹çš„æ•°å­—const int N =100;vector&lt;int&gt; multiply(vector&lt;int&gt; arr, int n)&#123; vector&lt;int&gt; res(n); for(int i =0, p =1; i&lt; n; i++) &#123; res[i] =p; p *= arr[i]; &#125; for(int i =n-1, p =1; i&gt;=0; i--) &#123; res[i] =p * res[i]; p *= arr[i]; &#125; return res; &#125;int main()&#123; int n; vector&lt;int&gt; arr(N); cin&gt;&gt;n; for(int i =0; i&lt;n;i++) cin&gt;&gt; arr[i]; vector&lt;int&gt; res =multiply(arr, n); for(auto u: res) cout&lt;&lt; u&lt;&lt; " "; cout&lt;&lt; endl; return 0;&#125; åŠ æ·± å¯¹äºŽ â€œ~â€ è¿ç®—çš„ç†è§£ å’Œå¯¹äºŽ if åˆ¤æ–­çš„ç†è§£ã€‚å½“ if ä¸­æ¡ä»¶æ˜¯0 ï¼ˆå¯¹åº”bool ä¸­çš„falseï¼‰çš„æ—¶å€™ï¼Œé‚£ä¹ˆæ‰ä¼šä¸æ‰§è¡Œï¼Œå¦‚æžœæ˜¯ -1 é‚£ä¹ˆä¹Ÿæ˜¯å¯ä»¥æ‰§è¡Œçš„ã€‚ä½†æ˜¯è¿™é‡Œæ²¡æœ‰å¿…è¦å†™çš„é‚£ä¹ˆç®€æ´æ·±é‚ƒï¼Œå¯ä»¥ç®€å•ç‚¹å†™ã€‚ 12345678910int main()&#123; cout&lt;&lt; ~-1&lt;&lt; endl; cout&lt;&lt; ~0 &lt;&lt;endl; cout&lt;&lt; ~2 &lt;&lt;endl; if( -3) cout&lt;&lt; "niubi "&lt;&lt; endl; return 0;&#125; è¡¨ç¤ºæ•°å€¼çš„å­—ç¬¦ä¸² è¯·å®žçŽ°ä¸€ä¸ªå‡½æ•°ç”¨æ¥åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦è¡¨ç¤ºæ•°å€¼ï¼ˆåŒ…æ‹¬æ•´æ•°å’Œå°æ•°ï¼‰ã€‚ä¾‹å¦‚ï¼Œå­—ç¬¦ä¸²â€+100â€,â€5e2â€,â€-123â€,â€3.1416â€å’Œâ€-1E-16â€éƒ½è¡¨ç¤ºæ•°å€¼ã€‚ ä½†æ˜¯â€12eâ€,â€1a3.14â€,â€1.2.3â€,â€+-5â€å’Œâ€12e+4.3â€éƒ½ä¸æ˜¯ã€‚ è¿™ä¸ªæ˜¯åˆ¤æ–­æ˜¯å¦çš„é—®é¢˜ï¼Œè€Œä¸æ˜¯çœŸæ­£è½¬æ¢æˆ intçš„è¿‡ç¨‹ï¼Œæ‰€ä»¥å­å‡½æ•°æ˜¯è¿”å›žçš„true or falseï¼Œè€Œä¸æ˜¯çœŸæ­£çš„æ•°å€¼ã€‚è¿™ä¸ªç›¸å¯¹äºŽå‰é¢é‚£ä¸ªstring2int å°±æ¯”è¾ƒéš¾ä¸€ç‚¹äº†ï¼Œå…³é”®æ˜¯åˆ¤æ–­ â€œeâ€ çš„å­˜åœ¨ä¸Žå¦ã€‚è¿™ç§ str2int or allownum æ˜¯éžå¸¸å¸¸è§çš„åˆå§‹åŒ–ï¼Œæ˜¯å¿…é¡»è¦å­¦ä¼šã€‚ è¿™ä¸ªä¸æ˜¯ä¸€é“å¾ˆå¥½çš„ç®—æ³•é¢˜ï¼Œæ˜¯å„ç§æƒ…å†µçš„åµŒå¥—çš„ åˆ†ç±»è®¨è®ºã€‚æ‰€ä»¥æš‚æ—¶ä¸è€ƒè™‘ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839class Solution: # så­—ç¬¦ä¸² # ç¬¬ä¸€ç§æ–¹æ³•æ˜¯ float()å¼ºè½¬ï¼Œä¸€ç§æ˜¯ re æ­£åˆ™è¡¨è¾¾å¼åŒ¹é… æœ€åŽä¸€ç§é€»è¾‘åˆ¤æ–­ä¹‹ç±»çš„ # ä»¥ e ä¸ºåˆ†å‰²ç¬¦ï¼Œåˆ†æˆfront and behind ä¸¤éƒ¨åˆ†ï¼Œbehind é•¿åº¦ä¸èƒ½ä¸º0 æˆ–è€…å‡ºçŽ° . # digitçš„åˆ¤æ–­ï¼Œ+- åªèƒ½å‡ºçŽ°åœ¨é¦–ä½ï¼Œ . åªèƒ½å‡ºçŽ°ä¸€æ¬¡ """ https://github.com/leeguandong/Interview-code-practice-python/blob/master/%E5%89%91%E6%8C%87offer/%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.py """ def isNumeric(self, s): if not s or len(s) == 0: return s s = [i.lower() for i in s] if 'e' in s: index = s.index('e') front = s[:index] behind = s[index + 1:] if len(behind) == 0 or '.' in behind: return False f = self.Digit(front) b = self.Digit(behind) return f and b else: isNum = self.Digit(s) return isNum def Digit(self, s): dotNum = 0 allowNum = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', '+', '-'] for i in range(len(s)): if s[i] not in allowNum: return False if s[i] == '.': dotNum += 1 if s[i] in '+-' and i != 0: return False if dotNum &gt; 1: return False return True å­—ç¬¦æµä¸­ç¬¬ä¸€ä¸ªä¸é‡å¤çš„å­—ç¬¦ è¯·å®žçŽ°ä¸€ä¸ªå‡½æ•°ç”¨æ¥æ‰¾å‡ºå­—ç¬¦æµä¸­ç¬¬ä¸€ä¸ªåªå‡ºçŽ°ä¸€æ¬¡çš„å­—ç¬¦ã€‚ä¾‹å¦‚ï¼Œå½“ä»Žå­—ç¬¦æµä¸­åªè¯»å‡ºå‰ä¸¤ä¸ªå­—ç¬¦â€goâ€æ—¶ï¼Œç¬¬ä¸€ä¸ªåªå‡ºçŽ°ä¸€æ¬¡çš„å­—ç¬¦æ˜¯â€gâ€ã€‚å½“ä»Žè¯¥å­—ç¬¦æµä¸­è¯»å‡ºå‰å…­ä¸ªå­—ç¬¦â€œgoogleâ€æ—¶ï¼Œç¬¬ä¸€ä¸ªåªå‡ºçŽ°ä¸€æ¬¡çš„å­—ç¬¦æ˜¯â€lâ€ã€‚ æµæ“ä½œä¸€èˆ¬åœ¨ç¬”è¯•ä¸­ä¸ä¼šè€ƒå¯Ÿã€‚ 12345678910111213141516171819class Solution: # è¿”å›žå¯¹åº”char # è¿™ä¸ªæ²¡æœ‰äº†dict é‚£ä¹ˆä¾èµ–äºŽ count å‡½æ•° # ä¸»è¦å·®åˆ«åœ¨äºŽæœ‰äº†ä¸€ä¸ª å­—ç¬¦æµï¼Œæ˜¯åŠ¨æ€çš„ï¼Œæ‰€ä»¥éœ€è¦æœ‰ä¸€ä¸ªå¤§çš„å­˜å‚¨çš„list def __init__(self): self.list1 =[] def FirstAppearingOnce(self): # write code here for string in self.list1: if self.list1.count(string) == 1: return string return "#" def Insert(self, char): # write code here self.list1.append(char) å¯¹äºŽ $O(n^2)$ ç®—æ³•å¤æ‚åº¦ï¼Œä¼˜åŒ–æˆ $O(n)$ï¼Œ ä¸€èˆ¬åœ¨é¢è¯•çš„è¿‡ç¨‹ä¸­ï¼Œæœ‰ä¸¤ç§ä¼˜åŒ–ç®—æ³•ï¼Œä¸€ç§æ˜¯åŒæŒ‡é’ˆç®—æ³•ï¼Œä¸€ç§æ˜¯å•è°ƒé˜Ÿåˆ—ç®—æ³•ã€‚ c++ ä¸­é˜Ÿåˆ—æ“ä½œçš„è®¿é—®ï¼š front() è¿”å›žç¬¬ä¸€ä¸ªå…ƒç´  (è®¿é—®)pop() åˆ é™¤ç¬¬ä¸€ä¸ªå…ƒç´ push() åœ¨æœ«å°¾åŠ å…¥ä¸€ä¸ªå…ƒç´ back() è¿”å›žæœ€åŽä¸€ä¸ªå…ƒç´  ï¼ˆè®¿é—®ï¼‰empty() å¦‚æžœé˜Ÿåˆ—ç©ºåˆ™è¿”å›žçœŸsize() è¿”å›žé˜Ÿåˆ—ä¸­å…ƒç´ çš„ä¸ªæ•° c++ æ ˆstack çš„æ“ä½œè®¿é—® top() è¿”å›žæ ˆé¡¶å…ƒç´ ï¼Œä¸åˆ é™¤ï¼ˆèŽ·å–ï¼‰pop() ç§»é™¤æ ˆé¡¶å…ƒç´  ï¼ˆåˆ é™¤ï¼‰push() åœ¨æ ˆé¡¶å¢žåŠ å…ƒç´  ï¼ˆå¢žåŠ ï¼‰empty() å †æ ˆä¸ºç©ºåˆ™è¿”å›žçœŸsize() è¿”å›žæ ˆä¸­å…ƒç´ æ•°ç›® 1234567891011121314151617181920212223242526272829class Solution&#123;public: //Insert one char from stringstream // åŒæŒ‡é’ˆç®—æ³•ï¼Œä½†åœ¨å®žçŽ°çš„æ—¶å€™ä¸ä¸€å®šé€‚ç”¨åŒæŒ‡é’ˆ // ä½¿ç”¨é˜Ÿåˆ—ï¼Œå¯ä»¥èŠ‚çœå†…å­˜ unordered_map&lt;char, int&gt; dic; // è¿™ä¸ªç»´æŠ¤çš„æ˜¯ä¸€ä¸ªdictionary queue&lt;char&gt; q; // è¿™ä¸ªç»´æŒçš„æ˜¯ä¸€ä¸ª first appearing once çš„é˜Ÿåˆ— void Insert(char ch) &#123; if( ++dic[ch] &gt;1) &#123; while(q.size() &amp;&amp; dic[q.front()] &gt;1) q.pop(); &#125; else q.push(ch); &#125; //return the first appearence once char in current stringstream char FirstAppearingOnce() &#123; if(q.empty()) return '#'; return q.front(); &#125;&#125;; KMP ç®—æ³•å­—ç¬¦ä¸²åŒ¹é…ç®—æ³• ä¸€èˆ¬çš„å­—ç¬¦ä¸²åŒ¹é…çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(m *n)$ï¼Œ KMP ç®—æ³•èƒ½å¤Ÿè¾¾åˆ° $O(m +n)$ï¼Œ å…¶ä¸­ $m$ å’Œ$n$ åˆ†åˆ«å¯¹åº”çš„æ˜¯å­—ç¬¦ä¸²çš„é•¿åº¦ã€‚KMP ç®—æ³•æ€æƒ³ï¼Œè®¾æ³•åˆ©ç”¨ä¹‹å‰æ¯”è¾ƒè¿‡çš„å­ä¸²ä¿¡æ¯ï¼Œå®žçŽ°è·¨è¶Šè·³è½¬ï¼Œè¿™æ ·å°±æé«˜äº†æ•ˆçŽ‡ã€‚å¯ä»¥ç›´æŽ¥å¤„ç†æ¨¡å¼ä¸²ï¼Œè€Œä¸ç”¨å¤„ç†æœç´¢è¯å­—ç¬¦ä¸²ã€‚å¦‚ä½•åˆ©ç”¨ä¹‹å‰çš„ç»“æžœï¼Œé‚£ä¹ˆè¿™ä¸ªå°±ä½¿ç”¨åˆ°äº†next æ•°ç»„ã€‚next æ•°ç»„å°±æ˜¯å­—ç¬¦ä¸²çš„å‰åŽç¼€çš„è®¡ç®—ã€‚å‰ç¼€æ˜¯é™¤äº†æœ€åŽä¸€ä¸ªå­—æ¯çš„â€å‰ç¼€â€œï¼Œ åŽç¼€æ˜¯é™¤äº†ç¬¬ä¸€ä¸ªå­—æ¯çš„åŽç¼€ã€‚é¦–å…ˆè®¡ç®—æ¨¡å¼ä¸²æ‰€æœ‰å­ä¸²ä¸­çš„å‰åŽç¼€ï¼Œæ‰¾å‡ºå…±æœ‰çš„å­ä¸²ä¸­æœ€é•¿çš„é‚£ä¸ªã€‚ è¿™é‡Œç¼ºå°‘äº†kmp ç®—æ³•çš„å®žçŽ°ã€‚ç­‰å­¦å®Œå­—ç¬¦ä¸²å¤„ç†ä¹‹åŽè¿›è¡Œã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Back to my blog]]></title>
    <url>%2F2019%2F03%2F07%2FBack-to-my-blog%2F</url>
    <content type="text"><![CDATA[ç›´åˆ°æŸä¸€å¤©å‘çŽ°ä¸ªäººç½‘ç«™ä¸­çš„å›¾ç‰‡éƒ½æ˜¾ç¤ºä¸å‡ºæ¥äº†ï¼ŒæŸ¥äº†ä¸€ä¸‹æ‰å‘çŽ°ä¹‹å‰çš„å›¾åºŠä¸èƒ½ç”¨äº†ï¼ˆç‚¹åæ‰¹è¯„ä¸ƒç‰›ï¼‰ï¼Œæžœæ–­å¼ƒä¹‹ï¼Œæ¢äº†ä¸ªå¤§åŽ‚å­äº§å“ã€‚è¯æ˜Žä¸€ä¸‹å›¾ç‰‡æ˜¯èƒ½å‡ºæ¥çš„ã€‚psï¼šä¹‹å‰çš„å›¾ç‰‡æœ‰æ—¶é—´å†æ•´ç†åˆ°æ–°çš„å¹³å°ä¸Šã€‚]]></content>
      <categories>
        <category>NOT_FOR_YOU</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode tree]]></title>
    <url>%2F2019%2F03%2F01%2Fleetcode-tree%2F</url>
    <content type="text"><![CDATA[åˆ¤æ–­æ˜¯ä¸æ˜¯ä¸€ä¸ªäºŒå‰æœç´¢æ ‘ï¼Ÿ è§£é¢˜æ€è·¯æœ‰äºŒã€‚ä¸€æ–¹é¢æ˜¯å¯ä»¥é€’å½’çš„è¿›è¡Œåˆ¤æ–­ï¼Œå¦‚æžœæ ¹èŠ‚ç‚¹å¤§äºŽï¼ˆä¸¥æ ¼ï¼‰å·¦å­æ ‘ï¼Œå°äºŽå³å­æ ‘ã€‚é‚£ä¹ˆæ˜¯ä¸€ä¸ªäºŒå‰æœç´¢æ ‘ã€‚å¦ä¸€æ–¹å¯ä»¥ä½¿ç”¨åŒºé—´çš„æ€æƒ³ã€‚å°±æ˜¯ä¸‹é¢çš„è§£æ³•ã€‚ 1234567891011121314151617181920212223/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // åˆ¤æ–­æ˜¯å¦æ˜¯äºŒå‰æœç´¢æ ‘ï¼Œ å·¦å­æ ‘&lt; æ ¹èŠ‚ç‚¹&lt; å³å­æ ‘ // ä½¿ç”¨åŒºé—´çš„æ¦‚å¿µï¼Œæ ¹èŠ‚ç‚¹ [INT_MIN, INT_MAX] bool isValidBST(TreeNode* root) &#123; return dfs(root, INT_MIN, INT_MAX); &#125; bool dfs(TreeNode * root, long long minv, long long maxv) &#123; if(!root) return true; if(root-&gt; val &lt; minv || root-&gt;val &gt; maxv) return false; return dfs(root-&gt; left, minv, root-&gt;val- 1ll) &amp;&amp; dfs(root-&gt; right, root-&gt;val+1ll, maxv); &#125;&#125;; Binary Tree Inorder Traversal ä¸­åºéžé€’å½’éåŽ†ã€‚ a. å°†æ•´ä¸ªæ ‘çš„æœ€å·¦è¾¹ä¸€æ¡é“¾åŽ‹å…¥æ ˆä¸­b. æ¯æ¬¡å–å‡ºæ ˆé¡¶å…ƒç´ ï¼Œå¦‚æžœæœ‰å³å­æ ‘ï¼Œé‚£ä¹ˆå°†å³å­æ ‘åŽ‹å…¥æ ˆä¸­ 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode *&gt; stk; auto p =root; // è¿™ä¸ªæ¡ä»¶ä¹Ÿæ˜¯æ¯”è¾ƒniceçš„ï¼Œ p || stk.size() while( p || stk.size()) &#123; while(p ) &#123; stk.push(p); p =p-&gt; left; &#125; // è¿™ä¸ªp æ˜¯ä¸€ä¸ªéåŽ†æŒ‡é’ˆï¼Œç±»ä¼¼iï¼Œæ˜¯å¯ä»¥é‡å¤çš„èµ‹å€¼çš„ p = stk.top(); stk.pop(); //auto tmp =stk.top(); //stk.pop(); res.push_back(p-&gt; val); // ç„¶åŽå°±è½¬å‘äº†å³å­æ ‘ p =p-&gt;right; &#125; return res; &#125;&#125;; Symmetric Tree é€’å½’åˆ¤æ–­æ˜¯å¦æ˜¯ symmetric treeã€‚ è¿™ä¸ªè¿˜æ˜¯éžå¸¸niceçš„ã€‚ è¿™ç§æ€è·¯æ¯”è¾ƒç®€å•çš„ï¼Œæ ¹èŠ‚ç‚¹ä¸ç”¨æ¯”è¾ƒï¼Œç„¶åŽå·¦å³å­æ ‘ï¼Œå·¦å­æ ‘çš„å·¦ç»“ç‚¹å’Œå³å­æ ‘çš„å³èŠ‚ç‚¹ï¼Œå·¦å­æ ‘çš„å³èŠ‚ç‚¹å’Œå³å­æ ‘çš„å·¦ç»“ç‚¹ã€‚ a. ä¸¤ä¸ªæ ¹èŠ‚ç‚¹çš„å€¼è¦ç›¸ç­‰b. å·¦è¾¹çš„å·¦å­æ ‘å’Œå³è¾¹çš„å³å­æ ‘å¯¹ç§°c. å·¦è¾¹çš„å³å­æ ‘å’Œå³è¾¹çš„å·¦å­æ ‘å¯¹ç§° 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // å¯¹ç§°ï¼Œ å·¦å­æ ‘çš„å·¦ç»“ç‚¹ å’Œå³å­æ ‘çš„å³èŠ‚ç‚¹ï¼› å·¦å­æ ‘çš„å³èŠ‚ç‚¹å’Œå³å­æ ‘çš„å·¦ç»“ç‚¹ // bool isSymmetric(TreeNode* root) &#123; // å¦‚æžœä¸ºç©º é‚£ä¹ˆ return true if (! root) return true; return dfs(root-&gt; left, root -&gt; right); &#125; bool dfs(TreeNode * left, TreeNode * right) &#123; if(! left || ! right) return !left &amp;&amp; ! right; // åªæœ‰ä¸¤è€…éƒ½ä¸ºç©ºï¼Œé‚£ä¹ˆæ‰æ˜¯true if(left-&gt; val != right -&gt; val) return false; return dfs(left-&gt; left, right -&gt; right) &amp;&amp; dfs(left-&gt; right, right -&gt; left); &#125;&#125;; é‡å»ºäºŒå‰æ ‘ æ ¹æ®å‰åºéåŽ†å’Œä¸­åºéåŽ†é‡å¡‘äºŒå‰æ ‘ã€‚åœ¨ä¸€ä¸ªæ— åºçš„list ä¸­åŽ»æŸ¥æ‰¾äºŒå‰æ ‘ï¼Œæ—¶é—´æ˜¯ $O(n)$ï¼Œè¿™ä¸ªæ˜¯å¯ä»¥ä½¿ç”¨hash ä¼˜åŒ–æˆ $O(1)$ã€‚é‡ç‚¹æ˜¯å¯ä»¥é€šè¿‡é•¿åº¦è¿›è¡Œåˆ’åˆ† å·¦å­æ ‘åºåˆ—å’Œå³å­æ ‘åºåˆ—ã€‚ 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: unordered_map&lt;int, int&gt; hash; TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; int n =preorder.size(); for(int i =0; i&lt; n; i++) hash[inorder[i]] =i; return dfs(preorder, inorder, 0, n -1, 0, n -1); &#125; TreeNode * dfs(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt; &amp; inorder, int pl, int pr, int il, int ir) &#123; // dfs ä¸€å®šæ˜¯æœ‰return çš„ if(pl &gt; pr) return NULL ; int val =preorder[pl]; int index =hash[val]; int len =index -il; TreeNode* root =new TreeNode(val); root -&gt; left =dfs(preorder, inorder, pl+1, pl +len, il, index -1); root -&gt; right =dfs(preorder, inorder, pl+len+1, pr, index +1, ir); return root; &#125; &#125;; å±‚åºéåŽ†ï¼Œéžé€’å½’å†™æ³•ã€‚ 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // å±‚æ¬¡éåŽ†ï¼Œå…ˆè¿›å…ˆå‡ºï¼Œé˜Ÿåˆ—çš„ä¸œè¥¿ queue&lt;TreeNode *&gt; q; vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if (!root) return res; q.push(root); while(q.size()) &#123; vector&lt;int&gt; level; int n = q.size(); // è¿™ä¸ªæ˜¯éœ€è¦åˆ’åˆ†æˆä¸€å±‚çš„ for(int i =0; i&lt; n; i++) &#123; auto tmp =q.front(); q.pop(); level.push_back(tmp-&gt;val ); if(tmp -&gt; left) q.push(tmp -&gt; left); if(tmp -&gt; right) q.push(tmp -&gt; right); &#125; res.push_back(level); &#125; return res; &#125;&#125;; lowest common ancestor of a binary tree äºŒå‰æ ‘çš„æœ€å°å…¬å…±çˆ¶èŠ‚ç‚¹ã€‚ 12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // æœ€çŸ­å…¬å…±ç¥–å…ˆ TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(! root || p ==root || q ==root) return root; // å¦åˆ™å°±éœ€è¦è¿›è¡Œå¯»æ‰¾ auto left =lowestCommonAncestor(root -&gt;left, p, q); auto right =lowestCommonAncestor(root -&gt; right, p, q); if( !left) return right; if(! right) return left; return root; &#125;&#125;; serialize and deserialize binary tree ä¸€èˆ¬æ¥è¯´ï¼Œå•ç‹¬çš„å‰åºéåŽ†æ˜¯ä¸èƒ½å”¯ä¸€ç¡®å®šä¸€ä¸ªæ ‘çš„ç»“æž„ã€‚ï¼ˆä½¿ç”¨å‰åºéåŽ†å’Œä¸­åºéåŽ†æ‰èƒ½ç¡®å®šä¸€ä¸ªäºŒå‰æ ‘çš„ç»“æž„ï¼Œå¦‚ä¹‹å‰çš„é¢˜ç›®ï¼‰ä½†æ˜¯è¿™é‡Œå¯ä»¥å”¯ä¸€ç¡®å®šï¼Œå› ä¸ºå‰åºéåŽ†ä¸­æŠŠç©ºèŠ‚ç‚¹åŠ å…¥äº†æ•´ä¸ªåºåˆ—ä¸­ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Codec &#123;public: // ç¼–ç çš„æ ¼å¼ 1,2,#,#, // Encodes a tree to a single string. // ä½¿ç”¨string çš„åœ°å€è¡¨ç¤º exactly çš„é‚£ç§ç»“æžœ string serialize(TreeNode* root) &#123; string res; dfs1(root, res); return res; &#125; void dfs1(TreeNode * root, string &amp; res) &#123; if(! root) &#123; res +="#,"; return; &#125; res += to_string(root-&gt;val)+','; dfs1(root-&gt;left, res); dfs1(root-&gt;right, res); &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; int u=0 ; return dfs2(data, u); &#125; TreeNode* dfs2(string &amp;data, int &amp; u) &#123; if(data[u] =='#') &#123; u +=2; // ä¸€ä¸ª # ä¸€ä¸ª, return NULL ; &#125; bool is_minus =false; if(data[u] =='-') &#123; is_minus =true; u ++; &#125; int val =0; while(data[u] != ',') &#123; val = val *10 +data[u] -'0'; u ++; &#125; u ++; if(is_minus) val =-val; auto root =new TreeNode(val); root-&gt;left =dfs2(data, u); root -&gt;right =dfs2(data, u); return root; &#125;&#125;;// Your Codec object will be instantiated and called as such:// Codec codec;// codec.deserialize(codec.serialize(root)); diameter of binary tree å…ˆæ˜¯æžšä¸¾èŠ‚ç‚¹ï¼Œç„¶åŽæ±‚è§£å·¦å³å­æ ‘æ·±åº¦ä¹‹å’Œã€‚å› ä¸ºå·¦å³å­æ ‘æ˜¯æ²¡æœ‰è”ç³»çš„ï¼Œæ˜¯å¯ä»¥å•ç‹¬æ±‚è§£å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦ã€‚ï¼ˆ å’Œä¸‹ä¸€é“é¢˜ç›®ç›¸æ¯”ï¼Œè¿™ä¸ªæ‰€æœ‰çš„æƒé‡éƒ½æ˜¯ 1) æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n)$ï¼Œ å› ä¸ºè¿™ä¸ªä¸€å®šæ˜¯ä»Žæ ¹èŠ‚ç‚¹å‡ºå‘ çš„ã€‚ 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // è¿™ä¸ªé¢˜ç›®å’Œæœ€é•¿è·¯å¾„ä¸ä¸€æ ·ï¼Œåœ¨äºŽè¿™ä¸ªæ˜¯æ±‚è§£è¾¹çš„é•¿åº¦ï¼Œè€Œä¸æ˜¯ç»“ç‚¹çš„ä¸ªæ•° // æ‰€ä»¥æœ€é•¿çš„æ˜¯ä¸€å®šæ˜¯ä»Žæ ¹èŠ‚ç‚¹å‡ºå‘çš„ï¼Œ ç„¶åŽdfsè¿›è¡Œ // é•¿åº¦æ˜¯ left + right // æ—¶é—´å¤æ‚åº¦æ˜¯ O(n) int res =0; int diameterOfBinaryTree(TreeNode* root) &#123; dfs(root); return res; &#125; // è¿™ä¸ªä¸æ˜¯dfs ï¼Œè¿™ä¸ªæ˜¯ä»Žrootå‘ä¸‹èµ°çš„æœ€å¤§çš„è·¯å¾„ int dfs(TreeNode * root) &#123; if( !root) return 0; auto left =dfs(root -&gt; left); auto right =dfs( root -&gt; right); res =max(res, left +right); return max(left, right) +1; &#125; &#125;; binary tree maximum path sum è¿™ä¸ªæƒé‡æœ‰æ­£æœ‰è´Ÿã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ $O( n^2)$ï¼Œ é¦–å…ˆæžšä¸¾çš„æ˜¯ç‚¹ $O(n)$ ï¼Œç„¶åŽæ¯ä¸ªç‚¹ä¸Šè®¡ç®—ï¼Œ é‚£ä¹ˆä¹Ÿæ˜¯ $O(n)$ï¼Œ æœ€åŽçš„ç»“æžœæ˜¯ $O(n ^2)$ã€‚è¿™é‡Œå®žé™…ä¸Šæ˜¯æœ‰ä¸‰ç§è·¯å¾„çš„ï¼ša. root -&gt; val + Lb. root-&gt;val + Rc. root -&gt;val æ‰€ä»¥çœ‹ä¸€ä¸‹æœ€åŽæ˜¯ä¸‰ç§é€‰æ‹©çš„. 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // æƒé‡å¯ä»¥çœ‹æˆ root -&gt;val int res =INT_MIN; int maxPathSum(TreeNode* root) &#123; dfs(root); return res; &#125; // ä»Žæ ¹èŠ‚ç‚¹éåŽ† int dfs(TreeNode* root) &#123; if(! root) return 0; // å·¦å³å­æ ‘çš„æœ€å¤§å€¼ int left =dfs(root -&gt; left); int right =dfs(root -&gt; right); res =max(res, left +right + root -&gt;val); // è¿”å›žå½“å‰èŠ‚ç‚¹çš„æœ€å¤§å€¼ return max(0, max(left, right) + root -&gt; val); &#125;&#125;; binary search tree iterator å…¶ä¸­çš„ average æ˜¯å‡æ‘Šçš„æ„æ€ï¼Œ $O(n) $ é™¤ä»¥ $n$ é‚£ä¹ˆæœ€åŽçš„ç»“æžœæ˜¯ $O(1)$ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class BSTIterator &#123;public: // è¿­ä»£å™¨ å°±æ˜¯æœ‰next å‡½æ•°ï¼Œæ¯æ¬¡éƒ½æ˜¯å¯ä»¥å¾—åˆ°ä¸‹ä¸€ä¸ªç»“ç‚¹ // è¿™é‡Œå› ä¸ºé™åˆ¶ O(h) ç©ºé—´ï¼Œä½¿ç”¨æ ˆè¿›è¡Œä¸­åºéåŽ†çš„ï¼ˆä¸èƒ½ä½¿ç”¨ vectorï¼Œå› ä¸ºé‚£æ ·æ˜¯ O(n), n è¡¨ç¤ºå…¨éƒ¨ç»“ç‚¹çš„ä¸ªæ•°ï¼‰ // ä½¿ç”¨æ ˆä¸­åºéåŽ†ï¼Œå°±æ˜¯æ¯æ¬¡æŠŠ ç»“ç‚¹çš„å·¦å­æ ‘å…¨éƒ¨æ”¾åˆ°é‡Œé¢ å·¦ä¸­å³éåŽ†æ–¹å¼ï¼Œ stack&lt;TreeNode*&gt; stk; BSTIterator(TreeNode* root) &#123; while(root) &#123; stk.push(root); root = root-&gt;left; &#125; &#125; /** @return the next smallest number */ int next() &#123; TreeNode* p =stk.top(); stk.pop(); int res =p -&gt;val ; p =p-&gt;right; while(p) &#123; stk.push(p); p =p -&gt;left; &#125; return res; &#125; /** @return whether we have a next smallest number */ bool hasNext() &#123; return ! stk.empty(); &#125;&#125;;/** * Your BSTIterator object will be instantiated and called as such: * BSTIterator* obj = new BSTIterator(root); * int param_1 = obj-&gt;next(); * bool param_2 = obj-&gt;hasNext(); */]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux commands]]></title>
    <url>%2F2019%2F02%2F18%2Flinux-commands%2F</url>
    <content type="text"><![CDATA[ä»‹ç»linux ä¸­å¸¸è§çš„å‘½ä»¤ å’Œgithub ä¸­å¸¸ç”¨çš„å‘½ä»¤ Linux å¸¸è§å‘½ä»¤awkã€grepã€sedæ˜¯linuxæ“ä½œæ–‡æœ¬çš„ä¸‰å¤§åˆ©å™¨ï¼Œä¹Ÿæ˜¯å¿…é¡»æŽŒæ¡çš„linuxå‘½ä»¤ä¹‹ä¸€ã€‚ä¸‰è€…çš„åŠŸèƒ½éƒ½æ˜¯å¤„ç†æ–‡æœ¬ï¼Œä½†ä¾§é‡ç‚¹å„ä¸ç›¸åŒï¼Œå…¶ä¸­å±žawkåŠŸèƒ½æœ€å¼ºå¤§ï¼Œä½†ä¹Ÿæœ€å¤æ‚ï¼Œawkæ›´é€‚åˆæ ¼å¼åŒ–æ–‡æœ¬ï¼Œå¯¹æ–‡æœ¬è¿›è¡Œè¾ƒå¤æ‚æ ¼å¼å¤„ç†ã€‚grepæ›´é€‚åˆå•çº¯çš„æŸ¥æ‰¾æˆ–åŒ¹é…æ–‡æœ¬ï¼Œsedæ›´é€‚åˆç¼–è¾‘åŒ¹é…åˆ°çš„æ–‡æœ¬ã€‚ awk å–åˆ—æ•°æ®ä¹‹æ‰€ä»¥å«AWKæ˜¯å› ä¸ºå…¶å–äº†ä¸‰ä½åˆ›å§‹äºº Alfred Ahoï¼ŒPeter Weinberger, å’Œ Brian Kernighan çš„Family Nameçš„é¦–å­—ç¬¦ã€‚AWKæ˜¯ä¸€ç§å¤„ç†æ–‡æœ¬æ–‡ä»¶çš„è¯­è¨€ï¼Œæ˜¯ä¸€ä¸ªå¼ºå¤§çš„æ–‡æœ¬åˆ†æžå·¥å…·ã€‚ç‰¹ç‚¹æ˜¯å¤„ç†çµæ´»ï¼ŒåŠŸèƒ½å¼ºå¤§ã€‚å¯å®žçŽ°ç»Ÿè®¡ã€åˆ¶è¡¨ä»¥åŠå…¶ä»–åŠŸèƒ½ã€‚ awk åŸºæœ¬è¯­æ³•ï¼š1awk &apos;BEGIN&#123;&#125; &#123;command&#125; END&#123;&#125;&apos; filename awk æ˜¯é€è¡Œå¤„ç†æ–‡æœ¬å†…å®¹çš„ï¼›BEGIN{} æ˜¯åˆè¯†åŒ–ä»£ç å—ï¼Œåœ¨å¤„ç†æ–‡ä»¶ç¬¬ä¸€è¡Œå†…å®¹ä¹‹å‰ï¼Œå®šä¹‰ä¸€äº›å˜é‡ï¼›{command} ä¸ºä¸€äº›å‘½ä»¤ï¼Œå¯¹æ–‡ä»¶å†…å®¹çš„æ¯ä¸€è¡Œè¿›è¡Œç›¸åº”åœ°å¤„ç†ï¼›END{} ä¸ºç»“æŸä»£ç å—ï¼Œåœ¨ {command}è¿è¡Œç»“æŸåŽæ‰§è¡Œã€‚ æ ¼å¼1234å‘½ä»¤è¡Œæ ¼å¼awk [options] &apos;command&apos; file(s)è„šæœ¬æ ¼å¼awk -f awk-script-file file(s) å¸¸ç”¨å†…ç½®å‚æ•° 12345$0ï¼Œ$1ï¼Œ$2... è¡¨ç¤ºæ•´ä¸ªå½“å‰è¡Œ$1 æ¯è¡Œç¬¬ä¸€ä¸ªå­—æ®µNF å­—æ®µæ•°é‡å˜é‡NR æ¯è¡Œçš„è®°å½•å·ï¼Œå¤šæ–‡ä»¶è®°å½•é€’å¢žFILENAME æ–‡ä»¶å awk -Fâ€™\tâ€™ â€˜{print $1;}â€™ all-test.txt &gt; all_query.inc AWKæ˜¯ä¸€ç§å¤„ç†æ–‡æœ¬æ–‡ä»¶çš„è¯­è¨€ï¼Œæ˜¯ä¸€ä¸ªå¼ºå¤§çš„æ–‡æœ¬åˆ†æžå·¥å…·ã€‚ä¹‹æ‰€ä»¥å«AWKæ˜¯å› ä¸ºå…¶å–äº†ä¸‰ä½åˆ›å§‹äºº Alfred Ahoï¼ŒPeter Weinberger, å’Œ Brian Kernighan çš„ Family Name çš„é¦–å­—ç¬¦ã€‚ awk éžå¸¸æ“…é•¿å¤„ç†ç»“æž„åŒ–æ•°æ®å’Œç”Ÿæˆè¡¨å•.å’Œ sed å’Œ grep å¾ˆç›¸ä¼¼.ç”±äºŽ awk å…·å¤‡å„ç§åŠå“¦å•Šæœ¬è¯­è¨€çš„ç‰¹ç‚¹,æ‰€ä»¥å¯ä»¥æŠŠå®ƒçœ‹åšæ˜¯ä¸€ç§è„šæœ¬è¯­è¨€. è¯­æ³•ï¼ˆæœ‰ä¸‰ç§æ–¹å¼ï¼‰ ç¬¬ä¸€ç§æ–¹å¼: 1awk [-F åˆ†éš”ç¬¦] â€˜commandsâ€™ input-file(s) åœ¨ awk ä¸­é»˜è®¤ä½¿ç”¨ç©ºæ ¼é—´éš”ï¼› å¦‚æžœæ–‡ä»¶ä¸­ä½¿ç”¨å†’å·ä½œä¸ºåˆ†éš”ç¬¦ï¼Œé‚£ä¹ˆå¿…é¡»ä½¿ç”¨ -F é€‰é¡¹:1awk -F : &apos;commands&apos; input-file ç¬¬äºŒç§æ–¹å¼ å°†æ‰€æœ‰ awk å‘½ä»¤æ’å…¥ä¸€ä¸ªå•ç‹¬æ–‡ä»¶ï¼Œç„¶åŽè°ƒç”¨1awk -f awk-script-file input-file å¸¸è§çš„æ¡ˆä¾‹å­¦ä¹  1234567891011121314151617181920ç»Ÿè®¡/etc/passwd:æ–‡ä»¶åï¼Œæ¯è¡Œçš„è¡Œå·ï¼Œæ¯è¡Œçš„åˆ—æ•°ï¼Œå¯¹åº”çš„å®Œæ•´è¡Œå†…å®¹:awk -F &apos;:&apos; &apos;&#123;print &quot;filename:&quot; FILENAME &quot;,linenumber:&quot; NR &quot;,columns:&quot; NF &quot;,linecontent:&quot;$0&#125;&apos; /etc/passwdé™¤äº† awk çš„å†…ç½®å˜é‡,awk è¿˜å¯ä»¥è‡ªå®šä¹‰å˜é‡.ä¾‹å¦‚:ç»Ÿè®¡/etc/passwd çš„è¡Œæ•°:awk &apos;&#123;count++&#125;END&#123;print count&#125;&apos; /etc/passwdcount æ˜¯è‡ªå®šä¹‰å˜é‡,è¿™é‡Œæ²¡æœ‰åˆå§‹åŒ– count,è™½ç„¶é»˜è®¤æ˜¯ 0,ä½†æ˜¯å¦¥å½“çš„åšæ³•è¿˜æ˜¯åˆå§‹åŒ–ä¸º 0.awk &apos;BEGIN&#123;count=0&#125;&#123;count=count+1&#125;END&#123;print count&#125;&apos; /etc/passwdä¾‹å¦‚:ç»Ÿè®¡æŸä¸ªæ–‡ä»¶å¤¹ä¸‹çš„æ–‡ä»¶å ç”¨çš„å­—èŠ‚æ•°ls -l |awk &apos;BEGIN &#123;size=0;&#125; &#123;size=size+$5;&#125; END&#123;print &quot;[end]size is &quot;, size&#125;&apos;å¦‚æžœæŒ‰ç…§ M ä¸ºå•ä½æ˜¾ç¤ºls -l |awk &apos;BEGIN &#123;size=0;&#125; &#123;size=size+$5;&#125; END&#123;print &quot;[end]size is &quot;, size/1024/1024,&quot;M&quot;&#125;&apos; shell å­¦ä¹ åä¸ƒå¤©â€”awk å‘½ä»¤ è§£é‡Šï¼šæ‰“å°åŒ…å« MA çš„è¡Œä¸­çš„ç¬¬ä¸€ä¸ªå•è¯ã€‚(ä½¿ç”¨ echo å…³é”®å­—å¯ä»¥æ¨¡æ‹Ÿè¯»å…¥æ–‡ä»¶çš„æ“ä½œ) 1echo &apos;this is one world\nthat is another world&apos; | awk &apos;&#123;print $1&#125;&apos; å…³äºŽ -F çš„ä½¿ç”¨ æŒ‰ç…§ [] è¿›è¡Œåˆ‡åˆ†1awk -F &apos;[\[\]]&apos; &apos;&#123;print $1, $2, $3&#125;&apos; log.txt æŒ‰ç…§ () è¿›è¡Œåˆ‡åˆ† 1awk -F &apos;[()]&apos; &apos;&#123;print $1, $2, $3&#125;&apos; log.txt è¿™é‡Œçš„ â€˜$0â€™ å°±æ˜¯ä¸€è¡Œçš„ä¿¡æ¯, â€˜$1â€™ å°±æ˜¯ç¬¬ä¸€åˆ—ä¿¡æ¯1awk &apos;&#123;$2 = &quot;***&quot;; print $0&#125;&apos; fruit.txt åœ¨è¾“å‡ºçš„æ—¶å€™ï¼Œå¯ä»¥åŠ ä¸Šå­—ç¬¦ä¸²å’Œè½¬ä¹‰å­—ç¬¦ä¹‹ç±»çš„ï¼Œ æ³¨æ„åŠ ä¸Šçš„è¿™äº›ä¸œè¥¿æ˜¯ä½¿ç”¨åŒå¼•å·è¡¨ç¤ºçš„ã€‚1awk &apos;&#123;print $1 &quot;\t&quot; $2 &quot;\t&quot; $3&#125;&apos; fruit.txt åŒæ—¶å¤„ç†å¤šä¸ªæ–‡ä»¶ 1awk &apos;&#123;print FILENAME &quot;\t&quot; $0&#125;&apos; demo1.txt demo2.txt åœ¨ awk ä¸­ä½¿ç”¨å˜é‡ 1awk &apos;&#123;msg=&quot;hello world&quot;; print msg &quot;\t&quot; $0&#125;&apos; log.txt å¦‚æžœè¦åˆ¤æ–­æ–‡ä»¶çš„ç¬¬ 3 åˆ—æ•°æ®ï¼Œä¹Ÿå°±æ˜¯å¹³å‡å·¥èµ„å°äºŽ 5500 çš„å…¬å¸ï¼Œç„¶åŽå°†å…¶æ‰“å°è¾“å‡º Â·Â·Â·awk â€˜$3 &lt; 5500 {print $0}â€™ company.txtÂ·Â·Â· åœ¨ awk ä¸­ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…å­—ç¬¦ä¸² â€œThereâ€ ï¼Œå°†åŒ…å«è¿™ä¸ªå­—ç¬¦ä¸²çš„è¡Œæ‰“å°å¹¶è¾“å‡º 1awk &apos;/There/&#123;print $0&#125;&apos; poetry.txt ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼é…ä¸€ä¸ªåŒ…å«å­—æ¯ t å’Œå­—æ¯ e ï¼Œå¹¶ä¸” t å’Œ e ä¸­é—´åªèƒ½æœ‰ä»»æ„å•ä¸ªå­—ç¬¦çš„è¡Œ 12345awk &apos;/t.e/&#123;print $0&#125;&apos; poetry.txtThere is nothing either good or bad, but thinking makes it soThereâ€™s a special providence in the fall of a sparrowNo matter how dark long, may eventually in the day arrival è¿™ä¸ªcat å‘½ä»¤ä¹Ÿæ˜¯ä¸å¤ªæ‡‚å¾— cat base_meta | python segmentor.py ~/default_query/data &gt; base_meta.seg å¸¸è§çš„å˜é‡ å˜é‡NFè¡¨ç¤ºå½“å‰è¡Œæœ‰å¤šå°‘ä¸ªå­—æ®µï¼Œå› æ­¤$NFå°±ä»£è¡¨æœ€åŽä¸€ä¸ªå­—æ®µã€‚ 12$ echo &apos;this is a test&apos; | awk &apos;&#123;print $NF&#125;&apos;test 1$(NF-1)ä»£è¡¨å€’æ•°ç¬¬äºŒä¸ªå­—æ®µã€‚ printå‘½ä»¤é‡Œé¢ï¼Œå¦‚æžœåŽŸæ ·è¾“å‡ºå­—ç¬¦ï¼Œè¦æ”¾åœ¨åŒå¼•å·é‡Œé¢ã€‚ awkè¿˜æä¾›äº†ä¸€äº›å†…ç½®å‡½æ•°ï¼Œæ–¹ä¾¿å¯¹åŽŸå§‹æ•°æ®çš„å¤„ç†ã€‚ å‡½æ•°toupper()ç”¨äºŽå°†å­—ç¬¦è½¬ä¸ºå¤§å†™ã€‚ 1234567tolower()ï¼šå­—ç¬¦è½¬ä¸ºå°å†™ã€‚length()ï¼šè¿”å›žå­—ç¬¦ä¸²é•¿åº¦ã€‚substr()ï¼šè¿”å›žå­å­—ç¬¦ä¸²ã€‚sin()ï¼šæ­£å¼¦ã€‚cos()ï¼šä½™å¼¦ã€‚sqrt()ï¼šå¹³æ–¹æ ¹ã€‚rand()ï¼šéšæœºæ•°ã€‚ å®Œæ•´çš„built-in function æ‰‹å†Œ 12345678910# è¾“å‡ºå¥‡æ•°è¡Œ$ awk -F &apos;:&apos; &apos;NR % 2 == 1 &#123;print $1&#125;&apos; demo.txtrootbinsync# è¾“å‡ºç¬¬ä¸‰è¡Œä»¥åŽçš„è¡Œ$ awk -F &apos;:&apos; &apos;NR &gt;3 &#123;print $1&#125;&apos; demo.txtsyssync ä¸‹é¢çš„ä¾‹å­è¾“å‡ºç¬¬ä¸€ä¸ªå­—æ®µç­‰äºŽæŒ‡å®šå€¼çš„è¡Œã€‚ 12345$ awk -F &apos;:&apos; &apos;$1 == &quot;root&quot; &#123;print $1&#125;&apos; demo.txtroot$ awk -F &apos;:&apos; &apos;$1 == &quot;root&quot; || $1 == &quot;bin&quot; &#123;print $1&#125;&apos; demo.txtrootbin if else è¯­å¥ 1234$ awk -F &apos;:&apos; &apos;&#123;if ($1 &gt; &quot;m&quot;) print $1&#125;&apos; demo.txtrootsyssync ä¸Šé¢ä»£ç è¾“å‡ºç¬¬ä¸€ä¸ªå­—æ®µçš„ç¬¬ä¸€ä¸ªå­—ç¬¦å¤§äºŽmçš„è¡Œã€‚ awk å¤„ç†æ–‡æœ¬ awkã€grepã€sedæ˜¯linuxæ“ä½œæ–‡æœ¬çš„ä¸‰å¤§åˆ©å™¨ï¼Œä¹Ÿæ˜¯å¿…é¡»æŽŒæ¡çš„linuxå‘½ä»¤ä¹‹ä¸€ã€‚ä¸‰è€…çš„åŠŸèƒ½éƒ½æ˜¯å¤„ç†æ–‡æœ¬ï¼Œä½†ä¾§é‡ç‚¹å„ä¸ç›¸åŒï¼Œå…¶ä¸­å±žawkåŠŸèƒ½æœ€å¼ºå¤§ï¼Œä½†ä¹Ÿæœ€å¤æ‚ã€‚grepæ›´é€‚åˆå•çº¯çš„æŸ¥æ‰¾æˆ–åŒ¹é…æ–‡æœ¬ï¼Œsedæ›´é€‚åˆç¼–è¾‘åŒ¹é…åˆ°çš„æ–‡æœ¬ï¼Œawkæ›´é€‚åˆæ ¼å¼åŒ–æ–‡æœ¬ï¼Œå¯¹æ–‡æœ¬è¿›è¡Œè¾ƒå¤æ‚æ ¼å¼å¤„ç†ã€‚ grep å‘½ä»¤grepï¼ˆglobal search regular expression(RE) and print out the lineï¼Œå…¨é¢æœç´¢æ­£åˆ™è¡¨è¾¾å¼å¹¶æŠŠè¡Œæ‰“å°å‡ºæ¥ï¼‰æ˜¯ä¸€ç§å¼ºå¤§çš„æ–‡æœ¬æœç´¢å·¥å…·ï¼Œå®ƒèƒ½ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æœç´¢æ–‡æœ¬ï¼Œå¹¶æŠŠåŒ¹é…çš„è¡Œæ‰“å°å‡ºæ¥ã€‚ 12345678910111213-d&lt;è¿›è¡ŒåŠ¨ä½œ&gt; å½“æŒ‡å®šè¦æŸ¥æ‰¾çš„æ˜¯ç›®å½•è€Œéžæ–‡ä»¶æ—¶ï¼Œå¿…é¡»ä½¿ç”¨è¿™é¡¹å‚æ•°ï¼Œå¦åˆ™grepå‘½ä»¤å°†å›žæŠ¥ä¿¡æ¯å¹¶åœæ­¢åŠ¨ä½œã€‚-h å½“æœç´¢å¤šä¸ªæ–‡ä»¶æ—¶ï¼Œä¸æ˜¾ç¤ºåŒ¹é…æ–‡ä»¶åå‰ç¼€-i å¿½ç•¥å­—ç¬¦å¤§å°å†™çš„å·®åˆ«ã€‚-l åˆ—å‡ºæ–‡ä»¶å†…å®¹ç¬¦åˆæŒ‡å®šçš„èŒƒæœ¬æ ·å¼çš„æ–‡ä»¶åç§°ã€‚-n åˆ—å‡ºæ‰€æœ‰çš„åŒ¹é…çš„æ–‡æœ¬è¡Œï¼Œå¹¶æ˜¾ç¤ºè¡Œå·-r é€’å½’æœç´¢ï¼Œæœç´¢å½“å‰ç›®å½•å’Œå­ç›®å½•,æ­¤å‚æ•°çš„æ•ˆæžœå’ŒæŒ‡å®šâ€œ-d recurseâ€å‚æ•°ç›¸åŒã€‚-v åè½¬æŸ¥æ‰¾ã€‚åªæ˜¾ç¤ºä¸åŒ¹é…çš„æ–‡æœ¬è¡Œ history | grep â€œsshâ€ # åœ¨è¿”å›žçš„ç»“æžœä¸­ä½¿ç”¨ grep è¿›è¡ŒæŸ¥æ‰¾ sed è¡Œç¼–è¾‘å™¨sedæ˜¯ä¸€ç§æµç¼–è¾‘å™¨ï¼Œå®ƒæ˜¯æ–‡æœ¬å¤„ç†ä¸­éžå¸¸é‡è¦çš„å·¥å…·ï¼Œèƒ½å¤Ÿå®Œç¾Žçš„é…åˆæ­£åˆ™è¡¨è¾¾å¼ä½¿ç”¨ï¼ŒåŠŸèƒ½ä¸åŒå‡¡å“ã€‚å¤„ç†æ—¶ï¼ŒæŠŠå½“å‰å¤„ç†çš„è¡Œå­˜å‚¨åœ¨ä¸´æ—¶ç¼“å†²åŒºä¸­ï¼Œç§°ä¸ºâ€œæ¨¡å¼ç©ºé—´â€ï¼ˆpattern spaceï¼‰ï¼ŒæŽ¥ç€ç”¨sedå‘½ä»¤å¤„ç†ç¼“å†²åŒºä¸­çš„å†…å®¹ï¼Œå¤„ç†å®ŒæˆåŽï¼ŒæŠŠç¼“å†²åŒºçš„å†…å®¹é€å¾€å±å¹•ã€‚æŽ¥ç€å¤„ç†ä¸‹ä¸€è¡Œï¼Œè¿™æ ·ä¸æ–­é‡å¤ï¼Œç›´åˆ°æ–‡ä»¶æœ«å°¾ã€‚æ–‡ä»¶å†…å®¹å¹¶æ²¡æœ‰ æ”¹å˜ï¼Œé™¤éžä½ ä½¿ç”¨é‡å®šå‘å­˜å‚¨è¾“å‡ºã€‚Sedä¸»è¦ç”¨æ¥è‡ªåŠ¨ç¼–è¾‘ä¸€ä¸ªæˆ–å¤šä¸ªæ–‡ä»¶ï¼›ç®€åŒ–å¯¹æ–‡ä»¶çš„åå¤æ“ä½œï¼›ç¼–å†™è½¬æ¢ç¨‹åºç­‰ã€‚ å¸¸ç”¨çš„é€‰é¡¹ 12-e&lt;script&gt;æˆ–--expression=&lt;script&gt;ï¼šä»¥é€‰é¡¹ä¸­çš„æŒ‡å®šçš„scriptæ¥å¤„ç†è¾“å…¥çš„æ–‡æœ¬æ–‡ä»¶ï¼›-næˆ–--quietæˆ–â€”â€”silentï¼šä»…æ˜¾ç¤ºscriptå¤„ç†åŽçš„ç»“æžœï¼› å¸¸ç”¨çš„å‘½ä»¤12345678910a\ åœ¨å½“å‰è¡Œä¸‹é¢æ’å…¥æ–‡æœ¬ã€‚i\ åœ¨å½“å‰è¡Œä¸Šé¢æ’å…¥æ–‡æœ¬ã€‚c\ æŠŠé€‰å®šçš„è¡Œæ”¹ä¸ºæ–°çš„æ–‡æœ¬ã€‚d åˆ é™¤ï¼Œåˆ é™¤é€‰æ‹©çš„è¡Œã€‚n è¯»å–ä¸‹ä¸€ä¸ªè¾“å…¥è¡Œï¼Œç”¨ä¸‹ä¸€ä¸ªå‘½ä»¤å¤„ç†æ–°çš„è¡Œè€Œä¸æ˜¯ç”¨ç¬¬ä¸€ä¸ªå‘½ä»¤ã€‚s æ›¿æ¢æŒ‡å®šå­—ç¬¦p æ‰“å°æ¨¡æ¿å—çš„è¡Œã€‚q é€€å‡ºSedã€‚r file ä»Žfileä¸­è¯»è¡Œã€‚w file å†™å¹¶è¿½åŠ æ¨¡æ¿å—åˆ°fileæœ«å°¾ã€‚ æ›´å¤šè¯¦ç»†çš„ä¾‹å­ æœ€å¥½æ˜¯åŠ¨æ‰‹è¯•ä¸€ä¸‹ å…³äºŽä¸Šè¿°ä¸‰ä¸ªå‘½ä»¤çš„ç»ƒä¹ awk çš„ç»ƒä¹ é¢˜çœ‹ä¸Šé¢çš„ä¾‹å­å°±è¡Œ å¼ºå¤§çš„grepï¼Œsedå’Œawkâ€“ç”¨æ¡ˆä¾‹æ¥è®²è§£æ›´å¤šsed è¯¦ç»†çš„ä¾‹å­å…³äºŽsed çš„ç»ƒä¹ é¢˜ è½¯é“¾æŽ¥ ç¡¬é“¾æŽ¥ å’Œcp ln -s æºæ–‡ä»¶ ç›®æ ‡æ–‡ä»¶ åšè½¯é“¾æŽ¥ è½¯é“¾æŽ¥ï¼šé€šè¿‡è½¯é“¾æŽ¥å»ºç«‹çš„é“¾æŽ¥æ–‡ä»¶ä¸ŽåŽŸæ–‡ä»¶å¹¶ä¸æ˜¯åŒä¸€ä¸ªæ–‡ä»¶ï¼Œç›¸å½“äºŽåŽŸæ–‡ä»¶çš„å¿«æ·æ–¹å¼ã€‚ ç¡¬é“¾æŽ¥ï¼šç¡¬é“¾æŽ¥çš„ä¸¤ä¸ªæ–‡ä»¶æ˜¯ç‹¬ç«‹çš„ä¸¤ä¸ªå¼•ç”¨è®¡æ•°æ–‡ä»¶ï¼Œä»–ä»¬å…±ç”¨åŒä¸€ä»½æ•°æ®ï¼Œæ‰€ä»¥ä»–ä»¬- çš„inodeèŠ‚ç‚¹ç›¸åŒåˆ é™¤ç¡¬é“¾æŽ¥ä¸­çš„ä»»æ„ä¸€ä¸ªæ–‡ä»¶ï¼Œå¦å¤–ä¸€ä¸ªæ–‡ä»¶ä¸ä¼šè¢«åˆ é™¤ã€‚ ln -s ~/sag_common/production/search/nlp/query_quality/src/libglog.so.0 /usr/lib6 ln -s log2013.log link2013 ssh è¿œç¨‹ç™»å½•çš„å‘½ä»¤ ssh -i .ssh/qiso_id_rsa qiso@10.39.22.30 ä½¿ç”¨ exit é€€å‡ºå½“å‰è´¦æˆ·çš„ssh ç™»å½• ssh -i .ssh/qiso_id_rsa zhlu@10.52.80.185 # è¿™ä¸ªæ˜¯æœ‰gpu çš„æœºå™¨ ssh -i .ssh/qiso_id_rsa qiso@10.39.22.30 # è¿™ä¸ªåº”è¯¥æ˜¯hadoop çš„æœºå™¨ æ‰€ä»¥çŽ°åœ¨ä¸€å…±æœ‰ä¸‰ä¸ªæœºå™¨ï¼Œä¸€ä¸ªæ˜¯æˆ‘è´¦æˆ·ä¸‹çš„æœºå™¨ï¼Œä¸€ä¸ªæ˜¯ gpuæœºå™¨ï¼Œä¸€ä¸ªæ˜¯qiso çš„æœºå™¨ scp -i è¡¨ç¤ºä½¿ç”¨ssh è¿›è¡Œä¼ è¾“æ–‡ä»¶ scp -r -i ~/.ssh/qiso_id_rsa qiso@10.39.22.30:/home/qiso/jarvis* ~/ scp -r -i ~/.ssh/qiso_id_rsa qiso@10.39.22.30:/home/qiso/data/production//search/nlp/default_query/data/traditi /home/qiso/data/production/search/nlp/query_quality/data/ scp -i Selects the file from which the identity (private key) for public # ä½¿ç”¨ private key è¿›è¡Œæµ‹è¯• tar å‘½ä»¤ è§£åŒ…ï¼štar zxvf FileName.taræ‰“åŒ…ï¼štar czvf FileName.tar DirName ä¸¤ä¸ªå‘½ä»¤è¿žç”¨ï¼š ps -ax æŸ¥çœ‹è¿›ç¨‹çš„ï¼Œ To see every process on the system using BSD syntax: ps -ax | grep vulgar_ kill -9 pid æ€æ­»è¿›ç¨‹ ps æ˜¯æ˜¾ç¤ºè¿›ç¨‹çš„ ä¸‹é¢ä¸¤ä¸ªéƒ½æ˜¯æ˜¾ç¤ºè¿›ç¨‹ç”¨çš„ ps -e ps -ef æ‰§è¡Œshell è„šæœ¬ sh -x vulgar_query_preprocessor.sh scp -r -i ~/.ssh/qiso_id_rsa qiso@10.39.22.30:/home/qiso/data/production/search/nlp/query_quality/data/vulgar_query/model/ ./ Â· /home/qiso/data/production/search/nlp/query_quality/data/vulgar_query/embedding/query_ngram_represent diff å‘½ä»¤ è®²è§£ï¼š http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html æ¯”è¾ƒä¸¤ä¸ªæ–‡ä»¶ diff &lt;a.file&gt; &lt;b.file&gt; æœ€ç®€å•çš„å½¢å¼ï¼Œæ²¡æœ‰å‚æ•°ï¼Œå¾—åˆ°çš„æ˜¯3å››è¡Œ 4c4 #ç¬¬ä¸€è¡Œæ˜¯æç¤ºï¼Œè¡¨ç¤ºå˜åŠ¨çš„ä½ç½®, cè¡¨ç¤º change , a è¡¨ç¤º addition, d è¡¨ç¤º deletion &lt; a #è¡¨ç¤º a.file åŽ»é™¤ a å†…å®¹ â€”- # åˆ†éš”ç¬¦ > b #è¡¨ç¤ºb.file æ·»åŠ è¯¥è¡Œ alias ç”¨æ¥è®¾ç½®æŒ‡ä»¤çš„åˆ«å åœ¨æœºå™¨ä¸Šä½¿ç”¨vim è€Œä¸è¦ä½¿ç”¨ vi alias vi=â€™/usr/bin/vimâ€™ # è®¾ç½® alias alias vi=â€™vimâ€™ # è®¾ç½®æŒ‡å‘ source, sh, bash, ./ æ‰§è¡Œ shell æ–‡ä»¶çš„åŒºåˆ« source source a.sh # åœ¨å½“å‰çš„shell ä¸­è¯»å–ï¼Œa.sh ä¸éœ€è¦æœ‰æ‰§è¡Œæƒåˆ© . a.sh # ä¹Ÿå¯ä»¥å†™æˆè¿™æ ·ï¼Œæ³¨æ„ä¸­é—´æ˜¯æœ‰ç©ºæ ¼çš„ #è¿™ä¸ªæ˜¯åœ¨å½“å‰çš„ shell ä¸­ï¼Œé€è¡Œè¯»å…¥çš„è„šæœ¬ï¼Œç„¶åŽåˆ›å»ºçš„å˜é‡éƒ½ä¿å­˜åœ¨å½“å‰çš„shell ä¸­ sh/bash sh a.sh bash a.sh # è¿™ä¸¤ç§æ–¹å¼éƒ½æ˜¯æ‰“å¼€ä¸€ä¸ª subshell åŽ»æ‰§è¡Œï¼Œ a.sh ä¸éœ€è¦æœ‰æ‰§è¡Œæƒé™ sh -x a.sh # è¿™ä¸ªæ˜¯ boss å¸¸ç”¨çš„æ‰§è¡Œæ–¹å¼ ./ ./a.sh #æ‰“å¼€ä¸€ä¸ªsubshell æ‰§è¡Œï¼Œ a.sh æ˜¯éœ€è¦æœ‰æ‰§è¡Œæƒé™çš„ï¼Œå¦‚æžœæ²¡æœ‰å¯ä»¥é€šè¿‡ chmod +x è¿›è¡Œæ·»åŠ  çŽ¯å¢ƒå˜é‡ - setã€envã€export setå‘½ä»¤æ˜¾ç¤ºå½“å‰shellçš„å˜é‡ï¼ŒåŒ…æ‹¬å½“å‰ç”¨æˆ·çš„å˜é‡; envå‘½ä»¤æ˜¾ç¤ºå½“å‰ç”¨æˆ·çš„å˜é‡; exportå‘½ä»¤æ˜¾ç¤ºå½“å‰å¯¼å‡ºæˆç”¨æˆ·å˜é‡çš„shellå˜é‡ã€‚ æŸ¥çœ‹å‘½ä»¤-more, less, cat cat æ˜¯ä¸€æ¬¡æ€§æ˜¾ç¤ºæ•´ä¸ªæ–‡ä»¶çš„å†…å®¹ï¼Œè¿˜å¯ä»¥å°†å¤šä¸ªæ–‡ä»¶è¿žæŽ¥èµ·æ¥æ˜¾ç¤ºï¼Œå®ƒå¸¸ä¸Žé‡å®šå‘ç¬¦å·é…åˆä½¿ç”¨ï¼Œé€‚ç”¨äºŽæ–‡ä»¶å†…å®¹å°‘çš„æƒ…å†µï¼› moreå‘½ä»¤ï¼ŒåŠŸèƒ½ç±»ä¼¼ catã€‚moreå‘½ä»¤åªèƒ½å‰å‘åŽè¯»å–æ–‡ä»¶ï¼Œå› æ­¤åœ¨å¯åŠ¨æ—¶å°±åŠ è½½æ•´ä¸ªæ–‡ä»¶ã€‚ lesså¯ä»¥å‰åŽçœ‹ï¼Œæ¯”more åŠŸèƒ½æ›´åŠ å¼ºå¤§ã€‚ linux ä¸­ sort 123456sort file1.txt file2.txt &gt; sorted.txtsort file1.txt file2.txt -o sorted.txt #ä¸Šé¢ä¸¤ç§æ‰‹å·¥å†™æ³•éƒ½æ˜¯ä¸€æ ·çš„cat sorted_file.txt | uniq &gt; uniq_lines.txt # æ‰¾å‡ºå·²æŽ’åºæ–‡ä»¶ä¸­ä¸é‡å¤çš„è¡Œï¼šsort -k 2 data.txt # kè¡¨ç¤ºçš„åˆ—æ•° ä¾æ®ç¬¬äºŒåˆ—è¿›è¡ŒæŽ’åºsort -nrk 1 data.txt #ä¾æ®ç¬¬ä¸€åˆ—è¿›è¡Œé€†åºæŽ’åº, -r è¡¨ç¤ºé€†åº 1ä¾æ®ç¬¬äºŒåˆ—è¿›è¡ŒæŽ’åº æŸ¥çœ‹cpuä¿¡æ¯çš„æ–¹æ³• ä½¿ç”¨å‘½ä»¤ lscpu æŸ¥çœ‹ç³»ç»Ÿæ–‡ä»¶ less /proc/cpuinfo ä½¿ç”¨ä¸‰æ–¹çš„è½¯ä»¶åŒ… æŸ¥çœ‹GPU çš„ä¿¡æ¯ï¼š nvidia-smi è¿™ä¸ªæ˜¯æŸ¥çœ‹NVIDIA æ˜¾å¡çš„å‘½ä»¤ linux ä¸­çš„è„šæœ¬è°ƒè¯• å¸¸ç”¨æ˜¯ä»¥ä¸‹çš„ä¸‰ç§æ–¹å¼ã€‚ echo æ–¹å¼è¾“å‡º æœ€ç®€å•çš„è°ƒè¯•æ–¹æ³•ï¼Œ æ¯”å¦‚ï¼š echo $VAR å‘½ä»¤é€‰é¡¹ -n åŠŸèƒ½ï¼šè¯»å–shellè„šæœ¬ï¼Œä½†æ˜¯ä¸æ‰§è¡Œã€‚ æ¯”å¦‚ bash â€“n script.sh å‘½ä»¤é€‰é¡¹ -x åŠŸèƒ½ï¼š æä¾›è·Ÿè¸ªæ‰§è¡Œä¿¡æ¯,å°†æ‰§è¡Œè„šæœ¬çš„è¿‡ç¨‹ä¸­æŠŠå®žé™…æ‰§è¡Œçš„æ¯ä¸ªå‘½ä»¤æ˜¾ç¤ºå‡ºæ¥ï¼Œè¡Œé¦–æ˜¾ç¤º+, +åŽé¢æ˜¾ç¤ºç»è¿‡æ›¿æ¢ä¹‹åŽçš„å‘½ä»¤è¡Œå†…å®¹ï¼Œæœ‰åŠ©äºŽåˆ†æžå®žé™…æ‰§è¡Œçš„æ˜¯ä»€ä¹ˆå‘½ä»¤. å…¶ä¸­â€+â€ è¡¨ç¤ºæ‰§è¡Œçš„æŸä¸ªå‘½ä»¤äººï¼Œç„¶åŽåŸºäºŽä¸Šä¸€ä¸ªâ€+â€ ä½¿ç”¨â€++â€ è¡¨ç¤ºæ›´è¿‘ä¸€æ­¥çš„æ‰§è¡Œã€‚å¾ˆå¥½ç†è§£çš„æ–¹å¼ã€‚ ç‰¹ç‚¹ï¼š æ˜¯shell é¦–é€‰çš„è°ƒè¯•æ–¹å¼ã€‚æ¯”å¦‚ï¼š åœ¨å‘½ä»¤è¡Œæä¾›å‚æ•°: sh -x script.sh åœ¨è„šæœ¬å¼€å¤´æä¾›å‚æ•°: #!/bin/sh -x åœ¨è„šæœ¬ä¸­ç”¨ set å‘½ä»¤å¯ç”¨or ç¦ç”¨å‚æ•°ï¼š set -x è¡¨ç¤ºå¯ç”¨ï¼Œ set +x è¡¨ç¤ºç¦ç”¨ ç®¡é“linux ä¸­æœ‰äº›å‘½ä»¤æ˜¯å¯ä»¥å¸¦å‚æ•°ï¼ŒæŽ¥å—â€œæ ‡å‡†è¾“å…¥â€ä½œä¸ºå‚æ•°1cat /etc/passwd | grep root å…¶ä¸­çš„ | æ˜¯ç®¡é“å‘½ä»¤ã€‚å·¦ä¾§çš„å‘½ä»¤(cat /etc/passwd)çš„æ ‡å‡†è¾“å‡ºä½œä¸ºåŽé¢å‘½ä»¤çš„è¾“å…¥ã€‚å…¶ä¸­grep æ˜¯å¯ä»¥æŽ¥å—æ ‡å‡†è¾“å…¥ä½œä¸ºå‚æ•°ã€‚ä¸Šé¢çš„å‘½ä»¤ç­‰åŒäºŽ1grep root /etc/passwd ä½†æ˜¯å¤§å¤šæ•°çš„å‘½ä»¤æ˜¯ä¸æŽ¥å—æ ‡å‡†è¾“å…¥ä½œä¸ºå‚æ•°ï¼Œæ¯”å¦‚è¯´ echo è¿™ä¸ªä½¿ç”¨åŽå°±å‡ºçŽ°äº† xargs å‘½ä»¤, è¯¥å‘½ä»¤å°†æ ‡å‡†è¾“å…¥è½¬æ¢æˆå‘½ä»¤è¡Œå‚æ•°ã€‚ 12echo &quot;hello world&quot; | xargs echo# hello world å°±æ˜¯è¾“å‡º è¯¥å‘½ä»¤çš„æ ¼å¼å¦‚ä¸‹1$ xargs [-options] [command] xargsçš„ä½œç”¨åœ¨äºŽï¼Œå¤§å¤šæ•°å‘½ä»¤ï¼ˆæ¯”å¦‚rmã€mkdirã€lsï¼‰ä¸Žç®¡é“ä¸€èµ·ä½¿ç”¨æ—¶ï¼Œéƒ½éœ€è¦xargså°†æ ‡å‡†è¾“å…¥è½¬ä¸ºå‘½ä»¤è¡Œå‚æ•°ã€‚ é»˜è®¤æƒ…å†µä¸‹ï¼Œ xargs å°†æ¢è¡Œç¬¦å’Œç©ºæ ¼ä½œä¸ºåˆ†éš”ç¬¦ï¼ŒæŠŠæ ‡å‡†è¾“å…¥åˆ†è§£æˆä¸€ä¸ªä¸ªå‘½ä»¤è¡Œå‚æ•°ã€‚1echo &quot;one two three&quot; | xargs mkdir ä½¿ç”¨ -d å¯ä»¥æ›´æ”¹åˆ†éš”ç¬¦1echo -e &quot;a\tb\tc&quot; | xargs -d &quot;\t&quot; echo å‚æ•° -pï¼Œå¯ä»¥ç¡®è®¤åˆ°åº•æ‰§è¡Œçš„æ˜¯ä»€ä¹ˆå‘½ä»¤ -på‚æ•°æ‰“å°å‡ºè¦æ‰§è¡Œçš„å‘½ä»¤ï¼Œè¯¢é—®ç”¨æˆ·æ˜¯å¦è¦æ‰§è¡Œã€‚ 12$ echo &apos;one two three&apos; | xargs -p touchtouch one two three ?... -tå‚æ•°åˆ™æ˜¯æ‰“å°å‡ºæœ€ç»ˆè¦æ‰§è¡Œçš„å‘½ä»¤ï¼Œç„¶åŽç›´æŽ¥æ‰§è¡Œï¼Œä¸éœ€è¦ç”¨æˆ·ç¡®è®¤ã€‚ 12$ echo &apos;one two three&apos; | xargs -t rmrm one two three examples xargs å’Œcp å‘½ä»¤ç»“åˆä½¿ç”¨è¿‡ï¼Œè¿”å›žå‰ 5 ä¸ªç»“æžœä½œä¸º cp çš„è¾“å…¥ã€‚1234ls | head -n 5| xargs -i cp &#123;&#125; /home/jijeng/projects/test/src# å›žåˆ°ä¸Šä¸€ä¸ªç›®å½•ï¼ˆæœ€è¿‘çš„ç›®å½•ï¼‰cd - git å¸¸è§çš„å‘½ä»¤gitå‘½ä»¤ git å‘½ä»¤æ¸…å• http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html git checkout # æ£€å‡ºåˆ†æ”¯ï¼Œ åˆ›å»ºåˆ†æ”¯å’Œåˆ‡æ¢åˆ†æ”¯ git checkout [branch-name] # åˆ‡æ¢åˆ°æŒ‡å®šåˆ†æ”¯ git checkout -b dev origin/dev git checkout -b [branch] #æ–°å»ºä¸€ä¸ªåˆ†æ”¯ å¹¶åˆ‡æ¢åˆ°è¯¥åˆ†æ”¯ git branch [branch] # æ–°å»ºä¸€ä¸ªåˆ†æ”¯ å¹¶åœç•™åœ¨å½“å‰çš„åˆ†æ”¯ git checkout dev git checkout master git fetch å‘½ä»¤ç”¨äºŽä»Žå¦ä¸€ä¸ªå­˜å‚¨åº“ä¸‹è½½å¯¹è±¡å’Œå¼•ç”¨ã€‚ git fetch &lt;è¿œç¨‹ä¸»æœºå&gt; &lt;åˆ†æ”¯å&gt; git fetch #æ›´æ–°æ‰€æœ‰åˆ†æ”¯ï¼Œå‘½ä»¤å¯ä»¥ç®€å†™ä¸ºï¼š git fetch origin git fetch [remote] # ä¸‹è½½è¿œç¨‹ä»“åº“æ‰€æœ‰çš„å˜åŠ¨ git push origin dev git push [remote] [branch] # ä¸Šä¼ æœ¬åœ°æŒ‡å®šåˆ†æ”¯åˆ°è¿œç¨‹ä»“åº“ git commit -am â€œupdateâ€ -a append, è¿½åŠ ä¿®æ”¹è¿‡çš„æ–‡ä»¶ç„¶åŽæäº¤åˆ°ä»“åº“é‡Œé¢ -m message æ·»åŠ message åœ¨æ¯æ¬¡æ‰§è¡Œ git commitä¹‹å‰å…ˆä½¿ç”¨git statusæ£€æŸ¥æ–‡ä»¶çŠ¶æ€æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„ä¹ æƒ¯, è¿™æ ·èƒ½é˜²æ­¢ä½ ä¸å°å¿ƒæäº¤äº†æ‚¨ä¸æƒ³æäº¤çš„ä¸œè¥¿ã€‚ git status Gitå‘½ä»¤è¯¦è§£ vi å¸¸è§å‘½ä»¤å’Œé…ç½® ç¬¬ä¸€é˜¶æ®µ 123456789i â†’ Insert æ¨¡å¼ï¼ŒæŒ‰ ESC å›žåˆ° Normal æ¨¡å¼.x â†’ åˆ å½“å‰å…‰æ ‡æ‰€åœ¨çš„ä¸€ä¸ªå­—ç¬¦ã€‚:wq â†’ å­˜ç›˜ + é€€å‡º (:w å­˜ç›˜, :q é€€å‡º) ï¼ˆé™ˆçš“æ³¨ï¼š:w åŽå¯ä»¥è·Ÿæ–‡ä»¶åï¼‰dd â†’ åˆ é™¤å½“å‰è¡Œï¼Œå¹¶æŠŠåˆ é™¤çš„è¡Œå­˜åˆ°å‰ªè´´æ¿é‡Œp â†’ ç²˜è´´å‰ªè´´æ¿æŽ¨è:hjkl (å¼ºä¾‹æŽ¨èä½¿ç”¨å…¶ç§»åŠ¨å…‰æ ‡ï¼Œä½†ä¸å¿…éœ€) â†’ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨å…‰æ ‡é”® (â†â†“â†‘â†’). æ³¨: j å°±åƒä¸‹ç®­å¤´ã€‚:help &lt;command&gt; â†’ æ˜¾ç¤ºç›¸å…³å‘½ä»¤çš„å¸®åŠ©ã€‚ä½ ä¹Ÿå¯ä»¥å°±è¾“å…¥ :help è€Œä¸è·Ÿå‘½ä»¤ã€‚ï¼ˆé™ˆçš“æ³¨ï¼šé€€å‡ºå¸®åŠ©éœ€è¦è¾“å…¥:qï¼‰ ç¬¬äºŒé˜¶æ®µ å„ç§æ’å…¥æ¨¡å¼ 1234a â†’ åœ¨å…‰æ ‡åŽæ’å…¥o â†’ åœ¨å½“å‰è¡ŒåŽæ’å…¥ä¸€ä¸ªæ–°è¡ŒO â†’ åœ¨å½“å‰è¡Œå‰æ’å…¥ä¸€ä¸ªæ–°è¡Œcw â†’ æ›¿æ¢ä»Žå…‰æ ‡æ‰€åœ¨ä½ç½®åŽåˆ°ä¸€ä¸ªå•è¯ç»“å°¾çš„å­—ç¬¦ ç®€å•çš„ç§»åŠ¨å…‰æ ‡ 123450 â†’ æ•°å­—é›¶ï¼Œåˆ°è¡Œå¤´^ â†’ åˆ°æœ¬è¡Œç¬¬ä¸€ä¸ªä¸æ˜¯blankå­—ç¬¦çš„ä½ç½®ï¼ˆæ‰€è°“blankå­—ç¬¦å°±æ˜¯ç©ºæ ¼ï¼Œtabï¼Œæ¢è¡Œï¼Œå›žè½¦ç­‰ï¼‰$ â†’ åˆ°æœ¬è¡Œè¡Œå°¾g_ â†’ åˆ°æœ¬è¡Œæœ€åŽä¸€ä¸ªä¸æ˜¯blankå­—ç¬¦çš„ä½ç½®ã€‚/pattern â†’ æœç´¢ pattern çš„å­—ç¬¦ä¸²ï¼ˆé™ˆçš“æ³¨ï¼šå¦‚æžœæœç´¢å‡ºå¤šä¸ªåŒ¹é…ï¼Œå¯æŒ‰né”®åˆ°ä¸‹ä¸€ä¸ªï¼‰ æ‹·è´/ç²˜è´´ 12P â†’ ç²˜è´´yy â†’ æ‹·è´å½“å‰è¡Œå½“è¡ŒäºŽ ddP Undo/Redo 12u â†’ undo&lt;C-r&gt; â†’ redo æ‰“å¼€/ä¿å­˜/é€€å‡º/æ”¹å˜æ–‡ä»¶(Buffer) 123456:e &lt;path/to/file&gt; â†’ æ‰“å¼€ä¸€ä¸ªæ–‡ä»¶:w â†’ å­˜ç›˜:saveas &lt;path/to/file&gt; â†’ å¦å­˜ä¸º &lt;path/to/file&gt;:xï¼Œ ZZ æˆ– :wq â†’ ä¿å­˜å¹¶é€€å‡º (:x è¡¨ç¤ºä»…åœ¨éœ€è¦æ—¶ä¿å­˜ï¼ŒZZä¸éœ€è¦è¾“å…¥å†’å·å¹¶å›žè½¦):q! â†’ é€€å‡ºä¸ä¿å­˜ :qa! å¼ºè¡Œé€€å‡ºæ‰€æœ‰çš„æ­£åœ¨ç¼–è¾‘çš„æ–‡ä»¶ï¼Œå°±ç®—åˆ«çš„æ–‡ä»¶æœ‰æ›´æ”¹ã€‚:bn å’Œ :bp â†’ ä½ å¯ä»¥åŒæ—¶æ‰“å¼€å¾ˆå¤šæ–‡ä»¶ï¼Œä½¿ç”¨è¿™ä¸¤ä¸ªå‘½ä»¤æ¥åˆ‡æ¢ä¸‹ä¸€ä¸ªæˆ–ä¸Šä¸€ä¸ªæ–‡ä»¶ã€‚ï¼ˆé™ˆçš“æ³¨ï¼šæˆ‘å–œæ¬¢ä½¿ç”¨:nåˆ°ä¸‹ä¸€ä¸ªæ–‡ä»¶ï¼‰ ç¬¬ä¸‰é˜¶æ®µ ä½¿å¾— vim é‡å¤ä»»åŠ¡ 12. â†’ é‡å¤ä¸Šä¸€ä¸ªå‘½ä»¤â€”â€” 100 â€œdesu â€œ.3. â†’ é‡å¤ 3 æ¬¡ â€œdesuâ€ (æ³¨æ„ï¼šä¸æ˜¯ 300ï¼Œä½ çœ‹ï¼ŒVIMå¤šèªæ˜Žå•Š). å…‰æ ‡çš„ç§»åŠ¨ 1234567891011NG â†’ åˆ°ç¬¬ N è¡Œ ï¼ˆé™ˆçš“æ³¨ï¼šæ³¨æ„å‘½ä»¤ä¸­çš„Gæ˜¯å¤§å†™çš„ï¼Œå¦æˆ‘ä¸€èˆ¬ä½¿ç”¨ : N åˆ°ç¬¬Nè¡Œï¼Œå¦‚ :137 åˆ°ç¬¬137è¡Œï¼‰gg â†’ åˆ°ç¬¬ä¸€è¡Œã€‚ï¼ˆé™ˆçš“æ³¨ï¼šç›¸å½“äºŽ1Gï¼Œæˆ– :1ï¼‰G â†’ åˆ°æœ€åŽä¸€è¡Œã€‚æŒ‰å•è¯ç§»åŠ¨ï¼šw â†’ åˆ°ä¸‹ä¸€ä¸ªå•è¯çš„å¼€å¤´ã€‚e â†’ åˆ°ä¸‹ä¸€ä¸ªå•è¯çš„ç»“å°¾ã€‚&gt; å¦‚æžœä½ è®¤ä¸ºå•è¯æ˜¯ç”±é»˜è®¤æ–¹å¼ï¼Œé‚£ä¹ˆå°±ç”¨å°å†™çš„eå’Œwã€‚é»˜è®¤ä¸Šæ¥è¯´ï¼Œä¸€ä¸ªå•è¯ç”±å­—æ¯ï¼Œæ•°å­—å’Œä¸‹åˆ’çº¿ç»„æˆï¼ˆé™ˆçš“æ³¨ï¼šç¨‹åºå˜é‡ï¼‰&gt; å¦‚æžœä½ è®¤ä¸ºå•è¯æ˜¯ç”±blankå­—ç¬¦åˆ†éš”ç¬¦ï¼Œé‚£ä¹ˆä½ éœ€è¦ä½¿ç”¨å¤§å†™çš„Eå’ŒWã€‚ï¼ˆé™ˆçš“æ³¨ï¼šç¨‹åºè¯­å¥ï¼‰% : åŒ¹é…æ‹¬å·ç§»åŠ¨ï¼ŒåŒ…æ‹¬ (, &#123;, [. ï¼ˆé™ˆçš“æ³¨ï¼šä½ éœ€è¦æŠŠå…‰æ ‡å…ˆç§»åˆ°æ‹¬å·ä¸Šï¼‰* å’Œ #: åŒ¹é…å…‰æ ‡å½“å‰æ‰€åœ¨çš„å•è¯ï¼Œç§»åŠ¨å…‰æ ‡åˆ°ä¸‹ä¸€ä¸ªï¼ˆæˆ–ä¸Šä¸€ä¸ªï¼‰åŒ¹é…å•è¯ï¼ˆ*æ˜¯ä¸‹ä¸€ä¸ªï¼Œ#æ˜¯ä¸Šä¸€ä¸ªï¼‰ ç¬¬å››é˜¶æ®µ 12345678910åœ¨å½“å‰è¡Œä¸Šç§»åŠ¨å…‰æ ‡: 0 ^ $ f F t T , ;0 â†’ åˆ°è¡Œå¤´^ â†’ åˆ°æœ¬è¡Œçš„ç¬¬ä¸€ä¸ªéžblankå­—ç¬¦$ â†’ åˆ°è¡Œå°¾g_ â†’ åˆ°æœ¬è¡Œæœ€åŽä¸€ä¸ªä¸æ˜¯blankå­—ç¬¦çš„ä½ç½®ã€‚fa â†’ åˆ°ä¸‹ä¸€ä¸ªä¸ºaçš„å­—ç¬¦å¤„ï¼Œä½ ä¹Ÿå¯ä»¥fsåˆ°ä¸‹ä¸€ä¸ªä¸ºsçš„å­—ç¬¦ã€‚t, â†’ åˆ°é€—å·å‰çš„ç¬¬ä¸€ä¸ªå­—ç¬¦ã€‚é€—å·å¯ä»¥å˜æˆå…¶å®ƒå­—ç¬¦ã€‚3fa â†’ åœ¨å½“å‰è¡ŒæŸ¥æ‰¾ç¬¬ä¸‰ä¸ªå‡ºçŽ°çš„aã€‚F å’Œ T â†’ å’Œ f å’Œ t ä¸€æ ·ï¼Œåªä¸è¿‡æ˜¯ç›¸åæ–¹å‘ã€‚ åŒºåŸŸé€‰æ‹© a æˆ– i(è¿™ä¸ªéƒ¨åˆ†æ²¡æœ‰çœ‹æ‡‚ï¼Œå¯ä»¥è¯¦ç»†çš„çœ‹åŽŸæ–‡) å—æ“ä½œ: 12345å—æ“ä½œï¼Œå…¸åž‹çš„æ“ä½œï¼š 0 &lt;C-v&gt; &lt;C-d&gt; I-- [ESC]^ â†’ åˆ°è¡Œå¤´&lt;C-v&gt; â†’ å¼€å§‹å—æ“ä½œ&lt;C-d&gt; â†’ å‘ä¸‹ç§»åŠ¨ (ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨hjklæ¥ç§»åŠ¨å…‰æ ‡ï¼Œæˆ–æ˜¯ä½¿ç”¨%ï¼Œæˆ–æ˜¯åˆ«çš„)I-- [ESC] â†’ Iæ˜¯æ’å…¥ï¼Œæ’å…¥â€œ--â€ï¼ŒæŒ‰ESCé”®æ¥ä¸ºæ¯ä¸€è¡Œç”Ÿæ•ˆã€‚ å¯è§†åŒ–ä¹‹åŽçš„æ“ä½œ123J â†’ æŠŠæ‰€æœ‰çš„è¡Œè¿žæŽ¥èµ·æ¥ï¼ˆå˜æˆä¸€è¡Œï¼‰&lt; æˆ– &gt; â†’ å·¦å³ç¼©è¿›= â†’ è‡ªåŠ¨ç»™ç¼©è¿› ï¼ˆé™ˆçš“æ³¨ï¼šè¿™ä¸ªåŠŸèƒ½ç›¸å½“å¼ºå¤§ï¼Œæˆ‘å¤ªå–œæ¬¢äº†ï¼‰ åˆ†å±: :split å’Œ vsplit.ï¼ˆè¿™ä¸ªæˆ‘ä¸ªäººä½¿ç”¨çš„ä¸å¤šï¼Œæ›´åŠ çš„å€¾å‘äºŽä½¿ç”¨è½¯ä»¶åˆ†å±ï¼Œè€Œä¸æ˜¯å‘½ä»¤åˆ†å±ï¼‰ ç®€æ˜Ž VIM ç»ƒçº§æ”»ç•¥ ä½¿ç”¨æŠ€èƒ½ï¼š ä½¿ç”¨ vi å‘½ä»¤æœç´¢ä¸‹ä¸€ä¸ªå­—ç¬¦ä¸²æ‰€åœ¨çš„ä½ç½® æŒ‰escé”®ï¼Œè¾“å…¥/stringå›žè½¦ï¼Œå°±èƒ½å®šä½å­—ç¬¦ä¸²stringï¼ŒæŒ‰nå®šä½ä¸‹ä¸€ä¸ª linux ä¸­è¿›ç¨‹å’Œçº¿ç¨‹çš„å…³ç³» å‡ ç§è¿›ç¨‹é—´çš„é€šä¿¡æ–¹å¼ ç®¡é“ï¼ˆpipeï¼‰ï¼šç®¡é“æ˜¯ä¸€ç§åŠåŒå·¥çš„é€šä¿¡æ–¹å¼ï¼Œæ•°æ®åªèƒ½å•å‘æµåŠ¨ï¼Œè€Œä¸”åªèƒ½åœ¨å…·æœ‰è¡€ç¼˜å…³ç³»çš„è¿›ç¨‹é—´ä½¿ç”¨ã€‚è¿›ç¨‹çš„è¡€ç¼˜å…³ç³»é€šå¸¸æŒ‡çˆ¶å­è¿›ç¨‹å…³ç³»ã€‚ æœ‰åç®¡é“ï¼ˆnamed pipeï¼‰ï¼šæœ‰åç®¡é“ä¹Ÿæ˜¯åŠåŒå·¥çš„é€šä¿¡æ–¹å¼ï¼Œä½†æ˜¯å®ƒå…è®¸æ— äº²ç¼˜å…³ç³»è¿›ç¨‹é—´é€šä¿¡ã€‚ ä¿¡å·é‡ï¼ˆsemophoreï¼‰ï¼šä¿¡å·é‡æ˜¯ä¸€ä¸ªè®¡æ•°å™¨ï¼Œå¯ä»¥ç”¨æ¥æŽ§åˆ¶å¤šä¸ªè¿›ç¨‹å¯¹å…±äº«èµ„æºçš„è®¿é—®ã€‚å®ƒé€šå¸¸ä½œä¸ºä¸€ç§é”æœºåˆ¶ï¼Œé˜²æ­¢æŸè¿›ç¨‹æ­£åœ¨è®¿é—®å…±äº«èµ„æºæ—¶ï¼Œå…¶ä»–è¿›ç¨‹ä¹Ÿè®¿é—®è¯¥èµ„æºã€‚å› æ­¤ï¼Œä¸»è¦ä½œä¸ºè¿›ç¨‹é—´ä»¥åŠåŒä¸€è¿›ç¨‹å†…ä¸åŒçº¿ç¨‹ä¹‹é—´çš„åŒæ­¥æ‰‹æ®µã€‚ æ¶ˆæ¯é˜Ÿåˆ—ï¼ˆmessage queueï¼‰ï¼šæ¶ˆæ¯é˜Ÿåˆ—æ˜¯ç”±æ¶ˆæ¯ç»„æˆçš„é“¾è¡¨ï¼Œå­˜æ”¾åœ¨å†…æ ¸ä¸­ å¹¶ç”±æ¶ˆæ¯é˜Ÿåˆ—æ ‡è¯†ç¬¦æ ‡è¯†ã€‚æ¶ˆæ¯é˜Ÿåˆ—å…‹æœäº†ä¿¡å·ä¼ é€’ä¿¡æ¯å°‘ï¼Œç®¡é“åªèƒ½æ‰¿è½½æ— æ ¼å¼å­—èŠ‚æµä»¥åŠç¼“å†²åŒºå¤§å°å—é™ç­‰ç¼ºç‚¹ã€‚ ä¿¡å·ï¼ˆsignalï¼‰ï¼šä¿¡å·æ˜¯ä¸€ç§æ¯”è¾ƒå¤æ‚çš„é€šä¿¡æ–¹å¼ï¼Œç”¨äºŽé€šçŸ¥æŽ¥æ”¶è¿›ç¨‹æŸä¸€äº‹ä»¶å·²ç»å‘ç”Ÿã€‚ å…±äº«å†…å­˜ï¼ˆshared memoryï¼‰ï¼šå…±äº«å†…å­˜å°±æ˜¯æ˜ å°„ä¸€æ®µèƒ½è¢«å…¶ä»–è¿›ç¨‹æ‰€è®¿é—®çš„å†…å­˜ï¼Œè¿™æ®µå…±äº«å†…å­˜ç”±ä¸€ä¸ªè¿›ç¨‹åˆ›å»ºï¼Œä½†å¤šä¸ªè¿›ç¨‹éƒ½å¯ä»¥è®¿é—®ï¼Œå…±äº«å†…å­˜æ˜¯æœ€å¿«çš„IPCæ–¹å¼ï¼Œå®ƒæ˜¯é’ˆå¯¹å…¶ä»–è¿›ç¨‹é—´çš„é€šä¿¡æ–¹å¼è¿è¡Œæ•ˆçŽ‡ä½Žè€Œä¸“é—¨è®¾è®¡çš„ã€‚å®ƒå¾€å¾€ä¸Žå…¶ä»–é€šä¿¡æœºåˆ¶ï¼Œå¦‚ä¿¡å·é‡é…åˆä½¿ç”¨ï¼Œæ¥å®žçŽ°è¿›ç¨‹é—´çš„åŒæ­¥å’Œé€šä¿¡ã€‚ å¥—æŽ¥å­—ï¼ˆsocketï¼‰ï¼šå¥—æŽ¥å£ä¹Ÿæ˜¯ä¸€ç§è¿›ç¨‹é—´çš„é€šä¿¡æœºåˆ¶ï¼Œä¸Žå…¶ä»–é€šä¿¡æœºåˆ¶ä¸åŒçš„æ˜¯å®ƒå¯ä»¥ç”¨äºŽä¸åŒåŠå…¶é—´çš„è¿›ç¨‹é€šä¿¡ã€‚ å‡ ç§çº¿ç¨‹é—´çš„é€šä¿¡æœºåˆ¶ é”æœºåˆ¶ äº’æ–¥é”ï¼šæä¾›äº†ä»¥æŽ’å®ƒæ–¹å¼é˜»æ­¢æ•°æ®ç»“æž„è¢«å¹¶å‘ä¿®æ”¹çš„æ–¹æ³•ã€‚ è¯»å†™é”ï¼šå…è®¸å¤šä¸ªçº¿ç¨‹åŒæ—¶è¯»å…±äº«æ•°æ®ï¼Œè€Œå¯¹å†™æ“ä½œäº’æ–¥ã€‚ æ¡ä»¶å˜é‡ï¼šå¯ä»¥ä»¥åŽŸå­çš„æ–¹å¼é˜»å¡žè¿›ç¨‹ï¼Œç›´åˆ°æŸä¸ªç‰¹å®šæ¡ä»¶ä¸ºçœŸä¸ºæ­¢ã€‚å¯¹æ¡ä»¶æµ‹è¯•æ˜¯åœ¨äº’æ–¥é”çš„ä¿æŠ¤ä¸‹è¿›è¡Œçš„ã€‚æ¡ä»¶å˜é‡å§‹ç»ˆä¸Žäº’æ–¥é”ä¸€èµ·ä½¿ç”¨ã€‚ ä¿¡å·é‡æœºåˆ¶ï¼šåŒ…æ‹¬æ— åçº¿ç¨‹ä¿¡å·é‡ä¸Žæœ‰åçº¿ç¨‹ä¿¡å·é‡ ä¿¡å·æœºåˆ¶ï¼šç±»ä¼¼äºŽè¿›ç¨‹é—´çš„ä¿¡å·å¤„ç†ã€‚ çº¿ç¨‹é—´é€šä¿¡çš„ä¸»è¦ç›®çš„æ˜¯ç”¨äºŽçº¿ç¨‹åŒæ­¥ï¼Œæ‰€ä»¥çº¿ç¨‹æ²¡æœ‰è±¡è¿›ç¨‹é€šä¿¡ä¸­ç”¨äºŽæ•°æ®äº¤æ¢çš„é€šä¿¡æœºåˆ¶ã€‚ æ›´å¤šå…³äºŽè¿™æ–¹é¢çš„ä»‹ç»å¯ä»¥å‚è€ƒè¿™é‡Œ]]></content>
      <tags>
        <tag>linux</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-List]]></title>
    <url>%2F2019%2F02%2F16%2Fleetcode-list%2F</url>
    <content type="text"><![CDATA[LeetCode åˆ·é¢˜æ€»ç»“ï¼ˆäºŒï¼‰ï¼Œ ä½¿ç”¨Python å®žçŽ°ã€‚è¯¥ç¯‡é¢˜ç›®ç±»åž‹ä¸»è¦æ˜¯ï¼š list, linkedList è¿˜æœ‰ç®€å•çš„ treeã€‚ Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. Tips: åŠ æ³•çš„è¿‡ç¨‹ï¼Œä½¿ç”¨ \% å’Œ æ•´é™¤è¿›è¡Œæ±‚è§£ï¼Œä½¿ç”¨linkedList è¿›è¡Œå­˜å‚¨ã€‚https://leetcode.com/problems/add-two-numbers/ 123456789101112131415161718192021222324252627# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ dummy = cur = ListNode(0) carry = 0 while l1 or l2 or carry: if l1: carry += l1.val l1 = l1.next if l2: carry += l2.val l2 = l2.next cur.next = ListNode(carry%10) cur = cur.next carry //= 10 return dummy.next Remove Nth Node From End of List Given a linked list, remove the n-th node from the end of list and return its head. Tips: å¯ä»¥ä½¿ç”¨â€ä¸¤æŒ‡é’ˆâ€œ æ–¹æ³•è¿›è¡Œæ±‚è§£ï¼Œå‰åŽä¸¤æŒ‡é’ˆç›¸å·® Næ­¥æ•°ã€‚ 12345678910111213141516171819202122232425262728293031323334353637# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def removeNthFromEnd(self, head, n): """ :type head: ListNode :type n: int :rtype: ListNode """ if not head or not head.next: return None new_head =ListNode(-1) new_head.next =head fast =new_head # å…ˆèµ°n æ­¥ for i in range(n): # è¿™é‡Œå¾ˆå¥½çš„å¤„ç†äº† n &gt; é“¾è¡¨é•¿åº¦ æƒ…å†µ if fast.next: fast =fast.next else: return head slow =new_head # ä¸€å—èµ° # å› ä¸ºæ˜¯ fast å…ˆèµ°åˆ°noneï¼Œæ‰€ä»¥è¿™ä¸ªåˆ¤æ–­æ¡ä»¶ while fast.next: fast =fast.next slow =slow.next slow.next =slow.next.next # è¿™ä¸ªæŒ‡å‘æ˜¯ç»éªŒæ€§ï¼Œè¿˜æ˜¯è¶…çº§niceçš„ return new_head.next Merge Two Sorted Lists Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Tips: å½’å¹¶æ“ä½œä¸­çš„â€å¹¶â€œ æ“ä½œã€‚ https://leetcode.com/problems/merge-two-sorted-lists/ 123456789101112131415161718192021222324252627282930313233343536373839404142# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def mergeTwoLists(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ if not l1 and not l2: return None elif not l1 or not l2: return l1 or l2 # è¿™é‡Œæ–°å»ºäº† nodeï¼Œä½œä¸ºæœ€åŽè¿”å›žlist ä¸­çš„headï¼Œå› ä¸ºä½¿ç”¨å“ªä¸ªå­list éƒ½æ˜¯ä¸ç¡®å®šçš„ new_node =ListNode(-1) cur =new_node head1 =l1 head2 =l2 while head1 and head2: if head1.val &lt; head2.val: cur.next =head1 head1 =head1.next else: cur.next =head2 head2 =head2.next cur =cur.next # å¯¹äºŽè¿™ç§ if else éœ€è¦æ˜¯ç›¸å½“çš„æ¸…æ¥š if head1: cur.next =head1 elif head2: cur.next =head2 return new_node.next Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head.You may not modify the values in the listâ€™s nodes, only nodes itself may be changed. Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Tips: å¸¸è§çš„ç±»åž‹ï¼Œä½¿ç”¨ä¸‰ä¸ªæŒ‡é’ˆä¿®æ”¹æŒ‡å‘ã€‚ç»å¸¸åˆ›å»º dummyæŒ‡é’ˆï¼Œå¦‚æžœhead å¯èƒ½è¢«æ”¹å˜çš„è¯ã€‚ 1234567891011121314151617181920212223242526272829303132# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): """ ä¸‰ä¸ªæŒ‡é’ˆçš„ä¿®æ”¹ï¼Œåº”è¯¥æ˜¯æ²¡æœ‰é—®é¢˜çš„ """ def swapPairs(self, head): """ :type head: ListNode :rtype: ListNode """ if not head: return head dummy=pre =ListNode(-1) dummy.next =head while True: cur =pre.next if not cur: break nex =cur.next if not nex: break pre.next, cur.next, nex.next, pre =nex, nex.next, cur, cur return dummy.next Count and Say The count-and-say sequence is the sequence of integers with the first five terms as following: 1. 1 2. 11 3. 21 4. 1211 5. 111221 1 is read off as &quot;one 1&quot; or 11. 11 is read off as &quot;two 1s&quot; or 21. 21 is read off as &quot;one 2, then one 1&quot; or 1211. Tips: è¿™ä¸ªæ˜¯å±žäºŽå¾ªçŽ¯ï¼Œå­—ç¬¦ä¸²å¤„ç†ã€‚ 12345678910111213141516171819202122232425262728class Solution(object): def doCountAndSay(self, string): char =string[0] num =0 result ="" for c in string: if char ==c: num +=1 else: result += (str(num)+ char) char =c num =1 result += (str(num) +char) return result def countAndSay(self, n): if 0 ==n: return "" elif 1== n: return "1" result ='1' for i in range(1, n): result =self.doCountAndSay(result) return result Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. Tips: ç®—æ³•æ¯”è¾ƒå·§å¦™ï¼Œå·¦å³ä¸¤è¾¹è¿›è¡ŒéåŽ†æ‰¾å‡ºâ€ç´¯è®¡â€œæœ€é«˜ç‚¹ï¼Œåœ¨O(N) æ—¶é—´å†…å®Œæˆã€‚èƒ½è£…çš„æ°´ï¼Œå–å†³äºŽå·¦å³ä¸¤è¾¹( neighbor) çš„å°å€¼- height[i]ã€‚ https://leetcode.com/problems/trapping-rain-water/ 1234567891011121314151617181920212223242526class Solution(object): def trap(self, height): if not height: return 0 len_h =len(height) leftmax=[0]* len_h max_h=0 for i in range(len_h): if height[i] &gt;max_h: max_h =height[i] leftmax[i] =max_h rightmax =[0] *len_h max_h =0 for i in range(len_h-1, -1, -1): if height[i]&gt; max_h: max_h =height[i] rightmax[i] =max_h result =0 for i in range(len_h): result += (min(leftmax[i], rightmax[i])- height[i]) return result Maximum Subarray Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Tips: ä¸€ç»´æ•°ç»„è¿”å›žæœ€å¤§çš„å­æ•°ç»„ï¼Œå­—ç¬¦ä¸²å¤„ç†ã€‚https://leetcode.com/problems/maximum-subarray/ 1234567891011121314151617181920212223class Solution(object): def maxSubArray(self, nums): """ :type nums: List[int] :rtype: int """ len_n =len(nums) if len_n ==1: return nums[0] max_n =nums[0] # å¦‚æžœæå‰åˆå§‹åŒ–ï¼Œé‚£ä¹ˆä¹‹åŽåœ¨æ›´æ–°max_n æ—¶å€™å°±ä¸ç”¨è¿›è¡Œ None çš„åˆ¤æ–­äº† sum_n =0 for num in nums: sum_n += num if sum_n&gt; max_n: max_n =sum_n if sum_n &lt;0: sum_n =0 # continue return max_n Insert Interval Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).You may assume that the intervals were initially sorted according to their start times. Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] Tips: ä½¿ç”¨( 0, 1) åŽ»åŒºåˆ† start, end è¿™ç§ç‚¹ï¼Œç±»ä¼¼ä¸€ç§æ•°æ®ç»“æž„çš„æ ·å­, æŽ’åºä¹‹åŽç»“æžœçš„start index å’Œend index åˆ†åˆ«å‡ºçŽ°åœ¨é¦–æ®µå’Œå°¾æ®µï¼Œä½¿ç”¨æ ˆè¿›è¡Œå­˜å‚¨ start index å°±è¡Œäº†ã€‚https://leetcode.com/problems/insert-interval/ 123456789101112131415161718192021222324252627282930313233343536class Solution(object): def insert(self, intervals, newinterval): """ è¿™ä¸ªæ¯ä¸ªéƒ½æ˜¯æœ‰ æ•°æ®ç±»åž‹çš„ï¼Œè¿™ä¸ªå°±æ˜¯ LeetCode çš„ä¼˜ç‚¹ :type intervals: List[List[int]] :type newInterval: List[int] :rtype: List[List[int]] """ if not intervals: return [newinterval] datas =[] if intervals: datas.append((newinterval[0], 0)) datas.append((newinterval[1], 1)) for interval in intervals: datas.append((interval[0], 0)) datas.append((interval[1], 1)) datas.sort() # sort() æ˜¯ä¸€ä¸ªéªšæ“ä½œ, é»˜è®¤çš„æŽ’åºæ˜¾ç¤ºæ ¹æ® tuple[0] è¿›è¡ŒæŽ’åºï¼Œå¦‚æžœç›¸åŒï¼Œé‚£ä¹ˆæ ¹æ® tuple[1] è¿›è¡ŒæŽ’åº # æ‰€ä»¥æŽ’åœ¨å‰é¢çš„ä¸€å®šæ˜¯ start indexã€‚ merged =[] stack =[datas[0]] for i in range(1, len(datas)): data =datas[i] if data[1] ==0: stack.append(data) elif data[1] ==1: if stack: start =stack.pop() if len(stack) ==0: # è¿™ä¸ªæ—¶å€™ data æ˜¯ end point merged.append((start[0], data[0])) return merged Rotate List Given a linked list, rotate the list to the right by k places, where k is non-negative. Tipsï¼š ç»†èŠ‚åœ¨äºŽk å¯èƒ½å¤§äºŽ list çš„é•¿åº¦ã€‚ 123456789101112131415161718192021222324252627282930313233343536# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def rotateRight(self, head, k): if k ==0: return head if not head: return head # å¤´æŒ‡é’ˆ dummy =ListNode(-1) dummy.next =head p =dummy count =0 while p.next: p =p.next count +=1 # æŒ‡å‘äº†å¤´æŒ‡é’ˆï¼Œè¿žæˆäº†ä¸€ä¸ªçŽ¯ï¼Œä¸‹ä¸€æ­¥å¼€å§‹æ‰¾å¤´æŒ‡é’ˆ p.next =dummy.next step =count -(k% count) for i in range(step): p =p.next # æ‰¾åˆ°äº†å¤´æŒ‡é’ˆï¼Œé‚£ä¹ˆä¸‹ä¸€ä¸ªå°±æ˜¯å°¾æŒ‡é’ˆ head =p.next p.next =None return head Unique Paths A robot is located at the top-left corner of a m x n grid (marked â€˜Startâ€™ in the diagram below).The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked â€˜Finishâ€™ in the diagram below).How many possible unique paths are there? Tipsï¼š æœ€åŽæ±‚è§£çš„æ˜¯unique paths çš„æ•°é‡ï¼Œè€Œä¸æ˜¯å…·ä½“çš„è·¯å¾„ï¼Œæ‰€ä»¥å¯ä»¥ä¸ä½¿ç”¨ dpï¼Œæˆäº†ä¸€é“æ¨¡æ‹ŸæŽ’åˆ—ç»„åˆçš„æ•°å­¦é¢˜ã€‚ 12345678910111213141516171819202122class Solution(object): # è¿™ä¸ªæ€»çš„æ­¥æ•°æ˜¯ä¸€å®šçš„ m+n -1 ï¼Œç„¶åŽä¸‹è¡Œå’Œå³è¡Œä¹Ÿæ˜¯ä¸€å®šçš„ï¼Œ # æ‰€ä»¥è¿™ä¸ªæ˜¯æ¨¡æ‹Ÿçš„â€œæŽ’åˆ—ç»„åˆâ€ çš„æ€æƒ³ def uniquePaths(self, m, n): """ :type m: int :type n: int :rtype: int """ if m ==0 or n ==0: return 1 up =1 # è¿™ä¸ªæ˜¯åˆ†å­ for i in range(m+n-2, n -1, -1): up *=i down =1 # è¿™ä¸ªæ˜¯åˆ†æ¯ for j in range(1, m): down *= j return up/down Sort Colors Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Tips: å¿«æŽ’æ€æƒ³ï¼Œ ä¸­é—´æ•°å­—1 å½“åškey indexï¼Œå·¦å³ä¸¤è¾¹åˆ†åˆ«æ˜¯leftï¼Œright indexã€‚ 1234567891011121314151617class Solution(object): """ 0, 1, 2 (red, white, blue) """ def sortColors(self, nums): # zero and r record the position of "0" and "2" respectively index, two, zero = 0, len(nums) - 1, 0 while index &lt;= two: if nums[index] == 0: nums[index], nums[zero] = nums[zero], nums[index] index += 1; zero += 1 elif nums[index] == 2: nums[index], nums[two] = nums[two], nums[index] two -= 1 else: index += 1 Remove Duplicates from Sorted List II Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Tips: å¸¸è§„é¢˜ï¼Œç»å¸¸å‡ºçŽ°è¿™æ ·çš„é€»è¾‘ï¼Œ ifâ€¦ while ï¼Œå¦‚æžœå‘çŽ°æœ‰é‡å¤çš„ï¼Œé‚£ä¹ˆä¸€ç›´å°±æ‰¾åˆ°ä¸é‡å¤ä¸ºæ­¢ã€‚ 12345678910111213141516171819202122232425262728# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): """ å°±æ˜¯åœ¨åˆ é™¤èŠ‚ç‚¹çš„æ—¶å€™ï¼Œå¦‚æžœhead èŠ‚ç‚¹ä¹Ÿå¾—åˆ é™¤ï¼Œè¿™ä¸ªæ—¶å€™ å¸¸å¸¸åˆ›å»ºä¸€ä¸ª dummy ç»“ç‚¹ æ±‚è§£çš„æ˜¯distinct çš„list """ def deleteDuplicates(self, head): dummy =pre =ListNode(0) dummy.next =head while head and head.next: if head.val ==head.next.val: while head and head.next and head.val ==head.next.val: head =head.next head =head.next pre.next =head else: # è¿™ä¸ªæ›´æ–°å¾ˆæœ‰æ„æ€ï¼Œ head =head.next, pre.next =head pre =pre.next head =head.next return dummy.next Partition List Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.You should preserve the original relative order of the nodes in each of the two partitions. Tips: æ–°å»ºäº†ä¸¤ä¸ªç»“ç‚¹ï¼Œåˆ†åˆ«è¿žæŽ¥å°äºŽ x å’Œä¸å°äºŽ x çš„ç»“ç‚¹ï¼Œæœ€åŽä¸¤ä¸ªç»“ç‚¹ç›¸è¿žã€‚ list æ˜¯ç›´æŽ¥è¿›è¡Œäº¤æ¢ä½ç½®ï¼Œä½†æ˜¯linkedList ä¸æ˜¯è¿™æ ·çš„ã€‚ 123456789101112131415161718192021222324252627282930# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): # å±€éƒ¨æŽ’åºï¼Œä¸æ˜¯å…¨å±€æŽ’åº def partition(self, head, x): """ :type head: ListNode :type x: int :rtype: ListNode """ small =l1 =ListNode(0) great =l2 =ListNode(0) while head: if head.val &lt;x : l1.next =head l1 =l1.next else: l2.next =head l2 =l2.next head =head.next # è¿™ä¸ªæ˜¯ä¸€ä¸ªç»†èŠ‚ï¼Œ æœ€åŽl2 æ˜¯éœ€è¦ä¸€ä¸ªnone è¿›è¡Œç»“æŸæ ‡è®° l2.next =None l1.next =great.next return small.next Reverse Linked List II Reverse a linked list from position m to n. Do it in one-pass.Note: 1 â‰¤ m â‰¤ n â‰¤ length of list. Tips: å±€éƒ¨è¿›è¡Œreverseï¼Œæ‰¾åˆ°è¯¥èŠ‚ç‚¹ï¼Œç„¶åŽè¿­ä»£è¿›è¡Œå°±å¯ä»¥äº†ã€‚ 1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): # The idea is simple and intuitive: find linkedlist [m, n], reverse it, then connect m with n+1, connect n with m-1 def reverseBetween(self, head, m, n): pre =dummy =ListNode(0) dummy.next =head #cur, pre =head, dummy for _ in range(m-1): #cur =cur.next pre =pre.next cur =pre.next for _ in range(n-m): tmp =cur.next cur.next =tmp.next tmp.next =pre.next pre.next =tmp return dummy.next Unique Binary Search Trees Given n, how many structurally unique BSTâ€™s (binary search trees) that store values 1 â€¦ n? Tips: ä»Žå¤„ç†å­é—®é¢˜çš„è§’åº¦æ¥çœ‹ï¼Œé€‰å–ä¸€ä¸ªç»“ç‚¹ä¸ºæ ¹ï¼Œå°±æŠŠç»“ç‚¹åˆ‡æˆå·¦å³å­æ ‘ï¼Œä»¥è¿™ä¸ªç»“ç‚¹ä¸ºæ ¹çš„å¯è¡ŒäºŒå‰æ ‘æ•°é‡å°±æ˜¯å·¦å³å­æ ‘å¯è¡ŒäºŒå‰æ ‘æ•°é‡çš„ä¹˜ç§¯ï¼Œæ‰€ä»¥æ€»çš„æ•°é‡æ˜¯å°†ä»¥æ‰€æœ‰ç»“ç‚¹ä¸ºæ ¹çš„å¯è¡Œç»“æžœç´¯åŠ èµ·æ¥ã€‚ 123456789101112131415161718class Solution(object): # äºŒå‰æœç´¢æ ‘ï¼Œå½“ä¸”ä»…å½“ä¸­åºéåŽ†çš„æ—¶å€™æ˜¯å•è°ƒéžå‡çš„æ—¶å€™ã€‚ # æ•°å­¦é—®é¢˜ def numTrees(self, n): """ :type n: int :rtype: int """ arr =[0]*(n+1) arr[0] =1 for i in range(1, n+1): for j in range(1, i+1): # å¤„ç†çš„æ˜¯å·¦å³å­æ ‘çš„ä¹˜ç§¯ arr[i] += arr[j-1] *arr[i-j] return arr[-1] Best Time to Buy and Sell Stock Say you have an array for which the ith element is the price of a given stock on day i.If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.Note that you cannot sell a stock before you buy one. Tips: è™½ç„¶è¿™ä¸ªè¯´æ˜¯æœ€å¤šä¸€æ¬¡ä¹°å…¥å–å‡ºï¼Œä½†æ˜¯è¿™ä¸ªä»·æ ¼å˜åŒ–æ˜¯â€è¿žç»­â€œçš„ï¼Œæ‰€ä»¥åªè¦æ˜¯ä¸‹ä¸€ä¸ªå¤§äºŽä¸Šä¸€ä¸ªå°±æ˜¯å¯ä»¥ += profit ä¸­çš„ã€‚ 12345678910111213141516class Solution(object): # ä»Žä»£ç ä¸Šæ¥çœ‹ï¼Œæ¯«æ— ç®—æ³•å¯è¨€ def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if not prices or len(prices) ==1: return 0 profit =0 for i in range(1, len(prices)): if prices[i] &gt; prices[i-1]: profit += prices[i]-prices[i-1] return profit Best Time to Buy and Sell Stock II Say you have an array for which the ith element is the price of a given stock on day i.Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Tips: å¯ä»¥è¿›è¡Œå¤šæ¬¡ä¹°å–ã€‚å’Œä¸Šé¢çš„åŒºåˆ«åœ¨äºŽ ä¸‹ä¸€ä¸ªåªè¦ä¸å°äºŽä¸Šä¸€ä¸ªå°±æ˜¯å¯ä»¥ç´¯åŠ çš„ã€‚ 123456789101112131415class Solution(object): # å¯ä»¥å¤šæ¬¡ä¹°å–ï¼Œ ä¹°ä¸€æ¬¡ç„¶åŽå–ä¸€æ¬¡ã€‚ä¸èƒ½å¤šæ¬¡ä¹°å…¥ # è¿™ç§å°±å¦‚åŒå¯»æ‰¾çš„æ˜¯ å¢žåºåˆ—ã€‚ def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ total =0 for i in range(1, len(prices)): if prices[i]&gt;= prices[i-1]: total += prices[i]-prices[i-1] return total Longest Consecutive Sequence Given an unsorted array of integers, find the length of the longest consecutive elements sequence.Your algorithm should run in O(n) complexity. Tipsï¼š è¿™ç§æ–¹æ³•å¾ˆå·§å¦™ï¼Œå¦‚æžœx-1 not inï¼Œé‚£ä¹ˆåŽ» try x+1ï¼Œç„¶åŽè®¡æ•°ã€‚ 123456789101112131415161718class Solution(object): # ç¬¬ä¸€å°è±¡æ˜¯ å…ˆè¿›è¡ŒæŽ’åºï¼Œ ç„¶åŽé€‰æ‹©çš„è¿‡ç¨‹ï¼Œ ä½†æ˜¯é™åˆ¶æ¡ä»¶æ˜¯ O(n) çš„å¤æ‚åº¦ def longestConsecutive(self, nums): """ :type nums: List[int] :rtype: int """ nums =set(nums) best =0 for x in nums: if x-1 not in nums: y =x+1 while y in nums: y +=1 best =max(best, y-x) return best Candy There are N children standing in a line. Each child is assigned a rating value.You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors.What is the minimum candies you must give? Tips: å› ä¸ºæ¶‰åŠåˆ° neighborsï¼Œæ‰€ä»¥å·¦å³ä¸¤è¾¹è¿›è¡ŒéåŽ†ï¼Œå› ä¸ºå¦‚æžœratings å¤§çš„è¯ï¼Œé‚£ä¹ˆç»“æžœä¸€å®šå¾—å¤§ï¼Œæ‰€ä»¥è¿”å›žçš„æ˜¯è¾ƒå¤§è€…ã€‚ 1234567891011121314151617181920class Solution(object): def candy(self, ratings): """ :type ratings: List[int] :rtype: int """ # æ»¡è¶³ç¬¬ä¸€ä¸ªæ¡ä»¶ï¼Œat least one candy res =len(ratings) *[1] # left to right, higher then more candies for i in range(1, len(ratings)): if ratings[i] &gt; ratings[i-1]: # è¿™ä¸ªæ˜¯ä¸¥æ ¼çš„ &gt; res[i] = res[i-1] +1 # right to left, higher then more candy, neighbors for i in range(len(ratings)-1, 0, -1): if ratings[i-1] &gt; ratings[i]: res[i-1] =max(res[i-1], res[i] +1) return sum(res) Single Number Given a non-empty array of integers, every element appears twice except for one. Find that single one. Tips: å¼‚æˆ–çš„æ€§è´¨ 1234567891011121314class Solution(object): # åˆ†åˆ†é’Ÿ å¼‚æˆ–å°±å‡ºæ¥äº† # integers, -2 -1 0 1 2 è¿™æ ·çš„æ•°å­— def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ standard =0 # å¦‚æžœæ­£å¥½æ˜¯å…¶ä¸­çš„ 0 å‡ºçŽ°ä¸€æ¬¡ï¼Œä¹Ÿæ˜¯æ²¡æœ‰å…³ç³»çš„ï¼Œ å› ä¸ºåˆå§‹åŒ–çš„ 0 å’Œ list ä¸­çš„å•æ•° 0 æ­£å¥½åŒ¹é…ï¼Œå¼‚æˆ–æ“ä½œä¹‹åŽç›¸åŒä¸º 0 # ç»“æžœä¸Šæ˜¯æ²¡æœ‰ä»€ä¹ˆé—®é¢˜çš„ for num in nums: standard = num^ standard return standard Single Number II Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one. Tipsï¼šè¿™ä¸ª three timesä¸èƒ½ä½¿ç”¨ å¼‚æˆ–ï¼Œä»ŽäºŒè¿›åˆ¶çš„è§’åº¦è¿›è¡Œè€ƒè™‘ï¼Œä»¥äºŒè¿›åˆ¶çš„å½¢å¼ï¼Œå°†æ•°å­—å­˜å‚¨èµ·æ¥ï¼Œå¦‚æžœæ˜¯å‡ºçŽ°äº† 3æ¬¡ï¼Œé‚£ä¹ˆ %3 ç»“æžœå°±æ˜¯0ï¼Œæœ€åŽåªæ˜¯å‰©ä¸‹äº† é‚£ä¸ªå‡ºçŽ°ä¸€æ¬¡çš„æ•°å­— 1234567891011121314151617181920212223242526class Solution(object): # åªæ˜¯å‡ºçŽ°çš„ä¸€ä¸ªçš„single oneï¼Œ å…¶ä»–çš„å‡ºçŽ°ä¸‰æ¬¡ # var |= value is short for var = var | value def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ bit = [0] * 32 for num in nums: for i in range(32): bit[i] += num &gt;&gt; i &amp; 1 # è¿™ä¸ªå°±æ˜¯ä»Žå·¦å¾€å³çš„é¡ºåºï¼Œå…ˆæ˜¯è¿›è¡Œ &gt;&gt; è¿ç®—ï¼Œç„¶åŽæ˜¯ &amp; è¿ç®— # å¯ä»¥æƒ³è±¡è¿™ä¸ªé‡å¤è®¡ç®—æ¯”è¾ƒå¤šï¼Œå› ä¸ºæ¯æ¬¡éƒ½éœ€è¦ num &gt;&gt; i è¿›è¡Œä½è¿ç®— res = 0 for i, val in enumerate(bit): # if the single numble is negative, # this case should be considered separately , è¡¥ç  å’ŒåŽŸç çš„è½¬æ¢å…³ç³» if i == 31 and val % 3: res = -((1 &lt;&lt; 31) - res) else: res |= (val % 3) * (1 &lt;&lt; i) # | è¿™ä¸ªæ˜¯ä½æ“ä½œï¼Œæ›´åŠ ç±»ä¼¼ä¸æ–­çš„å– 1 çš„è¿‡ç¨‹ï¼Œ ç„¶åŽå’Œè¯¥ä½ç½®çš„æƒé‡ç›¸ä¹˜ return res Copy List with Random Pointer A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.Return a deep copy of the list. Tipsï¼šåœ¨å‰‘æŒ‡offer ä¸Šæ˜¯é€šè¿‡ æŒ‡é’ˆæ“ä½œè¿›è¡Œåšé¢˜ï¼Œä½†æ˜¯ä½¿ç”¨ defaultdict åŸºæœ¬ä¸Šå°±ä¸ç”¨å‡ºï¼Œä½¿ç”¨dict æ¥å¤„ç†è¿™ç§å…³ç³»ï¼Œæœ€åŽè¿”å›žçš„æ˜¯æ ¹èŠ‚ç‚¹ã€ 123456789101112131415161718192021222324252627282930"""# Definition for a Node.class Node(object): def __init__(self, val, next, random): self.val = val self.next = next self.random = random"""# ä½¿ç”¨dict æœ‰æ²¡æœ‰æ„Ÿè§‰åœ¨ä½œå¼Šclass Solution(object): # åšè¿‡è¿™ä¸ª def copyRandomList(self, head): """ :type head: Node :rtype: Node """ import ipdb dic = collections.defaultdict(lambda: Node(0, None, None)) # è¿™ä¸ªå°±æ˜¯ç»™å®šäº†ä¸€ä¸ªé»˜è®¤çš„å€¼, ç›´æŽ¥åˆå§‹åŒ–dict ä¸­çš„value ä¸ºè¿™ä¸ªnode # dict çš„æœ¬èº«å°±æ˜¯å­˜å‚¨ä¸€ç§node çš„å…³ç³»ï¼Œæ‰€ä»¥dict[n].val , next, random å¯ä»¥è¿™æ ·è¿›è¡Œæ“ä½œ dic[None] = None n = head while n: dic[n].val = n.val dic[n].next = dic[n.next] dic[n].random = dic[n.random] n = n.next #ipdb.set_trace() return dic[head] Linked List Cycle Given a linked list, determine if it has a cycle in it.To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Tipsï¼šå¿«æ…¢ä¸¤ä¸ªæŒ‡é’ˆçš„é—®é¢˜ï¼Œç»™äº†ä¸¤ç§æ–¹æ³•æ¥å®žçŽ°ã€‚ 1234567891011121314151617181920212223242526272829303132333435# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): # O(1) == constant memory, def hasCycle(self, head): """ :type head: ListNode :rtype: bool """ ''' # è¿™ç§ä¸ç”¨è¿›è¡Œåˆ¤æ–­ fast æ˜¯å¦å¯ä»¥è®¿é—®çš„åŽŸå› åœ¨äºŽ try except çš„ä½¿ç”¨ try: slow = head fast = head.next while slow is not fast: slow = slow.next fast = fast.next.next return True except: return False ''' # è¿™ä¸ªæ˜¯æ¯”è¾ƒä¸­è§„ä¸­çŸ©çš„å†™æ³• slow = fast = head # æ³¨æ„ä½¿ç”¨çš„æ˜¯ fastè¿›è¡Œåˆ¤æ–­ï¼Œå› ä¸ºè¿™ä¸ªèµ°çš„å¿« while fast and fast.next: fast = fast.next.next slow = slow.next if slow == fast: return True return False Reorder List Given a singly linked list L: L0â†’L1â†’â€¦â†’Ln-1â†’Ln,reorder it to: L0â†’Lnâ†’L1â†’Ln-1â†’L2â†’Ln-2â†’â€¦You may not modify the values in the listâ€™s nodes, only nodes itself may be changed. Tipsï¼š ä»Žä¸­é—´æ–­å¼€ï¼ŒåŽåŠéƒ¨åˆ†ç¿»è½¬ï¼Œç„¶åŽå’Œå‰åŠéƒ¨åˆ†è½®æµè¿žæŽ¥ 12345678910111213141516171819202122232425262728293031323334353637383940414243# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reorderList(self, head): """ :type head: ListNode :rtype: None Do not return anything, modify head in-place instead. """ if not head: return fast, slow = head.next, head # first part has the same or one more node while fast and fast.next: fast = fast.next.next slow = slow.next # reverse the send half p = slow.next slow.next = None node = None # ç±»ä¼¼ä¸Šä¸€ä¸ªç»“ç‚¹ï¼Œ p æ˜¯cur çš„ç»“ç‚¹ while p: nex = p.next p.next = node node = p p = nex # combine head part and node part p = head while node: tmp = node.next node.next = p.next # ä¸¤ä¸ª next æŒ‡å‘æ“ä½œ, éœ€è¦next ä¸¤æ¬¡ p.next = node p =p.next.next node = tmp ** Majority Element Given an array of size n, find the majority element. The majority element is the element that appears more than âŒŠ n/2 âŒ‹ times. Output: 2Input: K = 1, N = 2Explanation:Drop the egg from floor 1. If it breaks, we know with certainty that F = 0.Otherwise, drop the egg from floor 2. If it breaks, we know with certainty that F = 1.If it didnâ€™t break, then we know with certainty F = 2.Hence, we needed 2 moves in the worst case to know what F is with certainty. Tips: å¯ä»¥æŸ¥çœ‹ solution ä¸­çš„(è®²è§£)[https://leetcode.com/problems/super-egg-drop/] 123456789101112131415161718class Solution(object): def majorityElement(self, nums): """ :type nums: List[int] :rtype: int """ # åˆå§‹åŒ– counts =0 for num in nums: if counts ==0: majority =num counts =1 elif majority ==num: counts +=1 else: counts -=1 return majority Maximum Product Subarray Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Tips: åœ¨äºŽå·¦å³ä¸¤ééåŽ†ï¼Œåˆ†åˆ«å¾—åˆ° prefixå’Œ suffix çš„ä¹˜ç§¯ã€‚è¿™ä¸ªé€Ÿåº¦ä¸Šæ¯”è¾ƒå¿«åœ¨äºŽå­˜å‚¨äº†ä¹‹å‰çš„ç»“æžœã€‚å®žçŽ°çš„æ—¶å€™åˆ©ç”¨äº† 1 or prefix[i-1] è¿™ç§æŠ€å·§ã€‚ 12345678910111213class Solution(object): def maxProduct(self, nums): """ :type nums: List[int] :rtype: int """ prefix =nums suffix =prefix[::-1] for i in range(1, len(prefix)): prefix[i] *= 1 or prefix[i-1] suffix[i] *= 1 or suffix[i-1] return max(prefix+ suffix) Majority Element Given an array of size n, find the majority element. The majority element is the element that appears more than âŒŠ n/2 âŒ‹ times. You may assume that the array is non-empty and the majority element always exist in the array. Tips: majority çš„counts çš„æ€»æ•°æ˜¯å¤§äºŽå…¶ä»–æ‰€æœ‰countsç›¸åŠ ä¹‹å’Œçš„ 123456789101112131415161718class Solution(object): def majorityElement(self, nums): """ :type nums: List[int] :rtype: int """ majority =None counts =0 for num in nums: if not majority or counts ==0: majority =num counts =1 elif num ==majority: counts +=1 else: counts -=1 return majority Rotate Array Given an array, rotate the array to the right by k steps, where k is non-negative. Tipsï¼š å¯¹äºŽpython è€Œè¨€ï¼Œæ˜¯ä¸å­˜åœ¨åˆ‡åˆ†å­—ç¬¦ä¸²ç®—æ³•çš„ï¼Œä¸€æ­¥æ“ä½œã€‚å°çš„ç»†èŠ‚æ˜¯ k %len(array) æ›´åŠ åˆç† 12345678910111213class Solution(object): def rotate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: None Do not return anything, modify nums in-place instead. """ # è¿™ä¸ªin-place æ“ä½œæ˜¯ä¸éœ€è¦ return k =k%len(nums) # è¿™ä¸ªæ˜¯ä¸€ä¸ªç»†èŠ‚å§ #nums[:] =nums[-k:] +nums[:k+1] nums[:] =nums[-k:] +nums[:-k] # å·¦è¾¹æœ‰æ—¶å€™æ˜¯nums å°±è¡Œï¼Œæœ‰æ—¶å€™å¿…é¡»nums[:] è¡¨ç¤ºindexçš„æ“ä½œï¼Œå› ä¸ºçŽ¯å¢ƒçš„é—®é¢˜ # è¿™ç§ å¯¹ç§°çš„åˆ‡åˆ†çœŸçš„æ˜¯æ¯”è¾ƒå¥½çœ‹ Contains Duplicate Given an array of integers, find if the array contains any duplicates.Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Tips: æœ‰å¾ˆå¤šç§æ–¹æ³•ï¼Œæ¯”å¦‚ dictionary or setï¼Œè¿™ä¸ªç®€å•ä¹‹å¤„æœ€åŽè¿”å›žçš„æ˜¯ true or falseï¼Œä¸æ˜¯è¦æ‰¾å‡ºæ¥ã€‚ æ–¹æ³•ä¸€ï¼šä½¿ç”¨setï¼Œæ ¹æ®lengthåˆ¤æ–­ã€‚ 1234567891011class Solution(object): def containsDuplicate(self, nums): """ :type nums: List[int] :rtype: bool """ # æƒ³æ³•ä¸€ï¼ŒæŽ’åºä¹‹åŽåˆ¤æ–­ï¼Œ # æƒ³æ³•äºŒï¼šä½¿ç”¨dictionary, åœ¨å»ºç«‹çš„è¿‡ç¨‹ä¸­å°±å¯ä»¥åˆ¤æ–­ï¼Œæ²¡æœ‰å¿…è¦å»ºç«‹å®Œä¹‹åŽéåŽ†ï¼Œfrom collections import Counter # æƒ³æ³•ä¸‰ï¼š ä½¿ç”¨setï¼Œé“ç†å’Œdictionary åŸºæœ¬ä¸Šæ˜¯ç›¸åŒçš„ return len(nums) !=len(set(nums)) æ–¹æ³•äºŒï¼šä½¿ç”¨dictionaryï¼Œä¸éœ€è¦å»ºå®Œä¹‹åŽå†åˆ¤æ–­ã€‚ Â·Â·Â·pythonclass Solution(object): def containsDuplicate(self, nums): â€œâ€â€ :type nums: List[int] :rtype: bool â€œâ€â€ dic ={} for num in nums: if num in dic: return True else: dic[num] =1 return False 12345678910111213141516171819202122232425** Move Zeroes **&gt; Given an array nums, write a function to move all 0&apos;s to the end of it while maintaining the relative order of the non-zero elements.&gt; Input: [0,1,0,3,12]Output: [1,3,12,0,0]Tips: åŒæŒ‡é’ˆé—®é¢˜ï¼Œpre æŒ‡å‘çš„æ˜¯0 ï¼Œindexæ˜¯éåŽ†çš„å‘çŽ°å¦‚æžœä¸æ˜¯0ï¼Œé‚£ä¹ˆè¿›è¡Œæ“ä½œ```pythonclass Solution(object): def moveZeroes(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: None Do not return anything, modify nums in-place instead. &quot;&quot;&quot; # in-place æ“ä½œ pre = 0 for index in range(0, len(nums)): if nums[index]: if not nums[pre]: nums[index], nums[pre] =nums[pre], nums[index] pre +=1 Shuffle an Array Shuffle a set of numbers without duplicates. Tips: ä½¿ç”¨åº“å‡½æ•°randomintï¼Œ æœ‰ shuffle å’Œreset ä¸¤ç§æ“ä½œï¼Œå‰è€…ä½¿ç”¨randomint å¯ä»¥å¾—åˆ°ä¸€ä¸ªnumberï¼ŒåŽè€…ä½¿ç”¨ list å¤‡ä»½ã€‚ 12345678910111213141516171819202122232425class Solution(object): def __init__(self, nums): self.original =nums[:] self.nums =nums def reset(self): self.nums =self.original[:] # è¿™ä¸ªåº”è¯¥ id() æ˜¯ä¸åŒçš„ return self.nums def shuffle(self): tmp =self.nums[:] for i in range(len(self.nums)): rand =random.randint(0, len(tmp)-1) self.nums[i] =tmp[rand] del tmp[rand] return self.nums # Your Solution object will be instantiated and called as such:# obj = Solution(nums)# param_1 = obj.reset()# param_2 = obj.shuffle() Intersection of Two Arrays II Given two arrays, write a function to compute their intersection. https://leetcode.com/problems/intersection-of-two-arrays-ii/ Tips: å¤šçœ‹çœ‹é¢˜æ„ï¼Œå¦‚æžœæƒ³è¦æ˜ å°„æˆdictionaryï¼Œé‚£ä¹ˆresult å°±æ˜¯ min(dict1[i], dict1[j]), ä¸¤ä¸ªdictionary ä¸­values çš„æœ€å°å€¼ã€‚ 123456789101112131415161718class Solution(object): def intersect(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: List[int] """ # å­˜å‚¨dict ç„¶åŽå¦‚æžœéƒ½å­˜åœ¨ï¼Œé‚£ä¹ˆé€‰æ‹©values è¾ƒå°è€… ä¸ºå¥½ # è¯´ä¸€ä¸‹å‡ ç§ä¸åŒçš„æ€è·¯ dic1 =collections.Counter(nums1) res =[] for num in nums2: if dic1[num] &gt;0: res += [num] dic1[num] -=1 return res Increasing Triplet Subsequence Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array. Input: [1,2,3,4,5]Output: true Tips: é¦–å…ˆå­¦ä¼šåœ¨python ä¸­è¡¨ç¤ºæœ€å¤§æ•°å­—(float(â€˜infâ€™)), ç„¶åŽè¿™ä¸ªæŠ€å·§ç›¸å½“äºŽé€‰æ‹©æŽ’åºä¸­ä¸€æ¬¡éåŽ†é€‰æ‹©æœ€å°çš„é‚£ä¸ªã€‚ä»£ç æ¯”è¾ƒç®€æ´å“ˆ 12345678910111213141516class Solution(object): def increasingTriplet(self, nums): """ :type nums: List[int] :rtype: bool """ first = second = float('inf') for n in nums: if n &lt;= first: first = n elif n &lt;= second: second = n else: return True return False Product of Array Except Self Given an array nums of n integers where n &gt; 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Tips:å·¦å³ä¸¤éï¼Œè¿™ä¸ªæ˜¯ä¸€ç»´çš„è¿˜æ˜¯æ¯”è¾ƒniceï¼Œæ¢æˆ m*n ä¹Ÿæ˜¯åŸºæœ¬çš„æ€è·¯å§ã€‚ 12345678910111213141516171819202122class Solution(object): def productExceptSelf(self, nums): """ :type nums: List[int] :rtype: List[int] """ # æˆ‘è®°å¾—ä½¿ç”¨ä¸€ä¸ªæ•°ç»„å­˜å‚¨èµ·æ¥ä¸­é—´çš„ç»“æžœï¼Œç„¶åŽè¿›è¡Œæ“ä½œçš„ len_n =len(nums) res =[1] *len_n # from left to right for i in range(1, len_n): res[i] =res[i-1] * nums[i-1] tmp =1 # from right to left for i in range(len_n-2, -1, -1): tmp *= nums[i+1] res[i] *= tmp return res Min Stack Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) â€“ Push element x onto stack. pop() â€“ Removes the element on top of the stack. top() â€“ Get the top element. getMin() â€“ Retrieve the minimum element in the stack. Tips: ä½¿ç”¨ä¸¤ä¸ªlistï¼Œåœ¨push å’Œpop çš„æ—¶å€™è¦ç»´æŠ¤æ ˆï¼Œå§‹ç»ˆä¿æŒè¿™stack[-1] æ˜¯æœ€å°å€¼ã€‚getMin() å°±ç›´æŽ¥è°ƒç”¨ç»“æžœå°±è¡Œã€‚ https://leetcode.com/problems/min-stack/ 123456789101112131415161718192021222324252627class MinStack(object): def __init__(self): self.stack =[] self.min =[] def push(self, x): if not self.min: self.min.append(x) else: if x &lt;= self.min[-1]: self.min.append(x) self.stack.append(x) def pop(self): tmp =self.stack.pop() # è¿™ä¸ªæ˜¯åˆç†çš„ï¼Œå› ä¸ºåªæœ‰pop æŽ‰äº†æœ€å°å€¼ï¼Œç„¶åŽ min list æ‰éœ€è¦æ”¹å˜ï¼Œä¹‹å‰min list ä¹Ÿåªæ˜¯å­˜å‚¨çš„æœ€å°å€¼åºåˆ— if tmp ==self.min[-1]: self.min.pop() def top(self): return self.stack[-1] def getMin(self): return self.min[-1] Kth Largest Element in an Array Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Tips: è¿™ä¸ªå¾ˆå·§å¦™ï¼Œæ˜¯å¿«æŽ’çš„æ€æƒ³ï¼Œæ¯ä¸€æ¬¡çš„pivot æ˜¯ä¸æ˜¯ç¬¬ Kå¤§ã€‚ 12345678910111213141516171819202122232425262728293031323334353637class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ left, right =0, len(nums)-1 while True: index = self.partition(nums, left, right) if index ==k-1: return nums[index] elif index &lt; k-1: left =index+1 else: right =index -1 def partition(self, nums, left, right): pivot =nums[left] p1, p2 =left+1, right #æ‰¾å‡º pivot è¿™ä¸ªnumber çš„ä½ç½® while p1 &lt;=p2: if nums[p1] &lt; pivot and nums[p2]&gt; pivot: nums[p1], nums[p2] =nums[p2], nums[p1] p1 +=1 p2 -=1 elif nums[p1] &gt;= pivot: p1 +=1 elif nums[p2] &lt;=pivot: p2 -=1 nums[left], nums[p2] =nums[p2] , nums[left] return p2 Min Stack Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) â€“ Push element x onto stack. pop() â€“ Removes the element on top of the stack. top() â€“ Get the top element. getMin() â€“ Retrieve the minimum element in the stack. Tips: éœ€è¦ç»´æŒä¸¤ä¸ªstackï¼Œ ä¸€ä¸ªæ˜¯æ—¥å¸¸çš„ï¼Œä¸€ä¸ªæ˜¯min_stakc, åœ¨push or pop çš„è¿‡ç¨‹ä¸­éœ€è¦æ—¥å¸¸æ€§ç»´æŠ¤ min_stack . 123456789101112131415161718192021222324252627class MinStack(object): def __init__(self): self.stack =[] self.min =[] def push(self, x): if not self.min: self.min.append(x) else: if x &lt;= self.min[-1]: self.min.append(x) self.stack.append(x) def pop(self): tmp =self.stack.pop() # è¿™ä¸ªæ˜¯åˆç†çš„ï¼Œå› ä¸ºåªæœ‰pop æŽ‰äº†æœ€å°å€¼ï¼Œç„¶åŽ min list æ‰éœ€è¦æ”¹å˜ï¼Œä¹‹å‰min list ä¹Ÿåªæ˜¯å­˜å‚¨çš„æœ€å°å€¼åºåˆ— if tmp ==self.min[-1]: self.min.pop() def top(self): return self.stack[-1] def getMin(self): return self.min[-1] Kth Largest Element in an Array Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Tipsï¼š å¿«æŽ’ä¸­çš„ pivot å¦‚æžœæ°å¥½æ˜¯ è¿™ä¸ª kthï¼Œé‚£ä¹ˆå°±æˆäº†ã€‚å› ä¸ºå¿«æŽ’ä»¥ pivot ä¸ºåˆ†ç•Œç‚¹ï¼Œå·¦è¾¹æ˜¯å¤§äºŽï¼Œå³è¾¹æ˜¯å°äºŽï¼ˆå‡è®¾æ˜¯é€’å‡æŽ’åºçš„è¯ï¼‰ï¼›ä½¿ç”¨äºŒåˆ†çš„æ–¹æ³•ï¼ŒåŽ»å¯»æ‰¾è¿™ä¸ª pivotã€‚å±žäºŽä¸€é“æ¯”è¾ƒå¥½çš„é¢˜ç›®ã€‚ Â·Â·Â·pythonclass Solution(object): # å®žé™…ä¸Šæ˜¯åœ¨è¯•æŽ¢ å¿«æŽ’ä¸­pivot è¿™ä¸ªç‚¹æ˜¯å¦æ˜¯ç¬¬k å¤§å€¼ def findKthLargest(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; left, right =0, len(nums)-1 while True: index = self.partition(nums, left, right) if index ==k-1: return nums[index] elif index &lt; k-1: left =index+1 else: right =index -1 def partition(self, nums, left, right): pivot =nums[left] p1, p2 =left+1, right #æ‰¾å‡º pivot è¿™ä¸ªnumber çš„ä½ç½® while p1 &lt;=p2: if nums[p1] &lt; pivot and nums[p2]&gt; pivot: nums[p1], nums[p2] =nums[p2], nums[p1] p1 +=1 p2 -=1 elif nums[p1] &gt;= pivot: p1 +=1 elif nums[p2] &lt;=pivot: p2 -=1 nums[left], nums[p2] =nums[p2] , nums[left] return p2 12345678910111213141516171819202122232425262728** Top K Frequent Elements**&gt; Given a non-empty array of integers, return the k most frequent elements. Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2]Tips: å¦‚æžœæ˜¯ä½¿ç”¨ dictionary è¿›è¡Œè®¡æ•°ï¼Œé‚£ä¹ˆç›´æŽ¥è°ƒç”¨ counter æ˜¯ä¸€ä¸ªä¸é”™çš„é€‰æ‹©ï¼› ä¸‹é¢æ˜¯è¶…çº§niceçš„ä»£ç ã€‚```pythonclass Solution(object): # ä¸€ç§å¾ˆç®€å•çš„æ–¹æ³•ï¼Œå°±æ˜¯æ”¾åˆ°dictionary ä¸­ï¼Œç„¶åŽæ ¹æ®valuesä»Žå¤§åˆ°å°æŽ’åºï¼Œç„¶åŽè¿”å›žç›¸åº”çš„keys # python ä¸­çš„ sort() å‡½æ•°é»˜è®¤æ˜¯ä»Žå°åˆ°å¤§è¿›è¡ŒæŽ’åºçš„ def topKFrequent(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: List[int] &quot;&quot;&quot; from collections import Counter # æœ¬è´¨ä¸Šå°±æ˜¯ä¸€ä¸ªdictionary freq =Counter(nums) # è¿™ä¸ªdictionaryï¼Œ ç„¶åŽè®¿é—®çš„æ—¶å€™freq æ“ä½œçš„æ˜¯é”®ï¼Œç„¶åŽfreq[x] æ˜¯å€¼ #counters =sorted(counters, key =counters[1], reverse =True) uniques=sorted(freq,key=lambda x:freq[x],reverse=True) # æœ€åŽè¿”å›žæ˜¯ä¸€ä¸ªlistï¼Œåªæ˜¯æŒ‰ç…§value è¿›è¡ŒæŽ’åºï¼Œè¿”å›žçš„æ˜¯keyçš„åˆ—è¡¨ return uniques[:k] 4Sum II Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.To make problem a bit easier, all A, B, C, D have same length of N where 0 â‰¤ N â‰¤ 500. All integers are in the range of $-2^{28} $ to$ 2^{28} - 1 $ and the result is guaranteed to be at most $2^{31} - 1$. Tips: æ€è·¯å’Œ 2 sum æ˜¯ä¸€æ ·ï¼Œæ”¾åˆ°dictionary ä¸­åŽ»ã€‚defaultdict å’Œdict çš„å”¯ä¸€å·®åˆ«åœ¨äºŽå‰è€…ä¸ç”¨è®°æ€§ key in dict çš„åˆ¤æ–­ã€‚ 12345678910111213141516171819202122232425class Solution(object): def fourSumCount(self, A, B, C, D): from collections import defaultdict length, dic, res =len(A), defaultdict(int), 0 for a in A: for b in B: dic[a+b] +=1 """ if a+b not in dic: dic[a+b] =1 else: dic[a+b] +=1 """ for c in C: for d in D: if -(c+d) in dic: res += dic[-(c+d)] return res Sliding Window Maximum Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Tips: æ»‘åŠ¨çª—å£ï¼Œç„¶åŽçª—å£ä¸­çš„max(). è°èƒ½æƒ³å¾—åˆ° python æ˜¯æ“…é•¿å¤„ç† listï¼Œç„¶åŽmax() å‡½æ•°å°±è§£å†³äº†å‘¢ 1234567891011121314class Solution(object): def maxSlidingWindow(self, nums, k): """ :type nums: List[int] :type k: int :rtype: List[int] """ if nums ==[]: return () res =[] for i in range(len(nums)-k +1): res.append(max(nums[i:i+k])) return res The Skyline Problem A cityâ€™s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B). Tips: å…³é”®ç‚¹å°±æ˜¯è®°å½•ï¼š è½®å»“ä¸Šå‡å’Œè½®å»“ä¸‹é™çš„ç‚¹ï¼Œåˆ†åˆ«å¯¹åº”ç€ left çš„ä¸Šå‡å’Œ right çš„ä¸‹é™ã€‚è¯„è®ºåŒºè®²è§£ï¼Œè™½ç„¶æ¯”è¾ƒéš¾çœ‹æ‡‚ https://leetcode.com/problems/the-skyline-problem/ 12345678910111213141516171819202122232425262728293031323334from heapq import heappush, heappopclass Solution(object): def getSkyline(self, buildings): """ :type buildings: List[List[int]] :rtype: List[List[int]] """ events =[ (left, -height, right) for left, right, height in buildings] events += list((right, 0, 0) for _, right, _ in buildings) events.sort() # å…ˆæ˜¯æŒ‰ç…§left å‡åºæŽ’åºï¼Œç„¶åŽæ˜¯ right é™åºæŽ’åº( è¿™ä¸ªå°±æ˜¯ä¸ºä»€ä¹ˆæ—¶å€™ -right) res =[[0, 0]] # æœ€å°å †ï¼Œä¿å­˜å½“å‰æœ€é«˜çš„è½®å»“ (-Height, right)ï¼Œ ä½¿ç”¨-H è½¬æ¢æˆæœ€å¤§å †ï¼ŒR çš„ä½œç”¨æ˜¯è®°å½•è½®å»“çš„æœ‰æ•ˆé•¿åº¦ heap =[(0, float('inf'))] for left, height, right in events: # å¦‚æžœè½®å»“ä¸Šå‡ if height: heappush(heap, (height, right)) while heap[0][1] &lt;=left: heappop(heap) if res[-1][1] != -heap[0][0]: res += [[left, -heap[0][0]]] return res[1:] Wiggle Sort II Given an unsorted array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]â€¦. Tips: ç®—æ³•é¢˜ç›®è¢« python ä¸­çš„lsit æ“ä½œç»™æ¯äº†, å¯ä»¥å­¦ä¹ ä»¥ä¸‹ list[::-1], list[::2], è¿™ç§æ˜¯æ¨¡å¼åŒ–çš„æ“ä½œï¼Œä¸æ˜¯å¶ç„¶ã€‚ 12345678910111213141516class Solution(object): def wiggleSort(self, nums): """ :type nums: List[int] :rtype: None Do not return anything, modify nums in-place instead. """ #nums.sort() #half =len(nums)/2 #nums[::2], nums[1::2] =nums[:half][::-1], nums[half:][::-1] nums.sort() half = len(nums[::2]) # æ³¨æ„è¿™ä¸ªæ˜¯ half å¿…é¡»æ˜¯è¿™æ ·å†™çš„ # è¿™é‡Œé¢å€’è¿‡æ¥çš„åŽŸå› ï¼Œ å‰åŠä¸ªæ°¸è¿œä¸å¤§äºŽåŽåŠä¸ªï¼Œæ‰€ä»¥è¿™æ ·èƒ½ä¿è¯ æ³¢åŠ¨ nums[::2], nums[1::2] = nums[:half][::-1], nums[half:][::-1] Find Peak Element A peak element is an element that is greater than its neighbors.Given an input array nums, where nums[i] â‰  nums[i+1], find a peak element and return its index. Input: nums = [1,2,3,1]Output: 2Explanation: 3 is a peak element and your function should return the index number 2. Tips: äºŒåˆ†æŸ¥æ‰¾ï¼Œ å¦‚æžœæ˜¯ä¸¤ä¸ª if é‚£ä¹ˆå°±æ˜¯ä¸¤ä¸ªæ­¥éª¤ï¼Œå¦‚æžœ if else é‚£ä¹ˆå°±æ˜¯ä¸€ç§é€‰æ‹©ã€‚ç»™å®šçš„æ¡ä»¶ä¸­ç›¸é‚»çš„å…ƒç´ æ˜¯ä¸ç›¸åŒçš„ã€‚æ‰¾åˆ°ä¸€ä¸ªè§£è¿›è¡Œäº†ã€‚ã€‚ https://leetcode.com/problems/find-peak-element/ 123456789101112131415161718192021class Solution(object): def findPeakElement(self, nums): """ :type nums: List[int] :rtype: int """ if not nums: return -1 if len(nums) ==1: return 0 left, right =0, len(nums)-1 while left &lt; right: mid =(left +right) /2 if nums[mid] &gt; nums[mid+1]: right =mid elif nums[mid] &lt; nums[mid+1]: left =mid +1 return left Find the Duplicate Number Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Tips: æœ‰ä¸¤ç§æ€è·¯ã€‚ä¸€ç§æ˜¯äºŒåˆ†æ³•ï¼Œä¸€ç§æ˜¯ä¸¤ä¸ª pointer çš„æ–¹æ³•ã€‚åŽè€…ç±»ä¼¼linked list ä¸­çš„æ“ä½œã€‚å¥½å¥½çœ‹çœ‹ä»£ç ï¼Œ fast =nums[nums[fast]] è¿™ä¸ªæ“ä½œå°±æ˜¯ fast =fast.next.next æœ‰æœ¨æœ‰å¾ˆç¥žå¥‡çš„æ ·å­ã€‚ Â·Â·Â·pythonclass Solution(object): # æ„Ÿè§‰è¿™ä¸ªä»Žæ—¶é—´å’Œç©ºé—´å¤æ‚åº¦ä¸Šé™åˆ¶çš„å¥½å¤šå‘€ï¼Œå¦‚æžœæ»¡è¶³è¿™ä¸¤ä¸ªç»´åº¦çš„ï¼Œä¸€èˆ¬æ˜¯å…ˆè¿›è¡ŒæŽ’åºï¼ŒOï¼ˆnlgnï¼‰ æ—¶é—´ï¼Œç„¶åŽéåŽ†æ‰¾å‡ºé‡å¤çš„æ•°å­— # åŸºæœ¬ä¸Šæœ‰ä¸¤ç§æ€è·¯ï¼Œä¸€ç§æ˜¯ index(faster, slower point)ï¼Œ ä¸€ç§æ˜¯äºŒåˆ†æ³• # æ ¹æ® indics æ˜¯æœ‰åºçš„ï¼Œç„¶åŽä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾ # The array is not sorted - but the indices of the array are sorted - #Insight &apos;&apos;&apos; def findDuplicate(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if len(nums) == 0: return 0 low = 0 high = len(nums)-1 # éœ€è¦è®¿é—®ä¸¤ä¸ªæŒ‡é’ˆ while low &lt; high: mid = low + int((high-low)&gt;&gt;1) count = 0 for x in nums: if x &lt;= mid: count = count + 1 if count &gt; mid: high = mid else: low = mid+1 return low &apos;&apos;&apos; # è¿™ä¸¤ç§æ–¹æ³•çš„æ ¹æœ¬ä¾æ®æ˜¯ é•¿åº¦ä¸ºn åŒ…å«n+1 ä¸ªæ•´æ•°ï¼Œå¹¶ä¸”åªæœ‰ä¸€ä¸ª duplicate def findDuplicate(self, nums): slow = fast = finder = 0 while True: slow = nums[slow] fast = nums[nums[fast]] if slow == fast: while finder != slow: finder = nums[finder] slow = nums[slow] return finder 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960** Count of Smaller Numbers After Self**&gt; You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].&gt; Input: [5,2,6,1]Output: [2,1,1,0] Explanation:To the right of 5 there are 2 smaller elements (2 and 1).To the right of 2 there is only 1 smaller element (1).To the right of 6 there is 1 smaller element (1).To the right of 1 there is 0 smaller element.Tips: è¿™ä¸ªæœ¬èº«çš„åº”ç”¨è¿˜æ˜¯æŒºæœ‰æ„æ€çš„ã€‚python ä¸­çš„åº“å‡½æ•°bisort (binary sort) äº†è§£ä¸€ä¸‹ã€‚é€†åºéåŽ†ï¼Œæ‰¾åˆ°åˆé€‚çš„ä½ç½®ï¼Œæ’è¿›åŽ»ï¼Œç„¶åŽindex è®¡æ•°ã€‚```pythonclass Solution(object): # The problem is equal to find each number&apos;s inversion count. Actually there are three kinds of solutions: BST, mergeSort, and BITree. While the first two answer&apos;s time complexity is O(nlogn), and BITree time comlexity is O( nlog(maximumNum) ). # å¤ªéš¾äº† # ä¸¤ç§è§£æ³• &apos;&apos;&apos; def merge(self,left,right,res): i,j=0,0 new_array=[] while i&lt;len(left) and j&lt;len(right): if left[i][1]&gt;right[j][1]: new_array+=[left[i]] res[left[i][0]]+=len(right)-j i+=1 else: new_array+=[right[j]] j+=1 new_array+=left[i:] new_array+=right[j:] return new_array def merge_sort(self,nums,res): if len(nums)&lt;2: return nums mid=len(nums)//2 left=self.merge_sort(nums[:mid],res) right=self.merge_sort(nums[mid:],res) return self.merge(left,right,res) def countSmaller(self, nums): res=[0]*len(nums) self.merge_sort([(i,num) for i,num in enumerate(nums)],res) return res &apos;&apos;&apos; def countSmaller(self, nums): count,sorted=[],[] for num in nums[::-1]: index=bisect.bisect_left(sorted,num) sorted.insert(index,num) count+=[index] return count[::-1] Longest Consecutive Sequence Given an unsorted array of integers, find the length of the longest consecutive elements sequence.Your algorithm should run in O(n) complexity. Tips: è¿™ç§è§£é¢˜çš„æ–¹å¼ï¼Œæ˜¯æ¯”è¾ƒæ–°é¢–çš„ã€‚ 12345678910111213141516171819class Solution(object): # ç¬¬ä¸€å°è±¡æ˜¯ å…ˆè¿›è¡ŒæŽ’åºï¼Œ ç„¶åŽé€‰æ‹©çš„è¿‡ç¨‹ï¼Œ ä½†æ˜¯é™åˆ¶æ¡ä»¶æ˜¯ O(n) çš„å¤æ‚åº¦ def longestConsecutive(self, nums): """ :type nums: List[int] :rtype: int """ nums =set(nums) best =0 # è¿™ç§æ–¹å¼çœŸçš„å¾ˆç®€æ´ for x in nums: if x-1 not in nums: y =x+1 while y in nums: y +=1 best =max(best, y-x) return best House Robber Tips: dp çš„æ€æƒ³è¿ç”¨åˆ°æžè‡´å°±æ˜¯è¿™ä¸ªæ ·å­ã€‚ä½¿ç”¨ä¸¤ä¸ªå˜é‡å¥å¯ä»¥æžå®šã€‚ 12345678910111213141516class Solution(object): """ f(0) = nums[0] f(1) = max(num[0], num[1]) f(k) = max( f(k-2) + nums[k], f(k-1) ) """ def rob(self, nums): """ :type nums: List[int] :rtype: int """ # dp æœ‰æ—¶å€™å°±èƒ½è¿™æ ·ä¼˜åŒ–åˆ°ä½¿ç”¨ä¸¤ä¸ªå˜é‡ last, now =0, 0 for num in nums: last, now =now, max(last +num, now) return now Longest Increasing Subsequence Given an unsorted array of integers, find the length of longest increasing subsequence. Tips: f(i) è¡¨ç¤ºä»¥ nums[i]ä¸ºç»“å°¾çš„ longest encreasing subsequence( ç¬¬äºŒä¸ªfor å¯¹æ¯”çš„å¯¹è±¡æ˜¯ f[:i] ä½¿ç”¨j è¿›è¡ŒéåŽ† ) 12345678910111213141516171819202122class Solution(object): # æ±‚è§£æœ€å€¼ å”¯ä¸€è§£éƒ½æ˜¯å¯ä»¥ä½¿ç”¨è¿™æ ·çš„æ–¹å¼çš„å“¦ # ä¸èƒ½ä½¿ç”¨ in é‚£ç§éªšæ“ä½œäº†ï¼Œ åªèƒ½è¸è¸å®žå®žçš„ dp # è¿™ä¸ªç‰ˆæœ¬çš„dp æ²¡æœ‰ä¼˜åŒ–å¥½ def lengthOfLIS(self, nums): """ :type nums: List[int] :rtype: int """ if not nums: return 0 dp = [1] * len(nums) """ """ for i in range(len(nums)): for j in range(i): if nums[i] &gt; nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) Coin Change You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Tips: dpé—®é¢˜ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from sys import maxintclass Solution(object): """ :type coins: List[int] :type amount: int :rtype: int """ ''' # è¿™ç§æ–¹æ³•ä¸è¡Œ if len(coins) ==1: if amount % coins[0] ==0: return amount /coins[0] else: return -1 coins.sort(reverse =True) res =0 for i in range(len(coins)): res += amount /coins[i] amount %= coins[i] return res # table ä½œä¸ºdpï¼Œ table[i] è¡¨ç¤ºå‰i ä¸ªæ•°å­—ä½¿ç”¨æ•°é‡æœ€å°‘çš„ç¡¬å¸èƒ½å¤Ÿ è¡¨ç¤º # å¤šçœ‹å‡ éå°±èƒ½ç†è§£äº† def coinChange(self, coins, amount): table = [0]*(amount + 1) for i in range(1, amount+1): minimum = maxint # æœ‰å¥½å‡ ç§å¯¹äºŽæœ€å°å€¼å’Œæœ€å¤§çš„åˆå§‹åŒ–äº† for j in coins: if i &gt;= j and table[i-j] != -1: minimum = min(minimum, table[i-j] + 1) table[i] = -1 if minimum == maxint else minimum return table[amount] ''' # python3 ä¸èƒ½ä½¿ç”¨python2,python2 èƒ½ä½¿ç”¨ python3? def coinChange(self, coins, amount): table = [0 ] *(amount + 1) for i in range(1, amount +1): #minimum =maxint minimum =float('inf') for j in coins: if i &gt;= j and table[ i -j] != -1: minimum = min(minimum, table[ i -j] + 1) table[i] = -1 if minimum == float('inf') else minimum return table[amount]]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode- Array]]></title>
    <url>%2F2019%2F02%2F16%2Fleetcode-array%2F</url>
    <content type="text"><![CDATA[LeetCode åˆ·é¢˜æ€»ç»“ï¼ˆä¸€ï¼‰ï¼Œ ä½¿ç”¨Python å®žçŽ°ã€‚è¯¥ç¯‡é¢˜ç›®ç±»åž‹ä¸»è¦æ˜¯ï¼š array å’Œstring çš„ç›¸å…³å¤„ç†ã€‚ Two Sum Given an array of integers, find two numbers such that they add up to a specific target number. Tipsï¼š è¿”å›žçš„æ˜¯ indexï¼Œæ‰€ä»¥ dict ä¸­å­˜å‚¨çš„ (num, index) è¿™æ ·çš„ç»„åˆ, æ˜¯ä¸¤ä¸ªä¸ç›¸åŒçš„æ•°å­—çš„index https://leetcode.com/problems/two-sum/ 12345678910111213class Solution(object): # ä¸èƒ½é‡å¤ä½¿ç”¨ä¸€ä¸ªï¼Œreturn index def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ cache = &#123;&#125; for i in range(len(nums)): if target - nums[i] in cache and cache[target - nums[i]] != i: # if else ç”¨çš„æ˜¯æ¯”è¾ƒç®€æ´çš„ return [cache[target - nums[i]], i] cache[nums[i]] = i Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Tips: å…ˆæ˜¯ mergeï¼Œç„¶åŽé€‰æ‹© medianï¼Œå¸¸è§„åšæ³•ï¼Œæ—¶é—´0(mn)ï¼Œä¸æ˜¯æœ€ä¼˜çš„ï¼Œè¿˜å¯ä»¥è¾¾åˆ°O(min(m, n) ) è¿™æ ·çš„æ—¶é—´å¤æ‚åº¦ 123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): # ä½¿ç”¨ merge() æ“ä½œï¼Œç„¶åŽæ ¹æ®ï¼Œç„¶åŽå–å¾—ä¸­ä½æ•° def median(self, nums): len_n =len(nums) if len_n &amp;1 ==1: return nums[len_n//2] else: return float(nums[len_n//2]+nums[len_n//2-1])/2 def findMedianSortedArrays(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: float """ res =[] if not nums1 or not nums2: res =nums1 or nums2 return self.median(res) else: left, right =0, 0 len_1, len_2 =len(nums1)-1, len(nums2)-1 while left&lt;= len_1 and right &lt;=len_2: if nums1[left] &lt;nums2[right]: res.append(nums1[left]) left +=1 else: res.append(nums2[right]) right +=1 if left &lt;= len_1: res.extend(nums1[left:]) if right &lt;=len_2: res.extend(nums2[right:]) return self.median(res) ZigZag Conversion The string â€œPAYPALISHIRINGâ€ is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H NA P L S I I GY I R And then read line by line: â€œPAHNAPLSIIGYIRâ€ Tips: å­—ç¬¦ä¸²å¤„ç† 12345678910111213141516171819202122class Solution(object): def convert(self, s, numRows): """ :type s: str :type numRows: int :rtype: str """ if numRows == 1 or numRows &gt;= len(s): # string of list return s L = [''] * numRows # string of list row, step = 0, 1 for x in s: L[row] += x if row == 0: step = 1 elif row == numRows -1: step = -1 row += step return ''.join(L) # array (list) è½¬æˆstring å¸¸ç”¨çš„æ–¹æ³• Container With Most Water Given n non-negative integers a1, a2, â€¦, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Tips: å·¦å³åŒæŒ‡é’ˆé—®é¢˜ã€‚é¦–å…ˆç§»åŠ¨é«˜åº¦è¾ƒå°çš„ç‚¹ï¼Œå› ä¸ºä¸¤è€…çš„è·ç¦»æ˜¯è‚¯å®šå˜å°ï¼Œå¦‚æžœç§»åŠ¨é«˜åº¦å¤§çš„ï¼Œé‚£ä¹ˆæœ€åŽçš„é¢ç§¯è‚¯å®šå˜å°ï¼›ä½†æ˜¯å¦‚æžœ ç§»åŠ¨é«˜åº¦è¾ƒå°çš„ç‚¹ï¼Œé‚£ä¹ˆæœ€åŽçš„é¢ç§¯æ˜¯æœ‰å¯èƒ½å˜å¤§çš„ã€‚æ‰€ä»¥è¿™ä¸ªæ˜¯ä¸€ä¸ªå¯èƒ½æ€§çš„ä¸œè¥¿ã€‚ 1234567891011121314151617181920212223class Solution(object): def maxArea(self, height): len_h = len(height) if len_h == 1: return 0 max_area = 0 left = 0 right = len_h - 1 # left, right =0, len_h -1 while left &lt; right: if height[left] &lt; height[right]: area = (right - left) * height[left] left += 1 else: area = (right - left) * height[right] right -= 1 if area &gt; max_area: max_area = area return max_area Longest Common Prefix Write a function to find the longest common prefix string amongst an array of strings.If there is no common prefix, return an empty string â€œâ€. Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;] Output: &quot;fl&quot; Tips: ä¸€ä¸ªä¸ªå¯»æ‰¾äº¤é›†ï¼Œæœ€æœ´ç´ çš„æƒ³æ³•ã€ 123456789101112131415161718192021222324252627282930313233class Solution(object): # æ—¶é—´å¤æ‚åº¦æ˜¯ O(N^2), N=len(strs), ç¬¼ç»Ÿçš„è¯´ def longestCommonPrefix(self, strs): """ :type strs: List[str] :rtype: str """ if not strs: return "" n =len(strs) if n ==0: return "" elif n ==1: return strs[0] predix =strs[0] for s in strs[1:]: # è¿™ç§ç»“æž„è§è¿‡äº†ï¼Œå°±æ˜¯ä¸æ–­è¿­ä»£ï¼Œä¸æ–­åœ°çš„åŽ»å¯»æ‰¾ â€äº¤é›†â€œ predix =self.findPrefix(predix, s) if "" ==predix: break return predix def findPrefix(self, s1, s2): min_len =min(len(s1), len(s2)) # è¿™ä¸ªif å’Œ return å†™çš„éƒ½æ˜¯å¾ˆå·§å¦™çš„ for i in range(0, min_len): if s1[i] != s2[i]: return s1[:i] return s1[:min_len] Remove Duplicates from Sorted Array Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Tips: å‰åŽä¸¤ä¸ªæŒ‡é’ˆè¦†ç›–çš„æ€æƒ³ï¼Œæœ€åŽè¿”å›žçš„æ˜¯indexï¼Œå¦‚æžœå‘çŽ°äº†åŽè€…è¦†ç›–å‰è€… 12345678910111213141516171819202122class Solution(object): def removeDuplicates(self, nums): """ :type nums: List[int] :rtype: int """ if None == nums: return 0 len_n = len(nums) if len_n &lt;= 1: return len_n m = 0 n = 1 while n &lt; len_n: if nums[m] != nums[n]: m += 1 if m != n: nums[m] = nums[n] n += 1 return m + 1 Remove Element Given an array nums and a value val, remove all instances of that value in-place and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Tips: in-place è¡¨ç¤ºä¸èƒ½åˆ›å»ºæ•°ç»„ï¼Œå¯ä»¥ä½¿ç”¨ï¼ˆä¸´æ—¶ï¼‰å˜é‡ã€‚é€šè¿‡åŒæŒ‡é’ˆè¿›è¡Œå¤„ç†ï¼Œæƒ³æƒ³ä¸ºä»€ä¹ˆå¯ä»¥ä½¿ç”¨è¿™ä¹ˆç®€æ´çš„ä»£ç è¿›è¡Œå¤„ç†å‘¢ã€‚m n åˆ†åˆ«ä»Žå·¦åˆ°å³ã€ä»Žå³åˆ°å·¦è¿›è¡ŒéåŽ†ï¼Œå°†å’Œ val ç›¸åŒçš„å…ƒç´ éƒ½æ”¾åˆ°å³è¾¹ï¼Œä¸ç›¸åŒçš„æ”¾åˆ°å·¦è¾¹ 1234567891011121314151617181920212223242526class Solution(object): def removeElement(self, nums, val): """ :type nums: List[int] :type val: int :rtype: int """ if not nums: return 0 len_n =len(nums) m,n =0, len_n-1 # æ³¨æ„è·³å‡ºæ¡ä»¶ï¼ŒéåŽ†çš„æ–¹å‘å’Œè·³å‡ºæ¡ä»¶æ˜¯ç›¸å…³çš„, è¿™ä¸ª ç­‰å·å–äºŽä¸å– ä¸€æ˜¯æ¯”è¾ƒéš¾æŠŠæ¡ï¼Œå¯ä»¥å…·ä½“å¸¦ä¸ªå€¼ while m &lt;=n: if val ==nums[m]: if val !=nums[n]: # è¿™ä¸ªæ˜¯ä¸èƒ½ä½¿ç”¨ while æ‰¾ï¼Œå› ä¸ºæœ‰æ¯”è¾ƒå¤šçš„case éœ€è¦è€ƒè™‘ï¼Œæ‰€ä»¥ä½¿ç”¨ if è¿›è¡Œå•æ­¥æ“ä½œ nums[m], nums[n] =nums[n], nums[m] m +=1 n -=1 else: n -=1 else: m +=1 return m # å› ä¸º m æ˜¯ä»Ž0å¼€å§‹çš„ Search in Rotated Sorted Array Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).You are given a target value to search. If found in the array return its index, otherwise return -1. Tipsï¼šä¸€å®šæ˜¯ äºŒåˆ†æ€æƒ³ï¼Œå…³é”®æ˜¯åˆ¤æ–­ å¢žåºåˆ— å’Œ target çš„å…³ç³»ï¼Œæ‰€ä»¥æœ‰ä¸¤å±‚ if åˆ¤æ–­æ¡ä»¶ï¼Œä¸€å±‚æ˜¯å¢žåºåˆ—ï¼Œ ä¸€å±‚æ˜¯ target æ˜¯å¦åœ¨å¢žåºåˆ—ä¸‹é¢è¿™ä¸ªè§‚ç‚¹æ˜¯è¦æœ‰çš„ï¼š æ•´ä¸ªæ•°ç»„ç”±ä¸¤ä¸ªæœ‰åºçš„å­åºåˆ—æž„æˆï¼Œä¸”å·¦å­åºåˆ—ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½&gt;,å³å­åºåˆ—ä¸­çš„æ¯ä¸ªå…ƒç´ ã€‚ 123456789101112131415161718192021222324class Solution(object): # @param nums, a list of integers # @param target, an integer to be searched # @return an integer def search(self, nums, target): left = 0; right = len(nums) - 1 # è¿™ä¸ª == æ˜¯ä¸å®¹æ˜“è¿›è¡Œå–èˆçš„ï¼Œ while left &lt;= right: mid = (left + right) / 2 if target == nums[mid]: return mid # æˆ‘å½“æ—¶é¢è¯•çš„æ—¶å€™å°±æ˜¯è¿™ç§æ€è·¯ï¼Œä¸€å®šè¦æœ‰æ¡ç†å°±æ˜¯äº† # å·¦è¾¹æ˜¯å¢žåºåˆ— if nums[mid] &gt;= nums[left]: if target &lt; nums[mid] and target &gt;= nums[left]: right = mid - 1 else: left = mid + 1 elif nums[mid] &lt; nums[right]: if target &gt; nums[mid] and target &lt;= nums[right]: left = mid + 1 else: right = mid - 1 return -1 Search Insert Position Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.You may assume no duplicates in the array. Tipsï¼š äºŒåˆ†æŸ¥æ‰¾ï¼Œä¹‹å‰æ˜¯found or not foundï¼ŒçŽ°åœ¨å¦‚æžœæ²¡æœ‰æ‰¾è§è¿”å›žçš„æ˜¯ indexï¼Œæ²¡æœ‰ä»€ä¹ˆæœ¬è´¨åŒºåˆ«ã€‚ 1234567891011121314151617181920212223242526272829class Solution(object): def searchInsert(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if not nums: return None len_n =len(nums) if nums[0] &gt; target: return 0 if nums[-1] &lt; target: return len_n left, right =0, len_n-1 while left&lt;=right: mid =(left +right)/2 if nums[mid] ==target: return mid elif nums[mid] &lt;target: left =mid +1 else: right =mid -1 return left Rotate Image You are given an n x n 2D matrix representing an image.Rotate the image by 90 degrees (clockwise). Given input matrix =[ [1,2,3], [4,5,6], [7,8,9]],rotate the input matrix in-place such that it becomes:[ [7,4,1], [8,5,2], [9,6,3]] Tips: å¥½å¥½è§‚å¯Ÿå››ä¸ªç­‰å¼ï¼Œå°±æ˜¯è¡Œå˜åˆ—ï¼Œç„¶åŽå…¶ä»–çš„ä¸€ä¸ªåæ ‡æ˜¯å¯¹ç§°çš„ï¼Œè¿™ä¸ªå°±æ˜¯æ—‹è½¬ 90åº¦ï¼›ç„¶åŽæœ‰äº”ä¸ªå˜é‡ï¼ˆæœ‰é‡å¤çš„ï¼‰ 1234567891011 class Solution(object): def rotate(self, matrix): n = len(matrix) if 1 == n: return round = int(n / 2) for x in range(0, round): for y in range(x, n - x - 1): matrix[n - y - 1][x], matrix[n - x - 1][n - y - 1], matrix[y][n - x - 1], matrix[x][y] = matrix[n - x - 1][n - y - 1], matrix[y][n - x - 1], matrix[x][y], matrix[n - y - 1][x] Spiral Matrix Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.èžºæ—‹å½¢ Input:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]Output: [1,2,3,6,9,8,7,4,5] Tips: åœ¨å¤„ç†â€è¡Œâ€œ ä¿¡æ¯çš„æ—¶å€™ï¼Œæ˜¯å¯ä»¥æ•°ç»„åˆ‡å‰²çš„ã€‚åœ¨å¤„ç†åˆ—ä¿¡æ¯çš„æ—¶å€™ï¼Œéœ€è¦ä¸€ä¸ªä¸ªappend() 123456789101112131415161718192021222324252627282930313233343536class Solution(object): # è¿™ä¸ªä¸æ˜¯è·Ÿé‚£ä¸ª å‰‘æŒ‡offer ä¸­çš„é¡ºæ—¶é’ˆæ‰“å°è¾“å‡ºä¸€æ ·å—ï¼Œ # è¿™ä¸ªç‰ˆæœ¬æ˜¯æ¯”è¾ƒå®¹æ˜“ç†è§£ï¼Œæ‰€ä»¥é€‰æ‹©è¿™ä¸ªç‰ˆæœ¬ def spiralOrder(self, matrix): if matrix ==[]: return [] top, bottom =0, len(matrix)-1 left, right =0, len(matrix[0])-1 res =[] # å½“æœ‰ä¸€ä¸ªç­‰äºŽçš„æ—¶å€™å°±åº”è¯¥è·³å‡ºæ¥äº† while left &lt;right and top&lt; bottom: # å¯¹äºŽè¡Œ å¤„ç†python æ˜¯æœ‰æ¯”è¾ƒç®€å•çš„æ–¹å¼çš„ res += matrix[top][left: right+1] for x in range(top+1, bottom): res.append(matrix[x][right]) res += matrix[bottom][left:right+1][::-1] # å€’å™ for x in range(bottom-1, top, -1): res.append(matrix[x][left]) top, bottom, left, right =top+1, bottom-1, left+1, right-1 if top ==bottom: res += matrix[top][left:right] elif left ==right: for x in range(top, bottom+1): res.append(matrix[x][right]) return res Spiral Matrix II Given a positive integer n, generate a square matrix filled with elements from 1 to $n^2$ in spiral order. Tips : æ³¨æ„è¾¹è§’çš„ç»†èŠ‚ã€‚åˆå§‹åŒ–èµ‹å€¼çš„åº”è¯¥æ˜¯å¸¸è§çš„æ“ä½œï¼Œè¿™é‡Œçš„cur æ˜¯æ¯”è¾ƒæ ¸å¿ƒçš„ä¸œè¥¿ã€‚ 123456789101112131415161718192021222324252627282930313233343536class Solution(object): # version 1 æ˜¯éåŽ†èŽ·å–ï¼Œ version 2 æ˜¯å¡«å……ã€‚è¿™ä¸ªçœŸæ˜¯æœ‰è¶£çš„ä¸œè¥¿ # è¿˜æ˜¯è®¾ç½®ä¸Šä¸‹å·¦å³å››ä¸ªåæ ‡è¿›è¡ŒéåŽ†çš„å¤„ç† def generateMatrix(self, n): ans =[ [0] *n for _ in range(n)] top, bottom, left, right =0, n-1, 0, n-1 cur =1 while left &lt;= right and top &lt;= bottom: for i in range(left, right+1): ans[top][i] =cur cur +=1 top +=1 # æ ¹æ®é—®é¢˜éœ€æ±‚ï¼Œæ˜¯å¯ä»¥åœ¨é¢˜ç›®ä¸­ è®¾ç½®è¿™ç§breakï¼Œä¸éœ€è¦ç­‰åˆ° while çš„åˆ¤æ–­ if top &gt; bottom: break for i in range(top, bottom+1): ans[i][right] =cur cur +=1 right -=1 if left &gt; right: break # å¥½å¥½ä½“ä¼šè¿™ä¸ªè¿žæŽ¥ç‚¹çš„å¤„ç†ï¼Œå·¦è¾¹æ˜¯èƒ½å¤Ÿè®¿é—®åˆ°çš„ï¼Œå³è¾¹ä¸ºäº†èƒ½å¤Ÿè®¿é—®åˆ° # è¿›è¡Œäº† -1 çš„æ“ä½œ for i in range(right, left-1, -1): ans[bottom][i] =cur cur +=1 bottom -=1 if bottom &lt;top: break for i in range(bottom, top-1, -1): ans[i][left] =cur cur +=1 left +=1 return ans Merge Intervals Given a collection of intervals, merge all overlapping intervals. Tips: éœ€è¦åŒºåˆ†åŒºé—´çš„start å’Œend ç‚¹ï¼Œåˆ†åˆ«ä½¿ç”¨ (0 1) è¿›è¡ŒåŒºåˆ†ï¼Œç„¶åŽ sort() ï¼Œé‚£ä¹ˆé‚£ä¹ˆstart å°±å‡ºçŽ°äº†æœ€å‰é¢ï¼Œend å°±å‡ºçŽ°äº†æœ€åŽé¢ã€‚é»˜è®¤çš„sort æ˜¯å…ˆæŒ‰ç…§ ç¬¬ä¸€ä¸ªå…ƒç´ æŽ’åºï¼Œç„¶åŽæŒ‰ç…§ç¬¬äºŒä¸ªå…ƒç´ æŽ’åºï¼Œæ‰€ä»¥æ ‡è¯† (0, 1) è¿™ä¸ªæ˜¯æ²¡æœ‰æ”¶åˆ°å½±å“çš„ã€‚ 12345678910111213141516171819202122232425class Solution(object): def merge(self, intervals): if not intervals: return [] data = [] for interval in intervals: data.append((interval[0], 0)) data.append((interval[1], 1)) data.sort() merged = [] stack = [data[0]] for i in range(1, len(data)): d = data[i] if d[1] == 0: # this is a lower bound, push this onto the stack stack.append(d) elif d[1] == 1: if stack: start = stack.pop() if len(stack) == 0: # we have found our merged interval merged.append( (start[0], d[0])) return merged Length of Last Word Given a string s consists of upper/lower-case alphabets and empty space characters â€˜ â€˜, return the length of last word in the string.If the last word does not exist, return 0. Tips: ä¸èƒ½ä½¿ç”¨ split() å› ä¸ºå¤ªå¤šçš„caseéœ€è¦å•ç‹¬çš„å¤„ç†ï¼Œæ‰€ä»¥åº”è¯¥ä½¿ç”¨å­—æ¯ä¸ºåŸºæœ¬ï¼Œä¸€ä¸ªä¸ªå¤„ç†ã€‚ç­‰ä¸ç­‰äºŽ â€˜ â€˜è¿›è¡Œçš„åˆ‡åˆ†ã€‚ 1234567891011121314151617class Solution(object): # è¿™ä¸ªæ˜¯éœ€è¦ä»Ž å­—æ¯è§’åº¦è€ƒè™‘ï¼Œè€Œä¸æ˜¯ä»Žå•è¯è§’åº¦è€ƒè™‘ def lengthOfLastWord(self, s): len_s =len(s) if 0==len_s: return 0 index =len_s -1 # æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸æ˜¯ ' 'çš„å­—æ¯ while index&gt;=0 and ' ' ==s[index]: index -=1 len_last_word =0 while index &gt;=0 and ' ' != s[index]: index -=1 len_last_word +=1 return len_last_word Valid Number Validate if a given string can be interpreted as a decimal number. Tips :å¯¹äºŽå°æ•°(decimal ) å„ç§ case çš„ç†ŸçŸ¥ç¨‹åº¦ 123456789101112131415161718192021222324252627class Solution(object): def isNumber(self, s): """ :type s: str :rtype: bool """ s = s.strip() digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'] met_dot = met_e = met_digit = False for i, char in enumerate(s): if char in ['+', '-']: if i &gt; 0 and s[i-1] != 'e': return False elif char == '.': if met_dot or met_e: return False met_dot = True elif char == 'e': if met_e or not met_digit: return False met_e, met_digit = True, False #elif char.isdigit(): elif char in digits: met_digit = True else: return False return met_digit Plus One Given a non-empty array of digits representing a non-negative integer, plus one to the integer.The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.You may assume the integer does not contain any leading zero, except the number 0 itself. Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. Tips: é‡ç‚¹åœ¨äºŽåŠ æ³•çš„å¤„ç†ï¼Œä¸€èˆ¬ä½¿ç”¨ æ±‚ä½™å¾—åˆ°digitï¼Œç„¶åŽä½¿ç”¨carry å¾—åˆ°è¿›ä½ã€‚ 1234567891011121314151617181920class Solution(object): def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ len_s =len(digits) carry =1 for i in range(len_s-1, -1, -1): total =digits[i] +carry digit =int(total %10) carry =int(total //10) digits[i] =digit # è¿™ä¸ªæ˜¯æœ€åŽä¸€ä¸ªè¿›ä½ if carry ==1: digits.insert(0, 1) return digits Simplify Path Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path. Tipsï¼š 12345678910111213141516171819class Solution(object): # è¿™ä¸ªä»Žè€ƒç‚¹ä¸Šæ˜¯ stackï¼Œä½†æ˜¯ä½¿ç”¨pythonå­—ç¬¦ä¸²å¤„ç†æ›´å¥½ # æŒ‰ç…§ '/' è¿›è¡Œsplit() def simplifyPath(self, path): """ :type path: str :rtype: str """ stack = [] for token in path.split('/'): if token in ('', '.'): pass # continue è¿™ä¸¤ä¸ªæ˜¯ä¸€æ ·çš„æ•ˆæžœï¼Œ pass å°±ç±»ä¼¼ä¸€ç§å ä½ç¬¦ï¼Œåœ¨æµ‹è¯•çš„æ—¶å€™å¸¸è§ elif token == '..': if stack: stack.pop() else: stack.append(token) return '/' + '/'.join(stack) Edit Distance Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2. Tips: åŠ¨æ€è§„åˆ’å°±é€šè¿‡å­˜å‚¨å­é—®é¢˜ç»“æžœæ¥åŠ å¿«è¿ç®—ï¼Œä½†ä¸€ä¸ªå¥½çš„åŠ¨æ€è§„åˆ’ç®—æ³•ä¼šå°½é‡å‡å°‘ç©ºé—´å¤æ‚åº¦ã€‚ ç„¶åŽæ˜¯å¯ä»¥ç»§ç»­ä¼˜åŒ–çš„ï¼Œä½¿ç”¨ O(n) çš„ç©ºé—´çš„å¤æ‚åº¦. çœŸæ­£çš„å†™å‡ºæ¥ä¹‹åŽï¼Œå‘çŽ°ä»£ç æ˜¯æ¯”æƒ³æ³•æ›´åŠ ç®€å•çš„ã€‚ æä¾›äº†ä¸¤ç§è§£æ³•ï¼Œç¬¬ä¸€ç§æ¯”è¾ƒå¸¸è§„ dpï¼Œæ¯”è¾ƒå®¹æ˜“ç†è§£ã€‚123456789101112131415161718192021222324class Solution(object): def minDistance(self, word1, word2): """ :type word1: str :type word2: str :rtype: int """ m = len(word1) n = len(word2) table = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): table[i][0] = i for j in range(n + 1): table[0][j] = j for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: table[i][j] = table[i - 1][j - 1] else: table[i][j] = 1 + min(table[i - 1][j], table[i][j - 1], table[i - 1][j - 1]) return table[-1][-1] ç¬¬äºŒç§å°±æ˜¯å‚è€ƒä¸€ä¸‹å§ã€‚ 1234567891011121314151617class Solution(object): # ä»Žå®žçŽ°çš„è§’åº¦è®²ï¼Œè¿™ä¸ªæ˜¯éœ€è¦æŠŠæ¡ä½æœ‰ä¸€ä¸ª wordçš„index æ˜¯ä¸å˜çš„ def minDistance(self, word1, word2): l1, l2 = len(word1)+1, len(word2)+1 pre = [0 for _ in range(l2)] for j in range(l2): pre[j] = j for i in range(1, l1): cur = [i]*l2 for j in range(1, l2): cur[j] = min(cur[j-1]+1, pre[j]+1, pre[j-1]+(word1[i-1]!=word2[j-1])) #pre = cur[:] pre =cur return pre[-1] Set Matrix Zeroes Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place. Tips: ä½¿ç”¨ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—ä½œä¸ºæ ‡è®°ï¼Œä½¿ç”¨ 0ä½œä¸ºæ ‡è®°ã€‚ 123456789101112131415161718192021class Solution(object): def setZeroes(self, matrix): """ :type matrix: List[List[int]] :rtype: None Do not return anything, modify matrix in-place instead. """ firstRowHasZero = not all(matrix[0]) # all() åªæœ‰æ‰€æœ‰çš„ä¸ä¸º0 è¿”å›žçš„æ‰ä¸ä¸º0ï¼Œå¦åˆ™è¿”å›ž0 for i in range(1,len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 0: # è¿™ç§éåŽ†å¹¶æ ‡è®°çš„æ–¹æ³•è¿˜æ˜¯æ¯”è¾ƒä¼˜ç§€çš„ matrix[0][j] = 0 matrix[i][0] = 0 for i in range(1,len(matrix)): for j in range(len(matrix[0])-1,-1,-1): # æ³¨æ„æ˜¯ä»ŽåŽå¾€å‰æ ‡è®°çš„ if matrix[0][j] == 0 or matrix[i][0] == 0: matrix[i][j] = 0 if firstRowHasZero: matrix[0] = [0]*len(matrix[0]) #æœ€åŽå¤„ç†ç¬¬ä¸€è¡Œ Remove Duplicates from Sorted List Given a sorted linked list, delete all duplicates such that each element appear only once. Tips: æ³¨æ„è¿™é“é¢˜å’Œä¸Šé¢æœ‰é“é¢˜æ˜¯æœ‰å·®åˆ«çš„ï¼Œè¿™ä¸ªæ˜¯ delete all duplicates 1234567891011121314151617181920212223# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): """ ä½¿ç”¨ä¸¤ä¸ª while æ˜¯å› ä¸ºï¼Œé€»è¾‘ä¸Šç®€å• """ def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ cur =head while cur: while cur.next and cur.val == cur.next.val: cur.next =cur.next.next # skip duplicates cur =cur.next return head Merge Sorted Array Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Tips: é¢˜ç›®ä¸­è¯´äº† nums1 æ˜¯ä¸ä¼šå‡ºçŽ° index è®¿é—®æŠ¥é”™çš„ã€‚ä»ŽåŽå¾€å‰éåŽ†ï¼Œå› ä¸ºè¿™ä¸ªæ˜¯è¦æ±‚ merge 2 into 1çš„ã€‚ 1234567891011121314151617181920212223242526class Solution(object): def merge(self, nums1, m, nums2, n): """ :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: None Do not return anything, modify nums1 in-place instead. """ i, j, k =m-1, n-1, m+n-1 while i &gt;=0 and j&gt;=0: if nums1[i] &gt; nums2[j]: nums1[k] =nums1[i] i -=1 else: nums1[k] =nums2[j] j -=1 k -=1 #import ipdb #ipdb.set_trace() # å¦‚æžœè¿™æ˜¯ if é‚£ä¹ˆä½¿ç”¨çš„å°±æ˜¯å­—ç¬¦ä¸²çš„åˆ‡å‰²ï¼Œå¦‚æžœæ˜¯while é‚£ä¹ˆå°±æ˜¯ä¸€ä¸ªä¸ªæ“ä½œ if j&gt;=0: nums1[:k+1] =nums2[:j+1] Restore IP Addresses Given a string containing only digits, restore it by returning all possible valid IP address combinations. Tipsï¼š ç»†èŠ‚æ¯”è¾ƒå¤šï¼Œåœ¨è¿›è¡Œ dfs çš„æ—¶å€™ 123456789101112131415161718192021222324252627282930class Solution(object): def restoreIpAddresses(self, s): """ :type s: str :rtype: List[str] """ ans = [] self.helper(ans, s, 4, []) # ans ä¸­çš„item ä¹‹é—´ä½¿ç”¨ . è¿›è¡Œéš”å¼€ï¼Œè¿™ç§æŠ€æœ¯ï¼Œæ˜¯éžå¸¸å¸¸è§çš„ # è¿™ä¸ªæ˜¯ list of listï¼Œ ç„¶åŽè½¬æ¢æˆäº† list of string return ['.'.join(x) for x in ans] def helper(self, ans, s, k, temp): if len(s) &gt; k * 3: return if k == 0: #ans.append(temp[:]) ans.append(temp) else: for i in range(min(3, len(s) - k + 1)): # s æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå½“åªæœ‰ä¸€ä½æ—¶ï¼Œ0å¯ä»¥æˆæŸä¸€æ®µï¼Œå¦‚æžœæœ‰ä¸¤ä½æˆ–ä¸‰ä½æ—¶ï¼Œåƒ 00ï¼Œ 01ï¼Œ 001ï¼Œ 011ï¼Œ 000ç­‰éƒ½æ˜¯ä¸åˆæ³•çš„ï¼Œ # åªèƒ½æ˜¯ 0.1.0.0 è€Œä¸èƒ½æ˜¯00.1.0.0 ï¼Œè¿™ä¸ªæ˜¯ipè¯­æ³• # è¿™ä¸ªæ˜¯æœ‰è¿žä¸ªå¹¶åˆ—çš„åˆ¤æ–­æ¡ä»¶ if i == 2 and int(s[:3]) &gt; 255 or i &gt;0 and s[0] =='0': continue self.helper(ans, s[i + 1:], k - 1, temp + [s[:i + 1]]) Interleaving String Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. Tipsï¼š interleaving æ’å…¥ï¼›s3 æ˜¯å¦èƒ½å¤Ÿç”¨s1 å’Œs2 ç»„æˆ, len(s1) +len(s2) == len(s3) è¿™ä¸ªæ ·å­çš„ã€‚è¡Œåˆ—åˆ†åˆ«è¡¨ç¤ºs1 å’Œs2 ä¸­çš„å­—æ¯ï¼Œç„¶åŽ (x, y) å€¼è¡¨ç¤ºå½“å‰çš„èƒ½å¤Ÿâ€èµ°â€œ é€šçš„è·¯å¾„ã€‚ 12345678910111213141516171819202122232425262728293031class Solution(object): """ interleaving, åˆ¤æ–­s3æ˜¯å¦ç”±s1å’Œs2äº¤å‰æž„æˆï¼Œ """ def isInterleave(self, s1, s2, s3): """ :type s1: str :type s2: str :type s3: str :rtype: bool """ r, c, l =len(s1), len(s2), len(s3) if r+c !=l: return False # 0 è¡Œå’Œ 0åˆ—çš„åˆå§‹åŒ–ï¼Œä½¿ç”¨ true or false æ¥è¿›è¡Œè¡¨ç¤ºç»“æžœ dp =[ [True] * (c+1) for _ in range(r+1)] for i in range(1, r+1): dp[i][0] =dp[i-1][0] and s1[i-1] == s3[i-1] for j in range(1, c+1): dp[0][j] =dp[0][j-1] and s2[j-1] ==s3[j-1] # çœ‹åˆ°ä»£ç ä¹‹åŽè§‰å¾—å¾ˆç®€å•ï¼Œ for i in range(1, r+1): for j in range(1, c+1): dp[i][j] = dp[i-1][j] and s1[i-1] ==s3[i+j-1] or dp[i][j-1] and s2[j-1] ==s3[i+j-1] return dp[-1][-1] æ–¹æ³•äºŒï¼š12345678910111213141516# ä»Žè¿è¡Œçš„ç»“æžœæ¥è¯´ï¼Œå†…å­˜ä¸‹é™äº†0.1Mï¼Œ ä½†æ˜¯è¿™ä¸ªæ—¶é—´å´å•†åŸŽäº†def isInterleave(self, s1, s2, s3): r, c, l= len(s1), len(s2), len(s3) if r+c != l: return False dp = [True for _ in range(c+1)] for j in range(1, c+1): dp[j] = dp[j-1] and s2[j-1] == s3[j-1] for i in range(1, r+1): dp[0] = (dp[0] and s1[i-1] == s3[i-1]) for j in range(1, c+1): dp[j] = (dp[j] and s1[i-1] == s3[i-1+j]) or (dp[j-1] and s2[j-1] == s3[i-1+j]) return dp[-1] Pascalâ€™s Triangle Given a non-negative integer numRows, generate the first numRows of Pascalâ€™s triangle. Tips: è¿™ä¸ªæ˜¯å°å­¦æ•°å­¦é¢˜ï¼Œå˜æˆäº†ç¼–ç¨‹é¢˜ã€å¯¹åº”å¥½index è¿›è¡Œäº†ã€‚æœ€åŽ res å¯èƒ½ä¸æ˜¯æ­£ä¸‰è§’å½¢ï¼ˆç›´è§’ä¸‰è§’å½¢ï¼‰ä½†ä¸€å®šæ˜¯å¯ä»¥è¿™æ ·åšçš„ã€‚ 123456789101112131415class Solution(object): def generate(self, numRows): """ :type numRows: int :rtype: List[List[int]] """ res = [[1 for _ in range(i+1)] for i in range(numRows)] for i in range(2, numRows): for j in range(1, i): # è¿™ä¸ªå°±æ˜¯ä¸€ä¸ªæ•°å­¦é—®é¢˜ # å°±æ˜¯ä¸Šä¸€è¡Œ(i-1) çš„ j-1 å’Œj å…ƒç´ çš„ç›¸åŠ  res[i][j] =res[i-1][j-1] + res[i-1][j] return res Given a non-negative index k where k â‰¤ 33, return the kth index row of the Pascalâ€™s triangle.Note that the row index starts from 0. Tipsï¼š ç›¸æ¯”äºŽä¸Šä¸€ä¸ªï¼Œè¿™ä¸ªåªæ˜¯è¿”å›žäº†æœ€åŽä¸€è¡Œã€‚ 123456789101112131415class Solution(object): # ç›¸å¯¹æ¯”ä¸Šä¸€ä¸ªï¼Œåªæ˜¯è¾“å‡ºæœ€åŽä¸€è¡Œçš„ä¿¡æ¯ï¼Œ rowIndex def getRow(self, rowIndex): """ :type rowIndex: int :rtype: List[int] """ res =[ [1 for _ in range(i+1) ] for i in range(rowIndex+1)] for i in range(2, rowIndex+1): for j in range(1, i): res[i][j ] = res[i-1][j] + res[i-1][j-1] return res[-1] Valid Palindrome Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.Note: For the purpose of this problem, we define empty string as valid palindrome. Input: &quot;A man, a plan, a canal: Panama&quot; Output: true Tipsï¼š å»ºè®®ä½¿ç”¨ is.alnum() è¿™ä¸ªpython ä¸­è‡ªå¸¦çš„å‡½æ•°ï¼Œå› ä¸ºè¿™ç§åˆ¤æ–­è¿˜æ˜¯æŒºå¸¸è§çš„ã€‚å›žæ–‡æ•°ã€‚å…ˆæ˜¯é¢„å¤„ç†ï¼Œç„¶åŽæ‰æ˜¯ lower() åˆ¤æ–­ã€‚ 1234567891011121314151617181920212223242526class Solution(object): # palindrome å›žæ–‡æ•°ï¼Œ alphanumeric ï¼Œ å­—æ¯ä¸Žæ•°å­—å¹¶ç”¨çš„; # é¢„å¤„ç†ä¹‹åŽï¼Œç„¶åŽæ¯”è¾ƒå‰åŽä¸¤ä¸ªå­—ç¬¦çš„å¼‚åŒ # Python isalnum() æ–¹æ³•æ£€æµ‹å­—ç¬¦ä¸²æ˜¯å¦ç”±å­—æ¯å’Œæ•°å­—ç»„æˆï¼Œè¿™ç§å‡½æ•°åªæœ‰åœ¨ æ­ªæžœä»çš„ä»£ç ä¸­å¸¸è§ # s[i] &gt;= 'a' and s[i] &lt;= 'z' or s[i] &gt;= '0' and s[i] &lt;= '9' or s[i] &gt;= 'A' and s[i] &lt;= 'Z':, è¿™ä¸ªæ˜¯å›½äººçš„å†™æ³• # a=''.join([x for x in s if x.isalpha() or x.isdigit()]).lower() æˆ–è€…è¿™æ · # å–œæ¬¢å†™æºç  def isPalindrome(self, s): """ :type s: str :rtype: bool """ left, right =0, len(s)-1 while left &lt; right: while left &lt; right and not s[left].isalnum(): left +=1 while left &lt; right and not s[right].isalnum(): right -=1 if s[left].lower() != s[right].lower(): return False left +=1 right -=1 return True Gas Station There are N gas stations along a circular route, where the amount of gas at station i is gas[i].You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.Return the starting gas stationâ€™s index if you can travel around the circuit once in the clockwise direction, otherwise return -1. Input:gas = [1,2,3,4,5]cost = [3,4,5,1,2]Output: 3Explanation:Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4Travel to station 4. Your tank = 4 - 1 + 5 = 8Travel to station 0. Your tank = 8 - 2 + 1 = 7Travel to station 1. Your tank = 7 - 3 + 2 = 6Travel to station 2. Your tank = 6 - 4 + 3 = 5Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.Therefore, return 3 as the starting index. Tips: çœ‹ç€æŒºå“äººçš„ï¼Œä½†æ˜¯è½å®žåˆ°ä»£ç ä¸Šï¼Œå°±æ˜¯ä¸€ä¸ªå¾ªçŽ¯ï¼Œå½“ä¸èƒ½å‡ºå‘æ—¶ï¼Œ r (rest) æ˜¯ä¸º0ï¼Œç„¶åŽå¯»æ±‚ä¸‹ä¸€ä¸ªå¯ä»¥å‡ºå‘çš„ç‚¹ã€‚ 123456789101112class Solution(object): def canCompleteCircuit(self, gas, cost): if sum(gas) &lt; sum(cost): return -1 index, rest = 0, 0 for i in range(len(gas)): if gas[i] + rest &lt; cost[i]: #è¿™ä¸ªæ˜¯éœ€è¦éåŽ†æ•´ä¸ª gasçš„ï¼Œå› ä¸ºæœ‰å¯èƒ½å¼€å§‹è¡Œä½†æ˜¯åŽæ¥ä¸è¡Œï¼Œæ‰€ä»¥å¼€å§‹çš„index è¿˜æ˜¯æ— æ³•å®Œæˆæ•´ä¸ªéåŽ† index = i +1 rest = 0 else: rest += gas[i] - cost[i] return index Evaluate Reverse Polish Notation Evaluate the value of an arithmetic expression in Reverse Polish Notation.Valid operators are +, -, *, /. Each operand may be an integer or another expression. Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won&apos;t be any divide by zero operation. Tipsï¼š æœ¯è¯­ï¼Œé€†æ³¢å…°è¡¨è¾¾å¼ï¼ˆæ“ä½œæ•°åœ¨å‰ï¼Œæ“ä½œç¬¦åœ¨åŽï¼‰çš„ä¸€ç§å½¢å¼ã€‚æ ˆæ˜¯å­˜å‚¨æ“ä½œæ•° å’Œè¿ç®—ç»“æžœçš„ã€‚å¯¹äºŽè´Ÿæ•°ä¸èƒ½æ•´é™¤çš„ï¼Œå‘ç€ 0 é æ‹¢ 1234567891011121314151617181920212223242526272829class Solution(object): # è®¡ç®—é€†æ³¢å…°è¡¨è¾¾å¼ï¼šæŠŠæ“ä½œæ•°æ”¾å‰é¢ï¼ŒæŠŠæ“ä½œç¬¦åŽç½®çš„ä¸€ç§å†™æ³• # è¿™ä¸ªæ˜Žæ˜¾å°±æ˜¯ æ ˆçš„ä½¿ç”¨å‘€ï¼Œä¸¤ä¸ªæ ˆï¼Œ def evalRPN(self, tokens): """ :type tokens: List[str] :rtype: int """ stack =[] for t in tokens: if t not in "+-*/": stack.append(int(t)) else: right, left =stack.pop(), stack.pop() if t =="+": stack.append(left +right) elif t =="-": stack.append(left-right) elif t =="*": stack.append(left*right) else: # case like 1/(-2) è´Ÿæ•°ä¸”ä¸èƒ½æ•´é™¤ if left*right &lt;0 and left % right!=0: stack.append(left/right +1) else: stack.append(left/right) return stack.pop() Reverse Words in a String Given an input string, reverse the string word by word. Tipsï¼š æ­£å¸¸çš„æ€è·¯æ˜¯ç¬¬ä¸€æ¬¡å…¨ç¿»è½¬ï¼Œç¬¬äºŒæ¬¡æŒ‰ç…§ word è¿›è¡Œç¿»è½¬ã€‚ä½†æ˜¯python ååˆ†æ“…é•¿ å­—ç¬¦ä¸²çš„å¤„ç†ã€‚ 123456789class Solution(object): # ä¸¤æ¬¡ç¿»è½¬ã€‚ç¬¬ä¸€æ¬¡æ˜¯å…¨ç¿»è½¬ï¼Œç„¶åŽç¬¬äºŒæ¬¡æ˜¯word ç¿»è½¬ # å­—ç¬¦ä¸²ç±»åž‹çš„ç®—æ³•é¢˜ç›®ï¼Œä½¿ç”¨python æ˜¯æ— æ³•get åˆ°ç®—æ³•å±‚é¢çš„ hahaha def reverseWords(self, s): """ :type s: str :rtype: str """ return " ".join(s.split()[::-1]) Search a 2D Matrix Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Tips: æ³¨æ„ç¬¬äºŒä¸ªæ¡ä»¶ï¼Œä¸‹ä¸€è¡Œçš„å¼€å¤´æ˜¯å¤§äºŽä¸Šä¸€è¡Œçš„æœ«å°¾ï¼Œæ‰€ä»¥å¦‚æžœ dense ä¸€ä¸‹ï¼Œæ˜¯å¯ä»¥çœ‹æˆå¤§çš„æœ‰åºï¼Œæ‰€ä»¥æ€è·¯å°±æ˜¯äºŒå‰æŽ’åºã€‚ https://leetcode.com/problems/search-a-2d-matrix/ Input:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 3Output: true 123456789101112131415161718192021222324252627class Solution(object): def searchMatrix(self, matrix, target): """ :type matrix: List[List[int]] :type target: int :rtype: bool """ # å¦‚æžœå†™æˆ not target æ˜¯æœ‰é—®é¢˜ï¼Œå½“ target ==0 çš„æ—¶å€™ï¼Œè¿™ä¸ªæ˜¯ä¸æˆç«‹çš„ï¼Œæ‰€ä»¥éœ€è¦çœ‹ä¸€ä¸‹æ•°æ®çš„èŒƒå›´ # æ³¨æ„åŒºåˆ† if not matrix or target ==None: return False rows, cols=len(matrix), len(matrix[0]) low, high =0, rows*cols-1 # æ€»çš„äºŒå‰ while low &lt;=high: mid =(low +high) /2 num =matrix[mid/cols][mid%cols] if num ==target: return True elif num&lt; target: low =mid +1 else: high =mid -1 return False Search a 2D Matrix II Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] Tips: æ³¨æ„åŒºåˆ†å’Œä¸Šä¸€é“é¢˜ç›®çš„ç¬¬äºŒç‚¹çš„åŒºåˆ«ã€‚è¿™ä¸ªåªèƒ½æ˜¯ä¸€æ­¥æ­¥èµ°ï¼Œä¸‹é¢çš„ç¨‹åºæ˜¯ä»Žå³ä¸Šæ–¹å¼€å§‹èµ°ï¼Œå¦‚æžœ target å¤§åˆ™å‘ä¸‹ç›´èµ°ï¼Œå¦åˆ™å·¦èµ°ã€‚å¯ä»¥æœ‰ä¸¤ç§åˆå§‹åŒ–æ–¹å¼ï¼Œä¸€ç§æ˜¯å³ä¸Šè§’ï¼Œä¸€ç§æ˜¯å·¦ä¸‹è§’ã€‚ https://leetcode.com/problems/search-a-2d-matrix-ii/ 1234567891011121314151617181920212223242526272829303132333435class Solution(object): def searchMatrix(self, matrix, target): """ :type matrix: List[List[int]] :type target: int :rtype: bool """ # ä¸€å¼€å§‹çš„æ—¶å€™ä¸çŸ¥é“ä½¿ç”¨ä»€ä¹ˆéåŽ†æ–¹å¼ï¼Œå› ä¸º for å¥½åƒä¸å¤ªè¡Œï¼Œåº”è¯¥ä½¿ç”¨ while åŸºäºŽæ¡ä»¶éåŽ† if matrix ==[]: return False rows, cols =len(matrix)-1, len(matrix[0])-1 """ row, col = 0, cols # start points while row &lt;= rows and col &gt;= 0: if matrix[row][col] == target: return True elif matrix[row][col] &lt; target: row +=1 else: col -=1 """ # è¿˜æœ‰ä¸€ç§åˆå§‹åŒ–æ–¹å¼ row, col =rows, 0 while row &gt;=0 and col &lt;= cols: if matrix[row][col] ==target: return True elif matrix[row][col] &lt; target: col +=1 else: row -=1 return False Kth Smallest Element in a Sorted Matrix Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix. Tips: ä¸»è¦æ˜¯çœ‹åˆ° example ä¸­çš„æ•°æ®ï¼Œæœ‰ä¸¤ç§ç±»åž‹ï¼Œä¸€ç§æ˜¯å¯ä»¥æŠŠmatrix dense ä¹‹åŽä¾ç„¶æ˜¯æœ‰åºï¼Œå¦ä¸€ç§ä¸æ˜¯ã€‚è¿™ä¸ªæ˜¯å±žäºŽå‰è€…ã€‚ä¸‹é¢è¿™ç§è§£æ³•æ¯”è¾ƒæ–°é¢–ï¼Œä½¿ç”¨heapq è¿›è¡Œæ“ä½œï¼ŒéåŽ†k th å°±å¾—åˆ°äº†kth æœ€å°ã€‚ Â·Â·Â·pythonclass Solution(object): # æœ‰ä¸€ç§æ–¹æ³•æ˜¯åˆå§‹åŒ–ä¸ºå³ä¸Šè§’ï¼Œç„¶åŽå°å¾€å·¦èµ°ï¼Œå¤§å¾€ä¸‹èµ° # è¿™ä¸ªé»˜è®¤æ±‚è§£çš„k smallestï¼Œæ‰€ä»¥python ä¸­heapq é»˜è®¤ä¹Ÿæ˜¯å°æ ¹å †ï¼Œæ‰€ä»¥ def kthSmallest(self, matrix, k): &quot;&quot;&quot; :type matrix: List[List[int]] :type k: int :rtype: int &quot;&quot;&quot; heap, res, n =[(matrix[0][0], 0, 0)], 0, len(matrix) for k in range(1, k+1): # è¿™ä¸ªæ˜¯æ¬¡æ•° res, row, col =heapq.heappop(heap) # é—®é¢˜åœ¨äºŽè¿™é‡Œå¹¶æ²¡æœ‰ä½“çŽ°äº† row colç›¸åº”çš„å˜åŒ– +1 è¿™ç±»ä¸œè¥¿ # è¿™ä¸ªæ˜¯é€šè¿‡ heapq ä¸æ–­åœ°push å’Œpop æ¥å¾—åˆ°ç›¸åº”çš„ row col ç„¶åŽè¿›è¡Œres çš„èŽ·å–çš„ if not row and col&lt; n-1: heapq.heappush(heap, (matrix[row][col+1], row, col+1)) if row&lt; n-1: heapq.heappush(heap, (matrix[row+1][col], row+1, col)) return res 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748** Evaluate Reverse Polish Notation**&gt; Evaluate the value of an arithmetic expression in Reverse Polish Notation.Valid operators are +, -, *, /. Each operand may be an integer or another expression.Tips: é€†æ³¢å…°åˆç§°ä¹‹ä¸ºåŽç¼€è¡¨è¾¾å¼ï¼Œæ“ä½œç¬¦ç½®äºŽæ“ä½œæ•°åŽé¢ï¼Œè¿™ä¸ªå‰åŽæ˜¯ä»¥â€œæ“ä½œç¬¦â€ è¿›è¡Œå®šä¹‰çš„ã€‚è§£é¢˜æ€è·¯ï¼Œå¦‚æžœæ˜¯æ“ä½œæ•°ï¼Œé‚£ä¹ˆå°±åŽ‹æ ˆï¼Œå¦‚æžœæ˜¯æ“ä½œç¬¦ï¼Œé‚£ä¹ˆå¼¹å‡ºè¿›è¡Œè¿ç®—ã€‚```pythonclass Solution(object): def evalRPN(self, tokens): stack =[] operators =[&apos;+&apos;, &apos;-&apos;, &apos;*&apos;, &apos;/&apos;] for token in tokens: if token not in operators: #è¿™ç§æ¯”è¾ƒnice exact stack.append(int(token)) # ç»†èŠ‚ string to int else: if len(stack) &lt;2: return False second =stack.pop() first =stack.pop() if token ==&quot;+&quot;: result =first +second elif token ==&quot;-&quot;: result =first -second elif token ==&quot;*&quot;: result =first *second else: # é™¤æ³•å‘æ¥å¤„ç†å°±æ¯”è¾ƒéº»çƒ¦ if second ==0: return False # è¿™ä¸ªæ˜¯æ“ä½œä¸­çš„abs æ²¡æœ‰æ”¹å˜åŽŸæ¥çš„å€¼ï¼Œæ‰€ä»¥æ¯”è¾ƒnice result =abs(first)/abs(second) if first *second &lt;0: result =-result stack.append(result) # æœ€åŽåªæœ‰ä¸€ä¸ªresult å€¼ï¼Œæ‰€ä»¥ååˆ†ç®€æ´ if len(stack) !=1: return False return stack[0] Excel Sheet Column Number Given a column title as appear in an Excel sheet, return its corresponding column number. Tips: åœ¨äºŽ char å’Œnum çš„å¯¹åº”å…³ç³»ã€‚ord() ç”¨äºŽ char è½¬æˆint è¿™ç§åº“å‡½æ•°è¿˜æ˜¯è¦æœ‰çš„ã€‚ å¯ä»¥çœ‹æˆ 26 è¿›åˆ¶ã€‚ 123456789101112class Solution(object): def titleToNumber(self, s): """ :type s: str :rtype: int """ res =0 for char in s: res =res*26 +(ord(char)- ord('A') +1) return res Largest Number Given a list of non negative integers, arrange them such that they form the largest number. Tips: string ç±»åž‹ç»„åˆæˆçš„æ•°å­—æ˜¯æœ€å¤§çš„ã€‚ åœ¨string é‡Œé¢ â€˜9â€™ &gt; â€˜88888â€™ è¿™ä¸ªæ˜¯æˆç«‹ï¼Œæ‰€ä»¥è¿™ä¸ªç‰¹æ€§å¯ä»¥å¤„ç†è¿™ä¸ªé¢˜ç›®ï¼Œå¾ˆå·§å¦™ã€‚ 12345678910class Solution(object): def largestNumber(self, nums): """ :type nums: List[int] :rtype: str """ nums =map(str, nums) nums.sort(cmp =lambda a, b :cmp(a+b, b+a), reverse =True) # é™åº # å¯èƒ½å‡ºçŽ° 00 è¿™æ ·çš„å­—ç¬¦ä¸²ï¼Œæ‰€ä»¥æ˜¯å…ˆ int ç„¶åŽå†stringï¼Œæ„Ÿè§‰è¿™ä¸ªä¸æ˜¯ç®—æ³•çš„å‘³é“ return str(int(''.join(nums))) Longest Substring with At Least K Repeating Characters Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times. Tips: è¿™ä¸ªcodes ä¸­çš„else è¿˜æ˜¯ç›¸å½“çš„ç‰›é€¼ï¼Œç¬¬ä¸€æ¬¡è§è¿™ç§å†™æ³•çš„ã€‚å¦‚æžœ for å¾ªçŽ¯ä¸­çš„æ¡ä»¶ä¸æˆç«‹ï¼Œelseã€‚ 12345678910111213141516171819class Solution: def longestSubstring(self, s, k): """ :type s: str :type k: int :rtype: int """ stack = [] stack.append(s) ans = 0 while stack: s = stack.pop() for c in set(s): if s.count(c) &lt; k: stack.extend([z for z in s.split(c)]) break else: ans = max(ans, len(s)) return ans Longest Increasing Path in a Matrix Given an integer matrix, find the length of the longest increasing path.From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed). Tips: dfs, åˆ¤æ–­æ¡ä»¶æ˜¯ val &gt; matrix[i][j] 12345678910111213141516171819202122232425262728class Solution(object): # ä¸€çœ‹è¿™ä¸ªå°±æ˜¯æ·±åº¦ä¼˜å…ˆæœç´¢ # è¿™ç§åšæ³•æ›´åŠ æ™®ä¸– def longestIncreasingPath(self, matrix): """ :type matrix: List[List[int]] :rtype: int """ # è¡¨ç¤ºä»¥è¿™ç‚¹ä¸ºç»ˆç‚¹çš„ è·¯å¾„æ˜¯æœ‰å¤šé•¿ # è¿™ä¸ªé€»è¾‘ä¸Šæ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œ å°±æ˜¯dfs()ï¼Œç„¶å“¦å¼å¦‚æžœä»Žä»»æ„ä¸€ç‚¹å‡ºå‘ range() range()ï¼Œ # ä½¿ç”¨ dfs() ï¼Œå¦‚æžœæ˜¯value &gt; matrix[][]ï¼Œå°±ç›´æŽ¥è¿”å›žäº† dp[i][j] def dfs(i, j): if not dp[i][j]: val = matrix[i][j] # i-1 çš„æ—¶å€™è¦å¤§äºŽ0 i+1çš„æ—¶å€™è¦i &lt; M è¿™æ ·çš„æ“ä½œ dp[i][j] = 1 + max( dfs(i - 1, j) if i and val &gt; matrix[i - 1][j] else 0, dfs(i + 1, j) if i &lt; M - 1 and val &gt; matrix[i + 1][j] else 0, dfs(i, j - 1) if j and val &gt; matrix[i][j - 1] else 0, dfs(i, j + 1) if j &lt; N - 1 and val &gt; matrix[i][j + 1] else 0) return dp[i][j] if not matrix or not matrix[0]: return 0 M, N = len(matrix), len(matrix[0]) dp = [[0] * N for i in range(M)] # ä»¥è¯¥ç‚¹ä¸ºç»ˆç‚¹çš„ increasing path æœ‰å¤šå°‘ä¸ª return max(dfs(x, y) for x in range(M) for y in range(N)) Word Ladder Given two words (beginWord and endWord), and a dictionaryâ€™s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:Only one letter can be changed at a time.Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Tips: è®²è§£-tm) https://leetcode.com/problems/word-ladder/ 123456789101112131415161718192021222324252627class Solution(object): # https://leetcode.com/problems/word-ladder/discuss/157376/Python-(BFS)-tm # å†™å‡ºæ¥ä¹‹åŽå°±æ¯”è¾ƒå¥½ç†è§£ï¼Œå¯ä»¥å¥½å¥½æƒ³æƒ³ def ladderLength(self, beginWord, endWord, wordList): """ :type beginWord: str :type endWord: str :type wordList: List[str] :rtype: int """ wordList =set(wordList) queue =collections.deque([(beginWord, 1)]) visited =set() alpha =string.ascii_lowercase # 'abcd..z' while queue: word, length =queue.popleft() if word == endWord: return length for i in range(len(word)): for ch in alpha: new_word =word[:i] +ch+word[i+1:] if new_word in wordList and new_word not in visited: queue.append((new_word, length+1)) visited.add(new_word) return 0 Fraction to Recurring Decimal Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.If the fractional part is repeating, enclose the repeating part in parentheses. Tips: åˆ†æ•°å˜æˆå°æ•° 123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): # ä¸»è¦æ˜¯è€ƒå¯Ÿåˆ†æƒ…å†µè®¨è®ºï¼Œè¿™æ ·æ˜¯æ¯”è¾ƒå¤šçš„ # å°±æ˜¯åœ¨æ‹¼æŽ¥å‘€ def fractionToDecimal(self, numerator, denominator): """ :type numerator: int :type denominator: int :rtype: str """ res ='' if numerator % denominator ==0: return str(numerator/denominator) if numerator* denominator &lt;0: res += '-' numerator, denominator =abs(numerator), abs(denominator) res += str(numerator/denominator) res +='.' numerator %= denominator i =len(res) table =&#123;&#125; # ä¸‹é¢æè¿°çš„å°±æ˜¯è¾—è½¬ç›¸é™¤çš„è¿‡ç¨‹ï¼Œ ä½¿ç”¨ &#123;&#125; è¿›è¡Œå­˜å‚¨ while numerator !=0: if numerator not in table: table[numerator] =i else: i =table[numerator] res =res[:i] +'('+res[i:]+')' return res numerator =numerator*10 res += str(numerator/denominator) numerator %= denominator i +=1 return res Reverse Bits Reverse bits of a given 32 bits unsigned integer. Tips: ä¸Žæ“ä½œå’Œå·¦ç§»æ“ä½œ ( &amp; and &lt;&lt;) æ˜¯å¸¸è§çš„ bit operationä¸­ç”¨åˆ°çš„ Â·Â·Â·pythonclass Solution: # @param n, an integer # @return an integer # æ²¡æœ‰ä»€ä¹ˆè¯´çš„ï¼Œ äºŒçº§åˆ¶æ“ä½œï¼Œæ³¨æ„è¾“å…¥å’Œè¾“å‡ºéƒ½æ˜¯ integer # One small thing is the plus operator can be replaced by &quot;bitwise or&quot;, aka &quot;|&quot;. # Just generate the answer bit by bit, do not use things like &quot;% 2&quot; or &quot;2 ** k&quot; or &quot;bin&quot;. Bit manipulation is a lot faster. def reverseBits(self, n): ans =0 # ä»ŽåŽå¾€å‰å¤„ç†ï¼Œæ‰€ä»¥è¿™å°±reverse äº† for i in range(32): # n&amp;1 æ˜¯å–æœ€åŽä¸€ä½ # ans &lt;&lt;1 å·¦ç§»ä¸€ä½ï¼Œç±»ä¼¼ä¹˜2 ans += n &amp;1 if i ==31: return ans n &gt;&gt;= 1 ans &lt;&lt;= 1 return ans 12345678910111213141516171819202122232425262728293031323334** Word Break**&gt; Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.Tips: dp é—®é¢˜```pythonclass Solution(object): # å­—ç¬¦ä¸²çš„å¤„ç†ï¼Œæ„Ÿè§‰æœ‰ç‚¹éš¾å‘€ # dpçš„æ€è·¯ï¼Œ dp[i] è¡¨ç¤º s[:i] æ˜¯å¦å¯åˆ† def wordBreak(self, s, wordDict): &quot;&quot;&quot; :type s: str :type wordDict: List[str] :rtype: bool &quot;&quot;&quot; dict =&#123;&#125; for w in wordDict: dict[w] =True dp =[False for x in range(len(s)+1)] dp[0] =True for i in range(1, len(s)+1): # å¦‚æžœå‡ºçŽ°äº† range(i) è¿™ç§æ˜¯å¸¸ç”¨çš„å¤„ç†å­—ç¬¦ä¸²çš„æ‰‹æ®µï¼Œçœ‹å‰i æ˜¯å¦ç¬¦åˆæŸç§è¦æ±‚ # å‰é¢çš„å¯åˆ†ï¼ŒåŽé¢çš„çœ‹ä¸€ä¸‹æ˜¯å¦å¯åˆ† for j in range(i): if dp[j] and s[j:i] in dict: dp[i] =True break return dp[-1] Word Break II Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Tips : dfs 1234567891011121314151617181920212223242526272829303132333435class Solution(object): # ä¸Šä¸€é¢˜æ˜¯è¿”å›ž true or falseï¼Œè¿™ä¸ªæ˜¯è¦æ±‚æ˜¯è·¯å¾„ï¼Œé‚£ä¹ˆæœ€ç›´æŽ¥çš„å°±æ˜¯dfs(), ä¸èƒ½ä½¿ç”¨dpäº† def wordBreak(self, s, wordDict): """ :type s: str :type wordDict: List[str] :rtype: List[str] """ return self.dfs(s, wordDict, &#123;&#125;) def dfs(self, s, wordDict, memo): # è¿™ä¸ªmemo å°±æ˜¯æŸé•¿åº¦çš„å­—ç¬¦ä¸²ï¼Œåœ¨ä¹‹å‰çš„dfs ä¸­æ˜¯å¦å­˜åœ¨è¿‡ # 'penapple': ['pen apple'], 'applepenapple': ['apple pen apple' if s in memo: return memo[s] if not s: return [] res =[] for word in wordDict: # è¿™ç§ç›´æŽ¥ä»Ž dictionary ä¸­å¯»æ‰¾è¦æ¯” ä»Žstring ä¸­æ‹¼å‡‘å¿«ä¸€äº› if not s.startswith(word): # è¿™ä¸ªå°±æ˜¯æœ€è´ªå©ªçš„æ‰¾å¼€å¤´çš„python å¥å­ continue if len(word) ==len(s): # åŒ…å«ä¸”é•¿åº¦ç›¸åŒï¼Œé‚£ä¹ˆ res.append() å°±æ˜¯è¿™ä¸ªæ“ä½œäº† res.append(word) else: rest =self.dfs(s[len(word):], wordDict, memo) # å¦‚æžœåŽŸæ¥çš„ s æ¯”è¾ƒé•¿ é‚£ä¹ˆå°±åˆ‡åˆ†äº† # è¿™ç§ä¸æ”¶ é€’å½’å½±å“çš„æ€ç»´è¿˜æ˜¯æŒºç‰›é€¼çš„ å“ˆå“ˆ for item in rest: item =word +' '+item res.append(item) memo[s] =res return res Palindrome Partitioning Given a string s, partition s such that every substring of the partition is a palindrome.Return all possible palindrome partitioning of s. Tips: dfs, å…¶ä¸­ ispa å†™çš„æ˜¯æ¯”è¾ƒç®€æ´çš„ 123456789101112131415161718192021222324252627class Solution(object): # æ„Ÿè§‰è¿™ä¸ªæœ‰ç‚¹éš¾åº¦å‘€ # æ‰€æœ‰å€¼çš„ä¸€èˆ¬æ˜¯ dfs() è¿™ä¸ªè¿˜æ˜¯å¾—ä¸æ–­çš„åŠ å¼ºè®¤è¯†çš„ï¼Œ def partition(self, s): """ :type s: str :rtype: List[List[str]] """ res =[] self.dfs(s, [], res) return res def dfs(self, s, path, res): if not s: res.append(path) return # å…³é”®æ˜¯è¿™é‡Œçš„ç†è§£ï¼Œ path æ˜¯ä¸æ–­çš„å¢žåŠ çš„ï¼Œå¹¶ä¸” s[I:] è¿™ä¸ªæ˜¯ä¸æ–­çš„ä»‹ç»çš„ï¼Œ # å…ˆæ˜¯è¦æ±‚ s[:i] æ˜¯ palindrome ç„¶åŽé€’å½’ s[i:] æ˜¯palindrome ï¼Œæ•´ä½“ä¸Šæ˜¯æ¯”è¾ƒniceçš„ for i in range(1, len(s)+1): if self.isPal(s[:i]): self.dfs(s[i:], path+[s[:i]], res) def isPal(self, s): return s ==s[::-1] Word Search II Given a 2D board and a list of words from the dictionary, find all words in the board.Each word must be constructed from letters of sequentially adjacent cell, where â€œadjacentâ€ cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Tips: ä½¿ç”¨å­—å…¸æ ‘ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class TrieNode(): def __init__(self): self.children = collections.defaultdict(TrieNode) self.isWord = Falseclass Trie(): def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for w in word: node = node.children[w] node.isWord = True def search(self, word): node = self.root for w in word: node = node.children.get(w) if not node: return False return node.isWord# ä¸Šé¢åœ¨ä¸Šä¸€é“é¢˜ç›®ä¸­å°±åº”è¯¥è®°ä½ï¼Œè¿™ä¸ªæ˜¯ä¸€é“ç»å…¸çš„é¢˜ç›®class Solution(object): def findWords(self, board, words): res = [] trie = Trie() node = trie.root for w in words: trie.insert(w) # å…ˆæ˜¯insertï¼Œç„¶åŽåœ¨æ¯ä¸€ä¸ªç‚¹è¿›è¡ŒæŸ¥æ‰¾ï¼Œæœ€åŽçœ‹res for i in range(len(board)): for j in range(len(board[0])): self.dfs(board, node, i, j, "", res) return res def dfs(self, board, node, i, j, path, res): if node.isWord: res.append(path) node.isWord = False if i &lt; 0 or i &gt;= len(board) or j &lt; 0 or j &gt;= len(board[0]): return tmp = board[i][j] node = node.children.get(tmp) if not node: return board[i][j] = "#" self.dfs(board, node, i + 1, j, path + tmp, res) self.dfs(board, node, i - 1, j, path + tmp, res) self.dfs(board, node, i, j - 1, path + tmp, res) self.dfs(board, node, i, j + 1, path + tmp, res) board[i][j] = tmp Valid Anagram Given two strings s and t , write a function to determine if t is an anagram of s. Tips: dictionary çš„åº”ç”¨ 12345678910111213141516171819202122232425262728293031323334353637class Solution(object): # è¿™ä¸ªå’Œæ—‹è½¬æ•°ç»„ æ„Ÿè§‰ä¸Šæ˜¯å·®ä¸å¤šçš„å‘€ # è§£ç­”çš„æ—¶å€™ï¼Œåº”è¯¥ä»Ž dictionary çš„è§’åº¦è€ƒè™‘ def isAnagram(self, s, t): """ :type s: str :type t: str :rtype: bool """ dic =&#123;&#125; # dic =collections.defaultdic(int) å’Œä¸Šé¢çš„å”¯ä¸€å·®åˆ«å°±æ˜¯ï¼Œç›´æŽ¥ä½¿ç”¨ dic[char] +=1 è¿™æ ·çš„æ“ä½œ # ä¸ç”¨åˆ¤æ–­æ˜¯å¦å­˜åœ¨ è¿™æ ·çš„æ“ä½œ for n in s: if n not in dic: dic[n] =1 else: dic[n] +=1 for n in t: if n not in dic: return False else: dic[n] -=1 """ for n in dic: if dic[n]!=0: return False return True """ for value in dic.values(): if value !=0: return False return True First Unique Character in a String Given a string, find the first non-repeating character in it and return itâ€™s index. If it doesnâ€™t exist, return -1. Tips: æ³¨æ„æ˜¯ç¬¬ä¸€ä¸ª non-repeatingçš„ 1234567891011121314151617181920class Solution(object): # è¿™ä¸ªä¸é‡å¤ æ˜¯æ•´ä½“ä¹‹åŽçš„ä¸é‡å¤ï¼Œè€Œä¸æ˜¯å·¦å³çš„ä¸é‡å¤ï¼Œæ˜¯å…¨å±€çš„ # æˆ‘çš„æƒ³æ³•ä½¿ç”¨dict def firstUniqChar(self, s): """ :type s: str :rtype: int """ dic =&#123;&#125; seen =set() for index, ch in enumerate(s): if ch not in seen: dic[ch] =index seen.add(ch) elif ch in dic: del dic[ch] # è¿™ä¸ªæ˜¯é€šè¿‡æ›´æ–°index è¾¾åˆ°çš„ # å› ä¸ºé¢˜ç›®ä¸­æåˆ°çš„æ˜¯ ç¬¬ä¸€ä¸ª non-repeating Reverse String Write a function that reverses a string. The input string is given as an array of characters char[].Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Tips : in-place æ“ä½œ pointer 123456789101112131415class Solution(object): # æˆ‘åæ‰‹ä¸€ä¸ªreverse() è¿‡åŽ»ï¼Œæœ‰é—®é¢˜å— # sting is immutable, cannot reverse in-place def reverseString(self, s): """ :type s: List[str] :rtype: None Do not return anything, modify s in-place instead. """ left, right =0, len(s)-1 while left &lt; right: s[left], s[right] =s[right], s[left] left +=1 right -=1]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ç®—æ³•æ¨¡æ¿-åŸºç¡€ç®—æ³•]]></title>
    <url>%2F2019%2F02%2F06%2Falgorithm-demo1%2F</url>
    <content type="text"><![CDATA[ä»‹ç»åŸºç¡€æ€§ç®—æ³• åŒæŒ‡é’ˆé—®é¢˜ æœ€é•¿è¿žç»­ä¸é‡å¤å­åºåˆ— æ—¶é—´è´Ÿè´£åº¦æ˜¯ $O(n)$ 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;const int N =100000 +11;int n;int arr[N];int tmp[N];int main()&#123; cin &gt;&gt;n; for(int i =0; i&lt; n ;i++) scanf("%d",&amp;arr[i]); int res =0; for(int i =0,j =0; i&lt; n; i++) &#123; tmp[arr[i]] ++; while(j&lt; i &amp;&amp; tmp[arr[i]] &gt;1) &#123; tmp[arr[j++]] --; &#125; //cout &lt;&lt; i&lt;&lt; " "&lt;&lt; j&lt;&lt;endl; res =max(res, i -j +1); &#125; cout &lt;&lt; res&lt;&lt;endl; return 0;&#125; æ•°ç»„å…ƒç´ çš„ç›®æ ‡å’Œ è¦ä½¿ç”¨åŒæŒ‡é’ˆç®—æ³•ï¼Œå°±è¦æ‰¾åˆ°å…¶ä¸­çš„å•è°ƒæ€§ã€‚å½“iï¼Œj åˆ†åˆ«æŒ‡å‘ Aæ•°ç»„çš„å¼€å¤´å’ŒB æ•°ç»„çš„ç»“å°¾ã€‚å½“ i å‘å³ç§»åŠ¨ï¼Œé‚£ä¹ˆä¸Žä¹‹å¯¹åº”çš„j å¿…ç„¶åœ¨åŽŸå…ˆçš„å·¦è¾¹ã€‚æ‰€ä»¥è¿™å°±ç¬¦åˆå•è°ƒæ€§çš„è¦æ±‚ï¼Œé‚£ä¹ˆå°±å¯ä»¥ä½¿ç”¨åŒæŒ‡é’ˆæ¥åšã€‚ 1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N = 100000+11;int n, m, x;int A[N];int B[N];int main()&#123; cin &gt;&gt;n &gt;&gt;m &gt;&gt;x; for(int i =0; i&lt; n; i++) scanf("%d", &amp;A[i]); for(int i =0; i&lt; m; i++ ) scanf("%d", &amp;B[i]); // ä½¿ç”¨åŒæŒ‡é’ˆç®—æ³•ï¼Œå¿…ç„¶éœ€è¦æ‰¾åˆ°å…¶ä¸­çš„å•è°ƒæ€§ï¼Œ for(int i =0, j =m -1; i&lt; n ; i++) &#123; while(j &gt;=0 &amp;&amp; A[i] +B[j] &gt; x) j --; if(A[i] +B[j] ==x) printf("%d %d", i, j); &#125; return 0;&#125; æœ€é•¿ä¸å«é‡å¤å­—ç¬¦çš„å­å­—ç¬¦ä¸² è¿™é“é¢˜ç›®å’Œä¸Šä¸€é“é¢˜ç›®æ˜¯å¾ˆç›¸ä¼¼çš„ã€‚ã€‚ç¬¬ä¸€ç§è§£æ³•æ˜¯æ˜¯åŒæŒ‡é’ˆè§£æ³•ã€‚ 123456789101112131415161718192021class Solution &#123;public: int longestSubstringWithoutDuplication(string s) &#123; unordered_map&lt;char, int&gt; has; // åŒæŒ‡é’ˆé—®é¢˜ int n =s.size() ; int res =0; for(int i =0, j =0; i&lt; n; i++ ) &#123; has[s[i]] ++; while( j&lt; i &amp;&amp; has[s[i]] &gt;1) &#123; has[s[j]] --; // æ±‚è§£çš„é•¿åº¦ï¼Œå¯ä»¥å…ˆå‡ä¸€ä¸ªå˜´è¯´ j ++; &#125; res =max(res, i -j +1); &#125; return res; &#125;&#125;; ç¬¬äºŒç§è§£æ³•æ˜¯dp è§£æ³•ã€‚ å­—ç¬¦æµä¸­ç¬¬ä¸€ä¸ªåªå‡ºçŽ°ä¸€æ¬¡çš„å­—ç¬¦ å¯¹äºŽè¿™ç§é‡å¤ä¸é‡å¤çš„é¢˜ç›®ï¼Œç»å¸¸ä½¿ç”¨çš„å°±æ˜¯ dictionary è¿›è¡Œåˆ¤æ–­ã€‚ 12345678910111213141516171819202122class Solution&#123;public: // é˜Ÿåˆ—æ¨¡æ‹Ÿè¯»å…¥å’Œå¼¹å‡ºçš„è¿‡ç¨‹ï¼Œ // åˆ°åº• ä»€ä¹ˆæ˜¯dictionaryï¼Œå°±æ˜¯ä¸€ä¸ªå¿«é€Ÿè®¿é—®çš„æ•°æ®ç»“æž„ï¼Œä»Žkey åˆ°valueçš„é‚£ç§ //Insert one char from stringstream unordered_map&lt;char, int&gt; dic; queue&lt;char&gt; q; void insert(char ch)&#123; if( ++dic[ch] &gt;1) &#123; while(q.size() &amp;&amp; dic[q.front()] &gt;1) q.pop(); &#125; else q.push(ch); &#125; //return the first appearence once char in current stringstream char firstAppearingOnce()&#123; if(q.size() &gt;=1) return q.front(); else return '#'; &#125;&#125;; è°ƒæ•´æ•°ç»„é¡ºåºä½¿å¥‡æ•°ä½äºŽå¶æ•°å‰é¢ ä¸¤ä¸ªæŒ‡é’ˆç›¸é‡ï¼Œèµ°è¿‡çš„æ€»è·¯ç¨‹æ˜¯$n$, æ‰€ä»¥æ—¶é—´å¤æ‚åº¦æ˜¯$O(n)$ 12345678910111213class Solution &#123;public: void reOrderArray(vector&lt;int&gt; &amp;array) &#123; int l =0, r =array.size() -1; while(l&lt; r) &#123; while(l &lt; r &amp;&amp; array[l] %2 ==1) l ++; //int t=array[l]; while(l&lt; r &amp;&amp; array[r] %2 ==0) r --; if(l&lt; r) swap(array[l], array[r]); &#125; &#125;&#125;; å’Œä¸ºSçš„è¿žç»­æ­£æ•°åºåˆ— 1234567891011121314151617181920212223class Solution &#123;public: // ä½¿ç”¨i j ä¸¤ä¸ªæŒ‡é’ˆæ“ä½œ vector&lt;vector&lt;int&gt; &gt; findContinuousSequence(int sum) &#123; int i=1, j =2; vector&lt;vector&lt;int&gt;&gt; res; while(i &lt; j &amp;&amp; j&lt; sum) &#123; int total = (j -i+1) *(i +j); if(total == 2*sum) &#123; vector&lt;int&gt; level; for(int k =i; k&lt;=j ; k++) level.push_back(k); res.push_back(level); level.clear(); i ++, j ++; &#125; else if(total &gt; 2*sum) i ++; else j ++; &#125; return res; &#125;&#125;; ç¿»è½¬å•è¯é¡ºåº 12345678910111213141516171819202122232425class Solution &#123;public: // éœ€è¦ç¿»è½¬ä¸¤æ¬¡ï¼Œä¸€æ¬¡ä»¥å­—æ¯ä¸ºå•ä½å…¨ç¿»è½¬ï¼Œä¸€æ¬¡ä»¥å•è¯ä¸ºå•ä½ç¿»è½¬ // å¯ä»¥å¤„ç†å‰åŽæœ‰ç©ºæ ¼ï¼Œä¸­é—´æœ‰å¤šä½™çš„ç©ºæ ¼çš„æƒ…å†µ string reverseWords(string s) &#123; int k =0;// kå­˜å‚¨çš„æ˜¯æœ‰æ•ˆçš„é•¿åº¦ for(int i =0; i&lt; s.size() ; i++) &#123; // æ‰¾åˆ°å­—æ¯å¼€å§‹ int j =i; while(j &lt; s.size() &amp;&amp; s[j] ==' ') j ++; // jæŒ‡å‘çš„æ˜¯éžç©ºæ ¼ if (j ==s.size()) break; // æ‰¾åˆ°å­—æ¯çš„ç»“æŸ i =j; while(j &lt; s.size() &amp;&amp; s[j] !=' ') j++;// jæŒ‡å‘çš„æ˜¯ç©ºæ ¼ //ç»†èŠ‚ï¼Œ if(k) s[k++] =' '; reverse(s.begin() +i, s.begin() +j);// å·¦é—­å³å¼€ while(j -i) s[k++] =s[i++]; &#125; s.erase(s.begin() +k, s.end()); reverse(s.begin(), s.end()); return s; &#125;&#125;; çºªå¿µå“åˆ†ç»„ è´ªå¿ƒç®—æ³• + åŒæŒ‡é’ˆï¼ˆé¢˜ç›®è¿˜æ˜¯æœ‰ä¸€å®šçš„è§„å¾‹ï¼Œæ¯”å¦‚ï¼Œæ“ä½œ jâ€“ é‚£ä¹ˆå¿…é¡» j&gt;=0 ï¼‰ï¼Œå¯¹äºŽè´ªå¿ƒï¼Œå¸¸è§çš„å¥—è·¯å°±æ˜¯ å…ˆæŽ’åºï¼Œç„¶åŽé€‰æ‹©â€œä»·å€¼â€ æœ€å¤§çš„ã€‚å¯¹äºŽåŒæŒ‡é’ˆå¸¸è§çš„å†™æ³• for å¾ªçŽ¯ç„¶åŽæ˜¯while å¾ªçŽ¯ã€‚æœ¬é¢˜çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(nlogn)$. ä¸Šé™æ˜¯sort() å‡½æ•°çš„æŽ’åºç®—æ³•ã€‚ 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 30000 +11;int a[N];bool st[N];int main()&#123; int w,n; cin &gt;&gt;w&gt;&gt; n; for(int i =0; i&lt; n; i++) cin &gt;&gt; a[i]; sort(a, a+n); int res =0; // å°½å¯èƒ½è´ªå¿ƒçš„é€‰æ‹©ï¼Œé€‰æ‹©ä¸¤ä¸ªï¼Œç„¶åŽé€‰æ‹©ä»·å€¼æœ€å¤§çš„ for(int i =0, j =n -1; i&lt; n;i++) &#123; if(st[i]) continue; while( j &gt;= 0&amp;&amp;( st[j] || a[i] +a[j] &gt;w )) j --; st[i] =st[j] =true; res +=1; &#125; cout&lt;&lt; res &lt;&lt;endl; return 0;&#125; æ‰€ä»¥æ¨¡æ¿å¯ä»¥å¤„ç†ä¸¤ç±»é—®é¢˜ã€‚ 123456789for (int i = 0, j = 0; i &lt; n; i ++ )&#123; while (j &lt; i &amp;&amp; check(i, j)) j ++ ; // å…·ä½“é—®é¢˜çš„é€»è¾‘&#125;å¸¸è§é—®é¢˜åˆ†ç±»ï¼š (1) å¯¹äºŽä¸€ä¸ªåºåˆ—ï¼Œç”¨ä¸¤ä¸ªæŒ‡é’ˆç»´æŠ¤ä¸€æ®µåŒºé—´ (2) å¯¹äºŽä¸¤ä¸ªåºåˆ—ï¼Œç»´æŠ¤æŸç§æ¬¡åºï¼Œæ¯”å¦‚å½’å¹¶æŽ’åºä¸­åˆå¹¶ä¸¤ä¸ªæœ‰åºåºåˆ—çš„æ“ä½œ 75. Sort Colors æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n)$ ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯$O(1)$123456789101112131415class Solution &#123;public: // l å’Œr åˆ†åˆ«è¡¨ç¤º 01 è¾¹ç•Œé—®é¢˜ï¼Œ 12 è¾¹ç•Œé—®é¢˜ void sortColors(vector&lt;int&gt;&amp; nums) &#123; int l =0, r =nums.size() -1; int index =0; // æ³¨æ„è¿™ä¸ªè¾¹ç•Œæ¡ä»¶ while( index&lt;=r ) &#123; if(nums[index] ==1) index ++; else if(nums[index] ==0) swap(nums[index++], nums[l++]); else swap(nums[index], nums[r--]); &#125; &#125;&#125;; åˆå¹¶å­åºåˆ—æ—¶é—´å¤æ‚åº¦æ˜¯ $NlogN$ 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;iostream&gt;using namespace std;const int N =1e5+11;typedef pair&lt;int, int&gt; PAIR;int n;vector&lt;PAIR&gt; arr;void merge(vector&lt;PAIR&gt; &amp; segs)&#123; vector&lt;PAIR&gt; res; sort(segs.begin(), segs.end()); int l =-2e9, r =-2e9; for(auto seg : segs) &#123; // å¥½å¥½ç†è§£ä¸ºä»€ä¹ˆä¹‹ç±»æ˜¯ first if(seg.first &gt; r) &#123; if( l != -2e9) res.push_back(&#123;l, r&#125;); l =seg.first, r =seg.second; &#125; else r =max(r, seg.second); &#125; if(l != -2e9) res.push_back(&#123;l, r&#125;); segs =res;&#125;int main()&#123; cin &gt;&gt; n; for(int i =0; i&lt; n; i ++) &#123; int a, b; scanf("%d %d", &amp;a, &amp;b); arr.push_back(&#123;a, b&#125;); &#125; merge(arr); cout &lt;&lt; arr.size() &lt;&lt; endl; return 0;&#125; Insert Interval æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n)$ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯$O(n)$ 1234567891011121314151617181920212223class Solution &#123;public: // è¿™ä¸ªé¢˜ç›®ç›¸å¯¹äºŽ åˆå¹¶åŒºé—´æ˜¯ç®€å•çš„ï¼Œå› ä¸ºä¸€å¼€å§‹æœ‰æœ‰åºçš„ï¼Œç„¶åŽåŠ å…¥ä¸€ä¸ªæ— åºçš„ï¼Œæ€»çš„æ˜¯ O(n) vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123; vector&lt;vector&lt;int&gt;&gt; res; int i=0, n =intervals.size(); // å¦‚æžœintervals ä¸­çš„ä¸€éƒ¨åˆ†æ˜¯å°äºŽ newIntervalçš„å·¦è¾¹ while( i &lt; n &amp;&amp; intervals[i][1] &lt; newInterval[0]) &#123; res.push_back(intervals[i++]); &#125; // å¦‚æžœintervals ä¸­çš„æŸä¸€ä¸ªå’Œ newInterval æœ‰äº¤é›† while(i &lt;n &amp;&amp; intervals[i][0] &lt;= newInterval[1]) &#123; newInterval[0] =min(intervals[i][0], newInterval[0]); newInterval[1] =max(intervals[i][1], newInterval[1]); i++;// è¿™é‡Œéžå¸¸å®¹æ˜“æ‹‰æŽ‰ i ++ &#125; res.push_back(newInterval); while(i&lt; n ) res.push_back(intervals[i++]); return res; &#125;&#125;; é«˜ç²¾åº¦è®¡ç®—åœ¨32ä½æˆ–64ä½æœºå™¨ä¸­ï¼Œintå 4ä¸ªå­—èŠ‚ï¼Œå³32ä½ã€‚C/C++è§„å®šè¯¥å€¼ä¸º-2^31=-2147483648ï¼ˆå¤§æ¦‚æ˜¯ 21 äº¿çš„æ ·å­ï¼‰ã€‚longlong æ˜¯64ä½ã€‚åœ¨å­—ç¬¦ä¸²å¤„ç†çš„æ—¶å€™ï¼ŒåŠ æ³•å’Œä¹˜æ³•éœ€è¦åŠ ä¸Št(å¦‚æžœæœ€åŽt &gt;0)ï¼Œ å¯¹äºŽé™¤æ³•å’Œå‡æ³•ï¼Œéœ€è¦åŽ»æŽ‰æœ€åŽå¤šä½™çš„0. é«˜ç²¾åº¦åŠ æ³• åŸºæœ¬ä¸Šæ˜¯æ­£åºå¤„ç†åŠ æ³•ï¼Œç„¶åŽæ˜¯é€†åºè¾“å‡ºå’Œè¾“å…¥ã€‚ 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;vector&lt;int&gt; add(vector&lt;int&gt; &amp; a, vector&lt;int&gt; &amp; b)&#123; vector&lt;int&gt; res; int t =0; // è¿™ä¸ª iç›¸å½“äºŽæ˜¯æ¯æ¬¡å¤„ç†çš„æ•°å­— // è¿™é‡Œçš„ || æ˜¯ä¸€ä¸ªç»†èŠ‚ï¼Œå¦‚æžœæ˜¯ï¼Œæ˜¯éœ€è¦è¿™æ ·å†™çš„ for(int i =0 ; i&lt; a.size() || i&lt; b.size() ; i++ ) &#123; if(i &lt; a.size() ) t += a[i]; if( i&lt; b.size() ) t += b[i]; res.push_back(t %10); t =t/10; &#125; if(t &gt;0) res.push_back(t); return res;&#125;int main()&#123; string a, b; cin&gt;&gt; a&gt;&gt; b; vector&lt;int&gt; A, B; // ä»Žä½Žä½å¾€é«˜ä½è®¡ç®—çš„ for(int i =a.size() -1; i&gt;=0 ; i--) A.push_back(a[i] -'0'); for(int i =b.size() -1; i&gt;=0. ; i--) B.push_back(b[i] -'0'); // è¾“å‡ºä¹Ÿå¾ˆå¯¹ç§°ï¼Œä¹Ÿæ˜¯é€†åºè¾“å‡ºï¼Œå› ä¸ºå…ˆå¤„ç†çš„ä½Žä½ï¼Œç„¶åŽä½Žä½æ˜¯push_back() åˆ°åŽé¢äº†ï¼Œåº”è¯¥æ˜¯æœ€åŽè¾“å‡º vector&lt;int&gt; res =add(A, B); for(int i =res.size()-1 ; i&gt;=0 ; i-- ) cout&lt;&lt; res[i]; cout &lt;&lt;endl; return 0;&#125; é«˜ç²¾åº¦å‡æ³• 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;vector&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;bool cmp(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)&#123; if(a.size() != b.size() ) return a.size() &gt; b.size() ; for(int i =0; i&lt; a.size() ; i++) &#123; if(a[i] != b[i] ) return a[i] &gt;b[i]; &#125; return true;&#125;// a&gt;=bvector&lt;int&gt; sub(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)&#123; vector&lt;int&gt; res; int t =0; for(int i =0; i&lt; a.size() ; i++) &#123; t = a[i] -t; if(i &lt; b.size()) t -= b[i]; res.push_back( (t+10) %10); // åŠ æ³•ä¸­è¡¥ä½æ“ä½œ if(t &lt;0) t =1; else t =0; &#125; // åŽ»0 çš„æ“ä½œ while(res.size() &gt;0 &amp;&amp; res.back() == 0) res.pop_back(); return res;&#125;int main()&#123; string a, b; cin &gt;&gt; a&gt;&gt; b; vector&lt;int&gt; A, B; for(int i =a.size() -1; i&gt;=0 ; i--) A.push_back(a[i]); for(int i =b.size() -1; i&gt;=0; i--) B.push_back(b[i]); // a &gt;= b if(cmp(A, B)) &#123; vector&lt;int&gt; c =sub(A, B); for(int i =c.size() -1; i&gt;=0; i--) cout &lt;&lt; c[i]; &#125; else &#123; vector&lt;int&gt; c =sub(B, A); cout &lt;&lt; '`'; for(int i =c.size() -1; i&gt;=0; i--) cout &lt;&lt; c[i]; &#125; return 0;&#125; é«˜ç²¾åº¦ä¹˜æ³• ä¸¤ä¸ªæ•°å­—æ˜¯ä¸ä¸€æ ·çš„ï¼Œä¸€ä¸ªæ˜¯éœ€è¦ä½¿ç”¨string è¡¨ç¤ºï¼Œä¸€ä¸ªæ˜¯ä½¿ç”¨int è¡¨ç¤ºå°±è¡Œã€‚ 121â‰¤Açš„é•¿åº¦â‰¤1000001â‰¤Bâ‰¤10000 å®žçŽ°ä»£ç  1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;vector&lt;int&gt; multiply(vector&lt;int&gt; a, int b)&#123; vector&lt;int&gt; res; // è¿™ä¸ªåˆ¤æ–­æ¡ä»¶ä¹Ÿæ˜¯æ¯”è¾ƒç²¾å·§çš„ int t=0; for(int i =0; i&lt; a.size() || !b ; i++) &#123; if(i &lt; a.size()) t +=a[i] *b; res.push_back(t %10); t /= 10; &#125; return res;&#125;// å¯¹äºŽå¤§æ•°è½¬æˆå­—ç¬¦ä¸²ï¼Œé€†åºï¼Œç„¶åŽå¤„ç†ï¼Œé€†åºè¾“å‡ºï¼Œè¿™ä¸ªå°±æ˜¯éžå¸¸common çš„æ“ä½œäº†int main()&#123; string a; int b ; cin &gt;&gt; a&gt;&gt; b; vector&lt;int&gt; A; for(int i =a.size() -1; i&gt;=0; i--) A.push_back(a[i] -'0'); vector&lt;int&gt; res =multiply(A, b); for(int i =res.size() -1; i&gt;=0 ; i--) cout &lt;&lt; res[i]; return 0;&#125; ä¹˜æ³•è¿˜æ˜¯æ¯”è¾ƒnice çš„ã€‚ 12345678910111213141516171819202122232425262728#include&lt;string&gt;#include&lt;vector&gt;#include&lt;iostream&gt;using namespace std;vector&lt;int&gt; a, c;int b;void multiply()&#123; int t =0; for(int i =0; i&lt; a.size(); i++) &#123; t += a[i] *b; c.push_back(t %10); t /=10; &#125; if(t &gt;0) c.push_back(t);&#125;int main()&#123; string A; cin&gt;&gt; A ; cin &gt;&gt; b; for(int i =A.size() -1; i&gt;=0; i--) a.push_back(A[i] -'0'); multiply(); for(int i =c.size() -1; i&gt;=0 ; i--) cout &lt;&lt;c[i]; cout &lt;&lt; endl; return 0;&#125; é«˜ç²¾åº¦é™¤æ³• ï¼ˆä¸ªäººæ„Ÿè§‰è¿™ä¸ªå«åšå¤§æ•°é™¤æ³•æ›´åŠ åˆé€‚ï¼‰ç»™å®šä¸¤ä¸ªæ­£æ•´æ•°Aï¼ŒBï¼Œè¯·ä½ è®¡ç®— A / Bçš„å•†å’Œä½™æ•°ã€‚ é«˜ç²¾åº¦é™¤æ³• 123456789101112131415161718192021222324252627282930313233#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;vector&lt;int&gt; res;void divide(vector&lt;int&gt; &amp; a, int b , int &amp; r)&#123; for(int i =0 ; i&lt; a.size() ; i++) &#123; r =10*r +a[i]; res.push_back(r /b);// è¿™ä¸ªæ˜¯ç»“æžœæ±‚å•†çš„ r %= b; &#125; reverse(res.begin(), res.end()); while(res.size() &gt;0 &amp;&amp; res.back() ==0) res.pop_back();&#125;int main()&#123; string A; vector&lt;int&gt; a; int b; cin &gt;&gt; A; cin &gt;&gt; b; for(int i =0; i&lt; A.size() ; i++) a.push_back(A[i] -'0'); int r =0; divide(a, b, r); // æœ‰æ—¶å€™segment é”™è¯¯çœŸçš„æ˜¯å¾ˆçƒ¦ï¼Œå› ä¸ºå¾ˆæœ‰å¯èƒ½æ˜¯ä¸‹æ ‡çš„é—®é¢˜ï¼Œä¸èƒ½è®¿é—®å¯¼è‡´çš„é”™è¯¯ã€‚ for(int i =res.size() -1; i&gt;=0 ; i--) cout &lt;&lt; res[i]; cout &lt;&lt; endl; cout&lt;&lt; r&lt;&lt; endl; return 0;&#125; ä¸€ç»´å‰ç¼€å’Œæ€æƒ³å¾ˆç®€å•ï¼Œä½¿ç”¨ä¸€ä¸ª $O(n)$ çš„é¢„å¤„ç†ï¼Œç„¶åŽå† $O(1)$ çš„æ—¶é—´å†…å°±å¯ä»¥åŸºä¸‰æ¯ä¸ªæŸ¥è¯¢ã€‚æ‰€ä»¥æ€»çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n)$ ç©ºé—´æ˜¯ $O(N)$. å…³é”®åœ¨äºŽèƒŒä¼šæ¨¡æ¿ï¼Œæ³¨æ„è¾¹ç•Œæ¡ä»¶ã€‚ 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N =1e5;int n,m;int arr[N];int pre[N];// è®°å½•åŽŸæ¥çš„åºåˆ—ï¼Œç©ºé—´ O(n) æ—¶é—´æ˜¯ O(n)int main()&#123; int l, r; cin&gt;&gt; n&gt;&gt;m; for(int i =1; i&lt;=n; i++) &#123; int tmp; cin &gt;&gt;tmp; arr[i] =tmp; &#125; for(int i =1; i&lt;=n; i++) &#123; pre[i] =pre[i-1] +arr[i]; &#125; while(m --) &#123; cin &gt;&gt; l &gt;&gt;r; cout &lt;&lt; pre[r] -pre[l-1] &lt;&lt;endl; &#125; return 0;&#125; è¿˜æœ‰ä¸€ä¸ªå†™æ³•æ˜¯ï¼Œä¸ç”¨ä¿å­˜åŽŸæ¥çš„æ•°ç»„ã€‚123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N =1e5+11;int n, m;int pre[N];int main()&#123; cin &gt;&gt;n&gt;&gt;m; int l, r; for(int i=1; i&lt;=n ; i++) &#123; int tmp; cin &gt;&gt; tmp; // pre[i-1] è¡¨ç¤ºä¹‹å‰çš„ç´¯åŠ å’Œ pre[i] = pre[i-1] +tmp; &#125; while(m --) &#123; cin &gt;&gt; l &gt;&gt;r; cout &lt;&lt; pre[r] -pre[l-1]&lt;&lt; endl; &#125; return 0;&#125; äºŒç»´å‰ç¼€å’ŒäºŒç»´å‰ç¼€å’Œçš„å®šä¹‰è¿˜æ˜¯å¾ˆé‡è¦çš„ï¼Œçœ‹å›¾ $S[i,j]S[i,j] $å³ä¸ºå›¾ä¸­çº¢æ¡†ä¸­æ‰€æœ‰æ•°çš„çš„å’Œä¸ºï¼š $$S[i,j]=S[i,jâˆ’1]+S[iâˆ’1,j]âˆ’S[iâˆ’1,jâˆ’1]+a[i,j]S[i,j]=S[i,jâˆ’1]+S[iâˆ’1,j]âˆ’S[iâˆ’1,jâˆ’1]+a[i,j]$$ $(x1,y1),(x2,y2)(x1,y1),(x2,y2) $è¿™ä¸€å­çŸ©é˜µä¸­çš„æ‰€æœ‰æ•°ä¹‹å’Œä¸ºï¼š $$S[x2,y2]âˆ’S[x1âˆ’1,y2]âˆ’S[x2,y1âˆ’1]+S[x1âˆ’1,y1âˆ’1]$$ è¿™é“é¢˜ç›®çš„å…³é”®æ˜¯æžæ¸…ä¸‹æ ‡ï¼Œæœ€åŽå†æ±‚è§£æŸä¸€ä¸ªåŒºé—´çš„é¢ç§¯çš„æ—¶å€™ï¼Œ $s[x1-1][y2] $å’Œ $s[x2][y1-1] $æ³¨æ„è¿™ç‚¹ã€‚ 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int N =1011;int s[N][N];//int a[N][N];int n,m, q;int main()&#123; cin &gt;&gt;n&gt;&gt;m &gt;&gt;q; for(int i=1; i&lt;=n; i++) &#123; for(int j =1; j&lt;=m ; j++) &#123; //scanf("%d", &amp;a[i][j]); int tmp; scanf("%d", &amp;tmp); s[i][j] = s[i-1][j] +s[i][j -1] -s[i-1][j-1] + tmp; &#125; &#125; while(q--) &#123; int x1, y1, x2, y2; scanf("%d%d%d%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2); // å…³é”®æ˜¯ä¸‹æ ‡å‘€ printf("%d\n", s[x2][y2] - s[x1-1][y2] -s[x2][y1-1] + s[x1-1][y1-1]); &#125; return 0;&#125; å·®åˆ†å‰ç¼€å’Œå·®åˆ†æ˜¯2ä¸ªäº’é€†çš„è¿ç®—ã€‚ è¿™ç§ç­–ç•¥æ˜¯ï¼Œä»¤$b_i = a_i - a_{i-1} $ï¼Œå³ç›¸é‚»ä¸¤æ•°çš„å·®ã€‚æ˜“å¾—å¯¹è¿™ä¸ªåºåˆ—åšä¸€éå‰ç¼€å’Œå°±å¾—åˆ°äº†åŽŸæ¥çš„ $a$åºåˆ—ã€‚ å®ƒå¯ä»¥ç»´æŠ¤å¤šæ¬¡å¯¹åºåˆ—çš„ä¸€ä¸ªåŒºé—´åŠ ä¸Šä¸€ä¸ªæ•°ï¼Œå¹¶åœ¨æœ€åŽè¯¢é—®æŸä¸€ä½çš„æ•°æˆ–æ˜¯å¤šæ¬¡è¯¢é—®æŸä¸€ä½çš„æ•°ã€‚ï¼ˆæ€»ä¹‹ä¿®æ”¹æ“ä½œä¸€å®šè¦åœ¨æŸ¥è¯¢æ“ä½œä¹‹å‰ï¼‰ å…·ä½“æ€Žä¹ˆæžï¼Ÿè­¬å¦‚ä½¿ $[l, r]$ æ¯ä¸ªæ•°åŠ ä¸Šä¸€ä¸ª $k$ ï¼Œå°±æ˜¯ $b_l \leftarrow b_l+k $, $b_{r+1} \leftarrow b_{r+1} - k$ ã€‚æœ€åŽåšä¸€éå‰ç¼€å’Œå°±å¥½äº†ã€‚ æ³¨æ„ç‰¹æ®Šå¤„ï¼šè¿™é“é¢˜æ˜¯å…ˆè¿›è¡Œæ•´ä½“åŒºé—´ä¿®æ”¹ï¼Œæœ€åŽæ‰ç»Ÿä¸€æŸ¥è¯¢ã€‚ æ‰€ä»¥ï¼Œæˆ‘ä»¬åªè¦ç»´æŠ¤ä¸€ä¸ªå·®åˆ†æ•°ç»„å°±è¡Œäº†ã€‚æ€»çš„æ¥è¯´å·®åˆ†æ•°ç»„é€‚ç”¨äºŽç¦»çº¿çš„åŒºé—´ä¿®æ”¹é—®é¢˜ï¼Œå¦‚æžœæ˜¯åœ¨çº¿çš„è¯åº”è¯¥ç”¨çº¿æ®µæ ‘æˆ–å…¶ä»–æ•°æ®ç»“æž„ã€‚ä¸ºä»€ä¹ˆè¦å­˜å·®å€¼å‘¢ï¼Ÿâ€”â€”â€”â€”å› ä¸ºæ•°åˆ—ä¸­çš„æ•°æ»¡ $A[i]=sum{D[1]â€¦D[i]} $,ä¾¿äºŽç”¨é€’æŽ¨æ±‚å¾—æœ€åŽçš„å€¼ã€‚ 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;const int N =1e5+11;int n, m;int arr[N];int s[N];int main()&#123; cin &gt;&gt; n&gt;&gt;m; for(int i =1; i&lt;= n; i++) scanf("%d", &amp;arr[i]); for(int i =1; i&lt;=n; i++) s[i] =arr[i] -arr[i-1]; while(m --) &#123; int l, r,c; cin &gt;&gt; l&gt;&gt; r&gt;&gt;c; s[l] +=c; s[r+1] -=c; &#125; // æ±‚è§£ä¸€ä¸ªå‰ç¼€å’Œ for(int i =1; i&lt;=n ; i++) &#123; s[i] += s[i-1]; cout &lt;&lt; s[i]&lt;&lt;' '; &#125; return 0;&#125; å·®åˆ†çŸ©é˜µ è®²è§£ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;const int N =1011;// æž„é€ å·®åˆ†çŸ©é˜µ// ç»´æŠ¤å·®åˆ†çŸ©é˜µ// æ±‚è§£å‰é¡¹å’Œï¼Œç„¶åŽè¾“å‡ºint a[N][N];int b[N][N];// åœ¨ (x1, y1) å’Œ (x2, y2)è¿™ä¸ªèŒƒå›´å†… +cvoid insert(int x1, int y1, int x2, int y2, int c)&#123; b[x1][y1] +=c; b[x2+1][y1] -= c; b[x1][y2+1] -=c; b[x2+1][y2+1] += c;&#125;int main()&#123; int n, m, q; cin &gt;&gt;n&gt;&gt;m&gt;&gt;q; for(int i =1; i&lt;= n; i++) &#123; for(int j =1; j&lt;= m; j++) &#123; scanf("%d",&amp;a[i][j]); insert(i, j, i, j, a[i][j]); &#125; &#125; while(q--) &#123; int x1, y1, x2, y2, c; cin&gt;&gt; x1&gt;&gt; y1 &gt;&gt;x2&gt;&gt; y2&gt;&gt;c; insert(x1, y1, x2, y2, c); &#125; for(int i =1; i&lt;=n ; i++) &#123; for(int j =1; j&lt;=m ; j++) &#123; b[i][j] +=b[i-1][j] +b[i][j-1] -b[i-1][j-1]; printf("%d ", b[i][j]); &#125; puts(""); &#125; return 0;&#125; åŒºé—´ä¸“é¢˜é¢˜è§£ï¼šç»å¤§éƒ¨åˆ†æ¶‰åŠåˆ°åŒºé—´çš„é¢˜ç›®ç¬¬ä¸€æ­¥è¦åšçš„éƒ½æ˜¯æŒ‰ç…§å·¦ç«¯ç‚¹æˆ–è€…å³ç«¯ç‚¹è¿›è¡ŒæŽ’åºï¼ŒæŽ’å¥½åºåŽæ‰¾åˆ°å…¶ä¸­çš„é€’æŽ¨å…³ç³»ã€‚å…·ä½“åˆ°è¿™ä¸€é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆæŠŠé—®é¢˜è½¬åŒ–æˆæœ€å¤šèƒ½æ‰¾åˆ°å¤šå°‘ä¸ªäº’ä¸é‡å çš„åŒºé—´ã€‚ 56. Merge Intervals Given a collection of intervals, merge all overlapping intervals. åˆå¹¶æ‰€æœ‰çš„é‡åˆçš„åŒºé—´ã€‚æ€è·¯ï¼šåŒå…³é”®å­—æŽ’åºï¼Œå…ˆæŒ‰ç…§ begin æŽ’åºï¼Œç„¶åŽæŒ‰ç…§ end æŽ’åºã€‚ç„¶åŽåœ¨æ·»åŠ çš„æ—¶å€™ï¼Œå¦‚æžœå½“å‰éåŽ†çš„åŒºé—´çš„begin æ˜¯å¤§äºŽcur çš„endï¼Œé‚£ä¹ˆæŠŠ cur çš„åŒºé—´æ”¾åˆ°ç»“æžœä¸­ï¼Œæ›´æ–°cur ä¸ºå½“å‰éåŽ†çš„åŒºé—´ã€‚å¦åˆ™å¦‚æžœéåŽ†çš„åŒºé—´çš„ end æ˜¯å¤§äºŽcur çš„endï¼Œé‚£ä¹ˆæ›´æ–°cur çš„endã€‚æ—¶é—´å¤æ‚åº¦æ˜¯$nlogn$ï¼Œ æŽ’åºç®—æ³•æ˜¯ç“¶é¢ˆã€‚ 123456789101112131415161718192021222324252627282930class Solution &#123;public: typedef pair&lt;int, int&gt; PAIR; // æ•´ä½“çš„æ€è·¯æ˜¯ï¼Œsort(&#123;begin, end&#125;) å…ˆæ˜¯æŒ‰ç…§ç¬¬ä¸€å…³é”®å­—æŽ’åºï¼Œç„¶åŽæŒ‰ç…§ç¬¬äºŒå…³é”®å­—æŽ’åº vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; int n =intervals.size() ; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;PAIR&gt; pre; if(n ==0) return res; for (auto item : intervals) &#123; PAIR t =&#123;item[0], item[1]&#125;; pre.push_back(t); &#125; sort(pre.begin(), pre.end()); vector&lt;int&gt; cur =vector&lt;int&gt;&#123;pre[0].first, pre[0].second&#125;; for(int i =1; i&lt; pre.size(); i++) &#123; if(pre[i].first &gt; cur[1]) &#123; res.push_back(cur); cur =vector&lt;int&gt;&#123;pre[i].first, pre[i].second&#125;; &#125; else if(pre[i].second&gt; cur[1]) cur[1] =pre[i].second; &#125; res.push_back(cur); return res; &#125;&#125;; 57. Insert Interval 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: // è¿™ä¸ªç›¸å¯¹äºŽå‰ä¸€ä¸ªçš„æ€è·¯å¯èƒ½æ˜¯æ¯”è¾ƒéš¾çš„ï¼Œè¯¥å¦‚ä½•åšå‘¢ï¼Ÿ // éœ€è¦è®¾ç½®ä¸€ä¸ªç‰¹æ®Šçš„æ ‡å¿—ä½ï¼Œè¡¨ç¤ºæ˜¯å¦å·²ç»æŠŠ newInterval å¤„ç†æŽ‰äº† vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newinter) &#123; bool flag =false; vector&lt;vector&lt;int&gt;&gt; res; int n =intervals.size(); for(int i =0; i&lt; n; i++) &#123; if(newinter[1] &lt; intervals[i][0]) &#123; if(!flag)&#123; res.push_back(newinter); flag =true; &#125; // å¦‚æžœå·²ç»å¤„ç†è¿‡ newinter ï¼Œè¿™ä¸ªæ—¶å€™å°±å¯ä»¥ä¸æ–­çš„åŠ å…¥åŒºé—´åˆ°æœ€åŽçš„ç»“æžœä¸­åŽ» res.push_back(intervals[i]); &#125; else if(intervals[i][1] &lt; newinter[0]) &#123; res.push_back(intervals[i]); &#125; else &#123; newinter[0] =min(newinter[0], intervals[i][0]); newinter[1] =max(newinter[1], intervals[i][1]); &#125; &#125; //cout &lt;&lt; flag&lt;&lt; endl; if(!flag) &#123; res.push_back(newinter); &#125; return res; &#125;&#125;; æ•°å­¦çŸ¥è¯† åˆ¤æ–­è´¨æ•° ä¸€ä¸ªæ•°çš„å› æ•°éƒ½æ˜¯æˆå¯¹å‡ºçŽ°çš„ï¼šä¾‹å¦‚12 çš„å› æ•°æœ‰3 å’Œ4ï¼Œ2å’Œ6.æ‰€ä»¥æˆ‘ä»¬æ˜¯å¯ä»¥æžšä¸¾è¾ƒå°çš„é‚£ä¸ªï¼Œå³æ ¹å·nï¼Œå‡è®¾è¾ƒå°çš„æ˜¯dï¼Œè¾ƒå¤§çš„æ˜¯n /d primeï¼Œç´ æ•°å’Œè´¨æ•°æ˜¯ä¸€ä¸ªæ„æ€ï¼Œåˆæ•°æ˜¯å…¶ç›¸åçš„æ–¹é¢ã€‚ 1234567891011121314151617181920212223242526// 0å’Œ1 æ—¢éžè´¨æ•°ä¹Ÿéžåˆæ•°ï¼Œ2 æ˜¯æœ€å°çš„è´¨æ•°ï¼Œæœ€å¤§çš„è´¨æ•°ä¸å­˜åœ¨// å¯¹äºŽè´¨æ•°çš„å®šä¹‰ï¼Œå¦‚æžœa åªèƒ½è¢«1 å’Œæœ¬èº«æ•´é™¤ï¼Œé‚£ä¹ˆa å°±æ˜¯è´¨æ•°(a &gt;2)#include&lt;bits/stdc++.h&gt;using namespace std;bool is_prime(int x)&#123; if(x &lt; 2) return false; for(int i =2; i&lt;= x/i; i++) &#123; if(x %i ==0) return false; &#125; return true;&#125;int main()&#123; int n; cin &gt;&gt;n; for(int i =0; i&lt;n; i++) &#123; int tmp; cin &gt;&gt;tmp; if(is_prime(tmp)) cout &lt;&lt; "Yes"&lt;&lt;endl; else cout &lt;&lt; "No" &lt;&lt; endl; &#125; return 0;&#125; AcWing 867. åˆ†è§£è´¨å› æ•° æœ‰äº†ä¸Šé¢çš„è´¨æ•°ï¼Œé‚£ä¹ˆå†æ±‚è§£ä¸€ä¸ªæ•°å­—çš„è´¨å› æ•°åˆ†è§£ï¼Œåº”è¯¥ä¸æ˜¯å¾ˆéš¾çš„äº‹æƒ…ã€‚ 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;// è´¨å› æ•°åˆ†è§£ï¼Œ è¿™ä¸ªæ˜¯èƒ½å¤Ÿä¿è¯è¿‡ç¨‹ä¸­ i æ˜¯è´¨æ•°çš„void divide(int n)&#123; for(int i =2; i&lt;=n ; i++) &#123; // ä½ä¸€ä¸ªè¿™ä¸ªè¿‡ç¨‹ä¸­n æ˜¯ä¸æ–­å‡å°‘çš„ï¼Œæ‰€ä»¥è¿™ä¸ªå¤æ‚åº¦ä¸æ˜¯n^2 if( n%i ==0) &#123; int s =0; // å¯¹äºŽ i è¿™ä¸ªè´¨å› æ•°ï¼Œcouts æ˜¯å¤šå°‘? while(n %i ==0) n /=i, s++; cout &lt;&lt; i &lt;&lt;" "&lt;&lt; s&lt;&lt; endl; &#125; &#125; if(n &gt;1) cout &lt;&lt; n &lt;&lt; " "&lt;&lt; 1&lt;&lt; endl; cout &lt;&lt; endl;&#125;int main()&#123; int n; cin &gt;&gt;n; for(int i =0; i&lt; n; i++) &#123; int a; cin &gt;&gt;a; divide(a); &#125; return 0;&#125; ç­›è´¨æ•° è®²è§£ 123456789101112131415161718192021222324252627282930313233343536373839404142// å®šç†ï¼Œ ä»»æ„æ•´æ•°x çš„å€æ•° 2x 3x ç­‰éƒ½ä¸æ˜¯è´¨æ•°#include&lt;bits/stdc++.h&gt;using namespace std;const int N =1e6+11;int primes[N], cnt;int st[N];// æœ´ç´ ç­› O(nlogn) è¿™æ ·çš„å¤æ‚åº¦void get_primes(int n)&#123; for(int i =2; i&lt;=n ; i++) &#123; if(!st[i]) primes[cnt ++] =i; // æ˜¯ç¬¬ä¸€ä¸ªè´¨æ•°å€æ•°çš„ï¼Œé‚£ä¹ˆå…¨éƒ¨éƒ½ç½®ä¸º trueï¼Œé‚£ä¹ˆä¹…æ— æ³•è®¿é—®äº† for(int j =i +i; j&lt;=n ; j+= i) st[j] =true; &#125;&#125;// è¿™ç§æ–¹æ³•è¯´å®žè¯ï¼Œæ²¡æœ‰çœ‹æ‡‚//çº¿æ€§ç­›é€‰ï¼Œ æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)void get_prime(int x) &#123; for(int i = 2; i &lt;= x; i++) &#123; if(!st[i]) primes[cnt++] = i; for(int j = 0; primes[j] &lt;= x / i; j++) &#123; //å¯¹äºŽä»»æ„ä¸€ä¸ªåˆæ•°xï¼Œå‡è®¾pjä¸ºxæœ€å°è´¨å› å­ï¼Œå½“i&lt;x/pjæ—¶ï¼Œä¸€å®šä¼šè¢«ç­›æŽ‰ st[primes[j]*i] = true; if(i % primes[j] == 0) break; /* 1.i%pj == 0, pjå®šä¸ºiæœ€å°è´¨å› å­ï¼Œpjä¹Ÿå®šä¸ºpj*iæœ€å°è´¨å› å­ 2.i%pj != 0, pjå®šå°äºŽiçš„æ‰€æœ‰è´¨å› å­ï¼Œæ‰€ä»¥pjä¹Ÿä¸ºpj*iæœ€å°è´¨å› å­ */ &#125; &#125;&#125; int main()&#123; int n ; cin &gt;&gt;n; get_prime(n); //get_primes(n); cout &lt;&lt; cnt&lt;&lt; endl; return 0;&#125; AcWing 869. è¯•é™¤æ³•æ±‚çº¦æ•° å¯ä»¥ä»Žå®žçŽ°çš„è§’åº¦æ¯”è¾ƒ åˆæ•°å’Œè´¨æ•°ä¹‹é—´çš„å·®è·ã€‚ é¦–å…ˆåœ¨è®¡ç®—æ—¶å€™çš„åˆå§‹åŒ–å€¼æ˜¯ä¸åŒçš„ï¼Œç„¶åŽå¯¹äºŽå¦‚ä½•æ¡ä»¶çš„ (x%i) çš„å¤„ç†ä¹Ÿæ˜¯ä¸åŒçš„ã€‚ 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; get_divisors(int x)&#123; vector&lt;int&gt; res; for(int i =1; i&lt;= x/i; i++) &#123; if(x %i ==0) &#123; res.push_back(i); // è¿™é‡Œæ˜¯ä¸€ä¸ªç»†èŠ‚ï¼Œå¦‚æžœä¸¤ä¸ªæ•°å­—ç›¸åŒçš„è¯ï¼Œé‚£ä¹ˆåªéœ€è¦æ”¾è¿›åŽ»ä¸€ä¸ªï¼Œä¿è¯ä¸é‡å¤ if(i != x/i) res.push_back(x /i); &#125; &#125; sort(res.begin(), res.end()); return res;&#125;int main()&#123; int n ; cin &gt;&gt;n; for(int i =0; i&lt; n; i++) &#123; int tmp; cin &gt;&gt;tmp; vector&lt;int&gt; res =get_divisors(tmp); for(auto u : res) cout &lt;&lt; u&lt;&lt;" "; cout &lt;&lt; endl; &#125; return 0;&#125; æ±‚è§£çº¦æ•°ä¸ªæ•°å’Œçº¦æ•°ä¹‹å’Œï¼Œå°±æ˜¯ç†è§£ä¸‹é¢çš„å…¬å¼ã€‚æœ‰äº†ä¸Šé¢æ±‚è§£çº¦æ•°çš„ç»éªŒï¼Œé‚£ä¹ˆä¸‹é¢è¿™ä¸ªåº”è¯¥ä¸æ˜¯å¾ˆéš¾ã€‚ 123å¦‚æžœ N = p1^c1 * p2^c2 * ... *pk^ckçº¦æ•°ä¸ªæ•°ï¼š (c1 + 1) * (c2 + 1) * ... * (ck + 1)çº¦æ•°ä¹‹å’Œï¼š (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck) 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MOD =1e9+7;// å› ä¸º hash æ˜¯å¯ä»¥ä½¿ç”¨ first second è¿›è¡Œè®¿é—®çš„ï¼Œæ‰€ä»¥è¿™ä¸ªæœ¬è´¨ä¸Šä¹Ÿæ˜¯ä¸€ç§é”®å€¼å¯¹unordered_map&lt;int ,int&gt; primes;int main()&#123; int n; cin &gt;&gt;n; while(n --) &#123; int x ; cin &gt;&gt;x; for(int i =2; i&lt;= x/i; i++) &#123; while(x %i ==0) &#123; x /=i; primes[i] ++; &#125; &#125; if(x &gt;1) primes[x] ++; &#125; // å¯¹äºŽè¿™ç§å¯èƒ½æœ‰ int æº¢å‡ºï¼Œæ‰€ä»¥ä½¿ç”¨long long æ¥è¿›è¡Œè¡¨ç¤º // å°¤å…¶æ˜¯å‡ºçŽ°äº† 10^9 +7 å–æ¨¡ï¼Œè¿™ç§ï¼Œè¯´æ˜Žæ•°å­—å¾ˆå¤§ï¼Œè¿™ä¸ªæ—¶å€™æ˜¯éœ€è¦ä½¿ç”¨long long æ¥è¡¨ç¤ºç»“æžœçš„ ll ans =1; for(auto item : primes) ans = ans*(item.second +1) %MOD; cout &lt;&lt; ans&lt;&lt; endl; return 0;&#125; æ±‚è§£æœ€å¤§å…¬çº¦æ•° 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int gcb(int a, int b)&#123; return b ? gcb( b,a% b) :a;&#125;int main()&#123; int n ; cin &gt;&gt;n; while(n --) &#123; int a, b; cin &gt;&gt; a&gt;&gt;b; cout &lt;&lt; gcb(a, b)&lt;&lt; endl; &#125; return 0;&#125; å¿«é€Ÿå¹‚ å¿«é€Ÿå¹‚é¡¾åæ€ä¹‰ï¼Œå°±æ˜¯å¿«é€Ÿç®—æŸä¸ªæ•°çš„å¤šå°‘æ¬¡å¹‚ã€‚å…¶æ—¶é—´å¤æ‚åº¦ä¸º O(logâ‚‚N)ï¼Œ ä¸Žæœ´ç´ çš„O(N)ç›¸æ¯”æ•ˆçŽ‡æœ‰äº†æžå¤§çš„æé«˜ã€‚ æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n)$ ä¼˜åŒ–æˆäº† $O(logn)$. æ‰€è°“çš„å¿«é€Ÿå¹‚ï¼Œå°±æ˜¯ä½¿ç”¨å¹³æ–¹çš„æ–¹å¼ï¼Œè€Œä¸æ˜¯ä¸€æ¬¡æ¬¡ä¹˜æ³•è¿›è¡Œå¤„ç†ã€‚ 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;int fast_power(int a, int b, int p)&#123; int res=1; while(b) &#123; if(b &amp;1)// è¿™ä¸ªè¡¨ç¤ºå¥‡æ•° res = 1ll* a*res %p; // è¿™é‡Œä½“çŽ°çš„æ˜¯ logn çš„æ€æƒ³ a = 1ll* a* a %p; b &gt;&gt;= 1; &#125; return res;&#125;int main()&#123; int n; cin &gt;&gt;n; while(n--) &#123; int a, b, p; cin &gt;&gt;a&gt;&gt;b&gt;&gt;p; printf("%d\n", fast_power(a, b, p)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>åŒæŒ‡é’ˆ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pytorch]]></title>
    <url>%2F2019%2F02%2F01%2Fpytorch%2F</url>
    <content type="text"><![CDATA[pytorch å­¦ä¹ ç¬”è®° ä¸ç†è§£çš„åœ°æ–¹ï¼Œä¸€ä¸ªæ˜¯å…³äºŽ nnåŒ…æ­å»ºç½‘ç»œçš„éƒ¨åˆ†ã€‚ pytorch å’Œtorch æ¯”è¾ƒ ç¼–ç¨‹è¯­è¨€ï¼špytorch é‡‡ç”¨pythonè¯­è¨€ï¼Œå®žé™…ä¸Šä½¿ç”¨cè¯­è¨€å’Œc++ åšæŽ¥å£torch é‡‡ç”¨luaï¼Œä½¿ç”¨cè¯­è¨€å’Œlua è¯­è¨€åšæŽ¥å£ï¼ˆlua è¯­è¨€ç›¸å½“äºŽä¸€ä¸ªå°åž‹åŠ å¼ºç‰ˆçš„cè¯­è¨€ï¼Œæ”¯æŒç±»å’Œé¢å‘å¯¹è±¡ï¼‰ä¾èµ–åº“ï¼špytorch å’Œ torch æ¡†æž¶çš„åŒºåˆ«å’Œè”ç³»ï¼špytorch å¯è°ƒç”¨pythonå¼ºå¤§çš„ç¬¬ä¸‰æ–¹åº“ï¼Œæ¯”å¦‚ opencvtorch å¯è°ƒç”¨ lua åº“å‡½æ•°ï¼Œç›®å‰ luaåº“å‡½æ•°æ²¡æœ‰pythonå¤špytorch ä¾èµ–åº“å¤šäºŽ torchæ•ˆçŽ‡ï¼špython çš„debug åŠŸèƒ½æ¯”lua å¼ºå¤§ï¼Œæ‰€ä»¥pytorch æ•ˆçŽ‡é«˜äºŽtorchæ¨¡åž‹å’Œä¸­é—´å˜é‡çš„å…³ç³»ï¼špytorch ä¸­ä¸­é—´å˜é‡éƒ½å­˜åœ¨è®¡ç®—å›¾ä¸­ï¼Œæ‰€ä»¥model å…±äº«ä¸­é—´å˜é‡torch çš„ä¸­é—´å˜é‡åœ¨æ¯ä¸€ä¸ªæ¨¡å—ä¸­ï¼Œæ‰€ä»¥æƒ³è¦è°ƒç”¨å…¶ä»–æ¨¡å—çš„å‚æ•°å°±å¿…é¡»å¤åˆ¶è¿™ä¸ªæ¨¡å—ç„¶åŽå†è°ƒç”¨ æ€»ç»“pytorchå¯ä»¥è¯´æ˜¯torch çš„pythonç‰ˆæœ¬ï¼Œå¹¶å¢žåŠ äº†å¾ˆå¤šæ–°åŠŸèƒ½ å¸¸ç”¨çš„æ¡†æž¶æ¯”è¾ƒ tensorflow èƒŒåŽæ˜¯googleï¼Œ mxnet æ˜¯Amazonï¼ŒpytorchèƒŒåŽæ˜¯Facebookæ¯ä¸ªæ¡†æž¶éƒ½æœ‰å„è‡ªçš„æœ‰ç‚¹ï¼Œæ¯”å¦‚tensorflowçš„å·¥ç¨‹èƒ½åŠ›å¾ˆå¼ºï¼ŒTheanoç‰¹åˆ«é€‚åˆç§‘ç ”ç­‰ç­‰kerasæ˜¯ä¸€ä¸ªå¾ˆé«˜å±‚çš„ç»“æž„ï¼Œå®ƒçš„åŽç«¯æ”¯æŒtheanoå’Œtensorflowï¼Œå®ƒæœ¬è´¨ä¸Šå¹¶ä¸æ˜¯ä¸€ä¸ªæ¡†æž¶ï¼Œåªæ˜¯å¯¹æ¡†æž¶çš„æ“ä½œåšäº†ä¸€ä¸ªå°è£…ï¼Œä½ åœ¨å†™kerasçš„æ—¶å€™å…¶å®žæ˜¯å¯¹å…¶åŽç«¯è¿›è¡Œè°ƒç”¨ï¼Œç›¸å½“äºŽä½ è¿˜æ˜¯åœ¨tensorflowæˆ–è€…theanoä¸Šè·‘ç¨‹åºï¼Œåªä¸è¿‡ä½ æŠŠä½ çš„è¯­è¨€äº¤ç»™keraså¤„ç†äº†ä¸€ä¸‹å˜æˆtensorflowå¬å¾—æ‡‚çš„è¯­è¨€ï¼Œç„¶åŽå†äº¤ç»™tensorflowå¤„ç†ï¼Œè¿™æ ·çš„åŽæžœå½“ç„¶æ–¹ä¾¿ä½ æž„å»ºç½‘ç»œï¼Œæ–¹ä¾¿å®šä¹‰æ¨¡åž‹åšè®­ç»ƒï¼Œæžå¿«çš„æž„å»ºä½ çš„æƒ³æ³•ï¼Œå·¥ç¨‹å®žçŽ°å¾ˆå¼ºï¼Œä½†æ˜¯è¿™æ ·ä¹Ÿæœ‰ä¸€ä¸ªåŽæžœï¼Œé‚£å°±æ˜¯ç»†èŠ‚ä½ æ²¡æœ‰åŠžæ³•æŠŠæŽ§ï¼Œè®­ç»ƒè¿‡ç¨‹é«˜åº¦å°è£…ï¼Œå¯¼è‡´ä½ æ²¡æœ‰åŠžæ³•çŸ¥é“é‡Œé¢çš„å…·ä½“ç»†èŠ‚ï¼Œä»¥åŠæ¯ä¸ªå‚æ•°çš„å…·ä½“ç»†èŠ‚ï¼Œä½¿å¾—è°ƒè¯•å’Œç ”ç©¶å˜å¾—å¾ˆå›°éš¾ã€‚ pytorchçš„æ€æƒ³ PyTorch çš„æž„å»ºè€…è¡¨æ˜Žï¼ŒPyTorch çš„å“²å­¦æ˜¯è§£å†³å½“åŠ¡ä¹‹æ€¥ï¼Œä¹Ÿå°±æ˜¯è¯´å³æ—¶æž„å»ºå’Œè¿è¡Œæˆ‘ä»¬çš„è®¡ç®—å›¾ã€‚è¿™æ°å¥½é€‚åˆ Python çš„ç¼–ç¨‹æ–¹æ³•ï¼Œå› ä¸ºæˆ‘ä»¬ä¸éœ€ç­‰å¾…æ•´ä¸ªä»£ç éƒ½è¢«å†™å…¥æ‰èƒ½çŸ¥é“æ˜¯å¦èµ·ä½œç”¨ã€‚æˆ‘ä»¬å¾ˆå®¹æ˜“è¿è¡Œéƒ¨åˆ†ä»£ç ï¼Œå¹¶å®žæ—¶æ£€æŸ¥å®ƒã€‚ PyTorch æ˜¯ä¸€ä¸ªåŸºäºŽ Python çš„åº“ï¼Œæ—¨åœ¨ä¸ºæ·±åº¦å­¦ä¹ æä¾›ä¸€ä¸ªçµæ´»çš„å¼€å‘å¹³å°ã€‚PyTorch çš„å·¥ä½œæµç¨‹éžå¸¸æŽ¥è¿‘äºŽ Python çš„ç§‘å­¦è®¡ç®—åº“ NumPyã€‚é‚£ä¹ˆä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦ä½¿ç”¨ PyTorch æž„å»ºæ·±åº¦å­¦ä¹ æ¨¡åž‹ï¼Ÿä»¥ä¸‹ä½œè€…æ ¹æ®å®žé™…ç»éªŒæä¾›äº†ä¸‰ä¸ªç†ç”±ï¼š ä¾¿äºŽä½¿ç”¨çš„ APIï¼šå®ƒçš„ä½¿ç”¨å¦‚åŒ Python é‚£æ ·ç®€å•ã€‚ æ”¯æŒ Pythonï¼šæ­£å¦‚ä¸Šæ–‡æ‰€è¿°ï¼ŒPyTorch å¯ä»¥å¹³æ»‘åœ°ä¸Ž Python æ•°æ®ç§‘å­¦æ ˆç›¸ç»“åˆã€‚å®ƒä¸Ž NumPy ä¸€æ ·ç®€å•ï¼Œç”šè‡³æˆ‘ä»¬éƒ½æ„Ÿè§‰ä¸å‡ºå®ƒä»¬çš„åŒºåˆ«ã€‚ åŠ¨æ€è®¡ç®—å›¾ï¼šPyTorch ä¸å†é‡‡ç”¨ç‰¹å®šçš„å‡½æ•°é¢„å®šä¹‰è®¡ç®—å›¾ï¼Œè€Œæ˜¯æä¾›æž„å»ºåŠ¨æ€è®¡ç®—å›¾çš„æ¡†æž¶ï¼Œç”šè‡³æˆ‘ä»¬å¯ä»¥åœ¨è¿è¡Œæ—¶ä¿®æ­£å®ƒä»¬ã€‚è¿™ç§åŠ¨æ€æ¡†æž¶åœ¨æˆ‘ä»¬ä¸çŸ¥é“æ‰€æž„å»ºçš„ç¥žç»ç½‘ç»œéœ€è¦å¤šå°‘å†…å­˜æ—¶éžå¸¸æœ‰ç”¨ã€‚å…¶å®ƒä¸€äº›ä½¿ç”¨ PyTorch çš„ä¼˜ç‚¹è¿˜æœ‰å¤š GPU æ”¯æŒã€è‡ªå®šä¹‰æ•°æ®åŠ è½½å™¨å’Œæžç®€çš„é¢„å¤„ç†è¿‡ç¨‹ç­‰ã€‚ åœ¨è®¨è®º PyTorch çš„å„ä¸ªç»„ä»¶å‰ï¼Œæˆ‘ä»¬éœ€è¦äº†è§£å®ƒçš„å·¥ä½œæµã€‚PyTorch ä½¿ç”¨ä¸€ç§ç§°ä¹‹ä¸º imperative / eager çš„èŒƒå¼ï¼Œå³æ¯ä¸€è¡Œä»£ç éƒ½è¦æ±‚æž„å»ºä¸€ä¸ªå›¾ä»¥å®šä¹‰å®Œæ•´è®¡ç®—å›¾çš„ä¸€ä¸ªéƒ¨åˆ†ã€‚å³ä½¿å®Œæ•´çš„è®¡ç®—å›¾è¿˜æ²¡æœ‰å®Œæˆæž„å»ºï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ç‹¬ç«‹åœ°æ‰§è¡Œè¿™äº›ä½œä¸ºç»„ä»¶çš„å°è®¡ç®—å›¾ï¼Œè¿™ç§åŠ¨æ€è®¡ç®—å›¾è¢«ç§°ä¸ºã€Œdefine-by-runã€æ–¹æ³•ã€‚ PyTorch æä¾›äº† CPU å¼ é‡å’Œ GPU å¼ é‡ï¼Œå¹¶ä¸”æžå¤§åœ°åŠ é€Ÿäº†è®¡ç®—çš„é€Ÿåº¦ã€‚ä»Žå¼ é‡çš„æž„å»ºä¸Žè¿è¡Œå°±èƒ½ä½“ä¼šåˆ° PyTorch ç›¸æ¯” TensorFLow éœ€è¦å£°æ˜Žå¼ é‡ã€åˆå§‹åŒ–å¼ é‡è¦ç®€æ´åœ°å¤šã€‚ä»¥ä¸‹è¯­å¥å°†éšæœºåˆå§‹åŒ–ä¸€ä¸ª 5Ã—3 çš„äºŒç»´å¼ é‡ï¼Œå› ä¸º PyTorch æ˜¯ä¸€ç§åŠ¨æ€å›¾ï¼Œæ‰€ä»¥å®ƒå£°æ˜Žå’ŒçœŸå®žèµ‹å€¼æ˜¯åŒæ—¶è¿›è¡Œçš„ã€‚1torch.Tensor(5, 3) è‹¥æˆ‘ä»¬å¸Œæœ›éšæœºåˆå§‹åŒ–çš„å¼ é‡æœä»ŽæŸäº›åˆ†å¸ƒï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ç›´æŽ¥å¯¹å¼ é‡å¯¹è±¡ä½¿ç”¨ä¸€äº›æ–¹æ³•ã€‚å¦‚ä¸‹åˆå§‹åŒ–çš„å¼ é‡å°†æœä»Žå‡åŒ€åˆ†å¸ƒï¼š1torch.Tensor(5, 3).uniform_(-1, 1) PyTorch åŒæ ·æ”¯æŒå¹¿æ’­ï¼ˆBroadcastingï¼‰æ“ä½œï¼Œä¸€èˆ¬å®ƒä¼šéšå¼åœ°æŠŠä¸€ä¸ªæ•°ç»„çš„å¼‚å¸¸ç»´åº¦è°ƒæ•´åˆ°ä¸Žå¦ä¸€ä¸ªç®—å­ç›¸åŒ¹é…çš„ç»´åº¦ä»¥å®žçŽ°ç»´åº¦å…¼å®¹ã€‚ å¦‚ä¸‹ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸¤ä¸ª GPU å¼ é‡ï¼Œå¹¶å¯¹è¿™ä¸¤ä¸ªå¼ é‡æ‰§è¡ŒçŸ©é˜µä¹˜æ³•ã€‚å½“ç„¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å¦‚ä¸‹æ‰€ç¤ºå°† CPU å¼ é‡è½¬æ¢ä¸º GPU å¼ é‡ã€‚1234567# ä»¥ä¸‹è½¬åŒ–CPUå¼ é‡ä¸ºGPUå¼ é‡x = torch.FloatTensor(5, 3).uniform_(-1, 1)print(x)x = x.cuda(device=0)print(x)x = x.cpu()print(x) AutoGrad æ¨¡å— TensorFlowã€Caffe å’Œ CNTK ç­‰å¤§å¤šæ•°æ¡†æž¶éƒ½æ˜¯ä½¿ç”¨çš„é™æ€è®¡ç®—å›¾ï¼Œå¼€å‘è€…å¿…é¡»å»ºç«‹æˆ–å®šä¹‰ä¸€ä¸ªç¥žç»ç½‘ç»œï¼Œå¹¶é‡å¤ä½¿ç”¨ç›¸åŒçš„ç»“æž„æ¥æ‰§è¡Œæ¨¡åž‹è®­ç»ƒã€‚æ”¹å˜ç½‘ç»œçš„æ¨¡å¼å°±æ„å‘³ç€æˆ‘ä»¬å¿…é¡»ä»Žå¤´å¼€å§‹è®¾è®¡å¹¶å®šä¹‰ç›¸å…³çš„æ¨¡å—ã€‚ PyTorch ä½¿ç”¨çš„æŠ€æœ¯ä¸ºè‡ªåŠ¨å¾®åˆ†ï¼ˆautomatic differentiationï¼‰ï¼Œè¿™ä¸ªæ˜¯ç”¨æ¥è‡ªåŠ¨æ±‚è§£å¾®åˆ†çš„æ¨¡å—ã€‚åœ¨è¿™ç§æœºåˆ¶ä¸‹ï¼Œç³»ç»Ÿä¼šæœ‰ä¸€ä¸ª Recorder æ¥è®°å½•æˆ‘ä»¬æ‰§è¡Œçš„è¿ç®—ï¼Œç„¶åŽå†åå‘è®¡ç®—å¯¹åº”çš„æ¢¯åº¦ã€‚è¿™ç§æŠ€æœ¯åœ¨æž„å»ºç¥žç»ç½‘ç»œçš„è¿‡ç¨‹ä¸­ååˆ†å¼ºå¤§ï¼Œå› ä¸ºæˆ‘ä»¬å¯ä»¥é€šè¿‡è®¡ç®—å‰å‘ä¼ æ’­è¿‡ç¨‹ä¸­å‚æ•°çš„å¾®åˆ†æ¥èŠ‚çœæ—¶é—´ã€‚ ä»Žæ¦‚å¿µä¸Šè®², Autograd å¯¹æ•°æ®è®°å½•è®°å½•äº†ä¸€ä¸ªæœ‰å‘æ— çŽ¯å›¾ï¼ˆDAGï¼‰ï¼Œ å«åšè®¡ç®—å›¾ï¼Œç”¨æ¥è¡¨ç¤ºå®ƒçš„è®¡ç®—è¿‡ç¨‹ã€‚æ²¿ç€è®¡ç®—å›¾åº”ç”¨é“¾å¼æ±‚å¯¼æ³•åˆ™å°±å¯ä»¥æ±‚å‡ºå…¶æ¢¯åº¦ã€‚Autograd åŒ…ä¸­æœ‰ä¸¤ä¸ªæ ¸å¿ƒåŒ…ï¼š torch.Tensor å’Œtorch.Functionï¼Œ é»˜è®¤æŸä¸ª tensorçš„å±žæ€§æ˜¯ .requires_grad ä¸ºtrueï¼Œå½“è®¡ç®—å®Œæˆçš„æ—¶å€™å¯ä»¥è°ƒç”¨ .backward() æ¥è‡ªåŠ¨è®¡ç®—æ‰€æœ‰çš„æ¢¯åº¦ï¼Œé’ˆå¯¹è¿™ä¸ªtensor å¯ä»¥åœ¨ .grad å±žæ€§ä¸­åŽ»æŸ¥çœ‹ã€‚ è®¾ç½®ä¸€ä¸ªå¼ é‡ä¸è·Ÿè¸ªåŽ†å²è®°å½•çš„æ–¹æ³•ï¼š è°ƒç”¨ .detach() å°†å…¶ä»Žè®¡ç®—åŽ†å²ä¸­åˆ†ç¦»å‡ºæ¥ ä½¿ç”¨ torch.no_grad() åŒ…è£¹ä»£ç å—ï¼Œé‚£ä¹ˆåœ¨è¯¥ä»£ç å—ä¸­çš„è®¡ç®—éƒ½ä¸ä¼šè®¡ç®—æ¢¯åº¦ã€‚ä½¿ç”¨çš„æƒ…å†µæ˜¯ï¼Œ åœ¨è¯„ä¼°é˜¶æ®µï¼ˆpredictï¼‰é˜¶æ®µã€‚ è®¾ç½®æŸä¸ªtensor çš„å±žæ€§ä¸º Required_grad =False Function ç±»ï¼Œæ¯ä¸€ä¸ªtensoréƒ½æœ‰ä¸€ä¸ª.grad_fn å±žæ€§æŒ‡å‘ä¸€ä¸ª Functionï¼Œè¡¨ç¤ºå¦‚ä½•å¾—åˆ°äº†å½“æœŸçš„tensorã€‚å¦‚æžœæ˜¯ç”¨æˆ·è‡ªå·±åˆ›å»ºçš„å¼ é‡tensorï¼Œé‚£ä¹ˆ grad_fn is Noneã€‚ .requires_gradå…·æœ‰ä¼ é€’æ€§ï¼Œæ¯”å¦‚è¯´ $x_1, x_2, \dots, x_n$ ä¸­æŸä¸€ä¸ªæ»¡è¶³ required_grad =Trueï¼Œé‚£ä¹ˆè¿™ä¸ªæ—¶å€™ç”±è¿™äº›tensorè¡¨ç¤ºtensor çš„å±žæ€§éƒ½æ˜¯trueã€‚ æœ€ä¼˜åŒ–æ¨¡å—torch.optim æ˜¯å®žçŽ°ç¥žç»ç½‘ç»œä¸­å¤šç§ä¼˜åŒ–ç®—æ³•çš„æ¨¡å—ï¼Œå®ƒç›®å‰å·²ç»æ”¯æŒå¤§å¤šæ•°ä¸€èˆ¬çš„æ–¹æ³•ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸éœ€è¦ä»Žå¤´æž„å»ºä¼˜åŒ–ç®—æ³•ã€‚ä»¥ä¸‹å±•ç¤ºäº†ä½¿ç”¨ Adam ä¼˜åŒ–å™¨çš„åŸºæœ¬ä»£ç ï¼š1optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate) æˆ‘ä»¬ä¸€èˆ¬å¯ä»¥ä½¿ç”¨ torch.nn åŒ…æž„å»ºç¥žç»ç½‘ç»œï¼Œä¸‹é¢æä¾›äº†ä¸€äº› API çš„è¡¨è¾¾åŠæ„ä¹‰ï¼š çº¿æ€§å±‚- nn.Linearã€nn.Bilinear å·ç§¯å±‚ - nn.Conv1dã€nn.Conv2dã€nn.Conv3dã€nn.ConvTranspose2d éžçº¿æ€§æ¿€æ´»å‡½æ•°- nn.Sigmoidã€nn.Tanhã€nn.ReLUã€nn.LeakyReLU æ± åŒ–å±‚ - nn.MaxPool1dã€nn.AveragePool2d å¾ªçŽ¯ç½‘ç»œ - nn.LSTMã€nn.GRU å½’ä¸€åŒ– - nn.BatchNorm2dDropout - nn.Dropoutã€nn.Dropout2d åµŒå…¥ - nn.Embedding æŸå¤±å‡½æ•° - nn.MSELossã€nn.CrossEntropyLossã€nn.NLLLoss å¼ é‡12import torcha = torch.FloatTensor(5, 7) ç›¸åŒç‚¹ / ä¸åŒç‚¹ç¬¬ä¸€ä¸ªåŒºåˆ«æ˜¯ï¼Œæ‰€æœ‰çš„æ“ä½œåœ¨å¼ é‡æ“ä½œéœ€è¦æœ‰åŽç¼€ã€‚ä¾‹å¦‚ï¼Œaddåœ¨æ­¤å¤„æ— ç”¨ï¼Œä½¿ç”¨addæ˜¯å¯ç”¨çš„ã€‚ 123456a.fill_(3.5)# å°†aå¡«å……å€¼3.5ã€‚b = a.add(4.0)# a ä¾ç„¶æ˜¯å¡«å……3.5# æ–°å¼ é‡bçš„è¿”å›žå€¼ä¸º3.5 + 4ï¼7.5ã€‚print(a, b) é›¶ç´¢å¼•123b = a[0, 3] # é€‰æ‹©aä¸­çš„1è¡Œ4åˆ—b = a[:, 3:5] # ä»Žaä¸­é€‰æ‹©æ‰€ä»¥è¡Œçš„4åˆ°5åˆ—x.index_add_(1, torch.LongTensor([4, 0]), z) ä¸‹ä¸€ä¸ªå°çš„åŒºåˆ«æ˜¯æ‰€æœ‰çš„åŠŸèƒ½çŽ°åœ¨éƒ½ä¸æ˜¯é©¼å³°å‘½åäº†ã€‚ä¾‹å¦‚indexAddçŽ°åœ¨è°ƒç”¨index_add_ CUDAä¼ æ„Ÿå™¨åœ¨pytorchä¸­å¾ˆå¥½å¹¶ä¸”å¾ˆå®¹æ˜“ï¼Œå¹¶å°†CUDAå¼ é‡ä»ŽCPUè½¬ç§»åˆ°GPUå°†ä¿ç•™å…¶åŸºç¡€ç±»åž‹ã€‚123456789# æŸ¥çœ‹ç”µè„‘æ˜¯å¦æ”¯æŒCUDAif torch.cuda.is_available(): # åˆ›å»ºä¸€ä¸ªLongTensorå¹¶ä¸”æŠŠå®ƒå…¨éƒ¨è½¬æ¢ä¸º3 # to GPU as torch.cuda.LongTensor a = torch.LongTensor(10).fill_(3).cuda() print(type(a)) b = a.cpu() # transfers it to CPU, back to # being a torch.LongTensor åŸºæœ¬ç±»åž‹Tensorçš„åŸºæœ¬æ•°æ®ç±»åž‹æœ‰äº”ç§ï¼š 32ä½æµ®ç‚¹åž‹ï¼štorch.FloatTensorã€‚ (é»˜è®¤) 64ä½æ•´åž‹ï¼štorch.LongTensorã€‚ 32ä½æ•´åž‹ï¼štorch.IntTensorã€‚ 16ä½æ•´åž‹ï¼štorch.ShortTensorã€‚ 64ä½æµ®ç‚¹åž‹ï¼štorch.DoubleTensorã€‚ numpy å’Œ tensor ä¹‹é—´çš„ç›¸äº’è½¬æ¢ ä½¿ç”¨numpy æ–¹æ³•å°†tensor è½¬æ¢æˆ ndarray1234a = torch.randn((3, 2))# tensorè½¬åŒ–ä¸ºnumpynumpy_a = a.numpy()print(numpy_a) numpyè½¬åŒ–ä¸ºTensor12torch_a = torch.from_numpy(numpy_a)torch_a ä¸€èˆ¬æƒ…å†µä¸‹å¯ä»¥ä½¿ç”¨.cudaæ–¹æ³•å°†tensorç§»åŠ¨åˆ°gpuï¼Œè¿™æ­¥æ“ä½œéœ€è¦cudaè®¾å¤‡æ”¯æŒ 12cpu_a=torch.rand(4, 3)cpu_a.type() 12gpu_a=cpu_a.cuda()gpu_a.type() ä½¿ç”¨.cpu å°†tensor è½¬æ¢æˆcpu12cpu_b=gpu_a.cpu()cpu_b.type() å¦‚æžœæˆ‘ä»¬æœ‰å¤šGPUçš„æƒ…å†µï¼Œå¯ä»¥ä½¿ç”¨toæ–¹æ³•æ¥ç¡®å®šä½¿ç”¨é‚£ä¸ªè®¾å¤‡ï¼Œè¿™é‡Œåªåšä¸ªç®€å•çš„å®žä¾‹ï¼š123456#ä½¿ç”¨torch.cuda.is_available()æ¥ç¡®å®šæ˜¯å¦æœ‰cudaè®¾å¤‡device = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;)print(device)#å°†tensorä¼ é€åˆ°è®¾å¤‡gpu_b=cpu_b.to(device)gpu_b.type() ä¸‹ä¸€ç« ä»‹ç»PyTorchçš„è‡ªåŠ¨æ±‚å¯¼æœºåˆ¶ å˜é‡ æ¢¯åº¦ ä»Ž0.4èµ·, Variable æ­£å¼åˆå¹¶å…¥Tensorç±», é€šè¿‡VariableåµŒå¥—å®žçŽ°çš„è‡ªåŠ¨å¾®åˆ†åŠŸèƒ½å·²ç»æ•´åˆè¿›å…¥äº†Tensorç±»ä¸­ã€‚è™½ç„¶ä¸ºäº†ä»£ç çš„å…¼å®¹æ€§è¿˜æ˜¯å¯ä»¥ä½¿ç”¨Variable(tensor)è¿™ç§æ–¹å¼è¿›è¡ŒåµŒå¥—, ä½†æ˜¯è¿™ä¸ªæ“ä½œå…¶å®žä»€ä¹ˆéƒ½æ²¡åšã€‚æ‰€ä»¥ï¼Œä»¥åŽçš„ä»£ç å»ºè®®ç›´æŽ¥ä½¿ç”¨Tensorç±»è¿›è¡Œæ“ä½œï¼Œå› ä¸ºå®˜æ–¹æ–‡æ¡£ä¸­å·²ç»å°†Variableè®¾ç½®æˆè¿‡æœŸæ¨¡å—ã€‚è¦æƒ³é€šè¿‡Tensorç±»æœ¬èº«å°±æ”¯æŒäº†ä½¿ç”¨autogradåŠŸèƒ½ï¼Œåªéœ€è¦è®¾ç½®.requries_grad=Trueã€‚ Variableç±»ä¸­çš„çš„gradå’Œgrad_fnå±žæ€§å·²ç»æ•´åˆè¿›å…¥äº†Tensorç±»ä¸­ æ¯ä¸ªå˜é‡éƒ½æœ‰ä¸¤ä¸ªæ ‡å¿—ï¼šrequires_gradå’Œvolatileã€‚å®ƒä»¬éƒ½å…è®¸ä»Žæ¢¯åº¦è®¡ç®—ä¸­ç²¾ç»†åœ°æŽ’é™¤å­å›¾ï¼Œå¹¶å¯ä»¥æé«˜æ•ˆçŽ‡ã€‚ requires_gradå¦‚æžœæœ‰ä¸€ä¸ªå•ä¸€çš„è¾“å…¥æ“ä½œéœ€è¦æ¢¯åº¦ï¼Œå®ƒçš„è¾“å‡ºä¹Ÿéœ€è¦æ¢¯åº¦ã€‚ç›¸åï¼Œåªæœ‰æ‰€æœ‰è¾“å…¥éƒ½ä¸éœ€è¦æ¢¯åº¦ï¼Œè¾“å‡ºæ‰ä¸éœ€è¦ã€‚å¦‚æžœå…¶ä¸­æ‰€æœ‰çš„å˜é‡éƒ½ä¸éœ€è¦æ¢¯åº¦è¿›è¡Œï¼ŒåŽå‘è®¡ç®—ä¸ä¼šåœ¨å­å›¾ä¸­æ‰§è¡Œã€‚ è¿™ä¸ªæ ‡å¿—ç‰¹åˆ«æœ‰ç”¨ï¼Œå½“æ‚¨æƒ³è¦å†»ç»“éƒ¨åˆ†æ¨¡åž‹æ—¶ï¼Œæˆ–è€…æ‚¨äº‹å…ˆçŸ¥é“ä¸ä¼šä½¿ç”¨æŸäº›å‚æ•°çš„æ¢¯åº¦ã€‚ä¾‹å¦‚ï¼Œå¦‚æžœè¦å¯¹é¢„å…ˆè®­ç»ƒçš„CNNè¿›è¡Œä¼˜åŒ–ï¼Œåªè¦åˆ‡æ¢å†»ç»“æ¨¡åž‹ä¸­çš„requires_gradæ ‡å¿—å°±è¶³å¤Ÿäº†ï¼Œç›´åˆ°è®¡ç®—åˆ°æœ€åŽä¸€å±‚æ‰ä¼šä¿å­˜ä¸­é—´ç¼“å†²åŒºï¼Œå…¶ä¸­çš„ä»¿å°„å˜æ¢å°†ä½¿ç”¨éœ€è¦æ¢¯åº¦çš„æƒé‡å¹¶ä¸”ç½‘ç»œçš„è¾“å‡ºä¹Ÿå°†éœ€è¦å®ƒä»¬ã€‚ volatile çº¯ç²¹çš„inferenceæ¨¡å¼ä¸‹æŽ¨èä½¿ç”¨volatileï¼Œå½“ä½ ç¡®å®šä½ ç”šè‡³ä¸ä¼šè°ƒç”¨.backward()æ—¶ã€‚å®ƒæ¯”ä»»ä½•å…¶ä»–è‡ªåŠ¨æ±‚å¯¼çš„è®¾ç½®æ›´æœ‰æ•ˆâ€”â€”å®ƒå°†ä½¿ç”¨ç»å¯¹æœ€å°çš„å†…å­˜æ¥è¯„ä¼°æ¨¡åž‹ã€‚volatileä¹Ÿå†³å®šäº†require_grad is Falseã€‚ volatileä¸åŒäºŽrequire_gradçš„ä¼ é€’ã€‚å¦‚æžœä¸€ä¸ªæ“ä½œç”šè‡³åªæœ‰æœ‰ä¸€ä¸ªvolatileçš„è¾“å…¥ï¼Œå®ƒçš„è¾“å‡ºä¹Ÿå°†æ˜¯volatileã€‚Volatilityæ¯”â€œä¸éœ€è¦æ¢¯åº¦â€æ›´å®¹æ˜“ä¼ é€’â€”â€”åªéœ€è¦ä¸€ä¸ªvolatileçš„è¾“å…¥å³å¯å¾—åˆ°ä¸€ä¸ªvolatileçš„è¾“å‡ºï¼Œç›¸å¯¹çš„ï¼Œéœ€è¦æ‰€æœ‰çš„è¾“å…¥â€œä¸éœ€è¦æ¢¯åº¦â€æ‰èƒ½å¾—åˆ°ä¸éœ€è¦æ¢¯åº¦çš„è¾“å‡ºã€‚ä½¿ç”¨volatileæ ‡å¿—ï¼Œæ‚¨ä¸éœ€è¦æ›´æ”¹æ¨¡åž‹å‚æ•°çš„ä»»ä½•è®¾ç½®æ¥ç”¨äºŽinferenceã€‚åˆ›å»ºä¸€ä¸ªvolatileçš„è¾“å…¥å°±å¤Ÿäº†ï¼Œè¿™å°†ä¿è¯ä¸ä¼šä¿å­˜ä¸­é—´çŠ¶æ€ã€‚ å‚è€ƒå®˜æ–¹æ•™ç¨‹ PyTorch åŸºç¡€ : ç¥žç»ç½‘ç»œåŒ…nnå’Œä¼˜åŒ–å™¨optm pytorch å­¦ä¹ ç¬”è®° pytorch çš„æ ¸å¿ƒä¸»è¦æ˜¯æä¾›äº†ä¸¤ä¸ªä¸»è¦çš„åŠŸèƒ½ï¼š nç»´tensorï¼Œç±»ä¼¼numpyï¼Œä½†å¯ä»¥è¿è¡Œåœ¨GPU ä¸ŠNumpyæ˜¯ç§‘å­¦è®¡ç®—çš„é€šç”¨æ¡†æž¶;å®ƒå¯¹è®¡ç®—å›¾å½¢ã€æ·±åº¦å­¦ä¹ æˆ–æ¢¯åº¦ä¸€æ— æ‰€çŸ¥ã€‚Tensorå¼ é‡æ˜¯pytorch ä¸­æœ€åŸºæœ¬çš„æ¦‚å¿µã€‚PyTorchå¼ é‡å¯ä»¥åˆ©ç”¨GPUåŠ é€Ÿå…¶æ•°å­—è®¡ç®—ã€‚è¦åœ¨GPUä¸Šè¿è¡ŒPyTorch Tensorï¼Œè¯·åœ¨æž„é€ Tensoræ—¶ä½¿ç”¨deviceå‚æ•°å°†Tensoræ”¾ç½®åœ¨GPUä¸Šã€‚ è‡ªåŠ¨å¾®åˆ†ï¼Œç”¨äºŽæž„å»ºå’Œè®­ç»ƒç¥žç»ç½‘ç»œä½¿ç”¨è‡ªåŠ¨å¾®åˆ†æ¥è‡ªåŠ¨è®¡ç®—ç¥žç»ç½‘ç»œä¸­çš„åå‘é€šè¿‡ã€‚ åœ¨æ­å»ºç½‘ç»œçš„è¿‡ç¨‹ä¸­ï¼Œç½‘ç»œä¸­çš„æ­£å‘ä¼ æ’­å®šä¹‰ä¸ºä¸€ä¸ª computational graphè®¡ç®—å›¾ï¼š å›¾ä¸­çš„èŠ‚ç‚¹ä¸ºå¼ é‡ï¼Œè¾¹ä¸ºä»Žè¾“å…¥å¼ é‡äº§ç”Ÿè¾“å‡ºå¼ é‡çš„å‡½æ•°ï¼Œç„¶åŽé€šè¿‡æ”¹å›¾è¿›è¡Œåå‘ä¼ æ’­ï¼Œå¯ä»¥è½»æ¾è®¡ç®—æ¢¯åº¦ã€‚é»˜è®¤å¼ é‡ä¸­çš„å‚æ•° require_grad=Trueï¼Œ é‚£ä¹ˆåœ¨åå‘ä¼ æ’­çš„æ—¶å€™ï¼Œ x.gradå°†æ˜¯å¦ä¸€ä¸ªå¼ é‡ï¼Œ å®ƒä¿æŒäº†x ç›¸å¯¹äºŽæŸä¸ªæ ‡é‡å€¼çš„æ¢¯åº¦ã€‚å¦‚æžœåœ¨è®­ç»ƒç¥žç»ç½‘ç»œçš„æ—¶å€™ï¼Œæ¯”å¦‚é€šå¸¸ä¸æƒ³è¦æ›´æ–°æ­¥éª¤ä¸­å‘åŽä¼ æ’­ï¼ˆå½¢æˆè®¡ç®—å›¾ï¼‰ï¼Œé‚£ä¹ˆè¿™ä¸ªæ—¶å€™å¯ä»¥ä½¿ç”¨ torch.no_grad() ä¸Šä¸‹æ–‡ç®¡ç†å™¨æ¥é˜²æ­¢æž„å»ºè®¡ç®—å›¾ã€‚ pytorch ä¸­çš„è®¡ç®—å›¾å¾ˆæƒ³ tensorflow ä¸­çš„è®¡ç®—å›¾ï¼Œä½†æ˜¯ä¸¤è€…ä¸åŒåœ¨äºŽå‰è€…æ˜¯åŠ¨æ€å›¾ï¼ŒåŽè€…æ˜¯é™æ€å›¾ã€‚åœ¨tensorflow ä¸­ï¼Œå¦‚æžœå®šä¹‰äº†ä¸€ä¸ªè®¡ç®—å›¾ï¼Œç„¶åŽä¸€ééè®¡ç®—ç›¸åŒçš„å›¾ï¼Œå¯èƒ½å°†ä¸åŒçš„è¾“å…¥æ•°æ®æä¾›ç»™å›¾ã€‚åœ¨pytorch ä¸­ï¼Œæ¯ä¸€ä¸ªå‰å‘ä¼ æ’­éƒ½å®šä¹‰äº†ä¸€ä¸ªæ–°çš„è®¡ç®—å›¾ã€‚é™æ€å›¾çš„ä¼˜åŠ¿ï¼Œå¯ä»¥é¢„å…ˆä¼˜åŒ–å›¾ï¼Œæ¯”å¦‚è¯´èžåˆæŸäº›å›¾çš„æ“ä½œï¼Œåˆ†å¸ƒå¼ä¹‹ç±»çš„ã€‚è€ŒåŠ¨æ€å›¾ï¼Œå…¥é—¨æ¯”è¾ƒç®€å•ï¼Œæ–¹ä¾¿debugã€‚ pytorchä¸­å¸¸è§çš„åŒ…ï¼š nn å®šä¹‰äº†ä¸€ç»„æ¨¡å—ï¼ŒåŒ…æ‹¬ç¥žç»ç½‘ç»œå±‚å’Œæœ‰ç”¨çš„æŸå¤±å‡½æ•° optimï¼ˆä¼˜åŒ–å™¨ï¼‰ï¼Œä¼˜åŒ–ç®—æ³•çš„æ€æƒ³ï¼Œ æ¯”å¦‚è¯´ adagradï¼Œ rmspropï¼Œ adam 123456# å¸¸è§çš„æ“ä½œè°ƒç”¨æ¨¡åž‹å‰å‘ä¼ æ’­ y_pred = model(x)è°ƒç”¨æŸå¤±å‡½æ•° loss = loss_fn(y_pred, y)æ¢¯åº¦å½’é›¶ optimizer.zero_grad()åŽå‘ä¼ æ’­ loss.backward()è°ƒç”¨ä¼˜åŒ–å™¨æ›´æ–°å‚æ•° optimizer.step() ä½¿ç”¨ custom nn moduleï¼ˆè¿™ç§æ˜¯ç»å¸¸ç”¨åˆ°ï¼Œæ­å»ºè‡ªå·±çš„nn ç½‘ç»œï¼‰é€šè¿‡å­ç±»nn.Moduleå¹¶å®šä¹‰ä¸€ä¸ªforwadè¾“å…¥æ¥å®šä¹‰è‡ªå·±çš„æ¨¡å—ï¼Œè¯¥å‰å‘æŽ¥æ”¶è¾“å…¥å¼ é‡å¹¶ä½¿ç”¨å…¶ä»–æ¨¡å—æˆ–åœ¨å¼ é‡ä¸Šçš„å…¶ä»–è‡ªåŠ¨è½¬æ¢æ“ä½œäº§ç”Ÿè¾“å‡ºå¼ é‡ã€‚ control flow and weight sharingè¿™ä¸ªæƒå€¼å…±äº«åœ¨RNN ä¸­ä½¿ç”¨æ¯”è¾ƒå¤šï¼Œä½†æ˜¯ä¸æ˜¯å¾ˆå¤šå‘€ï¼Œå¤šçœ‹ä¾‹å­æŠŠ~ å‚è€ƒæ–‡çŒ® ä»‹ç»PyTorchçš„ç®€å•ç¤ºä¾‹LEARNING PYTORCH WITH EXAMPLES]]></content>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Regular Expression]]></title>
    <url>%2F2019%2F01%2F22%2Fregular-expression%2F</url>
    <content type="text"><![CDATA[ä»‹ç»æ­£åˆ™è¡¨è¾¾å¼ æ­£åˆ™è¡¨è¾¾å¼ä½¿ç”¨å•ä¸ªå­—ç¬¦ä¸²æ¥æè¿°ã€åŒ¹é…ä¸€ç³»åˆ—åŒ¹é…æŸä¸ªå¥æ³•è§„åˆ™çš„å­—ç¬¦ä¸²ã€‚æ¢å¥è¯è¯´ï¼Œæ­£åˆ™è¡¨è¾¾å¼å°±æ˜¯è®°å½•æ–‡æœ¬è§„åˆ™çš„ä»£ç ã€‚æ­£åˆ™è¡¨è¾¾å¼(Regular Expression)æ˜¯ä¸€ç§æ–‡æœ¬æ¨¡å¼ï¼ŒåŒ…æ‹¬æ™®é€šå­—ç¬¦ï¼ˆä¾‹å¦‚ï¼Œa åˆ° z ä¹‹é—´çš„å­—æ¯ï¼‰å’Œç‰¹æ®Šå­—ç¬¦ï¼ˆç§°ä¸ºâ€å…ƒå­—ç¬¦â€ï¼‰ã€‚ æ­£åˆ™è¡¨è¾¾å¼çš„å·¥ä½œæœºåˆ¶123456789101112131415161718 +--------+ | ç¼–è¯‘ | +--------+ | â†“+----------------+| è®¾ç½®å¼€å§‹ä½ç½® |â†---------++----------------+ â†‘ | | â†“ å…¶ |+----------------+ ä»– || åŒ¹é… &amp; å›žæº¯ | è·¯ |+----------------+ å¾„ | | | â†“ |+----------------+ || æˆåŠŸ or å¤±è´¥ |---------â†’++----------------+ å¸¸ç”¨çš„å…ƒå­—ç¬¦ ä»£ç  è¯´æ˜Ž . åŒ¹é…é™¤æ¢è¡Œç¬¦ä»¥å¤–çš„ä»»æ„å­—ç¬¦ \w åŒ¹é…å­—æ¯æˆ–æ•°å­—æˆ–ä¸‹åˆ’çº¿æˆ–æ±‰å­— \s åŒ¹é…ä»»æ„çš„ç©ºç™½ç¬¦ \d åŒ¹é…æ•°å­— \b åŒ¹é…å•è¯çš„å¼€å§‹æˆ–ç»“æŸ ^ åŒ¹é…å­—ç¬¦ä¸²çš„å¼€å§‹ $ åŒ¹é…å­—ç¬¦ä¸²çš„ç»“æŸ å…ƒå­—ç¬¦ æè¿° . å¥å·åŒ¹é…ä»»æ„å•ä¸ªå­—ç¬¦é™¤äº†æ¢è¡Œç¬¦. [ ] å­—ç¬¦ç§ç±». åŒ¹é…æ–¹æ‹¬å·å†…çš„ä»»æ„å­—ç¬¦. [^ ] å¦å®šçš„å­—ç¬¦ç§ç±». åŒ¹é…é™¤äº†æ–¹æ‹¬å·é‡Œçš„ä»»æ„å­—ç¬¦ * åŒ¹é…&gt;=0ä¸ªé‡å¤çš„åœ¨*å·ä¹‹å‰çš„å­—ç¬¦. + åŒ¹é…&gt;=1ä¸ªé‡å¤çš„+å·å‰çš„å­—ç¬¦. ? æ ‡è®°?ä¹‹å‰çš„å­—ç¬¦ä¸ºå¯é€‰. {n,m} åŒ¹é…numä¸ªä¸­æ‹¬å·ä¹‹å‰çš„å­—ç¬¦ (n &lt;= num &lt;= m). (xyz) å­—ç¬¦é›†, åŒ¹é…ä¸Ž xyz å®Œå…¨ç›¸ç­‰çš„å­—ç¬¦ä¸². &#124; æˆ–è¿ç®—ç¬¦,åŒ¹é…ç¬¦å·å‰æˆ–åŽçš„å­—ç¬¦. &#92; è½¬ä¹‰å­—ç¬¦,ç”¨äºŽåŒ¹é…ä¸€äº›ä¿ç•™çš„å­—ç¬¦ [ ] ( ) { } . * + ? ^ $ \ &#124; ^ ä»Žå¼€å§‹è¡Œå¼€å§‹åŒ¹é…. $ ä»Žæœ«ç«¯å¼€å§‹åŒ¹é…. é”šç‚¹ åœ¨æ­£åˆ™è¡¨è¾¾å¼ä¸­, æƒ³è¦åŒ¹é…æŒ‡å®šå¼€å¤´æˆ–ç»“å°¾çš„å­—ç¬¦ä¸²å°±è¦ä½¿ç”¨åˆ°é”šç‚¹. ^ æŒ‡å®šå¼€å¤´, $ æŒ‡å®šç»“å°¾. ^ ç”¨æ¥æ£€æŸ¥åŒ¹é…çš„å­—ç¬¦ä¸²æ˜¯å¦åœ¨æ‰€åŒ¹é…å­—ç¬¦ä¸²çš„å¼€å¤´. ä¾‹å¦‚, åœ¨ abc ä¸­ä½¿ç”¨è¡¨è¾¾å¼ ^a ä¼šå¾—åˆ°ç»“æžœ a. ä½†å¦‚æžœä½¿ç”¨ ^b å°†åŒ¹é…ä¸åˆ°ä»»ä½•ç»“æžœ. å› ä¸ºåœ¨å­—ç¬¦ä¸² abc ä¸­å¹¶ä¸æ˜¯ä»¥ b å¼€å¤´. ä¾‹å¦‚, ^(T|t)he åŒ¹é…ä»¥ The æˆ– the å¼€å¤´çš„å­—ç¬¦ä¸². åŒç†äºŽ ^ å·, $ å·ç”¨æ¥åŒ¹é…å­—ç¬¦æ˜¯å¦æ˜¯æœ€åŽä¸€ä¸ª. ä¾‹å¦‚, (at\.)$ åŒ¹é…ä»¥ at. ç»“å°¾çš„å­—ç¬¦ä¸². é‡å¤ ä»£ç  è¯´æ˜Ž * é‡å¤é›¶æ¬¡æˆ–æ›´å¤šæ¬¡ + é‡å¤ä¸€æ¬¡æˆ–æ›´å¤šæ¬¡ ? é‡å¤é›¶æ¬¡æˆ–ä¸€æ¬¡ {n} é‡å¤næ¬¡ {n,} é‡å¤næ¬¡æˆ–æ›´å¤šæ¬¡ {n,m} é‡å¤nåˆ°mæ¬¡ åä¹‰æœ‰æ—¶éœ€è¦æŸ¥æ‰¾ä¸å±žäºŽæŸä¸ªèƒ½ç®€å•å®šä¹‰çš„å­—ç¬¦ç±»çš„å­—ç¬¦ã€‚æ¯”å¦‚æƒ³æŸ¥æ‰¾é™¤äº†æ•°å­—ä»¥å¤–ï¼Œå…¶å®ƒä»»æ„å­—ç¬¦éƒ½è¡Œçš„æƒ…å†µï¼Œè¿™æ—¶éœ€è¦ç”¨åˆ°åä¹‰ï¼š ä»£ç  è¯´æ˜Ž \W åŒ¹é…ä»»æ„ä¸æ˜¯å­—æ¯ï¼Œæ•°å­—ï¼Œä¸‹åˆ’çº¿ï¼Œæ±‰å­—çš„å­—ç¬¦ \S åŒ¹é…ä»»æ„ä¸æ˜¯ç©ºç™½ç¬¦çš„å­—ç¬¦ \D åŒ¹é…ä»»æ„éžæ•°å­—çš„å­—ç¬¦ \B åŒ¹é…ä¸æ˜¯å•è¯å¼€å¤´æˆ–ç»“æŸçš„ä½ç½® [^x] åŒ¹é…é™¤äº†xä»¥å¤–çš„ä»»æ„å­—ç¬¦ [^aeiou] åŒ¹é…é™¤äº†aeiouè¿™å‡ ä¸ªå­—æ¯ä»¥å¤–çš„ä»»æ„å­—ç¬¦ ç®€å†™å­—ç¬¦é›† æ­£åˆ™è¡¨è¾¾å¼æä¾›ä¸€äº›å¸¸ç”¨çš„å­—ç¬¦é›†ç®€å†™. å¦‚ä¸‹: ç®€å†™ æè¿° . é™¤æ¢è¡Œç¬¦å¤–çš„æ‰€æœ‰å­—ç¬¦ \w åŒ¹é…æ‰€æœ‰å­—æ¯æ•°å­—, ç­‰åŒäºŽ [a-zA-Z0-9_] \W åŒ¹é…æ‰€æœ‰éžå­—æ¯æ•°å­—, å³ç¬¦å·, ç­‰åŒäºŽ: [^\w] \d åŒ¹é…æ•°å­—: [0-9] \D åŒ¹é…éžæ•°å­—: [^\d] \s åŒ¹é…æ‰€æœ‰ç©ºæ ¼å­—ç¬¦, ç­‰åŒäºŽ: [\t\n\f\r\p{Z}] \S åŒ¹é…æ‰€æœ‰éžç©ºæ ¼å­—ç¬¦: [^\s] \f åŒ¹é…ä¸€ä¸ªæ¢é¡µç¬¦ \n åŒ¹é…ä¸€ä¸ªæ¢è¡Œç¬¦ \r åŒ¹é…ä¸€ä¸ªå›žè½¦ç¬¦ \t åŒ¹é…ä¸€ä¸ªåˆ¶è¡¨ç¬¦ \v åŒ¹é…ä¸€ä¸ªåž‚ç›´åˆ¶è¡¨ç¬¦ \p åŒ¹é… CR/LF (ç­‰åŒäºŽ \r\n)ï¼Œç”¨æ¥åŒ¹é… DOS è¡Œç»ˆæ­¢ç¬¦ å›žè½¦â€ï¼ˆcarriage returnï¼‰å’Œâ€æ¢è¡Œâ€ï¼ˆline feedï¼‰ çš„åŒºåˆ« å›žè½¦æ¯è¡ŒåŽé¢åŠ ä¸¤ä¸ªè¡¨ç¤ºç»“æŸçš„å­—ç¬¦ã€‚ä¸€ä¸ªå«åšâ€å›žè½¦â€ï¼Œå‘Šè¯‰æ‰“å­—æœºæŠŠæ‰“å°å¤´å®šä½åœ¨å·¦è¾¹ç•Œï¼›å¦ä¸€ä¸ªå«åšâ€æ¢è¡Œâ€ï¼Œå‘Šè¯‰æ‰“å­—æœºæŠŠçº¸å‘ä¸‹ç§»ä¸€è¡Œã€‚ä»Žè‹±æ–‡å•è¯ä¸Šä¹Ÿæ˜¯èƒ½get åˆ°æ„æ€çš„ã€‚ â€˜\nâ€™ 10 æ¢è¡Œï¼ˆnewlineï¼‰â€˜\râ€™ 13 å›žè½¦ï¼ˆreturnï¼‰ å›žè½¦ \r æœ¬ä¹‰æ˜¯å…‰æ ‡é‡æ–°å›žåˆ°æœ¬è¡Œå¼€å¤´ï¼Œrçš„è‹±æ–‡returnï¼ŒæŽ§åˆ¶å­—ç¬¦å¯ä»¥å†™æˆCRï¼Œå³Carriage Returnæ¢è¡Œ \n æœ¬ä¹‰æ˜¯å…‰æ ‡å¾€ä¸‹ä¸€è¡Œï¼ˆä¸ä¸€å®šåˆ°ä¸‹ä¸€è¡Œè¡Œé¦–ï¼‰ï¼Œnçš„è‹±æ–‡newlineï¼ŒæŽ§åˆ¶å­—ç¬¦å¯ä»¥å†™æˆLFï¼Œå³Line Feed ä¸åŒæ“ä½œç³»ç»Ÿä¸‹çš„å«ä¹‰ï¼š \n: UNIX ç³»ç»Ÿè¡Œæœ«ç»“æŸç¬¦\r\n: window ç³»ç»Ÿè¡Œæœ«ç»“æŸç¬¦\r: MAC OS ç³»ç»Ÿè¡Œæœ«ç»“æŸç¬¦ è½¯å›žè½¦å’Œç¡¬å›žè½¦ ç¡¬å›žè½¦å°±æ˜¯æ™®é€šæˆ‘ä»¬æŒ‰å›žè½¦äº§ç”Ÿçš„ï¼Œå®ƒåœ¨æ¢è¡Œçš„åŒæ—¶ä¹Ÿèµ·ç€æ®µè½åˆ†éš”çš„ä½œç”¨ã€‚ è½¯å›žè½¦æ˜¯ç”¨ Shift + Enter äº§ç”Ÿçš„ï¼Œå®ƒæ¢è¡Œï¼Œä½†æ˜¯å¹¶ä¸æ¢æ®µï¼Œå³å‰åŽä¸¤æ®µæ–‡å­—åœ¨ Word ä¸­å±žäºŽåŒä¸€â€œæ®µâ€ã€‚åœ¨åº”ç”¨æ ¼å¼æ—¶ä½ ä¼šä½“ä¼šåˆ°è¿™ä¸€ç‚¹ã€‚è½¯å›žè½¦èƒ½ä½¿å‰åŽä¸¤è¡Œçš„è¡Œé—´è·å¤§å¹…åº¦ç¼©å°ï¼Œå› ä¸ºå®ƒä¸æ˜¯æ®µè½æ ‡è®°ï¼Œè¦å’Œæ³•å®šçš„æ®µè½æ ‡è®°â€”â€”ç¡¬å›žè½¦åŒºåˆ«å‡ºæ¥ã€‚ç¡¬å›žè½¦çš„htmlä»£ç æ˜¯ &lt;p&gt;..&lt;/p&gt;ï¼Œæ®µè½çš„å†…å®¹å°±å¤¹åœ¨é‡Œé¢ï¼Œè€Œè½¯å›žè½¦çš„ä»£ç å¾ˆç²¾æ‚ &lt;br&gt;ã€‚ç½‘é¡µçš„æ–‡å­—å¦‚æžœå¤åˆ¶åˆ°wordä¸­ï¼Œåˆ™ç¡¬å›žè½¦å˜ä¸ºå¼¯æ›²çš„ç®­å¤´ï¼Œè½¯å›žè½¦å˜ä¸ºå‘ä¸‹çš„ç®­å¤´ã€‚ æ ‡å¿— æ ‡å¿—ä¹Ÿå«ä¿®é¥°è¯­, å› ä¸ºå®ƒå¯ä»¥ç”¨æ¥ä¿®æ”¹è¡¨è¾¾å¼çš„æœç´¢ç»“æžœ. è¿™äº›æ ‡å¿—å¯ä»¥ä»»æ„çš„ç»„åˆä½¿ç”¨, å®ƒä¹Ÿæ˜¯æ•´ä¸ªæ­£åˆ™è¡¨è¾¾å¼çš„ä¸€éƒ¨åˆ†. æ ‡å¿— æè¿° i å¿½ç•¥å¤§å°å†™. g å…¨å±€æœç´¢. m å¤šè¡Œçš„: é”šç‚¹å…ƒå­—ç¬¦ ^ $ å·¥ä½œèŒƒå›´åœ¨æ¯è¡Œçš„èµ·å§‹. ä¿®é¥°è¯­ i ç”¨äºŽå¿½ç•¥å¤§å°å†™ã€‚ä¾‹å¦‚, è¡¨è¾¾å¼ /The/gi è¡¨ç¤ºåœ¨å…¨å±€æœç´¢ The, åœ¨åŽé¢çš„ i å°†å…¶æ¡ä»¶ä¿®æ”¹ä¸ºå¿½ç•¥å¤§å°å†™, åˆ™å˜æˆæœç´¢ the å’Œ The, g è¡¨ç¤ºå…¨å±€æœç´¢. ä¿®é¥°ç¬¦ g å¸¸ç”¨è¯­æ‰§è¡Œä¸€ä¸ªå…¨å±€æœç´¢åŒ¹é…, å³(ä¸ä»…ä»…è¿”å›žç¬¬ä¸€ä¸ªåŒ¹é…çš„, è€Œæ˜¯è¿”å›žå…¨éƒ¨). ä¾‹å¦‚, è¡¨è¾¾å¼ /.(at)/g è¡¨ç¤ºæœç´¢ ä»»æ„å­—ç¬¦(é™¤äº†æ¢è¡Œ) + at, å¹¶è¿”å›žå…¨éƒ¨ç»“æžœ. å¤šè¡Œä¿®é¥°ç¬¦ m å¸¸ç”¨è¯­æ‰§è¡Œä¸€ä¸ªå¤šè¡ŒåŒ¹é…. åƒä¹‹å‰ä»‹ç»çš„ (^,$) ç”¨äºŽæ£€æŸ¥æ ¼å¼æ˜¯å¦æ˜¯åœ¨å¾…æ£€æµ‹å­—ç¬¦ä¸²çš„å¼€å¤´æˆ–ç»“å°¾. ä½†æˆ‘ä»¬å¦‚æžœæƒ³è¦å®ƒåœ¨æ¯è¡Œçš„å¼€å¤´å’Œç»“å°¾ç”Ÿæ•ˆ, æˆ‘ä»¬éœ€è¦ç”¨åˆ°å¤šè¡Œä¿®é¥°ç¬¦ m. ä¾‹å¦‚, è¡¨è¾¾å¼ /at(.)?$/gm è¡¨ç¤ºåœ¨å¾…æ£€æµ‹å­—ç¬¦ä¸²æ¯è¡Œçš„æœ«å°¾æœç´¢ atåŽè·Ÿä¸€ä¸ªæˆ–å¤šä¸ª . çš„å­—ç¬¦ä¸², å¹¶è¿”å›žå…¨éƒ¨ç»“æžœ. åˆ†æžæ¡ä»¶ ï¼ˆå®šä¹‰äº†å‡ ç§ä¸åŒçš„åŒ¹é…è§„åˆ™ï¼‰ä¸å¹¸çš„æ˜¯ï¼Œåˆšæ‰é‚£ä¸ªè¡¨è¾¾å¼ä¹Ÿèƒ½åŒ¹é…(010)12345678æˆ–(022-87654321è¿™æ ·çš„â€œä¸æ­£ç¡®â€çš„æ ¼å¼ã€‚è¦è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦ç”¨åˆ°åˆ†æžæ¡ä»¶ã€‚æ­£åˆ™è¡¨è¾¾å¼é‡Œçš„åˆ†æžæ¡ä»¶æŒ‡çš„æ˜¯æœ‰å‡ ç§è§„åˆ™ï¼Œå¦‚æžœæ»¡è¶³å…¶ä¸­ä»»æ„ä¸€ç§è§„åˆ™éƒ½åº”è¯¥å½“æˆåŒ¹é…ï¼Œå…·ä½“æ–¹æ³•æ˜¯ç”¨|æŠŠä¸åŒçš„è§„åˆ™åˆ†éš”å¼€ã€‚å¬ä¸æ˜Žç™½ï¼Ÿæ²¡å…³ç³»ï¼Œçœ‹ä¾‹å­ï¼š 0\d{2}-\d{8}|0\d{3}-\d{7}è¿™ä¸ªè¡¨è¾¾å¼èƒ½åŒ¹é…ä¸¤ç§ä»¥è¿žå­—å·åˆ†éš”çš„ç”µè¯å·ç ï¼šä¸€ç§æ˜¯ä¸‰ä½åŒºå·ï¼Œ8ä½æœ¬åœ°å·(å¦‚010-12345678)ï¼Œä¸€ç§æ˜¯4ä½åŒºå·ï¼Œ7ä½æœ¬åœ°å·(0376-2233445)ã€‚ (?0\d{2})?[- ]?\d{8}|0\d{2}[- ]?\d{8}è¿™ä¸ªè¡¨è¾¾å¼åŒ¹é…3ä½åŒºå·çš„ç”µè¯å·ç ï¼Œå…¶ä¸­åŒºå·å¯ä»¥ç”¨å°æ‹¬å·æ‹¬èµ·æ¥ï¼Œä¹Ÿå¯ä»¥ä¸ç”¨ï¼ŒåŒºå·ä¸Žæœ¬åœ°å·é—´å¯ä»¥ç”¨è¿žå­—å·æˆ–ç©ºæ ¼é—´éš”ï¼Œä¹Ÿå¯ä»¥æ²¡æœ‰é—´éš”ã€‚ä½ å¯ä»¥è¯•è¯•ç”¨åˆ†æžæ¡ä»¶æŠŠè¿™ä¸ªè¡¨è¾¾å¼æ‰©å±•æˆä¹Ÿæ”¯æŒ4ä½åŒºå·çš„ã€‚ \d{5}-\d{4}|\d{5}è¿™ä¸ªè¡¨è¾¾å¼ç”¨äºŽåŒ¹é…ç¾Žå›½çš„é‚®æ”¿ç¼–ç ã€‚ç¾Žå›½é‚®ç¼–çš„è§„åˆ™æ˜¯5ä½æ•°å­—ï¼Œæˆ–è€…ç”¨è¿žå­—å·é—´éš”çš„9ä½æ•°å­—ã€‚ä¹‹æ‰€ä»¥è¦ç»™å‡ºè¿™ä¸ªä¾‹å­æ˜¯å› ä¸ºå®ƒèƒ½è¯´æ˜Žä¸€ä¸ªé—®é¢˜ï¼šä½¿ç”¨åˆ†æžæ¡ä»¶æ—¶ï¼Œè¦æ³¨æ„å„ä¸ªæ¡ä»¶çš„é¡ºåºã€‚å¦‚æžœä½ æŠŠå®ƒæ”¹æˆ\d{5}|\d{5}-\d{4}çš„è¯ï¼Œé‚£ä¹ˆå°±åªä¼šåŒ¹é…5ä½çš„é‚®ç¼–(ä»¥åŠ9ä½é‚®ç¼–çš„å‰5ä½)ã€‚åŽŸå› æ˜¯åŒ¹é…åˆ†æžæ¡ä»¶æ—¶ï¼Œå°†ä¼šä»Žå·¦åˆ°å³åœ°æµ‹è¯•æ¯ä¸ªæ¡ä»¶ï¼Œå¦‚æžœæ»¡è¶³äº†æŸä¸ªåˆ†æžçš„è¯ï¼Œå°±ä¸ä¼šåŽ»å†ç®¡å…¶å®ƒçš„æ¡ä»¶äº†ã€‚ åˆ†ç»„ï¼ˆä½¿ç”¨index è®¿é—®ä½¿ç”¨å¾ˆå¹¿æ³›ï¼‰ æˆ‘ä»¬å·²ç»æåˆ°äº†æ€Žä¹ˆé‡å¤å•ä¸ªå­—ç¬¦ï¼ˆç›´æŽ¥åœ¨å­—ç¬¦åŽé¢åŠ ä¸Šé™å®šç¬¦å°±è¡Œäº†ï¼‰ï¼›ä½†å¦‚æžœæƒ³è¦é‡å¤å¤šä¸ªå­—ç¬¦åˆè¯¥æ€Žä¹ˆåŠžï¼Ÿä½ å¯ä»¥ç”¨å°æ‹¬å·æ¥æŒ‡å®šå­è¡¨è¾¾å¼(ä¹Ÿå«åšåˆ†ç»„)ï¼Œç„¶åŽä½ å°±å¯ä»¥æŒ‡å®šè¿™ä¸ªå­è¡¨è¾¾å¼çš„é‡å¤æ¬¡æ•°äº†ï¼Œä½ ä¹Ÿå¯ä»¥å¯¹å­è¡¨è¾¾å¼è¿›è¡Œå…¶å®ƒä¸€äº›æ“ä½œ(åŽé¢ä¼šæœ‰ä»‹ç»)ã€‚ (\d{1,3}.){3}\d{1,3}æ˜¯ä¸€ä¸ªç®€å•çš„IPåœ°å€åŒ¹é…è¡¨è¾¾å¼ã€‚è¦ç†è§£è¿™ä¸ªè¡¨è¾¾å¼ï¼Œè¯·æŒ‰ä¸‹åˆ—é¡ºåºåˆ†æžå®ƒï¼š\d{1,3}åŒ¹é…1åˆ°3ä½çš„æ•°å­—ï¼Œ(\d{1,3}.){3}åŒ¹é…ä¸‰ä½æ•°å­—åŠ ä¸Šä¸€ä¸ªè‹±æ–‡å¥å·(è¿™ä¸ªæ•´ä½“ä¹Ÿå°±æ˜¯è¿™ä¸ªåˆ†ç»„)é‡å¤3æ¬¡ï¼Œæœ€åŽå†åŠ ä¸Šä¸€ä¸ªä¸€åˆ°ä¸‰ä½çš„æ•°å­—(\d{1,3})ã€‚ ä¸å¹¸çš„æ˜¯ï¼Œå®ƒä¹Ÿå°†åŒ¹é…256.300.888.999è¿™ç§ä¸å¯èƒ½å­˜åœ¨çš„IPåœ°å€ã€‚å¦‚æžœèƒ½ä½¿ç”¨ç®—æœ¯æ¯”è¾ƒçš„è¯ï¼Œæˆ–è®¸èƒ½ç®€å•åœ°è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä½†æ˜¯æ­£åˆ™è¡¨è¾¾å¼ä¸­å¹¶ä¸æä¾›å…³äºŽæ•°å­¦çš„ä»»ä½•åŠŸèƒ½ï¼Œæ‰€ä»¥åªèƒ½ä½¿ç”¨å†—é•¿çš„åˆ†ç»„ï¼Œé€‰æ‹©ï¼Œå­—ç¬¦ç±»æ¥æè¿°ä¸€ä¸ªæ­£ç¡®çš„IPåœ°å€ï¼š((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)ã€‚ å¸¸è§çš„ä¾‹å­ é™¤äº†ä½¿ç”¨[]è¡¨ç¤ºæˆ–é€»è¾‘,()ä¹Ÿæ˜¯å¯ä»¥çš„ã€‚ç”¨æ³•æ˜¯(a|b)è¡¨ç¤ºaæˆ–è€…b åŒ¹é…é‚®ç®± 123gaoyaqi411@126.com dyumc@google.net sam@sjtu.edu æ­¥éª¤ ä»»ä½•ä¸€ä¸ªä»¥wordså¼€å¤´çš„ï¼Œä¸€ä¸ªæˆ–æ›´å¤š \w+ ç´§æŽ¥ç€æ˜¯ä¸€ä¸ª@ç¬¦å· \w+@ æŽ¥ç€æœ‰ä¸€ä¸ªæˆ–è€…æ›´å¤šçš„words \w+@\w+ æŽ¥ç€ä¸€ä¸ª.æ ‡ç‚¹ \w+@\w+. æŽ¥ç€ä¸€ä¸ªcom net æˆ– edu \w+@\w+.(com|net|edu) æ‰‹æœºå·æ­£åˆ™1/^1[34578][0-9]&#123;9&#125;$/ å•è¯è¾¹ç•Œ1/\bis\b/ URLåˆ†ç»„æ›¿æ¢1/http:(\/\/.+\.jpg)/ æ­£åˆ™è¡¨è¾¾å¼ä½¿ç”¨å°æ‹¬å·ç”¨æ¥åˆ†ç»„ï¼Œè¿™ä¸ªæ—¶å€™æˆ‘ä»¬å¯ä»¥é€šè¿‡ç”¨ $1æ¥èŽ·å– group#1çš„å†…å®¹ã€‚ èŽ·å–å†…å®¹æ˜¯ä¸ºäº† replace æ­£åˆ™è¡¨è¾¾å¼ç”±ä¸¤ç§åŸºæœ¬å­—ç¬¦ç»„æˆï¼š åŽŸä¹‰å­—ç¬¦ éžæ‰“å°å­—ç¬¦ å…ƒå­—ç¬¦ (* + ? $ ^ . | ( ) { } [ ]) éžæ‰“å°å­—ç¬¦åŒ…æ‹¬æ¢è¡Œç¬¦ã€å›žè½¦ç¬¦å·ï¼Œ åˆ†é¡µç¬¦ç­‰ç­‰ å­—ç¬¦ç±»å–å[^]èŒƒå›´ç±» [-]é¢„å®šä¹‰ç±» ï¼ˆè¿™ä¸ªæ˜¯ä¸ºäº†æ–¹ä¾¿ä½¿ç”¨ï¼Œåœ¨ä¸Šé¢ä¹Ÿè¢«ç§°ä¸º ç®€å†™ç±»ï¼‰ è¾¹ç•Œç±» ^ è¡¨ç¤ºå¼€å¤´ï¼Œ $ è¡¨ç¤ºç»“å°¾ï¼Œ \b è¡¨ç¤ºå•è¯è¾¹ç•Œ, \B è¡¨ç¤ºéžå•è¯è¾¹ç•Œ é‡è¯ æ­£åˆ™è¡¨è¾¾å¼é»˜è®¤ä¼šåŒ¹é…è´ªå©ªæ¨¡å¼ï¼Œä»€ä¹ˆæ˜¯è´ªå©ªæ¨¡å¼å‘¢ï¼Ÿå¦‚å…¶åå°½å¯èƒ½å¤šçš„åŒ¹é…ã€‚æˆ‘ä»¬çœ‹ä¸ªä¾‹å­ä¸Žè´ªå©ªå¯¹åº”å°±æ˜¯æ‡’æƒ°æ¨¡å¼ï¼Œæ‡’æƒ°å¯¹åº”çš„å°±æ˜¯åŒ¹é…çš„å°½å¯èƒ½å°‘çš„æƒ…å†µã€‚å¦‚ä½•å¼€å¯æ‡’æƒ°æ¨¡å¼ï¼Ÿ åœ¨é‡è¯åŽé¢åŠ ?ã€‚ç»§ç»­ä¸Šé¢çš„ä¾‹å­1/\d&#123;3,6&#125;?/ é‚®ç®±æ­£åˆ™è¡¨è¾¾å¼å®žä¾‹ åˆ†æžé‚®ä»¶åç§°éƒ¨åˆ†ï¼š 26ä¸ªå¤§å°å†™è‹±æ–‡å­—æ¯è¡¨ç¤ºä¸ºa-zA-Z æ•°å­—è¡¨ç¤ºä¸º0-9 ä¸‹åˆ’çº¿è¡¨ç¤ºä¸º_ ä¸­åˆ’çº¿è¡¨ç¤ºä¸º- ç”±äºŽåç§°æ˜¯ç”±è‹¥å¹²ä¸ªå­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿å’Œä¸­åˆ’çº¿ç»„æˆï¼Œæ‰€ä»¥éœ€è¦ç”¨åˆ°+è¡¨ç¤ºå¤šæ¬¡å‡ºçŽ° æ ¹æ®ä»¥ä¸Šæ¡ä»¶å¾—å‡ºé‚®ä»¶åç§°è¡¨è¾¾å¼ï¼š[a-zA-Z0-9_-]+ åˆ†æžåŸŸåéƒ¨åˆ†ï¼š å¸¸ç”¨æ­£åˆ™è¡¨è¾¾å¼â€”é‚®ç®±ï¼ˆEmailï¼‰ åˆ†æžé‚®ä»¶åç§°éƒ¨åˆ†ï¼š æ±‰å­—åœ¨æ­£åˆ™è¡¨ç¤ºä¸º [\u4e00-\u9fa5]å­—æ¯å’Œæ•°å­—è¡¨ç¤ºä¸º A-Za-z0-9 é€šè¿‡åˆ†æžå¾—å‡ºé‚®ä»¶åç§°éƒ¨åˆ†è¡¨è¾¾å¼ä¸º [A-Za-z0-9\u4e00-\u9fa5]+ C++ regexå‡½æ•°æœ‰3ä¸ªï¼šregex_matchã€ regex_search ã€regex_replace matchæ˜¯å…¨æ–‡åŒ¹é…ï¼Œå³è¦æ±‚æ•´ä¸ªå­—ç¬¦ä¸²ç¬¦åˆåŒ¹é…è§„åˆ™ã€‚ 12cout &lt;&lt; regex_match("123", regex("\\d")) &lt;&lt; endl; //ç»“æžœä¸º0cout &lt;&lt; regex_match("123", regex("\\d+")) &lt;&lt; endl; //ç»“æžœä¸º1 searchæ˜¯æœç´¢åŒ¹é…ï¼Œå³æœç´¢å­—ç¬¦ä¸²ä¸­å­˜åœ¨ç¬¦åˆè§„åˆ™çš„å­å­—ç¬¦ä¸²ã€‚ 12cout &lt;&lt; regex_match(&quot;123&quot;, regex(&quot;\\d&quot;)) &lt;&lt; endl; //ç»“æžœä¸º0cout &lt;&lt; regex_search(&quot;123&quot;, regex(&quot;\\d&quot;)) &lt;&lt; endl; //ç»“æžœä¸º1 regex_searchå’Œregex_matchçš„ä¸»è¦åŒºåˆ«æ˜¯ï¼šregex_matchæ˜¯å…¨è¯åŒ¹é…ï¼Œè€Œregex_searchæ˜¯æœç´¢å…¶ä¸­åŒ¹é…çš„å­—ç¬¦ä¸² regex_replaceæ˜¯æ›¿æ¢æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…å†…å®¹çš„å‡½æ•°replaceæ˜¯æ›¿æ¢åŒ¹é…ï¼Œå³å¯ä»¥å°†ç¬¦åˆåŒ¹é…è§„åˆ™çš„å­å­—ç¬¦ä¸²æ›¿æ¢ä¸ºå…¶ä»–å­—ç¬¦ä¸²ã€‚ 1234string str = &quot;Hello_2018!&quot;;regex pattern(&quot;Hello&quot;); cout &lt;&lt; regex_replace(str, pattern, &quot;&quot;) &lt;&lt; endl; //è¾“å‡ºï¼š_2018ï¼Œå°†Helloæ›¿æ¢ä¸º&quot;&quot;cout &lt;&lt; regex_replace(str, pattern, &quot;Hi&quot;) &lt;&lt; endl; //è¾“å‡ºï¼šHi_2018ï¼Œå°†Helloæ›¿æ¢ä¸ºHi æœ‰æ—¶æˆ‘ä»¬å¸Œæœ›èƒ½å¤ŸåŒ¹é…çš„æ—¶å€™å¿½ç•¥å¤§å°å†™ï¼Œè¿™æ—¶å€™å°±è¦ç”¨åˆ°Regexçš„è¯­æ³•é€‰é¡¹äº†ã€‚ 12cout &lt;&lt; regex_match("aaaAAA", regex("a*", regex::icase)) &lt;&lt; endl; //ç»“æžœä¸º1cout &lt;&lt; regex_match("aaaAAA", regex("a*")) &lt;&lt; endl; é’ˆå¯¹python çš„æ­£åˆ™è¡¨è¾¾å¼çš„ç»ƒä¹ é¢˜ 12345671ã€search(pattern, string, flags=0) åœ¨ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­æŸ¥æ‰¾åŒ¹é…2ã€findall(pattern, string ,flags=0) æ‰¾åˆ°åŒ¹é…ï¼Œè¿”å›žæ‰€æœ‰åŒ¹é…éƒ¨åˆ†çš„åˆ—è¡¨3ã€sub(pattern, repl, string , count=0, flags=0) å°†å­—ç¬¦ä¸²ä¸­åŒ¹é…æ­£åˆ™è¡¨è¾¾å¼çš„éƒ¨åˆ†æ›¿æ¢ä¸ºå…¶ä»–å€¼4ã€split(pattern, string ,maxsplit=0, flags=0) æ ¹æ®åŒ¹é…åˆ†å‰²å­—ç¬¦ä¸²ï¼Œè¿”å›žåˆ†éš”ç¬¦ä¸²ç»„æˆçš„åˆ—è¡¨ å¼€å§‹æ€»ç»“ python ç‰ˆæœ¬çš„æ­£åˆ™è¡¨è¾¾å¼ æ­£åˆ™è¡¨è¾¾å¼ (Regular Expression) åˆç§° RegEx, æ˜¯ç”¨æ¥åŒ¹é…å­—ç¬¦çš„ä¸€ç§å·¥å…·. åœ¨ä¸€å¤§ä¸²å­—ç¬¦ä¸­å¯»æ‰¾ä½ éœ€è¦çš„å†…å®¹. å®ƒå¸¸è¢«ç”¨åœ¨å¾ˆå¤šæ–¹é¢, æ¯”å¦‚ç½‘é¡µçˆ¬è™«, æ–‡ç¨¿æ•´ç†, æ•°æ®ç­›é€‰ç­‰ç­‰. çŽ°åœ¨éƒ½æ˜¯æ¯”è¾ƒå¹¿æ³›å­¦ä¹ ï¼Œéœ€è¦çŸ¥é“è¿™é‡Œé¢éƒ½æ˜¯æœ‰ä»€ä¹ˆï¼Œç­‰åˆ°ç”¨çš„æ—¶å€™ï¼Œå†å¥½å¥½ç¢ç£¨ï¼Œå› ä¸ºå†…å®¹è¿˜æ˜¯å¾ˆå¤šçš„å‘€ã€‚ è¦æ³¨æ„çš„æ˜¯ï¼Œæ­£åˆ™è¡¨è¾¾å¼å¹¶ä¸æ˜¯ä¸€ä¸ªç¨‹åºï¼Œè€Œæ˜¯ç”¨äºŽå¤„ç†å­—ç¬¦ä¸²çš„ä¸€ç§æ¨¡å¼ï¼Œå¦‚æžœä½ æƒ³ç”¨å®ƒæ¥å¤„ç†å­—ç¬¦ä¸²ï¼Œå°±å¿…é¡»ä½¿ç”¨æ”¯æŒæ­£åˆ™è¡¨è¾¾å¼çš„å·¥å…·ï¼Œæ¯”å¦‚ Linux ä¸­çš„ awk, sed, grepï¼Œæˆ–è€…ç¼–ç¨‹è¯­è¨€ Perl, Python, Java ç­‰ç­‰ã€‚ è¿™ä¸ªæ˜¯ä¸€ä¸ªå¼•å­, å…³é”®å­— in è¡¨ç¤ºå­—ç¬¦ä¸²çš„åŒ¹é…å…³ç³» 123456# matching stringpattern1 = "cat"pattern2 = "bird"string = "dog runs to cat"print(pattern1 in string) # Trueprint(pattern2 in string) # False å¦‚æžœæƒ³è¦ä½¿ç”¨æ›´åŠ å¼ºå¤§çš„åŠŸèƒ½ï¼Œé‚£ä¹ˆä½¿ç”¨ re æ¨¡å—ï¼Œ äºŽæ˜¯å°±æ˜¯æˆ‘ä»¬ä»Šå¤©çš„ä¸»è§’- æ­£åˆ™åŒ¹é…ã€‚ re æ¨¡å—ä¸­æä¾›äº†ä¸å°‘æœ‰ç”¨çš„å‡½æ•°ï¼Œ æ¯”å¦‚ compile å‡½æ•° match å‡½æ•° search å‡½æ•° findall å‡½æ•° finditer å‡½æ•° split å‡½æ•° sub å‡½æ•° subn å‡½æ•° re æ¨¡å—çš„ä¸€èˆ¬ä½¿ç”¨çš„æ­¥éª¤ ä½¿ç”¨ compile å‡½æ•°å°†æ­£åˆ™è¡¨è¾¾å¼çš„å­—ç¬¦ä¸²å½¢å¼ç¼–è¯‘ä¸ºä¸€ä¸ª Pattern å¯¹è±¡ é€šè¿‡ Pattern å¯¹è±¡æä¾›çš„ä¸€ç³»åˆ—æ–¹æ³•å¯¹æ–‡æœ¬è¿›è¡ŒåŒ¹é…æŸ¥æ‰¾ï¼ŒèŽ·å¾—åŒ¹é…ç»“æžœï¼ˆä¸€ä¸ª Match å¯¹è±¡ï¼‰ æœ€åŽä½¿ç”¨ Match å¯¹è±¡æä¾›çš„å±žæ€§å’Œæ–¹æ³•èŽ·å¾—ä¿¡æ¯ï¼Œæ ¹æ®éœ€è¦è¿›è¡Œå…¶ä»–çš„æ“ä½œ compile å‡½æ•°compile å‡½æ•°ç”¨äºŽç¼–è¯‘æ­£åˆ™è¡¨è¾¾å¼ï¼Œç”Ÿæˆä¸€ä¸ª Pattern å¯¹è±¡ï¼Œå®ƒçš„ä¸€èˆ¬ä½¿ç”¨å½¢å¼å¦‚ä¸‹ï¼š 1re.compile(pattern[, flag]) å…¶ä¸­ï¼Œpattern æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²å½¢å¼çš„æ­£åˆ™è¡¨è¾¾å¼ï¼Œflag æ˜¯ä¸€ä¸ªå¯é€‰å‚æ•°ï¼Œè¡¨ç¤ºåŒ¹é…æ¨¡å¼ï¼Œæ¯”å¦‚å¿½ç•¥å¤§å°å†™ï¼Œå¤šè¡Œæ¨¡å¼ç­‰ã€‚ match æ–¹æ³• match æ–¹æ³•ç”¨äºŽæŸ¥æ‰¾å­—ç¬¦ä¸²çš„å¤´éƒ¨ï¼ˆä¹Ÿå¯ä»¥æŒ‡å®šèµ·å§‹ä½ç½®ï¼‰ï¼Œå®ƒæ˜¯ä¸€æ¬¡åŒ¹é…ï¼Œåªè¦æ‰¾åˆ°äº†ä¸€ä¸ªåŒ¹é…çš„ç»“æžœå°±è¿”å›žï¼Œè€Œä¸æ˜¯æŸ¥æ‰¾æ‰€æœ‰åŒ¹é…çš„ç»“æžœã€‚ search æ–¹æ³•search æ–¹æ³•ç”¨äºŽæŸ¥æ‰¾å­—ç¬¦ä¸²çš„ä»»ä½•ä½ç½®ï¼Œå®ƒä¹Ÿæ˜¯ä¸€æ¬¡åŒ¹é…ï¼Œåªè¦æ‰¾åˆ°äº†ä¸€ä¸ªåŒ¹é…çš„ç»“æžœå°±è¿”å›žï¼Œè€Œä¸æ˜¯æŸ¥æ‰¾æ‰€æœ‰åŒ¹é…çš„ç»“æžœ findall æ–¹æ³•ä¸Šé¢çš„ match å’Œ search æ–¹æ³•éƒ½æ˜¯ä¸€æ¬¡åŒ¹é…ï¼Œåªè¦æ‰¾åˆ°äº†ä¸€ä¸ªåŒ¹é…çš„ç»“æžœå°±è¿”å›žã€‚ç„¶è€Œï¼Œåœ¨å¤§å¤šæ•°æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦æœç´¢æ•´ä¸ªå­—ç¬¦ä¸²ï¼ŒèŽ·å¾—æ‰€æœ‰åŒ¹é…çš„ç»“æžœã€‚ finditer æ–¹æ³•finditer æ–¹æ³•çš„è¡Œä¸ºè·Ÿ findall çš„è¡Œä¸ºç±»ä¼¼ï¼Œä¹Ÿæ˜¯æœç´¢æ•´ä¸ªå­—ç¬¦ä¸²ï¼ŒèŽ·å¾—æ‰€æœ‰åŒ¹é…çš„ç»“æžœã€‚ä½†å®ƒè¿”å›žä¸€ä¸ªé¡ºåºè®¿é—®æ¯ä¸€ä¸ªåŒ¹é…ç»“æžœï¼ˆMatch å¯¹è±¡ï¼‰çš„è¿­ä»£å™¨ã€‚ split æ–¹æ³•split æ–¹æ³•æŒ‰ç…§èƒ½å¤ŸåŒ¹é…çš„å­ä¸²å°†å­—ç¬¦ä¸²åˆ†å‰²åŽè¿”å›žåˆ—è¡¨ sub æ–¹æ³•sub æ–¹æ³•ç”¨äºŽæ›¿æ¢ã€‚ åŒ¹é…ä¸­æ–‡ åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬æƒ³åŒ¹é…æ–‡æœ¬ä¸­çš„æ±‰å­—ï¼Œæœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸­æ–‡çš„ unicode ç¼–ç èŒƒå›´ ä¸»è¦åœ¨ [\u4e00-\u9fa5]ï¼Œè¿™é‡Œè¯´ä¸»è¦æ˜¯å› ä¸ºè¿™ä¸ªèŒƒå›´å¹¶ä¸å®Œæ•´ï¼Œæ¯”å¦‚æ²¡æœ‰åŒ…æ‹¬å…¨è§’ï¼ˆä¸­æ–‡ï¼‰æ ‡ç‚¹ï¼Œä¸è¿‡ï¼Œåœ¨å¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼Œåº”è¯¥æ˜¯å¤Ÿç”¨çš„ã€‚ 123456# -*- coding: utf-8 -*-import retitle = u&apos;ä½ å¥½ï¼Œhelloï¼Œä¸–ç•Œ&apos;pattern = re.compile(ur&apos;[\u4e00-\u9fa5]+&apos;)result = pattern.findall(title)print result æ³¨æ„åˆ°ï¼Œæˆ‘ä»¬åœ¨æ­£åˆ™è¡¨è¾¾å¼å‰é¢åŠ ä¸Šäº†ä¸¤ä¸ªå‰ç¼€ urï¼Œå…¶ä¸­ rè¡¨ç¤ºä½¿ç”¨åŽŸå§‹å­—ç¬¦ä¸²ï¼Œu è¡¨ç¤ºæ˜¯ unicode å­—ç¬¦ä¸²ã€‚ æ‰§è¡Œç»“æžœ: 1[u&apos;\u4f60\u597d&apos;, u&apos;\u4e16\u754c&apos;] æ€»ç»“ re æ¨¡å—çš„ä¸€èˆ¬ä½¿ç”¨æ­¥éª¤å¦‚ä¸‹ï¼š ä½¿ç”¨ compile å‡½æ•°å°†æ­£åˆ™è¡¨è¾¾å¼çš„å­—ç¬¦ä¸²å½¢å¼ç¼–è¯‘ä¸ºä¸€ä¸ª Pattern å¯¹è±¡ï¼› é€šè¿‡ Pattern å¯¹è±¡æä¾›çš„ä¸€ç³»åˆ—æ–¹æ³•å¯¹æ–‡æœ¬è¿›è¡ŒåŒ¹é…æŸ¥æ‰¾ï¼ŒèŽ·å¾—åŒ¹é…ç»“æžœï¼ˆä¸€ä¸ª Match å¯¹è±¡ï¼‰ï¼› æœ€åŽä½¿ç”¨ Match å¯¹è±¡æä¾›çš„å±žæ€§å’Œæ–¹æ³•èŽ·å¾—ä¿¡æ¯ï¼Œæ ¹æ®éœ€è¦è¿›è¡Œå…¶ä»–çš„æ“ä½œï¼› Python çš„æ­£åˆ™åŒ¹é…é»˜è®¤æ˜¯è´ªå©ªåŒ¹é…ã€‚ æ€»ç»“çš„å°æŠ„ï¼Œå‡ºå¤„ åœ¨çˆ¬è™«ä¸­çš„å®žè·µ ä½¿ç”¨requests å¾—åˆ°å†…å®¹ä¹‹åŽï¼Œç„¶åŽä½¿ç”¨ re è¿›è¡Œè§£æžã€‚12345678910import requestsimport recontent = requests.get('https://movie.douban.com/chart').text# è±†ç“£ç”µå½±æŽ’è¡Œæ¦œpattern = re.compile('class="pl2".*?&lt;.*?="(.*?)".*?&gt;(.*?)&lt;span.*?&gt;(.*?)&lt;/span&gt;.*?"rating_nums"&gt;(.*?)&lt;/span&gt;.*?"pl"&gt;(.*?)&lt;/span&gt;', re.S)# compileå¯ä»¥åœ¨å¤šæ¬¡ä½¿ç”¨ä¸­æé«˜æ•ˆçŽ‡ï¼Œè¿™é‡Œå½±å“ä¸å¤§results = re.findall(pattern, content)for result in results: url, name1, name2, nums, pl = result print(url, name1.replace("/","").strip(), name2.replace("/","").strip(), nums, pl) æ­£åˆ™åŒ¹é…å¸®åŠ©æ–‡æ¡£ åœ¨çº¿æ­£åˆ™è¡¨è¾¾å¼æµ‹è¯• åœ¨çº¿æ­£åˆ™æµ‹è¯• ç»†è¯´pythonæ­£åˆ™è¡¨è¾¾å¼ ï¼Œå†™çš„éžå¸¸å…¨Python æ­£åˆ™è¡¨è¾¾å¼ re æ¨¡å— ä¹Ÿæ˜¯æ¯”è¾ƒå¥½çš„åšå®¢ è¿™ä¸ªæ˜¯å®žæˆ˜ï¼Œå†™çš„å¾ˆå®¹æ˜“ç†è§£ https://segmentfault.com/a/1190000013075245https://blog.csdn.net/make164492212/article/details/51656638]]></content>
      <tags>
        <tag>regular_exppression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å‰‘æŒ‡offer-å…¶ä»–(1)]]></title>
    <url>%2F2019%2F01%2F17%2F%E5%89%91%E6%8C%87offer-%E5%85%B6%E4%BB%96%2F</url>
    <content type="text"><![CDATA[è¿™æ˜¯å‰‘æŒ‡offer ç³»åˆ—å››éƒ¨æ›²ä¸­çš„æœ€åŽä¸€éƒ¨ï¼Œå› ä¸ºæœ‰äº›ç®—æ³•é¢˜ç›®ç±»åˆ«æ•°é‡å¤ªå°‘å°±æ±‡æ€»åˆ°äº†â€å…¶ä»–â€œ, æ¯”å¦‚ä½è¿ç®—ã€æ­£åˆ™åŒ¹é…ç­‰ã€‚ç¬¬ä¸€éƒ¨å…³äºŽå­—ç¬¦ä¸²å’Œæ•°ç»„ï¼Œç¬¬äºŒéƒ¨æ˜¯æ ˆã€é˜Ÿåˆ—ã€é“¾è¡¨å’Œæ ‘ï¼Œ ç¬¬ä¸‰éƒ¨é€’å½’ã€å›žæº¯å’ŒåŠ¨æ€è§„åˆ’ã€‚ äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•° è¾“å…¥ä¸€ä¸ªæ•´æ•°ï¼Œè¾“å‡ºè¯¥æ•°äºŒè¿›åˆ¶è¡¨ç¤ºä¸­1çš„ä¸ªæ•°ã€‚å…¶ä¸­è´Ÿæ•°ç”¨è¡¥ç è¡¨ç¤ºã€‚ Tipsï¼šé¦–å…ˆå¤„ç†æ­£æ•°, bitwise and operationï¼Œ å¾ˆç®€å•ã€‚å¯¹äºŽè´Ÿæ•°ï¼Œéœ€è¦è½¬æ¢æˆ æ­£æ•°ç„¶åŽè¿›è¡Œå¤„ç†ï¼Œmathã€‚ 123456789101112131415161718192021class Solution: def NumberOf1(self, n): # write code here if n == 0: return 0 if n &gt; 0: counts = self.number_of_positive(n) else: n = abs(n) - 1 counts = 32 - self.number_of_positive(n) return counts def number_of_positive(self, n): if n == 0: return 0 counts = 0 while n: counts += (n &amp; 1) n = n &gt;&gt; 1 return counts è¿™æ˜¯c++ å®žçŽ°ã€‚ 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;// positiveint number_of_1(int n)&#123; int res =0; while(n) &#123; res += (n&amp;1); n =n/2; &#125; return res;&#125;int main()&#123; int n; cin &gt;&gt;n; int res =0; if(n &gt;0) res =number_of_1(n); else &#123; n =abs(n) -1; res =32 -number_of_1(n); &#125; cout &lt;&lt; res&lt;&lt;endl; return 0;&#125; è¡¥æ•°å’Œè¡¥ç ï¼Œ2 å’Œ8 å¯¹äºŽ10 å°±æ˜¯äº’ä¸ºè¡¥æ•°ã€‚é‚£ä¹ˆè¡¥ç è¿™ä¸ªæ¦‚å¿µä¹Ÿæ˜¯ç±»ä¼¼çš„ï¼Œä¸¤ä¸ªæœºå™¨æ•°ç›¸åŠ ç­‰äºŽ 1000000ï¼ˆåœ¨äºŒçº§åˆ¶ä¸‹éžå¸¸æ•´é½çš„æ•°å­—ï¼‰è¿™æ ·çš„æ ‘ï¼Œç„¶åŽä¸¤ä¸ªæ•°å­—å°±äº’ä¸ºè¡¥æ•°ã€‚åœ¨è®¡ç®—æœºé‡Œé¢ï¼Œå¯¹äºŽè´Ÿæ•°å°±æ˜¯ä½¿ç”¨å…¶å¯¹åº”çš„è¡¥ç è¿›è¡Œè¡¨ç¤ºçš„ã€‚æ­£æ•°ä½¿ç”¨æœ¬èº«è¡¨ç¤ºï¼Œè´Ÿæ•°ä½¿ç”¨ç»å¯¹å€¼çš„è¡¥ç è¿›è¡Œè¡¨ç¤ºã€‚ é¦–å…ˆè½¬æ¢æˆä¸€ä¸ªæ— ç¬¦å·æ•´æ•°ï¼Œå¦‚æžœæ˜¯æ— ç¬¦å·ï¼Œå½“ä½¿ç”¨å³ç§»æ“ä½œçš„æ—¶å€™è¡¥ä¸Šçš„æ˜¯0ï¼›ä½†æ˜¯å½“å¦‚æžœæ˜¯æœ‰ç¬¦å·æ•´æ•°çš„æ—¶å€™ï¼Œå³ç§»æ“ä½œè¡¥å……çš„æ˜¯1ã€‚è¿™ä¸ªå°±æ˜¯ä¸¤è€…çš„åŒºåˆ«ã€‚ä»Žæœ¬è´¨ä¸Šæ•°å­—å¹¶æ²¡æœ‰å‘ç”Ÿå˜åŒ–ï¼Œä½†æ˜¯è§£è¯»çš„æ–¹å¼å‘ç”Ÿäº†å˜åŒ–ã€‚ å¯¹äºŽæ­£æ•°æ˜¯æ¯”è¾ƒå¥½å¤„ç†çš„ï¼Œè´Ÿæ•°çš„è¡¥ç è¡¨ç¤ºå½¢å¼ã€‚å¦‚æžœæ˜¯8ä½ï¼Œé‚£ä¹ˆä½¿ç”¨ 1ä½è¡¨ç¤ºç¬¦å·ä½ï¼Œä½¿ç”¨7ä½è¿›è¡ŒæŠ€æœ¯ï¼Œé‚£ä¹ˆå°±æœ‰$2^7 =128 $ç§å¯èƒ½æ€§ã€‚å› ä¸ºåŒ…å«0ï¼Œæ‰€ä»¥åªèƒ½æ˜¯æ­£è´Ÿ127ã€‚è´Ÿæ•°ä¸­ï¼ŒåŽŸç è¡¥ç ï¼Œåç è½¬æ¢å…³ç³»å‚è€ƒè¿™é‡Œ è¿™ä¸ªæ˜¯æˆ‘è§è¿‡çš„æœ€ä¸ºç®€æ´çš„ä»£ç äº†ã€‚ 1234567891011121314class Solution &#123;public: int NumberOf1(int _n) &#123; unsigned int n =_n; int res =0; while(n) &#123; res += (n&amp;1); n = n&gt;&gt;1; &#125; return res; &#125;&#125;; æ•°å€¼çš„æ•´æ•°æ¬¡æ–¹ ç»™å®šä¸€ä¸ªdoubleç±»åž‹çš„æµ®ç‚¹æ•°baseå’Œintç±»åž‹çš„æ•´æ•°exponentã€‚æ±‚baseçš„exponentæ¬¡æ–¹ã€‚ Tips: æ¬¡æ–¹ä½¿ç”¨ä¹˜æ³•æ¥è¿›è¡Œç´¯ä¹˜ 1234567891011121314151617181920212223242526272829303132333435class Solution: """ è¿™ä¸ªå°±æ˜¯è¾¹ç•Œæ¡ä»¶æ¯”è¾ƒå¤šè€Œå·²ï¼Œéœ€è¦åˆ†åˆ«åˆ¤æ–­ base å’Œ exponent çš„æ­£è´Ÿ """ def Power(self, base, exponent): # write code here if base == 0 and exponent != 0: return 0 if base != 0 and exponent == 0: return 1 flag = 1 if base &lt;= 0 and (exponent % 2 == 1): flag = -1 base = abs(base) result = 1 if exponent &gt; 0: reverse = 0 else: reverse = 1 exponent = abs(exponent) if exponent % 2 == 0: result = base * base for i in range(exponent // 2 - 1): result = result * result else: result = base * base for i in range(exponent // 2 - 1): result = result * result result = result * base if reverse: result = 1.0 / result return result * flag è¿™ä¸ªæ˜¯éœ€è¦çœ‹æ•°æ®çš„èŒƒå›´ï¼Œå¦‚æžœæ˜¯åœ¨ $10^7$ ä¹‹å†…ï¼Œé‚£ä¹ˆå¯ä»¥ç›´æŽ¥ä½¿ç”¨ $O(n)$ çš„åšæ³•ã€‚éœ€è¦å¤„ç†ä¸€ä¸ªè´Ÿå·çš„æƒ…å†µã€‚ è°è¯´ c++ ä¸­çš„ä»£ç æ˜¯æ¯”è¾ƒé•¿çš„ï¼Œå…³é”®æ˜¯çœ‹è°å†™çš„ã€‚ 123456789101112 class Solution &#123;public: double Power(double base, int exponent) &#123; double res =1; for(int i =0; i&lt;abs(exponent); i++) res *= base; if( exponent &lt;0) res =1/res; return res; &#125;&#125;; æœ€å°çš„Kä¸ªæ•° è¾“å…¥nä¸ªæ•´æ•°ï¼Œæ‰¾å‡ºå…¶ä¸­æœ€å°çš„Kä¸ªæ•°ã€‚ä¾‹å¦‚è¾“å…¥4,5,1,6,2,7,3,8è¿™8ä¸ªæ•°å­—ï¼Œåˆ™æœ€å°çš„4ä¸ªæ•°å­—æ˜¯1,2,3,4,ã€‚ Tipsï¼š è¿™ä¸ªæœ‰ç‚¹æŠ•æœºå–å·§äº†ï¼Œä½¿ç”¨äº† â€œheapqâ€ çš„åº“å‡½æ•°ã€‚è¿™ä¸ªé¢˜ç›®è·Ÿ ç¬¬ Kä¸ª smallest æ˜¯æœ‰å·®åˆ«çš„ï¼Œå¿«æŽ’ä¸­çš„ partition æ˜¯æ‰¾åˆ°äº† ä¸€ä¸ªæ•°å­—åœ¨æœ€åŽæŽ’åºç»“æžœä¸­çš„ä½ç½®ã€‚å¯¹äºŽæœ‰â€ç´¯åŠ â€œå‰ Kä¸ªæ•°å­—è¿˜æ˜¯è¦ä½¿ç”¨å¸¸è§„çš„æŽ’åºã€‚æ¯”è¾ƒå¥½çš„å°±æ˜¯å †æŽ’åºã€‚ 123456789class Solution: # æƒ³è¯´çš„æ˜¯æ—¢ç„¶æ˜¯ä½¿ç”¨è¿™ç§å¼€æºçš„åº“å‡½æ•° é‚£ä¹ˆå°±è®°ä½è¿™ç§å‡½æ•°åå­— def GetLeastNumbers_Solution(self, tinput, k): # write code here if len(tinput) &lt; k: return [] import heapq res = heapq.nsmallest(k, tinput) return res The function partition puts the numbers smaller than nums[left] to its left and then returns the new index of nums[left]. The returned index is actually telling us how small nums[left] ranks in nums. 123456789101112131415161718192021222324252627282930313233343536class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ left, right = 0, len(nums) - 1 while True: pos = self.partition(nums, left, right) # è¿™ä¸ªåœ¨æŽ’åºçš„æ—¶å€™ï¼Œæ˜¯æŠŠå¤§çš„æ•°å­—æ”¾åˆ°å‰é¢ï¼Œè€Œå‰é¢æ˜¯pos æ˜¯ä»Ž0 å¼€å§‹çš„ï¼Œ # æ‰€ä»¥è¿™é‡Œæ˜¯ k-1 if pos == k - 1: return nums[pos] # å·¦è¾¹çš„å¹¶ä¸è¶³ä»¥æž„æˆk ä¸ªï¼Œ é‚£ä¹ˆåœ¨å³è¾¹ elif pos &lt; k - 1: left = pos + 1 else: right = pos - 1 def partition(self, nums, left, right): # choose nums[left] as pivot pivot = nums[left] # p1, p2å°±ç±»ä¼¼ working ä¸­çš„left right p1, p2 = left + 1, right while p1 &lt;= p2: if nums[p1] &lt; pivot and nums[p2] &gt; pivot: nums[p1], nums[p2] = nums[p2], nums[p1] p1, p2 = p1 + 1, p2 - 1 elif nums[p1] &gt;= pivot: p1 += 1 else: #nums[p2] &lt;= pivot: p2 -=1 nums[left], nums[p2] = nums[p2], nums[left] return p2 æœ‰ä¸¤ç§è§£æ³•ï¼Œç¬¬ä¸€ç§æ€è·¯æ˜¯å¿«æŽ’çš„æ€è·¯ï¼Œå…ˆæ˜¯æ‰¾åˆ°ç¬¬ $K$å¤§ï¼Œç„¶åŽ $O(n)$ çš„æ—¶é—´ï¼ŒéåŽ†ä¸€éï¼Œä¿ç•™ $K $ä¸ªæœ€å¤§çš„å…ƒç´ ã€‚ è¿™ä¸ªæ˜¯å¿«é€ŸæŸ¥æ‰¾ï¼ˆquick_searchï¼‰ è€Œä¸æ˜¯quick_sort æ‰€ä»¥æ˜¯ä¸ä¼šä¿®æ”¹æ•°ç»„çš„æœ‰åºä¸Žå¦ã€‚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int partition(vector&lt;int&gt; arr, int l, int r)&#123; int key =arr[r]; while(l&lt; r) &#123; while(l &lt;r &amp;&amp; arr[l] &gt;= key) l +=1; arr[r] =arr[l]; while(l &lt;r &amp;&amp; arr[r] &lt;= key) r -=1; arr[l] =arr[r]; &#125; arr[r] =key; return l;&#125;int find(vector&lt;int&gt; arr, int k)&#123; if(arr.empty() || arr.size() &lt; k) return -1; int l =0, r =arr.size() -1; while( true) &#123; int pos =partition(arr, l, r); if( pos == k-1) return arr[k]; else if (pos &gt; k-1) r= pos -1; else l =pos +1; &#125; return -1;&#125;int main()&#123; vector&lt;int&gt; arr; int n, k; cin &gt;&gt;n &gt;&gt;k; for(int i =0; i&lt;n; i++) &#123; int tmp ; cin &gt;&gt; tmp; arr.push_back(tmp); &#125; int key = find(arr, k); cout &lt;&lt; key&lt;&lt; endl; vector&lt;int&gt; res ; for(auto a: arr) &#123; if( a&gt; key) res.push_back(a); &#125; for(auto u: res) cout &lt;&lt; u&lt;&lt; " "; cout&lt;&lt; endl; &#125; ç¬¬äºŒç§æ€è·¯ä½¿ç”¨å †çš„æ€æƒ³ã€‚ä½¿ç”¨å¤§æ ¹å †å­˜å‚¨æœ€å°çš„k ä¸ªæ•°ï¼Œå †é¡¶å…ƒç´ å°±æ˜¯æ‰€æœ‰å…ƒç´ ä¸­æœ€å¤§çš„ï¼Œé‚£ä¹ˆå¦‚æžœå¼¹å‡ºï¼Œå°±ä¸€å®šå¼¹å‡ºå †é¡¶çš„å…ƒç´ ã€‚ ä½¿ç”¨å¤§æ ¹å †å®žçŽ°ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ $nlog(k)$ï¼Œ kæ˜¯ä¸ªæ•°ï¼Œn æ˜¯æ•°ç»„çš„é•¿åº¦ã€‚å¤§æ ¹å †ä¿å­˜æ˜¯k ä¸ªå…ƒç´ ï¼Œå…¶ä¸­å †é¡¶æ˜¯è¿™k ä¸ªå…ƒç´ ä¸­æœ€å¤§çš„é‚£ä¸ªã€‚(å§æ§½ï¼Œå½“æ—¶äº¬ä¸œé¢è¯•çš„æ—¶å€™ï¼Œç¡®å®žæ˜¯å¯ä»¥ä½¿ç”¨å¤§æ ¹å †è¿›è¡Œå®žçŽ°çš„ï¼ŒçŽ°åœ¨æœ‰ç‚¹æƒ³è¦å“­ï¼Œå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆï¼Œ) stackåªéœ€è¦æ ‡è®°topä¸‹æ ‡ï¼Œé˜Ÿåˆ—é€šè¿‡frontå’Œrearæ¥æ ‡è®°é˜Ÿé¦–å’Œé˜Ÿå°¾ã€‚ .queueä¹Ÿæ˜¯çº¿æ€§è¡¨ï¼Œå¯ä»¥ç”¨æ•°ç»„(ç”±äºŽå‡æº¢å‡ºçš„åŽŸå› ä½¿ç”¨å¾ªçŽ¯æ•°ç»„)å’Œé“¾è¡¨æ¥å®žçŽ° ä½¿ç”¨c++ ä¸­çš„å¤§æ ¹å †çš„æ€æƒ³ï¼ˆæ±‚è§£æœ€å°çš„k ä¸ªæ•°å­—ä½¿ç”¨ å¤§æ ¹å †ï¼‰ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;string&gt;using namespace std;// å¯»æ‰¾çš„æ˜¯ ç¬¬k å°vector&lt;int&gt; find_kth_largest(vector&lt;int&gt; &amp;arr, int k)&#123; if(arr.empty() || arr.size() &lt; k) return vector&lt;int&gt;(-1); priority_queue&lt;int&gt; q; for(auto u: arr) &#123; q.push(u); if(q.size() &gt;k) q.pop(); &#125; vector&lt;int&gt; res; while( k--) &#123; res.push_back(q.top()); q.pop(); &#125; return res;&#125;int main()&#123; vector&lt;int&gt; arr; int n, k; cin &gt;&gt;n &gt;&gt;k; for(int i =0; i&lt;n; i++) &#123; int tmp; cin &gt;&gt; tmp; arr.push_back(tmp); &#125; vector&lt;int&gt; res =find_kth_largest(arr, k); for(auto u : res) cout &lt;&lt; u&lt;&lt; " "; cout&lt;&lt; endl; cout&lt;&lt;"è¾“å‡ºæ•°å­—" &lt;&lt; endl; for(auto u: arr) &#123; cout &lt;&lt; u&lt;&lt; " "; &#125; return 0;&#125; æ•´æ•°ä¸­1å‡ºçŽ°çš„æ¬¡æ•°ï¼ˆä»Ž1åˆ°næ•´æ•°ä¸­1å‡ºçŽ°çš„æ¬¡æ•°ï¼‰(è¿‡) æ±‚å‡º1~13çš„æ•´æ•°ä¸­1å‡ºçŽ°çš„æ¬¡æ•°,å¹¶ç®—å‡º100~1300çš„æ•´æ•°ä¸­1å‡ºçŽ°çš„æ¬¡æ•°ï¼Ÿä¸ºæ­¤ä»–ç‰¹åˆ«æ•°äº†ä¸€ä¸‹1~13ä¸­åŒ…å«1çš„æ•°å­—æœ‰1ã€10ã€11ã€12ã€13å› æ­¤å…±å‡ºçŽ°6æ¬¡,ä½†æ˜¯å¯¹äºŽåŽé¢é—®é¢˜ä»–å°±æ²¡è¾™äº†ã€‚ACMerå¸Œæœ›ä½ ä»¬å¸®å¸®ä»–,å¹¶æŠŠé—®é¢˜æ›´åŠ æ™®éåŒ–,å¯ä»¥å¾ˆå¿«çš„æ±‚å‡ºä»»æ„éžè´Ÿæ•´æ•°åŒºé—´ä¸­1å‡ºçŽ°çš„æ¬¡æ•°ï¼ˆä»Ž1 åˆ° n ä¸­1å‡ºçŽ°çš„æ¬¡æ•°ï¼‰ã€‚ Tipsï¼šmath, è®¡æ•°åŽŸç†ï¼ŒæŒ‰ä½ç»Ÿè®¡è¯¥ä½ä¸º1æ—¶å¯èƒ½åŒ…å«çš„æ•°å­—æ€»æ•°.ç”±ä½Žä½å‘é«˜ä½ä¾æ¬¡éåŽ†æ•°å­—nçš„æ¯ä¸€ä½curnã€‚è®°å½“å‰ä½æ•°ä¸ºcï¼Œcurnå·¦è¾¹ï¼ˆé«˜ä½ï¼‰çš„æ•°å­—ç‰‡æ®µä¸ºhighnï¼Œcurå³è¾¹ï¼ˆä½Žä½ï¼‰çš„æ•°å­—ç‰‡æ®µä¸ºlownï¼Œlowc = 10 ^ c è‹¥curn = 0ï¼Œåˆ™é«˜ä½èŒƒå›´ä¸º0 ~ highn - 1ï¼Œä½Žä½0 ~ lowc - 1 è‹¥curn = 1ï¼Œåˆ™é«˜ä½èŒƒå›´ä¸º0 ~ highn - 1ï¼Œä½Žä½0 ~ lowc - 1ï¼›æˆ–è€… é«˜ä½ä¸ºhighnï¼Œ ä½Žä½0 ~ lown è‹¥curn ï¼ž 1ï¼Œåˆ™é«˜ä½èŒƒå›´ä¸º0 ~ highnï¼Œ ä½Žä½ä¸º0 ~ lowc - 1 ä¸€ä¸ªå°çš„ä¾‹å­ N= abcde,åˆ†åˆ«æ˜¯å„ä¸ªä½æ•°ä¸Šçš„æ•°å­—ã€‚å¦‚æžœè¦ç»Ÿè®¡ ç™¾ä½ä¸Šå‡ºçŽ° 1çš„æ¬¡æ•°ï¼Œé‚£ä¹ˆä»–å°†å—åˆ°ä¸‰ä¸ªå› ç´ çš„å½±å“ï¼š ç™¾ä½ä¸Šçš„æ•°å­—ï¼Œç™¾ä½ä»¥ä¸‹çš„æ•°å­—(ä½Žä½) å’Œç™¾ä½ä»¥ä¸Šçš„æ•°å­—( é«˜ä½)ã€‚ å¦‚æžœç™¾ä½ä¸Šçš„æ•°å­—æ˜¯ 0 ï¼Œ é«˜ä½æ•°å­— * å½“å‰çš„æ•°å­— å¦‚æžœç™¾ä½ä¸Šçš„æ•°å­—æ˜¯1ï¼Œé«˜ä½æ•°å­— * å½“å‰æ•°å­— + ( ä½Žä½æ•°å­—+1) å¦‚æžœç™¾ä½æ•°å­—å¤§äºŽ1 (2-9), ï¼ˆé«˜ä½æ•°å­—+1 )* å½“å‰çš„æ•°å­— åˆçº§ç‰ˆæœ¬: é€šè¿‡ä¸æ–­çš„æ±‚ä½™ å’Œæ•´é™¤ï¼Œè®¡ç®—æ¯ä¸ªä½ç½®ä¸Š 1çš„ä¸ªæ•°ã€‚ 12345678910111213141516171819int Count1InInteger(int n)&#123; int counts =0; while (n!=0) &#123; counts += (n%10) ==1? 1:0; n/=10; &#125; return counts;&#125;int main()&#123; int total =0; for (int i=0; i&lt;N; i++) &#123; total += Count1InInteger(i) &#125; return total;&#125; è¿›é˜¶ç‰ˆæœ¬ï¼špython ç‰ˆæœ¬ï¼Œæ€è·¯è§ä¸Šé¢åˆ†æžã€‚ 1234567891011121314151617181920class Solution: # æ•°å­—çš„åŸºæœ¬ç»“æž„åˆ†æˆ weights +working_num + n%base è¿™ä¸‰ä¸ªéƒ¨åˆ† # ç„¶åŽä¸€ä¸ªwhile å¾ªçŽ¯æ˜¯å¤„ç†ä¸€ä¸ªæ•°å­— def NumberOf1Between1AndN_Solution(self, n): # write code here if n &lt; 1: return 0 num = n counts = 0 base = 1 while num: cur = num % 10 num = num // 10 #é«˜ä½æ•°å­— counts += base * num if cur == 1: counts += (n % base) + 1 elif cur &gt; 1: counts += base base *= 10 return counts æœ€ä¼˜çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(log N)$ã€‚ä¸‹é¢çš„ä»£ç çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $ O(log^2(N))$. c++ è§£æ³•12345678910111213141516171819202122232425262728class Solution &#123;public: // æ—¶é—´å¤æ‚åº¦æ˜¯ log^2(N) // ç»è¿‡è®²è§£ä¹‹åŽï¼Œåªè¦å¾—åˆ° left right è¿™æ ·çš„æ•°å­—é‚£ä¹ˆåŽé¢å°±æ¯”è¾ƒå¥½è¯´äº† int NumberOf1Between1AndN_Solution(int n) &#123; if(!n) return 0; vector&lt;int&gt; number; // æŠŠæ¯ä¸€ä¸ªæ•°å­—å•ç‹¬çš„ä¿å­˜èµ·æ¥ // å¾ˆå¥½çš„å°çš„ä»£ç  // int ç±»åž‹çš„æ•°å­—ï¼Œè½¬æ¢æˆ int æ•°ç»„ç±»åž‹ while(n) number.push_back(n%10), n /=10; int res =0; for(int i =number.size() -1; i&gt;=0; i--) &#123; // t æ˜¯ä»€ä¹ˆå«ä¹‰ auto left =0, right =0, t =1; for(int j =number.size() -1; j&gt;i; j--) left =left*10 +number[j]; for(int j =i-1; j&gt;=0; j--) right =right *10+number[j], t *=10; res += left *t; if(number[i] ==1) res += right +1; else if(number[i] &gt;1) res += t; &#125; return res; &#125;&#125;; æŠŠæ•°ç»„æŽ’æˆæœ€å°çš„æ•° ï¼ˆå¤ä¹ åˆ°è¿™é‡Œäº†ï¼‰ è¾“å…¥ä¸€ä¸ªæ­£æ•´æ•°æ•°ç»„ï¼ŒæŠŠæ•°ç»„é‡Œæ‰€æœ‰æ•°å­—æ‹¼æŽ¥èµ·æ¥æŽ’æˆä¸€ä¸ªæ•°ï¼Œæ‰“å°èƒ½æ‹¼æŽ¥å‡ºçš„æ‰€æœ‰æ•°å­—ä¸­æœ€å°çš„ä¸€ä¸ªã€‚ä¾‹å¦‚è¾“å…¥æ•°ç»„{3ï¼Œ32ï¼Œ321}ï¼Œåˆ™æ‰“å°å‡ºè¿™ä¸‰ä¸ªæ•°å­—èƒ½æŽ’æˆçš„æœ€å°æ•°å­—ä¸º321323ã€‚ Tipsï¼šä½¿ç”¨sorted() å‡½æ•°ï¼Œ string ç±»åž‹çš„æŽ’åº å’Œ int ç±»åž‹çš„æŽ’åºæ˜¯ä¸€æ ·çš„ï¼Œåœ¨python é‡Œé¢æ¥è¯´ã€‚ 1234567class Solution: def PrintMinNumber(self, numbers): # write code here sorted_list = sorted(numbers, cmp=lambda a, b: cmp(str(a) + str(b), str(b) + str(a))) # è¿™ä¸ªæ—¶å€™å·²ç»æŽ’å¥½åºï¼Œç„¶åŽåªè¦ä¸€ä¸ªä¸ªè¿žæŽ¥èµ·æ¥å°±è¡Œäº† return ''.join(map(str, sorted_list)) è¿™ç§æ–¹å¼æ˜¯åŠå…¶å¥½ç”¨çš„ã€‚ 12list =["abc", "ad"]print("".join(list)) å‡¡æ˜¯èƒ½å¤ŸæŽ¨å‡ºæ¥çš„ï¼Œéƒ½æ˜¯æ¯”è¾ƒç®€å•çš„ï¼›å‡¡æ˜¯éœ€è¦çŒœå‡ºæ¥çš„ï¼Œéƒ½æ˜¯æ¯”è¾ƒéš¾çš„ã€‚å¯¹äºŽè¿™é“é¢˜ç›®ï¼Œéœ€è¦å…ˆå®šä¹‰ä¸€ç§æŽ’åºæ–¹å¼ï¼Œç„¶åŽå†èŽ·å¾—æœ€å°çš„æ•°å­—ã€‚ä¸»è¦æ˜¯æ¯”è¾ƒå‡½æ•°ã€‚ 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;// æ‹¼æŽ¥å‡ºæ‰€æœ‰æ•°å­—ä¸­æœ€å°çš„ä¸€ä¸ªbool cmp(int a, int b)&#123; string sa =to_string(a), sb =to_string(b); return sa +sb&lt; sb+sa;&#125;int main()&#123; vector&lt;int&gt; arr; int n ; cin &gt;&gt;n; for(int i =0; i&lt; n; i++) &#123; int tmp; cin &gt;&gt;tmp; arr.push_back(tmp); &#125; sort(arr.begin(), arr.end(), cmp); string res; for(auto u: arr) &#123; res += to_string(u); &#125; cout &lt;&lt; res&lt;&lt; endl; return 0;&#125; ä¸‘æ•° æŠŠåªåŒ…å«è´¨å› å­2ã€3å’Œ5çš„æ•°ç§°ä½œä¸‘æ•°ï¼ˆUgly Numberï¼‰ã€‚ä¾‹å¦‚6ã€8éƒ½æ˜¯ä¸‘æ•°ï¼Œä½†14ä¸æ˜¯ï¼Œå› ä¸ºå®ƒåŒ…å«è´¨å› å­7ã€‚ ä¹ æƒ¯ä¸Šæˆ‘ä»¬æŠŠ1å½“åšæ˜¯ç¬¬ä¸€ä¸ªä¸‘æ•°ã€‚æ±‚æŒ‰ä»Žå°åˆ°å¤§çš„é¡ºåºçš„ç¬¬Nä¸ªä¸‘æ•°ã€‚ Tipsï¼šä¹‹åŽçš„ä¸‘æ•°è‚¯å®šæ˜¯2ï¼Œ3æˆ–5 çš„å€æ•°ï¼Œåˆ†åˆ«å•ç‹¬è®¡æ•°ï¼Œç„¶åŽé€‰æ‹©æœ€å°çš„ã€‚ æ³¨æ„ä¸¤ä¸ªç‰ˆæœ¬å†å®žçŽ°çš„æ—¶å€™ç¨å¾®æœ‰ä¸€ç‚¹ä¸åŒã€‚ 12345678910111213class Solution(object): def getUglyNumber(self, n): index =n if index &lt; 1: return 0 res = [1] t2,t3,t5 = 0,0,0 while len(res) &lt; index: minNum = (min(res[t2]*2, res[t3]*3, res[t5]*5)) if minNum &gt; res[-1]: res.append(minNum) if (minNum == res[t2]*2): t2 += 1 elif (minNum == res[t3]*3): t3 += 1 else: t5 += 1 return res[-1] ä½¿ç”¨c++ å®žçŽ°ã€‚æ˜¯éœ€è¦æœ‰ $O(N)$ çš„ç©ºé—´çš„ï¼Œ 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;// è¿™ä¸ªæ˜¯æ¯”è¾ƒæœ‰æŠ€å·§çš„ï¼Œä½¿ç”¨ ijk ä¸‰ä¸ªæŒ‡é’ˆint main()&#123; int n; vector&lt;int&gt; res(1,1); cin &gt;&gt;n; int i =0, j =0, k=0; while (--n) &#123; int min_v =min(res[i] *2, min(res[j] *3, res[k] *5 )); res.push_back(min_v); if(min_v == res[i] *2) i +=1; if( min_v == res[j] *3 ) j+=1; if(min_v ==res[k] *5) k +=1; &#125; cout &lt;&lt; res.back()&lt;&lt; endl; return 0;&#125; æ­£åˆ™è¡¨è¾¾å¼åŒ¹é… è¯·å®žçŽ°ä¸€ä¸ªå‡½æ•°ç”¨æ¥åŒ¹é…åŒ…æ‹¬â€™.â€™å’Œâ€™â€˜çš„æ­£åˆ™è¡¨è¾¾å¼ã€‚æ¨¡å¼ä¸­çš„å­—ç¬¦â€™.â€™è¡¨ç¤ºä»»æ„ä¸€ä¸ªå­—ç¬¦ï¼Œè€Œâ€™â€˜è¡¨ç¤ºå®ƒå‰é¢çš„å­—ç¬¦å¯ä»¥å‡ºçŽ°ä»»æ„æ¬¡ï¼ˆåŒ…å«0æ¬¡ï¼‰ã€‚ åœ¨æœ¬é¢˜ä¸­ï¼ŒåŒ¹é…æ˜¯æŒ‡å­—ç¬¦ä¸²çš„æ‰€æœ‰å­—ç¬¦åŒ¹é…æ•´ä¸ªæ¨¡å¼ã€‚ä¾‹å¦‚ï¼Œå­—ç¬¦ä¸²â€aaaâ€ä¸Žæ¨¡å¼â€a.aâ€å’Œâ€abacaâ€åŒ¹é…ï¼Œä½†æ˜¯ä¸Žâ€aa.aâ€å’Œâ€ab*aâ€å‡ä¸åŒ¹é… Tips: dp é—®é¢˜ã€‚è½¬æ¢æ–¹ç¨‹ dp[i][j] i è¡¨ç¤º string çš„index jè¡¨ç¤º pattern çš„indexï¼Œ dp[i][j] ==dp[i-1][j-1] or dp[i][j] =dp[i][j-2] or dp[i][j-1] ã€‚ 123456789101112131415161718192021222324class Solution: # s, patternéƒ½æ˜¯å­—ç¬¦ä¸² # https://www.youtube.com/watch?v=l3hda49XcDE å¿ƒä¸­ä¸€å®šè¦æœ‰è¿™ä¸ªè¡¨æ ¼, a[i][j] è¿™ä¸ªæ›´åƒæ˜¯ä¸€ç§æŒ‡é’ˆ def match(self, s, pattern): if len(s) == 0 and len(pattern) == 0: return True dp = [[False for _ in range(len(pattern) + 1)] for _ in range(len(s) + 1)] dp[0][0] = True for j in range(1, len(pattern) + 1): if pattern[j - 1] == "*": dp[0][j] = dp[0][j - 2] for i in range(1, len(s) + 1): for j in range(1, len(pattern) + 1): if pattern[j - 1] == s[i - 1] or pattern[j - 1] == ".": dp[i][j] = dp[i - 1][j - 1] elif pattern[j - 1] == "*": dp[i][j] = dp[i][j - 2] if s[i - 1] == pattern[j - 2] or pattern[j - 2] == ".": dp[i][j] = dp[i][j] or dp[i - 1][j] else: dp[i][j] = False return dp[len(s)][len(pattern)] è§†é¢‘ä¸­è®²è§£dp ä½¿ç”¨çš„dfs çš„æ€æƒ³ï¼Œä½†æ˜¯æˆ‘æ›´åŠ å–œæ¬¢ä½¿ç”¨æ–¹æ ¼çš„æ€æƒ³ã€‚æ‰€ä»¥è¿™ä¸ªæ˜¯å¯ä»¥æš‚æ—¶çš„è¿‡åŽ»ã€‚ æ•°æ®æµä¸­çš„ä¸­ä½æ•° å¦‚ä½•å¾—åˆ°ä¸€ä¸ªæ•°æ®æµä¸­çš„ä¸­ä½æ•°ï¼Ÿå¦‚æžœä»Žæ•°æ®æµä¸­è¯»å‡ºå¥‡æ•°ä¸ªæ•°å€¼ï¼Œé‚£ä¹ˆä¸­ä½æ•°å°±æ˜¯æ‰€æœ‰æ•°å€¼æŽ’åºä¹‹åŽä½äºŽä¸­é—´çš„æ•°å€¼ã€‚å¦‚æžœä»Žæ•°æ®æµä¸­è¯»å‡ºå¶æ•°ä¸ªæ•°å€¼ï¼Œé‚£ä¹ˆä¸­ä½æ•°å°±æ˜¯æ‰€æœ‰æ•°å€¼æŽ’åºä¹‹åŽä¸­é—´ä¸¤ä¸ªæ•°çš„å¹³å‡å€¼ã€‚æˆ‘ä»¬ä½¿ç”¨Insert()æ–¹æ³•è¯»å–æ•°æ®æµï¼Œä½¿ç”¨GetMedian()æ–¹æ³•èŽ·å–å½“å‰è¯»å–æ•°æ®çš„ä¸­ä½æ•°ã€‚ Tipsï¼šä¸»è¦æ˜¯ä½“çŽ°äº†æ•°æ®æµï¼Œè¦æ±‚èƒ½å¤Ÿ insert å…ƒç´ ï¼Œç„¶åŽåŸºäºŽå½“å‰çš„çŠ¶æ€åŽ» getmedian() ï¼Œæ˜¯åŠ¨æ€çš„ï¼Œè€Œä¸æ˜¯é™æ€çš„ã€‚ 1234567891011121314151617181920class Solution: """ å¯¹äºŽæ•°æ®æµ è¿™ä¸ªåº”è¯¥æ˜¯ç¬¬äºŒæ¬¡æŽ¥è§¦äº†ï¼Œéœ€è¦ä½¿ç”¨ä¸€ä¸ªå…¨å±€å˜é‡ """ # è™½ç„¶çŸ¥é“è¿™ä¸ªä½¿ç”¨ å †çš„æ€æƒ³æ˜¯æ›´ä¼˜çš„ï¼Œæœç´¢æ—¶é—´å¯ä»¥Oï¼ˆ1ï¼‰ï¼Œ å †çš„è°ƒæ•´æ˜¯ O(log n) # ä½†æ˜¯æ²¡æœ‰ä»€ä¹ˆå¾ˆå¥½çš„æ•™ç¨‹ï¼Œæ‰€ä»¥æˆ‘ä¹Ÿæ²¡æœ‰å­¦ä¼šå•Š def __init__(self): self.list1 = [] def Insert(self, num): self.list1.append(num) def GetMedian(self, ch): length = len(self.list1) # æˆ‘è®°å¾—æœ‰ä¸€ä¸ªæ›´åŠ å¿«ä¸€äº› self.list1 = sorted(self.list1) if length % 2 == 0: return (self.list1[length // 2] + self.list1[length // 2 - 1]) / 2.0 else: return self.list1[length // 2] ä½¿ç”¨å¤§æ ¹å †å’Œå°æ ¹å †å®žçŽ°çš„åŠŸèƒ½æ˜¯éžå¸¸çš„ç²¾å¦™å‘€ï¼Œå¥½å¥½æ•²ä»£ç ï¼Œå¥½å¥½å­¦ä¹ ã€ 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: // å¤§æ ¹å †åœ¨ä¸‹é¢ï¼Œå°æ ¹å †åœ¨ä¸Šé¢ // å°æ ¹å †å­˜å‚¨å¤§çš„æ•°å­—ï¼Œå †é¡¶æ˜¯å°çš„å…ƒç´ ï¼Œå¤§æ ¹å †å­˜å‚¨å°çš„æ•°å­—ï¼Œå †é¡¶æ˜¯å¤§çš„å…ƒç´ ã€‚ // æ’å…¥çš„æ—¶å€™ä¼˜å…ˆå¾€å°æ ¹å †æ’å…¥ï¼Œå¦‚æžœå‘çŽ°ä¸¤å †ç›¸å·®å¤§äºŽ1ï¼Œé‚£ä¹ˆè°ƒæ•´ä¸¤ä¸ªå † // æ€»æ•°æ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆè¿”å›žå°æ ¹å †çš„å †é¡¶ï¼›æ€»æ•°æ˜¯å¶æ•°ï¼Œè¿”å›žä¸¤ä¸ªå †çš„å †é¡¶çš„å‡å€¼ // ä¸¤ä¸ªå † å¦‚ä½•è¿›è¡Œç»´æŠ¤å‘¢ï¼Ÿ äº¤æ¢ if é€†åºï¼› è½¬ç§» if å°æ ¹å †æ¯”è¾ƒå¤š priority_queue&lt;int&gt; max_heap; // priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; min_heap; void Insert(int num) &#123; max_heap.push(num); // å¦‚æžœæ˜¯é€†åº if(min_heap.size() &amp;&amp; max_heap.top() &gt; min_heap.top() ) &#123; auto maxv =max_heap.top(), minv= min_heap.top(); max_heap.pop(), min_heap.pop(); max_heap.push(minv),min_heap.push(maxv); &#125; // å¦‚æžœä¸‹é¢å¤š if(max_heap.size() &gt; min_heap.size() +1) &#123; min_heap.push(max_heap.top()); max_heap.pop(); &#125; &#125; double GetMedian() &#123; if(max_heap.size() + min_heap.size() &amp;1) return max_heap.top(); return (max_heap.top() + min_heap.top())/2.0; &#125; &#125;; è¿™ä¸ªæ˜¯å•æœºç‰ˆæœ¬çš„ã€‚ 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;priority_queue&lt;int&gt; max_h; // heap å †priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; min_h;void insert(int val)&#123; max_h.push(val); // å¤„ç†é€†åº if(min_h.size() &amp;&amp; min_h.top() &lt; max_h.top()) &#123; int minv =min_h.top(), maxv =max_h.top(); min_h.pop(), max_h.pop(); min_h.push(maxv), max_h.push(minv); &#125; // å¤„ç† diff &gt; 1 çš„æƒ…å†µ if(max_h.size() &gt; min_h.size() +1) &#123; min_h.push(max_h.top()); max_h.pop(); &#125;&#125;double get_median()&#123; if(max_h.size() + min_h.size() &amp;1) return max_h.top(); return (max_h.top() +min_h.top())/2.0;&#125;int main()&#123; return 0;&#125; æ»‘åŠ¨çª—å£çš„æœ€å¤§å€¼ ç»™å®šä¸€ä¸ªæ•°ç»„å’Œæ»‘åŠ¨çª—å£çš„å¤§å°ï¼Œæ‰¾å‡ºæ‰€æœ‰æ»‘åŠ¨çª—å£é‡Œæ•°å€¼çš„æœ€å¤§å€¼ã€‚ä¾‹å¦‚ï¼Œå¦‚æžœè¾“å…¥æ•°ç»„{2,3,4,2,6,2,5,1}åŠæ»‘åŠ¨çª—å£çš„å¤§å°3ï¼Œé‚£ä¹ˆä¸€å…±å­˜åœ¨6ä¸ªæ»‘åŠ¨çª—å£ï¼Œä»–ä»¬çš„æœ€å¤§å€¼åˆ†åˆ«ä¸º{4,4,6,6,6,5}ï¼› é’ˆå¯¹æ•°ç»„{2,3,4,2,6,2,5,1}çš„æ»‘åŠ¨çª—å£æœ‰ä»¥ä¸‹6ä¸ªï¼š {[2,3,4],2,6,2,5,1}ï¼Œ {2,[3,4,2],6,2,5,1}ï¼Œ {2,3,[4,2,6],2,5,1}ï¼Œ {2,3,4,[2,6,2],5,1}ï¼Œ {2,3,4,2,[6,2,5],1}ï¼Œ {2,3,4,2,6,[2,5,1]}ã€‚ Tipsï¼šä½¿ç”¨max(list1) è¿™æ ·çš„æ“ä½œæ˜¯å¯è¡Œçš„ã€‚ 123456789class Solution: # æœ€ç®€å•çš„æ¨¡æ‹Ÿæ»‘åŠ¨çª—å£ çš„è¿‡ç¨‹ def maxInWindows(self, num, size): slip = [] if not num or len(num) &lt; size or size == 0: return [] for i in range(len(num) - size + 1): slip.append(max(num[i:i + size])) return slip c++ ä¸­çš„deque æ˜¯åŒå‘é˜Ÿåˆ—ã€‚ è¿™ä¸ªåœ¨ç‰›å®¢ç½‘ä¸Šé€šè¿‡çš„æ ·ä¾‹æ˜¯ 12.5%ï¼Œä¼°è®¡æ˜¯çˆ†äº†å†…å­˜ä¹‹ç±»å§ã€‚ 1234567891011121314151617class Solution &#123;public: // å•è°ƒé˜Ÿåˆ—é—®é¢˜ï¼Œå•è°ƒåœ¨äºŽé˜Ÿé¦–åˆ°é˜Ÿå°¾æ˜¯é€’å‡çš„ã€‚ä½¿ç”¨åŒå‘é˜Ÿåˆ—åœ¨äºŽè¦æ”¯æŒé˜Ÿå°¾åˆ é™¤å…ƒç´  // ä½¿ç”¨é˜Ÿåˆ—æ˜¯ç»´æŒä¸€ä¸ªæ»‘åŠ¨çª—å£çš„æ¦‚å¿µï¼Œ vector&lt;int&gt; maxInWindows(vector&lt;int&gt;&amp; nums, int k) &#123; deque&lt;int &gt; q; vector&lt;int&gt; res; for(int i =0; i&lt; nums.size() ; i++) &#123; while( q.size() &amp;&amp; q.front() &lt;= i -k) q.pop_front();// i è¡¨ç¤ºå½“å‰çš„éåŽ†çš„indexï¼Œq.front() ä¸å¯èƒ½æ¯”è¿™ä¸ªå¤§ while(q.size() &amp;&amp; nums[q.back()] &lt;= nums[i]) q.pop_back(); q.push_back(i); if(i &gt;=k -1) res.push_back(nums[q.front()]); &#125; return res; &#125;&#125;; æ±‚è§£è¿žç»­å­æ•°ç»„çš„æœ€å¤§å’Œ c++ ä»£ç  1234567891011121314151617181920212223242526272829303132 #include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;// æ•´æ•°æ•°ç»„ä¸­å…ƒç´ æœ‰æ­£æœ‰è´Ÿï¼Œæ‰¾å‡ºä¸€ä¸ªè¿žç»­çš„å­æ•°ç»„ï¼Œè¦æ±‚è¿žç»­å­æ•°ç»„ä¸­å„å…ƒç´ å’Œå’Œæœ€å¤§ã€‚int maxSub(vector&lt;int&gt; arr, int n)&#123; int now =0; int max_v =INT_MIN; for(auto u: arr) &#123; now += u; if (now &lt;0) now =0; // æ³¨æ„è¿™é‡Œæ˜¯æ±‚è§£æœ€å¤§çš„å’Œ max_v =max(now, max_v); &#125; return max_v;&#125;int main()&#123; vector&lt;int&gt; arr; int n ; cin &gt;&gt;n; while(n --) &#123; int tmp; cin &gt;&gt;tmp; arr.push_back(tmp); &#125; int res =maxSub(arr, n); cout &lt;&lt; res&lt;&lt; endl; return 0;&#125; python ä»£ç  12345678910111213141516 # æ—¶é—´å¤æ‚åº¦æ˜¯ O(n), ç©ºé—´æ˜¯ O(1)def largestSub(arr): if not arr or len(arr) ==0: return now =0 max_v =arr[0] for i in range(len(arr)): now += arr[i] if(now &lt;0) : now =0 max_v =max(now, max_v) return max_v arr =[2, 4, -7, 5, 2, -1, 2, -4, 3]print(largestSub(arr))]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python from Beginner to Master]]></title>
    <url>%2F2019%2F01%2F09%2Fpython-for-beginners%2F</url>
    <content type="text"><![CDATA[Basic Skillsmodulepython æ–‡ä»¶å¯ä»¥å½“åšä¸»æ–‡ä»¶è¿›è¡Œè¿è¡Œæˆ–è€…å½“åšå‡½æ•°çš„é›†åˆè¿›è¡Œè°ƒç”¨ã€‚å¦‚æžœæ˜¯å‰è€…ä¸€èˆ¬æ˜¯éœ€è¦åŒ…å«â€__name__ ==â€__main__â€ã€‚å¯¹äºŽåŽè€…å°±æ˜¯åœ¨å…¶ä»–çš„pythonæ–‡ä»¶ä¸­è¿›è¡Œè°ƒç”¨ã€‚ 12import my_module # pythonæ–‡ä»¶from my_module import my_object packagesfrom packageroot.packagefolder.mod import my_object Note: Ensure each directory within your package import contains a file __init__.py python-pathpython2 å’Œpython3 ä½¿ç”¨ä¸åŒçš„è§£é‡Šå™¨ï¼Œå¯¼è‡´åœ¨ä¸€äº›å‡½æ•°å‘½åå’Œè®¡ç®—ä¸Šæœ‰ä¸€äº›å·®åˆ«ï¼Œæœ€å¥½åœ¨æ–‡ä»¶çš„å¼€å¤´æ ‡æ˜Žä½¿ç”¨çš„è§£é‡Šå™¨ã€‚ while or forwhile : provide a condition and run the loop until the condition is not met. for: loop for a number of specific times; loop over items or characters of a string. examples: 1234[Variable] AggregateFunction([Value] for [item] in [collection])x =[1, 2,3, 4, 5]y =[ 2*a for a in x if a%2 ==0]y &gt;&gt; [4, 8] æˆ–è€…å¯ä»¥ä½¿ç”¨è¿™æ ·æ›´åŠ ç®€æ´çš„è¯­å¥ï¼š 123lambda arguments : expressionfun1 = lambda a,b,c : a+b+cprint(fun1(5,6,2)) æ¥ä¸ªæ¯”è¾ƒå¤æ‚çš„ä¾‹å­: 12345nums =[1,2,3,4,5]letters =['a', 'b', 'c','d','e']# ä¸¤ä¸ªfor å¾ªçŽ¯ä¹Ÿæ˜¯è¦ç†Ÿç»ƒnums_letters =[[n, l] for n in nums for l in letters ]nums_letters break, continue, or passThe break, continue, and pass statements in Python will allow you to use for loops and while loops more effectively in your code.12345678910number = 0for number in range(10): number = number + 1 if number == 5: pass # pass here print('Number is ' + str(number))print('Out of loop') pass å…³é”®è¯çš„ä½œç”¨ï¼š ç©ºè¯­å¥ do nothing ä¿è¯æ ¼å¼å®Œæ•´ ä¿è¯è¯­ä¹‰å®Œæ•´ ç®€å•æ¥è¯´å°±æ˜¯å ä½ï¼Œæ²¡æœ‰ä»€ä¹ˆå®žè´¨æ€§çš„å†…å®¹ã€‚ The pass statement occurring after the if conditional statement is telling the program to continue to run the loop and ignore the fact that the variable number evaluates as equivalent to 5 during one of its iterations. yield å¯ä»¥ç”¨ç”¨ä½œæ–°çš„ ifçš„æµ‹è¯•, return results without termination The pass statement can create minimal classes, or act as a placeholder when working on new code and thinking on an algorithmic level before hammering out details.pass çš„å­˜åœ¨å°±æ˜¯å å‘ï¼Œå¦åˆ™è¿™ä¸ªåœ°æ–¹å°±æ˜¯æŠ¥é”™ï¼ˆIndentationErrorï¼‰ã€‚ç”¨äºŽæƒ³è¦æ‰©å±•çš„åœ°æ–¹ï¼Œä½†æ˜¯çŽ°åœ¨è¿˜æ²¡æœ‰æ‰©å±•ã€‚æ¯”å¦‚åœ¨æŸä¸ªmethod ä¸‹é¢æˆ–è€…æŸä¸ª if æ¡ä»¶ä¸‹ã€‚ yield or returnyield ç»å¸¸è¢«ç”¨æ¥ä½œä¸ºç”Ÿæˆå™¨ï¼Œè¿”å›žä½†æ˜¯å´æ²¡æœ‰è§£å†³å‡½æ•°ï¼Œä¸‹ä¸€å›žä»Žä¸Šä¸€å›žçš„ä½ç½®å¼€å§‹ã€‚ when you call a normal function with a return statement the function is terminated whenever it encounters a return statement. In a function with a yield statement the state of the function is â€˜savedâ€™ from the last call and can be picked up the next time you call a generator function. for examples12345678910111213141516171819gen_exp =(x **2 for x in range(10) if x %2 ==0)for x in gen_exp: print(x)def my_gen(): for x in range(5): yield xgen1 =my_gen()next(gen1)def my_generator1(): yield 1 yield 2 yield 3 my_gen =my_generator1()# ä½¿ç”¨ next() è¿›è¡Œè°ƒç”¨ä¸‹ä¸€ä¸ªnext(my_gen) recursionA function calling itself is known as recursion.ï¼ˆ recursion æ˜¯é€’å½’ï¼Œ iteration æ˜¯å¾ªçŽ¯ï¼‰ list, tuples, or dictionaryåœ¨python ä¸­æ˜¯ä½¿ç”¨é¢‘ç¹çš„data structureï¼Œè¿™ä¸ªæ˜¯å±žäºŽ collection ç±»åˆ«ï¼Œé‡Œé¢æ”¾çš„æ˜¯element. list: to add/update/ delete an item of a collection 123456my_list.append('C') #adds at the endmy_list[1] = 'D' #updatemy_list.pop(1) # removesmylist.pop() # é»˜è®¤å°±æ˜¯ç±»ä¼¼ æ ˆçš„ç»“æž„ï¼Œå°±æ˜¯pop å‡ºæ¥æœ€åŽä¸€ä¸ªmylist.pop(0) # å½“ç„¶ä¹Ÿå¯ä»¥æ ¹æ®index æŒ‡å®šç‰¹å®šçš„ pop(delete) çš„element å¯¹äºŽindex çš„è®¿é—®ï¼Œä¸€å®šè¦ä¿è¯æœ‰ç›¸åº”çš„size() é•¿åº¦ï¼Œç„¶åŽå†è¿›è¡Œindex çš„è®¿é—® 12del mylist[1:2] # é€šè¿‡æŒ‡å®š index range ç„¶åŽè¿›è¡Œdelmylist.sort() # æ”¯æŒ sorting ç„¶åŽæ˜¯ä»Žå°åˆ°å¤§, è¿™ä¸ªsortæ˜¯ä¸€ç§æ“ä½œï¼Œinplace çš„æ“ä½œ tuples: tuples store a sequence of objects, the object can be of any type. Tuples are faster than lists. dictionary: It stores key/value pair objects. 123456789my_dict =dict()my_dict['key'] ='value'or my_dict =&#123;'key': 'value', ...&#125;for key in my_dict:# do somethingif 'some key' in my_dict:# do something Iterators1234567891011121314151617class yrange: def __init__(self, n): self.i = 0 self.n = n # è¿™ä¸ªè¡¨æ˜Žæ˜¯ä¸€ä¸ª iteratorï¼Œmake an object iterable def __iter__(self): return self # è¿™ä¸ªnext å‡½æ•°å°±è¢«å½“åšæ˜¯ classçš„å±žæ€§ï¼Œå¯ä»¥è¢«å¤–éƒ¨è°ƒç”¨çš„ï¼Œ def next(self): if self.i &lt; self.n: i = self.i self.i += 1 return i else: raise StopIteration() shallow vs deep copypython3 ä¸­ï¼šå¯¹äºŽç®€å•çš„æ•°æ®ç±»åž‹ï¼Œåƒint ï¼Œstringï¼Œè¿™ç§ copy() å’Œcopy.deepcopy() è¿™ä¸¤è€…éƒ½æ˜¯ç›¸åŒçš„ï¼Œcopy éƒ½æ˜¯ä¸€ç§æ˜ å°„ï¼Œéƒ½æ˜¯ç›¸å½“äºŽâ€å€¼â€œ ä¸Šçš„å¼•ç”¨ï¼› 12345aa =2bb =aaprint(id(aa), id(bb)) # ç›¸åŒbb =3print(id(aa), id(bb)) # ä¸åŒï¼Œå› ä¸ºæŠŠ3 è¿™ä¸ªå€¼é‡æ–°å¤åˆ¶ç»™äº†å˜é‡bb å¯¹äºŽå¤æ‚çš„æ•°æ®ç±»åž‹ï¼Œä½¿ç”¨deepcopy() çš„æ—¶å€™ï¼Œæœ¬æ¥å°±æ˜¯ä¼šé‡æ–°æ‹·è´ä¸€ä»½åˆ°å†…å­˜ä¸­ã€‚åœ¨python3 ä¸­copy() å’Œdeepcopy() è¿™ä¸ªæ˜¯æ²¡æœ‰ä»€ä¹ˆåŒºåˆ«çš„ã€‚12345list1 =['a', 'b']list2 =list1 # è¿™ä¸ªæ˜¯å¼•ç”¨ï¼Œæ‰€ä»¥å’Œlist1 æ˜¯ç›¸åŒçš„list3 =copy.copy(list1) # è¿™ä¸ªid å’Œlist1 ä¸åŒlist4 =copy.deepcopy(list1)# è¿™ä¸ªid å’Œlist1 ä¸åŒ print(id(list1), id(list2), id(list3), id(list4)) åœ¨python ä¸­å¦‚ä½•è¿”å›žå€¼æœ‰å¤šä¸ªï¼Œå¯ä»¥ä½¿ç”¨å…ƒç»„ã€‚è™½ç„¶æ˜¯å¯ä»¥ä½¿ç”¨å…¨å±€å˜é‡ï¼Œä½†æ˜¯åœ¨çœŸæ­£çš„å·¥ä½œä¸­æ˜¯ä¸æŽ¨èè¿™æ ·åšçš„ï¼Œå› ä¸ºåœ¨å¤šçº¿ç¨‹çŽ¯å¢ƒä¸‹ï¼Œè¿™ç§æ–¹å¼å¹¶ä¸æ˜¯ä¸€ç§ çº¿ç¨‹å®‰å…¨çš„æ–¹æ³•ã€‚ å…³äºŽ ä¼ å€¼è¿˜æ˜¯ä¼ å¼•ç”¨ï¼Ÿ ç»“è®ºï¼špythonä¸å…è®¸ç¨‹åºå‘˜é€‰æ‹©é‡‡ç”¨ä¼ å€¼è¿˜æ˜¯ä¼ å¼•ç”¨ã€‚Pythonå‚æ•°ä¼ é€’é‡‡ç”¨çš„è‚¯å®šæ˜¯â€œä¼ å¯¹è±¡å¼•ç”¨â€çš„æ–¹å¼ã€‚è¿™ç§æ–¹å¼ç›¸å½“äºŽä¼ å€¼å’Œä¼ å¼•ç”¨çš„ä¸€ç§ç»¼åˆã€‚å¦‚æžœå‡½æ•°æ”¶åˆ°çš„æ˜¯ä¸€ä¸ªå¯å˜å¯¹è±¡ï¼ˆæ¯”å¦‚å­—å…¸æˆ–è€…åˆ—è¡¨ï¼‰çš„å¼•ç”¨ï¼Œå°±èƒ½ä¿®æ”¹å¯¹è±¡çš„åŽŸå§‹å€¼ï¼ï¼ç›¸å½“äºŽé€šè¿‡â€œä¼ å¼•ç”¨â€æ¥ä¼ é€’å¯¹è±¡ã€‚å¦‚æžœå‡½æ•°æ”¶åˆ°çš„æ˜¯ä¸€ä¸ªä¸å¯å˜å¯¹è±¡ï¼ˆæ¯”å¦‚æ•°å­—ã€å­—ç¬¦æˆ–è€…å…ƒç»„ï¼‰çš„å¼•ç”¨ï¼Œå°±ä¸èƒ½ç›´æŽ¥ä¿®æ”¹åŽŸå§‹å¯¹è±¡ï¼ï¼ç›¸å½“äºŽé€šè¿‡â€œä¼ å€¼â€™æ¥ä¼ é€’å¯¹è±¡ã€‚ ç»†è¯´ï¼š å¯¹äºŽä¸å¯å˜çš„å¯¹è±¡ï¼ŒåŽŸå§‹çš„å¯¹è±¡å› ä¸ºä¸èƒ½æ”¹å˜ï¼ŒäºŽæ˜¯è¢«â€œæŠ›å¼ƒâ€ï¼Œå®žé™…ä¸Šæ˜¯æ–°new äº†ä¸€ä¸ªæ•°å€¼ï¼Œæ‰€ä»¥æ“ä½œçš„ä¸æ˜¯åŽŸæ¥ä¸»å‡½æ•°ä¸­çš„å€¼ã€‚ python ä¸­çš„åŸºæœ¬æ•°æ®ç±»åž‹æœ‰å…­ç§ï¼šæ•°å­—ï¼Œå­—ç¬¦ä¸²ï¼Œåˆ—è¡¨ï¼Œå­—å…¸ï¼Œå…ƒç»„å’Œé›†åˆï¼Œ(Number, String, List, Dict, Tuple, Set) æ•°å­—åŒ…æ‹¬æ•´å½¢ï¼Œé•¿æ•´åž‹ï¼Œæµ®ç‚¹åž‹å’Œå¤æ•°ï¼Œ(Int, Long, Float, Complex)å¸ƒå°”å€¼ True å’Œ Falseé›†åˆåŒ…å«é›†åˆå’Œä¸å¯å˜é›†åˆ (set, frozenset)å­—ç¬¦ä¸²é‡ŒåŒ…æ‹¬ å­—ç¬¦ä¸²ï¼Œå­—èŠ‚ä¸²å’Œä¸‡å›½ç  (str, bytes, unicode)åˆ—è¡¨åŒ…æ‹¬ åˆ—è¡¨å’Œå­—èŠ‚æ•°ç»„ (list, bytearray)æœ‰çš„æ—¶å€™åˆ†å››ç§ï¼Œå°±æ˜¯æ•°å­—ï¼Œåºåˆ—ï¼Œé›†åˆå’Œå­—å…¸ã€‚åºåˆ—é‡ŒåŒ…æ‹¬å­—ç¬¦ä¸²å’Œåˆ—è¡¨å’Œå…ƒç»„ã€‚æœ‰çš„æ—¶å€™åˆ†äº”ç§ï¼Œå°±æ˜¯æ•°å­—ï¼Œå­—ç¬¦ä¸²ï¼Œåˆ—è¡¨ï¼Œå…ƒç»„å’Œå­—å…¸ã€‚åˆ—è¡¨é‡ŒåŒ…æ‹¬å…ƒç»„ã€‚å…¶ä¸­ä¸å¯å˜çš„ç±»åž‹æœ‰æ•°å­—ï¼Œå­—ç¬¦ä¸²ï¼Œå¸ƒå°”å€¼ï¼Œå…ƒç»„ï¼Œå’Œ frozensetï¼Œ å¯å˜ç±»åž‹æœ‰åˆ—è¡¨ï¼Œå­—å…¸ï¼Œå’Œé›†åˆã€‚ å¯å˜å’Œä¸å¯å˜çš„åŒºåˆ†æ˜¯è¯¥å¯¹è±¡æ˜¯å¦å­˜åœ¨ add æˆ–è€… append ç­‰æ–¹æ³•æ¥å¢žåŠ å¯¹è±¡å…ƒç´ ï¼Œä½¿å¾—å¯¹è±¡åœ¨ä¸æ”¹å˜è‡ªèº« ID çš„æƒ…å†µæ”¹å˜å†…å®¹ã€‚ object oriented design1234567class ParentClass: def my_function(self): print 'I am here'class SubClass1(ParentClass): class SubClass2(ParentClass): å¯¹äºŽå¤šç»§æ‰¿çš„æ”¯æŒ ï¼ˆæŽ¥å£ï¼‰ 1class A(B,C): #A implments B and C å¦‚æžœæƒ³è¦call parent class function then you can dp: 1super(A, self).funcion_name() garbage collectionall the objects in python are stored in a heap (å †) space. Python has an built-in garbage collection mechanism. Memory management in Python involves a private heap containing all Python objects and data structures. The management of this private heap is ensured internally by the Python memory manager. In computer science, a heap is a specialized tree-based data structure which is essentially an almost complete[1] tree that satisfies the heap property: if P is a parent node of C, then the key(the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. tryâ€¦catch123456789101112131415161718# raise exceptionstry: raise TyeErrorexcept: print('exception')# catching exceptionstry: do_something()except: print('exception')# try/ catch /finallytry: do_something()except TypeError: print('exception')finally: close_connections() å†…ç½®å‡½æ•°ä¸­çš„ all() å’Œ any()è¿™ä¸¤ä¸ªå‡½æ•°çš„å‚æ•°éƒ½æ˜¯iterableï¼Œä¹Ÿå°±æ˜¯ä¸ºlistæˆ–è€…tuple.all() å‡½æ•°: â€œå…¨â€˜çœŸâ€™ä¸ºTrueï¼Œæœ‰â€˜å‡â€™ä¸ºFalseâ€ ; å½“iterableä¸ºç©ºçš„æ—¶å€™ï¼Œå‡½æ•°è¿”å›žå€¼ä¸ºTrueany() â€œå…¨â€˜å‡â€™ä¸ºFalseï¼Œæœ‰â€˜çœŸâ€™ä¸ºTrueâ€. å½“iterableä¸ºç©ºçš„æ—¶å€™ï¼Œå‡½æ•°è¿”å›žå€¼ä¸ºFalse ç»™å‡ºall () å‡½æ•°çš„ä¸€ä¸ªç®€å•çš„ä¾‹å­ 123456789101112131415161718&gt;&gt;&gt; all(['a', 'b', 'c', 'd']) # åˆ—è¡¨listï¼Œå…ƒç´ éƒ½ä¸ä¸ºç©ºæˆ–0True&gt;&gt;&gt; all(['a', 'b', '', 'd']) # åˆ—è¡¨listï¼Œå­˜åœ¨ä¸€ä¸ªä¸ºç©ºçš„å…ƒç´ False&gt;&gt;&gt; all([0, 1ï¼Œ2, 3]) # åˆ—è¡¨listï¼Œå­˜åœ¨ä¸€ä¸ªä¸º0çš„å…ƒç´ False &gt;&gt;&gt; all(('a', 'b', 'c', 'd')) # å…ƒç»„tupleï¼Œå…ƒç´ éƒ½ä¸ä¸ºç©ºæˆ–0True&gt;&gt;&gt; all(('a', 'b', '', 'd')) # å…ƒç»„tupleï¼Œå­˜åœ¨ä¸€ä¸ªä¸ºç©ºçš„å…ƒç´ False&gt;&gt;&gt; all((0, 1, 2, 3)) # å…ƒç»„tupleï¼Œå­˜åœ¨ä¸€ä¸ªä¸º0çš„å…ƒç´ False &gt;&gt;&gt; all([]) # ç©ºåˆ—è¡¨True&gt;&gt;&gt; all(()) # ç©ºå…ƒç»„True æ€»ç»“ï¼šall()ï¼šâ€æœ‰â€˜å‡â€™ä¸ºFalseï¼Œå…¨â€˜çœŸâ€™ä¸ºTrueï¼Œiterableä¸ºç©ºæ˜¯Trueâ€any()ï¼šâ€æœ‰â€˜çœŸâ€™ä¸ºTrueï¼Œå…¨â€˜å‡â€™ä¸ºFalseï¼Œiterableä¸ºç©ºæ˜¯Falseâ€ sort() sorted() å‡½æ•°åœ¨python3 ä¸­ sorted() å–æ¶ˆäº†å¯¹cmp çš„æ”¯æŒ, æ‰€ä»¥åªèƒ½ä½¿ç”¨ sort() å‡½æ•°ï¼Œ æ¯”å¦‚ä¸‹é¢è¯­å¥ï¼Œè¡¨ç¤ºå…ˆæ˜¯æŒ‰ç…§ç¬¬ä¸€ä¸ªå…ƒç´ è¿›è¡Œå‡åºï¼Œç„¶åŽåœ¨ç¬¬ä¸€ä¸ªå…ƒç´ ç›¸åŒçš„æ¡ä»¶ä¸‹ï¼ŒæŒ‰ç…§ç¬¬äºŒä¸ªå…ƒç´ è¿›è¡Œé™åºã€‚ç°å¸¸niceçš„ä¸€ç§å†™æ³•ã€‚12# type envelopes: List[List[int]]envelopes.sort(key =lambda x:(x[0], -x[1])) list.sort( ) æ˜¯in-place æ“ä½œï¼Œ åœ¨python2 ä¸­ sorted() æ˜¯ä¸€ç§æœ‰è¿”å›žæŽ’åºå¥½çš„æ•°ç»„çš„æ“ä½œã€‚ python operatorsPython Arithmetic Operator Addition(+) Subtraction(-) Multiplication(*) Division(/) Exponentiation(**) Floor Division(//) å‘ä¸‹å–æ•´ Modulus(%) Python Relational Operator Less than(&lt;) Greater than(&gt;) Less than or equal to(&lt;=) Greater than or equal to(&gt;=) Equal to(= =) Not equal to(!=) Python Assignment Operatorï¼ˆpython ä¸­æ²¡æœ‰ ++ è¿™ä¸ªç¬¦å·ï¼Œè¿™ä¸ªæ˜¯c++ ä¸­çš„ç¬¦å·ï¼‰ Assign(=) Add and Assign(+=) Subtract and Assign(-=) Divide and Assign(/=) Divide and Assign(/=) Modulus and Assign(%=) Exponent and Assign(**=) Floor-Divide and Assign(//=) Python Logical Operator(ä¼šæœ‰æŸç§æœºåˆ¶ç®€åŒ–è¿ç®—ï¼Œæ¯”å¦‚ condition1 or condition2 ï¼Œå¦‚æžœcondition1 æ˜¯æ­£ç¡®çš„ï¼Œé‚£ä¹ˆæœ€åŽçš„ç»“æžœå°±æ˜¯æ­£ç¡®çš„ã€‚)ç”¨äºŽé€»è¾‘åˆ¤æ–­ and or not Python Membership Operator in ,not in Python Identity Operator is, is not , Python Bitwise Operator (è¿™å…¶ä¸­çš„ | è¡¨çŽ°çš„æ˜¯ä¸€ç§äºŒçº§åˆ¶â€™ å’Œâ€™çš„ å…³ç³»ï¼Œå¦‚æžœåœ¨äºŒè¿›åˆ¶ä¸‹ï¼Œ0 | 1 é‚£ä¹ˆå°±æ˜¯1 ) å±žäºŽé›†åˆæ“ä½œã€‚ Binary AND(&amp;) Binary OR(|) Binary XOR(^) Binary XOR(^) Binary Left-Shift(&lt;&lt;) Binary Right-Shift(&gt;&gt;) Working with files Working with CSV, Json and XML Over the years, the list of possible formats that you can store your data in has grown significantly. But, there are 3 that dominate in their everyday usage: CSV, JSON, and XML. In this article, Iâ€™m going to share with you the easiest ways to work with these 3 popular data formats in Python! æœ‰ä¸¤ç§æ–¹å¼åŽ»è¯»å†™ csv fileï¼šä¸€ç§æ˜¯ pd.read_csv() ï¼Œä¸€ç§æ˜¯built-in çš„library ä¸­çš„åº“å‡½æ•°ä¹‹å‰ä¸€ç›´ä½¿ç”¨çš„pd.read_csv(), çŽ°åœ¨æ‰å‘çŽ°python æœ‰built-in çš„libraryã€‚We can do both read and write of a CSV using the built-in Python csv library. Usually, weâ€™ll read the data into a list of lists. python built-in function.12345678910111213141516171819import csv filename = "my_data.csv"fields = [] rows = [] with open(filename, 'r') as csvfile: csvreader = csv.reader(csvfile) # å¦‚æžœå•å•æ˜¯è¿™ä¸ªforï¼Œé‚£ä¹ˆå†…å­˜æ˜¯æ¶ˆè€—æ¯”è¾ƒå¤§çš„ # fields = csvreader.next() for row in csvreader: rows.append(row)for row in rows[:5]: print(row)# Writing to csv file with open(filename, 'w+') as csvfile: csvwriter = csv.writer(csvfile) csvwriter.writerow(fields) csvwriter.writerows(rows) 12345678910111213141516171819202122import pandas as pdfrom dicttoxml import dicttoxmlimport json# Building our dataframedata = &#123;'Name': ['Emily', 'Katie', 'John', 'Mike'], 'Goals': [12, 8, 16, 3], 'Assists': [18, 24, 9, 14], 'Shots': [112, 96, 101, 82] &#125;df = pd.DataFrame(data, columns=data.keys())# Converting the dataframe to a dictionary# Then save it to filedata_dict = df.to_dict(orient="records")with open('output.json', "w+") as f: json.dump(data_dict, f, indent=4)# Converting the dataframe to XML# Then save it to filexml_data = dicttoxml(data_dict).decode()with open("output.xml", "w+") as f: f.write(xml_data) 12345678910111213141516171819import jsonimport pandas as pd# Read the data from file# We now have a Python dictionarywith open('data.json') as f: data_listofdict = json.load(f) # We can do the same thing with pandasdata_df = pd.read_json('data.json', orient='records')# We can write a dictionary to JSON like so# Use 'indent' and 'sort_keys' to make the JSON# file look nicewith open('new_data.json', 'w+') as json_file: json.dump(data_listofdict, json_file, indent=4, sort_keys=True)# And again the same thing with pandasexport = data_df.to_json('new_data.json', orient='records') å¤„ç†windows å’Œlinux ä¸­æ–‡ä»¶åˆ†å‰²ç¬¦ä¸å…¼å®¹çš„æƒ…å†µ python ä¸­ open( mode =â€™rtâ€™) çš„é€‰é¡¹ï¼šw,r,wt,rtéƒ½æ˜¯pythoné‡Œé¢æ–‡ä»¶æ“ä½œçš„æ¨¡å¼ã€‚wæ˜¯å†™æ¨¡å¼ï¼Œræ˜¯è¯»æ¨¡å¼ã€‚tæ˜¯windowså¹³å°ç‰¹æœ‰çš„æ‰€è°“text mode(æ–‡æœ¬æ¨¡å¼ï¼‰,åŒºåˆ«åœ¨äºŽä¼šè‡ªåŠ¨è¯†åˆ«windowså¹³å°çš„æ¢è¡Œç¬¦ã€‚ç±»Unixå¹³å°çš„æ¢è¡Œç¬¦æ˜¯\nï¼Œè€Œwindowså¹³å°ç”¨çš„æ˜¯\r\nä¸¤ä¸ªASCIIå­—ç¬¦æ¥è¡¨ç¤ºæ¢è¡Œï¼Œpythonå†…éƒ¨é‡‡ç”¨çš„æ˜¯\næ¥è¡¨ç¤ºæ¢è¡Œç¬¦ã€‚rtæ¨¡å¼ä¸‹ï¼Œpythonåœ¨è¯»å–æ–‡æœ¬æ—¶ä¼šè‡ªåŠ¨æŠŠ\r\nè½¬æ¢æˆ\n.wtæ¨¡å¼ä¸‹ï¼ŒPythonå†™æ–‡ä»¶æ—¶ä¼šç”¨\r\næ¥è¡¨ç¤ºæ¢è¡Œã€‚ å‚è€ƒèµ„æ–™ï¼šhttps://towardsdatascience.com/the-easy-way-to-work-with-csv-json-and-xml-in-python-5056f9325ca9 è¾“å…¥å’Œè¾“å‡ºpython2 æœ‰ raw_input() å’Œ input() å‡½æ•°ï¼Œå‰è€…æŠŠæ‰€æœ‰çš„æŽ¥æ”¶å€¼å½“åšstringï¼Œå¦‚æžœæƒ³è¦ç”¨intï¼Œé‚£ä¹ˆéœ€è¦è‡ªå·±è¿›è¡Œè½¬æ¢ã€‚input() å¦‚æžœå¾—åˆ°intï¼Œé‚£ä¹ˆå°±æ˜¯intï¼Œstring ç±»åž‹å°±æ˜¯string ç±»åž‹ã€‚python3 ä¸­åªæœ‰input() å‡½æ•°ï¼Œæ‰€æœ‰çš„æŽ¥æ”¶éƒ½æ˜¯ stringï¼Œéœ€è¦è‡ªå·±è¿›è¡Œè½¬æ¢ã€‚ python3 ä¸­çš„input() å‡½æ•°å°±æ˜¯python2 ä¸­çš„raw_input() å‡½æ•°ã€‚ä¸‹é¢çš„ä»£ç ä½¿ç”¨ python3 å®žçŽ°ã€‚ 1234567891011121314151617181920212223242526272829if __name__ =="__main__": # è¾“å…¥è¾“å‡º n*n çš„arrar """ n =int(input()) arr =[[0]*n] *n # åœ¨python3 ä¸­éœ€è¦ exactly çš„æ³¨æ„è¿™ç§åˆ†å‰²ï¼Œè¾“å…¥çš„æ—¶å€™è¦åŠå…¶çš„å°å¿ƒ for i in range(n): arr[i] = input().split(" ") arr[i] =[int(a) for a in arr[i]] # è½¬æˆ int ç±»åž‹ print(arr) """ # è¾“å…¥å’Œè¾“å‡º n*m çš„æ•°ç»„ n =int(input()) m =int(input()) arr =[[0]*m]*n for i in range(n): arr[i] =input().split(" ") arr[i] =[int(a) for a in arr[i]] print(arr) å¤„ç†è¾“å…¥å’Œè¾“å‡ºé—®é¢˜ï¼Œå°±æ˜¯ä½¿ç”¨ python3 å¤„ç†ï¼Œç„¶åŽæ³¨é‡Šä½¿ç”¨ list(map(str, [])) å’Œ list(map(int, [])) è¿™ç§å¤„ç†æ‰‹æ®µã€‚æ¶¨æ¶¨è®°æ€§å§ 12345678910111213141516171819202122#python ä¸­ä¼ é€’çš„æ˜¯å€¼ è¿˜æ˜¯å¼•ç”¨def quick_sort(nums, l, r): if l&gt;= r: return left, right =l, r key =nums[l] while(l&lt;r): while(l &lt;r and nums[r] &gt;= key): r -=1 nums[l] =nums[r] while(l &lt;r and nums[l] &lt;= key): l +=1 nums[r] =nums[l] nums[l] =key quick_sort(nums, left, l -1) quick_sort(nums, l +1, right)if __name__ =="__main__": n =int(input()) nums =list(map(int, input().split())) quick_sort(nums, 0, len(nums)-1) #print(nums) print(" ".join(list(map(str, nums)))) é¢å‘å¯¹è±¡ (for python)è®¿é—®æŽ§åˆ¶æœ‰ä¸‰ç§çº§åˆ«ï¼šç§æœ‰ã€å—ä¿æŠ¤ã€å…¬æœ‰ã€‚ç§æœ‰ã€‚ï¼ˆPrivateï¼‰ï¼šåªæœ‰ç±»è‡ªèº«å¯ä»¥è®¿é—® å—ä¿æŠ¤ã€‚ï¼ˆProtectedï¼‰ï¼šåªæœ‰ç±»è‡ªèº«å’Œå­ç±»å¯ä»¥è®¿é—® å…¬æœ‰ã€‚ï¼ˆPublicï¼‰ï¼šä»»ä½•ç±»éƒ½å¯ä»¥è®¿é—®ã€‚ å…¬æœ‰ï¼ˆPublicï¼‰ åœ¨Pythonçš„ç±»ä¸­ï¼Œé»˜è®¤æƒ…å†µä¸‹å®šä¹‰çš„å±žæ€§éƒ½æ˜¯å…¬æœ‰çš„ã€‚ 12345678910class Foo(object): bar = 123 def __init__(self, bob): self.bob = bobprint(Foo.bar) # 123foo = Foo(456)print(foo.bob) # 456 ä¸Šé¢ç±»Fooä¸­çš„barå±žæ€§å°±æ˜¯ç±»å±žæ€§ï¼Œinitæ–¹æ³•ä¸­å®šä¹‰çš„bobæ˜¯å®žä¾‹å±žæ€§ï¼Œbarå’Œbobéƒ½æ˜¯å…¬æœ‰çš„å±žæ€§ï¼Œå¤–éƒ¨å¯ä»¥è®¿é—®ï¼Œåˆ†åˆ«printç±»ä¸­çš„barå’Œå®žä¾‹ä¸­çš„bobï¼Œè¾“å‡ºäº†å¯¹åº”çš„å€¼ã€‚ å—ä¿æŠ¤ï¼ˆProtectedï¼‰ åœ¨Pythonä¸­å®šä¹‰ä¸€ä¸ªå—ä¿æŠ¤çš„å±žæ€§ï¼Œåªéœ€è¦åœ¨å…¶åå­—å‰åŠ ä¸€ä¸ªä¸‹åˆ’çº¿_ï¼Œæˆ‘ä»¬å°†Fooæ–¹æ³•ä¸­çš„bobå’Œbaræ”¹ä¸º_bobå’Œ_barï¼Œä»–ä»¬å°±å˜æˆäº†å—ä¿æŠ¤çš„å±žæ€§äº†ï¼Œä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021class Foo(object): _bar = 123 def __init__(self, bob): self._bob = bobclass Son(Foo): def print_bob(self): print(self._bob) @classmethod def print_bar(cls): print(cls._bar)Son.print_bar() # 123son = Son(456)son.print_bob() # 456 å®šä¹‰ä¸€ä¸ªç±»Sonç»§æ‰¿è‡ªFooï¼Œç”±äºŽå—ä¿æŠ¤çš„å¯¹è±¡åªèƒ½åœ¨ç±»çš„å†…éƒ¨å’Œå­ç±»ä¸­è¢«è®¿é—®ï¼Œä¸èƒ½ç›´æŽ¥è°ƒç”¨print(Son._bar)æˆ–print(son._bob)æ¥è¾“å‡ºè¿™ä¸¤ä¸ªå±žæ€§çš„å€¼ï¼Œæ‰€ä»¥å®šä¹‰äº†print_barå’Œprint_bobæ–¹æ³•ï¼Œå®žçŽ°åœ¨å­ç±»ä¸­è¾“å‡ºï¼Œè¿™æ®µä»£ç ä¹Ÿæ­£å¸¸çš„è¾“å‡ºäº†_barå’Œ_bobçš„å€¼ã€‚ 1234print(Son._bar) # 123son = Son(456)print(son._bob) # 456 ï¼ˆå‡è£…ï¼‰æƒŠè®¶çš„å‘çŽ°ï¼Œç«Ÿç„¶æ²¡æœ‰æŠ¥é”™ï¼Œä¹Ÿè¾“å‡ºäº†æ­£ç¡®çš„å€¼ã€‚ Pythonä¸­ç”¨åŠ ä¸‹åˆ’çº¿æ¥å®šä¹‰å—ä¿æŠ¤å˜é‡ï¼Œæ˜¯ä¸€ç§çº¦å®šçš„è§„èŒƒï¼Œè€Œä¸æ˜¯è¯­è¨€å±‚é¢çœŸçš„å®žçŽ°äº†è®¿é—®æŽ§åˆ¶ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬å®šä¹‰çš„ä¿æŠ¤å˜é‡ï¼Œä¾ç„¶å¯ä»¥åœ¨å¤–éƒ¨è¢«è®¿é—®åˆ°ï¼ˆè¿™æ˜¯ä¸ªfeatureï¼Œä¸æ˜¯bugï¼‰ã€‚ ç§æœ‰ï¼ˆprivateï¼‰ Pythonå®šä¹‰ç§æœ‰å±žæ€§ï¼Œéœ€è¦åœ¨å±žæ€§åå‰åŠ ä¸¤ä¸ªä¸‹åˆ’çº¿__ï¼ŒæŠŠä¸Šé¢çš„ä»£ç ä¿®æ”¹ä¸€ä¸‹ï¼Œè¿è¡Œä¸€ä¸‹ä¼šå‘çŽ°ä¸‹é¢çš„ä»£ç ä¸­çš„ä»»ä½•ä¸€ä¸ªprintéƒ½ä¼šæŠ¥é”™çš„ã€‚ 123456789101112131415161718192021class Foo(object): __bar = 123 def __init__(self, bob): self.__bob = bobclass Son(Foo): def print_bob(self): print(self.__bob) # Error @classmethod def print_bar(cls): print(cls.__bar) # Errorprint(Son.__bar) # Errorson = Son(456)print(son._bob) # Error æ·±å…¥ä¸€ä¸‹â€”â€”ç§æœ‰å±žæ€§çœŸçš„å°±è®¿é—®ä¸åˆ°äº†å—ï¼Ÿ è¦äº†è§£ç§æœ‰å±žæ€§æ˜¯å¦çœŸçš„è®¿é—®ä¸åˆ°ï¼Œéœ€è¦ä»ŽPythonæ˜¯å¦‚ä½•å®žçŽ°ç§æœ‰å±žæ€§å…¥æ‰‹ã€‚CPythonä¸­ï¼Œä¼šæŠŠåŒä¸‹åˆ’çº¿çš„å±žæ€§å˜ä¸º_ClassName__PropertyNameçš„å½¢å¼ï¼Œç”¨ä»£ç æ¼”ç¤ºä¸€ä¸‹ï¼š 1234class Foo(object): __bar = 123print(Foo._Foo__bar) # 123 å†æ¯”å¦‚ 12345class F: __name = "xurui"f = F()result = f._F__name ##é€šè¿‡è¿™ä¸ªæ–¹å¼å¯ä»¥ä»Žå¤–éƒ¨è®¿é—®...print(result) è¿è¡Œä¸€ä¸‹å¯ä»¥çŸ¥é“ï¼Œæ­£å¸¸è¾“å‡ºäº†__barçš„å€¼ï¼Œä½†æ˜¯ä¸æŽ¨èè¿™æ ·åŽ»è®¿é—®ç§æœ‰å±žæ€§ï¼Œå› ä¸ºä¸åŒçš„Pythonè§£é‡Šå™¨å¯¹äºŽç§æœ‰å±žæ€§çš„å¤„ç†ä¸ä¸€æ ·ã€‚ ç‰¹ä¾‹ ä½¿ç”¨åŒä¸‹åˆ’çº¿å®šä¹‰ç§æœ‰å±žæ€§ï¼Œæœ‰ä¸€ç§ç‰¹æ®Šæƒ…å†µï¼Œå½“å±žæ€§åŽä¹Ÿæœ‰ä¸¤ä¸ªä¸‹åˆ’çº¿çš„æ—¶å€™ï¼Œè¿™ä¸ªå±žæ€§ä¼šè¢«Pythonè§£é‡Šå™¨å½“åšé­”æœ¯æ–¹æ³•ï¼Œä»Žè€Œä¸åšç§æœ‰å¤„ç†ã€‚ 12345class Foo(object): __bar__ = 123print(Foo.__bar__) # 123 ä¸Šé¢ä»£ç è¾“å‡ºäº†123ï¼Œè¯æ˜ŽPythonè§£é‡Šå™¨å¹¶æ²¡æœ‰æŠŠbarå½“åšç§æœ‰å±žæ€§ã€‚å½“å®šä¹‰ç§æœ‰å±žæ€§æ—¶ï¼Œéœ€è¦æ³¨æ„åå­—æœ€åŽæœ€å¤šåªèƒ½æœ‰ä¸€ä¸ªä¸‹åˆ’çº¿ã€‚ å‡å¦‚å®šä¹‰çš„å±žæ€§åå°±å«__å‘¢ï¼Ÿä¸å¦¨ç›´æŽ¥è¯•ä¸€ä¸‹ï¼š 123class Foo(object): __ = 123print(Foo.__) # 123 å¯ä»¥å‘çŽ°åå­—å«çš„å±žæ€§ä¹Ÿä¸ä¼šè¢«è®¤ä¸ºæ˜¯ç§æœ‰å±žæ€§ï¼Œåå­—æ˜¯å¤šä¸ªä¸‹åˆ’çº¿çš„å±žæ€§ä¹Ÿä¸æ˜¯ç§æœ‰å±žæ€§ï¼ˆæ¯”å¦‚_ï¼‰ã€‚ 12345678910class ProtectMe(object): def __init__(self): self.me = "wxx" self.__name = "zixin" @property def name(self): return self.__namep = ProtectMe()print p.name ä¸Žé¢è¯•å®˜è°ˆç¬‘é£Žç”Ÿ | Pythoné¢å‘å¯¹è±¡ä¹‹è®¿é—®æŽ§åˆ¶ ç±»classçš„è®¿é—®æŽ§åˆ¶ ï¼ˆè¿™ä¸ªå®žé™…ä¸Šä½“çŽ°çš„æ˜¯å°è£…çš„æ€æƒ³ï¼‰ Pythonä¸­æ²¡æœ‰è®¿é—®æŽ§åˆ¶çš„å…³é”®å­—ï¼Œä¾‹å¦‚privateã€protectedç­‰ç­‰ã€‚ä½†æ˜¯ï¼Œåœ¨Pythonç¼–ç ä¸­ï¼Œæœ‰ä¸€äº›çº¦å®šæ¥è¿›è¡Œè®¿é—®æŽ§åˆ¶ã€‚Pythonä¸­æ²¡æœ‰çœŸæ­£çš„ç§æœ‰å±žæ€§æˆ–æ–¹æ³•,å¯ä»¥åœ¨ä½ æƒ³å£°æ˜Žä¸ºç§æœ‰çš„æ–¹æ³•å’Œå±žæ€§å‰åŠ ä¸Šå•ä¸‹åˆ’çº¿,ä»¥æç¤ºè¯¥å±žæ€§å’Œæ–¹æ³•ä¸åº”åœ¨å¤–éƒ¨è°ƒç”¨.å¦‚æžœçœŸçš„è°ƒç”¨äº†ä¹Ÿä¸ä¼šå‡ºé”™,ä½†ä¸ç¬¦åˆè§„èŒƒ. xxï¼š å…±æœ‰å˜é‡ å•ä¸‹åˆ’çº¿ â€œ_â€ å‰ç½®å•ä¸‹åˆ’çº¿ï¼Œç§æœ‰åŒ–å±žæ€§æˆ–æ–¹æ³•ï¼Œä¸€èˆ¬æ¥è®²ï¼Œå˜é‡å_xxè¢«çœ‹ä½œæ˜¯â€œç§æœ‰ çš„â€ï¼Œåœ¨æ¨¡å—æˆ–ç±»å¤–ä¸å¯ä»¥ä½¿ç”¨ã€‚å½“å˜é‡æ˜¯ç§æœ‰çš„æ—¶å€™ï¼Œç”¨_xx æ¥è¡¨ç¤ºå˜é‡æ˜¯å¾ˆå¥½çš„ä¹ æƒ¯ã€‚ç±»å¯¹è±¡å’Œå­ç±»å¯ä»¥è®¿é—®,è¿™å¹¶ä¸èƒ½å®Œå…¨åšåˆ°çœŸæ­£çš„ç§æœ‰ï¼Œåªæ˜¯çº¦å®šä¿—æˆçš„è€Œå·²ï¼Œè¿™æ ·å†™è¡¨ç¤ºä¸å¸Œæœ›è¿™ä¸ªå˜é‡åœ¨å¤–éƒ¨è¢«ç›´æŽ¥è°ƒç”¨ã€‚ åŒä¸‹åˆ’çº¿â€__â€ å‰ç½®åŒä¸‹åˆ’çº¿ï¼Œç§æœ‰åŒ–å±žæ€§æˆ–æ–¹æ³•ï¼Œæ— æ³•åœ¨å¤–éƒ¨ç›´æŽ¥è®¿é—®ï¼ˆåå­—é‡æ•´æ‰€ä»¥è®¿é—®ä¸åˆ°,åªèƒ½æ˜¯å…è®¸è¿™ä¸ªç±»æœ¬èº«è¿›è¡Œè®¿é—®äº†ã€‚è¿žå­ç±»ä¹Ÿä¸å¯ä»¥ï¼‰ xx_ï¼šåŽç½®å•ä¸‹åˆ’çº¿ï¼Œç”¨äºŽé¿å…ä¸ŽPythonå…³é”®è¯çš„å†²çªï¼ˆè¿™ç§çº¦å®šä¿—ç§°çš„ä¸œè¥¿å¾ˆå¥½ï¼Œä¸€å®šè¦æŒ‰ç…§è¿™ç§è§„èŒƒåŽ»åšï¼‰ å•ä¸‹åˆ’çº¿ã€åŒä¸‹åˆ’çº¿ã€å¤´å°¾åŒä¸‹åˆ’çº¿è¯´æ˜Žï¼š 12345__foo__: å®šä¹‰çš„æ˜¯ç‰¹æ®Šæ–¹æ³•ï¼Œä¸€èˆ¬æ˜¯ç³»ç»Ÿå®šä¹‰åå­— ï¼Œç±»ä¼¼ __init__() ä¹‹ç±»çš„ã€‚_foo: ä»¥å•ä¸‹åˆ’çº¿å¼€å¤´çš„è¡¨ç¤ºçš„æ˜¯ protected ç±»åž‹çš„å˜é‡ï¼Œå³ä¿æŠ¤ç±»åž‹åªèƒ½å…è®¸å…¶æœ¬èº«ä¸Žå­ç±»è¿›è¡Œè®¿é—®ï¼Œä¸èƒ½ç”¨äºŽ from module import *__foo: åŒä¸‹åˆ’çº¿çš„è¡¨ç¤ºçš„æ˜¯ç§æœ‰ç±»åž‹(private)çš„å˜é‡, åªèƒ½æ˜¯å…è®¸è¿™ä¸ªç±»æœ¬èº«è¿›è¡Œè®¿é—®äº†ã€‚ è¿™ç§å‘½åæ–¹å¼åŒæ ·æ˜¯é€‚ç”¨æ–¹æ³•çš„å‘½åã€‚ python ä¸­ä¹Ÿæ˜¯ä¸€æ ·çš„ï¼Œé‡è½½æ˜¯ç±»æœ¬èº«å°±æœ‰çš„æ–¹æ³•ï¼Œé‡å†™æ˜¯å­ç±»é’ˆå¯¹çˆ¶ç±»å‡½æ•°çš„é‡å†™ã€‚ 12345678910111213141516class Site: def __init__(self, name, url): self.name = name # public self.__url = url # private # è¿™ä¸ªæ˜¯ç³»ç»Ÿçš„æ–¹æ³• def who(self): print('name : ', self.name) print('url : ', self.__url) def __foo(self): # ç§æœ‰æ–¹æ³• print('è¿™æ˜¯ç§æœ‰æ–¹æ³•') def foo(self): # å…¬å…±æ–¹æ³• print('è¿™æ˜¯å…¬å…±æ–¹æ³•') self.__foo() ç»§æ‰¿ Python3çš„ç»§æ‰¿æœºåˆ¶ä¸åŒäºŽPython2ã€‚å…¶æ ¸å¿ƒåŽŸåˆ™æ˜¯ä¸‹é¢ä¸¤æ¡ï¼Œè¯·è°¨è®°ï¼ å­ç±»åœ¨è°ƒç”¨æŸä¸ªæ–¹æ³•æˆ–å˜é‡çš„æ—¶å€™ï¼Œé¦–å…ˆåœ¨è‡ªå·±å†…éƒ¨æŸ¥æ‰¾ï¼Œå¦‚æžœæ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ™å¼€å§‹æ ¹æ®ç»§æ‰¿æœºåˆ¶åœ¨çˆ¶ç±»é‡ŒæŸ¥æ‰¾ã€‚ æ ¹æ®çˆ¶ç±»å®šä¹‰ä¸­çš„é¡ºåºï¼Œä»¥æ·±åº¦ä¼˜å…ˆçš„æ–¹å¼é€ä¸€æŸ¥æ‰¾çˆ¶ç±»ï¼ ç»§æ‰¿å‚æ•°çš„ä¹¦å†™æœ‰å…ˆåŽé¡ºåºï¼Œå†™åœ¨å‰é¢çš„è¢«ä¼˜å…ˆç»§æ‰¿ã€‚ super() å‡½æ•° æˆ‘ä»¬éƒ½çŸ¥é“ï¼Œåœ¨å­ç±»ä¸­å¦‚æžœæœ‰ä¸Žçˆ¶ç±»åŒåçš„æˆå‘˜ï¼Œé‚£å°±ä¼šè¦†ç›–æŽ‰çˆ¶ç±»é‡Œçš„æˆå‘˜ã€‚é‚£å¦‚æžœä½ æƒ³å¼ºåˆ¶è°ƒç”¨çˆ¶ç±»çš„æˆå‘˜å‘¢ï¼Ÿä½¿ç”¨super()å‡½æ•°ï¼è¿™æ˜¯ä¸€ä¸ªéžå¸¸é‡è¦çš„å‡½æ•°ï¼Œæœ€å¸¸è§çš„å°±æ˜¯é€šè¿‡superè°ƒç”¨çˆ¶ç±»çš„å®žä¾‹åŒ–æ–¹æ³•initï¼ 1234567891011121314151617class A: def __init__(self, name): self.name = name print("çˆ¶ç±»çš„__init__æ–¹æ³•è¢«æ‰§è¡Œäº†ï¼") def show(self): print("çˆ¶ç±»çš„showæ–¹æ³•è¢«æ‰§è¡Œäº†ï¼")class B(A): def __init__(self, name, age): super(B, self).__init__(name=name) self.age = age def show(self): super(B, self).show()obj = B("jack", 18)obj.show() ç»§æ‰¿å¯ä»¥æŠŠçˆ¶ç±»çš„æ‰€æœ‰åŠŸèƒ½éƒ½ç›´æŽ¥æ‹¿è¿‡æ¥ï¼Œè¿™æ ·å°±ä¸å¿…é‡é›¶åšèµ·ï¼Œå­ç±»åªéœ€è¦æ–°å¢žè‡ªå·±ç‰¹æœ‰çš„æ–¹æ³•ï¼Œä¹Ÿå¯ä»¥æŠŠçˆ¶ç±»ä¸é€‚åˆçš„æ–¹æ³•è¦†ç›–é‡å†™ã€‚ å¤šæ€ 1234567891011121314151617181920212223242526272829303132333435class Animal: def kind(self): print("i am animal") class Dog(Animal): def kind(self): print("i am a dog") class Cat(Animal): def kind(self): print("i am a cat")class Pig(Animal): def kind(self): print("i am a pig")# è¿™ä¸ªå‡½æ•°æŽ¥æ”¶ä¸€ä¸ªanimalå‚æ•°ï¼Œå¹¶è°ƒç”¨å®ƒçš„kindæ–¹æ³•def show_kind(animal): animal.kind()d = Dog()c = Cat()p = Pig()show_kind(d)show_kind(c)show_kind(p)------------------æ‰“å°ç»“æžœï¼ši am a dogi am a cati am a pig å¤šæ€çš„æ€æƒ³ï¼Œä½¿ç”¨ä¸€ä¸ªæŒ‡é’ˆï¼ˆå˜é‡ï¼‰å¯ä»¥æ ¹æ®ä½ç½®æŒ‡å‘ä¸åŒçš„å­ç±»ã€‚ python ä¸­çš„ä¸‰ç±»æ–¹æ³•ä¸€èˆ¬ä½¿ç”¨å®žä¾‹æ–¹æ³•æœ€å¤šï¼Œéœ€è¦æœ‰ self ä½œä¸ºä¸€ä¸ªä¼ å…¥å‚æ•°ï¼Œåœ¨å­ç±»ä¸­å¯ä»¥ä½¿ç”¨è¯¥æ–¹æ³•ã€‚ ç±»æ–¹æ³•ä½¿ç”¨ä¿®é¥°å™¨ @classmethod ï¼›é™æ€æ–¹æ³•ä½¿ç”¨ä¿®é¥°å™¨ @staticmethodï¼Œå¯¹äºŽé™æ€æ–¹æ³•ï¼Œè°ƒç”¨æ—¶å¹¶ä¸éœ€è¦ä¼ é€’ç±»æˆ–è€…å®žä¾‹ã€‚å…¶å®žï¼Œé™æ€æ–¹æ³•å¾ˆåƒæˆ‘ä»¬åœ¨ç±»å¤–å®šä¹‰çš„å‡½æ•°ï¼Œåªä¸è¿‡é™æ€æ–¹æ³•å¯ä»¥é€šè¿‡ç±»æˆ–è€…å®žä¾‹æ¥è°ƒç”¨è€Œå·²ã€‚ å®žä¾‹æ–¹æ³•åªèƒ½è¢«å®žä¾‹å¯¹è±¡è°ƒç”¨ï¼Œé™æ€æ–¹æ³•(ç”±@staticmethodè£…é¥°çš„æ–¹æ³•)ã€ç±»æ–¹æ³•(ç”±@classmethodè£…é¥°çš„æ–¹æ³•)ï¼Œå¯ä»¥è¢«ç±»æˆ–ç±»çš„å®žä¾‹å¯¹è±¡è°ƒç”¨ã€‚ å®žä¾‹æ–¹æ³•ï¼Œç¬¬ä¸€ä¸ªå‚æ•°å¿…é¡»è¦é»˜è®¤ä¼ å®žä¾‹å¯¹è±¡ï¼Œä¸€èˆ¬ä¹ æƒ¯ç”¨selfã€‚é™æ€æ–¹æ³•ï¼Œå‚æ•°æ²¡æœ‰è¦æ±‚ã€‚ç±»æ–¹æ³•ï¼Œç¬¬ä¸€ä¸ªå‚æ•°å¿…é¡»è¦é»˜è®¤ä¼ ç±»ï¼Œä¸€èˆ¬ä¹ æƒ¯ç”¨clsã€‚ 1234567891011121314151617181920212223242526class Kls(object): def foo(self, x): print('executing foo(%s,%s)' % (self, x)) @classmethod def class_foo(cls,x): print('executing class_foo(%s,%s)' % (cls,x)) @staticmethod def static_foo(x): print('executing static_foo(%s)' % x)ik = Kls()# å®žä¾‹æ–¹æ³•ik.foo(1)print(ik.foo)print('==========================================')# ç±»æ–¹æ³•ik.class_foo(1)Kls.class_foo(1)print(ik.class_foo)print('==========================================')# é™æ€æ–¹æ³•ik.static_foo(1)Kls.static_foo('hi')print(ik.static_foo) ç±»æ–¹æ³•Python æä¾›äº† classmethod è£…é¥°å™¨è®©æˆ‘ä»¬å®žçŽ°ä¸Šè¿°åŠŸèƒ½ï¼Œçœ‹ä¸‹é¢çš„ä¾‹å­ï¼š 12345678910class A(object): bar = 1 @classmethod def class_foo(cls): print 'Hello, ', cls print cls.bar&gt;&gt;&gt; A.class_foo() # ç›´æŽ¥é€šè¿‡ç±»æ¥è°ƒç”¨æ–¹æ³•Hello, &lt;class '__main__.A'&gt;1 åœ¨ä¸Šé¢ï¼Œæˆ‘ä»¬ä½¿ç”¨äº† classmethod è£…é¥°æ–¹æ³• class_fooï¼Œå®ƒå°±å˜æˆäº†ä¸€ä¸ªç±»æ–¹æ³•ï¼Œclass_foo çš„å‚æ•°æ˜¯ clsï¼Œä»£è¡¨ç±»æœ¬èº«ï¼Œå½“æˆ‘ä»¬ä½¿ç”¨ A.class_foo() æ—¶ï¼Œcls å°±ä¼šæŽ¥æ”¶ A ä½œä¸ºå‚æ•°ã€‚å¦å¤–ï¼Œè¢« classmethod è£…é¥°çš„æ–¹æ³•ç”±äºŽæŒæœ‰ cls å‚æ•°ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åœ¨æ–¹æ³•é‡Œé¢è°ƒç”¨ç±»çš„å±žæ€§ã€æ–¹æ³•ï¼Œæ¯”å¦‚ cls.barã€‚ é™æ€æ–¹æ³• åœ¨ç±»ä¸­å¾€å¾€æœ‰ä¸€äº›æ–¹æ³•è·Ÿç±»æœ‰å…³ç³»ï¼Œä½†æ˜¯åˆä¸ä¼šæ”¹å˜ç±»å’Œå®žä¾‹çŠ¶æ€çš„æ–¹æ³•ï¼Œè¿™ç§æ–¹æ³•æ˜¯é™æ€æ–¹æ³•ï¼Œæˆ‘ä»¬ä½¿ç”¨ staticmethod æ¥è£…é¥°ï¼Œæ¯”å¦‚ä¸‹é¢çš„ä¾‹å­ï¼š 1234567891011class A(object): bar = 1 @staticmethod def static_foo(): print &apos;Hello, &apos;, A.bar&gt;&gt;&gt; a = A()&gt;&gt;&gt; a.static_foo()Hello, 1&gt;&gt;&gt; A.static_foo()Hello, 1 å¯ä»¥çœ‹åˆ°ï¼Œé™æ€æ–¹æ³•æ²¡æœ‰ self å’Œ cls å‚æ•°ï¼Œå¯ä»¥æŠŠå®ƒçœ‹æˆæ˜¯ä¸€ä¸ªæ™®é€šçš„å‡½æ•°ï¼Œæˆ‘ä»¬å½“ç„¶å¯ä»¥æŠŠå®ƒå†™åˆ°ç±»å¤–é¢ï¼Œä½†è¿™æ˜¯ä¸æŽ¨èçš„ï¼Œå› ä¸ºè¿™ä¸åˆ©äºŽä»£ç çš„ç»„ç»‡å’Œå‘½åç©ºé—´çš„æ•´æ´ã€‚ python ä¸­çš„å•ä¾‹/ å¤šä¾‹æ¨¡å¼ å®šä¹‰ å•ä¾‹æ¨¡å¼(Singleton Pattern)ï¼šå•ä¾‹æ¨¡å¼ç¡®ä¿æŸä¸€ä¸ªç±»åªæœ‰ä¸€ä¸ªå®žä¾‹ï¼Œè€Œä¸”è‡ªè¡Œå®žä¾‹åŒ–å¹¶å‘æ•´ä¸ªç³»ç»Ÿæä¾›è¿™ä¸ªå®žä¾‹ï¼Œè¿™ä¸ªç±»ç§°ä¸ºå•ä¾‹ç±»ï¼Œå®ƒæä¾›å…¨å±€è®¿é—®çš„æ–¹æ³•ã€‚å•ä¾‹æ¨¡å¼çš„è¦ç‚¹æœ‰ä¸‰ä¸ªï¼šä¸€æ˜¯æŸä¸ªç±»åªèƒ½æœ‰ä¸€ä¸ªå®žä¾‹ï¼›äºŒæ˜¯å®ƒå¿…é¡»è‡ªè¡Œåˆ›å»ºè¿™ä¸ªå®žä¾‹ï¼›ä¸‰æ˜¯å®ƒå¿…é¡»è‡ªè¡Œå‘æ•´ä¸ªç³»ç»Ÿæä¾›è¿™ä¸ªå®žä¾‹ã€‚å•ä¾‹æ¨¡å¼æ˜¯ä¸€ç§å¯¹è±¡åˆ›å»ºåž‹æ¨¡å¼ã€‚å•ä¾‹æ¨¡å¼åˆåå•ä»¶æ¨¡å¼æˆ–å•æ€æ¨¡å¼ã€‚ å•ä¾‹æ¨¡å¼çš„åˆ†ç±» æ‡’æ±‰ç‰ˆï¼ˆLazy Singletonï¼‰ï¼šå•ä¾‹å®žä¾‹åœ¨ç¬¬ä¸€æ¬¡è¢«ä½¿ç”¨æ—¶æ‰è¿›è¡Œåˆå§‹åŒ–ï¼Œè¿™å«åšå»¶è¿Ÿåˆå§‹åŒ–ã€‚ Lazy Singletonå­˜åœ¨å†…å­˜æ³„éœ²çš„é—®é¢˜ï¼Œæœ‰ä¸¤ç§è§£å†³æ–¹æ³•ï¼š ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ ä½¿ç”¨é™æ€çš„åµŒå¥—ç±»å¯¹è±¡ é¥¿æ±‰ç‰ˆï¼ˆEager Singletonï¼‰ï¼šæŒ‡å•ä¾‹å®žä¾‹åœ¨ç¨‹åºè¿è¡Œæ—¶è¢«ç«‹å³æ‰§è¡Œåˆå§‹åŒ–ã€‚ç”±äºŽåœ¨mainå‡½æ•°ä¹‹å‰åˆå§‹åŒ–ï¼Œæ‰€ä»¥æ²¡æœ‰çº¿ç¨‹å®‰å…¨çš„é—®é¢˜ã€‚ ä¸¤ç§åˆ†ç±»çš„æ€»ç»“ï¼šEager Singleton è™½ç„¶æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œä½†å­˜åœ¨æ½œåœ¨é—®é¢˜ï¼›Lazy Singletoné€šå¸¸éœ€è¦åŠ é”æ¥ä¿è¯çº¿ç¨‹å®‰å…¨ï¼Œä½†å±€éƒ¨é™æ€å˜é‡ç‰ˆæœ¬åœ¨C++11åŽæ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼›å±€éƒ¨é™æ€å˜é‡ç‰ˆæœ¬ï¼ˆMeyers Singletonï¼‰æœ€ä¼˜é›…ã€‚ ä»€ä¹ˆæƒ…å†µä¸‹ä½¿ç”¨å•ä¾‹æ¨¡å¼ ç³»ç»Ÿåªéœ€è¦ä¸€ä¸ªå®žä¾‹å¯¹è±¡ï¼Œå¦‚ç³»ç»Ÿè¦æ±‚æä¾›ä¸€ä¸ªå”¯ä¸€çš„åºåˆ—å·ç”Ÿæˆå™¨ï¼Œæˆ–è€…éœ€è¦è€ƒè™‘èµ„æºæ¶ˆè€—å¤ªå¤§è€Œåªå…è®¸åˆ›å»ºä¸€ä¸ªå¯¹è±¡ã€‚ å®¢æˆ·è°ƒç”¨ç±»çš„å•ä¸ªå®žä¾‹åªå…è®¸ä½¿ç”¨ä¸€ä¸ªå…¬å…±è®¿é—®ç‚¹ï¼Œé™¤äº†è¯¥å…¬å…±è®¿é—®ç‚¹ï¼Œä¸èƒ½é€šè¿‡å…¶ä»–é€”å¾„è®¿é—®è¯¥å®žä¾‹ã€‚ å°çš„ä¾‹å­ï¼šæŸä¸ªæœåŠ¡å™¨ç¨‹åºçš„é…ç½®ä¿¡æ¯å­˜æ”¾åœ¨ä¸€ä¸ªæ–‡ä»¶ä¸­ï¼Œå®¢æˆ·ç«¯é€šè¿‡ä¸€ä¸ª AppConfig çš„ç±»æ¥è¯»å–é…ç½®æ–‡ä»¶çš„ä¿¡æ¯ã€‚å¦‚æžœåœ¨ç¨‹åºè¿è¡ŒæœŸé—´ï¼Œæœ‰å¾ˆå¤šåœ°æ–¹éƒ½éœ€è¦ä½¿ç”¨é…ç½®æ–‡ä»¶çš„å†…å®¹ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¾ˆå¤šåœ°æ–¹éƒ½éœ€è¦åˆ›å»º AppConfig å¯¹è±¡çš„å®žä¾‹ï¼Œè¿™å°±å¯¼è‡´ç³»ç»Ÿä¸­å­˜åœ¨å¤šä¸ª AppConfig çš„å®žä¾‹å¯¹è±¡ï¼Œè€Œè¿™æ ·ä¼šä¸¥é‡æµªè´¹å†…å­˜èµ„æºï¼Œå°¤å…¶æ˜¯åœ¨é…ç½®æ–‡ä»¶å†…å®¹å¾ˆå¤šçš„æƒ…å†µä¸‹ã€‚äº‹å®žä¸Šï¼Œç±»ä¼¼ AppConfig è¿™æ ·çš„ç±»ï¼Œæˆ‘ä»¬å¸Œæœ›åœ¨ç¨‹åºè¿è¡ŒæœŸé—´åªå­˜åœ¨ä¸€ä¸ªå®žä¾‹å¯¹è±¡ã€‚ python ä¸­çš„å®žçŽ° æœ‰ä»¥ä¸‹å››ç§æ–¹å¼å®žçŽ°ï¼š1234ä½¿ç”¨æ¨¡å—ä½¿ç”¨ __new__ä½¿ç”¨è£…é¥°å™¨ï¼ˆdecoratorï¼‰ä½¿ç”¨å…ƒç±»ï¼ˆmetaclassï¼‰ ä½¿ç”¨æ¨¡å— å…¶å®žï¼ŒPython çš„æ¨¡å—å°±æ˜¯å¤©ç„¶çš„å•ä¾‹æ¨¡å¼ï¼Œå› ä¸ºæ¨¡å—åœ¨ç¬¬ä¸€æ¬¡å¯¼å…¥æ—¶ï¼Œä¼šç”Ÿæˆ .pyc æ–‡ä»¶ï¼Œå½“ç¬¬äºŒæ¬¡å¯¼å…¥æ—¶ï¼Œå°±ä¼šç›´æŽ¥åŠ è½½ .pyc æ–‡ä»¶ï¼Œè€Œä¸ä¼šå†æ¬¡æ‰§è¡Œæ¨¡å—ä»£ç ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åªéœ€æŠŠç›¸å…³çš„å‡½æ•°å’Œæ•°æ®å®šä¹‰åœ¨ä¸€ä¸ªæ¨¡å—ä¸­ï¼Œå°±å¯ä»¥èŽ·å¾—ä¸€ä¸ªå•ä¾‹å¯¹è±¡äº†ã€‚å¦‚æžœæˆ‘ä»¬çœŸçš„æƒ³è¦ä¸€ä¸ªå•ä¾‹ç±»ï¼Œå¯ä»¥è€ƒè™‘è¿™æ ·åšï¼š 12345# mysingleton.pyclass My_Singleton(object): def foo(self): passmy_singleton = My_Singleton() ä½¿ç”¨new å…³é”®å­—, å¦‚æžœå·²ç»æœ‰æœ‰äº†è¯¥å®žä¾‹ï¼Œé‚£ä¹ˆå°±ä¸ç”¨ç”Ÿæˆäº† 12345678class Singleton(object): _instance = None def __new__(cls, *args, **kw): if not cls._instance: cls._instance = super(Singleton, cls).__new__(cls, *args, **kw) return cls._instance class MyClass(Singleton): a = 1 ä½¿ç”¨ä¿®é¥°å™¨123456789101112from functools import wrapsdef singleton(cls): instances = &#123;&#125; @wraps(cls) def getinstance(*args, **kw): if cls not in instances: instances[cls] = cls(*args, **kw) return instances[cls] return getinstance@singletonclass MyClass(object): a = 1 pythonä¸­çš„å•ä¾‹æ¨¡å¼ æ•°æ®å¤„ç†å‡½æ•°è¯»å– çŸ©é˜µæ–‡ä»¶ 12345678910111213141516171819202122232425262728293031#ç¬¬ä¸€ç§æ–¹æ³• python è¯»å–çŸ©é˜µæ–‡ä»¶# å•ç²¾åº¦æ˜¯32 ä½ï¼ŒåŒç²¾åº¦æ˜¯64ä½def read_file(file1): f =open(file1) matrix=[] while True: line =f.readline() if not line: break line=line.strip() line =line.split(",") line =map(float, line) # è¿™é‡Œè½¬åŒ–æˆfloat å°±æ˜¯okçš„ matrix.append(line) f.close() # matrix =numpy.array(matrix) return matrix# ç¬¬äºŒç§æ–¹æ³• åŸºäºŽnumpy çš„å®žçŽ°path ="text.txt"matrix =numpy.loadtxt(path)b =numpy.reshape(matrix,(100, 2) )b =numpy.reshape(matrix, (-1, 3, 2)) shuffle å‡½æ•° åªè¦æ˜¯æ‰“æ•£ï¼Œéƒ½æ˜¯ä¼šç”¨åˆ° shuffle() è¿™æ ·çš„ä¸€ä¸ªå‡½æ•°ã€‚ 123456789101112# çº¯python å®žçŽ°index= [i for i in range(len(train_x))]random.shuffle(index)train_x =train_x[index]train_y =train_y[index]# åŸºäºŽ numpy å®žçŽ°def shuffle_data(data): np.random.shuffle(data) return data æŒ‰ç…§æ–‡ä»¶åè¿›è¡ŒæŽ’åº è¿™ä¸ªæ˜¯æŒ‰ç…§å­—å…¸åºæŽ’åºçš„ã€‚ 1234567891011import numpy as npimport os img_path='./img/' img_list=sorted(os.listdir(img_path)) #æ–‡ä»¶åæŒ‰å­—æ¯æŽ’åºimg_nums=len(img_list)for i in range(img_nums): img_name=img_path+img_list[i] print(img_name) æ³¨æ„ä¸‹é¢çš„æ˜¯æŒ‰ç…§æ•°å­—è¿›è¡ŒæŽ’åºçš„ï¼Œä¹Ÿå°±æ˜¯æ–‡ä»¶åã€‚è¿™ç§æ–¹æ³•æ›´åŠ ä½¿ç”¨ï¼Œæ³¨æ„åœ¨å®žçŽ°çš„æ—¶å€™ï¼Œå°† string è½¬æ¢æˆäº†int ç±»åž‹ã€‚ 1234567891011import numpy as npimport osimg_path='./img/' img_list=os.listdir(img_path)img_list.sort()img_list.sort(key = lambda x: int(x[:-4])) ##æ–‡ä»¶åæŒ‰æ•°å­—æŽ’åºimg_nums=len(img_list)for i in range(img_nums): img_name=img_path+img_list[i] print(img_name) åº“å‡½æ•° heapqåœ¨python ä¸­é»˜è®¤çš„æ˜¯ä¸€ä¸ªå°æ ¹å †ï¼ˆåœ¨c++ ä¸­é»˜è®¤çš„æ˜¯ä¸€ä¸ªå¤§æ ¹å †ï¼‰ 1234567heapq.heappush(heap, item) æŠŠitemæ·»åŠ åˆ°heapä¸­ï¼ˆheapæ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼‰heapq.heappop(heap) æŠŠå †é¡¶å…ƒç´ å¼¹å‡ºï¼Œè¿”å›žçš„å°±æ˜¯å †é¡¶heapq.heappushpop(heap, item) å…ˆæŠŠitemåŠ å…¥åˆ°å †ä¸­ï¼Œç„¶åŽå†popï¼Œæ¯”heappush()å†heappop()è¦å¿«å¾—å¤š# è¿™æ¯”è¾ƒå¥½ç”¨ï¼Œä¸ç”¨è‡ªå·±ç»´æŠ¤ pushpop æ“ä½œheapq.nlargest(n, iterable, key=None) è¿”å›žæœ€å¤§çš„nä¸ªå…ƒç´ ï¼ˆTop-Ké—®é¢˜ï¼‰heapq.nsmallest(n, iterable, key=None) è¿”å›žæœ€å°çš„nä¸ªå…ƒç´ ï¼ˆTop-Ké—®é¢˜ï¼‰# å¦‚æžœå†™æˆäº†è¿™æ ·ï¼Œé‚£ä¹ˆå¯»æ‰¾æœ€å¤§K ä¸ªå…ƒç´ ï¼Œçž¬é—´å°±æ²¡æœ‰äº†æ„ä¹‰ï¼Œæœ‰æ²¡æœ‰æ„Ÿè§‰åˆ° dictionary 1234import collections# å°±ç±»ä¼¼ä¸€ä¸ªè®¡æ•°å™¨äº†hash =collections.defaultdict(int); å…¶ä»–python ä¸­ in æ“ä½œ åœ¨ä¸åŒçš„æ•°æ®é›†åˆä¸­çš„æ—¶é—´å¤æ‚åº¦è¿™ä¸ªæ˜¯å–å†³äºŽæ“ä½œçš„æ•°æ®ç»“æž„ï¼š list (tuple) -average: O(N) set/dict- average: O(1), worst: O(N) (å¦‚æžœ dictionary æ‰€æœ‰çš„å€¼éƒ½ç›¸åŒçš„è¯ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦å°±æ˜¯ O(n)) The O(n) worst case for sets and dicts is very uncommon, but it can happen if hash is implemented poorly. This only happens if everything in your set has the same hash value. æ“ä½œ å¹³å‡æƒ…å†µ æœ€åæƒ…å†µ è¯´æ˜Ž åˆ—è¡¨ list O(n) O(n) list æ˜¯ç”±æ•°ç»„å®žçŽ°çš„ å­—å…¸ dict O(1) O(n) é›†åˆ set O(1) O(n) å†…éƒ¨å®žçŽ°å’Œ dict å¾ˆåƒ python ä¸­è¡¨ç¤ºæœ€å¤§å’Œæœ€å°çš„æ•°å­—123import syssys.maxsize #å¦‚æžœæ˜¯æ•´åž‹float(â€˜infâ€™) # å¦‚æžœæ˜¯æµ®ç‚¹åž‹]]></content>
      <categories>
        <category>CSåŸºç¡€</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++ ç¼–ç¨‹è¯­è¨€]]></title>
    <url>%2F2019%2F01%2F05%2Fcpp%2F</url>
    <content type="text"><![CDATA[ä¸»è¦ä»‹ç»C++ ç¼–ç¨‹è¯­è¨€ã€‚ C++ ä¸­çš„çŸ¥è¯†ç‚¹ c è¯­è¨€å’Œc++ çš„åŒºåˆ«ï¼šcè¯­è¨€æ˜¯é¢å‘è¿‡ç¨‹çš„è¯­è¨€ï¼Œc++ æ˜¯é¢å‘å¯¹è±¡çš„è¯­è¨€ c è¯­è¨€çš„ç»“æž„ä½“å’Œc++ çš„ç±»çš„åŒºåˆ«ï¼šc è¯­è¨€ç»“æž„ä½“æˆå‘˜é»˜è®¤çš„è®¿é—®æƒé™æ˜¯å…±æœ‰ï¼Œc++ çš„æˆå‘˜çš„é»˜è®¤è®¿é—®æƒé™æ˜¯ç§æœ‰ c++ çš„ä¸‰å¤§æ ¸å¿ƒæ¦‚å¿µï¼š å°è£…ã€ç»§æ‰¿å’Œå¤šæ€ã€‚ c++ æ ‡å‡†æ–°ç‰¹æ€§ï¼ˆå‘½åç©ºé—´ namepace std, stringï¼‰ STL(Standard Template Library æ ‡å‡†æ¨¡æ¿åº“, string, list, map) ç­‰å‡½æ•° é¢å‘å¯¹è±¡çš„ä¸‰å¤§ç‰¹å¾ï¼ˆc++ï¼‰ C++ çš„ä¸‰å¤§ç‰¹æ€§ï¼Œå°è£…ï¼Œç»§æ‰¿ï¼Œå¤šæ€ã€‚å°è£…å¯ä»¥ä½¿å¾—ä»£ç æ¨¡å—åŒ–ï¼Œç»§æ‰¿å¯ä»¥æ‰©å±•å·²å­˜åœ¨çš„ä»£ç ï¼Œè€Œå¤šæ€çš„ç›®çš„åˆ™æ˜¯ä¸ºäº†æŽ¥å£é‡ç”¨ã€‚ ç»§æ‰¿ï¼š (1 ) å¯ä»¥ä½¿ä»£ç å¾—åˆ°è‰¯å¥½çš„å¤ç”¨ (2 ) ä½¿æ•´ä¸ªç¨‹åºè®¾è®¡æ›´åŠ ç¬¦åˆäººä»¬çš„é€»è¾‘ï¼ˆåœ¨æ°´æžœçš„åŸºç¡€ä¸Šå¯ä»¥ç”Ÿæˆçƒ­å¸¦æ°´æžœï¼Œæ¸©å¸¦æ°´æžœï¼‰ å°è£…ï¼š ï¼ˆ1ï¼‰ æŠŠå˜é‡å’Œå‡½æ•°å†™åˆ°ä¸€ä¸ªç±»ä¸­ï¼Œå®žçŽ°å°è£… ï¼ˆ2ï¼‰ä¸æƒ³æš´éœ²åœ¨å¤–ç•Œçš„æˆå‘˜ç§æœ‰åŒ– å¤šæ€ï¼ˆä¸€ä¸ªæŽ¥å£ï¼Œå¤šç§å½¢æ€ï¼‰ï¼š çˆ¶ç±»çš„æŒ‡é’ˆæˆ–å¼•ç”¨æœ‰å¤šç§è¡¨çŽ°å½¢æ€ï¼Œç”¨çˆ¶ç±»çš„æŒ‡é’ˆæˆ–è€…å¼•ç”¨ç»Ÿä¸€æ“ä½œå„ç§å­ç±»å¯¹è±¡ã€‚ å¤šæ€ å¤šæ€æ€§æ˜¯å…è®¸ä½ å°†çˆ¶å¯¹è±¡è®¾ç½®æˆä¸ºå’Œä¸€ä¸ªæˆ–æ›´å¤šçš„ä»–çš„å­å¯¹è±¡ç›¸ç­‰çš„æŠ€æœ¯ï¼Œèµ‹å€¼ä¹‹åŽï¼Œçˆ¶å¯¹è±¡å°±å¯ä»¥æ ¹æ®å½“å‰èµ‹å€¼ç»™å®ƒçš„å­å¯¹è±¡çš„ç‰¹æ€§ä»¥ä¸åŒçš„æ–¹å¼è¿ä½œã€‚ç®€å•çš„è¯´ï¼šå…è®¸å°†å­ç±»ç±»åž‹çš„æŒ‡é’ˆèµ‹å€¼ç»™çˆ¶ç±»ç±»åž‹çš„æŒ‡é’ˆï¼ˆä¸€ä¸ªæŽ¥å£ï¼Œå¤šç§æ–¹æ³•ï¼‰ã€‚C++ æ”¯æŒä¸¤ç§å¤šæ€æ€§ï¼šç¼–è¯‘æ—¶å¤šæ€æ€§ï¼Œè¿è¡Œæ—¶å¤šæ€æ€§ã€‚aã€ç¼–è¯‘æ—¶å¤šæ€æ€§ï¼ˆé™æ€å¤šæ€ï¼‰ï¼šé€šè¿‡é‡è½½å‡½æ•°å®žçŽ°bã€è¿è¡Œæ—¶å¤šæ€æ€§ï¼ˆåŠ¨æ€å¤šæ€ï¼‰ï¼šé€šè¿‡è™šå‡½æ•°å®žçŽ°ã€‚ è¿è¡Œæ—¶å¤šæ€ï¼š æœ€å¸¸è§çš„ç”¨æ³•å°±æ˜¯å£°æ˜ŽåŸºç±»çš„æŒ‡é’ˆï¼Œåˆ©ç”¨è¯¥æŒ‡é’ˆæŒ‡å‘ä»»æ„ä¸€ä¸ªå­ç±»å¯¹è±¡ï¼Œè°ƒç”¨ç›¸åº”çš„è™šå‡½æ•°ï¼Œå¯ä»¥æ ¹æ®æŒ‡å‘çš„å­ç±»çš„ä¸åŒè€Œå®žçŽ°ä¸åŒçš„æ–¹æ³•ã€‚ éžè¿è¡Œæ—¶å¤šæ€ï¼š é€šè¿‡å‡½æ•°é‡è½½å®žçŽ° è™šå‡½æ•° è™šå‡½æ•°ï¼š å°±æ˜¯å…è®¸è¢«å…¶å­ç±»é‡æ–°å®šä¹‰çš„æˆå‘˜å‡½æ•°ï¼Œå­ç±»é‡æ–°å®šä¹‰çˆ¶ç±»è™šå‡½æ•°çš„åšæ³•ï¼Œå¯å®žçŽ°æˆå‘˜å‡½æ•°çš„åŠ¨æ€è¦†ç›–ï¼ˆOverrideï¼‰ã€‚ C++ä¸­çš„è™šå‡½æ•°å®žçŽ°äº†å¤šæ€çš„æœºåˆ¶ï¼Œä¹Ÿå°±æ˜¯ç”¨çˆ¶ç±»åž‹æŒ‡é’ˆæŒ‡å‘å…¶å­ç±»çš„å®žä¾‹ï¼Œç„¶åŽé€šè¿‡çˆ¶ç±»çš„æŒ‡é’ˆè°ƒç”¨å®žé™…å­ç±»çš„æˆå‘˜å‡½æ•°ï¼Œè¿™ç§æŠ€æœ¯å¯ä»¥è®©çˆ¶ç±»çš„æŒ‡é’ˆæœ‰â€œå¤šç§å½¢æ€â€ï¼Œè¿™ä¹Ÿæ˜¯ä¸€ç§æ³›åž‹æŠ€æœ¯ï¼Œä¹Ÿå°±æ˜¯ä½¿ç”¨ä¸å˜çš„ä»£ç æ¥å®žçŽ°å¯å˜çš„ç®—æ³•ã€‚ ä½¿ç”¨è™šå‡½æ•°çš„å¥½å¤„ï¼š æœ‰äº†è™šå‡½æ•°ï¼Œæ— éœ€å‘ä¸‹è½¬åž‹ï¼Œå¯ä»¥ä½¿ç”¨çˆ¶ç±»çš„æŒ‡é’ˆæˆ–è€…å¼•ç”¨ï¼Œè°ƒç”¨å­ç±»çš„å‡½æ•° è°ƒç”¨è™šå‡½æ•°æ—¶ï¼Œåˆ°åº•è°ƒç”¨å“ªä¸ªç‰ˆæœ¬ï¼Œæ˜¯æ ¹æ®æŒ‡é’ˆæˆ–å¼•ç”¨å®žé™…æ‰€æŒ‡å‘çš„å¯¹è±¡çš„ç±»åž‹æ¥ç¡®å®šï¼Œè€Œä¸æ˜¯è°ƒç”¨è€…æœ¬èº«çš„ç±»åž‹æ¥ç¡®å®š å¯¹è±¡æ•°æ®å’Œå‡½æ•°çš„å­˜å‚¨æ–¹å¼#æˆ‘ä»¬çŸ¥é“ï¼Œç”¨ç±»åŽ»å®šä¹‰å¯¹è±¡ï¼Œç³»ç»Ÿä¼šä¸ºæ¯ä¸€ä¸ªå¯¹è±¡åˆ†é…å­˜å‚¨ç©ºé—´ æ¯ä¸ªå¯¹è±¡å ç”¨å­˜å‚¨ç©ºé—´çš„åªæ˜¯è¯¥å¯¹è±¡çš„æ•°æ®éƒ¨åˆ†ï¼ˆè™šå‡½æ•°æŒ‡é’ˆå’Œè™šåŸºç±»æŒ‡é’ˆä¹Ÿå±žäºŽæ•°æ®éƒ¨åˆ†ï¼‰ï¼Œå‡½æ•°ä»£ç å±žäºŽå…¬ç”¨éƒ¨åˆ† C++çš„å†…å­˜åˆ†åŒºå¤§æ¦‚åˆ†æˆäº”ä¸ªéƒ¨åˆ†ï¼š æ ˆï¼ˆstackï¼‰ï¼šæ˜¯ç”±ç¼–è¯‘å™¨åœ¨éœ€è¦æ—¶è‡ªåŠ¨åˆ†é…ï¼Œä¸éœ€è¦æ—¶è‡ªåŠ¨æ¸…é™¤çš„å˜é‡å­˜å‚¨åŒºï¼Œé€šå¸¸å­˜æ”¾å±€éƒ¨å˜é‡ã€å‡½æ•°å‚æ•°ç­‰ã€‚å †ï¼ˆheapï¼‰ï¼šæ˜¯ç”±newåˆ†é…çš„å†…å­˜å—ï¼Œç”±ç¨‹åºå‘˜é‡Šæ”¾ï¼ˆç¼–è¯‘å™¨ä¸ç®¡ï¼‰ï¼Œä¸€èˆ¬ä¸€ä¸ªnewä¸Žä¸€ä¸ªdeleteå¯¹åº”ï¼Œä¸€ä¸ªnew[]ä¸Žä¸€ä¸ªdelete[]å¯¹åº”ï¼Œå¦‚æžœç¨‹åºå‘˜æ²¡æœ‰é‡Šæ”¾æŽ‰ï¼Œèµ„æºå°†ç”±æ“ä½œç³»ç»Ÿåœ¨ç¨‹åºç»“æŸåŽè‡ªåŠ¨å›žæ”¶è‡ªç”±å­˜å‚¨åŒºï¼šæ˜¯ç”±mallocç­‰åˆ†é…çš„å†…å­˜å—ï¼Œå’Œå †ååˆ†ç›¸ä¼¼ï¼Œç”¨freeæ¥é‡Šæ”¾å…¨å±€/é™æ€å­˜å‚¨åŒºï¼šå…¨å±€å˜é‡å’Œé™æ€å˜é‡è¢«åˆ†é…åˆ°åŒä¸€å—å†…å­˜ä¸­å¸¸é‡å­˜å‚¨åŒºï¼šè¿™æ˜¯ä¸€å—ç‰¹æ®Šå­˜å‚¨åŒºï¼Œé‡Œè¾¹å­˜æ”¾å¸¸é‡ï¼Œä¸å…è®¸ä¿®æ”¹ï¼ˆå †å’Œè‡ªç”±å­˜å‚¨åŒºå…¶å®žä¸è¿‡æ˜¯åŒä¸€å—åŒºåŸŸï¼Œnewåº•å±‚å®žçŽ°ä»£ç ä¸­è°ƒç”¨äº†mallocï¼Œnewå¯ä»¥çœ‹æˆæ˜¯mallocæ™ºèƒ½åŒ–çš„é«˜çº§ç‰ˆæœ¬ï¼‰ ä½ å¯èƒ½ä¼šé—®ï¼šé™æ€æˆå‘˜å‡½æ•°å’Œéžé™æ€æˆå‘˜å‡½æ•°éƒ½æ˜¯åœ¨ç±»çš„å®šä¹‰æ—¶æ”¾åœ¨å†…å­˜çš„ä»£ç åŒºçš„ï¼Œå› è€Œå¯ä»¥è¯´å®ƒä»¬éƒ½æ˜¯å±žäºŽç±»çš„ï¼Œä½†æ˜¯ç±»ä¸ºä»€ä¹ˆåªèƒ½ç›´æŽ¥è°ƒç”¨é™æ€ç±»æˆå‘˜å‡½æ•°ï¼Œè€Œéžé™æ€ç±»æˆå‘˜å‡½æ•°(å³ä½¿å‡½æ•°æ²¡æœ‰å‚æ•°)åªæœ‰ç±»å¯¹è±¡æ‰èƒ½è°ƒç”¨å‘¢ åŽŸå› æ˜¯ï¼šç±»çš„éžé™æ€ç±»æˆå‘˜å‡½æ•°å…¶å®žéƒ½å†…å«äº†ä¸€ä¸ªæŒ‡å‘ç±»å¯¹è±¡çš„æŒ‡é’ˆåž‹å‚æ•°(å³thisæŒ‡é’ˆ)ï¼Œå› æ­¤åªæœ‰ç±»å¯¹è±¡æ‰èƒ½è°ƒç”¨(æ­¤æ—¶thisæŒ‡é’ˆæœ‰å®žå€¼) è™šå‡½æ•°è¡¨åŽŸç†ç®€è¿° C++å®žçŽ°è™šå‡½æ•°çš„æ–¹æ³•æ˜¯ï¼šä¸ºæ¯ä¸ªç±»å¯¹è±¡æ·»åŠ ä¸€ä¸ªéšè—æˆå‘˜ï¼Œéšè—æˆå‘˜ä¿å­˜äº†ä¸€ä¸ªæŒ‡é’ˆï¼Œè¿™ä¸ªæŒ‡é’ˆå«è™šè¡¨æŒ‡é’ˆï¼ˆvptrï¼‰ï¼Œå®ƒæŒ‡å‘ä¸€ä¸ªè™šå‡½æ•°è¡¨ï¼ˆvirtual function table, vtblï¼‰ è™šå‡½æ•°è¡¨å°±åƒä¸€ä¸ªæ•°ç»„ï¼Œè¡¨ä¸­æœ‰è®¸å¤šçš„æ§½ï¼ˆslotï¼‰ï¼Œæ¯ä¸ªæ§½ä¸­å­˜æ”¾çš„æ˜¯ä¸€ä¸ªè™šå‡½æ•°çš„åœ°å€ï¼ˆå¯ä»¥ç†è§£ä¸ºæ•°ç»„é‡Œå­˜æ”¾ç€æŒ‡å‘æ¯ä¸ªè™šå‡½æ•°çš„æŒ‡é’ˆï¼‰ å³ï¼šæ¯ä¸ªç±»ä½¿ç”¨ä¸€ä¸ªè™šå‡½æ•°è¡¨ï¼Œæ¯ä¸ªç±»å¯¹è±¡ç”¨ä¸€ä¸ªè™šè¡¨æŒ‡é’ˆ C++çš„ç¼–è¯‘å™¨ä¼šä¿è¯è™šå‡½æ•°è¡¨çš„æŒ‡é’ˆå­˜åœ¨äºŽå¯¹è±¡å®žä¾‹ä¸­æœ€å‰é¢çš„ä½ç½®ï¼ˆä¸ºäº†ä¿è¯å–è™šå‡½æ•°è¡¨æœ‰æœ€é«˜çš„æ€§èƒ½ï¼Œåœ¨æœ‰å¤šå±‚ç»§æ‰¿æˆ–æ˜¯å¤šé‡ç»§æ‰¿çš„æƒ…å†µä¸‹ï¼‰ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬é€šè¿‡å¯¹è±¡å®žä¾‹çš„åœ°å€å¾—åˆ°è¿™å¼ è™šå‡½æ•°è¡¨çš„åœ°å€ï¼Œç„¶åŽå°±å¯ä»¥éåŽ†å…¶ä¸­å‡½æ•°æŒ‡é’ˆï¼Œå¹¶è°ƒç”¨ç›¸åº”çš„å‡½æ•° æˆ‘ä»¬å»ºç«‹ä¸€ä¸ªæ–°ç±» 1234567class Base &#123;public: virtual void f() &#123; cout &lt;&lt; "Base::f" &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; "Base::g" &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; "Base::h" &lt;&lt; endl; &#125;&#125;; æŒ‰ç…§ä¸Šé¢çš„è¯´æ³•ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡Baseçš„å®žä¾‹æ¥å¾—åˆ°è™šå‡½æ•°è¡¨ï¼Œè¿™ä¸ªè¡¨ï¼ˆæ•°ç»„ï¼‰å­˜äº†æŒ‡å‘fï¼Œgï¼Œhè¿™ä¸‰ä¸ªå‡½æ•°çš„æŒ‡é’ˆ123456789101112131415typedef void(*Fun)(void);int main()&#123; Base bObj; Fun pFun = NULL; //æŒ‡å‘void* pf(void)ç±»çš„å‡½æ•°çš„æŒ‡é’ˆpFun cout &lt;&lt; &quot;è™šå‡½æ•°è¡¨çš„åœ°å€ï¼š&quot; &lt;&lt; (int*)(&amp;bObj) &lt;&lt; endl; cout &lt;&lt; &quot;è™šå‡½æ•°è¡¨çš„ç¬¬ä¸€ä¸ªå‡½æ•°åœ°å€ï¼š&quot; &lt;&lt; (int*) * (int*)(&amp;bObj) &lt;&lt; endl; //å†æ¬¡å–å€å¾—åˆ°ç¬¬ä¸€ä¸ªè™šå‡½æ•°çš„åœ°å€ //ç¬¬ä¸€ä¸ªè™šå‡½æ•° pFun = (Fun) * ((int*) * (int*)(&amp;bObj)); pFun();&#125; è®¡ç®—å†…å­˜å¤§å° c++ä¸­æœ€é‡è¦çš„å°±æ˜¯ç±»ï¼Œé‚£ä¹ˆä¸€ä¸ªç±»çš„å¯¹è±¡ï¼Œå®ƒåœ¨å†…å­˜ä¸­å¦‚ä½•å­˜å‚¨çš„ï¼Ÿå®ƒå å†…å­˜ä¸­å¤šå°‘ä¸ªå­—èŠ‚ï¼Ÿé¦–å…ˆç¡®å®šç±»çš„æž„æˆï¼š1ï¼Œæ•°æ®æˆå‘˜ï¼šå¯ä»¥æ˜¯å†…ç½®ç±»åž‹ï¼Œç±»ç±»åž‹ã€‚2ï¼Œå‡½æ•°æˆå‘˜ï¼šè™šå‡½æ•°ï¼Œéžè™šå‡½æ•°1ï¼‰æ•°æ®æˆå‘˜å†…ç½®ç±»åž‹å¯¹é½åŽŸåˆ™ ï¼ˆå¯¹é½åŽŸåˆ™æœ‰ä¸¤ä¸ªç»´åº¦ï¼Œä¸€ä¸ªæ˜¯åœ¨è®¡ç®—è¿‡ç¨‹ä¸­ï¼Œå¦‚æžœå‡ºçŽ°äº†å‰å°åŽå¤§ï¼Œé‚£ä¹ˆå‰é¢éœ€è¦å’ŒåŽé¢å¯¹é½ï¼›æœ€åŽå°±ç®—å®Œå†…å­˜ä½¿ç”¨é‡ä¹‹åŽï¼Œä¹Ÿæ˜¯éœ€è¦å’Œç±»ä¸­æœ€é•¿çš„è¿›è¡Œå¯¹é½ã€‚ä¸»è¦æ˜¯ä¸ºäº†æ–¹ä¾¿å­˜å‚¨ã€‚å¯ä»¥é€šè¿‡çœ‹ä¸‹é¢é“¾æŽ¥ä¸­çš„å®žä¾‹ å¥½å¥½ç†è§£.ï¼‰ å†…ç½®ç±»åž‹å°±æ˜¯å¸¸ç”¨çš„ï¼šchar,short,long,int,float,double.è¿™äº›å†…ç½®ç±»åž‹åœ¨ç±»çš„å¯¹è±¡ä¸­å¯¹é½æ–¹å¼ï¼Œå­—èŠ‚ä¸ºå•ä½ï¼ˆåœ¨c ä¸­ç»“æž„ä½“ä¹Ÿæ˜¯ä¸€æ ·çš„ï¼‰char 1short 2long 4int 4float 4fouble 8ç±»ç±»åž‹å¯¹é½åŽŸåˆ™ï¼ˆc ä¸­å°±æ˜¯ç»“æž„ä½“å¯¹é½åŽŸåˆ™ï¼‰å–ç±»ä¸­æœ€é•¿çš„æ•°æ®æˆå‘˜ä½œä¸ºå¯¹é½åŽŸåˆ™ã€‚ä¾‹å¦‚ï¼Œç±»ä¸­æœ€é•¿ä¸º double,é‚£ä¹ˆå°±æ˜¯8 ä¸ªå­—èŠ‚ã€‚2ï¼‰å‡½æ•°æˆå‘˜å‡½æ•°æˆå‘˜æ˜¯ä¸å ç”¨å†…å­˜ä¸­ç±»çš„å¯¹è±¡çš„å­—èŠ‚ã€‚ä¸ºä»€ä¹ˆå‘¢ï¼Œä½ å¯ä»¥è¿™æ ·ç†è§£ï¼Œc++ä¸­ä¸ºäº†å…¼å®¹cä¹Ÿå…è®¸struct ä½œä¸ºç±»çš„å£°æ˜Žã€‚åœ¨c ä¸­struct æ˜¯ç”¨æ¥å£°æ˜Žç»“æž„ä½“ç±»åž‹çš„ï¼Œåªä¸è¿‡c ä¸­çš„ç»“æž„ä½“æ²¡æœ‰å‡½æ•°æˆå‘˜ã€‚åŒæ · c++ä¸­å…è®¸çš„å‡½æ•°æˆå‘˜ï¼Œåªä¸è¿‡æ˜¯ç±»ç»™å‡½æ•°æä¾›äº†ä¸€ä¸ªä½œç”¨åŸŸ ä¸Šé¢æ‰€è®²çš„å…¶å®žéƒ½æ˜¯å…³äºŽsizeof()å¯¹äºŽå­—ç¬¦ç›¸å…³å˜é‡çš„æ“ä½œï¼Œå­—ç¬¦æ“ä½œè¿˜æœ‰å¦ä¸€ä¸ªå¸¸ç”¨çš„å‡½æ•°strlen()ã€‚å‰è€…æ˜¯åŒ…æ‹¬ \0 ï¼ŒåŽè€…ä¸åŒ…æ‹¬ã€‚12345678string str ="abc";sizeof(str) æœ¬èº«å¤§å°æ˜¯å›ºå®šçš„ï¼Œç”±ç¼–è¯‘å™¨å†³å®šï¼Œä¸éšç€åŽé¢çœŸå®žå€¼çš„å˜åŒ–è€Œå˜åŒ–ã€‚æ˜¯ä¸€ä¸ªå¸¸é‡ã€‚``` æ›´å¤šçš„ä¾‹å­æ˜¯çœ‹è¿™é‡Œï¼šæ´¾ç”Ÿç±»éœ€è¦åŠ ä¸Šçˆ¶ç±»ä¸­çš„å˜é‡ï¼Œå› ä¸ºå‰è€…æ˜¯å¯ä»¥è®¿é—®ä¸Šè¿°å˜é‡çš„ã€‚[C++ç±»çš„å­˜å‚¨åŠç±»å¯¹è±¡å†…å­˜ç»“æž„](http://www.ishenping.com/ArtInfo/3127703.html) #includeusing namespace std;class basic{private: static int a; char b[10]; int c;public: static void fun1(){cout&lt;&lt;â€fun1â€&lt;&lt;endl;} void fun2(){cout&lt;&lt;â€fun2â€&lt;&lt;endl;} virtual void fun3(){cout&lt;&lt;â€fun3â€&lt;&lt;endl;} //virtual void fun4(){cout&lt;&lt;â€fun4â€&lt;&lt;endl;} //virtual void fun5(){cout&lt;&lt;â€fun4â€&lt;&lt;endl;}};int basic::a=1; int main (){ basic test; cout&lt;&lt;â€size:â€&lt;&lt;sizeof(test)&lt;&lt;endl; # 24 åœ¨64ä½æœºå™¨ä¸Šï¼Œä¸ç®¡æœ‰å‡ ä¸ªè™šå‡½æ•°ï¼Œåªæ˜¯åœ¨æœ€å¼€å§‹çš„åœ°æ–¹æœ‰ä¸€ä¸ªè™šå‡½æ•°è¡¨ï¼Œåœ°å€å­—èŠ‚(64/8)çš„å¤§å° return 0;}123çº¯è™šå‡½æ•°ï¼š æ˜¯åœ¨åŸºç±»ä¸­å£°æ˜Žçš„è™šå‡½æ•°ï¼Œå®ƒåœ¨åŸºç±»ä¸­æ²¡æœ‰å®šä¹‰ï¼Œä½†è¦æ±‚ä»»ä½•æ´¾ç”Ÿç±»éƒ½è¦å®šä¹‰è‡ªå·±çš„å®žçŽ°æ–¹æ³•ã€‚åœ¨åŸºç±»ä¸­å®žçŽ°çº¯è™šå‡½æ•°çš„æ–¹æ³•æ˜¯åœ¨å‡½æ•°åŽŸåž‹åŽåŠ â€œ=0â€ //çº¯è™šå‡½æ•°ï¼šè™šå‡½æ•°åªæœ‰å£°æ˜Žï¼Œæ²¡æœ‰å®žçŽ°ï¼Œå‡½æ•°ä½“=0virtual void draw() =0;virtual void rotate(double ) =0; // æ²¡æœ‰å®žçŽ°1234567891011121314151617181920212223242526272829æŠ½è±¡ç±»ï¼š åŒ…å«çº¯è™šå‡½æ•°çš„ç±»ç§°ä¸ºæŠ½è±¡ç±»ã€‚ç”±äºŽæŠ½è±¡ç±»åŒ…å«äº†æ²¡æœ‰å®šä¹‰çš„çº¯è™šå‡½æ•°ï¼Œæ‰€ä»¥ä¸èƒ½è¿›è¡Œå®žä¾‹åŒ–ã€‚çº¯è™šå‡½æ•°çš„ä½œç”¨ï¼š1. å¾ˆå¤šæƒ…å†µä¸‹ï¼ŒåŸºç±»æœ¬èº«ç”Ÿæˆå¯¹è±¡æ˜¯ä¸åˆç†çš„ã€‚ä¾‹å¦‚åŠ¨ç‰©ä½œä¸ºä¸€ä¸ªçˆ¶ç±»å¯ä»¥æ´¾ç”Ÿå‡ºè€è™Žï¼Œä½†æ˜¯åŠ¨ç‰©æœ¬èº«ç”Ÿæˆå¯¹è±¡æ˜¯ä¸åˆå¸¸ç†çš„ã€‚2. ç¼–è¯‘å™¨è¦æ±‚åœ¨æ´¾ç”Ÿç±»ä¸­å¿…é¡»äºˆä»¥é‡å†™ä»¥å®žçŽ°å¤šæ€æ€§ã€‚åŒæ—¶å«æœ‰çº¯è™šæ‹Ÿå‡½æ•°çš„ç±»ç§°ä¸ºæŠ½è±¡ç±»ï¼Œå®ƒä¸èƒ½ç”Ÿæˆå¯¹è±¡ã€‚è¿™æ ·å°±å¾ˆå¥½åœ°è§£å†³äº†ä¸Šè¿°ä¸¤ä¸ªé—®é¢˜ã€‚**éšè— vs. é‡è½½ vs. è¦†ç›–**éšè—æ˜¯æŒ‡æ´¾ç”Ÿç±»çš„å‡½æ•°å±è”½äº†ä¸Žå…¶åŒåçš„åŸºç±»å‡½æ•°ï¼Œè§„åˆ™å¦‚ä¸‹ï¼š1. å¦‚æžœæ´¾ç”Ÿç±»çš„å‡½æ•°ä¸ŽåŸºç±»çš„å‡½æ•°åŒåï¼Œä½†æ˜¯å‚æ•°ä¸åŒã€‚æ­¤æ—¶ï¼Œä¸è®ºæœ‰æ— virtualå…³é”®å­—ï¼ŒåŸºç±»çš„å‡½æ•°å°†è¢«éšè—ï¼ˆæ³¨æ„åˆ«ä¸Žé‡è½½æ··æ·†ï¼Œé‡è½½æ˜¯åœ¨åŒä¸€ä¸ªç±»ä¸­ï¼Œè€Œéšè—æ¶‰åŠæ´¾ç”Ÿç±»ä¸ŽåŸºç±»ï¼‰ã€‚2. å¦‚æžœæ´¾ç”Ÿç±»çš„å‡½æ•°ä¸ŽåŸºç±»çš„å‡½æ•°åŒåï¼Œå¹¶ä¸”å‚æ•°ä¹Ÿç›¸åŒï¼Œä½†æ˜¯åŸºç±»å‡½æ•°æ²¡æœ‰virtualå…³é”®å­—ã€‚æ­¤æ—¶ï¼ŒåŸºç±»çš„å‡½æ•°è¢«éšè—ï¼ˆæ³¨æ„åˆ«ä¸Žè¦†ç›–æ··æ·†ï¼Œè¦†ç›–æœ‰virtualå…³é”®å­—ï¼‰ã€‚ï¼ˆé‡å®šä¹‰ï¼‰éšè—æ˜¯å­ç±»å’Œçˆ¶ç±»ä¹‹é—´çš„å…³ç³»ï¼Œå­ç±»çš„å‡½æ•°å±è”½äº†ä¸Žå…¶åŒåçš„çˆ¶ç±»å‡½æ•°ä¸­çš„æ–¹æ³•ã€‚é‡è½½æ˜¯åŒä¸€ä¸ªç±»å†…éƒ¨çš„äº‹æƒ…ï¼ŒåŒåçš„å‡½æ•°ä½†å‚æ•°ä¸åŒçš„å‡½æ•°ï¼Œå¯ä»¥æ ¹æ®è°ƒç”¨æ—¶å€™çš„å‚æ•°çš„å˜åŒ–ä½¿ç”¨ä¸åŒçš„å‡½æ•°ã€‚ï¼ˆé‡å†™ overrideï¼‰è¦†ç›–æ˜¯å­ç±»å’Œçˆ¶ç±»ä¹‹é—´çš„å…³ç³»ï¼Œå’Œéšè—ä¸åŒçš„æ˜¯ï¼Œè¦æ±‚çˆ¶ç±»æœ‰å…³é”®å­—virtualï¼Œå¹¶ä¸”è¦†ç›–æ—¶å€™å­ç±»å’Œçˆ¶ç±»å‡½æ•°åå’Œå‚æ•°éœ€è¦ç›¸åŒã€‚é‡è½½ï¼ˆoverloadï¼‰ï¼šæŒ‡å‡½æ•°åç›¸åŒï¼Œä½†æ˜¯å®ƒçš„å‚æ•°è¡¨åˆ—ä¸ªæ•°æˆ–é¡ºåºï¼Œç±»åž‹ä¸åŒã€‚ä½†æ˜¯ä¸èƒ½é è¿”å›žç±»åž‹æ¥åˆ¤æ–­ã€‚ ï¼ˆ1ï¼‰ç›¸åŒçš„èŒƒå›´ï¼ˆåœ¨åŒä¸€ä¸ªä½œç”¨åŸŸä¸­ï¼‰ ï¼› ï¼ˆ2ï¼‰å‡½æ•°åå­—ç›¸åŒï¼› ï¼ˆ3ï¼‰å‚æ•°ä¸åŒï¼› ï¼ˆ4ï¼‰virtual å…³é”®å­—å¯æœ‰å¯æ— ã€‚ ï¼ˆ5ï¼‰è¿”å›žå€¼å¯ä»¥ä¸åŒï¼›```c++void a(int x)&#123;&#125;void a(int x, int y)&#123;&#125;void a(int x, int y, int z)&#123;&#125; é‡å†™ï¼ˆoverrideï¼‰ï¼š æ˜¯æŒ‡æ´¾ç”Ÿç±»é‡æ–°å®šä¹‰åŸºç±»çš„è™šå‡½æ•°ï¼Œç‰¹å¾æ˜¯ï¼š ï¼ˆ1ï¼‰ä¸åœ¨åŒä¸€ä¸ªä½œç”¨åŸŸï¼ˆåˆ†åˆ«ä½äºŽæ´¾ç”Ÿç±»ä¸ŽåŸºç±»ï¼‰ ï¼› ï¼ˆ2ï¼‰å‡½æ•°åå­—ç›¸åŒï¼› ï¼ˆ3ï¼‰å‚æ•°ç›¸åŒï¼› ï¼ˆ4ï¼‰åŸºç±»å‡½æ•°å¿…é¡»æœ‰ virtual å…³é”®å­—ï¼Œä¸èƒ½æœ‰ static ã€‚ 1234567891011class Base&#123;public: virtual void a(int x)&#123;&#125;&#125;class Derived: public Base&#123;public: void a(int x)&#123;&#125;&#125; è¿™ä¸ªæ˜¯çˆ¶ç±»å’Œå­ç±»ä¹‹é—´çš„ã€‚ é‡å®šä¹‰ï¼ˆéšè—ï¼‰ ä¹Ÿå«éšè—ï¼Œå­ç±»é‡å®šä¹‰çˆ¶ç±»ä¸­çš„éžè™šå‡½æ•°ï¼Œå±è”½äº†çˆ¶ç±»çš„åŒåå‡½æ•°(ç›¸å½“äºŽåˆ›å»ºäº†ä¸€ä¸ªæ–°çš„å‡½æ•°ï¼Œè·Ÿçˆ¶ç±»æ— å…³) ä¸¤ç§æƒ…å†µ å­ç±»å’Œçˆ¶ç±»å‡½æ•°çš„åç§°ç›¸åŒï¼Œå‚æ•°ä¹Ÿç›¸åŒï¼Œçˆ¶ç±»ä¸­çš„å‡½æ•°ä¸æ˜¯virtualï¼Œçˆ¶ç±»çš„å‡½æ•°å°†è¢«éšè— å­ç±»å’Œçˆ¶ç±»çš„å‡½æ•°åç§°ç›¸åŒï¼Œä½†å‚æ•°ä¸åŒï¼Œæ­¤æ—¶ä¸ç®¡çˆ¶ç±»å‡½æ•°æ˜¯ä¸æ˜¯virtualå‡½æ•°ï¼Œéƒ½å°†è¢«éšè—ã€‚ æž„é€ å‡½æ•°ï¼š æž„é€ å‡½æ•°æ˜¯ä¸€ç§æ¯”è¾ƒç‰¹æ®Šçš„æˆå‘˜å‡½æ•°ï¼Œç”¨äºŽåˆ›å»ºå¹¶åˆå§‹åŒ–å¯¹è±¡ã€‚å£°æ˜Žå¯¹è±¡æ—¶æž„é€ å‡½æ•°ä¼šè¢«ç¼–è¯‘å™¨è‡ªåŠ¨è°ƒç”¨ã€‚ æž„é€ å‡½æ•°çš„å››ä¸ªç‰¹ç‚¹ï¼š ï¼ˆ1ï¼‰æž„é€ å‡½æ•°çš„è®¿é—®æƒé™å¿…é¡»ä¸ºå…¬æœ‰ï¼ˆpublicï¼‰ ï¼ˆ2ï¼‰æž„é€ å‡½æ•°åå’Œç±»åç›¸åŒ ï¼ˆ3ï¼‰æž„é€ å‡½æ•°æ²¡æœ‰è¿”å›žå€¼ ï¼ˆ4ï¼‰ æž„é€ å‡½æ•°å¯ä»¥å¸¦å‚æ•°ï¼Œç”¨äºŽåˆå§‹åŒ–æˆå‘˜å˜é‡ 123Circle();// é»˜è®¤æž„é€ å‡½æ•°Circle(float a =0, float b =0, float c =0); // é»˜è®¤æž„é€ å‡½æ•°Circle(float a, float b, float c); æžæž„å‡½æ•°ï¼š ç±»çš„æžæž„å‡½æ•°æ˜¯ç±»çš„ä¸€ç§ç‰¹æ®Šçš„æˆå‘˜å‡½æ•°ï¼Œå®ƒä¼šåœ¨æ¯æ¬¡åˆ é™¤æ‰€åˆ›å»ºçš„å¯¹è±¡æ—¶æ‰§è¡Œã€‚ æžæž„å‡½æ•°çš„åç§°ä¸Žç±»çš„åç§°æ˜¯å®Œå…¨ç›¸åŒçš„ï¼Œåªæ˜¯åœ¨å‰é¢åŠ äº†ä¸ªæ³¢æµªå·ï¼ˆ~ï¼‰ä½œä¸ºå‰ç¼€ï¼Œå®ƒä¸ä¼šè¿”å›žä»»ä½•å€¼ï¼Œä¹Ÿä¸èƒ½å¸¦æœ‰ä»»ä½•å‚æ•°ã€‚æžæž„å‡½æ•°æœ‰åŠ©äºŽåœ¨è·³å‡ºç¨‹åºï¼ˆæ¯”å¦‚å…³é—­æ–‡ä»¶ã€é‡Šæ”¾å†…å­˜ç­‰ï¼‰å‰é‡Šæ”¾èµ„æºã€‚ 12345678910111213141516171819202122#include &lt;cstdio&gt;using namespace std;class A &#123;public: A() &#123; printf("A()\n"); &#125; virtual ~A() &#123; printf("~A()\n"); &#125;&#125;;class B : public A &#123;public: B() &#123; printf("B()\n"); &#125; ~B() &#123; printf("~B()\n"); &#125;&#125;;int main() &#123; A *p = nullptr; p = new B; delete p; return 0;&#125; ä¸‰ç§è®¿é—®æƒé™private: åªèƒ½ç”±è¯¥ç±»ä¸­çš„å‡½æ•°ã€å…¶å‹å…ƒå‡½æ•°è®¿é—®,ä¸èƒ½è¢«ä»»ä½•å…¶ä»–è®¿é—®ï¼Œè¯¥ç±»çš„å¯¹è±¡ä¹Ÿä¸èƒ½è®¿é—®.protected: å¯ä»¥è¢«è¯¥ç±»ä¸­çš„å‡½æ•°ã€å­ç±»çš„å‡½æ•°ã€ä»¥åŠå…¶å‹å…ƒå‡½æ•°è®¿é—®,ä½†ä¸èƒ½è¢«è¯¥ç±»çš„å¯¹è±¡è®¿é—®public: å¯ä»¥è¢«è¯¥ç±»ä¸­çš„å‡½æ•°ã€å­ç±»çš„å‡½æ•°ã€å…¶å‹å…ƒå‡½æ•°è®¿é—®,ä¹Ÿå¯ä»¥ç”±è¯¥ç±»çš„å¯¹è±¡è®¿é—®æ³¨ï¼šå‹å…ƒå‡½æ•°åŒ…æ‹¬ä¸¤ç§ï¼šè®¾ä¸ºå‹å…ƒçš„å…¨å±€å‡½æ•°ï¼Œè®¾ä¸ºå‹å…ƒç±»ä¸­çš„æˆå‘˜å‡½æ•° public: å¯ä»¥è¢«ä»»æ„å®žä½“è®¿é—®protected: åªå…è®¸å­ç±»å’Œæœ¬ç±»ä¸­çš„æˆå‘˜å‡½æ•°è®¿é—®private: åªå…è®¸æœ¬ç±»ä¸­çš„æˆå‘˜å‡½æ•°è®¿é—® å½“å‘ç”Ÿç»§æ‰¿æ—¶è®¿é—®æƒé™çš„å˜åŒ–ï¼š publicç»§æ‰¿ä¸æ”¹å˜åŸºç±»æˆå‘˜çš„è®¿é—®æƒé™ privateç»§æ‰¿ä½¿å¾—åŸºç±»æ‰€æœ‰æˆå‘˜åœ¨å­ç±»ä¸­çš„è®¿é—®æƒé™å˜ä¸ºprivate protectedç»§æ‰¿å°†åŸºç±»ä¸­publicæˆå‘˜å˜ä¸ºå­ç±»çš„protectedæˆå‘˜ï¼Œå…¶å®ƒæˆå‘˜çš„è®¿é—® æƒé™ä¸å˜ã€‚ åŸºç±»ä¸­çš„privateæˆå‘˜ä¸å—ç»§æ‰¿æ–¹å¼çš„å½±å“ï¼Œå­ç±»æ°¸è¿œæ— æƒè®¿é—®ã€‚ ç±»çš„å‹å…ƒå‡½æ•°æ˜¯å®šä¹‰åœ¨ç±»å¤–éƒ¨ï¼Œä½†æœ‰æƒè®¿é—®ç±»çš„æ‰€æœ‰ç§æœ‰ï¼ˆprivateï¼‰æˆå‘˜å’Œä¿æŠ¤ï¼ˆprotectedï¼‰æˆå‘˜ã€‚å°½ç®¡å‹å…ƒå‡½æ•°çš„åŽŸåž‹æœ‰åœ¨ç±»çš„å®šä¹‰ä¸­å‡ºçŽ°è¿‡ï¼Œä½†æ˜¯å‹å…ƒå‡½æ•°å¹¶ä¸æ˜¯æˆå‘˜å‡½æ•°ã€‚å‹å…ƒå¯ä»¥æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°è¢«ç§°ä¸ºå‹å…ƒå‡½æ•°ï¼›å‹å…ƒä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªç±»ï¼Œè¯¥ç±»è¢«ç§°ä¸ºå‹å…ƒç±»ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ•´ä¸ªç±»åŠå…¶æ‰€æœ‰æˆå‘˜éƒ½æ˜¯å‹å…ƒã€‚å¦‚æžœè¦å£°æ˜Žå‡½æ•°ä¸ºä¸€ä¸ªç±»çš„å‹å…ƒï¼Œéœ€è¦åœ¨ç±»å®šä¹‰ä¸­è¯¥å‡½æ•°åŽŸåž‹å‰ä½¿ç”¨å…³é”®å­— friendï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š 123456789class Box&#123; double width;public: double length; friend void printWidth( Box box ); // å‹å…ƒå‡½æ•° void setWidth( double wid ); friend class ClassTwo; // å‹å…ƒç±»&#125;; å¸¸è§çš„å…³é”®å­—const å…³é”®å­—ï¼š æ€»çš„åŽŸåˆ™æ˜¯åªè¯»çš„ï¼Œä¸èƒ½å˜ã€‚ (1 ) const å®šä¹‰å¸¸é‡ const float pi =3.14 (2 ) const ä¸ŽæŒ‡é’ˆ æŒ‡é’ˆå¸¸é‡å’Œå¸¸é‡æŒ‡é’ˆ (è°åœ¨å‰è°ä¸èƒ½å˜ï¼Œå¸¸é‡æŒ‡é’ˆä¸­å¸¸é‡ä¸èƒ½å˜ï¼ŒæŒ‡é’ˆå¸¸é‡ä¸­æŒ‡é’ˆä¸èƒ½å˜) å¸¸é‡æŒ‡é’ˆï¼š 123456789101112#include&lt;iostream&gt;using namespace std;int main()&#123; int a =5; const int *p =&amp;a; // ä¸èƒ½ä½¿ç”¨ *p =20 è¿™æ ·çš„ä¿®æ”¹å¸¸é‡çš„æ“ä½œ cout &lt;&lt; *p &lt;&lt; endl; return 0;&#125; è¿™ä¸‰ç§å½¢å¼éƒ½æ˜¯æ­£ç¡®çš„ã€‚12345int const *x;const int *y;int a =2;int *const p =&amp;a; æŒ‡é’ˆå¸¸é‡ï¼ˆæŒ‡å‘å¸¸é‡çš„æŒ‡é’ˆï¼‰ï¼š 1234567891011121314151617int a =5;int *const p =&amp;a;*p =20; // æŒ‡é’ˆä¸èƒ½å˜ï¼Œä½†æ˜¯å¯ä»¥ä¿®æ”¹å†…å®¹#include&lt;iostream&gt;using namespace std;int main()&#123; int a =5; int *const p =&amp;a; // ä¸èƒ½ä½¿ç”¨ *p =20 è¿™æ ·çš„ä¿®æ”¹å¸¸é‡çš„æ“ä½œ cout &lt;&lt; *p&lt;&lt;endl; int b =6; *p =20; cout &lt;&lt; *p &lt;&lt;endl; return 0;&#125; (3 ) const ä¸Žå‡½æ•° const int func(const int &amp; a) const; ä¿®é¥°å½¢å‚ï¼Œå½¢å‚ä¸èƒ½å˜ï¼›ä¿®é¥°æˆå‘˜å‡½æ•°æ—¶ï¼Œå‡½æ•°ä½“å†…ä¸èƒ½ä¿®æ”¹æˆå‘˜å˜é‡çš„å€¼ ï¼ˆæ³¨æ„ä¸€å…±å¯ä»¥æœ‰ä¸‰ä¸ªä½ç½®ï¼Œå¸¸ç”¨çš„æ˜¯ä½ç½®äºŒå’Œä½ç½®ä¸‰ï¼‰ 123456class Screen &#123;public: int ok() const &#123;return _cursor; &#125; int error(intival) const &#123; _cursor = ival; &#125;&#125; (4 ) const å¯¹è±¡ const Point p; å¸¸é‡å¯¹è±¡ const å¯¹è±¡ åªèƒ½è°ƒç”¨const æˆå‘˜å‡½æ•°ï¼Œä¸èƒ½è°ƒç”¨æ™®é€šæˆå‘˜å‡½æ•° æ™®é€šå¯¹è±¡æ—¢å¯ä»¥è°ƒç”¨const æˆå‘˜å‡½æ•° ä¹Ÿå¯ä»¥è°ƒç”¨æ™®é€šæˆå‘˜å‡½æ•° static å…³é”®å­— é™æ€å±€éƒ¨å˜é‡ï¼šå‡½æ•°ç»“æŸåŽï¼Œé™æ€å±€éƒ¨å˜é‡çš„å†…å­˜ç©ºé—´ä¸ä¼šè¢«ç³»ç»Ÿå›žæ”¶ï¼Œä¸‹ä¸€æ¬¡è°ƒç”¨å‡½æ•°æ—¶ä½¿ç”¨ä¸Šä¸€æ¬¡é€€å‡ºæ—¶çš„å€¼ã€‚ 12345678910#include&lt;iostream&gt;using namespace std;void show_average(double x)&#123;static double num =0;&#125;int main()&#123;return 0;&#125; åŽŸç†ï¼š (1 ): é™æ€å±€éƒ¨å˜é‡å­˜å‚¨åœ¨é™æ€å­˜å‚¨åŒº (2 ) é™æ€å±€éƒ¨å˜é‡åœ¨å‡½æ•°ç»“æŸåŽä¸ä¼šè¢«å›žæ”¶ï¼Œä¸‹æ¬¡ä½¿ç”¨çš„æ—¶å€™å¯ä»¥ä¿ç•™ä¸Šä¸€æ¬¡çš„ç»“æžœ ( 3): é™æ€å±€éƒ¨å˜é‡å¦‚æžœæœªè¿›è¡Œåˆå§‹åŒ–ï¼Œä¼šè¢«ç¼–è¯‘å™¨åˆå§‹åŒ–æˆ0 æˆ–è€…NULL é™æ€å±€éƒ¨å˜é‡æˆ–å…¨å±€å˜é‡çš„åŒºåˆ«ï¼šä½œç”¨åŸŸä¸åŒã€‚å±€éƒ¨å˜é‡åªæ˜¯åœ¨ä¸€ä¸ªå‡½æ•°ä¸­ï¼Œå…¨å±€å˜é‡æ˜¯æ•´ä¸ªclass æ–‡ä»¶ã€‚ é™æ€å…¨å±€å˜é‡å’Œå…¨å±€å˜é‡çš„åŒºåˆ«ï¼šé™æ€å…¨å±€å˜é‡åªèƒ½è¢«æœ¬æ–‡ä½¿ç”¨ï¼Œè€Œå…¨å±€å˜é‡å¯ä»¥è¢«åˆ«çš„æ–‡ä»¶ä½¿ç”¨ ç±»çš„é™æ€æˆå‘˜çš„è®¿é—®æœ‰ä¸¤ç§æ–¹å¼ï¼ŒæŽ¨èä½¿ç”¨æ–¹å¼ä¸€æ¥è®¿é—®ï¼Œå› ä¸ºé™æ€å˜é‡å±žäºŽæ•´ä¸ªç±»ï¼Œè€Œä¸æ˜¯æŸä¸ªç‰¹å®šçš„å¯¹è±¡ã€‚ 12345//æ–¹å¼ä¸€ ç±»å::é™æ€æˆå‘˜åStudent:: teacherName;// æ–¹å¼äºŒï¼š å¯¹è±¡å.é™æ€æˆå‘˜åStudent s1; s1.teacherName&apos; è§†é¢‘è®²è§£å¾ˆå¥½ c++ ä¸­é˜Ÿåˆ—æ“ä½œçš„è®¿é—®ï¼š front() è¿”å›žç¬¬ä¸€ä¸ªå…ƒç´ pop() åˆ é™¤ç¬¬ä¸€ä¸ªå…ƒç´ push() åœ¨æœ«å°¾åŠ å…¥ä¸€ä¸ªå…ƒç´ back() è¿”å›žæœ€åŽä¸€ä¸ªå…ƒç´ empty() å¦‚æžœé˜Ÿåˆ—ç©ºåˆ™è¿”å›žçœŸsize() è¿”å›žé˜Ÿåˆ—ä¸­å…ƒç´ çš„ä¸ªæ•° c++ æ ˆstack çš„æ“ä½œè®¿é—® top() è¿”å›žæ ˆé¡¶å…ƒç´ ï¼Œä¸åˆ é™¤ï¼ˆèŽ·å–ï¼‰pop() ç§»é™¤æ ˆé¡¶å…ƒç´  ï¼ˆåˆ é™¤ï¼‰push() åœ¨æ ˆé¡¶å¢žåŠ å…ƒç´  ï¼ˆå¢žåŠ ï¼‰empty() å †æ ˆä¸ºç©ºåˆ™è¿”å›žçœŸsize() è¿”å›žæ ˆä¸­å…ƒç´ æ•°ç›® auto å…³é”®è¯ åœ¨C++ 11 ä¸­ï¼Œå·²ç»åˆ é™¤äº†è¯¥ç”¨æ³•ï¼Œå–è€Œä»£ä¹‹çš„ä½œç”¨æ˜¯ï¼šè‡ªåŠ¨æŽ¨æ–­å˜é‡çš„ç±»åž‹ã€‚ define å’Œ typedef çš„åŒºåˆ« #define æ˜¯ C ä¸­å®šä¹‰çš„è¯­æ³•, typedef æ˜¯ C++ ä¸­å®šä¹‰çš„è¯­æ³•, äºŒè€…åœ¨ C++ ä¸­å¯ä»¥é€šç”¨, ä½† #define æˆäº†é¢„ç¼–è¯‘æŒ‡ä»¤, typedef å½“æˆè¯­å¥å¤„ç†. typedef å’Œ define éƒ½å¯ä»¥ç”¨æ¥ç»™å¯¹è±¡å–ä¸€ä¸ªåˆ«å, ä½†æ˜¯ä¿©è€…å´æœ‰å¾ˆå¤§çš„ä¸åŒ, æœ‰ä»¥ä¸‹å‡ ç‚¹ æ‰§è¡Œæ—¶é—´ å…³é”®å­— typedef åœ¨ç¼–è¯‘é˜¶æ®µæœ‰æ•ˆ, ç”±äºŽæ˜¯åœ¨ç¼–è¯‘é˜¶æ®µ, å› æ­¤ typededf æœ‰ç±»åž‹æ£€æŸ¥çš„åŠŸèƒ½.define æ˜¯å®å®šä¹‰, å‘ç”Ÿåœ¨é¢„å¤„ç†é˜¶æ®µ, ä¹Ÿå°±æ˜¯ç¼–è¯‘ä¹‹å‰, å®ƒåªæ˜¯è¿›è¡Œç®€å•è€Œæœºæ¢°çš„å­—ç¬¦ä¸²æ›¿æ¢, è€Œä¸è¿›è¡Œä»»ä½•æ£€æŸ¥. åŠŸèƒ½ä¸åŒ typedef ç”¨æ¥å®šä¹‰ç±»åž‹çš„åˆ«å#defineä¸æ­¢å¯ä»¥ä¸ºç±»åž‹å–åˆ«å, è¿˜å¯ä»¥å®šä¹‰å¸¸é‡, å˜é‡, ç¼–è¯‘å¼€å…³ç­‰. ä½œç”¨åŸŸä¸åŒ #define æ²¡æœ‰ä½œç”¨åŸŸçš„é™åˆ¶, åªè¦æ˜¯ä¹‹å‰é¢„å®šä¹‰è¿‡çš„å®, åœ¨ä»¥åŽçš„ç¨‹åºä¸­éƒ½å¯ä»¥ä½¿ç”¨. è€Œ typedef æœ‰è‡ªå·±çš„ä½œç”¨åŸŸ. 1234567void fun() &#123; #define A int&#125;void gun() &#123;//åœ¨è¿™é‡Œä¹Ÿå¯ä»¥ä½¿ç”¨Aï¼Œå› ä¸ºå®æ›¿æ¢æ²¡æœ‰ä½œç”¨åŸŸï¼Œ//ä½†å¦‚æžœä¸Šé¢ç”¨çš„æ˜¯typedefï¼Œé‚£è¿™é‡Œå°±ä¸èƒ½ç”¨A ï¼Œä¸è¿‡ä¸€èˆ¬ä¸åœ¨å‡½æ•°å†…ä½¿ç”¨typedef&#125; æœ€æŒ‡é’ˆæ“ä½œä½œç”¨ä¸åŒ 123456Typedef int * pintï¼› #define PINT int * Const pint pï¼›//pä¸å¯æ›´æ”¹ï¼ŒpæŒ‡å‘çš„å†…å®¹å¯ä»¥æ›´æ”¹ï¼Œç›¸å½“äºŽ int * const p; Const PINT pï¼›//på¯ä»¥æ›´æ”¹ï¼ŒpæŒ‡å‘çš„å†…å®¹ä¸èƒ½æ›´æ”¹ï¼Œç›¸å½“äºŽ const int *pï¼›æˆ– int const *pï¼› pint s1, s2; //s1å’Œs2éƒ½æ˜¯intåž‹æŒ‡é’ˆ PINT s3, s4; //ç›¸å½“äºŽint * s3ï¼Œs4ï¼›åªæœ‰ä¸€ä¸ªæ˜¯æŒ‡é’ˆã€‚ 123#define MAX(a,b) (a&gt;b)?a:bmax = MAX(x,y); define å’Œ typedef åŒºåˆ«C/C++ ä¸­çš„ define å’Œ typedefC/C++ ä¸­çš„å®/Macro decltypeç±»åž‹æŒ‡ç¤ºç¬¦ ä»Žè¡¨è¾¾å¼çš„ç±»åž‹æŽ¨æ–­å‡ºè¦å®šä¹‰çš„å˜é‡çš„ç±»åž‹ï¼Œä½†æ˜¯ä¸æƒ³ç”¨è¯¥è¡¨è¾¾å¼çš„å€¼åˆå§‹åŒ–å˜é‡ã€‚ æ¨¡æ¿ä¸‹é¢å°çš„ç¨‹åºè®¡ç®—çš„å°±æ˜¯æ•°å­— x çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­ 1 çš„ä¸ªæ•°ã€‚9999 çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸º â€œ10011100001111â€ã€‚ åšç¬”è¯•çš„æ—¶å€™ï¼Œå‘¨å›´è¿˜æ˜¯éœ€è¦æœ‰ä¸€ä¸ªç”µè„‘ï¼Œè¿™æ ·çš„è¯ï¼Œå°±èƒ½å¤ŸæŸ¥ä¸€ä¸‹èµ„æ–™ã€‚ 12345678int counters =0;int x;x =9999;while(x)&#123; counters +=1; x = x&amp; (x-1);&#125; é™åºæŽ’åºå’Œ ceil and floor åº“å‡½æ•° 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N =1000010;bool cmp1(int a, int b)&#123; return a&gt;b; // é™åº&#125;// é»˜è®¤çš„æ–¹å¼æ˜¯å‡åºçš„ï¼Œè¿™é‡Œä½¿ç”¨è‡ªå®šä¹‰çš„cmp å‡½æ•°ï¼Œå¯ä»¥å˜æˆé™åº// ceil() è¡¨ç¤ºå‘ä¸‹å–æ•´ï¼Œ floor() è¡¨ç¤ºå‘ä¸Šå–æ•´int main()&#123; int n; vector&lt;int&gt; arr(N); sort(arr.begin(), arr.end(), cmp1); retrun 0; &#125; ç®€å•çš„å®žçŽ° ä¸€ç›´è¾“å…¥å…ƒç´ ï¼Œå¦‚æžœæ˜¯ä»¥â€\nâ€ ç»“å°¾ï¼Œé‚£ä¹ˆå°±è·³å‡ºã€‚ 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdio.h&gt;using namespace std;const int N =1000010;int main()&#123; int n; char ch; while(scanf("%d%c", &amp;n, &amp;ch)) &#123; cout&lt;&lt; n&lt;&lt; " "; if(ch =='\n') break; &#125; return 0; &#125; c++ ä¸­çš„å€¼ä¼ é€’ã€æŒ‡é’ˆä¼ é€’å’Œå¼•ç”¨ä¼ é€’ å¯¹äºŽ ä¼ å€¼ã€ä¼ é€’å¼•ç”¨ã€ä¼ é€’æŒ‡é’ˆçš„ç†è§£ã€‚å¯¹äºŽå‰è€…æ˜¯ä¸ä¼šä¿®æ”¹åŽŸæ¥çš„å€¼ï¼Œç›¸å½“äºŽä¸€ç§copy ä¹‹åŽçš„æ“ä½œï¼›ä½†æ˜¯å¯¹äºŽåŽä¸¤è€…ï¼Œç›´æŽ¥æ“ä½œçš„æ˜¯åŽŸæ¥çš„å€¼ï¼Œç±»ä¼¼ä¸€ç§å…¨å±€å˜é‡çš„æ„Ÿè§‰ã€‚æ‰€ä»¥å¦‚æžœä¸æƒ³è¦ä¿®æ”¹åŽŸæ¥çš„å€¼ï¼Œé‚£ä¹ˆä¼ é€’å€¼ï¼Œå¦‚æžœæƒ³è¦ä¿®æ”¹åŽŸæ¥çš„å€¼ï¼Œé‚£ä¹ˆå°±ä¼ é€’æŒ‡é’ˆã€‚åŽè€…å°±ç±»ä¼¼ç»´æŠ¤ä¸€ç§å…¨å±€çš„å˜é‡ã€‚ ä¼ å€¼ï¼Œå°±æ˜¯copy æ•°å€¼ã€‚ ä¼ å¼•ç”¨ï¼Œå°±æ˜¯ä¼ é€’åœ°å€ï¼Œ ä½¿ç”¨ â€˜&amp;â€™ è¿™ä¸ªç¬¦å· ä¼ æŒ‡é’ˆï¼Œ ä½¿ç”¨ â€˜*â€™ ç¬¦å·ã€‚ åœ¨æ”¹å˜åŽŸå§‹çš„æ•°æ®ä¸Šé¢ï¼Œ2ï¼Œ 3ä¸¤ç§æ–¹å¼æ˜¯æ²¡æœ‰ä»€ä¹ˆåŒºåˆ«çš„ã€‚ä¸€èˆ¬æ¥è¯´èƒ½ç”¨å¼•ç”¨å°±ç”¨å¼•ç”¨ï¼ŒæŒ‡é’ˆå¼ºå¤§ï¼Œä½†æ˜¯å®¹æ˜“ä¿®æ”¹åœ°å€ï¼Œæ¯”è¾ƒå±é™©ã€‚å¼•ç”¨å¹¶ä¸èƒ½æ”¹å˜å…¶ç›®æ ‡å˜é‡ï¼Œè€ŒæŒ‡é’ˆå¯ä»¥ä»»æ„æ”¹å˜å…¶æŒ‡å‘çš„åœ°å€ã€‚ 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;//å€¼ä¼ é€’ void change1(int n)&#123; cout&lt;&lt;"å€¼ä¼ é€’--å‡½æ•°æ“ä½œåœ°å€"&lt;&lt;&amp;n&lt;&lt;endl; //æ˜¾ç¤ºçš„æ˜¯æ‹·è´çš„åœ°å€è€Œä¸æ˜¯æºåœ°å€ n++;&#125;//å¼•ç”¨ä¼ é€’void change2(int &amp; n)&#123; cout&lt;&lt;"å¼•ç”¨ä¼ é€’--å‡½æ•°æ“ä½œåœ°å€"&lt;&lt;&amp;n&lt;&lt;endl; n++;&#125; //æŒ‡é’ˆä¼ é€’void change3(int *n)&#123; cout&lt;&lt;"æŒ‡é’ˆä¼ é€’--å‡½æ•°æ“ä½œåœ°å€ "&lt;&lt;n&lt;&lt;endl; *n=*n+1; &#125; int main()&#123; int n=10; cout&lt;&lt;"å®žå‚çš„åœ°å€"&lt;&lt;&amp;n&lt;&lt;endl; change1(n); cout&lt;&lt;"after change1() n="&lt;&lt;n&lt;&lt;endl; change2(n); cout&lt;&lt;"after change2() n="&lt;&lt;n&lt;&lt;endl; change3(&amp;n); cout&lt;&lt;"after change3() n="&lt;&lt;n&lt;&lt;endl; return true;&#125; STLSTLçš„ä¸€ä¸ªé‡è¦ç‰¹ç‚¹æ˜¯æ•°æ®ç»“æž„å’Œç®—æ³•çš„åˆ†ç¦»ã€‚å°½ç®¡è¿™æ˜¯ä¸ªç®€å•çš„æ¦‚å¿µï¼Œä½†è¿™ç§åˆ†ç¦»ç¡®å®žä½¿å¾—STLå˜å¾—éžå¸¸é€šç”¨ã€‚ä¾‹å¦‚ï¼Œç”±äºŽSTLçš„sort()å‡½æ•°æ˜¯å®Œå…¨é€šç”¨çš„ï¼Œä½ å¯ä»¥ç”¨å®ƒæ¥æ“ä½œå‡ ä¹Žä»»ä½•æ•°æ®é›†åˆï¼ŒåŒ…æ‹¬é“¾è¡¨ï¼Œå®¹å™¨å’Œæ•°ç»„ã€‚ STLå¦ä¸€ä¸ªé‡è¦ç‰¹æ€§æ˜¯å®ƒä¸æ˜¯é¢å‘å¯¹è±¡çš„ã€‚ä¸ºäº†å…·æœ‰è¶³å¤Ÿé€šç”¨æ€§ï¼ŒSTLä¸»è¦ä¾èµ–äºŽæ¨¡æ¿è€Œä¸æ˜¯å°è£…ï¼Œç»§æ‰¿å’Œè™šå‡½æ•°ï¼ˆå¤šæ€æ€§ï¼‰â€”â€”OOPçš„ä¸‰ä¸ªè¦ç´ ã€‚ä½ åœ¨STLä¸­æ‰¾ä¸åˆ°ä»»ä½•æ˜Žæ˜¾çš„ç±»ç»§æ‰¿å…³ç³»ã€‚è¿™å¥½åƒæ˜¯ä¸€ç§å€’é€€ï¼Œä½†è¿™æ­£å¥½æ˜¯ä½¿å¾—STLçš„ç»„ä»¶å…·æœ‰å¹¿æ³›é€šç”¨æ€§çš„åº•å±‚ç‰¹å¾ã€‚å¦å¤–ï¼Œç”±äºŽSTLæ˜¯åŸºäºŽæ¨¡æ¿ï¼Œå†…è”å‡½æ•°çš„ä½¿ç”¨ä½¿å¾—ç”Ÿæˆçš„ä»£ç çŸ­å°é«˜æ•ˆã€‚ STLæä¾›äº†å¤§é‡çš„æ¨¡æ¿ç±»å’Œå‡½æ•°ï¼Œå¯ä»¥åœ¨OOPå’Œå¸¸è§„ç¼–ç¨‹ä¸­ä½¿ç”¨ã€‚æ‰€æœ‰çš„STLçš„å¤§çº¦50ä¸ªç®—æ³•éƒ½æ˜¯å®Œå…¨é€šç”¨çš„ï¼Œè€Œä¸”ä¸ä¾èµ–äºŽä»»ä½•ç‰¹å®šçš„æ•°æ®ç±»åž‹ã€‚ä¸‹é¢çš„å°èŠ‚è¯´æ˜Žäº†ä¸‰ä¸ªåŸºæœ¬çš„STLç»„ä»¶ï¼šï¼ˆ1ï¼‰è¿­ä»£å™¨æä¾›äº†è®¿é—®å®¹å™¨ä¸­å¯¹è±¡çš„æ–¹æ³•ã€‚ï¼ˆ2ï¼‰ å®¹å™¨æ˜¯ä¸€ç§æ•°æ®ç»“æž„ï¼Œå¦‚listï¼Œvectorï¼Œå’Œdeques ï¼Œä»¥æ¨¡æ¿ç±»çš„æ–¹æ³•æä¾›ã€‚ï¼ˆ3ï¼‰ç®—æ³•æ˜¯ç”¨æ¥æ“ä½œå®¹å™¨ä¸­çš„æ•°æ®çš„æ¨¡æ¿å‡½æ•°ã€‚ å­—å…¸åºï¼šæŒ‰å­—æ¯é¡ºåºæŽ’åˆ—çš„åºåˆ— 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798vector, å˜é•¿æ•°ç»„ï¼Œå€å¢žçš„æ€æƒ³ size() è¿”å›žå…ƒç´ ä¸ªæ•° empty() è¿”å›žæ˜¯å¦ä¸ºç©º clear() æ¸…ç©º front()/back() push_back()/pop_back() begin()/end() [] æ”¯æŒæ¯”è¾ƒè¿ç®—ï¼ŒæŒ‰å­—å…¸åºpair&lt;int, int&gt; first, ç¬¬ä¸€ä¸ªå…ƒç´  second, ç¬¬äºŒä¸ªå…ƒç´  æ”¯æŒæ¯”è¾ƒè¿ç®—ï¼Œä»¥firstä¸ºç¬¬ä¸€å…³é”®å­—ï¼Œä»¥secondä¸ºç¬¬äºŒå…³é”®å­—ï¼ˆå­—å…¸åºï¼‰stringï¼Œå­—ç¬¦ä¸² size()/length() è¿”å›žå­—ç¬¦ä¸²é•¿åº¦ empty() clear() substr(èµ·å§‹ä¸‹æ ‡ï¼Œ(å­ä¸²é•¿åº¦)) è¿”å›žå­ä¸² c_str() è¿”å›žå­—ç¬¦ä¸²æ‰€åœ¨å­—ç¬¦æ•°ç»„çš„èµ·å§‹åœ°å€queue, é˜Ÿåˆ— size() empty() push() å‘é˜Ÿå°¾æ’å…¥ä¸€ä¸ªå…ƒç´  front() è¿”å›žé˜Ÿå¤´å…ƒç´  back() è¿”å›žé˜Ÿå°¾å…ƒç´  pop() å¼¹å‡ºé˜Ÿå¤´å…ƒç´ priority_queue, ä¼˜å…ˆé˜Ÿåˆ—ï¼Œé»˜è®¤æ˜¯å¤§æ ¹å † push() æ’å…¥ä¸€ä¸ªå…ƒç´  top() è¿”å›žå †é¡¶å…ƒç´  pop() å¼¹å‡ºå †é¡¶å…ƒç´  å®šä¹‰æˆå°æ ¹å †çš„æ–¹å¼ï¼špriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;stack, æ ˆ size() empty() push() å‘æ ˆé¡¶æ’å…¥ä¸€ä¸ªå…ƒç´  top() è¿”å›žæ ˆé¡¶å…ƒç´  pop() å¼¹å‡ºæ ˆé¡¶å…ƒç´ deque, åŒç«¯é˜Ÿåˆ— size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() []set, map, multiset, multimap, åŸºäºŽå¹³è¡¡äºŒå‰æ ‘ï¼ˆçº¢é»‘æ ‘ï¼‰ï¼ŒåŠ¨æ€ç»´æŠ¤æœ‰åºåºåˆ— size() empty() clear() begin()/end() ++, -- è¿”å›žå‰é©±å’ŒåŽç»§ï¼Œæ—¶é—´å¤æ‚åº¦ O(logn) set/multiset insert() æ’å…¥ä¸€ä¸ªæ•° find() æŸ¥æ‰¾ä¸€ä¸ªæ•° count() è¿”å›žæŸä¸€ä¸ªæ•°çš„ä¸ªæ•° erase() (1) è¾“å…¥æ˜¯ä¸€ä¸ªæ•°xï¼Œåˆ é™¤æ‰€æœ‰x O(k + logn) (2) è¾“å…¥ä¸€ä¸ªè¿­ä»£å™¨ï¼Œåˆ é™¤è¿™ä¸ªè¿­ä»£å™¨ lower_bound()/upper_bound() lower_bound(x) è¿”å›žå¤§äºŽç­‰äºŽxçš„æœ€å°çš„æ•°çš„è¿­ä»£å™¨ upper_bound(x) è¿”å›žå¤§äºŽxçš„æœ€å°çš„æ•°çš„è¿­ä»£å™¨ map/multimap insert() æ’å…¥çš„æ•°æ˜¯ä¸€ä¸ªpair erase() è¾“å…¥çš„å‚æ•°æ˜¯pairæˆ–è€…è¿­ä»£å™¨ find() [] æ³¨æ„multimapä¸æ”¯æŒæ­¤æ“ä½œã€‚ æ—¶é—´å¤æ‚åº¦æ˜¯ O(logn) lower_bound()/upper_bound()unordered_set, unordered_map, unordered_multiset, unordered_multimap, å“ˆå¸Œè¡¨ å’Œä¸Šé¢ç±»ä¼¼ï¼Œå¢žåˆ æ”¹æŸ¥çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(1) ä¸æ”¯æŒ lower_bound()/upper_bound()ï¼Œ è¿­ä»£å™¨çš„++ï¼Œ--bitset, åœ§ä½ bitset&lt;10000&gt; s; ~, &amp;, |, ^ &gt;&gt;, &lt;&lt; ==, != [] count() è¿”å›žæœ‰å¤šå°‘ä¸ª1 any() åˆ¤æ–­æ˜¯å¦è‡³å°‘æœ‰ä¸€ä¸ª1 none() åˆ¤æ–­æ˜¯å¦å…¨ä¸º0 set() æŠŠæ‰€æœ‰ä½ç½®æˆ1 set(k, v) å°†ç¬¬kä½å˜æˆv reset() æŠŠæ‰€æœ‰ä½å˜æˆ0 flip() ç­‰ä»·äºŽ~ flip(k) æŠŠç¬¬kä½å–å æ³¨æ„ 1234567 #include&lt;queue&gt;queue&lt;Node *&gt; q;q.push(nullptr);q.push(nullptr);// è¿™ä¸ªæ—¶å€™ q.empty() æ˜¯0ï¼Œ ä½†æ˜¯ q.size() æ˜¯ 2ï¼Œæ‰€ä»¥å½“æœ‰ç©ºæŒ‡é’ˆçš„æ—¶å€™ï¼Œæ³¨æ„ä¸€ä¸‹ empty() å’Œsize() çš„åŒºåˆ« C++ STLä¸­æœ€åŸºæœ¬ä»¥åŠæœ€å¸¸ç”¨çš„ç±»æˆ–å®¹å™¨æ— éžå°±æ˜¯ä»¥ä¸‹å‡ ä¸ªï¼š vector C++ STLä¸­çš„vectorå¥½æ¯”æ˜¯Cè¯­è¨€ä¸­çš„æ•°ç»„ï¼Œä½†æ˜¯vectoråˆå…·æœ‰æ•°ç»„æ²¡æœ‰çš„ä¸€äº›é«˜çº§åŠŸèƒ½ã€‚ä¸Žæ•°ç»„ç›¸æ¯”ï¼Œvectorå°±æ˜¯ä¸€ä¸ªå¯ä»¥ä¸ç”¨å†åˆå§‹åŒ–å°±å¿…é¡»åˆ¶å®šå¤§å°çš„è¾¹é•¿æ•°ç»„ï¼Œå½“ç„¶äº†ï¼Œå®ƒè¿˜æœ‰è®¸å¤šé«˜çº§åŠŸèƒ½ã€‚ éœ€è¦åŒ…å«å¤´æ–‡ä»¶ã€‚ä¸‹é¢æ˜¯å¸¸è§çš„åˆå§‹åŒ–çš„æ“ä½œ 1234567891011#include &lt;vector&gt;vector&lt;int&gt; v1;vector&lt;father&gt; v2;vector&lt;string&gt; v3;vector&lt;vector&lt;int&gt; &gt;; //æ³¨æ„ç©ºæ ¼ã€‚è¿™é‡Œç›¸å½“äºŽäºŒç»´æ•°ç»„int a[n][n];vector&lt;int&gt; v5 = &#123; 1,2,3,4,5 &#125;; //åˆ—è¡¨åˆå§‹åŒ–,æ³¨æ„ä½¿ç”¨çš„æ˜¯èŠ±æ‹¬å·vector&lt;string&gt; v6 = &#123; "hi","my","name","is","lee" &#125;;vector&lt;int&gt; v7(5, -1); //åˆå§‹åŒ–ä¸º-1,-1,-1,-1,-1ã€‚ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯æ•°ç›®ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯è¦åˆå§‹åŒ–çš„å€¼vector&lt;string&gt; v8(3, "hi");vector&lt;int&gt; v9(10); //é»˜è®¤åˆå§‹åŒ–ä¸º0vector&lt;int&gt; v10(4); //é»˜è®¤åˆå§‹åŒ–ä¸ºç©ºå­—ç¬¦ä¸² æ¯”å¦‚ä¸‹é¢çš„ä»£ç æ˜¯é”™è¯¯çš„ï¼Œä½†æ˜¯ç¼–è¯‘å™¨ä¸ä¼šæŠ¥é”™ï¼Œå°±åƒæ˜¯æ•°ç»„è¶Šç•Œã€‚ 12vector&lt;int&gt; vec;vec[0] = 1; //é”™è¯¯ï¼ STLä¸­vectorçš„å®žçŽ°åŽŸç†ï¼švectorçš„æ•°æ®å®‰æŽ’ä»¥åŠæ“ä½œæ–¹å¼ä¸Žarrayéžå¸¸ç±»ä¼¼ã€‚ä¸¤è€…çš„å”¯ä¸€å·®åˆ«åœ¨äºŽç©ºé—´çš„è¿ç”¨çš„çµæ´»æ€§ã€‚arrayæ˜¯é™æ€ç©ºé—´ï¼Œä¸€æ—¦é…ç½®å¥½äº†å°±ä¸èƒ½å†æ”¹å˜äº†ã€‚å¦‚æžœç¨‹åºéœ€è¦ä¸€ä¸ªæ›´å¤§ç©ºé—´çš„arrayï¼Œåªèƒ½è‡ªå·±å†ç”³è¯·ä¸€ä¸ªæ›´å¤§çš„arrayï¼Œç„¶åŽå°†ä»¥å‰arrayä¸­çš„å†…å®¹å…¨éƒ¨æ‹·è´åˆ°æ–°çš„arrayä¸­ã€‚vectoræ˜¯åŠ¨æ€ç©ºé—´ï¼Œéšç€å…ƒç´ çš„åŠ å…¥ï¼Œå®ƒçš„å†…éƒ¨æœºåˆ¶ä¼šè‡ªåŠ¨æ‰©å……ç©ºé—´ä»¥å®¹çº³æ–°çš„å…ƒç´ ã€‚vectorçš„å…³é”®æŠ€æœ¯åœ¨äºŽå…¶å¯¹å¤§å°çš„æŽ§åˆ¶ä»¥åŠé‡æ–°é…ç½®æ—¶çš„æ•°æ®ç§»åŠ¨æ•ˆçŽ‡ã€‚ ä¸ºäº†é™ä½Žç©ºé—´é…ç½®æ—¶å€™çš„é€Ÿåº¦ï¼Œvectorå®žé™…é…ç½®çš„å¤§å°å¯èƒ½æ¯”å®¢æˆ·ç«¯éœ€æ±‚é‡æ›´å¤§ä¸€äº›ï¼Œä»¥å¤‡å°†æ¥å¯èƒ½çš„æ‰©å……ã€‚æ‰©å……ç©ºé—´éœ€è¦ç»è¿‡çš„æ­¥éª¤ï¼šé‡æ–°é…ç½®ç©ºé—´ï¼Œå…ƒç´ ç§»åŠ¨ï¼Œé‡Šæ”¾æ—§å†…å­˜ç©ºé—´ã€‚ vector ä¸­çš„æŸ¥è¯¢æ“ä½œ vectoræœ€å¸¸ç”¨çš„å¢žåˆ æ“ä½œ string åœ¨c è¯­è¨€ä¸­è¿™æ ·ä½¿ç”¨å­—ç¬¦ä¸² 12345678910 char* s1 = &quot;Hello SYSU!&quot;; //åˆ›å»ºæŒ‡é’ˆæŒ‡å‘å­—ç¬¦ä¸²å¸¸é‡ï¼Œè¿™æ®µå­—ç¬¦ä¸²æˆ‘ä»¬æ˜¯ä¸èƒ½ä¿®æ”¹çš„//æƒ³è¦åˆ›å»º å¯ä»¥ä¿®æ”¹çš„å­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ•°ç»„åˆ†é…ç©ºé—´char s2[20] = &quot;Hello SYSU!&quot;;//æˆ–è€…è¿™æ ·char s3[] = &quot;Hello SYSU!&quot;;//å½“ç„¶æˆ‘ä»¬ä¹Ÿå¯ä»¥åŠ¨æ€åˆ†é…å†…å­˜char* s4 = (char*)malloc(20ï¼‰;gets(s4); åœ¨ C++ ä¸­string ç±»åž‹æ˜¯å˜é•¿çš„ï¼Œåœ¨å¤´æ–‡ä»¶ string ä¸­ã€‚ç”¨stringåˆå§‹åŒ–å­—ç¬¦ä¸²åˆ†ä¸¤ç±»ï¼šç”¨â€œ=â€å·å°±æ˜¯æ‹·è´åˆå§‹åŒ–ï¼Œå¦åˆ™å°±æ˜¯ç›´æŽ¥åˆå§‹åŒ–ã€‚ 12345678 #include &lt;string&gt; string s1;//åˆå§‹åŒ–å­—ç¬¦ä¸²ï¼Œç©ºå­—ç¬¦ä¸²string s2 = s1; //æ‹·è´åˆå§‹åŒ–ï¼Œæ·±æ‹·è´å­—ç¬¦ä¸²string s3 = &quot;I am Yasuo&quot;; //ç›´æŽ¥åˆå§‹åŒ–ï¼Œs3å­˜äº†å­—ç¬¦ä¸²string s4(10, &apos;a&apos;); //s4å­˜çš„å­—ç¬¦ä¸²æ˜¯aaaaaaaaaastring s5(s4); //æ‹·è´åˆå§‹åŒ–ï¼Œæ·±æ‹·è´å­—ç¬¦ä¸²string s6(&quot;I am Ali&quot;); //ç›´æŽ¥åˆå§‹åŒ–string s7 = string(6, &apos;c&apos;); //æ‹·è´åˆå§‹åŒ–ï¼Œcccccc string ä¸­çš„IO æ“ä½œ ä½¿ç”¨cinè¯»å…¥å­—ç¬¦ä¸²æ—¶ï¼Œé‡åˆ°ç©ºæ ¼æˆ–è€…åˆ†éš”ç¬¦ï¼ˆ\nï¼‰å°±åœæ­¢è¯»å–ã€‚æ¯”å¦‚ç¨‹åºè¾“å…¥çš„æ˜¯ 1&quot; Hello World&quot; è¿™ä¸ªæ—¶å€™å¯ä»¥ä½¿ç”¨å¦‚ä¸‹çš„è¯­å¥è¿›è¡Œè¯»å…¥1cin&gt;&gt;s1&gt;&gt;s2; helloå­˜åœ¨s1é‡Œï¼Œworldå­˜åœ¨s2é‡Œäº†ã€‚å¦‚æžœæƒ³è¦å­˜å‚¨ä¸€è¡Œå†…å®¹è€Œä¸æ˜¯å•ä¸ªçš„ï¼Œé‚£ä¹ˆä½¿ç”¨ä»¥ä¸‹çš„è¯­å¥123string str;getline(cin, str);cout &lt;&lt; str &lt;&lt; endl; å½“æŠŠstringå¯¹è±¡å’Œå­—ç¬¦é¢å€¼åŠå­—ç¬¦ä¸²é¢å€¼æ··åœ¨ä¸€æ¡è¯­å¥ä¸­ä½¿ç”¨æ—¶ï¼Œå¿…é¡»ç¡®ä¿+çš„ä¸¤ä¾§çš„è¿ç®—å¯¹è±¡è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯string 1234string s1 = s2 + &quot;, &quot;; //æ­£ç¡®string s3 = &quot;s &quot; + &quot;, &quot;; //é”™è¯¯string s4 = &quot;hello&quot; + &quot;, &quot; + s1; //é”™è¯¯string s5 = s1 + &quot;hello &quot; + &quot;, &quot;; //æ”¹ä¸€ä¸‹é¡ºåºï¼Œs1æ”¾å‰å¤´ï¼Œæ­£ç¡®äº†ï¼Œæ³¨æ„ç†è§£=å·å³è¾¹çš„è¿ç®—é¡ºåº å¤„ç†string ç±»åž‹çš„å­—ç¬¦ npos è¡¨ç¤º non-position åœ¨cpp ä¸­è¡¨ç¤ºä¸å¯è¾¾çš„åœ°å€ï¼Œå¦‚æžœæ‰¾ä¸è§positionï¼Œé‚£ä¹ˆå°±è¿”å›žè¿™ä¸ªå€¼ã€‚ä¸ä¸€å®šæ˜¯ -1ï¼Œåœ¨mac ä¸­è‡³å°‘ä¸æ˜¯ã€‚ 12345 for (int i = 0; i &lt; s3.size(); i++)&#123; cout &lt;&lt; s3[i] &lt;&lt; endl; s3[i] = 's';&#125; stringè¿˜æœ‰ä¸€äº›å¾ˆå¥½ç”¨çš„å‡½æ•°ï¼Œæ¯”å¦‚æ‰¾å­ä¸² 1234567891011121314151617 #include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string str ="abcddd"; char ch ='e'; auto position =str.find(ch, 0); if(position != str.npos) cout &lt;&lt; position&lt;&lt; endl; else cout &lt;&lt; "could not find "&lt;&lt; endl; return 0;&#125; string ä¸­çš„æŸ¥è¯¢æ“ä½œ set setè·Ÿvectorå·®ä¸å¤šï¼Œå®ƒè·Ÿvectorçš„å”¯ä¸€åŒºåˆ«å°±æ˜¯ï¼Œseté‡Œé¢çš„å…ƒç´ æ˜¯æœ‰åºçš„ä¸”å”¯ä¸€çš„ï¼Œåªè¦ä½ å¾€seté‡Œæ·»åŠ å…ƒç´ ï¼Œå®ƒå°±ä¼šè‡ªåŠ¨æŽ’åºï¼Œè€Œä¸”ï¼Œå¦‚æžœä½ æ·»åŠ çš„å…ƒç´ seté‡Œé¢æœ¬æ¥å°±å­˜åœ¨ï¼Œé‚£ä¹ˆè¿™æ¬¡æ·»åŠ æ“ä½œå°±ä¸æ‰§è¡Œã€‚è¦æƒ³ç”¨setå…ˆåŠ ä¸ªå¤´æ–‡ä»¶setã€‚ å¸¸ç”¨çš„æ“ä½œ set å’Œ map éƒ½æ˜¯æœ‰åºä¸”æ²¡æœ‰é‡å¤å…ƒç´ çš„ã€‚å¦‚æžœä¸å¼ºè°ƒæœ‰åºï¼Œé‚£ä¹ˆæ˜¯å¯ä»¥ä½¿ç”¨ unordered_map å’Œ unordered_set è¿™ä¸¤ä¸ªè¿›è¡Œå®šä¹‰çš„ã€‚ 1234567891011121314151617181920212223# è®¿é—®å®¹é‡empty() //åˆ¤æ–­setå®¹å™¨æ˜¯å¦ä¸ºç©ºsize() //è¿”å›žå½“å‰setå®¹å™¨ä¸­çš„å…ƒç´ ä¸ªæ•°max_size() //è¿”å›žsetå®¹å™¨å¯èƒ½åŒ…å«çš„å…ƒç´ æœ€å¤§ä¸ªæ•°# å…ƒç´ çš„è®¿é—®begin() //è¿”å›žsetå®¹å™¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ end() //è¿”å›žsetå®¹å™¨çš„æœ€åŽä¸€ä¸ªå…ƒç´ # ä¿®æ”¹erase(iterator) //åˆ é™¤å®šä½å™¨iteratoræŒ‡å‘çš„å€¼erase(first,second) //åˆ é™¤å®šä½å™¨firstå’Œsecondä¹‹é—´çš„å€¼erase(key_value) //åˆ é™¤é”®å€¼key_valueçš„å€¼insert(key_value) //å°†key_valueæ’å…¥åˆ°setä¸­ï¼ˆæ¯”è¾ƒå¸¸è§ï¼‰insert(first,second) //å°†å®šä½å™¨firståˆ°secondä¹‹é—´çš„å…ƒç´ æ’å…¥åˆ°setä¸­# ä½¿ç”¨è¿­ä»£å™¨è¿›è¡ŒéåŽ†set&lt;int&gt;::iterator it; //å£°æ˜Žè¿­ä»£å™¨for(it = s.begin(); it!=s.end(); it++) //è¿­ä»£è¾“å‡º &#123; cout&lt;&lt;*it&lt;&lt;endl; &#125; list map æŸ¥çœ‹æ˜¯å¦å­˜åœ¨æŸä¸ªkeyï¼Œå¯ä»¥ä½¿ç”¨ cout åˆ¤æ–­ã€‚ 12345678if (m1.count("Lee"))&#123; cout &lt;&lt; "Lee is in m1!" &lt;&lt; endl;&#125;else&#123; cout &lt;&lt; "Lee do not exist!" &lt;&lt; endl;&#125; C++ STLå¿«é€Ÿå…¥é—¨ ä»‹ç» C++ ä¸­æ ‡å‡†æ¨¡æ¿åº“ (standard template libary) STL C++ ä¸­çš„å¤§æ ¹å †å’Œå°æ ¹å † ä½¿ç”¨ C++ ä¸­çš„ä¼˜å…ˆé˜Ÿåˆ—å®žçŽ° å¤§æ ¹å †å’Œå°æ ¹å †.ä¸Žå‰é¢FIFOç»“æž„çš„é˜Ÿåˆ—ä¸åŒï¼Œä¼˜å…ˆé˜Ÿåˆ—ä¸­å…ƒç´ å‡ºé˜Ÿåˆ—çš„é¡ºåºç”±å…ƒç´ çš„ä¼˜å…ˆçº§å†³å®šã€‚ä»Žä¼˜å…ˆé˜Ÿåˆ—ä¸­åˆ é™¤å…ƒç´ æ˜¯æ ¹æ®ä¼˜å…ˆæƒé«˜æˆ–ä½Žçš„æ¬¡åºï¼Œè€Œä¸æ˜¯å…ƒç´ è¿›å…¥é˜Ÿåˆ—çš„æ¬¡åºã€‚å¯¹äºŽæœ€å¤§ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆmax priority queueï¼‰ï¼ŒæŸ¥æ‰¾æ“ä½œç”¨æ¥æœç´¢ä¼˜å…ˆæƒæœ€å¤§çš„å…ƒç´ ï¼Œåˆ é™¤æ“ä½œç”¨æ¥åˆ é™¤è¯¥å…ƒç´ ã€‚ä¼˜å…ˆæƒé˜Ÿåˆ—ä¸­çš„å…ƒç´ å¯ä»¥æœ‰ç›¸åŒçš„ä¼˜å…ˆæƒï¼ŒæŸ¥æ‰¾ä¸Žåˆ é™¤æ“ä½œå¯æ ¹æ®ä»»æ„ä¼˜å…ˆæƒè¿›è¡Œã€‚(ä¸ºä»€ä¹ˆä½¿ç”¨é˜Ÿåˆ—æ¥å®žçŽ°å¤§æ ¹å †å’Œå°æ ¹å †å‘¢ï¼Ÿ å› ä¸ºé˜Ÿåˆ—çš„å‡ºé˜Ÿå’Œå…¥é˜Ÿé¡ºåºå’Œå¤§æ ¹å †å¼¹å‡ºå’ŒåŠ å…¥çš„é¡ºåºç±»ä¼¼) 123priority_queue&lt;Type, Container, Functional&gt;Typeä¸ºæ•°æ®ç±»åž‹ï¼Œ Containerä¸ºä¿å­˜æ•°æ®çš„å®¹å™¨ï¼ŒFunctionalä¸ºå…ƒç´ æ¯”è¾ƒæ–¹å¼ã€‚å¦‚æžœä¸å†™åŽä¸¤ä¸ªå‚æ•°ï¼Œé‚£ä¹ˆå®¹å™¨é»˜è®¤ç”¨çš„æ˜¯vectorï¼Œæ¯”è¾ƒæ–¹å¼é»˜è®¤ç”¨operator&lt;ï¼Œä¹Ÿå°±æ˜¯ä¼˜å…ˆé˜Ÿåˆ—æ˜¯å¤§é¡¶å †ï¼Œé˜Ÿå¤´å…ƒç´ æœ€å¤§ã€‚ å¤§æ ¹å † 12345//æž„é€ ä¸€ä¸ªç©ºçš„ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆæ­¤ä¼˜å…ˆé˜Ÿåˆ—é»˜è®¤ä¸ºå¤§é¡¶å †ï¼‰priority_queue&lt;int&gt; big_heap; //å¦ä¸€ç§æž„å»ºå¤§é¡¶å †çš„æ–¹æ³•priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; big_heap2; å°æ ¹å † 12//æž„é€ ä¸€ä¸ªç©ºçš„ä¼˜å…ˆé˜Ÿåˆ—,æ­¤ä¼˜å…ˆé˜Ÿåˆ—æ˜¯ä¸€ä¸ªå°é¡¶å †priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; small_heap; æ„æ€æ˜¯&lt;ç±»åž‹,&lt;å­˜å‚¨æ–¹å¼&gt;,&lt;æ¯”è¾ƒå‡½æ•°&gt; &gt; æ³¨æ„å¦‚æžœä½¿ç”¨ &gt; less å’Œ &gt; greater ï¼Œé‚£ä¹ˆæ˜¯éœ€è¦åŒ…å«å¤´é—®é¢˜ï¼š 1234567891011#include &lt;functional&gt;/** addition equal_to ç›¸ç­‰ not_equal_to ä¸ç›¸ç­‰ less å°äºŽ greater å¤§äºŽ less_equal å°äºŽç­‰äºŽ greater_equal å¤§äºŽç­‰ è¿™äº›åœ¨æ‰€æœ‰çš„æŽ’åºç®—æ³•ä¸­åŒæ ·é€‚ç”¨ */ c++ä¸­1234char ch =&apos;a&apos;;string str =&quot;a&quot;;// æ³¨æ„å•å¼•å·å’ŒåŒå¼•å·çš„åŒºåˆ« C++ queue å’Œ dequeçš„åŒºåˆ« queueå‡½æ•° ä¸€ç§å…ˆè¿›å…ˆå‡º(FIFO)çš„æ•°æ®ç»“æž„ã€‚ å¸¸è§çš„æ“ä½œ 123456789101112// è®¿é—®å‡½æ•°front() è¿”å›žç¬¬ä¸€ä¸ªå…ƒç´ back() è¿”å›žæœ€åŽä¸€ä¸ªå…ƒç´ // ä¿®æ”¹å‡½æ•°pop() åˆ é™¤ç¬¬ä¸€ä¸ªå…ƒç´ push() åœ¨æœ«å°¾åŠ å…¥ä¸€ä¸ªå…ƒç´ // åˆ¤æ–­å‡½æ•°empty() å¦‚æžœé˜Ÿåˆ—ç©ºåˆ™è¿”å›žçœŸsize() è¿”å›žé˜Ÿåˆ—ä¸­å…ƒç´ çš„ä¸ªæ•° å¤ä¹ åˆ°è¿™é‡Œäº†dequeæ˜¯åŒå‘é˜Ÿåˆ—Double ended queue, å¯ä»¥åœ¨ä¸¤æ®µæ‰©å±•å’Œæ”¶ç¼©ï¼Œæœ‰ç€å’Œ vector ç›¸ä¼¼çš„æ€§è´¨ï¼Œä½†å¹¶ä¸æ˜¯ä¸¥æ ¼è¿žç»­å­˜å‚¨çš„ã€‚å¸¸è§çš„æ“ä½œå¦‚ä¸‹: 1234567891011121314151617181920// è¿™é‡Œé¢å­˜å‚¨çš„æ˜¯index ä¿¡æ¯ï¼Œè€Œä¸æ˜¯æ•°å€¼ä¿¡æ¯// å¢žåŠ å‡½æ•°void push_front(const T&amp; x):åŒç«¯é˜Ÿåˆ—å¤´éƒ¨å¢žåŠ ä¸€ä¸ªå…ƒç´ Xvoid push_back(const T&amp; x):åŒç«¯é˜Ÿåˆ—å°¾éƒ¨å¢žåŠ ä¸€ä¸ªå…ƒç´ x// åˆ é™¤å‡½æ•°void pop_front():åˆ é™¤åŒç«¯é˜Ÿåˆ—ä¸­æœ€å‰ä¸€ä¸ªå…ƒç´ void pop_back():åˆ é™¤åŒç«¯é˜Ÿåˆ—ä¸­æœ€åŽä¸€ä¸ªå…ƒç´ Iterator erase(iterator it):åˆ é™¤åŒç«¯é˜Ÿåˆ—ä¸­çš„æŸä¸€ä¸ªå…ƒç´ void clear():æ¸…ç©ºåŒç«¯é˜Ÿåˆ—ä¸­çš„å…ƒç´ // åˆ¤æ–­å‡½æ•°bool empty() const:å‘é‡æ˜¯å¦ä¸ºç©ºï¼Œè‹¥true,åˆ™å‘é‡ä¸­æ— å…ƒç´ // å¤§å°å‡½æ•°Int size() const:è¿”å›žå‘é‡ä¸­å…ƒç´ çš„ä¸ªæ•° ç®€å•çš„å®žçŽ°æ¨¡æ¿ã€‚ 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;int main()&#123; stack&lt;double&gt; s; queue&lt;double&gt; q; for(int i =0; i&lt;10 ; i++) s.push(i); while ( !s.empty()) &#123; cout &lt;&lt; s.top()&lt;&lt;endl; s.pop(); &#125; for(int i =0; i&lt;10; i++) q.push(i); while ( !q.empty()) &#123; cout&lt;&lt; q.front()&lt;&lt; endl; q.pop(); &#125; return 0;&#125; queue æ˜¯å•å‘é˜Ÿåˆ—ï¼Œåªèƒ½åœ¨å°¾éƒ¨æ’å…¥ï¼Œåœ¨å¤´éƒ¨åˆ é™¤ï¼Œ ä¸€èˆ¬ä½¿ç”¨ vector è¿™ç±»æ•°ç»„è¿›è¡Œå®žçŽ°ï¼Œè¿žç»­ç©ºé—´ã€‚ deque æ˜¯åŒå‘é˜Ÿåˆ—ï¼Œå¯ä»¥åœ¨å¤´éƒ¨å’Œå°¾éƒ¨è¿›è¡Œåˆ é™¤å’Œæ’å…¥æ“ä½œï¼Œä¸€èˆ¬å­˜å‚¨åœ°å€ä¸æ˜¯è¿žç»­çš„ã€‚ è¿­ä»£å™¨(iterator)æ˜¯ä¸€ä¸­æ£€æŸ¥å®¹å™¨å†…å…ƒç´ å¹¶éåŽ†å…ƒç´ çš„æ•°æ®ç±»åž‹ã€‚ 123456789101112131415#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; vector&lt;int&gt; ivec; ivec.push_back(1); ivec.push_back(2); ivec.push_back(3); ivec.push_back(4); for(vector&lt;int&gt;::iterator iter = ivec.begin();1. iter != ivec.end(); ++iter) cout &lt;&lt; *iter &lt;&lt; endl; return 0;&#125; set, map, multiset, multimap, åŸºäºŽå¹³è¡¡äºŒå‰æ ‘ï¼ˆçº¢é»‘æ ‘ï¼‰ï¼ŒåŠ¨æ€ç»´æŠ¤æœ‰åºåºåˆ—set/multisetbitset ï¼ˆå¯¹è¿™ä¸ªè®²è§£æ²¡æœ‰å¾ˆå¤§çš„æ„Ÿè§‰ï¼‰ mapå’Œsetå®¹å™¨ä¸­ï¼Œä¸€ä¸ªé”®åªå¯¹åº”ä¸€ä¸ªå®žä¾‹ã€‚è€Œåœ¨multimapå’Œmultisetä¸­ï¼Œä¸€ä¸ªé”®å¯ä»¥å¯¹åº”å¤šä¸ªå®žä¾‹ï¼Œä¾‹å¦‚æ¯ä¸ªäººéƒ½æœ‰ä¸€ä¸ªç”µè¯è”ç³»äººåˆ—è¡¨ï¼Œåˆ—è¡¨ä¸­è‚¯å®šä¸æ­¢ä¸€ä¸ªäººã€‚ æœ‰åºå…³è”å®¹å™¨ (æŒ‰ key å€¼æŽ’åº) map: key-value pairs set: åªæœ‰ key å€¼ multimap: å…è®¸ key é‡å¤çš„ mapï¼Œå®šä¹‰åœ¨ä¸­ multiset: å…è®¸ key é‡å¤çš„ setï¼Œå®šä¹‰åœ¨ä¸­ æ— åºå…³è”å®¹å™¨ unordered_map: é€šè¿‡ hash ç»„ç»‡çš„ map unordered_set: é€šè¿‡ hash ç»„ç»‡çš„ set unordered_multimap: é€šè¿‡ hash ç»„ç»‡çš„ multimapï¼Œå®šä¹‰åœ¨ä¸­ unordered_multiset: é€šè¿‡ hash ç»„ç»‡çš„ multisetï¼Œå®šä¹‰åœ¨ä¸­ cpp ä¸­æ ˆå’Œé˜Ÿåˆ— éœ€è¦åœ¨å¤´æ–‡ä»¶ä¸­ 1#include&lt;stack&gt; åŸºæœ¬æ“ä½œï¼š123456stackçš„åŸºæœ¬æ“ä½œæœ‰ï¼šå¯¹äºŽstack&lt;int&gt; s å…¥ æ ˆï¼š s.push(x); å‡º æ ˆï¼š s.pop(); //å‡ºæ ˆåªæ˜¯åˆ é™¤æ ˆé¡¶å…ƒç´ ï¼Œå¹¶ä¸è¿”å›žè¯¥å…ƒç´ è®¿é—®æ ˆé¡¶å…ƒç´ ï¼š s.top();åˆ¤ æ–­ æ ˆ ç©ºï¼š s.empty();//æ ˆç©ºæ—¶ï¼Œè¿”å›žtrueæ ˆä¸­çš„å…ƒç´ ä¸ªæ•°ï¼šs.size(); ä½¿ç”¨é˜Ÿåˆ— 1#include&lt;queue&gt; å¸¸è§çš„æ“ä½œ123456 å…¥ é˜Ÿï¼šq.push(x); // å°†x æŽ¥åˆ°é˜Ÿåˆ—çš„æœ«ç«¯ã€‚ å‡º é˜Ÿï¼šq.pop(); //å¼¹å‡ºé˜Ÿåˆ—çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œæ³¨æ„ï¼Œå¹¶ä¸ä¼šè¿”å›žè¢«å¼¹å‡ºå…ƒç´ çš„å€¼ã€‚è®¿é—®é˜Ÿé¦–å…ƒç´ ï¼šq.front(); //å³æœ€æ—©è¢«åŽ‹å…¥é˜Ÿåˆ—çš„å…ƒç´ ã€‚è®¿é—®é˜Ÿå°¾å…ƒç´ ï¼šq.back(); //å³æœ€åŽè¢«åŽ‹å…¥é˜Ÿåˆ—çš„å…ƒç´ ã€‚ åˆ¤æ–­é˜Ÿåˆ—ç©º q.empty(); //å½“é˜Ÿåˆ—ç©ºæ—¶ï¼Œè¿”å›žtrueã€‚é˜Ÿåˆ—ä¸­çš„å…ƒç´ ä¸ªæ•°ï¼šq.size(); pair çš„å®žçŽ°ï¼š pairçš„å®žçŽ°æ˜¯ä¸€ä¸ªç»“æž„ä½“ï¼Œä¸»è¦çš„ä¸¤ä¸ªæˆå‘˜å˜é‡æ˜¯first second å› ä¸ºæ˜¯ä½¿ç”¨structä¸æ˜¯classï¼Œæ‰€ä»¥å¯ä»¥ç›´æŽ¥ä½¿ç”¨pairçš„æˆå‘˜å˜é‡ã€‚ åˆå§‹åŒ–å’Œèµ‹å€¼ï¼šä½¿ç”¨ {} å’Œ make_pairåˆ›å»ºçš„æ˜¯ä¸€ä¸ªpairå¯¹è±¡ã€‚ è®¿é—®æ–¹å¼ï¼špairæ˜¯å•ä¸ªæ•°æ®å¯¹çš„æ“ä½œï¼Œpairæ˜¯ä¸€structç±»åž‹ï¼Œæœ‰ä¸¤ä¸ªæˆå‘˜å˜é‡ï¼Œé€šè¿‡first,secondæ¥è®¿é—®ï¼Œç”¨çš„æ˜¯â€œ.â€è®¿é—®ã€‚ pairçš„ä½¿ç”¨èŒƒå›´ï¼š STLä¸­çš„mapå°±æ˜¯å°†keyå’Œvalueæ”¾åœ¨ä¸€èµ·æ¥ä¿å­˜ã€‚ å¦ä¸€ä¸ªåº”ç”¨æ˜¯ï¼Œå½“ä¸€ä¸ªå‡½æ•°éœ€è¦è¿”å›ž2ä¸ªæ•°æ®çš„æ—¶å€™ï¼Œå¯ä»¥é€‰æ‹©pairã€‚ å†…å­˜ç®¡ç† å†…å­˜åˆ†é…æ–¹å¼ åœ¨C++ä¸­ï¼Œå†…å­˜åˆ†æˆ5ä¸ªåŒºï¼Œä»–ä»¬åˆ†åˆ«æ˜¯å †ã€æ ˆã€è‡ªç”±å­˜å‚¨åŒºã€å…¨å±€/é™æ€å­˜å‚¨åŒºå’Œå¸¸é‡å­˜å‚¨åŒºã€‚ æ ˆï¼šåœ¨æ‰§è¡Œå‡½æ•°æ—¶ï¼Œå‡½æ•°å†…å±€éƒ¨å˜é‡çš„å­˜å‚¨å•å…ƒéƒ½å¯ä»¥åœ¨æ ˆä¸Šåˆ›å»ºï¼Œå‡½æ•°æ‰§è¡Œç»“æŸæ—¶è¿™äº›å­˜å‚¨å•å…ƒè‡ªåŠ¨è¢«é‡Šæ”¾ã€‚æ ˆå†…å­˜åˆ†é…è¿ç®—å†…ç½®äºŽå¤„ç†å™¨çš„æŒ‡ä»¤é›†ä¸­ï¼Œæ•ˆçŽ‡å¾ˆé«˜ï¼Œä½†æ˜¯åˆ†é…çš„å†…å­˜å®¹é‡æœ‰é™ã€‚ å †ï¼šå°±æ˜¯é‚£äº›ç”± newåˆ†é…çš„å†…å­˜å—ï¼Œä»–ä»¬çš„é‡Šæ”¾ç¼–è¯‘å™¨ä¸åŽ»ç®¡ï¼Œç”±æˆ‘ä»¬çš„åº”ç”¨ç¨‹åºåŽ»æŽ§åˆ¶ï¼Œä¸€èˆ¬ä¸€ä¸ªnewå°±è¦å¯¹åº”ä¸€ä¸ª deleteã€‚å¦‚æžœç¨‹åºå‘˜æ²¡æœ‰é‡Šæ”¾æŽ‰ï¼Œé‚£ä¹ˆåœ¨ç¨‹åºç»“æŸåŽï¼Œæ“ä½œç³»ç»Ÿä¼šè‡ªåŠ¨å›žæ”¶ã€‚ è‡ªç”±å­˜å‚¨åŒºï¼šå°±æ˜¯é‚£äº›ç”±mallocç­‰åˆ†é…çš„å†…å­˜å—ï¼Œä»–å’Œå †æ˜¯ååˆ†ç›¸ä¼¼çš„ï¼Œä¸è¿‡å®ƒæ˜¯ç”¨freeæ¥ç»“æŸè‡ªå·±çš„ç”Ÿå‘½çš„ã€‚ å…¨å±€/é™æ€å­˜å‚¨åŒºï¼šå…¨å±€å˜é‡å’Œé™æ€å˜é‡è¢«åˆ†é…åˆ°åŒä¸€å—å†…å­˜ä¸­ï¼Œåœ¨ä»¥å‰çš„Cè¯­è¨€ä¸­ï¼Œå…¨å±€å˜é‡åˆåˆ†ä¸ºåˆå§‹åŒ–çš„å’Œæœªåˆå§‹åŒ–çš„ï¼Œåœ¨C++é‡Œé¢æ²¡æœ‰è¿™ä¸ªåŒºåˆ†äº†ï¼Œä»–ä»¬å…±åŒå ç”¨åŒä¸€å—å†…å­˜åŒºã€‚ å¸¸é‡å­˜å‚¨åŒºï¼šè¿™æ˜¯ä¸€å—æ¯”è¾ƒç‰¹æ®Šçš„å­˜å‚¨åŒºï¼Œä»–ä»¬é‡Œé¢å­˜æ”¾çš„æ˜¯å¸¸é‡ï¼Œä¸å…è®¸ä¿®æ”¹ã€‚ æ ·ä¾‹åˆ†æžï¼š 12345678910111213141516#include&lt;iostream&gt;using namespace std;int a = 0; //å…¨å±€åˆå§‹åŒ–åŒºchar *p1; //å…¨å±€æœªåˆå§‹åŒ–åŒºint main()&#123; int b; //æ ˆ char s[] = "abc"; //æ ˆ char *p2; //æ ˆ char *p3 = "123456"; // 123456\0åœ¨å¸¸é‡åŒºï¼Œp3åœ¨æ ˆä¸Šã€‚ static int c =0; //å…¨å±€(é™æ€)åˆå§‹åŒ–åŒº p1 = (char *)malloc(10); p2 = (char *)malloc(20); 12: //åˆ†é…å¾—æ¥å¾—10å’Œ20å­—èŠ‚çš„åŒºåŸŸå°±åœ¨å †åŒºã€‚ strcpy(p1, "123456"); //123456\0æ”¾åœ¨å¸¸é‡åŒºï¼Œç¼–è¯‘å™¨å¯èƒ½ä¼šå°†å®ƒä¸Žp3æ‰€æŒ‡å‘çš„"123456"ä¼˜åŒ–æˆä¸€ä¸ªåœ°æ–¹ã€‚ return 0;&#125; aã€ä»£ç åŒº(code area) å­˜æ”¾å‡½æ•°ä½“(ç±»æˆå‘˜å‡½æ•°ã€å…¨å±€å‡½æ•°)çš„äºŒè¿›åˆ¶ä»£ç ã€‚bã€å…¨å±€åŒº(data area) é™æ€å­˜å‚¨åŒºï¼Œå­˜æ”¾å…¨å±€å˜é‡ã€é™æ€å˜é‡ï¼Œåˆå§‹åŒ–å˜é‡çš„åœ¨ä¸€å—åŒºåŸŸ(ä½Žåœ°å€åŒºåŸŸ)ï¼Œæœªåˆå§‹åŒ–å˜é‡åœ¨å¦ä¸€å—åŒºåŸŸ(é«˜åœ°å€åŒºåŸŸBSS)ã€‚æ–‡å­—å¸¸é‡ã€å­—ç¬¦ä¸²å¸¸é‡ï¼Œç¨‹åºç»“æŸåŽç”±ç³»ç»Ÿé‡Šæ”¾ã€‚cã€å †åŒº(heap area) ç”±ä½Žåœ°å€å‘é«˜åœ°å€å¢žé•¿ã€‚ä¸€èˆ¬newã€mallocåˆ†é…ï¼Œç”±ç¨‹åºå‘˜åˆ†é…å’Œé‡Šæ”¾ï¼Œåˆ†é…æ–¹å¼ç±»ä¼¼äºŽé“¾è¡¨ã€‚eã€æ ˆåŒº(stack area) ç”±é«˜åœ°å€å‘ä½Žåœ°å€å¢žé•¿ã€‚å­˜æ”¾å‡½æ•°å½¢å‚ã€å±€éƒ¨å˜é‡ã€è¿”å›žå€¼ç­‰ï¼Œç”±ç¼–è¯‘å™¨è‡ªåŠ¨åˆ†é…ã€é‡Šæ”¾ã€‚ å †å’Œæ ˆçš„åŒºåˆ«ï¼Ÿ ï¼ˆè¿™é‡Œå’Œæ•°æ®ç»“æž„ä¸­çš„å †æ ˆæ˜¯ä¸ä¸€æ ·çš„ï¼‰ ç©ºé—´å¤§å°ï¼šä¸€èˆ¬æ¥è®²åœ¨32ä½ç³»ç»Ÿä¸‹ï¼Œå †å†…å­˜å¯ä»¥è¾¾åˆ°4Gçš„ç©ºé—´ï¼Œä»Žè¿™ä¸ªè§’åº¦æ¥çœ‹å †å†…å­˜å‡ ä¹Žæ˜¯æ²¡æœ‰ä»€ä¹ˆé™åˆ¶çš„ã€‚ä½†æ˜¯å¯¹äºŽæ ˆæ¥è®²ï¼Œä¸€èˆ¬éƒ½æ˜¯æœ‰ä¸€å®šçš„ç©ºé—´å¤§å°çš„ï¼Œä¾‹å¦‚ï¼Œåœ¨VC6ä¸‹é¢ï¼Œé»˜è®¤çš„æ ˆç©ºé—´å¤§å°æ˜¯1Mï¼ˆå¯ä»¥ä¿®æ”¹ï¼‰ã€‚ ç”Ÿé•¿æ–¹å‘ï¼šå¯¹äºŽå †æ¥è®²ï¼Œç”Ÿé•¿æ–¹å‘æ˜¯å‘ä¸Šçš„ï¼Œä¹Ÿå°±æ˜¯å‘ç€å†…å­˜åœ°å€å¢žåŠ çš„æ–¹å‘ï¼›å¯¹äºŽæ ˆæ¥è®²ï¼Œå®ƒçš„ç”Ÿé•¿æ–¹å‘æ˜¯å‘ä¸‹çš„ï¼Œæ˜¯å‘ç€å†…å­˜åœ°å€å‡å°çš„æ–¹å‘å¢žé•¿ã€‚ ç¢Žç‰‡é—®é¢˜ï¼šå¯¹äºŽå †æ¥è®²ï¼Œé¢‘ç¹çš„new/deleteåŠ¿å¿…ä¼šé€ æˆå†…å­˜ç©ºé—´çš„ä¸è¿žç»­ï¼Œä»Žè€Œé€ æˆå¤§é‡çš„ç¢Žç‰‡ï¼Œä½¿ç¨‹åºæ•ˆçŽ‡é™ä½Žã€‚å¯¹äºŽæ ˆæ¥è®²ï¼Œåˆ™ä¸ä¼šå­˜åœ¨è¿™ä¸ªé—®é¢˜ï¼Œå› ä¸ºæ ˆæ˜¯å…ˆè¿›åŽå‡ºçš„é˜Ÿåˆ— ç®¡ç†æ–¹å¼ä¸åŒ å¯¹äºŽæ ˆæ¥è®²ï¼Œæ˜¯ç”±ç¼–è¯‘å™¨è‡ªåŠ¨ç®¡ç†ï¼Œæ— éœ€æˆ‘ä»¬æ‰‹å·¥æŽ§åˆ¶;å¯¹äºŽå †æ¥è¯´ï¼Œé‡Šæ”¾å·¥ä½œç”±ç¨‹åºå‘˜æŽ§åˆ¶ï¼Œå®¹æ˜“äº§ç”Ÿmemory leakã€‚ malloc / free å’Œ new/ delete çš„å…³ç³» mallocä¸Žfreeæ˜¯C++/Cè¯­è¨€çš„æ ‡å‡†åº“å‡½æ•°ï¼Œnew/deleteæ˜¯C++çš„è¿ç®—ç¬¦ã€‚å®ƒä»¬éƒ½å¯ç”¨äºŽç”³è¯·åŠ¨æ€å†…å­˜å’Œé‡Šæ”¾å†…å­˜ã€‚å¯¹äºŽéžå†…éƒ¨æ•°æ®ç±»åž‹çš„å¯¹è±¡è€Œè¨€ï¼Œå…‰ç”¨maloc/freeæ— æ³•æ»¡è¶³åŠ¨æ€å¯¹è±¡çš„è¦æ±‚ã€‚ å¯¹è±¡çš„åŠ¨æ€å†…å­˜åˆ†é… 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std; class Box&#123; public: Box() &#123; cout &lt;&lt; "è°ƒç”¨æž„é€ å‡½æ•°ï¼" &lt;&lt;endl; &#125; ~Box() &#123; cout &lt;&lt; "è°ƒç”¨æžæž„å‡½æ•°ï¼" &lt;&lt;endl; &#125;&#125;; int main( )&#123; Box* myBoxArray = new Box[4]; delete [] myBoxArray; // åˆ é™¤æ•°ç»„ return 0;&#125; å¦‚æžœè¦ä¸ºä¸€ä¸ªåŒ…å«å››ä¸ª Box å¯¹è±¡çš„æ•°ç»„åˆ†é…å†…å­˜ï¼Œæž„é€ å‡½æ•°å°†è¢«è°ƒç”¨ 4 æ¬¡ï¼ŒåŒæ ·åœ°ï¼Œå½“åˆ é™¤è¿™äº›å¯¹è±¡æ—¶ï¼Œæžæž„å‡½æ•°ä¹Ÿå°†è¢«è°ƒç”¨ç›¸åŒçš„æ¬¡æ•°ï¼ˆ4æ¬¡ï¼‰ã€‚ C/C++å†…å­˜ç®¡ç†è¯¦è§£ ä¸¤è€…çš„åŒºåˆ«ï¼š mallocçš„å…¨ç§°æ˜¯memory allocation,ä¸­æ–‡å«åšï¼šåŠ¨æ€å†…å­˜åˆ†é…ã€‚æ³¨æ„äº‹é¡¹ï¼š 1)ç”³è¯·å†…å­˜ç©ºé—´åŽï¼Œå¿…é¡»æ£€æŸ¥æ˜¯å¦åˆ†é…æˆåŠŸï¼› 2ï¼‰å½“ä¸éœ€è¦å†ä½¿ç”¨ç”³è¯·çš„å†…å­˜æ—¶ï¼Œè®°å¾—é‡Šæ”¾ï¼›é‡Šæ”¾åŽåº”è¯¥æŠŠæŒ‡å‘è¿™å—å†…å­˜çš„æŒ‡é’ˆæŒ‡å‘NULLï¼Œä»¥é˜²åŽé¢çš„ç¨‹åºä¸å°å¿ƒä½¿ç”¨äº†é‡ŽæŒ‡é’ˆ 3ï¼‰mallocå’Œfreeåº”è¯¥é…å¯¹ä½¿ç”¨ï¼›é‡Šæ”¾åªèƒ½é‡Šæ”¾ä¸€æ¬¡ï¼Œè‹¥é‡Šæ”¾ä¸¤æ¬¡æˆ–æ›´å¤šä¼šå‡ºçŽ°é”™è¯¯ï¼Œï¼ˆé‡Šæ”¾ç©ºæŒ‡é’ˆä¾‹å¤–ï¼Œé‡Šæ”¾ç©ºæŒ‡é’ˆå…¶å®žç­‰äºŽå•¥éƒ½æ²¡åšï¼Œé‡Šæ”¾ç©ºæŒ‡é’ˆå¤šå°‘æ¬¡éƒ½æ²¡æœ‰é—®é¢˜ï¼‰ 4ï¼‰mallocä»Žå †é‡Œé¢èŽ·å¾—å†…å­˜ï¼›å‡½æ•°è¿”å›žçš„æŒ‡é’ˆæŒ‡å‘å †é‡Œé¢çš„ä¸€å—å†…å­˜ã€‚æ“ä½œç³»ç»Ÿä¸­æœ‰ä¸€ä¸ªè®°å½•ç©ºé—²å†…å­˜åœ°å€çš„é“¾è¡¨ï¼Œå½“æ“ä½œç³»ç»Ÿæ”¶åˆ°ç¨‹åºçš„ç”³è¯·æ—¶ï¼Œå°±ä¼šéåŽ†é“¾è¡¨ï¼Œç„¶åŽå¯»æ‰¾ç¬¬ä¸€ä¸ªç©ºé—´å¤§äºŽæ‰€ç”³è¯·ç©ºé—´çš„å †ç»“ç‚¹ï¼Œç„¶åŽå°†è¯¥ç»“ç‚¹ä»Žç©ºé—²ç»“ç‚¹é“¾è¡¨ä¸­åˆ é™¤ï¼Œå¹¶å°†è¯¥ç»“ç‚¹åˆ†é…ç»™ç¨‹åºã€‚ newè¿ç®—ç¬¦ c++ä¸­ï¼Œç”¨newå’ŒdeleteåŠ¨æ€åˆ›å»ºå’Œé‡Šæ”¾æ•°ç»„æˆ–è€…å•ä¸ªå¯¹è±¡ã€‚åŠ¨æ€åˆ›å»ºå¯¹è±¡æ—¶ï¼Œåªéœ€è¦æŒ‡å®šå…¶æ•°æ®ç±»åž‹ï¼Œè€Œä¸å¿…ä¸ºè¯¥å¯¹è±¡å‘½åã€‚ c++ä¸­ï¼Œç”¨newå’ŒdeleteåŠ¨æ€åˆ›å»ºå’Œé‡Šæ”¾æ•°ç»„æˆ–è€…å•ä¸ªå¯¹è±¡ã€‚ åŠ¨æ€åˆ›å»ºå¯¹è±¡æ—¶ï¼Œåªéœ€è¦æŒ‡å®šå…¶æ•°æ®ç±»åž‹ï¼Œè€Œä¸å¿…ä¸ºè¯¥å¯¹è±¡å‘½åã€‚ 1ï¼‰ newè¿ç®—ç¬¦è¿”å›žæŒ‡å‘è¯¥åˆ›å»ºå¯¹è±¡çš„æŒ‡é’ˆã€‚ æˆ‘ä»¬å¯ä»¥é€šè¿‡æŒ‡é’ˆæ¥è®¿é—®æ­¤å¯¹è±¡ã€‚int *pi = new int ;æ­¤newè¡¨è¾¾å¼åœ¨å †åŒºä¸­åˆ†é…åˆ›å»ºäº†ä¸€ä¸ªæ•´åž‹å¯¹è±¡ï¼Œå¹¶è¿”å›žæ­¤å¯¹è±¡çš„åœ°å€ï¼Œå¹¶ç”¨è¯¥åœ°å€åˆå§‹åŒ–æŒ‡é’ˆpiã€‚ 2ï¼‰ åŠ¨æ€åˆ›å»ºå¯¹è±¡çš„åˆå§‹åŒ– 2.1ï¼‰ åŠ¨æ€åˆ›å»ºçš„å¯¹è±¡å¯ä»¥ç”¨åˆå§‹åŒ–å˜é‡çš„æ–¹å¼åˆå§‹åŒ–ã€‚ int * pi = new int (100);//æŒ‡é’ˆpiæ‰€æŒ‡å‘çš„å¯¹è±¡åˆå§‹åŒ–ä¸º100 string ps = new string(10,â€™9â€™)//psä¸ºâ€œ9999999999â€ å¦‚æžœä¸æä¾›æ˜¾ç¤ºåˆå§‹åŒ–ï¼Œå¯¹äºŽç±»ç±»åž‹ï¼Œç”¨è¯¥ç±»çš„é»˜è®¤æž„é€ å‡½æ•°åˆå§‹åŒ–ï¼›è€Œå†…ç½®ç±»åž‹çš„å¯¹è±¡åˆ™æ— åˆå§‹åŒ–ã€‚ 2.2ï¼‰ å¯ä»¥å¯¹åŠ¨æ€åˆ›å»ºçš„å¯¹è±¡åšå€¼åˆå§‹åŒ–ï¼š int *pi = new int ();//åˆå§‹åŒ–ä¸º0ï¼› int *pi = new int ;//piæŒ‡å‘ä¸€ä¸ªæ²¡æœ‰åˆå§‹åŒ–çš„int string *ps = new string();//åˆå§‹åŒ–ä¸ºç©ºå­—ç¬¦ä¸²ï¼ˆå¯¹äºŽæä¾›äº†é»˜è®¤æž„é€ å‡½æ•°çš„ç±»åž‹ï¼Œæ²¡æœ‰å¿…è¦å¯¹å…¶å¯¹è±¡è¿›è¡Œå€¼åˆå§‹åŒ–ï¼‰ 3ï¼‰deleteæ’¤é”€åŠ¨æ€åˆ›å»ºçš„å¯¹è±¡ deleteè¡¨è¾¾å¼é‡Šæ”¾æŒ‡é’ˆæŒ‡å‘çš„åœ°å€ç©ºé—´ï¼› delete piï¼›//é‡Šæ”¾å•ä¸ªå¯¹è±¡ delete [ ] pi;//é‡Šæ”¾æ•°ç»„ å¦‚æžœæŒ‡é’ˆæŒ‡å‘çš„ä¸æ˜¯newåˆ†é…çš„å†…å­˜åœ°å€ï¼Œåˆ™ä½¿ç”¨deleteæ˜¯ä¸åˆæ³•çš„ã€‚ 4ï¼‰ deleteä¹‹åŽï¼Œé‡è®¾æŒ‡é’ˆçš„å€¼ delete pï¼›æ‰§è¡Œå®Œè¯¥è¯­å¥åŽï¼Œpå˜æˆäº†ä¸ç¡®å®šçš„æŒ‡é’ˆï¼Œå°½ç®¡på€¼æ²¡æœ‰æ˜Žç¡®å®šä¹‰ï¼Œä½†ä»ç„¶å­˜æ”¾äº†å®ƒä¹‹å‰æ‰€æŒ‡å¯¹è±¡çš„åœ°å€ï¼Œç„¶åŽpæ‰€æŒ‡çš„å†…å­˜å·²ç»è¢«é‡Šæ”¾äº†ï¼Œæ‰€ä»¥pä¸å†æœ‰æ•ˆã€‚æ­¤æ—¶ï¼Œè¯¥æŒ‡é’ˆå˜æˆäº†æ‚¬åž‚æŒ‡é’ˆï¼ˆæ‚¬åž‚æŒ‡é’ˆæŒ‡å‘æ›¾ç»å­˜æ”¾å¯¹è±¡çš„å†…å­˜ï¼Œä½†è¯¥å¯¹è±¡å·²ç»ä¸å­˜åœ¨äº†ï¼‰ã€‚æ‚¬åž‚æŒ‡é’ˆå¾€å¾€å¯¼è‡´ç¨‹åºé”™è¯¯ï¼Œè€Œä¸”å¾ˆéš¾æ£€æµ‹å‡ºæ¥ã€‚ ä¸€æ—¦åˆ é™¤äº†æŒ‡é’ˆæ‰€æŒ‡çš„å¯¹è±¡ï¼Œç«‹å³å°†æŒ‡é’ˆç½®ä¸º0ï¼Œè¿™æ ·å°±å¯ä»¥éžå¸¸æ¸…æ¥šçš„æŒ‡æ˜ŽæŒ‡é’ˆä¸å†æŒ‡å‘ä»»ä½•å¯¹è±¡ã€‚ï¼ˆé›¶å€¼æŒ‡é’ˆï¼šint * ip =0;ï¼‰ 3 mallocå’Œnewçš„åŒºåˆ«ï¼ˆ1ï¼‰new è¿”å›žæŒ‡å®šç±»åž‹æŒ‡é’ˆï¼Œå¹¶ä¸”å¯ä»¥è‡ªåŠ¨è®¡ç®—æ‰€éœ€è¦çš„å¤§å°ï¼›mallocéœ€è¦æ‰‹åŠ¨è®¡ç®—å­—èŠ‚æ•°ï¼Œå¹¶ä¸”åœ¨è¿”å›žåŽå¼ºåˆ¶ç±»åž‹è½¬æ¢ä¸ºå®žé™…ç±»åž‹çš„æŒ‡é’ˆã€‚ ï¼ˆ2ï¼‰mallocåªç®¡åˆ†é…å†…å­˜ï¼Œå¹¶ä¸èƒ½å¯¹æ‰€å¾—åˆ°çš„å†…å­˜è¿›è¡Œåˆå§‹åŒ–ï¼Œæ‰€ä»¥å¾—åˆ°çš„ä¸€ç‰‡æ–°å†…å­˜ä¸­ï¼Œå…¶å€¼å°†æ˜¯éšæœºçš„ï¼›newä¸ä»…åˆ†é…å†…å­˜ï¼Œè¿˜å¯¹å†…å­˜ä¸­çš„å¯¹è±¡è¿›è¡Œåˆå§‹åŒ–;freeåªç®¡é‡Šæ”¾å†…å­˜ï¼›deleteä¸ä»…é‡Šæ”¾å†…å­˜ï¼Œè¿˜ä¼šè°ƒç”¨å¯¹è±¡çš„æžæž„å‡½æ•°ï¼Œé”€æ¯å¯¹è±¡ã€‚ ï¼ˆ3ï¼‰ malloc/freeæ˜¯c++/cçš„æ ‡å‡†åº“å‡½æ•°ï¼Œå¤´æ–‡ä»¶ä¸ºstdlib.h;è€Œnew/deleteæ˜¯c++çš„è¿ç®—ç¬¦ã€‚ä»–ä»¬éƒ½å¯ç”¨äºŽç”³è¯·åŠ¨æ€å†…å­˜å’Œé‡Šæ”¾å†…å­˜ã€‚ ï¼ˆ4ï¼‰ å¯¹äºŽéžå†…éƒ¨æ•°æ®ç»“æž„çš„å¯¹è±¡è€Œè¨€ï¼Œå…‰ç”¨malloc/freeæ— æ³•æ»¡è¶³åŠ¨æ€å¯¹è±¡çš„è¦æ±‚ï¼Œå¯¹è±¡åœ¨åˆ›å»ºçš„åŒæ—¶ï¼Œè¿˜è¦è‡ªåŠ¨æ‰§è¡Œæž„é€ å‡½æ•°ï¼Œå¯¹è±¡åœ¨æ¶ˆäº¡ä¹‹å‰è¦è‡ªåŠ¨æ‰§è¡Œæžæž„å‡½æ•°ï¼Œç”±äºŽmalloc/freeæ˜¯åº“å‡½æ•°è€Œä¸æ˜¯è¿ç®—ç¬¦ï¼Œä¸åœ¨ç¼–è¯‘å™¨æŽ§åˆ¶æƒé™ä¹‹å†…ï¼Œä¸èƒ½å¤ŸæŠŠæ‰§è¡Œæž„é€ å‡½æ•°å’Œæžæž„å‡½æ•°çš„ä»»åŠ¡å¼ºåŠ äºŽmalloc/free;å› æ­¤ï¼Œc++è¯­è¨€éœ€è¦ä¸€ä¸ªèƒ½å¤Ÿå®ŒæˆåŠ¨æ€å†…å­˜åˆ†é…å’Œåˆå§‹åŒ–çš„è¿ç®—ç¬¦newï¼Œä»¥åŠä¸€ä¸ªèƒ½å®Œæˆæ¸…ç†ä¸Žé‡Šæ”¾å†…å­˜å·¥ä½œçš„è¿ç®—ç¬¦deleteï¼›æˆ‘ä»¬ä¸è¦ä¼å›¾ç”¨mallocå’Œfreeæ¥å®ŒæˆåŠ¨æ€å¯¹è±¡çš„å†…å­˜ç®¡ç†ï¼Œåº”è¯¥ç”¨new/deleteã€‚ç”±äºŽå†…éƒ¨æ•°æ®ç±»åž‹æ²¡æœ‰æž„é€ å’Œæžæž„è¿‡ç¨‹ï¼Œå¯¹ä»–ä»¬è€Œè¨€malloc/freeå’Œnew/deleteæ˜¯ç­‰ä»·çš„ã€‚ new/deleteçš„åŠŸèƒ½å®Œå…¨è¦†ç›–äº†malloc/free,ä¸ºä»€ä¹ˆè¿˜è¦mallocå’Œfreeäº†ï¼Ÿè¿™æ˜¯å› ä¸ºc++ç¨‹åºç»å¸¸è¦è°ƒç”¨cå‡½æ•°ï¼Œè€Œcç¨‹åºåªèƒ½ç”¨mallocå’Œfreeæ¥ç®¡ç†åŠ¨æ€å†…å­˜ã€‚ å¦‚æžœç”¨freeé‡Šæ”¾newåˆ›å»ºçš„åŠ¨æ€å¯¹è±¡ï¼Œé‚£ä¹ˆè¯¥å¯¹è±¡å› æ— æ³•æ‰§è¡Œæžæž„å‡½æ•°è€Œå¯èƒ½å¯¼è‡´ç¨‹åºå‡ºé”™ã€‚å¦‚æžœç”¨deleteé‡Šæ”¾æŽ‰mallocç”³è¯·çš„åŠ¨æ€å†…å­˜ï¼Œç»“æžœä¹Ÿä¼šå¯¼è‡´ç¨‹åºå‡ºé”™ï¼Œç»“æžœç†è®ºä¸Šåº”è¯¥å¯ä»¥ï¼Œä½†æ˜¯ç¨‹åºçš„å¯è¯»æ€§å¾ˆå·®ã€‚æ‰€ä»¥new/deleteå¿…é¡»é…å¯¹ä½¿ç”¨ï¼Œmallocå’Œfreeä¹Ÿä¸€æ ·ã€‚ mallocå’Œnewçš„åŒºåˆ« å¯¹äºŽc++ ä¸­malloc çš„ç†è§£ åœ¨C++ STLä¸­ï¼Œvectoræ˜¯ç”¨å†…å»ºï¼ˆbuild-inï¼‰çš„åŠ¨æ€æ•°ç»„ï¼ˆdynamic arrayï¼‰å®žçŽ°çš„ã€‚åŠ¨æ€æ•°ç»„æ˜¯ç›¸å¯¹äºŽé™æ€æ•°ç»„ï¼ˆæ•°ç»„å¤§å°ä¸å˜ï¼‰è€Œè¨€çš„ï¼Œåœ¨C++ä¸­æ™®é€šçš„æ•°ç»„çš„å¤§å°æ˜¯å›ºå®šçš„ï¼Œåœ¨åˆå§‹åŒ–çš„æ—¶å€™å°±ç¡®å®šäº†ï¼Œä½¿ç”¨çš„æ—¶å€™ä¸èƒ½è¶…è¿‡å…¶èŒƒå›´ã€‚ é™æ€æ•°ç»„æ˜¯åœ¨æ ˆä¸Šåˆ†é…çš„ç©ºé—´ 1int a[100] = &#123;0&#125;; åŠ¨æ€æ•°ç»„æ˜¯åœ¨å †ä¸Šåˆ†é…çš„ç©ºé—´1auto *p = new int(100); memset(p, 0, sizeof(int)); ä¸€èˆ¬æ¥è¯´ï¼Œå¦‚æžœé‡æ–°åˆ†é…ï¼Œé‚£ä¹ˆæ˜¯ä¹‹å‰çš„äºŒå€ã€‚1234567function insertEnd(dynarray a, element e) if (a.size = a.capacity) // resize a to twice its current capacity: a.capacity â† a.capacity * 2 // (copy the contents to the new memory location here) a[a.size] â† e a.size â† a.size + 1 å½“ä¸å¤Ÿçš„æ—¶å€™ï¼Œéœ€è¦è€ƒè™‘åˆ†é…ï¼Œé‡Šæ”¾ï¼Œå¤åˆ¶å’Œæžæž„ç­‰æ­¥éª¤ã€‚è¿™äº›è¿‡ç¨‹ä¼šå¤§å¤§å½±å“ç³»ç»Ÿçš„æ€§èƒ½ã€‚é‚£ä¹ˆå¦‚ä½•é¿å…vectoråœ¨ä½¿ç”¨ä¸­é¢‘ç¹çš„åˆ†é…ï¼Ÿ ä¸»è¦æœ‰ä¸¤ç§æ–¹å¼ã€‚ ä½¿ç”¨reserve()ä¿ç•™é€‚å½“å®¹é‡: 12std::vector&lt;int&gt; v; //size 0,capacity 0v.reserve(80); //size 0,capacity 80 åˆå§‹åŒ–æœŸé—´å°±å‘æž„é€ å‡½æ•°ä¼ é€’é™„åŠ å‚æ•°ï¼Œæž„é€ å‡ºè¶³å¤Ÿçš„ç©ºé—´: 1std::vector&lt;T&gt; v(5); //size 0,capacity 80 æŒ‡é’ˆå’Œå¼•ç”¨åœ¨C++ä¸­, å¦‚æžœè¦å¯¹æŸä¸ªå­˜å‚¨å•å…ƒè¿›è¡Œè®¿é—®(è¯»å–/å†™å…¥), æœ‰ä¸¤ç§æ–¹å¼, ä¸€æ˜¯é€šè¿‡å˜é‡åæ‰¾åˆ°å­˜å‚¨åœ°å€å†è¿›è¡Œè®¿é—®, äºŒæ˜¯ç›´æŽ¥é€šè¿‡å­˜å‚¨åœ°å€è¿›è¡Œè®¿é—®ã€‚ é€šè¿‡å˜é‡åè¿›è¡Œè®¿é—®é€šè¿‡å˜é‡åè¿›è¡Œè®¿é—®å°±æ˜¯æˆ‘ä»¬é€šè¿‡ç¼–è¯‘å™¨èµ·ä¸€ä¸ªåå­—, ç¨‹åºåœ¨è¿è¡Œæ—¶, ç³»ç»Ÿä¸ºè¯¥ç¨‹åºå»ºç«‹ä¸€ä¸ªå˜é‡åä¸Žå†…å­˜å•å…ƒåœ°å€ä¹‹é—´çš„æ˜ å°„è¡¨, é€šè¿‡åå­—å³å¯æ‰¾åˆ°è¯¥å­˜å‚¨å•å…ƒçš„åœ°å€å¹¶è¿›è¡Œæ“ä½œã€‚ é€šè¿‡åœ°å€ç›´æŽ¥è®¿é—®æ˜¾ç„¶, é€šè¿‡åœ°å€ç›´æŽ¥è¿›è¡Œè®¿é—®è¦æ¯”ç»è¿‡ä¸€æ¬¡ â€œä¸­è½¬â€ é€Ÿåº¦æ›´å¿«, æ—¢ç„¶è¦é€šè¿‡åœ°å€è¿›è¡Œç›´æŽ¥è®¿é—®é‚£ä¹ˆå°±å¿…é¡»è¦çŸ¥é“è¿™ä¸ªåœ°å€çš„å€¼(ç¼–å·)æ˜¯å¤šå°‘, å¹¶ä¸”è¦æŠŠè¿™ä¸ªåœ°å€å€¼(ç¼–å·)ç»™ä¿å­˜èµ·æ¥, è¿™æ ·æ‰èƒ½æ–¹ä¾¿åŽæ¥éšæ—¶ç›´æŽ¥è®¿é—®è¿™ä¸ªåœ°å€ã€‚ ä»€ä¹ˆæ˜¯æŒ‡é’ˆï¼Ÿ æŒ‡é’ˆæ˜¯ä¸€ä¸ªå˜é‡ï¼Œå…¶å€¼ä¸ºå¦ä¸€ä¸ªå˜é‡çš„åœ°å€ï¼Œå³ï¼Œå†…å­˜ä½ç½®çš„ç›´æŽ¥åœ°å€ã€‚æŒ‡é’ˆå˜é‡å£°æ˜Žçš„ä¸€èˆ¬å½¢å¼ä¸ºï¼š 1type *var-name; å®šä¹‰æ—¶, å…¶å·çš„ä½ç½®å¯ä»¥é å·¦( int pa; ), å±…ä¸­( int pa; )æˆ–é å³( int pa; ), å…·ä½“ä½¿ç”¨å“ªç§å½¢å¼å¯æ ¹æ®ä¸ªäººä¹ æƒ¯ã€‚ æŒ‡é’ˆå³ä¸ºåœ°å€ï¼ŒæŒ‡é’ˆå‡ ä¸ªå­—èŠ‚è·Ÿè¯­è¨€æ— å…³ï¼Œè€Œæ˜¯è·Ÿç³»ç»Ÿçš„å¯»å€èƒ½åŠ›æœ‰å…³ï¼Œæ¯”å¦‚åœ¨16ä½æœºå™¨ä¸Šï¼ŒæŒ‡é’ˆæ˜¯2å­—èŠ‚ï¼›32ä½ä¸Šï¼ŒæŒ‡é’ˆæ˜¯4å­—èŠ‚ï¼ŒçŽ°åœ¨åœ¨ 64ä½ä¸Šï¼Œå°±æ˜¯ 8å­—èŠ‚ã€‚ 123456789101112131415#include &lt;stdio.h&gt; int main(void)&#123; int a=1; char b='a'; float c=1.0; void *p; p=&amp;a; printf("açš„åœ°å€ä¸ºï¼š0x%xï¼Œå…¶å­—èŠ‚æ•°ä¸ºï¼š%d\n",p,sizeof(p)); p=&amp;b; printf("bçš„åœ°å€ä¸ºï¼š0x%xï¼Œå…¶å­—èŠ‚æ•°ä¸ºï¼š%d\n",p,sizeof(p)); p=&amp;c; printf("cçš„åœ°å€ä¸ºï¼š0x%xï¼Œå…¶å­—èŠ‚æ•°ä¸ºï¼š%d\n",p,sizeof(p)); return 0;&#125; æŒ‡é’ˆçš„åˆå§‹åŒ–ä¸Žèµ‹å€¼ ä¸ä¸€å®šå£°æ˜Žçš„æ—¶å€™é©¬ä¸Šåˆå§‹åŒ–ï¼Œä½†æ˜¯æ²¡æœ‰åˆå§‹åŒ–çš„æ—¶å€™ä¸€å®šæ˜¯ä¸èƒ½è®¿é—®çš„ï¼Œå¦åˆ™å°±æ˜¯é‡ŽæŒ‡é’ˆã€‚å› ä¸ºåœ¨å£°æ˜Žä¹‹åŽï¼Œç³»ç»Ÿä¼šéšæœºåˆ†é…ä¸€ä¸ªåœ°å€ï¼Œå¦‚æžœè¿™ä¸ªæ—¶å€™è®¿é—®å…¶å€¼ï¼Œé‡æ–°èµ‹å€¼ï¼Œé‚£ä¹ˆç»“æžœæ˜¯ä¸å¯é¢„æµ‹çš„ã€‚ æˆ‘ä»¬å°±æ¥çœ‹ä¸¤ä¸ªåŸºæœ¬çš„è¿ç®—ç¬¦:&amp;(å–å€è¿ç®—ç¬¦)å’Œ(é—´æŽ¥è®¿é—®è¿ç®—ç¬¦/è§£å¼•ç”¨æŒ‡é’ˆ)åœ¨C++ä¸­, ç”¨ â€˜&amp;â€™ ç¬¦å·æ¥èŽ·å–å˜é‡çš„åœ°å€; è¿™æ˜¯å› ä¸º a ä¸Ž pa å®žé™…ä¸Šéƒ½æ˜¯æŒ‡å‘åŒä¸€ä¸ªå­˜å‚¨åœ°å€, *å·ä¸ºé—´æŽ¥è®¿é—®ç¬¦, è¡¨ç¤ºè¦è®¿é—®æŒ‡é’ˆå˜é‡ä¸­æ‰€å­˜æ”¾çš„å†…å­˜åœ°å€ã€‚ 123456789#include &lt;iostream&gt;int main()&#123; int a = 10 ; int *pa = &amp;a ; //å®šä¹‰æŒ‡é’ˆå˜é‡paå¹¶åˆå§‹åŒ–åœ°å€ä¸ºå˜é‡aåœ¨å†…å­˜ä¸­æ‰€åœ¨çš„åœ°å€ std::cout&lt;&lt; a &lt;&lt; "\n" ; //é€šè¿‡å˜é‡åè®¿é—®aå˜é‡æ‰€åœ¨çš„åœ°å€ std::cout&lt;&lt; *pa &lt;&lt; "\n" ; //è¿ç”¨*å·è®¿é—®æŒ‡é’ˆå˜é‡paä¸­æ‰€ä¿å­˜çš„åœ°å€ return 0 ;&#125; ç§ç±» å¸¸é‡æŒ‡é’ˆ ä¸èƒ½æŠŠå¸¸é‡æŒ‡é’ˆèµ‹å€¼ç»™éžå¸¸é‡æŒ‡é’ˆã€‚åŽŸå› å¦‚ä¸‹ï¼šå®šä¹‰å¸¸é‡æŒ‡é’ˆçš„åˆè¡·æ˜¯ä¸èƒ½é€šè¿‡å¸¸é‡æŒ‡é’ˆä¿®æ”¹å…¶æŒ‡å‘çš„å†…å®¹ã€‚å¦‚æžœæŠŠå¸¸é‡æŒ‡é’ˆèµ‹å€¼ç»™éžå¸¸é‡æŒ‡é’ˆï¼Œå°±å¯ä»¥é€šè¿‡éžå¸¸é‡æŒ‡é’ˆä¿®æ”¹å¸¸é‡æŒ‡é’ˆæŒ‡å‘çš„å†…å®¹ã€‚123456void MyPrintf(const char *p)&#123; //strcpyå‡½æ•°åŽŸå½¢ç¬¬ä¸€ä¸ªå‚æ•°ä¸ºchar*ï¼Œç”±äºŽä¸èƒ½å°†å¸¸é‡æŒ‡é’ˆèµ‹å€¼ç»™éžå¸¸é‡æŒ‡é’ˆï¼Œå› æ­¤ç¼–è¯‘æŠ¥é”™ strcpy(p,"this");//ç¼–è¯‘å‡ºé”™ printf("%s",p);&#125; æŒ‡é’ˆæ•°ç»„ 1234 int var[MAX]=&#123;10,100,200&#125;; int *ptr[MAX]; //æŠŠ ptr å£°æ˜Žä¸ºä¸€ä¸ªæ•°ç»„ï¼Œç”± MAX ä¸ªæ•´æ•°æŒ‡é’ˆç»„æˆã€‚å› æ­¤ï¼Œptr ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œéƒ½æ˜¯ä¸€ä¸ªæŒ‡å‘ int å€¼çš„æŒ‡é’ˆã€‚ ptr[i] = &amp;var[i]; // èµ‹å€¼ä¸ºæ•´æ•°çš„åœ°å€ cout&lt;&lt;*ptr[i]&lt;&lt;endl; // 10 100 200 å‡½æ•°æŒ‡é’ˆ ç¨‹åºè¿è¡ŒæœŸé—´ï¼Œæ¯ä¸ªå‡½æ•°éƒ½ä¼šå ç”¨ä¸€æ®µè¿žç»­çš„å†…å­˜ç©ºé—´ã€‚è€Œå‡½æ•°åå°±æ˜¯è¯¥å‡½æ•°æ‰€å å†…å­˜åŒºåŸŸçš„èµ·å§‹åœ°å€ï¼ˆå…¥å£åœ°å€ï¼‰ã€‚æˆ‘ä»¬å¯ä»¥å°†å‡½æ•°çš„å…¥å£åœ°å€èµ‹ç»™ä¸€ä¸ªæŒ‡é’ˆå˜é‡ï¼Œä½¿è¯¥å˜é‡æŒ‡å‘è¯¥å‡½æ•°ã€‚ 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;cstddef&gt;void print_smaller(int a,int b)&#123; std::cout &lt;&lt; ((a &lt; b) ? a:b )&lt;&lt; std::endl;&#125;int main()&#123; /*ç­‰ä»·äºŽ void (*fn)(int ,int ) = print_smaller;*/ void (*fn)(int ,int ); fn = print_smaller; fn(3,4); return 0;&#125; å‡½æ•°æŒ‡é’ˆ ä½¿ç”¨typedefå®šä¹‰å‡½æ•°æŒ‡é’ˆ1typedef int64_t int64; ä¼ é€’æŒ‡é’ˆç»™å‡½æ•° å£°æ˜Žå‡½æ•°å‚æ•°ä¸ºæŒ‡é’ˆç±»åž‹å³å¯ã€‚ 1double getAverage(int *arr, int size); //arrè¡¨ç¤ºä¸€ä¸ªæ•°ç»„ NULLæŒ‡é’ˆå’Œvoid* NULLæŒ‡é’ˆæ˜¯ä¸€ç§éžå¸¸ç‰¹æ®Šçš„æŒ‡é’ˆ(åºŸè¯,ä¸ç„¶å•ç‹¬è¯´å®ƒå¹²å˜›?),ä¸æŒ‡å‘ä»»ä½•ä¸œè¥¿.è¡¨ç¤ºä¸æŒ‡å‘ä»»ä½•ä¸œè¥¿çš„æŒ‡é’ˆã€‚æœ‰ä¸€ä¸ªéžå¸¸é‡è¦çš„æ˜¯,å› ä¸ºNULLä¸æŒ‡å‘ä»»ä½•åœ°æ–¹,æ‰€ä»¥,ä¹Ÿå°±è‚¯å®šä¸èƒ½å¤Ÿè§£å¼•ç”¨äº†.åœ¨C++11ä¸­,æ–°å¼•å…¥äº†ä¸€ç§ç‰¹æ®Šç±»åž‹çš„å­—é¢å€¼nullptræ¥åˆå§‹åŒ–æŒ‡é’ˆä¸ºç©ºæŒ‡é’ˆ.ä»–èƒ½å¤Ÿè¢«è½¬æ¢æˆä»»ä½•ç±»åž‹çš„æŒ‡é’ˆ. Void*æ˜¯ä¸€ç§ç‰¹æ®Šç±»åž‹çš„æŒ‡é’ˆ,èƒ½å¤Ÿç”¨æ¥å­˜æ”¾ä»»ä½•ç±»åž‹å¯¹è±¡çš„åœ°å€.é€šä¿—æ¥è¯´,å°±æ˜¯æˆ‘ä¸çŸ¥é“è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘çš„æ˜¯ä»€ä¹ˆç±»åž‹çš„å¯¹è±¡. 1234567891011121314151617#include &lt;iostream&gt;int fun(int num)&#123; return num+10;&#125;int main()&#123; double x=25.5; //æ™®é€šæŒ‡é’ˆçš„è¯ç±»åž‹è¦ä¸¥æ ¼ä¿è¯ double *p=&amp;x; //void* ç±»åž‹å¯ä»¥æŽ¥å—ä»»æ„ç±»åž‹å¯¹è±¡åœ°å€ void *p_v=&amp;x; void *p_v2=p; std::cout&lt;&lt;"p_v:"&lt;&lt;p_v&lt;&lt;std::endl; std::cout&lt;&lt;"p_v2:"&lt;&lt;p_v2&lt;&lt;std::endl;&#125; æŒ‡é’ˆçš„æŒ‡é’ˆ 12345678910#include &lt;iostream&gt;int main()&#123; int a=10; int *p_a=&amp;a; int **pp_a=&amp;p_a; std::cout&lt;&lt;"p_a:"&lt;&lt;p_a&lt;&lt;std::endl&lt;&lt;"*p_a:"&lt;&lt;*p_a&lt;&lt;std::endl; std::cout&lt;&lt;std::endl; std::cout&lt;&lt;"PP_a:"&lt;&lt;pp_a&lt;&lt;std::endl&lt;&lt;"*pp_a:"&lt;&lt;*pp_a&lt;&lt;std::endl&lt;&lt;"**pp_a"&lt;&lt;**pp_a&lt;&lt;std::endl;&#125; è§£å¼•ç”¨çš„æ—¶å€™,å¸¦ä¸Šä¸¤ä¸ªæ˜Ÿå·,å°±å›žåˆ°çš„æœ€å¼€å§‹çš„é‚£ä¸ªå˜é‡.è¿™ä¹ˆè¯´æœ‰ç‚¹æ¨¡ç³Š.è¯¦ç»†æ¥è¯´,*pp_aå› ä¸ºçš„ä»Žå³å‘å·¦çš„ç»“åˆæ€§,è¿™ä¸ªè¡¨è¾¾å¼å¯ä»¥å†™æˆ(pp_a),é‚£ä¹ˆæˆ‘ä»¬çŸ¥é“pp_aå­˜æ”¾çš„æ˜¯p_açš„åœ°å€,pp_aå°±æ˜¯è¡¨ç¤ºp_aè¿™ä¸ªåœ°å€ä¸­å­˜æ”¾çš„å†…å®¹å³açš„åœ°å€(ä¸èƒ½æ™•!!!).é‚£ä¹ˆ(pp_a)å°±ç›¸å½“äºŽp_aæˆ–è€…a. æŒ‡é’ˆæ•°ç»„å’Œæ•°ç»„æŒ‡é’ˆ æŒ‡é’ˆæ•°ç»„ï¼šè¡¨ç¤ºçš„æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œæ•°ç»„ä¸­æ¯ä¸€ä¸ªå˜é‡éƒ½æ˜¯æŒ‡é’ˆåž‹å˜é‡ï¼› æ•°ç»„æŒ‡é’ˆï¼šè¡¨ç¤ºçš„æ˜¯ä¸€ä¸ªæŒ‡é’ˆç±»åž‹çš„å˜é‡ï¼Œè¿™ä¸ªæŒ‡é’ˆå˜é‡æŒ‡å‘çš„æ˜¯ä¸€ä¸ªæ•°ç»„ã€‚ 12int *p1[10];int (*p2)[10]; å ç”¨å†…å­˜åˆ†æž 12int *(p1[5]); //æŒ‡é’ˆæ•°ç»„ï¼Œå¯ä»¥åŽ»æŽ‰æ‹¬å·ç›´æŽ¥å†™ä½œ int *p1[5];int (*p2)[5]; //äºŒç»´æ•°ç»„æŒ‡é’ˆï¼Œä¸èƒ½åŽ»æŽ‰æ‹¬å· æŒ‡é’ˆæ•°ç»„æ˜¯æ•°ç»„ï¼Œå ç”¨ç©ºé—´ä¸º å•ä¸ªå…ƒç´ å­—èŠ‚æ•° Ã— å…ƒç´ ä¸ªæ•°ï¼Œp1åœ¨32ä½çŽ¯å¢ƒä¸‹å 4Ã—5 = 20ä¸ªå­—èŠ‚ï¼›æ•°ç»„æŒ‡é’ˆæ˜¯æŒ‡é’ˆï¼Œå ç”¨ç©ºé—´ä¸ºæŒ‡é’ˆå ç”¨ç©ºé—´ï¼Œp2åœ¨32ä½çŽ¯å¢ƒä¸‹å ç”¨4ä¸ªå­—èŠ‚ã€‚ï¼ˆæ‰€ä»¥å¦‚ä½•ä½¿ç”¨ æ•°ç»„æŒ‡é’ˆå­˜å‚¨æœ€åŽçš„ç»“æžœï¼Œé‚£ä¹ˆå ç”¨çš„å¤§å°å°±æ˜¯å¸¸é‡çº§åˆ«çš„ã€‚ï¼‰ 1â€œ[]â€çš„ä¼˜å…ˆçº§æ¯”â€œâ€è¦é«˜ã€‚p1 å…ˆä¸Žâ€œ[]â€ç»“åˆï¼Œæž„æˆä¸€ä¸ªæ•°ç»„çš„å®šä¹‰ï¼Œæ•°ç»„åä¸ºp1ï¼Œint *ä¿®é¥°çš„æ˜¯æ•°ç»„çš„å†…å®¹ï¼Œå³æ•°ç»„çš„æ¯ä¸ªå…ƒç´ ã€‚é‚£çŽ°åœ¨æˆ‘ä»¬æ¸…æ¥šï¼Œè¿™æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œå…¶åŒ…å«10 ä¸ªæŒ‡å‘int ç±»åž‹æ•°æ®çš„æŒ‡é’ˆï¼Œå³æŒ‡é’ˆæ•°ç»„ã€‚è‡³äºŽp2 å°±æ›´å¥½ç†è§£äº†ï¼Œåœ¨è¿™é‡Œâ€œï¼ˆï¼‰â€çš„ä¼˜å…ˆçº§æ¯”â€œ[]â€é«˜ï¼Œâ€œâ€å·å’Œp2 æž„æˆä¸€ä¸ªæŒ‡é’ˆçš„å®šä¹‰ï¼ŒæŒ‡é’ˆå˜é‡åä¸ºp2ï¼Œint ä¿®é¥°çš„æ˜¯æ•°ç»„çš„å†…å®¹ï¼Œå³æ•°ç»„çš„æ¯ä¸ªå…ƒç´ ã€‚æ•°ç»„åœ¨è¿™é‡Œå¹¶æ²¡æœ‰åå­—ï¼Œæ˜¯ä¸ªåŒ¿åæ•°ç»„ã€‚é‚£çŽ°åœ¨æˆ‘ä»¬æ¸…æ¥šp2 æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œå®ƒæŒ‡å‘ä¸€ä¸ªåŒ…å«10 ä¸ªint ç±»åž‹æ•°æ®çš„æ•°ç»„ï¼Œå³æ•°ç»„æŒ‡é’ˆã€‚æˆ‘ä»¬å¯ä»¥å€ŸåŠ©ä¸‹é¢çš„å›¾åŠ æ·±ç†è§£ï¼š ç»™ä¸€ä¸ªä¾‹å­ int *a[4]; //æŒ‡é’ˆæ•°ç»„ æŒ‡é’ˆæ•°ç»„å°±ç›¸å½“äºŽä¸€æ¬¡å£°æ˜Žäº†å¤šä¸ªæŒ‡é’ˆã€‚æ•°ç»„çš„æ¯ä¸€ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªæŒ‡é’ˆã€‚[ ]çš„ä¼˜å…ˆçº§é«˜äºŽï¼Œè¡¨ç¤ºaæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œå…ƒç´ ä¸ºint ï¼Œä¸ªæ•°ä¸º4ã€‚ int (*p)[4]; //æ•°ç»„æŒ‡é’ˆ æ•°ç»„æŒ‡é’ˆå°±ç›¸å½“äºŽä¸€æ¬¡å£°æ˜Žäº†ä¸€ä¸ªæŒ‡é’ˆã€‚åªä¸è¿‡è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘å¾ˆç‰¹åˆ«ï¼Œæ˜¯ä¸€ä¸ªæ•°ç»„ã€‚()çš„ä¼˜å…ˆçº§é«˜äºŽ[]ï¼Œè¡¨ç¤ºpæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œç±»åž‹æ˜¯ä¸ºint [4] ï¼Œæ­¥é•¿ä¸º4ã€‚ä¸‹æ ‡åŒºåˆ«ï¼šæŒ‡é’ˆæ•°ç»„çš„ä¸‹æ ‡è¡¨ç¤ºæ•°ç»„çš„å…ƒç´ ä¸ªæ•°ï¼Œæ•°ç»„æŒ‡é’ˆçš„è¡¨ç¤ºæŒ‡é’ˆçš„æ­¥é•¿ å¾ˆå¤šæ—¶å€™ï¼Œä½¿ç”¨æŒ‡é’ˆæ•°ç»„æ¥æŽ§åˆ¶ç¨‹åºå¯ä»¥èŠ‚çº¦å†…å­˜ç©ºé—´ï¼Œä¹Ÿå¯ä»¥èŠ‚çº¦æ—¶é—´ã€‚ å¥½å¥½ä½“ä¼šä¸€ä¸‹æ•°ç»„æŒ‡é’ˆ æŒ‡é’ˆæ•°ç»„ ç”¨æ³• åŒºåˆ« ä¸­çš„ä¸¤ä¸ªä¾‹å­ã€‚ é€šè¿‡è¡ŒæŒ‡é’ˆè®¿é—®äºŒç»´æ•°ç»„çš„å…ƒç´  123ç¬¦å·*ï¼šå–å†…å®¹ï¼Œå¯¹æŒ‡é’ˆå–å†…å®¹ï¼Œå°±æ˜¯æŠŠæŒ‡é’ˆæŒ‡å‘çš„ä¸œè¥¿å–å‡ºæ¥ç¬¦å·+ï¼šå‘å‰é€’è¿›ï¼Œå¦‚p+1å°±æ˜¯å‘å‰é€’è¿›ä¸€ä¸ªå…ƒç´ çš„ä½ç½®ç¬¦å·[]ï¼šå‘å‰é€’è¿›å¹¶å–å†…å®¹ã€‚ä¾‹å¦‚p[2]ï¼Œå³æŠŠåŽŸæ¥çš„på…ˆé€’è¿›2ä¸ªå…ƒç´ ï¼Œå†æŠŠå®ƒè¯»å‡ºæ¥ï¼Œç­‰ä»·*(p+2)ã€‚ æˆ‘ä»¬å…ˆç»™å‡ºæŒ‡å‘ç¬¬äºŒè¡Œç¬¬ä¸‰ä¸ªå…ƒç´ çš„è¡¨è¾¾å¼ï¼š 12345p[1][2];*(p+1)[2];*(*(p+1)+2); strlenä¸Žsizeofçš„åŒºåˆ« sizeofï¼š1ã€è®¡ç®—æ‰€æœ‰å˜é‡ç±»åž‹çš„å ç”¨å­—èŠ‚å¤§å°2ã€åœ¨è®¡ç®—å­—ç¬¦ä¸²çš„æ—¶å€™ï¼Œä¼šå°†å­—ç¬¦ä¸²åŽé¢çš„â€™\0â€™çš„å¤§å°ä¹Ÿè®¡ç®—ä¸Šæ¥ã€‚3ã€è®¡ç®—çš„æ˜¯å­—èŠ‚å†…å­˜çš„å¤§å°4ã€è®¡ç®—æ•°ç»„åçš„æ—¶å€™ç‰¹æ®Šï¼Œä¼šè®¡ç®—æ•´ä¸ªæ•°ç»„çš„é•¿åº¦ã€‚å…¶ä»–çš„å‡è®¡ç®—å•ä¸ªå˜é‡ strlenï¼š1ã€è®¡ç®—çš„æ˜¯å­—ç¬¦ä¸²çš„é•¿åº¦å¤§å°3ã€è®¡ç®—å­—ç¬¦ä¸²é•¿åº¦æ—¶ï¼Œå°†ä¼šå¿½ç•¥â€™\0â€™ç»“æŸç¬¦ï¼Œé‡åˆ°â€™\0â€™å­—ç¬¦å°±ä¼šç»“æŸã€‚ 12345678910111213141516#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;int main()&#123; char str[] ="world"; cout &lt;&lt; sizeof(str)&lt;&lt;":"; cout &lt;&lt; strlen(str)&lt;&lt;":"; char *p =str; cout &lt;&lt; sizeof(p) &lt;&lt;":"; char i =10; cout &lt;&lt; sizeof(i) &lt;&lt;":"; // è¾“å‡ºçš„ç»“æžœ 6:5:8:1: return 0;&#125; sizeof ä¼šåŒ…å« \0 çš„é•¿åº¦ï¼Œ ä½†æ˜¯strlen() ä¸ä¼šã€‚ä½†æ˜¯å½“ç”³è¯·å›ºå®šé•¿åº¦çš„ char æ•°ç»„ï¼Œé‚£ä¹ˆsizeof å°±ä¸åŒ…æ‹¬äº†\0ï¼Œå¯ä»¥æŸ¥çœ‹ä¸‹é¢çš„ä¾‹å­ã€‚ä½†æ˜¯strlen ä¸€ç›´æ˜¯æœ‰æ•ˆçš„é•¿åº¦ã€‚12345678910111213141516#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;int main()&#123; char str[10] ="world"; cout &lt;&lt; sizeof(str)&lt;&lt;":"; cout &lt;&lt; strlen(str)&lt;&lt;":"; char *p =str; cout &lt;&lt; sizeof(p) &lt;&lt;":"; char i =10; cout &lt;&lt; sizeof(i) &lt;&lt;":"; // è¾“å‡ºçš„ç»“æžœ 10:5:8:1: return 0;&#125; åˆ©ç”¨mallocåˆ†é…å†…å­˜ å¦‚æžœæƒ³å°†æŸä¸€ä¸ªå­—ç¬¦ä¸²å¤åˆ¶åˆ°æŸä¸€ä¸ªæŽ§ä»¶ï¼Œä¸€å®šè¦è®°å¾—åˆ†é…è¶³å¤Ÿçš„ç©ºé—´å¤§å°ï¼Œä¸è¦å¿˜è®°â€\0â€ç»“æŸç¬¦ã€‚ æ¯”å¦‚12345678char * strSrc = "Hello Boy."; char * strDest; //é”™è¯¯ï¼Œstrlenå¹¶æœªè®¡ç®—"\0"ç»“æŸç¬¦,èµ‹å€¼åŽçš„æŒ‡é’ˆæœ«å°¾æŒ‡å‘æœªçŸ¥ç©ºé—´ã€‚ strDest = (char *) malloc(strlen(strSrc)); //æ­£ç¡®ï¼Œä¸º"\0"ç•™å‡ºç©ºé—´ã€‚ strDest = (char *) malloc(strlen(strSrc)+1); strcpy(strDest,strSrc); C++å¼•ç”¨ å¼•ç”¨å˜é‡æ˜¯ä¸€ä¸ªåˆ«åï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒæ˜¯æŸä¸ªå·²å­˜åœ¨å˜é‡çš„å¦ä¸€ä¸ªåå­—ã€‚ä¸€æ—¦æŠŠå¼•ç”¨åˆå§‹åŒ–ä¸ºæŸä¸ªå˜é‡ï¼Œå°±å¯ä»¥ä½¿ç”¨è¯¥å¼•ç”¨åç§°æˆ–å˜é‡åç§°æ¥æŒ‡å‘å˜é‡ã€‚ å¼•ç”¨å¾ˆå®¹æ˜“ä¸ŽæŒ‡é’ˆæ··æ·†ï¼Œå®ƒä»¬ä¹‹é—´æœ‰ä¸‰ä¸ªä¸»è¦çš„ä¸åŒï¼šä¸å­˜åœ¨ç©ºå¼•ç”¨ã€‚å¼•ç”¨å¿…é¡»è¿žæŽ¥åˆ°ä¸€å—åˆæ³•çš„å†…å­˜ã€‚ä¸€æ—¦å¼•ç”¨è¢«åˆå§‹åŒ–ä¸ºä¸€ä¸ªå¯¹è±¡ï¼Œå°±ä¸èƒ½è¢«æŒ‡å‘åˆ°å¦ä¸€ä¸ªå¯¹è±¡ã€‚æŒ‡é’ˆå¯ä»¥åœ¨ä»»ä½•æ—¶å€™æŒ‡å‘åˆ°å¦ä¸€ä¸ªå¯¹è±¡ã€‚å¼•ç”¨å¿…é¡»åœ¨åˆ›å»ºæ—¶è¢«åˆå§‹åŒ–ã€‚æŒ‡é’ˆå¯ä»¥åœ¨ä»»ä½•æ—¶é—´è¢«åˆå§‹åŒ–ã€‚ int i=17;int&amp; r=i; //&amp;è¯»ä½œå¼•ç”¨ï¼Œr æ˜¯ä¸€ä¸ªåˆå§‹åŒ–ä¸º i çš„æ•´åž‹å¼•ç”¨cout&lt;&lt;i&lt;&lt;endl; //5cout&lt;&lt;r&lt;&lt;endl; //5 å¼•ç”¨é€šå¸¸ç”¨äºŽå‡½æ•°å‚æ•°åˆ—è¡¨å’Œå‡½æ•°è¿”å›žå€¼ã€‚ æŠŠå¼•ç”¨ä½œä¸ºå‚æ•°ã€‚ C++ æ”¯æŒæŠŠå¼•ç”¨ä½œä¸ºå‚æ•°ä¼ ç»™å‡½æ•°ï¼Œè¿™æ¯”ä¼ ä¸€èˆ¬çš„å‚æ•°æ›´å®‰å…¨ 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;// å‡½æ•°å£°æ˜Žvoid swap(int&amp; x, int&amp; y);int main ()&#123; // å±€éƒ¨å˜é‡å£°æ˜Ž int a = 100; int b = 200; cout &lt;&lt; "äº¤æ¢å‰ï¼Œa çš„å€¼ï¼š" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; "äº¤æ¢å‰ï¼Œb çš„å€¼ï¼š" &lt;&lt; b &lt;&lt; endl; /* è°ƒç”¨å‡½æ•°æ¥äº¤æ¢å€¼ */ swap(a,b); cout &lt;&lt; "äº¤æ¢åŽï¼Œa çš„å€¼ï¼š" &lt;&lt; a &lt;&lt; endl; //200 cout &lt;&lt; "äº¤æ¢åŽï¼Œb çš„å€¼ï¼š" &lt;&lt; b &lt;&lt; endl; //100 return 0;&#125;void swap(int&amp; x, int&amp; y)&#123; int temp; temp = x; /* ä¿å­˜åœ°å€ x çš„å€¼ */ x = y; /* æŠŠ y èµ‹å€¼ç»™ x */ y = temp; /* æŠŠ x èµ‹å€¼ç»™ y */ return;&#125; å•ç‹¬æ•´ç†ï¼Œéœ€è¦æœ‰ä»£ç åŠ æŒ å†…è”å‡½æ•°å‡½æ•°è°ƒç”¨æ˜¯æœ‰å¼€é”€çš„ã€‚å¦‚æžœå‡½æ•°æœ¬èº«åªæœ‰å‡ æ¡è¯­å¥ï¼Œæ‰§è¡Œéžå¸¸å¿«ï¼Œè€Œä¸”å‡½æ•°è¢«åå¤æ‰§è¡Œå¾ˆå¤šæ¬¡ï¼Œç›¸æ¯”ä¹‹ä¸‹è°ƒç”¨å‡½æ•°æ‰€äº§ç”Ÿçš„è¿™ä¸ªå¼€é”€å°±ä¼šæ˜¾å¾—æ¯”è¾ƒå¤§ã€‚ä¸ºäº†å‡å°‘å‡½æ•°è°ƒç”¨çš„å¼€é”€ï¼Œå¼•å…¥äº†å†…è”å‡½æ•°æœºåˆ¶ã€‚ç¼–è¯‘å™¨å¤„ç†å¯¹å†…è”å‡½æ•°çš„è°ƒç”¨è¯­å¥æ—¶ï¼Œæ˜¯å°†æ•´ä¸ªå‡½æ•°çš„ä»£ç æ’å…¥åˆ°è°ƒç”¨è¯­å¥å¤„ï¼Œè€Œä¸ä¼šäº§ç”Ÿè°ƒç”¨å‡½æ•°çš„è¯­å¥ã€‚åœ¨å‡½æ•°å®šä¹‰å‰é¢åŠ inlineå…³é”®å­—ï¼Œå³å¯å®šä¹‰å†…è”å‡½æ•°ã€‚ 123456789class B&#123; inline void func1(); void func2() &#123; &#125;&#125;;void B::func2()&#123;&#125; å‹å…ƒå‡½æ•° This approach may be used in friendly function when a function needs to access private data in objects from two different class. This may be accomplished in two similar ways:a function of global or namespace scope may be declared as friend of both classesa member function of one class may be declared as friend of another one. 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std; class Foo; // Forward declaration of class Foo in order for example to compile.class Bar &#123; private: int a; public: Bar(): a(0) &#123;&#125; void show(Bar&amp; x, Foo&amp; y); friend void show(Bar&amp; x, Foo&amp; y); // declaration of global friend&#125;; class Foo &#123; private: int b; public: Foo(): b(6) &#123;&#125; friend void show(Bar&amp; x, Foo&amp; y); // declaration of global friend friend void Bar::show(Bar&amp; x, Foo&amp; y); // declaration of friend from other class &#125;; // Definition of a member function of Bar; this member is a friend of Foovoid Bar::show(Bar&amp; x, Foo&amp; y) &#123; cout &lt;&lt; "Show via function member of Bar" &lt;&lt; endl; cout &lt;&lt; "Bar::a = " &lt;&lt; x.a &lt;&lt; endl; cout &lt;&lt; "Foo::b = " &lt;&lt; y.b &lt;&lt; endl;&#125; // Friend for Bar and Foo, definition of global functionvoid show(Bar&amp; x, Foo&amp; y) &#123; cout &lt;&lt; "Show via global function" &lt;&lt; endl; cout &lt;&lt; "Bar::a = " &lt;&lt; x.a &lt;&lt; endl; cout &lt;&lt; "Foo::b = " &lt;&lt; y.b &lt;&lt; endl;&#125; int main() &#123; Bar a; Foo b; show(a,b); a.show(a,b);&#125; ç»“æžœè¾“å‡ºï¼š 1234567Show via global functionBar::a = 0Foo::b = 6Show via function member of BarBar::a = 0Foo::b = 6Program ended with exit code: 0 ä½¿ç”¨ä¸€ä¸ªå‹å…ƒå‡½æ•°åŽ»è®¿é—®ä¸¤ä¸ªç±»åˆ«ä¸­çš„priate å˜é‡ã€‚ ä¸ºä»€ä¹ˆè¦ä½¿ç”¨å‹å…ƒå‡½æ•°ï¼Ÿ åœ¨C++ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ç±»å¯¹æ•°æ®è¿›è¡Œäº†éšè—å’Œå°è£…ï¼Œç±»çš„æ•°æ®æˆå‘˜ä¸€èˆ¬éƒ½å®šä¹‰ä¸ºç§æœ‰æˆå‘˜ï¼Œæˆå‘˜å‡½æ•°ä¸€èˆ¬éƒ½å®šä¹‰ä¸ºå…¬æœ‰çš„ï¼Œä»¥æ­¤æä¾›ç±»ä¸Žå¤–ç•Œçš„é€šè®¯æŽ¥å£ã€‚ä½†æ˜¯ï¼Œæœ‰æ—¶éœ€è¦å®šä¹‰ä¸€äº›å‡½æ•°ï¼Œè¿™äº›å‡½æ•°ä¸æ˜¯ç±»çš„ä¸€éƒ¨åˆ†ï¼Œä½†åˆéœ€è¦é¢‘ç¹åœ°è®¿é—®ç±»çš„æ•°æ®æˆå‘˜ï¼Œè¿™æ—¶å¯ä»¥å°†è¿™äº›å‡½æ•°å®šä¹‰ä¸ºè¯¥å‡½æ•°çš„å‹å…ƒå‡½æ•°ã€‚ï¼ˆå¦‚æžœå°è£…æ˜¯ä¸€å µå¢™ï¼Œé‚£ä¹ˆå‹å…ƒå‡½æ•°å°±æ˜¯ä¸€é“é—¨ï¼‰ ï¼ˆæ‰€ä»¥å»ºè®®æ…Žé‡ä½¿ç”¨ï¼‰å‹å…ƒçš„ä½œç”¨æ˜¯æé«˜äº†ç¨‹åºçš„è¿è¡Œæ•ˆçŽ‡ï¼ˆå³å‡å°‘äº†ç±»åž‹æ£€æŸ¥å’Œå®‰å…¨æ€§æ£€æŸ¥ç­‰éƒ½éœ€è¦æ—¶é—´å¼€é”€ï¼‰ï¼Œä½†å®ƒç ´åäº†ç±»çš„å°è£…æ€§å’Œéšè—æ€§ï¼Œä½¿å¾—éžæˆå‘˜å‡½æ•°å¯ä»¥è®¿é—®ç±»çš„ç§æœ‰æˆå‘˜ã€‚ ä½¿ç”¨æ–¹æ³•ï¼šéœ€è¦å†ç±»å†…è¿›è¡Œå®šä¹‰ç”³æ˜Žï¼Œä½†æ˜¯åœ¨ç±»å¤–è¿›è¡Œå…·ä½“çš„å®žçŽ°ã€‚ å¯¹è±¡çš„å¤§å°=æ‰€æœ‰æˆå‘˜å˜é‡çš„å¤§å°ä¹‹å’Œ c++ ä¸­è¾“å…¥å­—ç¬¦ä¸²çš„å‡ ç§æ–¹å¼ å¯¹äºŽå­—ç¬¦æ•°ç»„æ–¹æ³•ä¸€ï¼šgetline()è¯»å…¥æ•´è¡Œæ•°æ®ï¼Œå®ƒä½¿ç”¨å›žè½¦é”®è¾“å…¥çš„æ¢è¡Œç¬¦æ¥ç¡®å®šè¾“å…¥ç»“å°¾ã€‚è°ƒç”¨æ–¹æ³•: cin.getline(str, len);ç¬¬ä¸€ä¸ªå‚æ•°stræ˜¯ç”¨æ¥å­˜å‚¨è¾“å…¥è¡Œçš„æ•°ç»„åç§°ï¼Œç¬¬äºŒä¸ªå‚æ•°lenæ˜¯è¦è¯»å–çš„å­—ç¬¦æ•°ã€‚ 1234567891011#include&lt;iostream&gt;using namespace std;int main()&#123; char str[30]; cin.getline(str, 30); cout&lt;&lt; str&lt;&lt;endl; return 0;&#125; æ–¹æ³•äºŒï¼šget()è°ƒç”¨æ–¹æ³•ï¼šcin.get(str, len); å¯ä»¥æŽ¥å—ç©ºæ ¼ 123456789101112131415#include&lt;iostream&gt;using namespace std;int main()&#123; char str1[30], str2[30]; cin.get(str1, 30); cin.get(); // ä½¿ç”¨get æ˜¯ä¿ç•™äº† '\n' æ¢è¡Œç¬¦ï¼Œæ‰€ä»¥è¿™é‡Œéœ€è¦æ¸…é™¤ä¸€ä¸‹ cin.get(str2, 30); cout&lt;&lt; str1&lt;&lt;" "&lt;&lt;endl; cout&lt;&lt; str2 &lt;&lt; " "&lt;&lt; endl; return 0;&#125; cin.getline()cin.getline()å®žé™…ä¸Šæœ‰ä¸‰ä¸ªå‚æ•°ï¼Œcin.getline(æŽ¥å—å­—ç¬¦ä¸²åˆ°m,æŽ¥å—ä¸ªæ•°5,ç»“æŸå­—ç¬¦). å½“ç¬¬ä¸‰ä¸ªå‚æ•°çœç•¥æ—¶ï¼Œç³»ç»Ÿé»˜è®¤ä¸ºâ€™\0â€™ æ˜¯â€˜/nâ€™å§ã€‚ cin çš„ç”¨æ³•æŽ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œé‡â€œç©ºæ ¼â€ã€â€œTABâ€ã€â€œå›žè½¦â€éƒ½ç»“æŸ 1234567891011#include&lt;iostream&gt;using namespace std;int main()&#123; char a[20]; cin &gt;&gt;a; cout&lt;&lt; a&lt;&lt;endl; return 0;&#125; å¯¹äºŽ char çš„æ”¯æŒ 123456789101112#include&lt;iostream&gt;using namespace std;int main()&#123; char ch; ch =cin.get(); cout&lt;&lt;ch&lt;&lt;endl; return 0;&#125; å¯¹äºŽstring ç±» ä¸Šé¢çš„cin.getline() æ˜¯ç±»å‡½æ•°ï¼Œåœ¨string ä¸­è¿˜æœ‰ä¸€ä¸ªå‡½æ•°.getline() // æŽ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå¯ä»¥æŽ¥æ”¶ç©ºæ ¼å¹¶è¾“å‡ºï¼Œéœ€åŒ…å«â€œ#includeâ€ 12345678910#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string str; getline(cin ,str); return 0;&#125; gets() // æŽ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå¯ä»¥æŽ¥æ”¶ç©ºæ ¼å¹¶è¾“å‡ºï¼Œéœ€åŒ…å«â€œ#includeâ€ 123456789101112#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; char str[20]; gets(str); cout&lt;&lt; str&lt;&lt;endl; return 0;&#125; getchar() //æŽ¥å—ä¸€ä¸ªå­—ç¬¦ï¼Œéœ€åŒ…å«â€œ#includeâ€ 123456789101112#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; char ch; ch =getline(); cout&lt;&lt;ch&lt;&lt;endl; return 0;&#125; æ‰€ä»¥æ€»çš„æ¥è¯´ï¼Œæ˜¯æœ‰ä¸¤å¥—è¾“å…¥string çš„æ–¹æ¡ˆçš„ã€‚ ä½¿ç”¨ stringstream å®žçŽ°å­—ç¬¦ä¸²çš„split åŠŸèƒ½ã€‚ stringstreamä¸ºå­—ç¬¦ä¸²è¾“å…¥è¾“å‡ºæµï¼Œç»§æ‰¿è‡ªiostreamï¼Œçµæ´»åœ°ä½¿ç”¨stringstreamæµå¯ä»¥å®Œæˆå¾ˆå¤šå­—ç¬¦ä¸²å¤„ç†åŠŸèƒ½ï¼Œä¾‹å¦‚å­—ç¬¦ä¸²å’Œå…¶ä»–ç±»åž‹çš„è½¬æ¢ï¼Œå­—ç¬¦ä¸²åˆ†å‰²ç­‰ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨å…¶å®žçŽ°å­—ç¬¦ä¸²åˆ†å‰²åŠŸèƒ½ã€‚æ³¨æ„stingstreamçš„ä½¿ç”¨éœ€è¦åŒ…å«sstreamå¤´æ–‡ä»¶ã€‚ 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;sstream&gt;#include&lt;vector&gt;using namespace std;vector&lt;string&gt; split(const string &amp; str,const char ch)&#123; vector&lt;string&gt; res; stringstream input(str); string tmp; while(getline(input, tmp, ch)) res.push_back(tmp); return res;&#125;int main()&#123; string str("a,b,c#,aaa"); char ch=','; vector&lt;string&gt; res =split(str, ch); for(auto u : res) &#123; cout &lt;&lt; u; cout &lt;&lt; endl; &#125; return 0;&#125; å¯¹äºŽ cpp ä¸­ getline() çš„è¯¦è§£ï¼Œä¸‹é¢æ˜¯ä¸‰ä¸ªå‚æ•° 123input - the stream to get data fromstr - the string to put the data intodelim - the delimiter character getline æ˜¯é»˜è®¤ä»¥ â€œ\nâ€ ä½œä¸ºç»“æŸç¬¦å·çš„ã€‚ 12345678910#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string buff; getline(cin, buff); cout &lt;&lt; buff&lt;&lt; endl; return 0;&#125; æ³¨æ„è¿™ä¸ªå’Œä¸Šé¢çš„åŒºåˆ«ï¼Œåœ¨äºŽæœ€åŽçš„ delim æ˜¯ â€˜,â€™ã€‚ é‚£ä¹ˆåªæœ‰å½“å‡ºçŽ° , æ‰ä¼šåœæ­¢12345678910#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string buff; getline(cin, buff, ','); cout &lt;&lt; buff&lt;&lt; endl; return 0;&#125; æ¯”è¾ƒå¥½çš„åœ¨ cpp ä¸­å®žçŽ° 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;sstream&gt;using namespace std;vector&lt;string&gt; split(string &amp; str, char ch)&#123; vector&lt;string&gt; res; stringstream input(str); string tmp; // ç¬¬ä¸€ä¸ªå‚æ•°éœ€è¦æ˜¯ä¸€ä¸ªè¾“å…¥æµï¼Œç„¶åŽç¬¬äºŒä¸ªå‚æ•°æ˜¯å­˜å‚¨ç»“æžœæ˜¯æŒ‰ç…§ delim åˆ†å¼€çš„ä¸€ä¸ªç»“æžœ //res æ˜¯ç»è¿‡ split ä¹‹åŽçš„ç»“æžœ while(getline(input, tmp,ch)) &#123; res.push_back(tmp); &#125; return res;&#125;int main()&#123; string str; cin &gt;&gt; str; char ch =','; vector&lt;string&gt; res =split(str, ch); for(auto u : res) cout&lt;&lt; u &lt;&lt; endl; return 0;&#125; æŽ¥å£å’ŒæŠ½è±¡ç±»çš„åŒºåˆ«æŽ¥å£æ˜¯ä¸€ä¸ªæ¦‚å¿µã€‚å®ƒåœ¨C++ä¸­ç”¨æŠ½è±¡ç±»æ¥å®žçŽ°ï¼Œåœ¨C#å’ŒJavaä¸­ç”¨interfaceæ¥å®žçŽ°ã€‚ æŽ¥å£æ˜¯ä¸“é—¨è¢«ç»§æ‰¿çš„ã€‚æŽ¥å£å­˜åœ¨çš„æ„ä¹‰ä¹Ÿæ˜¯è¢«ç»§æ‰¿ã€‚å’ŒC++é‡Œçš„æŠ½è±¡ç±»é‡Œçš„çº¯è™šå‡½æ•°æ˜¯ç›¸åŒçš„ã€‚ä¸èƒ½è¢«å®žä¾‹åŒ–ã€‚å®šä¹‰æŽ¥å£çš„å…³é”®å­—æ˜¯interfaceï¼Œä¾‹å¦‚ï¼š 1234public interface MyInterface&#123; public void add(int x,int y); public void volume(int x,int y,int z); &#125; ç»§æ‰¿æŽ¥å£çš„å…³é”®å­—æ˜¯implementsï¼Œç›¸å½“äºŽç»§æ‰¿ç±»çš„extendsã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå½“ç»§æ‰¿ä¸€ä¸ªæŽ¥å£æ—¶ï¼ŒæŽ¥å£é‡Œçš„æ‰€æœ‰å‡½æ•°å¿…é¡»å…¨éƒ¨è¢«è¦†ç›–ã€‚å½“æƒ³ç»§æ‰¿å¤šä¸ªç±»æ—¶ï¼Œå¼€å‘ç¨‹åºä¸å…è®¸ï¼ŒæŠ¥é”™ã€‚è¿™æ ·å°±è¦ç”¨åˆ°æŽ¥å£ã€‚å› ä¸ºæŽ¥å£å…è®¸å¤šé‡ç»§æ‰¿ï¼Œè€Œç±»ä¸å…è®¸ï¼ˆC++ä¸­å¯ä»¥å¤šé‡ç»§æ‰¿ï¼‰ã€‚æ‰€ä»¥å°±è¦ç”¨åˆ°æŽ¥å£ã€‚ C++ä¸­çš„ç»“æž„ä½“12345678910111213141516171819#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;// å£°æ˜Žä¸€ä¸ªç»“æž„ä½“ç±»åž‹ stustruct Stu&#123; int num; // å£°æ˜Žç»“æž„ä½“ä¸­çš„æ•´åž‹å˜é‡ char name[20]; //å£°æ˜Žå­—ç¬¦ä¸²æ•°ç»„ float score; // å£°æ˜Žä¸€ä¸ªå•ç²¾åº¦å˜é‡ int age; // å£°æ˜Žä¸€ä¸ªæ•´åž‹age&#125;student1, student2;// å£°æ˜Žå˜é‡ student1, student2int main()&#123; cout &lt;&lt; sizeof(Stu)&lt;&lt;endl; cout &lt;&lt; sizeof(student1) &lt;&lt; endl; cout &lt;&lt; sizeof(student2) &lt;&lt; endl; return 0;&#125; C++ ä¸­çš„typedeftypedef ç”¨æ¥è®¾ç½®åˆ«å 1typedef char* PCHAR; // ä¸€èˆ¬ç”¨å¤§å†™ c++ ä¸­å„ç§æ•°æ®ç±»åž‹çš„å¤§å° å­—èŠ‚ (byte) æ˜¯ç”± 8ä½( bit) ç»„æˆã€‚å­—ï¼šâ€œå­—â€ç”±è‹¥å¹²ä¸ªå­—èŠ‚æž„æˆï¼Œå­—çš„ä½æ•°å«åšå­—é•¿ï¼Œä¸åŒæ¡£æ¬¡çš„æœºå™¨æœ‰ä¸åŒçš„å­—é•¿ã€‚ä¾‹å¦‚ä¸€å°8ä½æœºï¼Œå®ƒçš„1ä¸ªå­—å°±ç­‰äºŽ1ä¸ªå­—èŠ‚ï¼Œå­—é•¿ä¸º8ä½ã€‚å¦‚æžœæ˜¯ä¸€å°16ä½æœºï¼Œé‚£ä¹ˆï¼Œå®ƒçš„1ä¸ªå­—å°±ç”±2ä¸ªå­—èŠ‚æž„æˆï¼Œå­—é•¿ä¸º16ä½ã€‚å­—æ˜¯è®¡ç®—æœºè¿›è¡Œæ•°æ®å¤„ç†å’Œè¿ç®—çš„å•ä½ã€‚ å¸¸è§çš„è½¬æ¢å…³ç³»ï¼š1 byte = 8 bit1 KB = 1024 bytes = $2^{10} $ bytes1 MB = 1024 KB = $2^{20} $bytes1 GB = 1024 MB = $2^{30} $ bytesterabyte(TB) = $2^{40}$ bytes å¦‚æžœä½¿ç”¨10 è¿›åˆ¶è¡¨ç¤ºï¼Œé‚£ä¹ˆä¸Šé¢åˆ†åˆ«å¯ä»¥çº¦ç­‰äºŽ $10^3$, $10^6$ å’Œ $10^9$ ã€‚ sizeofçš„è¾“å‡ºå•ä½æ˜¯å­—èŠ‚ï¼Œå³Bï¼Œ1B=8bï¼ˆä½ï¼‰ï¼Œæµ‹è¯•å·¥å…·ä¸ºVS2013æ——èˆ°ç‰ˆã€‚ bitsetbitsetæ˜¯STLæä¾›çš„ç”¨äºŽè®°å½•01ä¸²çš„å®¹å™¨ï¼Œä¹Ÿå°±æ˜¯bitsetçš„æ¯ä¸ªå…ƒç´ åªèƒ½ä¸º0/1ã€‚ ç±»ä¼¼äºŽ vectorï¼Œbitsetä¹Ÿæ˜¯ä¸€ç§ç±»æ¨¡æ¿ã€‚bitset ç±»åž‹ä¹‹é—´çš„åŒºåˆ«åœ¨äºŽå…¶é•¿åº¦è€Œä¸æ˜¯ç±»åž‹ï¼Œåœ¨å®šä¹‰ bitset ç±»åž‹æ—¶ï¼Œè¦æ˜Žç¡®å…¶å«æœ‰å¤šå°‘ä½ï¼Œ&lt;&gt; å†…æŒ‡å®šå®ƒçš„é•¿åº¦ï¼š 1234#include&lt;bitset&gt;bitset&lt;16&gt; a; //ç¬¬0~15ä½éƒ½æ˜¯0bitset&lt;6&gt; b(string("010010")); //ç”¨å­—ç¬¦ä¸²åˆå§‹åŒ–bbitset&lt;32&gt; c(0x80000000); //ç¬¬0ä½æ˜¯1ï¼Œå…¶ä»–éƒ½æ˜¯0 æ³¨æ„bitsetå£°æ˜ŽåŽé•¿åº¦ä¸å¯æ”¹å˜ã€‚å’Œæ•°ç»„ä¸€æ ·ï¼Œbitsetä»Ž0å¼€å§‹ç¼–å· bitsetçš„æ“ä½œ 123456789a.any() //aä¸­æ˜¯å¦å«1a.none() //aæ˜¯å¦å…¨ä¸º0a.count() //aä¸­æœ‰å‡ ä¸ª1a.[pos] //è®¿é—®ç¬¬posä½a.test(pos) //ç¬¬posä½æ˜¯å¦ä¸º1a.set() //å…¨éƒ¨è®¾ä¸º1a.reset() //å…¨éƒ¨æ¸…é›¶a.flip() //å…¨éƒ¨å–åa.to_ulong() //è½¬æˆ32ä½æ— ç¬¦å·æ•´æ•° bitset ä¹Ÿæ˜¯æ”¯æŒä½æ“ä½œçš„123456a|ba&amp;ba^b~aa&lt;&lt;1a&gt;&gt;1 bitsetçš„åŽŸç† å°†ä¸€ä¸ªå¾ˆé•¿çš„01ä¸²æŒ‰64ä½ä¸€ç»„åˆ’åˆ†ã€‚æ¯ç»„01ä¸²ç”¨ä¸€ä¸ª64ä½æ— ç¬¦å·æ•´æ•°è®°å½•ã€‚bitsetæ‰€æœ‰çš„æ“ä½œéƒ½æ˜¯åŸºäºŽå¯¹æ•´æ•°çš„ä½æ“ä½œå®žçŽ°çš„ã€‚æ‰€ä»¥bitsetçš„æ•ˆçŽ‡éžå¸¸é«˜ï¼Œå¯ä»¥çœ‹ä½œ$O(N/64) $ã€‚ bitset çš„åŽŸç† bitsetä¸»è¦ç”¨äºŽçŠ¶æ€åŽ‹ç¼©ï¼Œbitsetå¯ä»¥ç”¨æ¯ä¸€ä½0æˆ–è€…1æ¥è¡¨ç¤ºå¯è¾¾æ€§ï¼Œä¾‹å¦‚å›¾ä¸Šç‚¹ä¸Žç‚¹çš„å¯è¾¾æ€§ï¼Œdpæ—¶å¯è¾¾æ€§ bitsetä¸»è¦ç”¨äºŽæš´åŠ›æžšä¸¾ï¼Œå¦‚æžœbitsetçš„é•¿åº¦æ˜¯n,ä¸€æ¬¡ä¸Žè¿ç®—çš„å¤æ‚åº¦å°±æ˜¯n/32 bitsetä¸»è¦ç”¨äºŽåˆå¹¶é›†åˆï¼Œäº¤å¹¶è¡¥è¿ç®—æ˜¾ç¤ºä¸åŒçš„é€»è¾‘æ„ä¹‰ C/C++ç¼–è¯‘è¿‡ç¨‹ä¸»è¦åˆ†ä¸º4ä¸ªè¿‡ç¨‹ 1) ç¼–è¯‘é¢„å¤„ç† 2) ç¼–è¯‘ã€ä¼˜åŒ–é˜¶æ®µ åœ¨ã€Šç¼–è¯‘åŽŸç†ã€‹ä¸­æˆ‘ä»¬å¯ä»¥äº†è§£åˆ°ä¸€ä¸ªç¼–è¯‘å™¨å¯¹ç¨‹åºä»£ç çš„ç¼–è¯‘ä¸»è¦åˆ†ä¸ºä¸‹é¢å‡ ä¸ªè¿‡ç¨‹ï¼ša) è¯æ³•åˆ†æžb) è¯­æ³•åˆ†æžc) è¯­ä¹‰åˆ†æžd) ä¸­é—´ä»£ç ç”Ÿæˆe) ä»£ç ä¼˜åŒ–f) ä»£ç ç”Ÿæˆg) ç¬¦å·è¡¨ç®¡ç†h) å°†å¤šä¸ªæ­¥éª¤ç»„åˆæˆè¶Ÿ 3) æ±‡ç¼–è¿‡ç¨‹ æ±‡ç¼–è¿‡ç¨‹å®žé™…ä¸ŠæŒ‡æŠŠæ±‡ç¼–è¯­è¨€ä»£ç ç¿»è¯‘æˆç›®æ ‡æœºå™¨æŒ‡ä»¤çš„è¿‡ç¨‹ã€‚å¯¹äºŽè¢«ç¿»è¯‘ç³»ç»Ÿå¤„ç†çš„æ¯ä¸€ä¸ªCè¯­è¨€æºç¨‹åºï¼Œéƒ½å°†æœ€ç»ˆç»è¿‡è¿™ä¸€å¤„ç†è€Œå¾—åˆ°ç›¸åº”çš„ç›®æ ‡æ–‡ä»¶ã€‚ç›®æ ‡æ–‡ä»¶ä¸­æ‰€å­˜æ”¾çš„ä¹Ÿå°±æ˜¯ä¸Žæºç¨‹åºç­‰æ•ˆçš„ç›®æ ‡çš„æœºå™¨è¯­è¨€ä»£ç ã€‚ç›®æ ‡æ–‡ä»¶ç”±æ®µç»„æˆã€‚é€šå¸¸ä¸€ä¸ªç›®æ ‡æ–‡ä»¶ä¸­è‡³å°‘æœ‰ä¸¤ä¸ªæ®µï¼š ä»£ç æ®µï¼šè¯¥æ®µä¸­æ‰€åŒ…å«çš„ä¸»è¦æ˜¯ç¨‹åºçš„æŒ‡ä»¤ã€‚è¯¥æ®µä¸€èˆ¬æ˜¯å¯è¯»å’Œå¯æ‰§è¡Œçš„ï¼Œä½†ä¸€èˆ¬å´ä¸å¯å†™ã€‚ æ•°æ®æ®µï¼šä¸»è¦å­˜æ”¾ç¨‹åºä¸­è¦ç”¨åˆ°çš„å„ç§å…¨å±€å˜é‡æˆ–é™æ€çš„æ•°æ®ã€‚ä¸€èˆ¬æ•°æ®æ®µéƒ½æ˜¯å¯è¯»ï¼Œå¯å†™ï¼Œå¯æ‰§è¡Œçš„ã€‚ æ±‡ç¼–è¯­è¨€å’ŒäºŒçº§åˆ¶ä»£ç æ˜¯ä¸ä¸€æ ·çš„ã€‚æ±‡ç¼–è¯­è¨€æ˜¯æœ€æŽ¥è¿‘æœºå™¨è¯­è¨€çš„ç¼–ç¨‹è¯­è¨€ã€‚å¸¸ç”¨çš„å‘½ä»¤æ¯”å¦‚ï¼š123mov a,#10000000Bmov a,#80Hmov a,#128 4) é“¾æŽ¥ç¨‹åº é“¾æŽ¥ç¨‹åºçš„ä¸»è¦å·¥ä½œå°±æ˜¯å°†æœ‰å…³çš„ç›®æ ‡æ–‡ä»¶å½¼æ­¤ç›¸è¿žæŽ¥ï¼Œä¹Ÿå³å°†åœ¨ä¸€ä¸ªæ–‡ä»¶ä¸­å¼•ç”¨çš„ç¬¦å·åŒè¯¥ç¬¦å·åœ¨å¦å¤–ä¸€ä¸ªæ–‡ä»¶ä¸­çš„å®šä¹‰è¿žæŽ¥èµ·æ¥ï¼Œä½¿å¾—æ‰€æœ‰çš„è¿™äº›ç›®æ ‡æ–‡ä»¶æˆä¸ºä¸€ä¸ªèƒ½å¤Ÿè¯¶æ“ä½œç³»ç»Ÿè£…å…¥æ‰§è¡Œçš„ç»Ÿä¸€æ•´ä½“ã€‚æ ¹æ®å¼€å‘äººå‘˜æŒ‡å®šçš„åŒåº“å‡½æ•°çš„é“¾æŽ¥æ–¹å¼çš„ä¸åŒï¼Œé“¾æŽ¥å¤„ç†å¯åˆ†ä¸ºä¸¤ç§ï¼š ï¼ˆ1ï¼‰é™æ€é“¾æŽ¥ åœ¨è¿™ç§é“¾æŽ¥æ–¹å¼ä¸‹ï¼Œå‡½æ•°çš„ä»£ç å°†ä»Žå…¶æ‰€åœ¨åœ°é™æ€é“¾æŽ¥åº“ä¸­è¢«æ‹·è´åˆ°æœ€ç»ˆçš„å¯æ‰§è¡Œç¨‹åºä¸­ã€‚ è¿™æ ·è¯¥ç¨‹åºåœ¨è¢«æ‰§è¡Œæ—¶è¿™äº›ä»£ç å°†è¢«è£…å…¥åˆ°è¯¥è¿›ç¨‹çš„è™šæ‹Ÿåœ°å€ç©ºé—´ä¸­ã€‚é™æ€é“¾æŽ¥åº“å®žé™…ä¸Šæ˜¯ä¸€ä¸ªç›®æ ‡æ–‡ä»¶çš„é›†åˆï¼Œ å…¶ä¸­çš„æ¯ä¸ªæ–‡ä»¶å«æœ‰åº“ä¸­çš„ä¸€ä¸ªæˆ–è€…ä¸€ç»„ç›¸å…³å‡½æ•°çš„ä»£ç ã€‚ ï¼ˆ2ï¼‰ åŠ¨æ€é“¾æŽ¥åœ¨æ­¤ç§æ–¹å¼ä¸‹ï¼Œå‡½æ•°çš„ä»£ç è¢«æ”¾åˆ°ç§°ä½œæ˜¯åŠ¨æ€é“¾æŽ¥åº“æˆ–å…±äº«å¯¹è±¡çš„æŸä¸ªç›®æ ‡æ–‡ä»¶ä¸­ã€‚é“¾æŽ¥ç¨‹åºæ­¤æ—¶æ‰€ä½œçš„åªæ˜¯åœ¨æœ€ç»ˆçš„å¯æ‰§è¡Œç¨‹åºä¸­è®°å½•ä¸‹å…±äº«å¯¹è±¡çš„åå­—ä»¥åŠå…¶å®ƒå°‘é‡çš„ç™»è®°ä¿¡æ¯ã€‚åœ¨æ­¤å¯æ‰§è¡Œæ–‡ä»¶è¢«æ‰§è¡Œæ—¶ï¼ŒåŠ¨æ€é“¾æŽ¥åº“çš„å…¨éƒ¨å†…å®¹å°†è¢«æ˜ å°„åˆ°è¿è¡Œæ—¶ç›¸åº”è¿›ç¨‹çš„è™šåœ°å€ç©ºé—´ã€‚åŠ¨æ€é“¾æŽ¥ç¨‹åºå°†æ ¹æ®å¯æ‰§è¡Œç¨‹åºä¸­è®°å½•çš„ä¿¡æ¯æ‰¾åˆ°ç›¸åº”çš„å‡½æ•°ä»£ç ã€‚C/C++ç¼–è¯‘è¿‡ç¨‹å¯¹äºŽå¯æ‰§è¡Œæ–‡ä»¶ä¸­çš„å‡½æ•°è°ƒç”¨ï¼Œå¯åˆ†åˆ«é‡‡ç”¨åŠ¨æ€é“¾æŽ¥æˆ–é™æ€é“¾æŽ¥çš„æ–¹æ³•ã€‚ä½¿ç”¨åŠ¨æ€é“¾æŽ¥èƒ½å¤Ÿä½¿æœ€ç»ˆçš„å¯æ‰§è¡Œæ–‡ä»¶æ¯”è¾ƒçŸ­å°ï¼Œå¹¶ä¸”å½“å…±äº«å¯¹è±¡è¢«å¤šä¸ªè¿›ç¨‹ä½¿ç”¨æ—¶èƒ½èŠ‚çº¦ä¸€äº›å†…å­˜ï¼Œå› ä¸ºåœ¨å†…å­˜ä¸­åªéœ€è¦ä¿å­˜ä¸€ä»½æ­¤å…±äº«å¯¹è±¡çš„ä»£ç ã€‚ä½†å¹¶ä¸æ˜¯ä½¿ç”¨åŠ¨æ€é“¾æŽ¥å°±ä¸€å®šæ¯”ä½¿ç”¨é™æ€é“¾æŽ¥è¦ä¼˜è¶Šã€‚åœ¨æŸäº›æƒ…å†µä¸‹åŠ¨æ€é“¾æŽ¥å¯èƒ½å¸¦æ¥ä¸€äº›æ€§èƒ½ä¸ŠæŸå®³ã€‚ Javaç¨‹åºç¼–è¯‘è¿‡ç¨‹ ç”¨gccç¼–è¯‘æˆæ‰§è¡Œç¨‹åºã€‚1gcc hello.c è¯¥å‘½ä»¤å°†hello.cç›´æŽ¥ç”Ÿæˆæœ€ç»ˆäºŒè¿›åˆ¶å¯æ‰§è¡Œç¨‹åºa.out 1gcc hello.c -o hello.exe å¦‚ä½•è¦æŒ‡å®šæœ€ç»ˆäºŒè¿›åˆ¶å¯æ‰§è¡Œç¨‹åºåï¼Œé‚£ä¹ˆç”¨-oé€‰é¡¹æ¥æŒ‡å®šåç§°ã€‚æ¯”å¦‚éœ€è¦ç”Ÿæˆæ‰§è¡Œç¨‹åºhello.exe GCCçš„å‘½ä»¤å‰–æžâ€“å››æ­¥èµ°GCCç¼–è¯‘Cæºç æœ‰å››ä¸ªæ­¥éª¤ï¼š é¢„å¤„ç†â€”â€“&gt; ç¼–è¯‘ â€”-&gt; æ±‡ç¼– â€”-&gt; é“¾æŽ¥ é¢„å¤„ç†åœ¨è¯¥é˜¶æ®µï¼Œç¼–è¯‘å™¨å°†Cæºä»£ç ä¸­çš„åŒ…å«çš„å¤´æ–‡ä»¶å¦‚stdio.hç¼–è¯‘è¿›æ¥ç¼–è¯‘ç¬¬äºŒæ­¥è¿›è¡Œçš„æ˜¯ç¼–è¯‘é˜¶æ®µï¼Œåœ¨è¿™ä¸ªé˜¶æ®µä¸­ï¼ŒGccé¦–å…ˆè¦æ£€æŸ¥ä»£ç çš„è§„èŒƒæ€§ã€æ˜¯å¦æœ‰è¯­æ³•é”™è¯¯ç­‰ï¼Œä»¥ç¡®å®šä»£ç çš„å®žé™…è¦åšçš„å·¥ä½œï¼Œåœ¨æ£€æŸ¥æ— è¯¯åŽï¼ŒGccæŠŠä»£ç ç¿»è¯‘æˆæ±‡ç¼–è¯­è¨€ã€‚ æ±‡ç¼–æ±‡ç¼–é˜¶æ®µæ˜¯æŠŠç¼–è¯‘é˜¶æ®µç”Ÿæˆçš„â€.sâ€æ–‡ä»¶è½¬æˆäºŒè¿›åˆ¶ç›®æ ‡ä»£ç .é“¾æŽ¥é˜¶æ®µ(Link)åœ¨æˆåŠŸç¼–è¯‘ä¹‹åŽï¼Œå°±è¿›å…¥äº†é“¾æŽ¥é˜¶æ®µã€‚ è§£é‡Šåž‹è¯­è¨€å’Œç¼–è¯‘åž‹è¯­è¨€ è®¡ç®—æœºæ˜¯ä¸èƒ½å¤Ÿè¯†åˆ«é«˜çº§è¯­è¨€çš„ï¼Œæ‰€ä»¥å½“æˆ‘ä»¬è¿è¡Œä¸€ä¸ªé«˜çº§è¯­è¨€ç¨‹åºçš„æ—¶å€™ï¼Œå°±éœ€è¦ä¸€ä¸ªâ€œç¿»è¯‘æœºâ€æ¥ä»Žäº‹æŠŠé«˜çº§è¯­è¨€è½¬å˜æˆè®¡ç®—æœºèƒ½è¯»æ‡‚çš„æœºå™¨è¯­è¨€çš„è¿‡ç¨‹ã€‚è¿™ä¸ªè¿‡ç¨‹åˆ†æˆä¸¤ç±»ï¼Œç¬¬ä¸€ç§æ˜¯ç¼–è¯‘ï¼Œç¬¬äºŒç§æ˜¯è§£é‡Šã€‚ ç¼–è¯‘åž‹è¯­è¨€åœ¨ç¨‹åºæ‰§è¡Œä¹‹å‰ï¼Œå…ˆä¼šé€šè¿‡ç¼–è¯‘å™¨å¯¹ç¨‹åºæ‰§è¡Œä¸€ä¸ªç¼–è¯‘çš„è¿‡ç¨‹ï¼ŒæŠŠç¨‹åºè½¬å˜æˆæœºå™¨è¯­è¨€ã€‚è¿è¡Œæ—¶å°±ä¸éœ€è¦ç¿»è¯‘ï¼Œè€Œç›´æŽ¥æ‰§è¡Œå°±å¯ä»¥äº†ã€‚æœ€å…¸åž‹çš„ä¾‹å­å°±æ˜¯Cè¯­è¨€ã€‚ è§£é‡Šåž‹è¯­è¨€å°±æ²¡æœ‰è¿™ä¸ªç¼–è¯‘çš„è¿‡ç¨‹ï¼Œè€Œæ˜¯åœ¨ç¨‹åºè¿è¡Œçš„æ—¶å€™ï¼Œé€šè¿‡è§£é‡Šå™¨å¯¹ç¨‹åºé€è¡Œä½œå‡ºè§£é‡Šï¼Œç„¶åŽç›´æŽ¥è¿è¡Œï¼Œæœ€å…¸åž‹çš„ä¾‹å­æ˜¯Rubyã€‚ é€šè¿‡ä»¥ä¸Šçš„ä¾‹å­ï¼Œæˆ‘ä»¬å¯ä»¥æ¥æ€»ç»“ä¸€ä¸‹è§£é‡Šåž‹è¯­è¨€å’Œç¼–è¯‘åž‹è¯­è¨€çš„ä¼˜ç¼ºç‚¹ï¼Œå› ä¸ºç¼–è¯‘åž‹è¯­è¨€åœ¨ç¨‹åºè¿è¡Œä¹‹å‰å°±å·²ç»å¯¹ç¨‹åºåšå‡ºäº†â€œç¿»è¯‘â€ï¼Œæ‰€ä»¥åœ¨è¿è¡Œæ—¶å°±å°‘æŽ‰äº†â€œç¿»è¯‘â€çš„è¿‡ç¨‹ï¼Œæ‰€ä»¥æ•ˆçŽ‡æ¯”è¾ƒé«˜ã€‚ä½†æ˜¯æˆ‘ä»¬ä¹Ÿä¸èƒ½ä¸€æ¦‚è€Œè®ºï¼Œä¸€äº›è§£é‡Šåž‹è¯­è¨€ä¹Ÿå¯ä»¥é€šè¿‡è§£é‡Šå™¨çš„ä¼˜åŒ–æ¥åœ¨å¯¹ç¨‹åºåšå‡ºç¿»è¯‘æ—¶å¯¹æ•´ä¸ªç¨‹åºåšå‡ºä¼˜åŒ–ï¼Œä»Žè€Œåœ¨æ•ˆçŽ‡ä¸Šè¶…è¿‡ç¼–è¯‘åž‹è¯­è¨€ã€‚ æ­¤å¤–ï¼Œéšç€Javaç­‰åŸºäºŽè™šæ‹Ÿæœºçš„è¯­è¨€çš„å…´èµ·ï¼Œæˆ‘ä»¬åˆä¸èƒ½æŠŠè¯­è¨€çº¯ç²¹åœ°åˆ†æˆè§£é‡Šåž‹å’Œç¼–è¯‘åž‹è¿™ä¸¤ç§ã€‚ ç”¨Javaæ¥ä¸¾ä¾‹ï¼ŒJavaé¦–å…ˆæ˜¯é€šè¿‡ç¼–è¯‘å™¨ç¼–è¯‘æˆå­—èŠ‚ç æ–‡ä»¶ï¼Œç„¶åŽåœ¨è¿è¡Œæ—¶é€šè¿‡è§£é‡Šå™¨ç»™è§£é‡Šæˆæœºå™¨æ–‡ä»¶ã€‚æ‰€ä»¥æˆ‘ä»¬è¯´Javaæ˜¯ä¸€ç§å…ˆç¼–è¯‘åŽè§£é‡Šçš„è¯­è¨€ã€‚ å†æ¢æˆC#ï¼ŒC#é¦–å…ˆæ˜¯é€šè¿‡ç¼–è¯‘å™¨å°†C#æ–‡ä»¶ç¼–è¯‘æˆILæ–‡ä»¶ï¼Œç„¶åŽåœ¨é€šè¿‡CLRå°†ILæ–‡ä»¶ç¼–è¯‘æˆæœºå™¨æ–‡ä»¶ã€‚æ‰€ä»¥æˆ‘ä»¬è¯´C#æ˜¯ä¸€é—¨çº¯ç¼–è¯‘è¯­è¨€ï¼Œä½†æ˜¯C#æ˜¯ä¸€é—¨éœ€è¦äºŒæ¬¡ç¼–è¯‘çš„è¯­è¨€ã€‚åŒç†ä¹Ÿå¯ç­‰æ•ˆè¿ç”¨åˆ°åŸºäºŽ.NETå¹³å°ä¸Šçš„å…¶ä»–è¯­è¨€ã€‚ ç®€è¿°Pythonçš„è¿è¡Œè¿‡ç¨‹åœ¨è¯´è¿™ä¸ªé—®é¢˜ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæ¥è¯´ä¸¤ä¸ªæ¦‚å¿µï¼ŒPyCodeObjectå’Œpycæ–‡ä»¶ã€‚ æˆ‘ä»¬åœ¨ç¡¬ç›˜ä¸Šçœ‹åˆ°çš„pycè‡ªç„¶ä¸å¿…å¤šè¯´ï¼Œè€Œå…¶å®žPyCodeObjectåˆ™æ˜¯Pythonç¼–è¯‘å™¨çœŸæ­£ç¼–è¯‘æˆçš„ç»“æžœã€‚æˆ‘ä»¬å…ˆç®€å•çŸ¥é“å°±å¯ä»¥äº†ï¼Œç»§ç»­å‘ä¸‹çœ‹ã€‚ å½“pythonç¨‹åºè¿è¡Œæ—¶ï¼Œç¼–è¯‘çš„ç»“æžœåˆ™æ˜¯ä¿å­˜åœ¨ä½äºŽå†…å­˜ä¸­çš„PyCodeObjectä¸­ï¼Œå½“Pythonç¨‹åºè¿è¡Œç»“æŸæ—¶ï¼ŒPythonè§£é‡Šå™¨åˆ™å°†PyCodeObjectå†™å›žåˆ°pycæ–‡ä»¶ä¸­ã€‚ å½“pythonç¨‹åºç¬¬äºŒæ¬¡è¿è¡Œæ—¶ï¼Œé¦–å…ˆç¨‹åºä¼šåœ¨ç¡¬ç›˜ä¸­å¯»æ‰¾pycæ–‡ä»¶ï¼Œå¦‚æžœæ‰¾åˆ°ï¼Œåˆ™ç›´æŽ¥è½½å…¥ï¼Œå¦åˆ™å°±é‡å¤ä¸Šé¢çš„è¿‡ç¨‹ã€‚ æ‰€ä»¥æˆ‘ä»¬åº”è¯¥è¿™æ ·æ¥å®šä½PyCodeObjectå’Œpycæ–‡ä»¶ï¼Œæˆ‘ä»¬è¯´pycæ–‡ä»¶å…¶å®žæ˜¯PyCodeObjectçš„ä¸€ç§æŒä¹…åŒ–ä¿å­˜æ–¹å¼ã€‚ æ‰€ä»¥python å’Œjava æ˜¯ä¸€æ ·çš„ï¼Œéƒ½æ˜¯å…ˆç¼–è¯‘ç„¶åŽå†æ‰§è¡Œã€‚ pycçš„ç›®çš„æ˜¯é‡ç”¨ æœ‰æ—¶å€™èƒ½å¤Ÿfind pycæ–‡ä»¶ï¼Œæœ‰æ—¶å€™ä¸èƒ½find pyc æ–‡ä»¶ï¼Œé‚£ä¹ˆé—®é¢˜æ˜¯ä»€ä¹ˆæ—¶å€™èƒ½å¤Ÿ findï¼Œä»€ä¹ˆæ—¶å€™ä¸èƒ½find å‘¢ï¼Ÿæ‰€ä»¥ï¼Œæˆ‘ä»¬éœ€è¦ç¼–è¯‘æˆpycæ–‡ä»¶çš„åº”è¯¥æ˜¯é‚£äº›å¯ä»¥é‡ç”¨çš„æ¨¡å—ï¼Œè¿™äºŽæˆ‘ä»¬åœ¨è®¾è®¡è½¯ä»¶ç±»æ—¶æ˜¯ä¸€æ ·çš„ç›®çš„ã€‚æˆ‘ä»¬å¯ä»¥è¿™æ ·ç†è§£Pythonè§£é‡Šå™¨çš„æ„å›¾ï¼ŒPythonè§£é‡Šå™¨åªæŠŠæˆ‘ä»¬å¯èƒ½é‡ç”¨åˆ°çš„æ¨¡å—æŒä¹…åŒ–æˆpycæ–‡ä»¶ã€‚ pycçš„è¿‡æœŸæ—¶é—´ å…¶å®žäº†è§£Pythonç¨‹åºçš„æ‰§è¡Œè¿‡ç¨‹å¯¹äºŽå¤§éƒ¨åˆ†ç¨‹åºå‘˜ï¼ŒåŒ…æ‹¬Pythonç¨‹åºå‘˜æ¥è¯´æ„ä¹‰éƒ½æ˜¯ä¸å¤§çš„ï¼Œé‚£ä¹ˆçœŸæ­£æœ‰æ„ä¹‰çš„æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥ä»ŽPythonçš„è§£é‡Šå™¨çš„åšæ³•ä¸Šå­¦åˆ°ä»€ä¹ˆï¼Œæˆ‘è®¤ä¸ºæœ‰è¿™æ ·çš„å‡ ç‚¹ï¼š å…¶å®žPythonæ˜¯å¦ä¿å­˜æˆpycæ–‡ä»¶å’Œæˆ‘ä»¬åœ¨è®¾è®¡ç¼“å­˜ç³»ç»Ÿæ—¶æ˜¯ä¸€æ ·çš„ï¼Œæˆ‘ä»¬å¯ä»¥ä»”ç»†æƒ³æƒ³ï¼Œåˆ°åº•ä»€ä¹ˆæ˜¯å€¼å¾—æ‰”åœ¨ç¼“å­˜é‡Œçš„ï¼Œä»€ä¹ˆæ˜¯ä¸å€¼å¾—æ‰”åœ¨ç¼“å­˜é‡Œçš„ã€‚ åœ¨è·‘ä¸€ä¸ªè€—æ—¶çš„Pythonè„šæœ¬æ—¶ï¼Œæˆ‘ä»¬å¦‚ä½•èƒ½å¤Ÿç¨å¾®åŽ‹æ¦¨ä¸€äº›ç¨‹åºçš„è¿è¡Œæ—¶é—´ï¼Œå°±æ˜¯å°†æ¨¡å—ä»Žä¸»æ¨¡å—åˆ†å¼€ã€‚ï¼ˆè™½ç„¶å¾€å¾€è¿™éƒ½ä¸æ˜¯ç“¶é¢ˆï¼‰ åœ¨è®¾è®¡ä¸€ä¸ªè½¯ä»¶ç³»ç»Ÿæ—¶ï¼Œé‡ç”¨å’Œéžé‡ç”¨çš„ä¸œè¥¿æ˜¯ä¸æ˜¯ä¹Ÿåº”è¯¥åˆ†å¼€æ¥å¯¹å¾…ï¼Œè¿™æ˜¯è½¯ä»¶è®¾è®¡åŽŸåˆ™çš„é‡è¦éƒ¨åˆ†ã€‚ åœ¨è®¾è®¡ç¼“å­˜ç³»ç»Ÿï¼ˆæˆ–è€…å…¶ä»–ç³»ç»Ÿï¼‰æ—¶ï¼Œæˆ‘ä»¬å¦‚ä½•æ¥é¿å…ç¨‹åºçš„è¿‡æœŸï¼Œå…¶å®žPythonçš„è§£é‡Šå™¨ä¹Ÿä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªç‰¹åˆ«å¸¸è§è€Œä¸”æœ‰æ•ˆçš„è§£å†³æ–¹æ¡ˆã€‚ å¸¸è§çš„ç¼–è¯‘æ€§è¯­è¨€ï¼š c/ c++, pascalå¸¸è§çš„è§£é‡Šæ€§è¯­è¨€ï¼š java python javascript æœºå™¨ç¿»è¯‘çš„æ–¹å¼æœ‰ä¸¤ç§ï¼Œä¸€ä¸ªæ˜¯ç¼–è¯‘ï¼Œä¸€ä¸ªæ˜¯è§£é‡Šã€‚ä¸¤ç§æ–¹å¼åªæ˜¯ç¿»è¯‘çš„æ—¶é—´ä¸åŒã€‚ç¼–è¯‘åž‹è¯­è¨€å†™çš„ç¨‹åºæ‰§è¡Œä¹‹å‰ï¼Œéœ€è¦ä¸€ä¸ªä¸“é—¨çš„ç¼–è¯‘è¿‡ç¨‹ï¼ŒæŠŠç¨‹åºç¼–è¯‘æˆä¸ºæœºå™¨è¯­è¨€çš„æ–‡ä»¶ï¼Œæ¯”å¦‚exeæ–‡ä»¶ï¼Œä»¥åŽè¦è¿è¡Œçš„è¯å°±ä¸ç”¨é‡æ–°ç¿»è¯‘äº†ï¼Œç›´æŽ¥ä½¿ç”¨ç¼–è¯‘çš„ç»“æžœå°±è¡Œäº†ï¼ˆexeæ–‡ä»¶ï¼‰ï¼Œå› ä¸ºç¿»è¯‘åªåšäº†ä¸€æ¬¡ï¼Œè¿è¡Œæ—¶ä¸éœ€è¦ç¿»è¯‘ï¼Œæ‰€ä»¥ç¼–è¯‘åž‹è¯­è¨€çš„ç¨‹åºæ‰§è¡Œæ•ˆçŽ‡é«˜ã€‚ è§£é‡Šæ€§è¯­è¨€çš„ç¨‹åºä¸éœ€è¦ç¼–è¯‘ï¼Œçœäº†é“å·¥åºï¼Œè§£é‡Šæ€§è¯­è¨€åœ¨è¿è¡Œç¨‹åºçš„æ—¶å€™æ‰ç¿»è¯‘ï¼Œæ¯”å¦‚è§£é‡Šæ€§javaè¯­è¨€ï¼Œä¸“é—¨æœ‰ä¸€ä¸ªè§£é‡Šå™¨èƒ½å¤Ÿç›´æŽ¥æ‰§è¡Œjavaç¨‹åºï¼Œæ¯ä¸ªè¯­å¥éƒ½æ˜¯æ‰§è¡Œçš„æ—¶å€™æ‰ç¿»è¯‘ã€‚è¿™æ ·è§£é‡Šæ€§è¯­è¨€æ¯æ‰§è¡Œä¸€æ¬¡å°±è¦ç¿»è¯‘ä¸€æ¬¡ï¼Œæ•ˆçŽ‡æ¯”è¾ƒä½Žã€‚ è„šæœ¬è¯­è¨€æ˜¯è§£é‡Šæ€§è¯­è¨€ã€‚è„šæœ¬è¯­è¨€ä¸€èˆ¬éƒ½æœ‰ç›¸åº”çš„è„šæœ¬å¼•æ“Žæ¥è§£é‡Šæ‰§è¡Œã€‚å®ƒä»¬ä¸€èˆ¬éœ€è¦è§£é‡Šå™¨æ‰èƒ½è¿è¡Œã€‚æ‰€ä»¥åªè¦ç³»ç»Ÿä¸Šæœ‰ç›¸åº”è¯­è¨€çš„è§£é‡Šç¨‹åºå°±å¯ä»¥åšåˆ°è·¨å¹³å°ã€‚è„šæœ¬è¯­è¨€æ˜¯ä¸€ç§è§£é‡Šæ€§çš„è¯­è¨€ï¼Œä¾‹å¦‚vbscript,javascript,install shield scriptç­‰ç­‰,å®ƒä¸è±¡c\c++ç­‰å¯ä»¥ç¼–è¯‘æˆäºŒè¿›åˆ¶ä»£ç ï¼Œä»¥å¯æ‰§è¡Œæ–‡ä»¶çš„å½¢å¼å­˜åœ¨ã€‚è„šæœ¬è¯­è¨€ä¸éœ€è¦ç¼–è¯‘ï¼Œå¯ä»¥ç›´æŽ¥ç”¨ï¼Œç”±è§£é‡Šå™¨æ¥è´Ÿè´£è§£é‡Šã€‚ ç¼–è¯‘è¯­è¨€ï¼š æ•´ä¸ªç¨‹åºç»è¿‡ç¼–è¯‘ä¹‹åŽå†æ‰§è¡Œï¼Œæ‰§è¡Œæ•ˆçŽ‡é«˜ã€‚è§£é‡Šæ€§è¯­è¨€ï¼Œä¸€è¡Œä¸€è¡Œæ‰§è¡Œï¼Œæ‰§è¡Œæ•ˆçŽ‡ä½Žï¼Œè§£é‡Šæ€§è¯­è¨€åœ¨è¿è¡Œç¨‹åºçš„æ—¶å€™æ‰ç¿»è¯‘ã€‚ï¼ˆæ‰€ä»¥åœ¨debug çš„æ—¶å€™ï¼Œpython çš„å‡ºé”™çš„åœ°æ–¹èƒ½å¤Ÿå®šä½åˆ°æŸä¸€è¡Œï¼Œä½†æ˜¯c++ å°±æ¯”è¾ƒå›°éš¾ã€‚ï¼‰ å…¶å®žjava ä¸èƒ½å®Œå…¨åˆ’åˆ†ä¸ºç¬¬äºŒç±»ï¼Œjava æ‰§è¡Œçš„è¿‡ç¨‹ï¼Œå…ˆæ˜¯ç¼–è¯‘æˆ å­—èŠ‚ç ï¼Œç„¶åŽå†æ‰§è¡Œã€‚è„šæœ¬è¯­è¨€å’Œè§£é‡Šæ€§è¯­è¨€æ˜¯ä¸€ä¸ªæ„æ€ã€‚]]></content>
      <categories>
        <category>CSåŸºç¡€</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leeetcode data structure]]></title>
    <url>%2F2018%2F10%2F04%2Fleeetcode-data-structure%2F</url>
    <content type="text"><![CDATA[æ­£å¼è¿›å…¥ä»£ç æ¨¡æ¿2-æ•°æ®ç»“æž„ä¸“é¢˜ã€‚ å•è°ƒé˜Ÿåˆ—ï¼ˆæ»‘åŠ¨çª—å£ï¼‰æ»‘åŠ¨çª—å£é¢˜ç›®æ€»ç»“ï¼š é¦–å…ˆè€ƒè™‘ç”¨ä¸€ä¸ªæ™®é€šé˜Ÿåˆ—æ€Žä¹ˆåšï¼Ÿï¼ˆå®žé™…ä¸Šå°±æ˜¯æ»‘åŠ¨çª—å£ä½¿ç”¨é˜Ÿåˆ—æ¥ç»´æŠ¤ï¼‰ï¼Œé‚£ä¹ˆO(n) æ˜¯å¾—åˆ°äº†é˜Ÿåˆ—ï¼Œç„¶åŽé˜Ÿåˆ—é•¿åº¦æ˜¯kï¼Œé‚£ä¹ˆæ€»å…±çš„æ—¶é—´å¤æ‚åº¦æ˜¯O(nk) æ™®é€šé˜Ÿåˆ—è¯¥æ€Žä¹ˆåš å°†é˜Ÿåˆ—ä¸­çš„æ²¡æœ‰ç”¨çš„å…ƒç´ åˆ æŽ‰-&gt; å…·æœ‰äº†å•è°ƒæ€§ å¯ä»¥ç”¨ O(1) æ—¶é—´ä»Žé˜Ÿå¤´/ å°¾å–å‡ºæœ€å€¼ ç”¨å¤„ä¸€èˆ¬åªæœ‰ä¸¤å¤„ï¼š æ»‘åŠ¨çª—å£ä¸­çš„æžå€¼ æ‰¾å‡ºç¦»ä»–æœ€è¿‘çš„æ¯”ä»–å°çš„å…ƒç´ æˆ–è€…æœ€å¤§å…ƒç´  12345678 å¸¸è§æ¨¡åž‹ï¼šæ‰¾å‡ºæ»‘åŠ¨çª—å£ä¸­çš„æœ€å¤§å€¼/æœ€å°å€¼int hh = 0, tt = -1;for (int i = 0; i &lt; n; i ++ )&#123; while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ; // åˆ¤æ–­é˜Ÿå¤´æ˜¯å¦æ»‘å‡ºçª—å£ while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ; q[ ++ tt] = i;&#125; ä¾‹é¢˜ 79. æ»‘åŠ¨çª—å£çš„æœ€å¤§å€¼ 1234567891011121314151617181920class Solution &#123;public: // å•è°ƒé˜Ÿåˆ—é—®é¢˜ï¼Œ é˜Ÿåˆ—ä¸­æ˜¯é€’å¢žçš„ï¼Œé‚£ä¹ˆé˜Ÿé¦–å°±æ˜¯æœ€å¤§å€¼ // éœ€è¦ç»´æŠ¤çª—å£size çš„å¤§å°å’Œ ä¿æŒå•è°ƒæ€§ // éœ€è¦ä½¿ç”¨åŒå‘é˜Ÿåˆ— vector&lt;int&gt; maxInWindows(vector&lt;int&gt;&amp; nums, int k) &#123; deque&lt;int&gt; q; vector&lt;int&gt; res; for(int i =0; i&lt; nums.size(); i++ ) &#123; // ç»´æŒçª—å£çš„å¤§å° while(q.size() &amp;&amp; q.front() &lt;= k-i) q.pop_front(); // ç»´æŒå•è°ƒæ€§ while(q.size() &amp;&amp; nums[i] &gt;= nums[q.back()]) q.pop_back(); q.push_back(i); if(q.front() +1&gt;= k) res.push_back(nums[q.front()]); &#125; return res; &#125;&#125;; è¿™ä¸ªæ˜¯å•æœºç‰ˆæœ¬ æ—¶é—´å¤æ‚åº¦æ˜¯$O(n)$ 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int n, k; vector&lt;int&gt; arr; cin&gt;&gt;n&gt;&gt;k; for(int i =0; i&lt; n; i++ ) &#123; int tmp; cin &gt;&gt; tmp; arr.push_back(tmp); &#125; deque&lt;int&gt; q; vector&lt;int&gt; res; for(int i =0; i&lt; n; i++) &#123; while(q.size() &amp;&amp; i-q.front() +1&gt; k ) q.pop_front(); while(q.size() &amp;&amp; arr[i] &gt;= arr[q.back()]) q.pop_back(); q.push_back(i); if(i-k +1&gt;=0) res.push_back(arr[q.front()]); &#125; for(auto u : res) &#123; cout &lt;&lt; u&lt;&lt;" "; &#125; cout &lt;&lt; endl; return 0;&#125; 154. æ»‘åŠ¨çª—å£ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int n,k; cin &gt;&gt;n&gt;&gt;k; vector&lt;int&gt; arr; for(int i =0; i&lt;n; i++) &#123; int tmp; cin &gt;&gt;tmp; arr.push_back(tmp); &#125; deque&lt;int&gt; min_q, max_q; vector&lt;int&gt; min_r, max_r; for(int i =0; i&lt; n; i++) &#123; // è¿™ä¸ªä¸€å®šè¦åˆ†æ¸…è°å¤§è°å° while( max_q.size() &amp;&amp;i- max_q.front() +1 &gt;k) max_q.pop_front(); while(min_q.size() &amp;&amp; i- min_q.front() +1&gt; k) min_q.pop_front(); // max_q æ˜¯é€’å¢žçš„, min_q æ˜¯é€’å‡çš„ while(max_q.size() &amp;&amp; arr[i] &gt;= arr[max_q.back()]) max_q.pop_back(); while(min_q.size() &amp;&amp; arr[i] &lt;= arr[min_q.back()]) min_q.pop_back(); max_q.push_back(i); min_q.push_back(i); if(i -k +1 &gt;=0) max_r.push_back(arr[max_q.front()]); if(i -k +1 &gt;=0) min_r.push_back(arr[min_q.front()]); &#125; for(auto u : min_r) &#123; cout &lt;&lt; u&lt;&lt;" "; &#125; cout &lt;&lt;endl; for(auto u : max_r) &#123; cout &lt;&lt; u&lt;&lt;" "; &#125; cout &lt;&lt;endl;&#125; Trieå­—ç¬¦ä¸²ç»Ÿè®¡ä¸ºä»€ä¹ˆä½¿ç”¨trie æ ‘ï¼Œå› ä¸ºtrie æ ‘å¯ä»¥å¿«é€Ÿçš„ï¼ˆæ—¶é—´å¤æ‚åº¦å¯ä»¥ O(n)ï¼‰åˆ¤æ–­ä¸‹é¢ä¸¤ä¸ªäº‹æƒ… æ˜¯å¦å­˜åœ¨ä¸€ä¸ªä¸²ï¼Œ æ˜¯å½“å‰ä¸²çš„å‰ç¼€ï¼šéåŽ†è·¯å¾„ä¸­æ˜¯å¦å­˜åœ¨å­—ç¬¦ä¸²ç»“å°¾æ ‡å¿—ã€‚ å½“å‰ä¸²ï¼Œæ˜¯å¦æ˜¯æŸä¸ªä¸²çš„å‰ç¼€ï¼šéåŽ†è·¯å¾„ä¸­ï¼Œ æ˜¯å¦åˆ›å»ºè¿‡æ–°çš„èŠ‚ç‚¹ã€‚ 142. å‰ç¼€ç»Ÿè®¡ è¾“å…¥çš„æ•°æ®å¤§äºŽ 100ä¸‡çš„è¯ï¼Œé‚£ä¹ˆä½¿ç”¨ scanf() ï¼Œå¦åˆ™ä½¿ç”¨ cin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;const int N =1e6+11, M =5e5;int n, m;// ä½¿ç”¨æ•°ç»„çš„æ–¹å¼å­˜å‚¨trie,ä¹Ÿæ˜¯å¯ä»¥ä½¿ç”¨ç»“æž„ä½“çš„æ–¹å¼int son[M][26], cnt[N], idx;//cnt è¡¨ç¤ºä»¥å½“å‰èŠ‚ç‚¹ä¸ºç»ˆç‚¹çš„å•è¯çš„ä¸ªæ•°, idx æ˜¯éåŽ†çš„æŒ‡é’ˆchar str[N];void insert()&#123; int p =0; // ä¸€èˆ¬ä½¿ç”¨ 0å·èŠ‚ç‚¹è¡¨ç¤ºæ ¹èŠ‚ç‚¹ for(int i=0; str[i]; i++ ) &#123; // é¦–å…ˆæžåˆ°å½“å‰èŠ‚ç‚¹çš„å„¿å­ int &amp;s =son[p][str[i] -'a']; if(!s) s = ++ idx;// å¦‚æžœä¸å­˜åœ¨çš„è¯ï¼Œé‚£å°±é‡æ–°åˆ†é…ä¸€ä¸ªæ–°çš„æŒ‡é’ˆ p =s; &#125; // æœ€åŽpå°±æ˜¯ç»ˆç‚¹ï¼Œ cnt[p] ++; // è¿™ä¸ªæ˜¯ç»Ÿè®¡çš„æ—¶å€™ï¼Œä»¥å½“å‰çš„ç‚¹ä¸ºç»ˆç‚¹çš„ä¸ªæ•°&#125;int query()&#123; int p =0, res =0; for(int i =0; str[i] ; i++) &#123; int &amp;s =son[p][str[i] -'a']; if(!s) break; p =s; res += cnt[p]; &#125; return res;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); // å¦‚æžœå¤§äºŽ 100ä¸‡ while(n --) &#123; scanf("%s", str); insert(); &#125; while(m --) &#123; scanf("%s", str); printf("%d\n", query()); &#125; return 0;&#125; 161. ç”µè¯åˆ—è¡¨ è¿™ä¸ªæ¯”è¾ƒéš¾ï¼Œ å¯ä»¥æŽ¥ç€çœ‹ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N =100010;int n ;int son[N][10], idx;char str[10010];bool f[N];// éœ€è¦åˆ¤æ–­ä¸¤ä¸ªå†…å®¹bool insert(char * str)&#123; int p =0; bool is_match =false; bool has_new_node =false; for(int i =0; str[i]; i++) &#123; int u =str[i] -'0'; if( !son[p][u]) &#123; son[p][u] = ++idx; has_new_node =true; &#125; p =son[p][u]; if(f[p]) is_match =true; &#125; f[p] =true; return !is_match &amp;&amp; has_new_node; &#125;int main()&#123; int T; cin &gt;&gt; T; // vector&lt;int&gt; å…¶å®žä¹Ÿæ˜¯å¯ä»¥exactly çš„åˆå§‹åŒ– // å¯¹äºŽ æ•°ç»„è¿™æ ·è¿›è¡Œåˆå§‹åŒ–, while(T--) &#123; cin &gt;&gt;n; memset(son, 0, sizeof son); memset(f, false, sizeof f); idx =0; bool res =true; for(int i =0; i&lt; n; i++) &#123; cin &gt;&gt; str; if(!insert(str)) res =false; &#125; if(res ) puts("YES"); else puts("NO"); &#125; return 0;&#125; æœç´¢å’Œå›¾è®ºå†³å®šæˆ‘ä»¬é‡‡ç”¨é‚»æŽ¥çŸ©é˜µè¿˜æ˜¯é‡‡ç”¨é‚»æŽ¥è¡¨æ¥è¡¨ç¤ºå›¾ï¼Œéœ€è¦åˆ¤æ–­ä¸€ä¸ªå›¾æ˜¯ç¨€ç–å›¾è¿˜æ˜¯ç¨ å¯†å›¾ã€‚ç¨ å¯†å›¾å’Œç¨€ç–å›¾çš„åˆ¤æ–­æ˜¯è¾¹æ•°å’Œé¡¶ç‚¹æ ‘çš„å…³ç³»ï¼Œå¦‚æžœç‚¹æ•°å°‘ï¼Œè¾¹æ•°å¤šï¼Œé‚£ä¹ˆå°±æ˜¯ç¨ å¯†å›¾ï¼Œåä¹‹å°±æ˜¯ç¨€ç–å›¾ã€‚å…·ä½“å…³ç³»ï¼Œé‚»æŽ¥çŸ©é˜µé€‚ç”¨äºŽç¨ å¯†å›¾ï¼ˆè¾¹æ•°æŽ¥è¿‘äºŽé¡¶ç‚¹æ•°çš„å¹³æ–¹ï¼‰è¿™ç§fï¼Œé‚»æŽ¥è¡¨é€‚ç”¨äºŽç¨€ç–å›¾ï¼ˆè¾¹æ•°è¿œå°äºŽé¡¶ç‚¹æ•°çš„å¹³æ–¹ï¼‰ã€‚æ®è¯´ï¼šé‚»æŽ¥è¡¨æ˜¯è¡¨ç¤ºå›¾çš„æ ‡å‡†æ–¹æ³•ï¼ŒåŽŸå› æ˜¯ç¨ å¯†å›¾åœ¨å®žé™…åº”ç”¨ä¸­å¹¶ä¸å¤šè§ã€‚å› ä¸ºç¨ å¯†å›¾ç”¨é‚»æŽ¥è¡¨è¡¨ç¤ºçš„è¯ä¼šå ç”¨å¾ˆå¤šç©ºé—´ï¼Œè€Œé‚»æŽ¥çŸ©é˜µçš„ç©ºé—´æ˜¯å›ºå®šçš„éƒ½æ˜¯nÂ²ï¼Œæ‰€ä»¥ç”¨çŸ©é˜µè¡¨ç¤ºç¨ å¯†å›¾ã€‚ é—®é¢˜è§£é‡Šï¼šä»Žå›¾ä¸­çš„æŸä¸ªé¡¶ç‚¹å‡ºå‘åˆ°è¾¾å¦å¤–ä¸€ä¸ªé¡¶ç‚¹çš„æ‰€ç»è¿‡çš„è¾¹çš„æƒé‡å’Œæœ€å°çš„ä¸€æ¡è·¯å¾„ï¼Œç§°ä¸ºæœ€çŸ­è·¯å¾„ ç®—æ³•ç‰¹ç‚¹ï¼š è¿ªç§‘æ–¯å½»ç®—æ³•ä½¿ç”¨äº†å¹¿åº¦ä¼˜å…ˆæœç´¢è§£å†³èµ‹æƒæœ‰å‘å›¾æˆ–è€…æ— å‘å›¾çš„å•æºæœ€çŸ­è·¯å¾„é—®é¢˜ï¼Œç®—æ³•æœ€ç»ˆå¾—åˆ°ä¸€ä¸ªæœ€çŸ­è·¯å¾„æ ‘ã€‚è¯¥ç®—æ³•å¸¸ç”¨äºŽè·¯ç”±ç®—æ³•æˆ–è€…ä½œä¸ºå…¶ä»–å›¾ç®—æ³•çš„ä¸€ä¸ªå­æ¨¡å—ã€‚ ä»Žé¡¶ç‚¹v1åˆ°å…¶ä»–å„ä¸ªé¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ ç™¾åº¦è¿‡åŽä»¿ä½›æ‰“å¼€äº†æ–°ä¸–ç•Œçš„å¤§é—¨ï¼Œå¤´æ–‡ä»¶å±…ç„¶è¿˜å¯ä»¥è¿™æ ·ç”¨ï¼ï¼1#include&lt;bits/stdc++.h&gt; // ä¸‡èƒ½å¤´æ–‡ä»¶ï¼Œ å¦‚æžœä¸èƒŒä¼š é‚£æ‰æ˜¯å‚»é€¼ Dijkstraæ±‚æœ€çŸ­è·¯ I æ¯”è¾ƒå¥½çš„è®²è§£ æœ´ç´ dijkstraç®—æ³• æ—¶é—´å¤æ‚æ˜¯ $O(n^2+m)$ï¼Œ $n$è¡¨ç¤ºç‚¹æ•°ï¼Œ$m $è¡¨ç¤ºè¾¹æ•° 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 510;int n, m;int g[N][N];int dist[N];bool st[N]; // trueè¡¨ç¤ºå·²ç»ç¡®å®šæœ€çŸ­è·¯int dijkstra()&#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0; // è¿­ä»£næ¬¡ï¼Œæ¯æ¬¡å¯ä»¥ç¡®å®šä¸€ä¸ªç‚¹åˆ°èµ·ç‚¹çš„æœ€çŸ­è·¯ for (int i = 0; i &lt; n; i++) &#123; // æ‰¾åˆ°å½“å‰æ²¡æœ‰ç¡®å®šæœ€çŸ­è·¯çš„ç‚¹ä¸­è·ç¦»æœ€å°çš„é‚£ä¸ª int t = -1; for (int j = 1; j &lt;= n; j++) if (!st[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j; st[t] = true; // ç”¨tæ›´æ–°å…¶ä»–æœªç¡®å®šæœ€çŸ­è·¯çš„ç‚¹çš„åˆ°èµ·ç‚¹çš„è·ç¦» for (int j = 1; j &lt;= n; j++) if (!st[j]) // ifå¯åŠ å¯ä¸åŠ  dist[j] = min(dist[j], dist[t] + g[t][j]); &#125; if (dist[n] == 0x3f3f3f3f) return -1; // 1ä¸Žnä¸è¿žé€š return dist[n];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; memset(g, 0x3f, sizeof g); while (m--) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); g[a][b] = min(g[a][b], c); // æœ‰é‡è¾¹ä¿ç•™çŸ­çš„ä¸€æ¡ &#125; cout &lt;&lt; dijkstra() &lt;&lt; endl; return 0;&#125; memsetè¯¦è§£ è®¾ç½®æ— ç©·å¤§INF é€šå¸¸æƒ…å†µä¸‹åœ¨ å›¾è®¡ç®—ä¸­çš„åˆå§‹åŒ–éƒ½æ˜¯ä½¿ç”¨ 0x3f è€Œä¸æ˜¯ 0x7fffffï¼ˆint æ‰€èƒ½è¡¨ç¤ºçš„æœ€å¤§å€¼ï¼‰ 12345678910111213141516171819Memsetä¸­æ— ç©·å¤§å¸¸é‡çš„è®¾å®šæŠ€å·§å¦‚æžœé—®é¢˜ä¸­å„æ•°æ®çš„èŒƒå›´æ˜Žç¡®ï¼Œé‚£ä¹ˆæ— ç©·å¤§çš„è®¾å®šä¸æ˜¯é—®é¢˜ï¼Œåœ¨ä¸æ˜Žç¡®çš„æƒ…å†µä¸‹ï¼Œå¾ˆå¤šç¨‹åºå‘˜éƒ½å–0x7fffffffä½œä¸ºæ— ç©·å¤§ï¼Œå› ä¸ºè¿™æ˜¯32-bit intçš„æœ€å¤§å€¼ã€‚å¦‚æžœè¿™ä¸ªæ— ç©·å¤§åªç”¨äºŽä¸€èˆ¬çš„æ¯”è¾ƒï¼ˆæ¯”å¦‚æ±‚æœ€å°å€¼æ—¶minå˜é‡çš„åˆå€¼ï¼‰ï¼Œé‚£ä¹ˆ0x7fffffffç¡®å®žæ˜¯ä¸€ä¸ªå®Œç¾Žçš„é€‰æ‹©ï¼Œä½†æ˜¯åœ¨æ›´å¤šçš„æƒ…å†µä¸‹ï¼Œ0x7fffffffå¹¶ä¸æ˜¯ä¸€ä¸ªå¥½çš„é€‰æ‹©ã€‚å¾ˆå¤šæ—¶å€™æˆ‘ä»¬å¹¶ä¸åªæ˜¯å•çº¯æ‹¿æ— ç©·å¤§æ¥ä½œæ¯”è¾ƒï¼Œè€Œæ˜¯ä¼šè¿ç®—åŽå†åšæ¯”è¾ƒï¼Œä¾‹å¦‚åœ¨å¤§éƒ¨åˆ†æœ€çŸ­è·¯å¾„ç®—æ³•ä¸­éƒ½ä¼šä½¿ç”¨çš„æ¾å¼›æ“ä½œï¼šif (d[u]+w[u][v]&lt;d[v]) d[v]=d[u]+w[u][v];æˆ‘ä»¬çŸ¥é“å¦‚æžœu,vä¹‹é—´æ²¡æœ‰è¾¹ï¼Œé‚£ä¹ˆw[u][v]=INFï¼Œå¦‚æžœæˆ‘ä»¬çš„INFå–0x7fffffffï¼Œé‚£ä¹ˆd[u]+w[u][v]ä¼šæº¢å‡ºè€Œå˜æˆè´Ÿæ•°ï¼Œæˆ‘ä»¬çš„æ¾å¼›æ“ä½œä¾¿å‡ºé”™äº†ï¼Œæ›´ä¸€èˆ¬çš„è¯´ï¼Œ0x7fffffffä¸èƒ½æ»¡è¶³â€œæ— ç©·å¤§åŠ ä¸€ä¸ªæœ‰ç©·çš„æ•°ä¾ç„¶æ˜¯æ— ç©·å¤§â€ï¼Œå®ƒå˜æˆäº†ä¸€ä¸ªå¾ˆå°çš„è´Ÿæ•°ã€‚é™¤äº†è¦æ»¡è¶³åŠ ä¸Šä¸€ä¸ªå¸¸æ•°ä¾ç„¶æ˜¯æ— ç©·å¤§ä¹‹å¤–ï¼Œæˆ‘ä»¬çš„å¸¸é‡è¿˜åº”è¯¥æ»¡è¶³â€œæ— ç©·å¤§åŠ æ— ç©·å¤§ä¾ç„¶æ˜¯æ— ç©·å¤§â€ï¼Œè‡³å°‘ä¸¤ä¸ªæ— ç©·å¤§ç›¸åŠ ä¸åº”è¯¥å‡ºçŽ°ç¾éš¾æ€§çš„é”™è¯¯ï¼Œè¿™ä¸€ç‚¹ä¸Š0x7fffffffä¾ç„¶ä¸èƒ½æ»¡è¶³æˆ‘ä»¬ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ›´å¥½çš„å®¶ä¼™æ¥é¡¶æ›¿0x7fffffffï¼Œæœ€ä¸¥è°¨çš„åŠžæ³•å½“ç„¶æ˜¯å¯¹æ— ç©·å¤§è¿›è¡Œç‰¹åˆ«å¤„ç†è€Œä¸æ˜¯æ‰¾ä¸€ä¸ªå¾ˆå¤§å¾ˆå¤§çš„å¸¸é‡æ¥ä»£æ›¿å®ƒï¼ˆæˆ–è€…è¯´æ¨¡æ‹Ÿå®ƒï¼‰ï¼Œä½†æ˜¯è¿™æ ·ä¼šè®©æˆ‘ä»¬çš„ç¼–ç¨‹è¿‡ç¨‹å˜å¾—å¾ˆéº»çƒ¦ã€‚åœ¨æˆ‘è¯»è¿‡çš„ä»£ç ä¸­ï¼Œæœ€ç²¾å·§çš„æ— ç©·å¤§å¸¸é‡å–å€¼æ˜¯0x3f3f3f3fï¼Œæˆ‘ä¸çŸ¥é“æ˜¯è°æœ€å…ˆå¼€å§‹ä½¿ç”¨è¿™ä¸ªç²¾å¦™çš„å¸¸é‡æ¥åšæ— ç©·å¤§ï¼Œä¸è¿‡æˆ‘çš„ç¡®æ˜¯ä»Žä¸€ä½ä¸è®¤è¯†çš„ACMer(ID:Staginner)çš„åšå®¢ä¸Šå­¦åˆ°çš„ï¼Œä»–/å¥¹çš„å¾ˆå¤šä»£ç ä¸­éƒ½ä½¿ç”¨äº†è¿™ä¸ªå¸¸é‡ï¼ŒäºŽæ˜¯æˆ‘è‡ªå·±ä¹Ÿå°è¯•äº†ä¸€ä¸‹ï¼Œå‘çŽ°éžå¸¸å¥½ç”¨ï¼Œè€Œå½“æˆ‘å¯¹è¿™ä¸ªå¸¸é‡åšæ›´æ·±å…¥çš„åˆ†æžæ—¶ï¼Œå°±å‘çŽ°å®ƒçœŸçš„æ˜¯éžå¸¸ç²¾å·§äº†ã€‚0x3f3f3f3fçš„åè¿›åˆ¶æ˜¯1061109567ï¼Œä¹Ÿå°±æ˜¯10^9çº§åˆ«çš„ï¼ˆå’Œ0x7fffffffä¸€ä¸ªæ•°é‡çº§ï¼‰ï¼Œè€Œä¸€èˆ¬åœºåˆä¸‹çš„æ•°æ®éƒ½æ˜¯å°äºŽ10^9çš„ï¼Œæ‰€ä»¥å®ƒå¯ä»¥ä½œä¸ºæ— ç©·å¤§ä½¿ç”¨è€Œä¸è‡´å‡ºçŽ°æ•°æ®å¤§äºŽæ— ç©·å¤§çš„æƒ…å½¢ã€‚å¦ä¸€æ–¹é¢ï¼Œç”±äºŽä¸€èˆ¬çš„æ•°æ®éƒ½ä¸ä¼šå¤§äºŽ10^9ï¼Œæ‰€ä»¥å½“æˆ‘ä»¬æŠŠæ— ç©·å¤§åŠ ä¸Šä¸€ä¸ªæ•°æ®æ—¶ï¼Œå®ƒå¹¶ä¸ä¼šæº¢å‡ºï¼ˆè¿™å°±æ»¡è¶³äº†â€œæ— ç©·å¤§åŠ ä¸€ä¸ªæœ‰ç©·çš„æ•°ä¾ç„¶æ˜¯æ— ç©·å¤§â€ï¼‰ï¼Œäº‹å®žä¸Š0x3f3f3f3f+0x3f3f3f3f=2122219134ï¼Œè¿™éžå¸¸å¤§ä½†å´æ²¡æœ‰è¶…è¿‡32-bit intçš„è¡¨ç¤ºèŒƒå›´ï¼Œæ‰€ä»¥0x3f3f3f3fè¿˜æ»¡è¶³äº†æˆ‘ä»¬â€œæ— ç©·å¤§åŠ æ— ç©·å¤§è¿˜æ˜¯æ— ç©·å¤§â€çš„éœ€æ±‚ã€‚æœ€åŽï¼Œ0x3f3f3f3fè¿˜èƒ½ç»™æˆ‘ä»¬å¸¦æ¥ä¸€ä¸ªæ„æƒ³ä¸åˆ°çš„é¢å¤–å¥½å¤„ï¼šå¦‚æžœæˆ‘ä»¬æƒ³è¦å°†æŸä¸ªæ•°ç»„æ¸…é›¶ï¼Œæˆ‘ä»¬é€šå¸¸ä¼šä½¿ç”¨memset(a,0,sizeof(a))è¿™æ ·çš„ä»£ç æ¥å®žçŽ°ï¼ˆæ–¹ä¾¿è€Œé«˜æ•ˆï¼‰ï¼Œä½†æ˜¯å½“æˆ‘ä»¬æƒ³å°†æŸä¸ªæ•°ç»„å…¨éƒ¨èµ‹å€¼ä¸ºæ— ç©·å¤§æ—¶ï¼ˆä¾‹å¦‚è§£å†³å›¾è®ºé—®é¢˜æ—¶é‚»æŽ¥çŸ©é˜µçš„åˆå§‹åŒ–ï¼‰ï¼Œå°±ä¸èƒ½ä½¿ç”¨memsetå‡½æ•°è€Œå¾—è‡ªå·±å†™å¾ªçŽ¯äº†ï¼ˆå†™è¿™äº›ä¸é‡è¦çš„ä»£ç çœŸçš„å¾ˆç—›è‹¦ï¼‰ï¼Œæˆ‘ä»¬çŸ¥é“è¿™æ˜¯å› ä¸ºmemsetæ˜¯æŒ‰å­—èŠ‚æ“ä½œçš„ï¼Œå®ƒèƒ½å¤Ÿå¯¹æ•°ç»„æ¸…é›¶æ˜¯å› ä¸º0çš„æ¯ä¸ªå­—èŠ‚éƒ½æ˜¯0ï¼ŒçŽ°åœ¨å¥½äº†ï¼Œå¦‚æžœæˆ‘ä»¬å°†æ— ç©·å¤§è®¾ä¸º0x3f3f3f3fï¼Œé‚£ä¹ˆå¥‡è¿¹å°±å‘ç”Ÿäº†ï¼Œ0x3f3f3f3fçš„æ¯ä¸ªå­—èŠ‚éƒ½æ˜¯0x3fï¼æ‰€ä»¥è¦æŠŠä¸€æ®µå†…å­˜å…¨éƒ¨ç½®ä¸ºæ— ç©·å¤§ï¼Œæˆ‘ä»¬åªéœ€è¦memset(a,0x3f,sizeof(a))ã€‚æ‰€ä»¥åœ¨é€šå¸¸çš„åœºåˆä¸‹ï¼Œ0x3f3f3f3fçœŸçš„æ˜¯ä¸€ä¸ªéžå¸¸æ£’çš„é€‰æ‹©ã€‚ å †ä¼˜åŒ–ç‰ˆdijkstra â€”â€” æ¨¡æ¿é¢˜ AcWing 850. Dijkstraæ±‚æœ€çŸ­è·¯ II æ—¶é—´å¤æ‚åº¦ $O(mlogn) $, $n $è¡¨ç¤ºç‚¹æ•°ï¼Œ$m$è¡¨ç¤ºè¾¹æ•°ï¼Œ ä»Žæ—¶é—´å¤æ‚åº¦è§’åº¦åˆ†æžä¸ºä»€ä¹ˆè¿™ç§æ˜¯æ¯”è¾ƒä¼˜ç§€çš„ç®—æ³•ï¼Œå› ä¸º $n$ ï¼ˆç‚¹æ•°ï¼‰è¿œè¿œå¤§äºŽ $m$ ï¼Œæ‰€ä»¥ç»è¿‡ log å¤„ç†ä¹‹åŽï¼Œæœ€åŽæ—¶é—´å¤æ‚åº¦æ˜¯æ¯”è¾ƒä»¤äººæ»¡æ„çš„ã€‚ è¿™ä¸ªæ—¶é—´å¤æ‚åº¦ä¸çŸ¥é“æ˜¯æ€Žä¹ˆåˆ†æžå‡ºæ¥çš„ï¼Ÿ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;int m, n;struct Node&#123; int vec; int w;&#125;;const int N =1e5+11;bool vis[N];int dis[N];vector&lt;Node&gt; g[N];typedef pair&lt;int, int&gt; P;void dijkstra()&#123; // åˆå§‹åŒ– memset(vis, 0, sizeof vis); for(int i =1; i&lt;=m ; i++) dis[i] =INT_MAX; dis[1] =0; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt;&gt; heap; heap.push(&#123;0, 1&#125;); // ç¬¬ä¸€ä¸ªç»´åº¦æ˜¯ distance, ç¬¬äºŒä¸ªç»´åº¦æ˜¯ vec while(heap.size()) &#123; auto t =heap.top(); heap.pop(); int vec =t.second; int distance =t.first; if(vis[vec] ==1) continue; vis[vec] =1; for(int i =0; i&lt; g[vec].size() ; i++) &#123; int next_node =g[vec][i].vec; if(distance+ g[vec][i].w &lt; dis[next_node]) &#123; dis[next_node] =distance + g[vec][i].w; heap.push(&#123;dis[next_node], next_node&#125;); &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt;m &gt;&gt;n; //m ä¸ªç‚¹ï¼Œ n ä¸ªè¾¹ Node tmp; int a, b, c; for(int i =0; i&lt; n; i++) &#123; cin &gt;&gt; a&gt;&gt; b&gt;&gt; c; tmp.vec =b; tmp.w =c; g[a].emplace_back(tmp); &#125; dijkstra(); if(dis[m] ==INT_MAX) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; dis[m] &lt;&lt; endl; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;int m, n; // è¡¨ç¤ºm ä¸ªè¾¹ï¼Œ nä¸ªç‚¹// å®šä¹‰ä¸€ä¸ªç»“ç‚¹ï¼Œstruct node&#123; int index; int w;&#125;;const int N =100010;bool vis[N];int dis[N];vector&lt;node&gt; g[N];typedef pair&lt;int, int&gt; P;// è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•void dijkstra()&#123; // åˆå§‹åŒ– memset(dis, INT_MAX, sizeof dis); dis[1] =0; memset(vis, 0, sizeof vis); // æœ´ç´ dijstraç®—æ³• æ—¶é—´å¤æ‚åº¦ O(n^2+m) nè¡¨ç¤ºç‚¹æ•°ï¼Œ m è¡¨ç¤ºè¾¹æ•° // ä½¿ç”¨å°æ ¹å †ä¼˜åŒ–æ—¶é—´å¤æ‚åº¦ä¸ºO(mlogn) mè¡¨ç¤ºè¾¹æ•° n è¡¨ç¤ºç‚¹æ•° // ä½¿ç”¨å°æ ¹å † priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt;&gt; heap; heap.push(&#123;0, 1&#125;); while(heap.size()) &#123; auto t =heap.top(); heap.pop(); int ver =t.second; int d =t.first; // è¿™ä¸ªä¼˜åŒ–ä¸€ä¸‹ if(vis[ver] ==1) continue; vis[ver] =1; for(int i =0; i&lt; g[ver].size(); i++) &#123; int nex_node =g[ver][i].index; if(d +g[ver][i].w &lt; dis[nex_node] &amp;&amp; vis[nex_node] ==0) &#123; dis[nex_node] = d + g[ver][i].w; heap.push(&#123;dis[nex_node], nex_node&#125;); &#125; &#125; &#125; &#125;int main()&#123; cin&gt;&gt; n &gt;&gt;m; int x, y, z; node tmp; for(int i =0; i&lt;m ; i++) &#123; cin &gt;&gt;x&gt;&gt;y&gt;&gt;z; tmp.index =y; tmp.w =z; g[x].push_back(tmp); &#125; dijkstra(); for(int i =0; i&lt;=n ; i++) cout &lt;&lt; dis[i] &lt;&lt; " "; if(dis[n] !=INT_MAX) cout &lt;&lt; dis[n]&lt;&lt; endl; else cout &lt;&lt; -1&lt;&lt; endl; return 0;&#125; cpp ä¸­é»˜è®¤æ˜¯å¤§æ ¹å †ï¼Œå¯ä»¥é€šè¿‡è®¾ç½®( greater å‚æ•°å’Œ small_heap æ­£å¥½æ˜¯ç›¸åçš„) 12//æž„é€ ä¸€ä¸ªç©ºçš„ä¼˜å…ˆé˜Ÿåˆ—,æ­¤ä¼˜å…ˆé˜Ÿåˆ—æ˜¯ä¸€ä¸ªå°é¡¶å †priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; small_heap; //emplaceå‡½æ•°çš„å‚æ•°æ ¹æ®å…ƒç´ ç±»åž‹è€Œå˜åŒ–ï¼Œå‚æ•°å¿…é¡»ä¸Žå…ƒç´ ç±»åž‹çš„æž„é€ å‡½æ•°ç›¸åŒ¹é…ã€‚emplaceå‡½æ•°åœ¨å®¹å™¨ä¸­ç›´æŽ¥æž„é€ å…ƒç´ ã€‚ä¼ é€’ç»™emplaceå‡½æ•°çš„å‚æ•°å¿…é¡»ä¸Žå…ƒç´ ç±»åž‹çš„æž„é€ å‡½æ•°ç›¸åŒ¹é…ã€‚// emplaceç›¸å…³å‡½æ•°å¯ä»¥å‡å°‘å†…å­˜æ‹·è´å’Œç§»åŠ¨ã€‚å½“æ’å…¥rvalueï¼Œå®ƒèŠ‚çº¦äº†ä¸€æ¬¡moveæž„é€ ï¼Œå½“æ’å…¥lvalueï¼Œå®ƒèŠ‚çº¦äº†ä¸€æ¬¡copyæž„é€ ã€‚ 787. Cheapest Flights Within K Stops è¿™ä¸ªæ˜¯åŒå…³é”®å­—çš„ dijkstra ç®—æ³•ï¼Œ è®²è§£ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct Node&#123; int no, stops; // å¯ä»¥ç†è§£ä¸ºåŒå…³é”®å­— int distance; Node(int no_, int stops_, int distance_): no(no_), stops(stops_), distance(distance_) &#123;&#125; // åœ¨ç»“æž„ä½“ä¸­ï¼Œå°±æ˜¯è¿™æ ·ä½¿ç”¨çš„ bool operator &gt;(const Node &amp;other) const &#123; return distance &gt; other.distance; &#125; &#125;;class Solution &#123;public: int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int K) &#123; //const int INF =1e9; vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph(n); // è¿™ä¸ªæ˜¯é‚»æŽ¥çŸ©é˜µ for(auto &amp;v :flights) graph[v[0]].emplace_back(v[1], v[2]); K ++; vector&lt;vector&lt;int&gt;&gt; dis(n, vector&lt;int&gt;(K +1,INT_MAX )); vector&lt;vector&lt;bool&gt;&gt; vis(n, vector&lt;bool&gt;(K +1, false)); priority_queue&lt;Node, vector&lt;Node&gt;, greater&lt;Node&gt;&gt; q; q.push(Node(src, 0, 0)); dis[src][0] =0; while(q.size()) &#123; auto u =q.top(); q.pop(); // è¿™é‡Œä½“çŽ°äº†åŒå…³é”®å­— if(vis[u.no][u.stops] ) continue; vis[u.no][u.stops] =true; for(const auto &amp;v : graph[u.no]) if(u.stops +1 &lt;=K &amp;&amp; dis[u.no][u.stops] + v.second &lt; dis[v.first][u.stops +1])&#123; dis[v.first][u.stops +1] =dis[u.no][u.stops] +v.second; q.push(Node(v.first, u.stops+1, dis[v.first][u.stops +1]));// è¿™ç§åŒå…³é”®å­—å°±ä¸å¤ªå¥½å®¹æ˜“ç†è§£äº† &#125; &#125; int ans =INT_MAX; for(int i =1; i&lt;=K ; i++) &#123; ans =min(ans, dis[dst][i]); &#125; if(ans ==INT_MAX) ans =-1; return ans; &#125;&#125;; floydç®—æ³• â€”â€” æ¨¡æ¿é¢˜ AcWing 854. Floydæ±‚æœ€çŸ­è·¯æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n^3)$, $n$è¡¨ç¤ºç‚¹æ•° ç®€å•çš„è¯´å°±æ˜¯è§£å†³ä»»æ„ä¸¤ç‚¹é—´çš„æœ€çŸ­è·¯å¾„çš„ä¸€ç§ç®—æ³•ï¼Œå¯ä»¥æ­£ç¡®å¤„ç†æœ‰å‘å›¾æˆ–è´Ÿæƒçš„æœ€çŸ­è·¯å¾„é—®é¢˜ï¼ŒåŒæ—¶ä¹Ÿè¢«ç”¨äºŽè®¡ç®—æœ‰å‘å›¾çš„ä¼ é€’é—­åŒ…ã€‚Floyd-Warshallç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(N3)ï¼Œç©ºé—´å¤æ‚åº¦ä¸ºO(N2)ã€‚ 1.dijkstraç®—æ³•,æœ€ç»å…¸çš„å•æºæœ€çŸ­è·¯å¾„ç®—æ³• ä¸Šç¯‡æ–‡ç« å·²ç»è®²åˆ° 2.bellman-fordç®—æ³•,å…è®¸è´Ÿæƒè¾¹çš„å•æºæœ€çŸ­è·¯å¾„ç®—æ³• 3.spfa,å…¶å®žæ˜¯bellman-ford+é˜Ÿåˆ—ä¼˜åŒ–,å…¶å®žå’Œbfsçš„å…³ç³»æ›´å¯†ä¸€ç‚¹ 4.floydç®—æ³•,ç»å…¸çš„å¤šæºæœ€çŸ­è·¯å¾„ç®—æ³• å•æºå°±æ˜¯ä»Žä¸€ä¸ªç‚¹åˆ°æ‰€æœ‰å…¶ä»–ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œå¾—åˆ°çš„ç»“æžœæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œè¡¨ç¤ºæŸä¸ªç‚¹åˆ°å…¶ä»–ç‚¹çš„æœ€çŸ­è·ç¦»ã€‚å¸¸ç”¨çš„ç®—æ³•æœ‰Dijkstraç®—æ³•å’ŒBellmanfordç®—æ³•ã€‚å¤šæºæœ€çŸ­è·¯å¾„è®¡ç®—æ‰€æœ‰ç‚¹åˆ°å…¶ä»–ç‚¹çš„æœ€çŸ­è·ç¦»ï¼Œå¾—åˆ°çš„æ˜¯ä¸€ä¸ªçŸ©é˜µã€‚å¸¸ç”¨çš„ç®—æ³•æœ‰Floydç®—æ³•ã€‚ 1234567891011121314åˆå§‹åŒ–ï¼š for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) if (i == j) d[i][j] = 0; else d[i][j] = INF;// ç®—æ³•ç»“æŸåŽï¼Œd[a][b]è¡¨ç¤ºaåˆ°bçš„æœ€çŸ­è·ç¦»void floyd()&#123; for (int k = 1; k &lt;= n; k ++ ) for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);&#125; 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;const int N =210, INF =0x3f3f3f3f; // è¿™ä¸ªåœ¨ç«žèµ›ä¸­æ˜¯éžå¸¸å¸¸è§çš„int d[N][N];int n, m , Q;void floyd()&#123; for(int k =1; k&lt;=n ; k++) for(int i =1; i&lt;=n ; i++) for(int j =1; j&lt;=n ; j++) d[i][j] =min(d[i][j], d[i][k] +d[k][j]); &#125;int main()&#123; cin &gt;&gt; n&gt;&gt;m&gt;&gt; Q; // åˆå§‹åŒ– for(int i =1; i&lt;= n; i++) &#123; for(int j =1; j&lt;=n ; j++) if(i ==j) d[i][j] =0; else d[i][j] =INF; &#125; while(m --) &#123; int a, b,c; cin &gt;&gt; a&gt;&gt;b&gt;&gt;c; d[a][b] =min(d[a][b], c); &#125; floyd(); while(Q --) &#123; int a, b; cin &gt;&gt; a&gt;&gt;b; if(d[a][b] &gt; INF/2) puts("impossible"); else cout &lt;&lt; d[a][b] &lt;&lt; endl; &#125; return 0;&#125; æœ´ç´ ç‰ˆprimç®—æ³• â€”â€” æ¨¡æ¿é¢˜ AcWing 858. Primç®—æ³•æ±‚æœ€å°ç”Ÿæˆæ ‘ æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n^2+m)$, $n$ è¡¨ç¤ºç‚¹æ•°ï¼Œ$m$ è¡¨ç¤ºè¾¹æ•° 1234567891011121314151617181920212223242526272829int n; // nè¡¨ç¤ºç‚¹æ•°int g[N][N]; // é‚»æŽ¥çŸ©é˜µï¼Œå­˜å‚¨æ‰€æœ‰è¾¹int dist[N]; // å­˜å‚¨å…¶ä»–ç‚¹åˆ°å½“å‰æœ€å°ç”Ÿæˆæ ‘çš„è·ç¦»bool st[N]; // å­˜å‚¨æ¯ä¸ªç‚¹æ˜¯å¦å·²ç»åœ¨ç”Ÿæˆæ ‘ä¸­// å¦‚æžœå›¾ä¸è¿žé€šï¼Œåˆ™è¿”å›žINF(å€¼æ˜¯0x3f3f3f3f), å¦åˆ™è¿”å›žæœ€å°ç”Ÿæˆæ ‘çš„æ ‘è¾¹æƒé‡ä¹‹å’Œint prim()&#123; memset(dist, 0x3f, sizeof dist); int res = 0; for (int i = 0; i &lt; n; i ++ ) &#123; int t = -1; for (int j = 1; j &lt;= n; j ++ ) if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; if (i &amp;&amp; dist[t] == INF) return INF; if (i) res += dist[t]; st[t] = true; for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]); &#125; return res;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;const int N =211;const int M =2e4+11;int arr[N][N];const int INF =0x3f3f3f3f;int n, m, q;void floyd()&#123; for(int k =1; k&lt;=n ; k++) &#123; for(int i =1; i&lt;=n ; i++) &#123; for(int j =1; j&lt;=n ; j++) if(arr[i][k] + arr[k][j] &lt; arr[i][j]) arr[i][j] = arr[i][k] + arr[k][j]; &#125; &#125;&#125;int main()&#123; cin &gt;&gt;n &gt;&gt;m &gt;&gt;q; // init for(int i= 1; i&lt;=n ; i++) for(int j =1; j&lt;=n ; j++) if(i ==j) arr[i][j] =0; else arr[i][j] =INF; while(m --) &#123; int a, b, c; cin &gt;&gt; a&gt;&gt; b&gt;&gt;c; arr[a][b] =min(arr[a][b], c); &#125; floyd(); while(q--) &#123; int a, b; cin &gt;&gt; a&gt;&gt;b; // è¿™ä¸ªåˆ¤æ–­æ¡ä»¶æ˜¯éžå¸¸å·§å¦™çš„ if(INF &gt; INF/2) , è¿™ä¸ªæ˜¯yes çš„æ“ä½œï¼Œ å› ä¸ºæœ¬èº«çš„ inf ++ -- æ˜¯ä¸ä¼šå½±å“æœ€åŽçš„ç»“æžœ if(arr[a][b] &gt; INF/2) puts("impossible"); else cout &lt;&lt; arr[a][b]&lt;&lt; endl; &#125; return 0;&#125; Kruskalç®—æ³• â€”â€” æ¨¡æ¿é¢˜ AcWing 859. Kruskalç®—æ³•æ±‚æœ€å°ç”Ÿæˆæ ‘ æ—¶é—´å¤æ‚åº¦æ˜¯ $O(mlogm)$, $n $è¡¨ç¤ºç‚¹æ•°ï¼Œ$m$è¡¨ç¤ºè¾¹æ•° 123456789101112131415161718192021222324252627282930313233343536373839404142int n, m; // næ˜¯ç‚¹æ•°ï¼Œmæ˜¯è¾¹æ•°int p[N]; // å¹¶æŸ¥é›†çš„çˆ¶èŠ‚ç‚¹æ•°ç»„struct Edge // å­˜å‚¨è¾¹&#123; int a, b, w; bool operator&lt; (const Edge &amp;W)const &#123; return w &lt; W.w; &#125;&#125;edges[M];int find(int x) // å¹¶æŸ¥é›†æ ¸å¿ƒæ“ä½œ&#123; if (p[x] != x) p[x] = find(p[x]); return p[x];&#125;int kruskal()&#123; sort(edges, edges + m); for (int i = 1; i &lt;= n; i ++ ) p[i] = i; // åˆå§‹åŒ–å¹¶æŸ¥é›† int res = 0, cnt = 0; for (int i = 0; i &lt; m; i ++ ) &#123; int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b) // å¦‚æžœä¸¤ä¸ªè¿žé€šå—ä¸è¿žé€šï¼Œåˆ™å°†è¿™ä¸¤ä¸ªè¿žé€šå—åˆå¹¶ &#123; p[a] = b; res += w; cnt ++ ; &#125; &#125; if (cnt &lt; n - 1) return INF; return res;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[åŸºäºŽsimhashçš„å¤§æ–‡æœ¬ç›¸ä¼¼åº¦æ¯”è¾ƒ]]></title>
    <url>%2F2018%2F08%2F23%2F%E5%9F%BA%E4%BA%8Esimhash%E7%9A%84%E6%96%87%E6%9C%AC%E7%9B%B8%E4%BC%BC%E5%BA%A6%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[æœ¬æ–‡ä¸»è¦è®°å½•ä½¿ç”¨simhashæ¯”è¾ƒä¸­æ–‡å¤§æ–‡æœ¬çš„ç›¸ä¼¼åº¦é—®é¢˜ã€‚å…ˆè¯´ä¸€ä¸‹æ–‡æœ¬ç‰¹å¾ï¼Œæ•°æ®å±žäºŽä¸­æ–‡æ–‡æœ¬ï¼Œæ¯ç¯‡æ–‡ç« çš„å­—æ•°å¤§äºŽ500,å°äºŽ2000,åŸºæœ¬ä¸Šå±žäºŽå¤§æ–‡æœ¬ã€‚æ­¥éª¤å¦‚ä¸‹ï¼š åŸºäºŽtf-idfæå–æ–‡æœ¬çš„å…³é”®è¯ã€‚å¦‚æžœè¿™äº›å…³é”®è¯åœ¨ä¹‹åŽçš„æ¯”è¾ƒä¸­æ˜¯ç›¸åŒçš„ï¼Œé‚£ä¹ˆè®¤ä¸ºå¯¹åº”çš„æ–‡ç« ä¹Ÿæ˜¯ç›¸åŒã€‚ç®€è€Œè¨€ä¹‹ï¼Œè¿™äº›æå–çš„å…³é”®è¯å¯ä»¥çœ‹åšåŽŸæ–‡ç« çš„â€ä»£è¡¨â€. æ ¹æ®å…³é”®å­—è®¡ç®—simhashç¼–ç ï¼Œç„¶åŽä½¿ç”¨hamming distanceè¿›è¡Œæ¯”è¾ƒä¸¤è€…çš„ä¸åŒã€‚å¦‚æžœå¯¹äºŽä¸Šè¿°æ¦‚å¿µæ¯”è¾ƒæ¨¡ç³Šï¼Œå»ºè®®é¦–å…ˆé˜…è¯»è¯¥ç¯‡åšå®¢ã€‚ å®žæˆ˜ é¡ºæ»‘è¿‡æ¸¡åˆ°ä»£ç å®žçŽ°ï¼š123456789101112131415# å¸¸è§„å¯¼åŒ…import sys,codecsimport pandas as pdimport numpy as npimport jieba.possegimport jieba.analysefrom sklearn import feature_extractionfrom sklearn.feature_extraction.text import TfidfTransformerfrom sklearn.feature_extraction.text import CountVectorizer# æ•°æ®é›†çš„è·¯å¾„path =&quot;../tianmao2.csv&quot;names =[&apos;where&apos;, &apos;time&apos;, &apos;title&apos;, &apos;url&apos;, &apos;contents&apos;]data =pd.read_csv(path, delimiter=&apos;\t&apos;, names= names, nrows=200)data[&apos;id&apos;] =data.index+1data.head() æˆ‘ä»¬ä½¿ç”¨titleå’Œcontents ç»„åˆä½œä¸ºåŽŸå§‹å¤„ç†çš„æ•°æ®ï¼Œæˆ‘ä»¬è®¤ä¸ºè¯¥æ•°æ®èƒ½å¤Ÿå°±æ˜¯æ–‡ç« çš„å†…å®¹ã€‚1stopkey = [w.strip() for w in codecs.open(&apos;../keyword_extraction/data/stopWord.txt&apos;, &apos;r&apos;).readlines()] è¯¥stop wordsæ˜¯ä¸­æ–‡åœç”¨è¯ï¼Œå°±æ˜¯å¸¸è§çš„â€çš„ äº†â€ã€‚å¸¸è§çš„æœ‰ç™¾åº¦åœç”¨è¯è¡¨ã€å“ˆå°”æ»¨å·¥ä¸šå¤§å­¦åœç”¨è¯è¡¨ä»¥åŠä¸­ç§‘é™¢çš„åœç”¨è¯è¡¨ã€‚è¿™é‡Œä½¿ç”¨çš„æ˜¯ä¸­ç§‘é™¢çš„åœç”¨è¯ã€‚å¯¹äºŽåœç”¨è¯çš„å­˜å‚¨ï¼Œå¯ä»¥ä½¿ç”¨set ï¼Œå› ä¸ºset è¦æ¯” listçš„æ£€ç´¢è¦å¿«ã€‚12345678def dataPrepos(text, stopkey): l = [] pos = [&apos;n&apos;, &apos;nz&apos;, &apos;v&apos;, &apos;vd&apos;, &apos;vn&apos;, &apos;l&apos;, &apos;a&apos;, &apos;d&apos;] # å®šä¹‰é€‰å–çš„è¯æ€§ seg = jieba.posseg.cut(text) # åˆ†è¯ for i in seg: if i.word not in stopkey and i.flag in pos: # åŽ»åœç”¨è¯ + è¯æ€§ç­›é€‰ l.append(i.word) return l æˆ‘ä»¬é€‰æ‹©åè¯ä½œä¸ºä¸»è¦çš„åˆ†æžå¯¹è±¡ã€‚12345678idList, titleList, abstractList = data[&apos;id&apos;], data[&apos;title&apos;], data[&apos;contents&apos;]corpus = [] # å°†æ‰€æœ‰æ–‡æ¡£è¾“å‡ºåˆ°ä¸€ä¸ªlistä¸­ï¼Œä¸€è¡Œå°±æ˜¯ä¸€ä¸ªæ–‡æ¡£# è¿™ä¸ª è™½ç„¶ä½¿ç”¨ &quot; &quot; è¿›è¡Œåˆ†å‰² ä½†æ˜¯å®žé™…ä¸Šè¿˜æ˜¯ä¸€ä¸ªæ‰“çš„listfor index in range(len(idList)): text = &apos;%sã€‚%s&apos; % (titleList[index], abstractList[index]) # æ‹¼æŽ¥æ ‡é¢˜å’Œæ‘˜è¦ text = dataPrepos(text, stopkey) # æ–‡æœ¬é¢„å¤„ç† text = &quot; &quot;.join(text) # è¿žæŽ¥æˆå­—ç¬¦ä¸²ï¼Œç©ºæ ¼åˆ†éš” corpus.append(text) è¿™é‡Œçš„corus æ˜¯å°†æ‰€æœ‰çš„ç»è¿‡é¢„å¤„ç†æ–‡æ¡£ä½œä¸ºå½“å‰è®¡ç®— idf çš„è¯­æ–™åº“ã€‚123456789vectorizer = CountVectorizer()X = vectorizer.fit_transform(corpus) # è¯é¢‘çŸ©é˜µ,a[i][j]:è¡¨ç¤ºjè¯åœ¨ç¬¬iä¸ªæ–‡æœ¬ä¸­çš„è¯é¢‘# 2ã€ç»Ÿè®¡æ¯ä¸ªè¯çš„tf-idfæƒå€¼transformer = TfidfTransformer()tfidf = transformer.fit_transform(X)# 3ã€èŽ·å–è¯è¢‹æ¨¡åž‹ä¸­çš„å…³é”®è¯word = vectorizer.get_feature_names()# 4ã€èŽ·å–tf-idfçŸ©é˜µï¼Œa[i][j]è¡¨ç¤ºjè¯åœ¨iç¯‡æ–‡æœ¬ä¸­çš„tf-idfæƒé‡weight = tfidf.toarray() ä½¿ç”¨sklearn å†…ç½®çš„å‡½æ•°è®¡ç®—tf-idfã€‚1234567891011121314151617181920212223242526272829topK = 10ids, titles, keys, weights = [], [], [], []for i in range(len(weight)): print(&quot;-------è¿™é‡Œè¾“å‡ºç¬¬&quot;, i + 1, &quot;ç¯‡æ–‡æœ¬çš„è¯è¯­tf-idf------&quot;) ids.append(idList[i]) titles.append(titleList[i]) df_word, df_weight = [], [] # å½“å‰æ–‡ç« çš„æ‰€æœ‰è¯æ±‡åˆ—è¡¨ã€è¯æ±‡å¯¹åº”æƒé‡åˆ—è¡¨ for j in range(len(word)): # print(word[j],weight[i][j]) df_word.append(word[j]) df_weight.append(weight[i][j]) df_word = pd.DataFrame(df_word, columns=[&apos;word&apos;]) df_weight = pd.DataFrame(df_weight, columns=[&apos;weight&apos;]) word_weight = pd.concat([df_word, df_weight], axis=1) # æ‹¼æŽ¥è¯æ±‡åˆ—è¡¨å’Œæƒé‡åˆ—è¡¨ word_weight = word_weight.sort_values(by=&quot;weight&quot;, ascending=False) # æŒ‰ç…§æƒé‡å€¼é™åºæŽ’åˆ— # åœ¨è¿™é‡Œå¯ä»¥æŸ¥çœ‹ kçš„é€‰å–çš„æ•°å€¼åº”è¯¥æ˜¯å¤šå¤§ï¼Œ # from ipdb import set_trace # set_trace() keyword = np.array(word_weight[&apos;word&apos;]) # é€‰æ‹©è¯æ±‡åˆ—å¹¶è½¬æˆæ•°ç»„æ ¼å¼ word_split = [keyword[x] for x in range(0, topK)] # æŠ½å–å‰topKä¸ªè¯æ±‡ä½œä¸ºå…³é”®è¯ word_split = &quot; &quot;.join(word_split) keys.append(word_split) wei = np.array(word_weight[&apos;weight&apos;]) wei_split = [str(wei[x]) for x in range(0, topK)] wei_split = &quot; &quot;.join(wei_split) weights.append(wei_split) # è¿™é‡Œçš„å‘½å å®¹æ˜“æ··æ·†result = pd.DataFrame(&#123;&quot;id&quot;: ids, &quot;title&quot;: titles, &quot;key&quot;: keys, &apos;weight&apos;: weights&#125;, columns=[&apos;id&apos;, &apos;title&apos;, &apos;key&apos;, &apos;weight&apos;]) é€‰æ‹©å‰10ä¸ªé¢‘çŽ‡æœ€é«˜çš„è¯è¯­ä½œä¸ºè¯¥ç¯‡æ–‡ç« çš„ä»£è¡¨ï¼Œå½“ç„¶è¿™ä¸ªå‚æ•°æ˜¯å¯ä»¥è°ƒæ•´ï¼Œéœ€è¦æ ¹æ®å…·ä½“çš„é—®é¢˜å’Œç»“æžœè¿›è¡Œè°ƒæ•´ã€‚1result.head() æœ€åŽçš„æ•ˆæžœå¦‚ä¸Šã€‚è‡³æ­¤æˆ‘ä»¬ç¬¬ä¸€æ­¥çš„æå–æ–‡ç« çš„å…³é”®è¯å°±å·²ç»åšå®Œã€‚ä¸‹é¢è¿›è¡Œç›¸ä¼¼åº¦çš„æ¯”è¾ƒã€‚ 1234import jiebaimport jieba.analyseimport pandas as pd#æ—¥å¸¸å¯¼åŒ… æ•°æ®å’Œä¸Šè¿°çš„ä¸€æ ·ï¼Œæ‰€ä»¥å°±ä¸æˆªå›¾äº†ã€‚123datasets =pd.read_csv(&quot;../tianmao2-tf-idf.csv&quot;)tokens =datasets[&apos;key&apos;]weights =datasets[&apos;weight&apos;] æå–å…³é”®è¯å’Œå¯¹åº”çš„æƒé‡ã€‚123456789101112print(tokens[0], len(tokens[0]))print(weights[0], len(weights[0]))tokens0 =tokens[0].split()weights0 =weights[0].split()len(tokens0)len(weights0)tokens1 =tokens[1].split()weights1 =weights[1].split()import astweights0 =[ ast.literal_eval(i) for i in weights0]weights1 =[ ast.literal_eval(i) for i in weights1] æž„é€ æµ‹è¯•ç”¨ä¾‹ã€‚å› ä¸ºæƒé‡æ˜¯å­—ç¬¦ä¸²ï¼Œæ‰€ä»¥ç®€å•å¤„ç†è½¬æˆæ•´æ•°ã€‚ 12dict0 =dict(zip(tokens0, weights0))dict1 =dict(zip(tokens1, weights1)) å®šä¹‰ä¸€ä¸ªSimhashï¼Œæä¾›å¯¹æ–‡æ¡£çš„æ•°å€¼æ˜ å°„å’Œæ–‡æ¡£é—´ç›¸ä¼¼åº¦è®¡ç®—çš„åŠŸèƒ½.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class Simhash(object): # åˆå§‹åŒ–å‡½æ•° def __init__(self, weights_dict, tokens=&apos;&apos;, hashbits=64): self.hashbits = hashbits self.hash = self.simhash_function(tokens, weights_dict) # toStringå‡½æ•° # ä¸æ‡‚è¿™ä¸ª self.hash ï¼Œå‡¡æ˜¯å¸¦æœ‰self çš„å‡½æ•°éƒ½æ˜¯å¯ä»¥ç±»å˜é‡ï¼Œæ‰€ä»¥è¿™ä¸ªå°±æ˜¯è¿”å›žçš„ self.hashè¿™ä¸ªå˜é‡ #å‡¡æ˜¯ä½¿ç”¨__str__ è¿™ç§ç±»åž‹çš„å‡½æ•° éƒ½æ˜¯é‡å†™ åŽŸæ¥çš„å‡½æ•° def __str__(self): return str(self.hash) &quot;&quot;&quot; ord() å‡½æ•°æ˜¯ chr() å‡½æ•°ï¼ˆå¯¹äºŽ8ä½çš„ASCIIå­—ç¬¦ä¸²ï¼‰æˆ– unichr() å‡½æ•°ï¼ˆå¯¹äºŽUnicodeå¯¹è±¡ï¼‰çš„é…å¯¹å‡½æ•°ï¼Œå®ƒä»¥ä¸€ä¸ªå­—ç¬¦ï¼ˆé•¿åº¦ä¸º1çš„å­—ç¬¦ä¸²ï¼‰ä½œä¸ºå‚æ•°ï¼Œè¿”å›žå¯¹åº”çš„ ASCII æ•°å€¼ï¼Œæˆ–è€… Unicode æ•°å€¼ &quot;&quot;&quot; # ç»™æ¯ä¸€ä¸ªå•è¯ç”Ÿæˆå¯¹åº”çš„hashå€¼ # è¿™ä¸ªæ“ä½œæžæ‡‚ä¹‹åŽä¸€å®šå¾ˆç®€æ´ï¼Œ ä½†æ˜¯çŽ°åœ¨å¾ˆéš¾ç†è§£ï¼Œå› ä¸ºä¸æ˜¯å­—ç¬¦ä¸²ï¼Œè€Œæ˜¯ä½æ“ä½œ def _string_hash(self, source): if source == &apos;&apos;: return 0 else: x = ord(source[0]) &lt;&lt; 7 # &lt;&lt; è¡¨ç¤º ä¹˜ä»¥2^7 ; &gt;&gt; è¡¨ç¤ºé™¤ä»¥ ; ** è¡¨ç¤ºæ¬¡æ–¹çš„æ„æ€ # ^ : æŒ‰ä½å¼‚æˆ– (äºŒè¿›åˆ¶è¿›è¡Œå¼‚æˆ–)ï¼› &amp; æŒ‰ä½è¿›è¡Œä¸Ž æ“ä½œ # å·¦ç§»ä½æ“ä½œä¹Ÿæ˜¯å¯ä»¥ç†è§£ä¸º 2^x çš„æ“ä½œï¼Œå› ä¸ºå­˜å‚¨æ˜¯äºŒè¿›åˆ¶ï¼Œè¿™æ ·å·¦ç§»ä¸€ä½ è¡¨ç¤ºÃ—2 ä¸€æ¬¡ m = 1000003 mask = 2 ** self.hashbits - 1 for c in source: x = ((x * m) ^ ord(c)) &amp; mask x ^= len(source) if x == -1: x = -2 return x # ç”Ÿæˆsimhashå€¼ def simhash_function(self, tokens, weights_dict): v = [0] * self.hashbits # è¿™ç§ä½¿ç”¨ &#123;&#125; dictionary ç„¶åŽå¼ºè¡Œå¾—åˆ°item å†è¿›è¡ŒéåŽ†ä¹Ÿæ˜¯ç‰›é€¼ for key, t in &#123;x: self._string_hash(x) for x in tokens&#125;.items(): for i in range(self.hashbits): bitmask = 1 &lt;&lt; i if t &amp; bitmask: v[i] += weights_dict[key] else: v[i] -= weights_dict[key] fingerprint = 0 for i in range(self.hashbits): if v[i] &gt;= 0: fingerprint += 1 &lt;&lt; i return fingerprint # æ±‚æ–‡æ¡£é—´çš„æµ·æ˜Žè·ç¦» def hamming_distance(self, other): x = (self.hash ^ other.hash) &amp; ((1 &lt;&lt; self.hashbits) - 1 ) tot = 0 while x : tot += 1 x &amp;= x - 1 return tot #æ±‚ç›¸ä¼¼åº¦ # è¿™ä¸ªç›¸ä¼¼åº¦çš„è®¡ç®—ï¼Œååˆ†ç®€å•ï¼Œå¦‚æžœä¸¤ä¸ªæ•°æŽ¥è¿‘ï¼Œé‚£ä¹ˆå°±æ˜¯è®¤ä¸ºç›¸ä¼¼ã€‚è¶Šæ˜¯æŽ¥è¿‘1 è¶Šæ˜¯ç›¸ä¼¼ï¼Œ # ä¸æ˜¯åŽŸå…ˆé‚£ç§ä»¥æŸä¸€ä¸ªå‚æ•°æ•´æ•° å¦‚3 ä¸ºè·ç¦»çš„ç›¸ä¼¼åº¦ def similarity(self, other): a = float(self.hash) b = float(other.hash) if a &gt; b: return b / a else: return a / b if __name__ == &apos;__main__&apos;: hash0 = Simhash(weights_dict=dict0, tokens=tokens0) print(hash0) hash1 = Simhash(weights_dict=dict1, tokens=tokens1) print(hash1) print(hash0.hamming_distance(hash1)) print(hash0.similarity(hash1)) ç»“æžœå¦‚ä¸Šã€‚å¯ä»¥çœ‹å‡ºè¯¥ä¾‹å­ä¸­ä½¿ç”¨çš„ä¸¤ä¸¤æ¯”è¾ƒçš„æ–¹å¼ï¼Œå¯¹äºŽå¤§æ•°æ®æ¥è¯´ï¼Œä¸€èˆ¬å¯èƒ½ä¼šç”¨åˆ°å€’æŽ’ç´¢å¼•å’Œcpuå¹¶è¡ŒæŠ€æœ¯ã€‚]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[æ–‡æœ¬ç›¸ä¼¼åº¦æ¯”è¾ƒåŸºæœ¬çŸ¥è¯†(1)]]></title>
    <url>%2F2018%2F08%2F23%2F%E6%96%87%E6%9C%AC%E7%9B%B8%E4%BC%BC%E5%BA%A6%E6%AF%94%E8%BE%83%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[äº’è”ç½‘ç½‘é¡µå­˜åœ¨å¤§é‡çš„é‡å¤å†…å®¹ç½‘é¡µï¼Œæ— è®ºå¯¹äºŽæœç´¢å¼•æ“Žçš„ç½‘é¡µåŽ»é‡å’Œè¿‡æ»¤ã€æ–°é—»å°è¯´ç­‰å†…å®¹ç½‘ç«™çš„å†…å®¹åç›—ç‰ˆå’Œè¿½è¸ªï¼Œè¿˜æ˜¯ç¤¾äº¤åª’ä½“ç­‰æ–‡æœ¬åŽ»é‡å’Œèšç±»ï¼Œéƒ½éœ€è¦å¯¹ç½‘é¡µæˆ–è€…æ–‡æœ¬è¿›è¡ŒåŽ»é‡å’Œè¿‡æ»¤ã€‚æœ¬æ–‡ä»‹ç»çš„ Locality Sensitive Hashing æ˜¯å¸¸è§çš„ä¸€ç±»hash å‡½æ•°ç”¨äºŽåŽ»é‡ã€‚ SimHashæ˜¯ä¸€ç§å±€éƒ¨æ•æ„Ÿhashï¼Œå®ƒä¹Ÿæ˜¯Googleå…¬å¸è¿›è¡Œæµ·é‡ç½‘é¡µåŽ»é‡ä½¿ç”¨çš„ä¸»è¦ç®—æ³•ã€‚ Locality Sensitive HashingHash å‡½æ•°èƒ½å¤Ÿä¿è¯æœ€åŽçš„æ˜ å°„ç©ºé—´å”¯ä¸€æ€§å’Œå‡åŒ€åˆ†å¸ƒï¼Œä½†æ˜¯ä¸èƒ½ä¿è¯åŽŸæ¥ç›¸ä¼¼å‘é‡ï¼Œæ˜ å°„ä¹‹åŽä¹Ÿæ˜¯ç›¸ä¼¼çš„ã€‚ä½†æ˜¯å±€éƒ¨æ•æ„Ÿhashï¼ˆæ¯”å¦‚ simhash or minhash ï¼‰æ˜¯èƒ½å¤Ÿä¿è¯è¿™ä¸€ç‚¹çš„ã€‚ä¹Ÿå¯ä»¥ä»Žé™ç»´çš„è§’åº¦è¿›è¡Œç†è§£ï¼Œé™ç»´ä¹‹å‰å’Œé™ç»´ä¹‹åŽï¼Œç›¸ä¼¼çš„æ–‡æ¡£ï¼ˆè¿™é‡Œå°±å…·ä½“åŒ–ä¸€ä¸ªä¸œè¥¿ï¼‰hash ä¹‹åŽä¹Ÿæ˜¯ç›¸ä¼¼çš„ã€‚ å±€éƒ¨æ•æ„Ÿå“ˆå¸Œçš„åŸºæœ¬æ€æƒ³ï¼šåœ¨é«˜ç»´æ•°æ®ç©ºé—´ä¸­çš„ä¸¤ä¸ªç›¸é‚»çš„æ•°æ®è¢«æ˜ å°„åˆ°ä½Žç»´æ•°æ®ç©ºé—´ä¸­åŽï¼Œå°†ä¼šæœ‰å¾ˆå¤§çš„æ¦‚çŽ‡ä»»ç„¶ç›¸é‚»ï¼›è€ŒåŽŸæœ¬ä¸ç›¸é‚»çš„ä¸¤ä¸ªæ•°æ®ï¼Œåœ¨ä½Žç»´ç©ºé—´ä¸­ä¹Ÿå°†æœ‰å¾ˆå¤§çš„æ¦‚çŽ‡ä¸ç›¸é‚»ã€‚é€šè¿‡è¿™æ ·ä¸€æ˜ å°„ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ä½Žç»´æ•°æ®ç©ºé—´æ¥å¯»æ‰¾ç›¸é‚»çš„æ•°æ®ç‚¹ï¼Œé¿å…åœ¨é«˜ç»´æ•°æ®ç©ºé—´ä¸­å¯»æ‰¾ï¼Œå› ä¸ºåœ¨é«˜ç»´ç©ºé—´ä¸­ä¼šå¾ˆè€—æ—¶ã€‚æœ‰è¿™æ ·æ€§è´¨çš„å“ˆå¸Œæ˜ å°„ç§°ä¸ºæ˜¯å±€éƒ¨æ•æ„Ÿçš„ã€‚simhash æˆ–è€…minhashæ˜¯å±€éƒ¨æ•æ„Ÿhashçš„ä¸€ç§å…·ä½“å®žçŽ°ã€‚å±€éƒ¨æ•æ„Ÿå“ˆå¸Œæ˜¯ä¸€ç§æ€æƒ³ã€‚ åº”ç”¨ï¼šå¯¹äºŽé«˜ç»´æ•°æ®çš„æµ·é‡æ•°æ®è¿‘é‚»æŸ¥æ‰¾ï¼Œå±€éƒ¨æ•æ„Ÿå“ˆå¸Œæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„è§£å†³æ–¹æ³•ã€‚åœ¨å¾ˆå¤šé—®é¢˜ä¸­ï¼Œä»Žæµ·é‡æ•°æ®åº“ä¸­å¯»æ‰¾åˆ°ä¸ŽæŸ¥è¯¢æ•°æ®ç›¸ä¼¼çš„æ•°æ®æ˜¯ä¸€ä¸ªå¾ˆå…³é”®çš„é—®é¢˜ã€‚å¯ä»¥å…·ä½“åº”ç”¨åˆ°æ–‡æœ¬ç›¸ä¼¼åº¦æ£€æµ‹ã€ç½‘é¡µæœç´¢ç­‰é¢†åŸŸã€‚ Simhashæˆ‘ä»¬çŽ°åœ¨å¤„ç†çš„æ˜¯å¤§æ•°æ®ç»´åº¦ä¸Šçš„æ–‡æœ¬åŽ»é‡ï¼Œè¿™å°±å¯¹ç®—æ³•çš„æ•ˆçŽ‡æœ‰ç€å¾ˆé«˜çš„è¦æ±‚ã€‚ä½†æ˜¯åœ¨å°çš„æ ·æœ¬ä¸Šè¿™ä¸ªæ˜¯ä¸ä¸€å®šæœ‰ä¿è¯æœ‰æ•ˆçš„ï¼Œå°æ–‡æœ¬ä½¿ç”¨ NLP ç›¸å…³çŸ¥è¯†å¯èƒ½å¾—åˆ°æ›´å¥½çš„ç²¾åº¦ã€‚SimHashç®—æ³•æ˜¯Googleå…¬å¸è¿›è¡Œæµ·é‡ç½‘é¡µåŽ»é‡çš„é«˜æ•ˆç®—æ³•ï¼Œå®ƒé€šè¿‡å°†åŽŸå§‹çš„æ–‡æœ¬æ˜ å°„ä¸º64ä½çš„äºŒè¿›åˆ¶æ•°å­—ä¸²ï¼Œç„¶åŽé€šè¿‡æ¯”è¾ƒäºŒè¿›åˆ¶æ•°å­—ä¸²çš„å·®å¼‚è¿›è€Œæ¥è¡¨ç¤ºåŽŸå§‹æ–‡æœ¬å†…å®¹çš„å·®å¼‚ã€‚æœ¬æ–‡æœåŠ¡äºŽè¯¥ç¯‡åšå®¢,ä¸»è¦è¿›è¡Œåè¯è§£é‡Šã€‚ åŸºæœ¬æ¦‚å¿µsimhash ä¹Ÿæ˜¯ä¸€ç§hashï¼Œä¸€èˆ¬çš„hash å‡½æ•°æ˜ å°„è§„åˆ™åªéœ€è¦æ»¡è¶³ä»¥ä¸‹ä¸¤ä¸ªæ¡ä»¶ï¼š å¯¹å¾ˆå¤šä¸åŒçš„ç‰¹å¾æ¥è¯´ï¼Œå®ƒä»¬å¯¹æ‰€å¯¹åº”çš„å‘é‡æ˜¯å‡åŒ€éšæœºåˆ†å¸ƒçš„ ç›¸åŒçš„ç‰¹å¾æ¥è¯´å¯¹åº”çš„å‘é‡æ˜¯å”¯ä¸€ simhash å’Œä¼ ç»Ÿçš„ hash ä¸åŒç‚¹åœ¨äºŽå‰è€…çš„01 ä¸²æ˜¯å¯ä»¥è¡¨å¾æ–‡æœ¬ä¹‹é—´çš„ç›¸ä¼¼åº¦ï¼Œè€ŒåŽè€…æ˜¯ä¸å¯ä»¥çš„ã€‚ ç®€å•æ¥è¯´æ™®é€šçš„hashæ˜ å°„éœ€è¦æ»¡è¶³éšæœºåˆ†å¸ƒå’Œå”¯ä¸€æ€§ä¸¤ä¸ªæ¡ä»¶ã€‚simhashæƒ³è¦å®žçŽ°çš„æ˜¯ï¼Œå¦‚æžœåŽŸæ¥çš„æ–‡æœ¬çš„ç‰¹å¾æ˜¯ç›¸ä¼¼ï¼Œé‚£ä¹ˆæ˜ å°„ä¹‹åŽçš„ç¼–ç ä¹Ÿæ˜¯ç›¸ä¼¼ã€‚è¿™é‡Œä½¿ç”¨ hamming distance è¿›è¡Œæ¯”è¾ƒsimhashæ˜ å°„ä¹‹åŽçš„è·ç¦»ã€‚æ ¹æ®ç»éªŒå€¼ï¼Œå¯¹64ä½çš„ SimHashå€¼ï¼Œæµ·æ˜Žè·ç¦»åœ¨3ä»¥å†…çš„å¯è®¤ä¸ºç›¸ä¼¼åº¦æ¯”è¾ƒé«˜ã€‚ç¼–ç ä¹‹åŽçš„è¡¨ç¤ºåœ¨è‹±æ–‡ä¸­æ˜¯ fingerprint(æŒ‡çº¹)ã€‚ simhashæœ€åˆè¢«google ç”¨äºŽç½‘é¡µåŽ»é‡ï¼Œå½“æ—¶ä½¿ç”¨çš„fingerprint æ˜¯64,æ‰€ä»¥è¿™é‡Œæ²¿ç”¨äº†è¿™ä¸ªä¼ ç»Ÿã€‚64ä½çš„ç­¾åå¯ä»¥è¡¨ç¤ºå¤šè¾¾$2^64$ä¸ªè±¡é™ï¼Œå› æ­¤åªä¿å­˜æ‰€åœ¨è±¡é™çš„ä¿¡æ¯ä¹Ÿè¶³å¤Ÿè¡¨å¾ä¸€ä¸ªæ–‡æ¡£äº†ã€‚æ›´è¿›ä¸€æ­¥ï¼Œè¡¨ç¤ºçš„æ–‡æ¡£çš„æ•°å­—æœ€å¤šæ˜¯å¤šå°‘ï¼Ÿè¿™ä¸ªåº”è¯¥å¯ä»¥å‡†ç¡®è®¡ç®—ç‰¹å¾çš„ä¸ªæ•°åº”ä¸ºå¦‚æžœç”¨ä¸‰ä½(01) è¡¨ç¤ºï¼Œé‚£ä¹ˆæœ‰8ç§ï¼Œé‚£ä¹ˆ2^64 è¿™ä¹ˆå¤šç§ç‰¹å¾ï¼Œæ‰€ä»¥16*10^18 è¿™ä¹ˆå¤šã€‚ ç®—æ³•æ­¥éª¤Simhash åˆ†ä¸º5ä¸ªæ­¥éª¤ï¼šåˆ†è¯ã€hashï¼ˆmd5 è¦æ±‚å‡åŒ€æ˜ å°„åˆ°æŸç©ºé—´å°±è¡Œï¼Œä¸è¦æ±‚ååº”åŽŸå§‹æ ·æœ¬çš„ç›¸å…³æ€§ï¼‰ã€åŠ æƒã€åˆå¹¶ï¼ˆåˆ—é¡¹ç›¸åŠ ï¼‰ã€é™ç»´ï¼ˆæ­£æ•°ä¸º1 è´Ÿæ•°ä¸º0ï¼‰ï¼Œå¾—åˆ°æ¯ç¯‡æ–‡ç« çš„simhash ä¹‹åŽï¼Œè®¡ç®—ä¸¤ä¸ªæ–‡ç« çš„æµ·æ˜Žè·ç¦»ï¼ˆä¸¤ä¸ªå­—ç¬¦ä¸²å¯¹åº”ä½ç½®çš„ä¸åŒå­—ç¬¦çš„ä¸ªæ•°ï¼‰ã€‚å¯¹äºŽ64 ä½çš„simhash å€¼ï¼Œåœ¨3ä»¥å†…å°±å¯ä»¥è®¤ä¸ºæ˜¯æ¯”è¾ƒç›¸ä¼¼çš„ã€‚ ç¬¬ä¸€æ­¥ï¼šæ–‡æœ¬é¢„å¤„ç†å¾—åˆ°åˆ†è¯ï¼ˆåŽ»é‡ï¼ŒåŽ»é™¤çš„äº†stop wordsï¼‰,ç„¶åŽweightæƒé‡å¯ä»¥ä½¿ç”¨åˆ†è¯çš„frequency æˆ–è€…tfidf è¿›è¡Œå¾—åˆ°ç¬¬äºŒæ­¥ï¼šè¿›è¡Œhash æ˜ å°„ï¼ˆå¯ä»¥ä½¿ç”¨md5è¿™ç§ä¼ ç»Ÿçš„æ˜ å°„æ–¹å¼ï¼ŒåŸºæœ¬çš„è¦æ±‚å°±æ˜¯å‡åŒ€æ˜ å°„åˆ°ä¸€ä¸ªç©ºé—´ï¼Œè¿™ç§æ˜ å°„å¹¶ä¸èƒ½åæ˜ åŽŸå§‹æ ·æœ¬çš„ç›¸å…³æ€§ï¼‰ç¬¬ä¸‰æ­¥ï¼šhash æ˜ å°„å€¼å’Œweight è¿›è¡Œç›¸ä¹˜ï¼Œå¦‚æžœåŽŸæ¥æ˜¯1 åˆ™ä¹˜ä»¥1ï¼Œå¦‚æžœæ˜¯0 åˆ™ä¹˜ä»¥-1ï¼Œç¬¬å››æ­¥ï¼š åˆ—å‘ç›¸åŠ ï¼Œå¾—åˆ°summing weights,è¿›è¡Œé™ç»´å¦‚æžœæ˜¯æ­£æ•°é‚£ä¹ˆä¸º1ï¼Œå¦‚æžœæ˜¯è´Ÿæ•°é‚£ä¹ˆä¸º-1ç¬¬äº”æ­¥ï¼š è®¡ç®—ä¸åŒæ–‡æœ¬ä¹‹é—´çš„ hamming distanceã€‚ ç„¶åŽè¿™ä¸ªsimhashå°±å‡ºæ¥äº†.æœ‰å›¾æœ‰çœŸç›¸ simhashçš„å±€é™æ€§ï¼šåªè€ƒè™‘åˆ°æ–‡ç« å­˜åœ¨å“ªäº›è¯ï¼Œæ²¡æœ‰è€ƒè™‘åˆ°è¯çš„é¡ºåºã€‚ä¸è¿‡ç›¸åº”çš„ä¼˜ç‚¹æ˜¯ï¼Œå¯ä»¥å®žçŽ°æµ·é‡æ–‡ç« ç›¸ä¼¼åº¦è®¡ç®—ã€‚æ–‡ç« ç›¸ä¼¼åº¦è®¡ç®—å¿½ç•¥è¯çš„é¡ºåºä¹‹åŽæ•ˆæžœæ›´å¥½ã€‚æ‰€ä»¥åœ¨å¤„ç†å¤§æ–‡æœ¬æ—¶å€™ï¼Œsimhashæ˜¯æœ‰æ•ˆçš„ï¼Œä½†æ˜¯åœ¨å¤„ç†å°æ–‡æœ¬ï¼Œè¿™ç§æ•ˆæžœå¾€å¾€ä¸èƒ½è¢«ä¿è¯ã€‚ç›´è§‚ä¸Šç†è§£ï¼Œåœ¨ä¸€ç‰‡æ®µæ–‡ç« æˆ–è€…æ®µè½ä¸­ï¼Œè¯è¯­å‡ºçŽ°çš„é¡ºåºè¿˜æ˜¯æ¯”è¾ƒé‡è¦çš„ã€‚æ›´åŠ å‡†ç¡®çš„è¯´ï¼Œè¿™ä¸ªæ˜¯ç”¨æ¥è¿›è¡Œåˆ¤é‡çš„ç®—æ³•ï¼Œè€Œä¸æ˜¯è®¡ç®—ç›¸ä¼¼åº¦çš„ç®—æ³•ã€‚ å¼€æºå®žçŽ°ï¼šsimhash çš„å®žçŽ°ï¼Œè°ƒç”¨ä¸€ä¸ªåº“ https://www.twblogs.net/a/5c178f2cbd9eee5e40bbc9e9/zh-cn simhash çš„ä¸€ä¸ªgithub https://github.com/yanyiwu/simhash ç™¾åº¦åŽ»é‡ï¼š top k æœ€é•¿çš„è¯­å¥ï¼Œä½œä¸ºæºæ•°æ® minhashæ€»çš„æ“ä½œæ­¥éª¤å¦‚ä¸‹ï¼š å¯¹ä¸€ä¸ªæ–‡æ¡£è½¬åŒ–ä¸ºå…³é”®è¯çš„é›†åˆï¼Œç”¨è¿™ä¸ªé›†åˆæ¥è¡¨ç¤ºè¿™ä¸ªæ–‡æ¡£ï¼Œå«Shinglingã€‚ ç”¨MinHashingå‡½æ•°æ¥æž„é€ å“ˆå¸Œè¡¨ã€‚ ä½¿ç”¨LSHæ¥å¯»æ‰¾ç›¸ä¼¼çš„æ–‡æ¡£ã€‚ å¯¹äºŽç¬¬ä¸€ç‚¹ä¸­çš„Shinglingï¼Œè¿™ä¸ªk æ˜¯ä¸€ä¸ªå…³é”®å‚æ•°ï¼Œå¯ä»¥ä½“çŽ°ä¸Šä¸‹æ–‡çš„é‚£ç§ã€‚ä¾‹å¦‚ï¼šk=2ï¼Œdoc=adcabï¼Œè¿™ä¸ªé›†åˆçš„2-shingles={ab,ba,ca} ã€‚æˆ‘ä»¬å¯¹è¿™ä¸ªå­—ç¬¦ä¸²è¿›è¡Œåˆ’åˆ†ï¼Œå¾—åˆ°çš„æ˜¯ad dc ca abï¼Œç”±äºŽé›†åˆæ˜¯å”¯ä¸€æ€§çš„æ‰€ä»¥ä¸å¯èƒ½æœ‰é‡å¤çš„å…ƒç´ ã€‚k=2 å…¶å®žæ˜¯ä¸€ä¸ªæ¯”è¾ƒç³Ÿç³•çš„é€‰æ‹©ï¼Œæˆ‘ä»¬ä¸€èˆ¬é€‰æ‹©Kåœ¨å®žé™…æƒ…å†µä¸­ä¸€èˆ¬ä¼šé€‰æ‹©9æˆ–è€…10ï¼Œæˆ‘ä»¬è¦æ±‚è¿™ä¸ªkä¸€èˆ¬è¦å¤§äºŽæˆ‘ä»¬æ–‡ç« ä¸­å‡ºçŽ°çš„å•è¯çš„é•¿åº¦ã€‚è¿™æ ·çš„é€‰æ‹©ä¼šæ¯”è¾ƒåˆç†ä¸€äº›ã€‚ ä½¿ç”¨ä¸€ä¸ªå…·ä½“çš„ä¾‹å­è®²è§£ minhash çš„æ“ä½œæ­¥éª¤ï¼š ç¬¬ä¸€æ­¥ï¼š æ–‡æ¡£çš„Shinglingï¼šå¯¹äºŽä¸­æ–‡é¦–å…ˆè¿›è¡Œåˆ†è¯ï¼Œå¾—åˆ°æ¯ç¯‡æ–‡ç« çš„è¯è¯­çš„é›†åˆï¼ˆé›†åˆæ˜¯åŽ»é‡ä¹‹åŽçš„ç»“æžœï¼‰ï¼Œè¿™é‡Œæ˜¯å¯ä»¥åšn-gram çš„æ€æƒ³çš„ï¼Œè¿™ä¸ªn çš„å–å€¼è¶Šå¤§ï¼Œè¶Šèƒ½æ‰¾åˆ°çœŸæ­£ç›¸ä¼¼çš„æ–‡æ¡£ï¼Œä»£ä»·æ˜¯dictionary å¾ˆå¤§ï¼Œå­˜å‚¨ä¸Šçš„ 1234&gt; s1 = &quot;æˆ‘ å‡è‚¥&quot;&gt; s2= &quot;è¦&quot;&gt; s3 = &quot;ä»– å‡è‚¥ æˆåŠŸ&quot;&gt; s4 = &quot;æˆ‘ è¦ å‡è‚¥&quot; ç¬¬äºŒæ­¥ï¼š æ–‡æ¡£çš„çŸ©é˜µè¡¨ç¤ºï¼ˆå¦‚æžœkeyword åœ¨ç›¸åº”çš„æ–‡ç« ä¸­å‡ºçŽ°ï¼Œæ ‡è®°ä¸º1 å¦åˆ™æ ‡è®°ä¸º0ï¼‰ å…ƒç´  S1 S2 S3 S4 æˆ‘ 1 0 0 1 ä»– 0 0 1 0 è¦ 0 1 0 1 å‡è‚¥ 1 0 1 1 æˆåŠŸ 0 0 1 0 çœŸæ­£å®žè·µä¸­çš„çŸ©é˜µåº”è¯¥æ˜¯ååˆ†ç¨€ç–çš„ã€‚ ç¬¬ä¸‰æ­¥ï¼š æœ€å°hashå®šä¹‰ä¸ºï¼šç‰¹å¾çŸ©é˜µæŒ‰è¡Œè¿›è¡Œä¸€ä¸ªéšæœºçš„æŽ’åˆ—åŽï¼Œç¬¬ä¸€ä¸ªåˆ—å€¼ä¸º1çš„è¡Œçš„è¡Œå·ã€‚ä¸¾ä¾‹è¯´æ˜Žå¦‚ä¸‹ï¼Œå‡è®¾ä¹‹å‰çš„ç‰¹å¾çŸ©é˜µæŒ‰è¡Œè¿›è¡Œçš„ä¸€ä¸ªéšæœºæŽ’åˆ—å¦‚ä¸‹ï¼š å…ƒç´  S1 S2 S3 S4 æˆ‘ 1 0 0 1 å‡è‚¥ 1 0 1 1 æˆåŠŸ 0 0 1 0 ä»– 0 0 1 0 è¦ 0 1 0 1 æœ€å°å“ˆå¸Œå€¼ï¼šh(S1)=1ï¼Œh(S2)=5ï¼Œh(S3)=2ï¼Œh(S4)=1. ä»Žå›¾ä¸­å¯ä»¥çŸ¥é“ï¼Œåº”è¯¥ä»Ž input matrixï¼ˆåŽŸå§‹çš„matrix ï¼‰å¾—åˆ°æ–°çš„ signature matrixã€‚ ç­¾åçš„ç›¸ä¼¼æ€§ 1/3 ï¼Œä»¥æ­¤ç±»æŽ¨æˆ‘ä»¬å¯ä»¥å¾—åˆ°æˆ‘ä»¬æ‰€æ±‚çš„å›¾ä¸­è¦æ±‚çš„ç›¸ä¼¼æ€§ï¼Œæˆ‘ä»¬çœ‹å›¾ä¸­ç¬¬2åˆ—å’Œç¬¬3åˆ— Jaccard similarity å°±æ˜¯ 1/5ï¼Œæˆ‘ä»¬ç­¾åçš„ç›¸ä¼¼æ€§å°±æ˜¯1/3 ã€‚ ä½¿ç”¨ signature matrix åŽ»è¿‘ä¼¼çš„è¡¨ç¤º Jaccard similarity è¿™ä¸ªæ˜¯ç¬¬ä¸€äºŒåˆ—çš„ input matrix 0 10 01 00 10 01 10 0 è¿™ä¸ªæ˜¯signature matrix 3 12 21 5 ä¸ºä»€ä¹ˆä½¿ç”¨ä¸Šè¿°æ–¹æ³•æ˜¯æœ‰æ•ˆï¼Ÿ äº‹å®žä¸Šï¼Œä¸¤åˆ—çš„æœ€å°hashå€¼å°±æ˜¯è¿™ä¸¤åˆ—çš„Jaccardç›¸ä¼¼åº¦çš„ä¸€ä¸ªä¼°è®¡ï¼Œæ¢å¥è¯è¯´ï¼Œä¸¤åˆ—æœ€å°hashå€¼åŒç­‰çš„æ¦‚çŽ‡ä¸Žå…¶ç›¸ä¼¼åº¦ç›¸ç­‰ï¼Œå³P(h(Si)=h(Sj)) = sim(Si,Sj)ã€‚ä¸ºä»€ä¹ˆä¼šç›¸ç­‰ï¼Ÿæˆ‘ä»¬è€ƒè™‘Siå’ŒSjè¿™ä¸¤åˆ—ï¼Œå®ƒä»¬æ‰€åœ¨çš„è¡Œçš„æ‰€æœ‰å¯èƒ½ç»“æžœå¯ä»¥åˆ†æˆå¦‚ä¸‹ä¸‰ç±»ï¼š ï¼ˆ1ï¼‰Aç±»ï¼šä¸¤åˆ—çš„å€¼éƒ½ä¸º1ï¼› ï¼ˆ2ï¼‰Bç±»ï¼šå…¶ä¸­ä¸€åˆ—çš„å€¼ä¸º0ï¼Œå¦ä¸€åˆ—çš„å€¼ä¸º1ï¼› ï¼ˆ3ï¼‰Cç±»ï¼šä¸¤åˆ—çš„å€¼éƒ½ä¸º0. ç‰¹å¾çŸ©é˜µç›¸å½“ç¨€ç–ï¼Œå¯¼è‡´å¤§éƒ¨åˆ†çš„è¡Œéƒ½å±žäºŽCç±»ï¼Œä½†åªæœ‰Aã€Bç±»è¡Œçš„å†³å®šsim(Si,Sj)ï¼Œå‡å®šAç±»è¡Œæœ‰aä¸ªï¼ŒBç±»è¡Œæœ‰bä¸ªï¼Œé‚£ä¹ˆsim(si,sj)=a/(a+b)ã€‚çŽ°åœ¨æˆ‘ä»¬åªéœ€è¦è¯æ˜Žå¯¹çŸ©é˜µè¡Œè¿›è¡ŒéšæœºæŽ’åˆ—ï¼Œä¸¤ä¸ªçš„æœ€å°hashå€¼ç›¸ç­‰çš„æ¦‚çŽ‡P(h(Si)=h(Sj))=a/(a+b)ï¼Œå¦‚æžœæˆ‘ä»¬æŠŠCç±»è¡Œéƒ½åˆ æŽ‰ï¼Œé‚£ä¹ˆç¬¬ä¸€è¡Œä¸æ˜¯Aç±»è¡Œå°±æ˜¯Bç±»è¡Œï¼Œå¦‚æžœç¬¬ä¸€è¡Œæ˜¯Aç±»è¡Œé‚£ä¹ˆh(Si)=h(Sj)ï¼Œå› æ­¤P(h(Si)=h(Sj))=P(åˆ æŽ‰Cç±»è¡ŒåŽï¼Œç¬¬ä¸€è¡Œä¸ºAç±»)=Aç±»è¡Œçš„æ•°ç›®/æ‰€æœ‰è¡Œçš„æ•°ç›®=a/(a+b)ï¼Œè¿™å°±æ˜¯æœ€å°hashçš„ç¥žå¥‡ä¹‹å¤„ã€‚ ç¬¬å››æ­¥ï¼š è¿™ä¸ªåªæ˜¯ä¸€æ¬¡éšæœºé‡‡æ ·ï¼Œæ ¹æ®ä¸­å¿ƒæžé™å®šç†ï¼Œåªæœ‰å¤šæ¬¡éšæœºé‡å¤é‡‡æ ·ï¼Œæ‰èƒ½å¾—åˆ°æ¯”è¾ƒç¨³å®šçš„ç»“æžœã€‚é‚£ä¹ˆçŽ°åœ¨å‡ºçŽ°å¦ä¸€ä¸ªé—®é¢˜ï¼Œå°†éšæœºæŽ’åˆ—åŽ»æŽ’åºï¼Œè¿™è€—è´¹å¾ˆé•¿çš„æ—¶é—´ã€‚äºŽæ˜¯è¿™é‡Œä½¿ç”¨äº†å¦ä¸€ç§æ–¹å¼ï¼Œé€‰æ‹©n ä¸ªhash å‡½æ•° $h_1$, $h_2$, $h_3$ .. $h_n$ å¾—åˆ°ä¸åŒçš„ç­¾åçŸ©é˜µï¼Œè€Œä¸æ˜¯å°†çŸ©é˜µè¿›è¡Œé‡æ–°æŽ’åºã€‚ å¯¹äºŽä¸¤ä¸ªdocumentï¼Œåœ¨Min-Hashingæ–¹æ³•ä¸­ï¼Œå®ƒä»¬hashå€¼ç›¸ç­‰çš„æ¦‚çŽ‡ç­‰äºŽå®ƒä»¬é™ç»´å‰çš„Jaccardç›¸ä¼¼åº¦ã€‚ å°±æ˜¯è¯´ï¼Œå¯¹äºŽä¸¤ä¸ªdocumentï¼Œåœ¨Min-Hashingæ–¹æ³•ä¸­ï¼Œå®ƒä»¬hashå€¼ç›¸ç­‰çš„æ¦‚çŽ‡ç­‰äºŽå®ƒä»¬é™ç»´å‰çš„Jaccardç›¸ä¼¼åº¦ã€‚ minhash çš„ç¼ºç‚¹ åœ¨å·¥ç¨‹ä¸­ï¼Œä¸å®¹æ˜“æ‰¾åˆ°ä¸€ç³»åˆ—çš„hash å‡½æ•°ï¼Œä¸åŒçš„hash å‡½æ•°ä¹‹é—´å¯èƒ½ç›¸å…³ å±€éƒ¨æ•æ„Ÿå“ˆå¸Œæ˜¯ç›¸å¯¹çš„ï¼Œè€Œä¸”æˆ‘ä»¬æ‰€è¯´çš„ä¿æŒæ•°æ®çš„ç›¸ä¼¼åº¦ä¸æ˜¯è¯´ä¿æŒ100%çš„ç›¸ä¼¼åº¦ï¼Œè€Œæ˜¯ä¿æŒæœ€å¤§å¯èƒ½çš„ç›¸ä¼¼åº¦ã€‚å¯¹äºŽå±€éƒ¨æ•æ„Ÿå“ˆå¸Œâ€œä¿æŒæœ€å¤§å¯èƒ½çš„ç›¸ä¼¼åº¦â€çš„è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ä»Žæ•°æ®é™ç»´çš„è§’åº¦åŽ»è€ƒè™‘ã€‚æ•°æ®å¯¹åº”çš„ç»´åº¦è¶Šé«˜ï¼Œä¿¡æ¯é‡ä¹Ÿå°±è¶Šå¤§ï¼Œç›¸åï¼Œå¦‚æžœæ•°æ®è¿›è¡Œäº†é™ç»´ï¼Œé‚£ä¹ˆæ¯«æ— ç–‘é—®æ•°æ®æ‰€åæ˜ çš„ä¿¡æ¯å¿…ç„¶ä¼šæœ‰æŸå¤±ã€‚å“ˆå¸Œå‡½æ•°ä»Žæœ¬è´¨ä¸Šæ¥çœ‹å°±æ˜¯ä¸€ç›´åœ¨æ‰®æ¼”æ•°æ®é™ç»´çš„è§’è‰²ã€‚ simhash æœ‰ä¸¤ä¸ªæ¯”è¾ƒå…¸åž‹çš„åº”ç”¨ï¼šä¸€ä¸ªæ˜¯ç½‘é¡µæŠ“å–çš„æŽ’é‡ï¼Œä¸€ä¸ªæ˜¯æ£€ç´¢æ—¶ç›¸ä¼¼doc çš„æŽ’é‡ simhashä¸ŽMinhashçš„è”ç³»å’ŒåŒºåˆ«ï¼š ç›¸åŒç‚¹ï¼šsimhashå’Œminhashå¯ä»¥åšåˆ°ä¸¤ä¸ªæ–‡æ¡£Hashä¹‹åŽä»ç„¶ç›¸ä¼¼ï¼Œä½†æ˜¯simhashè®¡ç®—ç›¸ä¼¼çš„æ–¹æ³•æ˜¯æµ·æ˜Žè·ç¦»ï¼›è€Œminhashè®¡ç®—è·ç¦»çš„æ–¹å¼æ˜¯Jaccardè·ç¦»ã€‚ä¸åŒç‚¹ï¼šç†è®ºä¸Šè®²ï¼Œsimhash çš„å‡†ç¡®çŽ‡ä½ŽäºŽminhashã€‚åŽŸå› æœ‰äºŒï¼š simhash å¯¹æ–‡æœ¬è¿›è¡Œåˆ†è¯å¹¶ç»Ÿè®¡è¯é¢‘ï¼Œå¯ä»¥è®¤ä¸ºæ˜¯ä¸€ä¸ªè¯è¢‹æ¨¡åž‹ï¼Œæ²¡æœ‰ç»Ÿè®¡è¯æ±‡çš„å…ˆåŽé¡ºåºã€‚è€Œminhash ä½¿ç”¨æ»‘åŠ¨çª—å£çš„æ–¹å¼ï¼ŒåŠ å…¥äº†è¯æ±‡çš„è¯åºä¿¡æ¯ã€‚ simhash å¯¹è¯æ±‡ç‰¹å¾å‘é‡æŒ‰åˆ—æ±‚å’Œç¬¦å·æ˜ å°„ï¼Œä¸¢å¤±äº†æ–‡æœ¬ç‰¹å¾ä¿¡æ¯ã€‚ å‚è€ƒèµ„æ–™ï¼š è®²è§£minhas https://www.cnblogs.com/maybe2030/p/4953039.html è¿™ä¸ªä¹Ÿæ˜¯æ¯”è¾ƒå¥½çš„ï¼šhttps://www.cnblogs.com/fengfenggirl/p/lsh.html è·ç¦»å‡½æ•°è¿™é‡Œçš„è·ç¦»å‡½æ•°éƒ½æ˜¯ç”¨æ¥æ–‡æœ¬ç›¸ä¼¼åº¦ã€‚ Jaccardç›¸ä¼¼åº¦ç®€å•æ¥è¯´äº¤é›†é™¤ä»¥å¹¶é›†ã€‚è¿™ä¸ªé›†åˆä¸­å­˜æ”¾çš„æ˜¯æ–‡ç« æˆ–è€…æ®µè½çš„å…³é”®è¯ã€‚ 1234567891011def JaccardSim(str_a, str_b): &apos;&apos;&apos; Jaccardç›¸ä¼¼æ€§ç³»æ•° è®¡ç®—saå’Œsbçš„ç›¸ä¼¼åº¦ lenï¼ˆsa &amp; sbï¼‰/ lenï¼ˆsa | sbï¼‰ &apos;&apos;&apos; seta = splitWords(str_a)[1] setb = splitWords(str_b)[1] sa_sb = 1.0 * len(seta &amp; setb) / len(seta | setb) return sa_sb å¯ä»¥çœ‹åˆ°æ ¸å¿ƒä»£ç å¾ˆç®€å•ï¼Œç»è¿‡åˆ†è¯ä¹‹åŽï¼Œå°±æ˜¯seta å’Œsetb è¿›è¡Œçš„æ“ä½œã€‚ Jaccard ç³»æ•°Jaccardç›¸ä¼¼æŒ‡æ•°ç”¨æ¥åº¦é‡ä¸¤ä¸ªé›†åˆä¹‹é—´çš„ç›¸ä¼¼æ€§,å®ƒè¢«å®šä¹‰ä¸ºä¸¤ä¸ªé›†åˆäº¤é›†å…ƒç´ ä¸ªæ•°é™¤ä»¥ä¸¤ä¸ªé›†åˆå¹¶é›†å…ƒç´ ä¸ªæ•°ã€‚ $$\mathrm { J } ( \mathrm { A } , \mathrm { B } ) = \frac { | A \cap B | } { | A \cup B | }$$Jaccardè·ç¦»ç”¨æ¥åº¦é‡ä¸¤ä¸ªé›†åˆä¹‹é—´çš„å·®å¼‚æ€§må®ƒæ˜¯jaccardçš„ç›¸ä¼¼ç³»æ•°çš„è¡¥é›†: $$d _ { J } ( A , B ) = 1 - J ( A , B ) = \frac { | A \cup B | - | A \cap B | } { | A \cup B | }$$åˆ©ç”¨jaccardç›¸ä¼¼åº¦æ¥è¡¡é‡æ–‡æ¡£ä¹‹é—´çš„ç›¸ä¼¼æ€§,ä½¿ç”¨LSHæ¥å®žçŽ°æ–‡æ¡£ç›¸ä¼¼åº¦è®¡ç®—ã€‚ cosine12345def cos_sim(a, b): a = np.array(a) b = np.array(b) # return &#123;&quot;æ–‡æœ¬çš„ä½™å¼¦ç›¸ä¼¼åº¦:&quot;:np.sum(a*b) / (np.sqrt(np.sum(a ** 2)) * np.sqrt(np.sum(b ** 2)))&#125; return np.sum(a * b) / (np.sqrt(np.sum(a ** 2)) * np.sqrt(np.sum(b ** 2))) å°†æ–‡æœ¬çš„å…³é”®è¯æ˜ å°„æˆæŸç§é«˜ç»´å‡½æ•°ï¼Œç„¶åŽåœ¨é«˜ç»´ç©ºé—´ä¸­è®¡ç®—ä¸¤è€…çš„ç›¸ä¼¼åº¦ã€‚ tf-idfåœ¨simhash ä¸­ä½¿ç”¨ tf-idfä½œä¸ºæˆ‘ä»¬çš„æ¯”è¾ƒå‡½æ•°ã€‚TF-IDFçš„ä¸»è¦æ€æƒ³å°±æ˜¯ï¼šå¦‚æžœæŸä¸ªè¯åœ¨ä¸€ç¯‡æ–‡æ¡£ä¸­å‡ºçŽ°çš„é¢‘çŽ‡é«˜ï¼Œä¹Ÿå³TFé«˜ï¼›å¹¶ä¸”åœ¨è¯­æ–™åº“ä¸­å…¶ä»–æ–‡æ¡£ä¸­å¾ˆå°‘å‡ºçŽ°ï¼Œå³DFçš„ä½Žï¼Œä¹Ÿå³IDFé«˜ï¼Œåˆ™è®¤ä¸ºè¿™ä¸ªè¯å…·æœ‰å¾ˆå¥½çš„ç±»åˆ«åŒºåˆ†èƒ½åŠ›ã€‚$$ TF-IDF = è¯é¢‘(TF) x é€†æ–‡æ¡£é¢‘çŽ‡(IDF) $$ ç®—æ³•æ­¥éª¤ï¼š è®¡ç®—è¯é¢‘$$ è¯é¢‘(TF) = æŸä¸ªè¯åœ¨æ–‡ç« ä¸­å‡ºçŽ°çš„æ¬¡æ•°( é¢‘æ•°) $$æˆ–è€…å¯ä»¥è¿›ä¸€æ­¥è¿›è¡Œâ€œæ ‡å‡†åŒ–â€$$ è¯é¢‘( TF) = \frac{æŸæ¬¡åœ¨æ–‡ä¸­å‡ºçŽ°çš„æ¬¡æ•°}{æ–‡ç« çš„æ€»è¯è¯­æ•°} $$ é€†æ–‡æ¡£é¢‘çŽ‡(è¿™å¯¹è¿™ä¸ªæœ¯è¯­çš„è¿˜æ˜¯å¥½å¥½è®°å¿†)è¿™ä¸ªæ—¶å€™éœ€è¦ä¸€ä¸ªè¯­æ–™åº“ (corpus)ï¼Œæ¨¡æ‹Ÿè¯­è¨€çŽ¯å¢ƒ$$ é€†æ–‡æ¡£é¢‘çŽ‡ (IDF) = log(\frac{è¯­æ–™ä¸­çš„æ–‡æ¡£æ€»æ•°}{ åŒ…å«è¯¥è¯çš„æ–‡æ¡£æ•° +1}) $$ TF-IDF ä¼˜ç‚¹æ˜¯ç®€å•å¿«é€Ÿï¼Œæ¯”è¾ƒç¬¦åˆå®žé™…ã€‚ç¼ºç‚¹ï¼Œæ— æ³•ä½“çŽ°è¯çš„ä½ç½®ä¿¡æ¯ï¼Œæ‰€æœ‰çš„ä½ç½®éƒ½æ˜¯è¢«è®¤ä¸ºé‡è¦æ€§ç›¸åŒï¼Œä½†æ˜¯å¼€å¤´ç»“å°¾ï¼Œæ®µè½çš„å¼€å¤´å’Œæ®µè½çš„ç»“å°¾ï¼Œthereforeï¼Œsoï¼Œbutè¿™äº›è¯è¯­éƒ½æ˜¯æ²¡æœ‰ä½“çŽ°çš„ï¼›è¿˜æœ‰ä¸€ä¸ªç¼ºç‚¹æ˜¯ï¼Œæ˜¯åŸºäºŽç»Ÿè®¡çš„ï¼Œæ²¡æœ‰è¡¨è¾¾å‡ºè¯è¯­çš„è¯­æ„ä¿¡æ¯ or context ä¸Šä¸‹æ–‡çš„ä¿¡æ¯ã€‚ Hamming distancehamming distanceå°±æ˜¯æ¯”è¾ƒ01ä¸²çš„ä¸åŒï¼ŒæŒ‰ç…§ä½è¿›è¡Œæ¯”è¾ƒã€‚ç®—æ³•ï¼šå¼‚æˆ–æ—¶ï¼Œåªæœ‰åœ¨ä¸¤ä¸ªæ¯”è¾ƒçš„ä½ä¸åŒæ—¶å…¶ç»“æžœæ˜¯1 ï¼Œå¦åˆ™ç»“æžœä¸º0ï¼Œä¸¤ä¸ªäºŒè¿›åˆ¶â€œå¼‚æˆ–â€åŽå¾—åˆ°1çš„ä¸ªæ•°å³ä¸ºæµ·æ˜Žè·ç¦»çš„å¤§å°ã€‚ 123456789101112131415161718hashbits =64 # ä½¿ç”¨64ä½è¿›è¡Œç¼–ç def simhash_function(tokens, weights_dict): v = [0] * hashbits # è¿™ç§ &#123;key: value&#125;.item() çš„æ“ä½œä¹Ÿæ˜¯æ²¡æœ‰äº†è°äº† for key, t in &#123;x: _string_hash(x) for x in tokens&#125;.items(): for i in range(hashbits): bitmask = 1 &lt;&lt; i if t &amp; bitmask: v[i] += weights_dict[key] else: v[i] -= weights_dict[key] fingerprint = 0 for i in range(hashbits): if v[i] &gt;= 0: fingerprint += 1 &lt;&lt; i return fingerprintfingerprint = simhash_function(tokens, weights) åˆ†è¯åœ¨è‹±æ–‡ä¸­å­˜åœ¨å¤©ç„¶çš„ç©ºæ ¼å¯ä»¥è¿›è¡Œåˆ†è¯æ“ä½œï¼Œä½†æ˜¯ä¸­æ–‡çš„åˆ†è¯å°±æ¯”è¾ƒå¤æ‚äº†ã€‚å¸¸ç”¨çš„ä¸­æ–‡åˆ†è¯å¼€æºå·¥å…·æœ‰ jiebaå’ŒHanLPå‰è€…ç®€å•æ˜“è¡Œï¼Œå®¹æ˜“ä¸Šæ‰‹ï¼›åŽè€…åœ¨è‡ªç„¶è¯­è¨€å¤„ç†ä½œä¸ºæ±‰è¯­è¨€å¤„ç†åŒ…ï¼Œå¯ä»¥ç”¨äºŽè¯æ€§æ ‡æ³¨ï¼Œå‘½åå®žä½“è¯†åˆ«ç­‰ä¸€ç³»åˆ—åŠŸèƒ½ã€‚å¸¸ç”¨çš„è‹±æ–‡åˆ†è¯ corenlp å€’æŽ’ç´¢å¼•å€’æŽ’ç´¢å¼•ä½¿ç”¨pythonåœ¨å®žçŽ°ä¸Šå°±æ˜¯ä¸€ä¸ªdictionary åµŒå¥—ä¸€ä¸ª set(). ä¸€èˆ¬çš„ç´¢å¼•éƒ½æ˜¯æ•°å­—æˆ–è€…è‹±æ–‡å­—æ¯æ˜ å°„å†…å®¹ï¼Œå…·ä½“åœ¨æ”¾åˆ°simhashçš„æƒ…æ™¯ä¸‹å°±æ˜¯ä½¿ç”¨æ–‡ç« çš„åºåˆ—å·å¯¹åº”æå–å‡ºæ¥çš„å…³é”®è¯ã€‚ä½†æ˜¯å€’æŽ’ç´¢å¼•å°±æ˜¯å…³é”®è¯å¯¹åº”æ–‡ç« çš„åºåˆ—å·ï¼Œç±»ä¼¼ä¸ŽåŽŸæ¥çš„â€å€¼â€å¯¹åº”è¿™â€é”®â€ï¼Œæ‰€ä»¥ç§°ä¹‹ä¸ºå€’æŽ’ç´¢å¼•ã€‚ä¸€èˆ¬ä½¿ç”¨åœ¨å¬å›žçš„åœºæ™¯ä¸‹ï¼Œä½¿ç”¨å…³é”®è¯ç„¶åŽå‡ºçŽ°äº†è¯¥å…³é”®è¯ä¸‹çš„index çš„é›†åˆã€‚å¯ä»¥å‚è€ƒè¿™ç¯‡æ–‡ç« ã€‚ ä¸€èˆ¬çš„æƒ…å†µæ˜¯key æ˜¯ç´¢å¼•ï¼Œvalue å¯¹åº”çš„æ˜¯å…³é”®è¯ä¹‹åˆ—çš„å†…å®¹ï¼› ä½†æ˜¯å€’æŽ’ç´¢å¼•æ­£å¥½ç›¸åï¼Œå…³é”®å­—ä½œä¸ºkeyï¼Œç„¶åŽç´¢å¼•ä½œä¸ºvalueï¼Œæ‰€ä»¥ç§°ä¹‹ä¸ºå€’æŽ’ç´¢å¼•ã€‚]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>simhash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Differences Between l1 and l2 as Loss Function and Regularization]]></title>
    <url>%2F2018%2F07%2F21%2Fdifferences-between-l1-and-l2-as-loss-function-and-regularization%2F</url>
    <content type="text"><![CDATA[L1 å’ŒL2 æ—¢å¯ä»¥ä½œä¸º loss function ä¹Ÿå¯ä»¥ä½œä¸º reguarizationï¼Œåˆ†åˆ«ä»‹ç»äº†ä¸€ä¸‹ä¸¤è€…ï¼Œæœ€åŽä»‹ç» overfitting çš„æ¦‚å¿µã€‚ As loss functionloss function or error function æ˜¯ç”¨æ¥è¡¡é‡çœŸå®ž$y$ å’Œç”Ÿæˆçš„$ f(x)$ ä¹‹é—´å·®è·çš„å‡½æ•°ã€‚åœ¨æ¨¡åž‹è®­ç»ƒä¸­æˆ‘ä»¬ä¸€èˆ¬æƒ…å†µä¸‹ä¸æ–­è®­ç»ƒæ¨¡åž‹ä½¿å¾—loss functionä¸æ–­ä¸‹é™ï¼ˆå¦‚æžœtaskè¦æ±‚loss functionæ˜¯å¢žå¤§ï¼Œè¿™æ—¶å€™ä¸€èˆ¬åŠ ä¸Šç¬¦å·æˆ–è€…è½¬æ¢æˆ 1- loss fucntionï¼Œæœ€åŽå®žçŽ°çš„è¿˜æ˜¯loss functionä¸‹é™ï¼‰ã€‚å¥½çš„å›žåˆ°L1 loss functionå’ŒL2 loss function. æ¦‚æ‹¬ï¼šä»Žé²æ£’æ€§ï¼ˆå¯¹å¾…å¼‚å¸¸å€¼ï¼‰çš„è§’åº¦çœ‹ï¼ŒL1 æ˜¯æ¯”L2 å…·æœ‰æ›´å¥½çš„æ€§è´¨ï¼Œå› ä¸ºL2 æ˜¯æŠŠè¯¯å·®è¿›è¡Œäº†å¹³æ–¹å¤„ç†ï¼Œè¯¯å·®å›žæ”¾å¤§ï¼›ä»Žç¨³å®šæ€§è§’åº¦ï¼ˆæ•°æ®é›†çš„ä¸€ä¸ªå°çš„ç§»åŠ¨ï¼‰ï¼ŒL2 æ˜¯æ¯”L1 å…·æœ‰æ›´å¥½çš„æ€§è´¨ï¼Œè¿™ä¸ªæ˜¯å¯ä»¥ä»Žå®žéªŒçš„è§’åº¦è¿›è¡Œæ€»ç»“ã€‚ L1-norm loss function is also known as least absolute deviations(LAD), least absolute errors. It is basically minimizing the sum of the absolute differences between the target value Y and the estimated values (f(x)). $$S = \sum _ { i = 1 } ^ { n } \left| y _ { i } - f \left( x _ { i } \right) \right|$$ L2-norm loss function is also known as least squares error(LSE). It is basically minimizing the sum of the square of the differences between the target value Y and the estimated values (f(x)). $$S = \sum _ { i = 1 } ^ { n } \left( y _ { i } - f \left( x _ { i } \right) \right) ^ { 2 }$$ æ¯”è¾ƒL1-norm å’ŒL2-normåœ¨å‰ä¸¤ä¸ªè¯„ä»·æŒ‡æ ‡ä¸­çš„è¡¨çŽ°ï¼š å¯¹äºŽæ˜¯å¦å…·æœ‰å”¯ä¸€è§£ï¼Œå¯ä»¥ä»Žè¿™ä¸ªè§’åº¦åˆ†æžï¼šL1æ˜¯å¯ä»¥æœ‰å¤šç§è§£ï¼Œè€ŒL2åªæœ‰ä¸€ç§è§£ã€‚(æ›¼å“ˆé¡¿è·ç¦») ä½¿ç”¨èŒƒå›´ï¼š L1 é€‚åˆåœ¨ç¨€ç–æ•°æ®ä¸Šä½¿ç”¨ï¼Œå…·æœ‰ç‰¹å¾é€‰æ‹©åŠŸèƒ½ï¼Œå¾—åˆ°çš„ç¨€ç–è§£ï¼›L2 é€‚åˆåœ¨ç¨ å¯†æ•°æ®ä¸Šä½¿ç”¨ï¼Œå¾—åˆ°çš„æ˜¯å”¯ä¸€è§£ï¼Œæ²¡æœ‰ç‰¹å¾é€‰æ‹©çš„åŠŸèƒ½ã€‚ As regularizationä»ŽXGBoostè°ƒå‚æŒ‡å—ä¸­æˆ‘ä»¬çŸ¥é“objective function = loss funcion + regularization. è€Œæˆ‘ä»¬å¤§å¤šæ•°æƒ…å†µä¸‹æåŠçš„éƒ½æ˜¯loss function,å¸¸å¸¸å¿½ç•¥äº†regularization çš„ä½œç”¨ã€‚ The regularization term controls the complexity of the model, which helps us to avoid overfitting.å¯¹äºŽæ¨¡åž‹è®­ç»ƒï¼Œä¸€å¼€å§‹çš„æƒ³æ³•æ˜¯å°½é‡çš„overfitting, å› ä¸ºå°±çŽ°åœ¨ä¸æˆç†Ÿçš„ç»éªŒè€Œè¨€ï¼Œå¯¹äºŽoverfittingè¿™ä¸ªé—®é¢˜æœ‰å¾ˆå¤šå¤„ç†æ–¹æ³•ï¼Œæ¯”å¦‚å·ç§¯æ·±åº¦ç¥žç»ç½‘ç»œä¸­çš„dropout, LightGBMä¸­çš„early stop å’Œéšæœºé‡‡æ ·çš„æ€æƒ³ã€‚ è¿™äº›æ–¹æ³•éƒ½æ˜¯å¯ä»¥ç¼“è§£overfittingï¼Œæ‰€ä»¥å¯ä»¥å‡ºçŽ°overfittingã€‚ç›¸åï¼Œå¦‚æžœä½ çš„æ¨¡åž‹æ˜¯underfittingï¼Œé‚£ä¹ˆä½ å°±å¾®æ˜¾å°´å°¬äº†ã€‚å¥½ï¼Œæ”¶å›žåˆ°L1 and L2ã€‚ æ€»ç»“ï¼š L1 åœ¨ç³»æ•°weights ä¸­ä½¿ç”¨ï¼ŒL2 åœ¨éžç¨€ç–çš„æƒ…å†µä¸‹ä½¿ç”¨æ›´å¥½ã€‚å¯ä»¥ä»Žè®¡ç®—æ•ˆçŽ‡ã€æ˜¯å¦ç¨€ç–è¾“å‡ºå’Œç‰¹å¾é€‰æ‹©è¿›è¡Œåˆ†æžã€‚ è®¡ç®—æ•ˆçŽ‡ ç¨€ç–ç»“æžœ ç‰¹å¾é€‰æ‹© L1 åœ¨ç¨€ç–è§£ ä¸Šæ•ˆçŽ‡æ¯”è¾ƒé«˜ï¼Œåœ¨éžç¨€ç–è§£ä¸Šæ•ˆçŽ‡æ¯”è¾ƒä½Ž äº§ç”Ÿç¨€ç–è§£ å…·æœ‰ç‰¹å¾é€‰æ‹©çš„åŠŸèƒ½ L2 åœ¨éžç¨€ç–è§£ä¸Šæ•ˆçŽ‡é«˜ ä¸äº§ç”Ÿç¨€ç–è§£ æ²¡æœ‰ç‰¹å¾é€‰æ‹©çš„åŠŸèƒ½ é¦–å…ˆç†è§£ä¸ºä»€ä¹ˆè¦æ­£åˆ™åŒ–ï¼Ÿ å¦‚æžœç½‘ç»œè¶³å¤Ÿçš„å¼ºå¤§ï¼Œæ•°æ®é‡ä¸æ˜¯é‚£ä¹ˆå……è¶³ï¼Œé‚£ä¹ˆç½‘ç»œå®Œå…¨æ˜¯å¯ä»¥é€šè¿‡â€œè®°ä½â€ è¿™äº›æ ·æœ¬ï¼Œç„¶åŽå¾—åˆ°å¾ˆé«˜çš„ training accï¼Œä½†æ˜¯è¿™ä¸ª test error ä¼šæ¯”è¾ƒå¤§ï¼Œè¿™ä¸ªæ—¶å€™å°±å‡ºçŽ°äº†è¿‡æ‹Ÿåˆã€‚æ­£åˆ™åŒ–å°±ç±»ä¼¼å‡è½»äº†æ•°æ®çš„å¤æ‚ç¨‹åº¦ã€‚å…³äºŽè¿‡æ‹Ÿåˆæ˜¯å¯ä»¥ä»Žä¸¤ä¸ªç»´åº¦è¿›è¡Œè§£å†³ï¼šç½‘ç»œå’Œæ•°æ®ã€‚ å¸¸å¸¸ä½¿ç”¨çš„ dropout å°±æ˜¯å‡å¼±ç½‘ç»œå¤æ‚æ€§çš„ä¸€ç§æ‰‹æ®µï¼Œéšæœºå‡å°‘äº†æŸäº›ç½‘ç»œä¸­çš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆç½‘ç»œå°±æ²¡æœ‰é‚£ä¹ˆå¼ºçš„â€œè®°å¿†â€åŠŸèƒ½ï¼Œä½†æ˜¯æœ€åŽçš„lossï¼ˆè¦æ±‚ï¼‰è¿˜æ˜¯ä¸å˜çš„ï¼Œæ‰€ä»¥åªèƒ½åŽ»å¯»æ‰¾æ•°æ®æ›´åŠ â€œç®€å•æ™®éâ€çš„è§„å¾‹ï¼›æ­£åˆ™åŒ–æ˜¯å¯¹æ•°æ®å’Œweights ä¸¤ç§ç±»åž‹çš„ï¼Œå‰è€…æ˜¯å¯¹äºŽæ•°æ®çš„æ“ä½œï¼Œç„¶åŽweights æ›´åŠ å€¾å‘äºŽå¯¹äºŽç½‘ç»œç»“æž„çš„æ“ä½œï¼Œä½¿å¾—ç³»æ•°æ›´åŠ â€œå…‰æ»‘â€ã€‚ ä¸ºä»€ä¹ˆL1 ç›¸æ¯”äºŽL2 äº§ç”Ÿäº†æ›´åŠ ç¨€ç–çš„è§£ï¼Ÿ ï¼ˆè¿™é‡Œä»Žæ•°æ®åˆ†å¸ƒçš„è§’åº¦è¿›è¡Œè§£è¯»ï¼ŒL2 çš„æ•°æ®æ¥æºæ˜¯é«˜æ–¯åˆ†å¸ƒï¼›L1 å¯ä»¥çœ‹æˆæ˜¯æ¥è‡ªlaplace åˆ†å¸ƒï¼‰ è¿™é‡Œä»Žæ•°å­¦è§’åº¦å’Œç©ºé—´è§’åº¦è¿›è¡Œäº†è§£é‡Šã€‚ ä½†æ˜¯ä»Žæ›´åŠ  tuition çš„è§’åº¦åŽ»ç†è§£ï¼ŒL1 æ²¡æœ‰ä¸€ä¸ªè¿žç»­çš„å¯¼æ•°ï¼Œèƒ½äº§ç”Ÿæƒå€¼ä¸º0ï¼Œæ‰€ä»¥ç±»ä¼¼å‰”é™¤äº†æŸäº›ç‰¹å¾ï¼Œäº§ç”Ÿäº†ç¨€ç–çš„æƒå€¼ï¼Œè€ŒL2 æ˜¯å…·æœ‰æ¯”è¾ƒè¿žç»­çš„å¯¼æ•°ï¼Œäº§ç”Ÿäº†æ¯”è¾ƒå¹³æ»‘çš„æƒå€¼ã€‚ æ›´åŠ æ•°å­¦åŒ–çš„ç†è§£ï¼š $$f ( x ) = \frac { 1 } { \sqrt { 2 \pi } \sigma } \exp \left( - \frac { ( x - \mu ) ^ { 2 } } { 2 \sigma ^ { 2 } } \right)$$å¦‚æžœæŠŠé«˜æ–¯å¯†åº¦å‡½æ•°å–å¯¹æ•°ï¼Œé‚£ä¹ˆå°±åªä¼šå‰©ä¸‹ä¸€ä¸ªå¹³æ–¹é¡¹ï¼Œè¿™ä¸ªå°±æ˜¯L2æ­£åˆ™é¡¹çš„æ¥æºï¼Œæ‰€ä»¥æ•°æ®æ˜¯æ¯”è¾ƒç¨ å¯†çš„ã€‚ åŒæ ·ï¼Œå¦‚æžœæ˜¯æ•°æ®æ¯”è¾ƒç¨€ç–ï¼Œä¸å¦¨å‡è®¾æ¥è‡ª laplace åˆ†å¸ƒï¼Œä¸‹é¢æ˜¯å…¶ä¸­çš„ $u$ è¡¨ç¤ºä½ç½®å‚æ•°ï¼Œ $ b $ è¡¨ç¤ºå°ºåº¦å‚æ•°, å½“ $b$ è¶Šå¤§çš„æ—¶å€™ï¼Œå›¾åƒè¶Šä½ŽçŸ®ï¼Œæ•°æ®è¶Šä¸é›†ä¸­ï¼Œè¶Šç±»ä¼¼å‡åŒ€åˆ†å¸ƒï¼Œæ‰€ä»¥æœ‰ä¸€ç§ç¨€ç–çš„æ„Ÿè§‰ã€‚è¿™ä¸¤ä¸ªéƒ½æ˜¯å¯ä»¥å¯¹æ ‡æ­£å¤ªåˆ†å¸ƒçš„ã€‚å¯ä»¥çœ‹åˆ°å›¾åƒçš„å°¾éƒ¨éƒ½æ˜¯æ¯”è¾ƒå¹³æ»‘ï¼Œç„¶åŽå¤§å¤šæ•°æ˜¯æŽ¥è¿‘äºŽ0çš„ã€‚ å…¬å¼ï¼š$$f ( x | \mu , b ) = \frac { 1 } { 2 b } \exp \left( - \frac { | x - \mu | } { b } \right)$$åŒæ ·å–å¯¹æ•°ï¼Œé‚£ä¹ˆå¾—åˆ°æ˜¯L1 æ­£åˆ™é¡¹ã€‚ æ‰€ä»¥L2 å¾—åˆ°çš„æ˜¯ä¸€ä¸ªæ¯”è¾ƒå¹³æ»‘çš„weights é€‚åˆå¤„ç†ç¨ å¯†çš„å‘é‡ï¼Œè€ŒL1 å¾—åˆ°æ˜¯ä¸€ä¸ªç¨€ç–çš„ç»“æžœï¼Œå› ä¸ºæœ‰å¾ˆå¤§ç¨‹åº¦çš„è¢«ç½®ä¸º0. å…ˆä¸Šå…¬å¼L1 regularization on least squares:$$\mathbf { w } ^ { * } = \underset { \mathbf { w } } { \arg \min } \sum _ { j } \left( t \left( \mathbf { x } _ { j } \right) - \sum _ { i } w _ { i } h _ { i } \left( \mathbf { x } _ { j } \right) \right) ^ { 2 }$$ L2 regularization on least squares: The difference between their properties can be promptly summarized as follows: å¯¹äºŽç¬¬ä¸€ç‚¹computational efficientçš„ç†è§£ï¼šå¹³æ–¹æ¯”ç»å¯¹å€¼æ›´å®¹æ˜“è®¡ç®—ï¼Œå¹³æ–¹å¯ä»¥æ±‚å¯¼ç›´æŽ¥æ±‚æœ€å€¼ï¼Œä½†æ˜¯ç»å¯¹å€¼å°±æ— æ³•æ±‚å¯¼ã€‚å¹¶ä¸”L1 regularizationåœ¨ non-sparse casesä¸­æ˜¯ computational inefficientï¼Œä½†æ˜¯åœ¨ sparse(0æ¯”è¾ƒå¤š) casesä¸­æ˜¯æœ‰ç›¸åº”çš„ç¨€ç–ç®—æ³•æ¥è¿›è¡Œä¼˜åŒ–çš„ï¼Œæ‰€ä»¥æ˜¯computational efficient.å¯¹äºŽç¬¬äºŒç‚¹æ˜¯å¦å…·æœ‰sparse solutionå¯ä»¥ä»Žå‡ ä½•æ„ä¹‰çš„è§’åº¦è§£è¯»ï¼šThe green line(L2-norm) is the unique shortest path, while the red, blue yellow(L1-norm) are all same length for the same route. Built-in feature selection is frequently mentioned as a useful property of the L1-norm, which the L2-norm does not. This is actually a result of the L1-norm, which tends to produces sparse coefficients (explained below). Suppose the model have 100 coefficients but only 10 of them have non-zero coefficients, this is effectively saying that â€œthe other 90 predictors are useless in predicting the target valuesâ€. L2-norm produces non-sparse coefficients, so does not have this property. æ‰€ä»¥è¡¨æ ¼ä¸­ç¬¬ä¸‰ç‚¹ä¹Ÿæ˜¯é¡ºç†æˆç« çš„äº†ã€‚è‡³æ­¤ï¼Œæˆ‘ä»¬åŒºåˆ†äº†L1-norm vs L2-norm loss function å’ŒL1-regularization vs L2-regularizationï¼Œä¸‹é¢è¯´ä¸€ä¸‹ overfittingçš„ä¸œè¥¿ã€‚ overfittingçŽ°åœ¨ï¼Œæˆ‘ä»¬çš„è®­ç»ƒä¼˜åŒ–ç®—æ³•æ˜¯ä¸€ä¸ªç”±ä¸¤é¡¹å†…å®¹ç»„æˆçš„å‡½æ•°ï¼šä¸€ä¸ªæ˜¯æŸå¤±é¡¹ï¼Œç”¨äºŽè¡¡é‡æ¨¡åž‹ä¸Žæ•°æ®çš„æ‹Ÿåˆåº¦ï¼Œå¦ä¸€ä¸ªæ˜¯æ­£åˆ™åŒ–é¡¹ï¼Œç”¨äºŽè¡¡é‡æ¨¡åž‹å¤æ‚åº¦ã€‚ å¯¹äºŽè¿‡æ‹Ÿåˆæœ‰ä¸¤ç§è§£è¯»æ–¹å¼ï¼Œä¸€ç§æ˜¯æ¨¡åž‹æ˜¯å¤æ‚ï¼Œç„¶åŽæ˜¯åŽ»æ‹Ÿåˆäº†æ‰€æœ‰çš„æ•°æ®ï¼Œæ²¡æœ‰äº†æ³›åŒ–æ€§èƒ½ï¼› ä¸€ç§æ˜¯ä»Žæ•°æ®è§’åº¦ï¼Œæ¨¡åž‹åŽ»æ‹Ÿåˆäº†noise ï¼Œè¿™äº›randomçš„æ•°æ®ã€‚ç„¶åŽä»Žloss functionçš„è§’åº¦åŽ»ä¼˜åŒ–çš„è¯ï¼Œå°±æ˜¯é™ä½Žæ¨¡åž‹çš„å¤æ‚åº¦ï¼Œæ­£åˆ™é¡¹å°±æ˜¯é™ä½Žæ¨¡åž‹å¤æ‚åº¦çš„ä¸€ç§æ‰‹æ®µã€‚æ‰€ä»¥ä»Žè¿™ä¸ªè§’åº¦ï¼ŒL2 æ˜¯é™ä½Žæ¨¡åž‹å¤æ‚åº¦çš„ä¸€ç§æ‰‹æ®µï¼Œä¹Ÿæ˜¯ä¸€ç§å‡è½»overfitçš„æ‰‹æ®µï¼Œè¿™ä¸¤è€…æ˜¯ç›¸è¾…ç›¸æˆçš„ã€‚ L0 èŒƒæ•°å¯¹äºŽ èŒƒæ•°çš„ä¸€èˆ¬å®šä¹‰, p-norrm å¦‚ä¸‹ï¼š $$|x|{p} :=\left(\sum{i=1}^{n}\left|x_{i}\right|^{p}\right)^{\frac{1}{p}}$$è™½ç„¶L0ä¸¥æ ¼è¯´ä¸å±žäºŽèŒƒæ•°ï¼Œæˆ‘ä»¬å¯ä»¥é‡‡ç”¨ä¸Šè¿°ç­‰å¼ç»™å‡ºl0-normå¾—å®šä¹‰ï¼š $$|x|{0} :=\sqrt[0]{\sum{i=0}^{n} x_{i}^{0}}$$ 0çš„æŒ‡æ•°å’Œå¹³æ–¹æ ¹ä¸¥æ ¼æ„ä¹‰ä¸Šæ˜¯å—é™æ¡ä»¶ä¸‹æ‰æˆç«‹çš„ã€‚å› æ­¤åœ¨å®žé™…åº”ç”¨ä¸­ï¼Œå¤šæ•°äººç»™å‡ºä¸‹é¢çš„æ›¿ä»£å®šä¹‰ï¼š$$|x|{0}=#(i) \text { with } x{i} \neq 0$$å…¶è¡¨ç¤ºå‘é‡ä¸­æ‰€æœ‰éžé›¶å…ƒç´ çš„ä¸ªæ•°ã€‚æ­£æ˜¯L0èŒƒæ•°çš„è¿™ä¸ªå±žæ€§ï¼Œä½¿å¾—å…¶éžå¸¸é€‚åˆæœºå™¨å­¦ä¹ ä¸­ç¨€ç–ç¼–ç ï¼Œç‰¹å¾é€‰æ‹©çš„åº”ç”¨ã€‚é€šè¿‡æœ€å°åŒ–L0èŒƒæ•°ï¼Œæ¥å¯»æ‰¾æœ€å°‘æœ€ä¼˜çš„ç¨€ç–ç‰¹å¾é¡¹ã€‚ä½†ä¸å¹¸çš„æ˜¯ï¼ŒL0èŒƒæ•°çš„æœ€å°åŒ–é—®é¢˜åœ¨å®žé™…åº”ç”¨ä¸­æ˜¯NPéš¾é—®é¢˜ã€‚å› æ­¤å¾ˆå¤šæƒ…å†µä¸‹ï¼ŒL0ä¼˜åŒ–é—®é¢˜å°±ä¼šè¢«relaxeä¸ºæ›´é«˜ç»´åº¦çš„èŒƒæ•°é—®é¢˜ï¼Œå¦‚L1èŒƒæ•°ï¼ŒL2èŒƒæ•°æœ€å°åŒ–é—®é¢˜ã€‚ ä»Žæœ€ä¼˜åŒ–é—®é¢˜è§£çš„å¹³æ»‘æ€§æ¥çœ‹ï¼ŒL1èŒƒæ•°çš„æœ€ä¼˜è§£ç›¸å¯¹äºŽL2èŒƒæ•°è¦å°‘ï¼Œä½†å…¶å¾€å¾€æ˜¯æœ€ä¼˜è§£ï¼Œè€ŒL2çš„è§£å¾ˆå¤šï¼Œä½†æ›´å¤šçš„å€¾å‘äºŽæŸç§å±€éƒ¨æœ€ä¼˜è§£ã€‚ L0,L1,L2èŒƒæ•°åŠå…¶åº”ç”¨ å¤ä¹ æ€»ç»“ ä½œä¸ºloss function L1å’ŒL2 çš„åŒºåˆ«ï¼š (1) é²æ£’æ€§ï¼ˆå¯¹å¾…å¼‚å¸¸å€¼ï¼‰è§’åº¦ï¼ŒL1 æ˜¯æ¯”L2 å…·æœ‰æ›´å¥½çš„æ€§è´¨ï¼Œå› ä¸ºåŽè€…æŠŠè¯¯å·®è¿›è¡Œäº†å¹³æ–¹æ”¾å¤§ã€‚(2 ) L2 æ˜¯å…·æœ‰å”¯ä¸€è§£L1 æ˜¯æœ‰å¤šç§è§£ ï¼ˆ3ï¼‰ L1é€‚åˆåœ¨ç¨€ç–çŸ©é˜µä¸Šä½¿ç”¨ï¼Œå…·æœ‰ç‰¹å¾é€‰æ‹©çš„åŠŸèƒ½ï¼ˆå› ä¸ºæ˜¯æœ‰0 å­˜åœ¨ï¼‰ å…³äºŽæ­£åˆ™é¡¹L1 æ˜¯å¦‚ä½•æ±‚å¯¼ï¼Ÿ åˆ¤æ–­å¯¼æ•°æ˜¯å¦ä¸º0 æœ‰ä¸¤ç§æ–¹å¼ï¼Œä¸€ç§æ˜¯ä»¤å¯¼æ•°ä¸º0ï¼›å¦ä¸€ç§æ˜¯åˆ¤æ–­ä¸€é˜¶å¯¼æ•°åœ¨è¯¥ç‚¹å·¦å³ä¸¤ä¸ªå¯¼æ•°çš„ç¬¦å·ï¼Œå¦‚æžœç¬¦å·ç›¸åï¼Œé‚£ä¹ˆè¯¥ç‚¹å¯¼æ•°ä¸º0. å¯¹äºŽL1ï¼Œå°±æ˜¯ä½¿ç”¨è¿™ç§æ–¹å¼è¿›è¡Œæ±‚å¯¼ã€‚è¿™ä¸ªé“¾æŽ¥ è§£é‡Šä»Žå¯¼æ•°è¿™ä¸ªè§’åº¦è§£é‡Šäº†ä¸ºä»€ä¹ˆL1 æ˜¯å®¹æ˜“äº§ç”Ÿç¨€ç–è§£ï¼Œæ˜¯å› ä¸ºåœ¨0 ç‚¹äº§ç”Ÿäº†æžå€¼ç‚¹ã€‚å¯¹äºŽL1 å’ŒL2 çš„ä¸€ç§è§£è¯»æ–¹å¼ï¼ŒL1æ˜¯æ¥è‡ªæ‹‰æ™®æ‹‰æ–¯åˆ†å¸ƒï¼ŒL2 æ˜¯æ¥è‡ªæ­£å¤ªåˆ†å¸ƒã€‚ è¿‡æ‹Ÿåˆé—®é¢˜å¯ä»¥ä»Žæ•°æ®å’Œæ¨¡åž‹ä¸¤æ–¹é¢è¿›è¡Œè€ƒè™‘ã€‚(1 )æ•°æ®è§’åº¦ï¼Œä½¿ç”¨æ›´å¤šçš„æ•°æ®é›† (2 ) æ¨¡åž‹åˆ†æˆèŠ‚ç‚¹å’Œè¿žçº¿(weights) ä¸¤éƒ¨åˆ†ã€‚dropout éšæœºå‡å°‘äº†ç½‘ç»œä¸­çš„èŠ‚ç‚¹ï¼Œå‡å°‘ç½‘ç»œå¤æ‚ç¨‹åº¦ï¼› æ­£åˆ™åŒ–å¯æœ‰ä½œç”¨äºŽweightsï¼Œå¯ä»¥ä½œç”¨äºŽè®­ç»ƒæ•°æ®é›†ï¼Œå‡å°‘äº†noiseï¼Œéƒ½æ˜¯ä½¿å¾—ç³»æ•°æ›´åŠ â€å…‰æ»‘â€œã€‚]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>l1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LightGBMå’ŒXGBooståŠå…¶è°ƒå‚]]></title>
    <url>%2F2018%2F07%2F21%2FLightGBM%E5%92%8CXGBoost%E5%8F%8A%E5%85%B6%E8%B0%83%E5%8F%82%2F</url>
    <content type="text"><![CDATA[å…ˆä¸»è¦ä»‹ç»æ ‘çš„åŸºæœ¬çŸ¥è¯†ï¼Œç„¶åŽä»‹ç»LightGBMå’ŒXGBooståŠå…¶è°ƒå‚. è¿›å…¥æ­£æ–‡ä¹‹å‰ç®€å•çš„è¯´ä¸€ä¸‹å†³ç­–æ ‘ã€‚ä¸€æ£µæ ‘å¾ˆå®¹æ˜“è¿‡æ‹Ÿåˆæˆ–è€…æ¬ æ‹Ÿåˆï¼ˆæ ¹æ®æ ‘çš„æ·±åº¦ï¼‰ï¼Œç„¶åŽéœ€è¦ä½¿ç”¨å¤šæ£µæ ‘è¿›è¡Œç»„åˆé¢„æµ‹ï¼Œè€ŒGBDTæ˜¯å®žçŽ°è¿™ä¸ªæ‰‹æ®µçš„æ–¹å¼ä¹‹ä¸€ã€‚sklearnä¸­ä¹Ÿæ˜¯å®žçŽ°äº† GBDT è¿™ç§æ€æƒ³ï¼Œä½†æ˜¯æ¯”è¾ƒéš¾ç”¨ï¼Œè®­ç»ƒé€Ÿåº¦è·Ÿä¸ä¸Šã€‚ä½†æ˜¯ lightGBM å’ŒXGBoost å®žçŽ°çš„æ•ˆæžœå°±æ¯”è¾ƒå¥½ã€‚ lightGBMè°ƒå‚(å¸¸ç”¨å‚æ•°)Since lightGBM is based on decision tree algorithms, it splits the tree with the best fit whereas boosting algorithms split the tree depth wise or level wise rather than leaf-wise. So when growing on the same leaf in Light GBM, the leaf-wise algorithm can reduce more loss than the level-wise algorithm and hence results in much better accuracy which can rarely be achieved by any of the existing boosting algorithms. Also, it is surprisingly very fast, hence the word â€˜Lightâ€™. Leaf wise splits lead to increase in complexity and may lead to overfitting and it can be overcome by specifying another parameter max_depth parameter. Advantages of LightGBM faster training speed and higher efficiencyLight GBM use histogram based algorithm i.e it buckets continuous feature values into discrete bins which fasten the training procedure. lower memory usageReplaces continuous values to discrete bins which result in lower memory usage. better accuracy than any other boosting algorithmIt produces much more complex trees by following leaf wise split approach rather than a level-wise approach which is the main factor in achieving higher accuracy. compatibility with large datasetsIt is capable of performing equally good with large datasets with a significant reduction in training time as compared to XGBOOST. parallel learning supported lightGBMè°ƒå‚(å¸¸ç”¨å‚æ•°) taskdefault= train, option: train, prediction applicationdefault= regression, option: regression, binary, multiclass, lambdarank(lambdarank application) datatraining data, è¿™ä¸ªæ¯”è¾ƒè¯¡å¼‚ï¼Œä½ éœ€è¦åˆ›å»ºä¸€ä¸ªlightGBMç±»åž‹çš„data num_iterationsdefault =100, å¯ä»¥è®¾ç½®ä¸ºçš„å¤§ä¸€äº›ï¼Œç„¶åŽä½¿ç”¨early_stoppingè¿›è¡Œè°ƒèŠ‚ã€‚ early_stopping_rounddefault =0, will stop training if one metric of one validation data doesnâ€™t improve in last early_stopping_round rounds. num_leavesdefault =31, number of leaves in a tree devicedefault =cpu, options: gpu, cpu, choose gpu for faster training. max_depthspecify the max depth to which tree will grow, which is very important. feature_fractiondefault =1, specifies the fraction of features to be taken for each iteration. bagging_fractiondefault =1, spefifies the fraction of data to be used for each iteration and it generally used to speed up the training and avoid overfitting. max_binmax number of bins to bucket the feature values.å› ä¸ºæ¨¡åž‹æ˜¯åŸºäºŽbinè®­ç»ƒçš„ï¼Œå¦‚æžœbin æ•°é‡è¶Šå¤šï¼Œå¾—åˆ°better accuracy,åŒæ—¶æ›´åŠ å®¹æ˜“ overfitting. num_threads labelspecify the label columns. categorical_featurespecify the categorical features num_classdefault =1, used only for multi-class classification referrencewhich-algorithm-takes-the-crown-light-gbm-vs-xgboostLightGBM å¦‚ä½•è°ƒå‚å®˜æ–¹æ–‡æ¡£param_tuningå®˜æ–¹æ–‡æ¡£parameter XGBoostè°ƒå‚Advantage of XGBoost regularizationstandard GBM implementation has no regularization, in fact, XGBoost is also known as â€˜regularized boostingâ€™ technique. parallel processingwe know that boosting is sequential process so how can it be parallelized? this link to explore further. high flexibilityXGBoost allow users to define custom optimization objectives and evaluation criteria handling missing valuesvery useful property. XGBoost has an in-built routine to handle missing values. User is required to supply a different value than other observations and pass that as a parameter. XGBoost tries different things as it encounter a missing value on each node and learns which path to take for missing values in future. Tree pruningA GBM would stop splitting a node when it encounters a negative loss in the split. Thus it is more of a greedy algorithm. XGBoost on the other hand make splits upon the max_depth specified and then start pruning the tree backwards and remove splits beyond which there is no positive gain. built-in cross-validationThis is unlike GBM where we have to run a grid-search and only a limited values can be tested. continue on existing model XGBoost Parametersgeneral parametersGeneral Parameters: Guide the overall functioning booster:default =gbtree, can be gbtree, gblinear or dart. ä¸€èˆ¬ä½¿ç”¨gbtree. silent:default =0, silent mode is activated if set to 1(no running messages will be printed) nthread:default to maximum of threads. booster parametersBooster Parameters: Guide the individual booster (tree/regression) at each step eta(learning rate):default=0.3, typical final values to be used: 0.01-0.2, using CV to tune min_child_weight:minimum sum of instance weight (hessian) needed in a child. If the tree partition step results in a leaf node with the sum of instance weight less than min_child_weight, then the building process will give up further partitioning. In linear regression mode, this simply corresponds to minimum number of instances needed to be in each node. The larger, the more conservative the algorithm will be.default =1,too high values can lead to under-fitting, it should be tuned using CV. æ•°å€¼è¶Šå°è¶Šå®¹æ˜“è¿‡æ‹Ÿåˆï¼Œè¶Šå¤§è¶Šå®¹æ˜“ under-fitting. max_depth:default =6, typical values: 3-10, should be tuned using CV. gamma:default =0, Gamma specifies the minimum loss reduction required to make a split.å¦‚æžœåœ¨åˆ†è£‚è¿‡ç¨‹ä¸­å°äºŽè¯¥å€¼ï¼Œé‚£ä¹ˆå°±ä¸ä¼šç»§ç»­åˆ†è£‚ã€‚ subsample:default =1, typical values: 0.5-1. Denotes the fraction of observations to be randomly samples for each tree. colsample_bytree:default =1, typical values: 0.5-1. colsample_bytreeå’Œsubsampleä¸åŒç‚¹ï¼šcolsample_byæ˜¯ç‰¹å¾çš„éšæœºfraction, subsampleæ˜¯rowsçš„éšæœºfractionã€‚ lambda:default =1, L2 regularization term on weights(analogous to Ridge regression). Though many data scientists donâ€™t use it often, it should be explored to reduce overfitting. alpha:default =0, L1 regularization term on weight (analogous to Lasso regression) scale_pos_weight:default =1, a value greater than 0 should be used in case of high class imbalance as it helps in faster convergence. learning task parametersLearning Task Parameters: Guide the optimization performed objectivebinary: logistic- returns predicated probability(not class)multi: softmax- returns predicated class(not probabilities)multi: softprob- returns predicated probability of each data point belonging to each class. eval_metircdefault according to objective(rmse for regression and error for classification), used for validation data.typical values: rmse(root mean square error), mse(mean absolute error), logloss(negative log-likelihood), error(binary classification error rate, 0.5 threshold), auc(area under the curve) seeddefault =0, used for reproducible results and also for parameter tuning. Control OverfittingThere are in general two ways that you can control overfitting in xgboost. The first way is to directly control model complexity. The second way is to add regularization parameters Referrencecomplete guide parameter tuning xgboost with codes pythonå®˜æ–¹æ–‡æ¡£ param_tuningå®˜æ–¹æ–‡æ¡£ parameter è¡¥å……ä¸€äº›ç†è®ºçŸ¥è¯† LightGBM å’Œ XGBoost çš„ä¸€äº›åŒºåˆ« æ ‘çš„å¢žé•¿æ–¹å¼ è¿™ä¸ªåŽŸå…ˆæ˜¯lightGBMæ‰€ç‰¹æœ‰çš„ï¼Œç„¶åŽxgboost åœ¨æœ€æ–°çš„ç‰ˆæœ¬ä¸Šä¹Ÿå®žçŽ°è¯¥ä¸­æ–¹å¼ï¼Œè¿™ä¼°è®¡å°±æ˜¯å¼€æºï¼Œå¹¶ä¸æ˜¯ä¸€æˆä¸å˜çš„ã€‚ä¸¤è€…éƒ½æ˜¯åŸºäºŽå¶å­è¿›è¡Œå¢žé•¿çš„ï¼Œä½†æ˜¯å¢žé•¿çš„æ–¹å¼æ˜¯ä¸åŒçš„ã€‚ä¸€ç§æ˜¯ level-wise ä¸€ç§æ˜¯ leaf-wiseboth xgboost and lightGBM use the leaf-wise growth strategy when growing the decision tree.there are two strategies that can be employed: level-wise and leaf-wise. level-wise maintains a balanced treeï¼ˆå¹³è¡¡æ ‘ï¼Œå·¦å³å­æ ‘çš„é«˜åº¦å·®ä¸è¶…è¿‡1ï¼‰;ä½†æ˜¯ leaf-wise è¿™ä¸ªå°±æ¯”è¾ƒéšæ„äº†ã€‚è¿™ä¸ªæ˜¯è¿™ä¸¤è€…çš„åŒºåˆ«ï¼šå½“å¶å­æ€»æ•°ç›¸åŒçš„æ—¶å€™ï¼Œleaf-wise è¿™ç§ç”Ÿé•¿æ–¹å¼å¾—åˆ°çš„æ ‘çš„æ·±åº¦æ˜¯å¤§äºŽ level-wise çš„æ·±åº¦çš„ã€‚Compared to the case of level-wise growth, a tree grown with leaf-wise growth will be deeper when the number of leaves is the same. find the best split The key challenge in training a GBDT is the process of finding the best split for each leaf. The computational complexity is thus $O \left( n _ { \text {data} } n _ { \text {features} } \right)$.è¿™ä¸¤è€…é‡‡ç”¨çš„æ–¹å¼éƒ½æ˜¯ï¼šçŽ°é˜¶æ®µçš„ä¸­çš„çš„æ•°æ® æ•°æ®é‡å’Œç‰¹å¾é‡éƒ½æ˜¯å¾ˆå¤§çš„ï¼Œæ‰€ä»¥è¿™ç§æ–¹å¼æ˜¯ä¸å¯å–çš„ã€‚ç„¶åŽè¿™ä¸¤ç§æ–¹æ³•éƒ½æ˜¯é‡‡ç”¨äº† Histogram-based methodsï¼Œè¿™æ ·æœ€åŽçš„æ—¶é—´å¤æ‚åº¦é™ä½Žåˆ°ï¼šreducing the computational complexity to $O \left( n _ { d a t a } n _ { b i n s } \right)$. è¿™ä¸ªå¤æ‚åº¦æ˜¯å–å†³äºŽnumber of binsã€‚è¿™ä¸ªæ˜¯å¼•å…¥äº†ä¸€ä¸ªè¶…å‚æ•°ï¼Œnumber of bins ï¼Œtrade off between precision and time, å½“æ›´å¤šçš„ bins çš„æ—¶å€™ï¼Œè¿™ä¸ªprecision ä¼šæé«˜ï¼Œä½†æ˜¯ time ä¹Ÿä¼šå¢žå¤§ã€‚ Ignoring sparse inputs è¿™ä¸ªæ˜¯å¤„ç†ç¼ºçœå€¼ï¼ˆæˆ–è€… 0ï¼‰çš„æ‰‹æ®µï¼šä¸¤è€…åœ¨split åˆ†è£‚ç‚¹çš„æ—¶å€™ï¼Œéƒ½æ˜¯å…ˆä¸å¤„ç†æ•°å€¼ 0ï¼›ç„¶åŽæ‰¾åˆ°åˆ†è£‚ç‚¹ä¹‹åŽï¼ŒæŠŠ0 æ”¾åˆ°å“ªè¾¹é€ æˆçš„loss ä¸‹é™çš„æ¯”è¾ƒå¤§ï¼Œç„¶åŽå°±æ”¾åˆ°å“ªè¾¹ã€‚ Subsampling the data: Gradient-based One-Side Sampling (lightGBM)biased sampling(æŠ½æ ·çš„åŸºæœ¬åŽŸåˆ™æ˜¯éšæœºæ€§ï¼Œä½†æ˜¯åœ¨æŠ½æ ·è¿‡ç¨‹ä¸­ç”±äºŽä¸€ç³»åˆ—å› ç´ é€ æˆåå·®æŠ½æ ·ï¼Œé€ æˆæ ·æœ¬æ˜¯ä¸ç¬¦åˆçœŸå®žæ ·æœ¬çš„åˆ†å¸ƒ)è¿™ä¸ªå°±æ˜¯ç¼“è§£ï¼Œä¹Ÿä¸æ˜¯ä¸ºäº†å½»åº•è®©å…¶å‡è¡¡ï¼Œlightgbm increases the weigths of the samples.This means that it is more efficient to concentrate on data points with larger gradients.In order to mitigate this problem, lightGBM also randomly samples from data with small gradients.lightGBM increases the weight of the samples with small gradients when computing their contribution to the change in loss (this is a form of importance sampling, a technique for efficient sampling from an arbitrary distribution). xgboost + lrå¦‚æžœæ¸…æ¥šGBDTåŽŸç†çš„è¯ï¼ˆæœºå™¨å­¦ä¹ -ä¸€æ–‡ç†è§£GBDTçš„åŽŸç†-20171001ï¼‰ï¼Œæœ€åŽæ¨¡åž‹é¢„æµ‹ç»“æžœä¹Ÿæ˜¯å°†å¶å­ç»“ç‚¹è¿›è¡Œçº¿æ€§åŠ æ€»ï¼Œæƒå€¼å°±æ˜¯è®­ç»ƒå¾—åˆ°çš„å„å¶å­ç»“ç‚¹çš„æƒé‡ã€‚å¦‚æžœå°†GBDTå¾—åˆ°çš„å¶å­èŠ‚ç‚¹ç‰¹å¾å–‚å…¥LRçš„è¯ï¼Œå…¶å®žç›¸å½“äºŽç”¨é€»è¾‘å›žå½’å¯¹å¶å­ç»“ç‚¹çš„æƒé‡è¿›è¡Œäº†é‡æ–°è®­ç»ƒè®¡ç®—ï¼Œåœ¨è¿™é‡ŒGBDTåªæ˜¯å°†æ•°æ®ä¸­çš„éžçº¿æ€§å…³ç³»è¿›è¡Œäº†ä¸€å±‚è½¬æ¢ï¼Œä»Žè€Œå¯ä»¥åˆ©ç”¨lrè¿›è¡Œçº¿æ€§ç»„åˆã€‚ é™¤äº†åŽŸç†å’Œå®žçŽ°æ–¹å¼ä¹‹å¤–ï¼Œå…¶å®žè¿˜æœ‰ä¸€äº›å°çš„ç»†èŠ‚éœ€è¦æ³¨æ„çš„ï¼Œæ¯”å¦‚ï¼š 1ã€è¿›è¡ŒLRè®­ç»ƒæ—¶ï¼ŒåŽŸå§‹ç‰¹å¾æ˜¯å¦è¦åŠ è¿›åŽ»ï¼›åŽŸå§‹ç‰¹å¾çš„åŠ å…¥åœ¨xgbæ¬ æ‹Ÿåˆçš„æ—¶å€™èµ·çš„ä½œç”¨æ›´å¤§ï¼Œå½“xgbæ ‘çš„é¢—æ•°ä¸Šå‡åˆ°ä¸€å®šæ•°é‡æ—¶ï¼ŒåŽŸå§‹ç‰¹å¾çš„åŠ å…¥æ²¡ä»€ä¹ˆæå‡ã€‚2ã€gbdtè®­ç»ƒçš„æ¨¡åž‹æ•ˆæžœå¯¹æœ€ç»ˆLRçš„è®­ç»ƒå‡ºæ¥çš„æ¨¡åž‹æœ‰å¤šå¤§çš„å½±å“ï¼› å½“xgbè®­ç»ƒå……åˆ†æ—¶ï¼Œlrç›´æŽ¥åˆ©ç”¨xgbå¶å­ç»“ç‚¹çš„ç¼–ç ç‰¹å¾åœ¨åˆé€‚çš„æƒ©ç½šç³»æ•°ä¸‹å¯ä»¥è®­ç»ƒå¾—åˆ°å’Œxgbä¸€æ ·çš„ç”šè‡³æ›´å¥½çš„æ•ˆæžœï¼ˆä¸æ˜¾è‘—ï¼‰ï¼› 3ã€æ ‘çš„æ£µæ•°ï¼Œå¶å­ç»“ç‚¹æ•°ï¼Œå­¦ä¹ çŽ‡ï¼Œæ ‘çš„æ·±åº¦ï¼Œé‡‡æ ·ä¼šå¦‚ä½•å½±å“æœ€ç»ˆçš„æ¨¡åž‹æ•ˆæžœç­‰ç­‰ï¼› lråˆ©ç”¨xgbå¶å­ç»“ç‚¹çš„ç¼–ç ç‰¹å¾è¿›è¡Œè®­ç»ƒï¼Œåˆ†åˆ«åœ¨ä¸åŒçš„Cä¸‹è®­ç»ƒå¾—åˆ°trainå’Œtestçš„aucå€¼ ç®€å•åœ°è¯´ï¼Œå°±æ˜¯æŠŠgbdtçš„è¾“å‡ºï¼Œä½œä¸ºlogistic regressionçš„è¾“å…¥ï¼Œæœ€åŽå¾—åˆ°ä¸€ä¸ªlogistic regressionæ¨¡åž‹ã€‚ä¾‹å¦‚ï¼Œgbdté‡Œæœ‰3æ£µæ ‘T1,T2,T3ï¼Œæ¯æ£µæ ‘çš„å¶èŠ‚ç‚¹ä¸ªæ•°ä¸º4ï¼Œç¬¬iä¸ªæ ‘çš„ç¬¬jä¸ªå¶èŠ‚ç‚¹æ˜¯Li,jã€‚å½“gdbtè®­ç»ƒå®Œæˆä¹‹åŽï¼Œæ ·æœ¬X1åœ¨ç¬¬ä¸€æ£µæ ‘ä¸­è¢«åˆ†åˆ°äº†ç¬¬3ä¸ªå¶èŠ‚ç‚¹ä¸Šï¼Œä¹Ÿå°±æ˜¯L1,3ï¼Œé‚£ä¹ˆè¿™ä¸ªæ ·æœ¬åœ¨T1ä¸Šçš„å‘é‡è¡¨è¾¾ä¸º(0,0,1,0)ã€‚ æ ·æœ¬X1åœ¨T2è¢«åˆ†åˆ°äº†L2,1ï¼Œé‚£ä¹ˆX1åœ¨T2ä¸Šçš„å‘é‡è¡¨è¾¾ä¸º(1,0,0,0)æ ·æœ¬X1åœ¨T3è¢«åˆ†åˆ°äº†L3,4ï¼Œé‚£ä¹ˆX1åœ¨T3ä¸Šçš„å‘é‡è¡¨è¾¾ä¸º(0,0,0,1)é‚£ä¹ˆX1åœ¨æ•´ä¸ªgbdtä¸Šçš„å‘é‡è¡¨è¾¾ä¸º (0,0,1,0,1,0,0,0,0,0,0,1)æ‰€ä»¥æ¯ä¸ªæ ·æœ¬éƒ½ä¼šè¢«è¡¨ç¤ºä¸ºä¸€ä¸ªé•¿åº¦ä¸º12çš„0-1å‘é‡ï¼Œå…¶ä¸­æœ‰3ä¸ªæ•°å€¼æ˜¯1ã€‚ ç„¶åŽè¿™ç±»å‘é‡å°±æ˜¯LRæ¨¡åž‹çš„è¾“å…¥æ•°æ®ã€‚ LR å’Œ XGOOST æ˜¯ CTR ä¸­å¸¸ç”¨çš„ä¸¤ç§æ¨¡åž‹ï¼ŒäºŒè€…å„æœ‰ä¼˜ç¼ºç‚¹ï¼Œåœ¨ facebook ä¸­ä½¿ç”¨ XGBOOSTï¼ˆæå–ç‰¹å¾ï¼‰ + LRï¼ˆé¢„æµ‹ï¼‰ çš„æ–¹å¼ã€‚GBDT æ¨¡åž‹æ“…é•¿å¤„ç†è¿žç»­ç‰¹å¾å€¼ï¼Œè€Œ LR åˆ™æ“…é•¿å¤„ç†ç¦»æ•£ç‰¹å¾å€¼ã€‚ åœ¨å·¥ä¸šç•Œï¼Œå¾ˆå°‘ç›´æŽ¥å°†è¿žç»­å€¼ä½œä¸ºç‰¹å¾å–‚ç»™é€»è¾‘å›žå½’æ¨¡åž‹ï¼Œè€Œæ˜¯å°†è¿žç»­ç‰¹å¾ç¦»æ•£åŒ–ä¸ºä¸€ç³»åˆ—0ã€1ç‰¹å¾äº¤ç»™é€»è¾‘å›žå½’æ¨¡åž‹ï¼Œè¿™æ ·åšçš„ä¼˜åŠ¿æœ‰ä»¥ä¸‹å‡ ç‚¹ï¼š 123451.ç¨€ç–å‘é‡å†…ç§¯ä¹˜æ³•è¿ç®—é€Ÿåº¦å¿«ï¼Œè®¡ç®—ç»“æžœæ–¹ä¾¿å­˜å‚¨ï¼Œå®¹æ˜“scalableï¼ˆæ‰©å±•ï¼‰ã€‚2.ç¦»æ•£åŒ–åŽçš„ç‰¹å¾å¯¹å¼‚å¸¸æ•°æ®æœ‰å¾ˆå¼ºçš„é²æ£’æ€§ï¼šæ¯”å¦‚ä¸€ä¸ªç‰¹å¾æ˜¯å¹´é¾„&gt;30æ˜¯1ï¼Œå¦åˆ™0ã€‚å¦‚æžœç‰¹å¾æ²¡æœ‰ç¦»æ•£åŒ–ï¼Œä¸€ä¸ªå¼‚å¸¸æ•°æ®â€œå¹´é¾„300å²â€ä¼šç»™æ¨¡åž‹é€ æˆå¾ˆå¤§çš„å¹²æ‰°ã€‚3.é€»è¾‘å›žå½’å±žäºŽå¹¿ä¹‰çº¿æ€§æ¨¡åž‹ï¼Œè¡¨è¾¾èƒ½åŠ›å—é™ï¼›å•å˜é‡ç¦»æ•£åŒ–ä¸ºNä¸ªåŽï¼Œæ¯ä¸ªå˜é‡æœ‰å•ç‹¬çš„æƒé‡ï¼Œç›¸å½“äºŽä¸ºæ¨¡åž‹å¼•å…¥äº†éžçº¿æ€§ï¼Œèƒ½å¤Ÿæå‡æ¨¡åž‹è¡¨è¾¾èƒ½åŠ›ï¼ŒåŠ å¤§æ‹Ÿåˆã€‚4.ç¦»æ•£åŒ–åŽå¯ä»¥è¿›è¡Œç‰¹å¾äº¤å‰ï¼Œç”±M+Nä¸ªå˜é‡å˜ä¸ºM*Nä¸ªå˜é‡ï¼Œè¿›ä¸€æ­¥å¼•å…¥éžçº¿æ€§ï¼Œæå‡è¡¨è¾¾èƒ½åŠ›ã€‚5.ç‰¹å¾ç¦»æ•£åŒ–åŽï¼Œæ¨¡åž‹ä¼šæ›´ç¨³å®šï¼Œæ¯”å¦‚å¦‚æžœå¯¹ç”¨æˆ·å¹´é¾„ç¦»æ•£åŒ–ï¼Œ20-30ä½œä¸ºä¸€ä¸ªåŒºé—´ï¼Œä¸ä¼šå› ä¸ºä¸€ä¸ªç”¨æˆ·å¹´é¾„é•¿äº†ä¸€å²å°±å˜æˆä¸€ä¸ªå®Œå…¨ä¸åŒçš„äººã€‚å½“ç„¶å¤„äºŽåŒºé—´ç›¸é‚»å¤„çš„æ ·æœ¬ä¼šåˆšå¥½ç›¸åï¼Œæ‰€ä»¥æ€Žä¹ˆåˆ’åˆ†åŒºé—´æ˜¯é—¨å­¦é—®ã€‚ å…ˆç”¨å·²æœ‰ç‰¹å¾è®­ç»ƒXgboostæ¨¡åž‹ï¼Œç„¶åŽåˆ©ç”¨Xgboostæ¨¡åž‹å­¦ä¹ åˆ°çš„æ ‘æ¥æž„é€ æ–°ç‰¹å¾ï¼Œæœ€åŽæŠŠè¿™äº›æ–°ç‰¹å¾åŠ å…¥åŽŸæœ‰ç‰¹å¾ä¸€èµ·è®­ç»ƒæ¨¡åž‹ã€‚æž„é€ çš„æ–°ç‰¹å¾å‘é‡æ˜¯å–å€¼0/1çš„ï¼Œå‘é‡çš„æ¯ä¸ªå…ƒç´ å¯¹åº”äºŽXgboostæ¨¡åž‹ä¸­æ ‘çš„å¶å­ç»“ç‚¹ã€‚å½“ä¸€ä¸ªæ ·æœ¬ç‚¹é€šè¿‡æŸæ£µæ ‘æœ€ç»ˆè½åœ¨è¿™æ£µæ ‘çš„ä¸€ä¸ªå¶å­ç»“ç‚¹ä¸Šï¼Œé‚£ä¹ˆåœ¨æ–°ç‰¹å¾å‘é‡ä¸­è¿™ä¸ªå¶å­ç»“ç‚¹å¯¹åº”çš„å…ƒç´ å€¼ä¸º1ï¼Œè€Œè¿™æ£µæ ‘çš„å…¶ä»–å¶å­ç»“ç‚¹å¯¹åº”çš„å…ƒç´ å€¼ä¸º0ã€‚æ–°ç‰¹å¾å‘é‡çš„é•¿åº¦ç­‰äºŽXGBoostæ¨¡åž‹é‡Œæ‰€æœ‰æ ‘åŒ…å«çš„å¶å­ç»“ç‚¹æ•°ä¹‹å’Œã€‚æœ€åŽå°†æ–°çš„ç‰¹å¾æ‰”åˆ°LRæ¨¡åž‹è¿›è¡Œè®­ç»ƒã€‚ xgboost+lræ¨¡åž‹èžåˆæ–¹æ³•ç”¨äºŽåˆ†ç±»æˆ–è€…å›žå½’çš„æ€æƒ³æœ€æ—©ç”±facebookåœ¨å¹¿å‘Šctré¢„æµ‹ä¸­æå‡ºï¼Œå…¶è®ºæ–‡Practical Lessons from Predicting Clicks on Ads at Facebookæœ‰å¯¹å…¶è¿›è¡Œé˜è¿°ã€‚åœ¨è¿™ç¯‡è®ºæ–‡ä¸­ä»–ä»¬æå‡ºäº†ä¸€ç§å°†xgboostä½œä¸ºfeature transformçš„æ–¹æ³•ã€‚å¤§æ¦‚çš„æ€æƒ³å¯ä»¥æè¿°ä¸ºå¦‚ä¸‹ï¼šå…ˆç”¨å·²æœ‰ç‰¹å¾è®­ç»ƒXGBoostæ¨¡åž‹ï¼Œç„¶åŽåˆ©ç”¨XGBoostæ¨¡åž‹å­¦ä¹ åˆ°çš„æ ‘æ¥æž„é€ æ–°ç‰¹å¾ï¼Œæœ€åŽæŠŠè¿™äº›æ–°ç‰¹å¾åŠ å…¥åŽŸæœ‰ç‰¹å¾ä¸€èµ·è®­ç»ƒæ¨¡åž‹ã€‚æž„é€ çš„æ–°ç‰¹å¾å‘é‡æ˜¯å–å€¼0/1çš„ï¼Œå‘é‡çš„æ¯ä¸ªå…ƒç´ å¯¹åº”äºŽXGBoostæ¨¡åž‹ä¸­æ ‘çš„å¶å­ç»“ç‚¹ã€‚å½“ä¸€ä¸ªæ ·æœ¬ç‚¹é€šè¿‡æŸæ£µæ ‘æœ€ç»ˆè½åœ¨è¿™æ£µæ ‘çš„ä¸€ä¸ªå¶å­ç»“ç‚¹ä¸Šï¼Œé‚£ä¹ˆåœ¨æ–°ç‰¹å¾å‘é‡ä¸­è¿™ä¸ªå¶å­ç»“ç‚¹å¯¹åº”çš„å…ƒç´ å€¼ä¸º1ï¼Œè€Œè¿™æ£µæ ‘çš„å…¶ä»–å¶å­ç»“ç‚¹å¯¹åº”çš„å…ƒç´ å€¼ä¸º0ã€‚æ–°ç‰¹å¾å‘é‡çš„é•¿åº¦ç­‰äºŽXGBoostæ¨¡åž‹é‡Œæ‰€æœ‰æ ‘åŒ…å«çš„å¶å­ç»“ç‚¹æ•°ä¹‹å’Œã€‚æœ€åŽå°†æ–°çš„ç‰¹å¾æ‰”åˆ°LRæ¨¡åž‹è¿›è¡Œè®­ç»ƒã€‚å®žéªŒç»“æžœè¡¨æ˜Žxgboost+lrèƒ½å–å¾—æ¯”å•ç‹¬ä½¿ç”¨ä¸¤ä¸ªæ¨¡åž‹éƒ½å¥½çš„æ•ˆæžœã€‚ å®žçŽ°è§’åº¦ åœ¨å®žè·µä¸­çš„å…³é”®ç‚¹æ˜¯å¦‚ä½•èŽ·å¾—æ¯ä¸ªæ ·æœ¬è½åœ¨è®­ç»ƒåŽçš„æ¯æ£µæ ‘çš„å“ªä¸ªå¶å­ç»“ç‚¹ä¸Šã€‚ Aã€å¯¹äºŽXgboostæ¥è¯´ï¼Œå› ä¸ºå…¶æœ‰sklearnæŽ¥å£å’Œè‡ªå¸¦æŽ¥å£ï¼Œå› æ­¤æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥èŽ·å¾—ï¼š â‘ ã€sklearnæŽ¥å£ã€‚å¯ä»¥è®¾ç½®pre_leaf=TrueèŽ·å¾—æ¯ä¸ªæ ·æœ¬åœ¨æ¯é¢—æ ‘ä¸Šçš„leaf_Indexã€‚XGBoostå®˜æ–¹æ–‡æ¡£ â‘¡ã€è‡ªå¸¦æŽ¥å£ã€‚åˆ©ç”¨apply()æ–¹æ³•å¯ä»¥èŽ·å¾—leaf indicesã€‚SKlearn GBDT API ï¼ï¼ï¼æ­¤è¿‡ç¨‹éœ€æ³¨æ„ï¼š æ— è®ºæ˜¯è®¾ç½®pre_leaf=Trueè¿˜æ˜¯åˆ©ç”¨apply()æ–¹æ³•ï¼ŒèŽ·å¾—çš„éƒ½æ˜¯å¶å­èŠ‚ç‚¹çš„ indexï¼Œä¹Ÿå°±æ˜¯è¯´è½åœ¨äº†å…·ä½“å“ªé¢—æ ‘çš„å“ªä¸ªå¶å­èŠ‚ç‚¹ä¸Šï¼Œå¹¶éžæ˜¯0/1å˜é‡ï¼Œå› æ­¤éœ€è¦è‡ªå·±åŠ¨æ‰‹åŽ»åš onehot ç¼–ç ã€‚onehot å¯ä»¥åœ¨ sklearn çš„é¢„å¤„ç†åŒ…ä¸­è°ƒç”¨å³å¯ã€‚ onehotçš„çŸ¥è¯†ç‚¹å¯ä»¥å‚çœ‹è¿™ç¯‡åšå®¢ã€‚ Bã€å¯¹äºŽå…¶å®ƒçš„æ ‘æ¨¡åž‹ï¼Œå¦‚éšæœºæ£®æž—å’ŒGBDTï¼Œæˆ‘ä»¬åªèƒ½ä½¿ç”¨apply()æ–¹æ³•èŽ·å¾—leaf indicesã€‚ XGBoost+LRèžåˆçš„åŽŸç†å’Œç®€å•å®žçŽ°xgboostå’ŒLRæ¨¡åž‹çº§è” å¯¹äºŽåŽŸå§‹æ•°æ®çš„ç¼–ç æ–¹å¼ è¿žç»­ç‰¹å¾ç¦»æ•£åŒ– ç¦»æ•£çš„ç‰¹å¾one-hot æˆ–è€…ç‰¹å¾ç»„åˆ ä½¿ç”¨ boosting æ–¹å¼å°†è¿žç»­ç‰¹å¾ç¦»æ•£åŒ–ï¼ˆxgboost ç‰¹å¾æå–ï¼‰XGBoost + LR æ˜¯ä¸€ç§æœ‰æ•ˆçš„ç‰¹å¾å·¥ç¨‹æ‰‹æ®µ åˆ©ç”¨ GBDT+LR èžåˆçš„æ–¹æ¡ˆæœ‰å¾ˆå¤šå¥½å¤„ï¼Œåˆ©ç”¨ GDBT ä¸»è¦æ˜¯å‘æŽ˜æœ‰åŒºåˆ†åº¦çš„ ç‰¹å¾å’Œç‰¹å¾ç»„åˆï¼š LR æ¨¡åž‹æ— æ³•å®žçŽ°ç‰¹å¾ç»„åˆï¼Œä½†æ˜¯æ¨¡åž‹ä¸­ç‰¹å¾ç»„åˆå¾ˆå…³é”®ï¼Œä¾é äººå·¥ç»éªŒéžå¸¸è€—æ—¶è€Œä¸”ä¸ä¸€å®šèƒ½æœ‰å¥½çš„æ•ˆæžœã€‚åˆ©ç”¨ GBDT å¯ä»¥è‡ªåŠ¨å‘çŽ°æœ‰æ•ˆçš„ç‰¹å¾ã€ç‰¹å¾ç»„åˆã€‚GBDT æ¯æ¬¡è¿­ä»£éƒ½æ˜¯åœ¨å‡å°‘æ®‹å·®çš„æ¢¯åº¦æ–¹å‘ä¸Šé¢æ–°å»ºä¸€æ£µå†³ç­–æ ‘ï¼ŒGBDT çš„æ¯ä¸ªå¶å­ç»“ç‚¹å¯¹åº”ä¸€ä¸ªè·¯å¾„ï¼Œä¹Ÿå°±æ˜¯ä¸€ç§ç»„åˆæ–¹å¼ã€‚ ä¸ºè¿›ä¸€æ­¥ç†è§£GBDT-LRçš„è¿è¡Œè¿‡ç¨‹ï¼ŒåŒæ—¶æŽ’æŸ¥ç¼–ç¨‹å®žçŽ°çš„é”™è¯¯ã€‚è¿™é‡Œå¯¹æ•´ä¸ªè¿‡ç¨‹ä¸­çš„æ•°æ®å½¢æ€å˜åŒ–è¿›è¡Œæ£€è§†ã€‚æ•°æ®çš„å¤„ç†æµç¨‹ä¸ºï¼š åŽŸå§‹ç‰¹å¾æ•°æ® -&gt; æ ‡ç­¾ç¼–ç  -&gt; GBDT -&gt; ç‹¬çƒ­ç¼–ç  -&gt; LR -&gt; è¾“å‡ºã€‚ xgboostå’ŒLRæ¨¡åž‹çº§è” 12345æ›´æ–°ï¼šï¼šï¼šç»è¿‡å®žè·µæ£€éªŒåŽï¼Œæˆ‘ä»¬å‘çŽ°xgb+lrç›¸æ¯”xgbå‡ ä¹Žæ²¡æœ‰æå‡ã€‚xgbä¸åƒDNNï¼Œå…¶æœ¬èº«çš„ç‰¹å¾äº¤å‰èƒ½åŠ›æ˜¯æœ‰é™çš„ï¼Œç”¨xgbä½œä¸ºlrçš„ç‰¹å¾äº¤å‰éƒ¨åˆ†æ˜¯è¿œè¿œä¸å¤Ÿçš„ï¼Œæ‰€ä»¥è¿˜æ˜¯éœ€è¦åœ¨LRè¿™è¾¹åšå¤§é‡çš„äººå·¥ç‰¹å¾äº¤å‰è®¾è®¡ï¼Œæˆ‘ä»¬å½“æ—¶å¹¶æ²¡æœ‰ä¸€ä¸ªå®žè·µæ£€éªŒè¿‡å¾ˆå¥½çš„å•LRæ¨¡åž‹ï¼Œå› ä¸ºæˆ‘ä»¬æ²¡æœ‰æ—¶é—´å’ŒäººåŠ›åšç²¾ç»†çš„äººå·¥ç‰¹å¾äº¤å‰è®¾è®¡ã€‚å…¶å®žå½“äººå·¥çš„ç‰¹å¾è®¾è®¡è¶³å¤Ÿä¼˜ç§€çš„æ—¶å€™ï¼Œç‰¹å¾ç»´åº¦å¾ˆä¸°æ»¡çš„å•LRå·²ç»å¾ˆå¼ºäº†ï¼Œxgbé‚£ç‚¹å¶å­ç»“ç‚¹çš„å½±å“åŠ›å…¶å®žä¸å¤§ã€‚ä¸€ä¸ªå¥½çš„å•LRæ¨¡åž‹å…¶å®žæ ¹æœ¬ä¸å¤ªéœ€è¦xgbè¿™ç‚¹äº¤å‰ï¼Œä¸€ä¸ªå•xgbæ¨¡åž‹æœ¬èº«ä¹Ÿè¶³å¤Ÿä¼˜ç§€ï¼Œçº§è”ä¸€ä¸ªåžƒåœ¾LRä¸å¦‚ä¸çº§è”ã€‚ Facebookåœ¨2014å¹´çš„æ€è·¯æ˜¯æ²¡é”™çš„ï¼Œxgbèƒ½å¤Ÿå¾ˆå¥½çš„å¤„ç†è¿žç»­æ€§åž‹ç‰¹å¾ï¼ŒLRæ¥è¡¥é½xgbå¯¹ç¦»æ•£ç±»ç‰¹å¾ä¿¡æ¯çš„ç›²åŒºã€‚ä½†æ˜¯å·¥ç¨‹ä¸Šå¦‚æžœæƒ³æœ‰æå‡ï¼Œä¸å¯é¿å…è¿˜æ˜¯è¦åšç‰¹å¾å·¥ç¨‹ï¼Œè¦è¸©å¾—å‘å¤ªå¤šè€Œä¸”æ”¶ç›Šç”šå¾®ï¼Œæœ‰è¿™ä¸ªç²¾åŠ›ä¸å¦‚æžæ·±åº¦å­¦ä¹ ã€‚æƒ³è¦æœ‰è´¨å˜çš„è¯å»ºè®®ç›´æŽ¥ä¸Šæ·±åº¦å­¦ä¹ ï¼ŒWide&amp;Deepç”¨Deepéƒ¨åˆ†ä»£æ›¿xgbï¼ŒDNNçš„ç‰¹å¾äº¤å‰èƒ½åŠ›å’Œä¿¡æ¯é‡è¦æ¯”xgbå¤§å¾—å¤šã€‚ xgboost ç¡®å®žèƒ½å¤Ÿå¤„ç†è¿žç»­ç‰¹å¾ï¼Œä½†æ˜¯åœ¨ç‰¹å¾äº¤å‰æ–¹é¢ï¼Œè¿˜æ˜¯æœ‰ä¸è¶³çš„ï¼Œæ‰€ä»¥è¦ä¹ˆæ˜¯ç‰¹å¾å·¥ç¨‹ï¼Œå¢žå¼ºå¯¹ç¦»æ•£ç‰¹å¾LRã€‚è¦ä¹ˆæ˜¯æ·±åº¦ç½‘ç»œï¼Œ DNNï¼ˆæˆ–è€…transformerï¼‰çš„ç‰¹å¾äº¤å‰èƒ½åŠ›å’Œä¿¡æ¯é‡è¦æ¯”xgbå¤§å¾—å¤šã€‚xgboostä¹Ÿå°±æ˜¯åšäº†ç‰¹å¾ç­›é€‰å’Œç‰¹å¾äº¤å‰ã€‚äººå·¥ç‰¹å¾å·¥ç¨‹åšçš„å¤Ÿå¥½ï¼ŒLRæ˜¯å¯ä»¥ä¿¯çž°ä¼—ç”Ÿï¼Œä½†æ˜¯è€ƒè™‘åˆ°èŠ±è´¹çš„äººåŠ›ç‰©åŠ›ï¼Œè¿˜æ˜¯é€‰æ¨¡åž‹çº§è”å§ï¼ç‰¹å¾å·¥ç¨‹æ…¢æ…¢åš= = LRæ˜¯å¹¿ä¹‰çº¿æ€§æ¨¡åž‹ï¼Œèƒ½å¤Ÿå¹¶è¡ŒåŒ–å¤„ç†å¤§é‡äº¿ä¸‡çº§ç‰¹å¾çš„è®­ç»ƒæ ·æœ¬ã€‚LRæ¨¡åž‹æ˜¯åªä½¿ç”¨ç¦»æ•£åž‹ç‰¹å¾çš„ï¼Œè¿žç»­åž‹ç‰¹å¾ä¸æ˜¯ä¸èƒ½ç”¨ï¼Œè€Œæ˜¯ç”¨äº†ä»¥åŽæ•ˆæžœä¸å¥½ï¼Œå¯¹æ¨¡åž‹æœ‰è´Ÿå½±å“ã€‚LRå¿«é€Ÿé«˜æ•ˆï¼Œå®Œå…¨å¯ä»¥å¤„ç†é«˜çº¬åº¦ç¨€ç–çš„ç¦»æ•£åŒ–ç‰¹å¾ã€‚ å¤ä¹ ç¬”è®° xgboost çš„ä¼˜åŠ¿ (1) èƒ½å¤Ÿ handle missing values (2) æ•°çš„å¢žé•¿æ–¹å¼ï¼Œä¸€ç§æ˜¯åŸºäºŽlevel å¢žé•¿ï¼Œä¸€ç§æ˜¯åŸºäºŽå¶å­èŠ‚ç‚¹å¢žé•¿ï¼ˆå¦‚æžœæ˜¯ç›¸åŒçš„ç»“ç‚¹æ•°é‡ï¼Œé‚£ä¹ˆåŸºäºŽå¶å­å¢žé•¿çš„æ–¹å¼æ˜¯æ›´åŠ çš„æ·±ï¼‰ è°ƒå‚æ˜¯èƒ½å¤Ÿè°ƒæ•´çš„å‚æ•°ï¼ˆmax_depth, éšæœºæ ·æœ¬çš„æ¯”ä¾‹ï¼Œéšæœºç‰¹å¾çš„æ¯”ä¾‹ï¼‰ï¼Œä¸æ˜¯å¸¸è§çš„å‚æ•°ï¼ˆæ¯”å¦‚è¯´ ntthread çº¿ç¨‹æ•°é‡ï¼Œ silent ä¸Žå¦ï¼‰ã€‚]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>LightGBM</tag>
        <tag>XGBoost</tag>
        <tag>xgboost+lr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é‚£äº›å¹´çš„ç®—æ³•é¢˜ç›®ï¼ˆäºŒï¼‰]]></title>
    <url>%2F2018%2F07%2F21%2F%E9%82%A3%E4%BA%9B%E5%B9%B4%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[åˆ·é¢˜ç¬”è®°ï¼ˆäºŒï¼‰ æœ€é•¿å…¬å…±å­ä¸² ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸²Aå’ŒBï¼Œé•¿åº¦åˆ†åˆ«ä¸ºmå’Œnï¼Œè¦æ±‚æ‰¾å‡ºå®ƒä»¬æœ€é•¿çš„å…¬å…±å­ä¸²ï¼Œå¹¶è¿”å›žå…¶é•¿åº¦ã€‚ä¾‹å¦‚ï¼š 12A = &quot;HelloWorld&quot;B = &quot;loop&quot; ç¬¬ä¸€ç§åšæ³•æ˜¯æš´åŠ›æžšä¸¾ï¼Œ æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n^3)$ï¼› ç¬¬äºŒç§åšæ³•æ—¶é—´å¤æ‚åº¦ $O(n^2)$ï¼Œä½¿ç”¨dp çš„åšæ³•ã€‚é‚£ä¹ˆçŠ¶æ€è½¬ç§»æ–¹ç¨‹æ˜¯ $$ dp[i][j] = \begin{cases}0 &amp; str1[i-1] !=str2[j-1] \\dp[i-1][j-1] +1&amp; str1[i-1] ==str2[j-1]\end{cases}$$ æ³¨æ„å…¬å…±å­ä¸²ï¼Œè¦æ±‚çš„æ˜¯éœ€è¦è¿žç»­çš„ï¼Œæ‰€ä»¥å½“å‘çŽ°ä¸è¿žç»­çš„æ—¶å€™ï¼Œ $dp[i][j] =0$ åº”è¯¥æ˜¯è¿™æ ·çš„è€ƒè™‘ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;// è¿™ä¸ªæ˜¯æœ€åŸºç¡€çš„ç®—æ³•ï¼Œ ä½¿ç”¨æš´åŠ›æžšä¸¾ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ n^3string common_str(string &amp;str1, string &amp; str2)&#123; string res; int n =str1.size(), m =str2.size(); //ä¿è¯n&gt;= m if(n&lt; m) &#123; res =common_str(str2, str1); return res; &#125; int max_l =0; for(int i=0; i&lt;n; i++) &#123; for(int j =i+1; j&lt;n; j++) &#123; // start point , len string substr= str1.substr(i,j-i+1); if( str2.find(substr) != str2.npos) &#123; if(j -i+1 &gt; max_l) &#123; res =substr; max_l =j-i+1; &#125; &#125; &#125; &#125; return res;&#125;// ä½¿ç”¨äºŒç»´dp è¿›è¡Œä¼˜åŒ–ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯O(n^2) ç©ºé—´æ˜¯O(n^2)int common_str2(string &amp;str1, string &amp;str2)&#123; int n =str1.size(), m =str2.size() ; vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(m+1, 0)); if(n &lt;m) return common_str2(str2, str1); int max_l =0; for(int i =1; i&lt;=n ; i++) &#123; for(int j =1; j&lt;=m ; j++) &#123; if(str1[i-1] ==str2[j-1]) &#123; dp[i][j] =dp[i-1][j-1] +1; max_l =max(max_l, dp[i][j]); &#125; else dp[i][j] =0; &#125; &#125; // è¿™ä¸ªæ˜¯dp æ€æƒ³æ±‚è§£ï¼Œä½†æ˜¯æœ€é•¿çš„é•¿åº¦ä¸æ˜¯dp[n][m] return max_l;&#125;// ä½¿ç”¨ä¸€ç»´dp è¿›è¡Œä¼˜åŒ–int findLongest(string A, int n, string B, int m) &#123; if(n == 0 || m == 0) return 0; int rs = 0; int dp[n + 1][m + 1]; for(int i = 0 ; i &lt;= n; i++)//åˆå§‹çŠ¶æ€ dp[i][0] = 0; for(int i = 0; i &lt;= m; i++) dp[0][i] = 0; for(int i = 1; i &lt;= n; i++) for(int j = 1; j&lt;= m; j++) &#123; if(A[i - 1] == B[j - 1]) &#123; dp[i][j] = dp[i -1][j - 1] + 1; rs = max(rs,dp[i][j]);//æ¯æ¬¡æ›´æ–°è®°å½•æœ€å¤§å€¼ &#125; else//ä¸ç›¸ç­‰çš„æƒ…å†µ dp[i][j] = 0; &#125; return rs;//è¿”å›žçš„ç»“æžœä¸ºrs&#125;int main()&#123; string str1, str2; //cin &gt;&gt;str1 &gt;&gt;str2; str1 ="abc", str2 ="bcd"; //string res =common_str(str1, str2); //for(auto u : res) cout &lt;&lt; u; int max_l =common_str2(str1, str2); cout &lt;&lt; max_l&lt;&lt; endl; //cout &lt;&lt; findLongest(str1, 3, str2, 3)&lt;&lt; endl; cout &lt;&lt;endl; return 0;&#125; python è§£æ³• 12345678910111213141516171819def longest_substring(str1, str2): n, m =len(str1), len(str2) dp=[[0] *m]*n max_ =0 res ="" for i in range(n): for j in range(m): if str1[i] ==str2[j]: if i and j: dp[i][j] =dp[i-1][j-1] +1 else: dp[i][j] =1 if dp[i][j] &gt;max_: max_ =dp[i][j] res += str1[i] return resstr1 ="abc"str2 ="bcd"print(longest_substring(str1, str2)) æ±‚è§£æœ€é•¿å…¬å…±å­åºåˆ— dp[i][j] è¡¨ç¤ºstring1ä¸­ç¬¬ i ä½ç½®ä¹‹å‰å’Œstring2 ä¸­ç¬¬j ä½ç½®ä¹‹å‰ï¼Œæœ€é•¿çš„å…¬å…±å­åºåˆ—ã€‚(æ±‚è§£çš„æ˜¯max æ“ä½œï¼Œå¯¹äºŽé›†åˆçš„åˆ’åˆ†å¯ä»¥é‡å¤ï¼Œä½†æ˜¯ä¸èƒ½ç¼ºå°‘) 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;int max_sub_len(string &amp; str1, string &amp;str2)&#123; int res =0; int n =str1.size(), m =str2.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(m+1, 0)); // åæ ‡çš„è½¬æ¢ // å¦‚æžœæ˜¯stringï¼Œè¿™ä¸ªåæ ‡æ˜¯å¯ä»¥ä»Ž for(int i =0; i&lt;n; i++) &#123; for(int j =0; j&lt;m; j++) &#123; dp[i+1][j+1] =max(dp[i][j+1], dp[i+1][j]); if(str1[i] ==str2[j]) dp[i+1][j+1] =max(dp[i+1][j+1], dp[i][j] +1); &#125; &#125; return dp[n][m];&#125;int main()&#123; string str1, str2; cin &gt;&gt; str1 &gt;&gt; str2; int res =max_sub_len(str1, str2); cout &lt;&lt; res&lt;&lt; endl; return 0;&#125; python è§£æ³• 123456789101112131415161718# æœ€é•¿å…¬å…±å­åºåˆ—ï¼Œè¿™ä¸ªå¯ä»¥æ˜¯ç¦»æ•£çš„def longest_common_string(str1, str2): n, m =len(str1), len(str2) dp =[[0]* (m+1)]*(n+1) res ="" for i in range(1, n+1): for j in range(1, m+1): dp[i][j] =max(dp[i-1][j], dp[i][j-1]) if str1[i-1] ==str2[j-1]: if dp[i][j]&lt; dp[i-1][j-1] +1: res +=str1[i-1] dp[i][j] = dp[i-1][j-1] +1 # dp[m][n] æ˜¯æœ€å¤§å€¼ return resstr1 ="abc"str2 ="adc"print(longest_common_string(str1, str2)) æœ€é•¿ä¸Šå‡å­åºåˆ— æœ€é•¿å…¬å…±ä¸Šå‡å­åºåˆ— æš´åŠ›çš„è§£æ³•æ˜¯ $O(n^2)$ï¼Œå°±æ˜¯æžšä¸¾å½“å‰ä½ç½®ä¹‹å‰çš„æ•°å­—æ˜¯å¦åˆæ³•ï¼Œå¦‚æžœåˆæ³•ï¼Œé‚£ä¹ˆå°±éœ€è¦ +1 æ“ä½œã€‚å¯¹äºŽdp åŠ¨æ€è§„åˆ’ï¼Œå«ä¹‰ï¼Œåˆå§‹åŒ–å’ŒåŠ¨æ€è½¬ç§»æ–¹ç¨‹ã€‚dp[i] è¡¨ç¤ºä½ç½®ä¸ºi çš„æ‰€æœ‰çš„å‰é¢çš„æ•°å­—æœ‰å¤šå°‘ä¸ªä¸Šå‡åºåˆ—æ•°å­—ã€‚ 123456789101112131415161718192021222324class Solution &#123;public: // æœ€é•¿é€’å¢žå­åºåˆ—ï¼ŒåŠ¨è§„çš„è§’åº¦åŽ»è€ƒè™‘ï¼Œ æžšä¸¾æ³•ï¼Œ æ—¶é—´å¤æ‚åº¦æ˜¯O(n^2) int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int n =nums.size(); if(n ==0) return 0; // éåŽ†å½“å‰ä½ç½®ä¹‹å‰çš„æ‰€æœ‰çš„ä½ç½®ï¼Œç»Ÿè®¡å‡ºçŽ°çš„å°äºŽå½“å‰æ•°å€¼çš„æ•°å­—ï¼Œå°±å¯ä»¥å¾—åˆ°æœ€åŽçš„ç»“æžœ int res =1; vector&lt;int&gt; dp(n, 1); for( int i =1; i&lt;n; i++) &#123; // è¿™ä¸ªæ˜¯ä¿è¯ä¹‹å‰çš„æ‰€æœ‰ä½ç½®çš„æ•°å­— for(int j =0; j&lt;i; j++) &#123; if(nums[i]&gt; nums[j]) dp[i] =max(dp[i], dp[j]+1); &#125; res =max(res, dp[i]); &#125; for(auto u : dp) cout &lt;&lt; u&lt;&lt;" "; cout &lt;&lt; endl; return res; &#125;&#125;; ä½¿ç”¨äºŒåˆ†è¿›è¡Œä¼˜åŒ–ï¼Œç©ºé—´ä¸Šçš„å¤æ‚åº¦ä¸å˜ï¼Œä½†æ˜¯æ—¶é—´ä¸Šçš„å¤æ‚åº¦ç”±åŽŸå…ˆçš„ $O(n^2)$ ä¼˜åŒ–æˆ $O(nlogn)$ï¼Œè¿™ä¸ªæ ·å­ã€‚ä½¿ç”¨æ•°ç»„å­˜å‚¨çš„æ˜¯æœ‰åºçš„æ•°å­—ï¼Œé‚£ä¹ˆæœ€åŽæ•°ç»„çš„é•¿åº¦å°±æ˜¯æœ€é•¿ä¸Šå‡åºåˆ—çš„é•¿åº¦ã€‚ ä¸€æ—¦æœ‰åºä¹‹åŽï¼Œé‚£ä¹ˆå°±å¯ä»¥ä½¿ç”¨äºŒåˆ†ç­‰æ€æƒ³è¿›è¡Œ 123456789101112131415161718192021222324class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; // ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾è¿›è¡Œäº†ä¼˜åŒ– æ—¶é—´å¤æ‚åº¦ä»ŽO(n^2) ä¼˜åŒ–æˆäº† O(nlogn) int n =nums.size(); if(n ==0) return 0; vector&lt;int&gt; h(n+1, 0); h[1] =nums[0]; int max_ =1; for(int i =1; i&lt; n; i++) &#123; int l =1, r =max_; while(l&lt;=r) &#123; int mid =l +r &gt;&gt;1; if(h[mid] &lt; nums[i]) l =mid +1; else r =mid -1; &#125; h[l] =nums[i]; if(l &gt; max_) max_ =l; &#125; return max_; &#125;&#125;; python è§£æ³• 12345678910111213141516171819202122class Solution(object): def lengthOfLIS(self, nums): """ :type nums: List[int] :rtype: int """ # æœ€é•¿ä¸Šå‡å­åºåˆ—ï¼Œæš´åŠ›è§£æ³•ï¼Œ n^2 çš„æ—¶é—´å¤æ‚åº¦ï¼Œ ç„¶åŽæ€Žä¹ˆä¼˜åŒ–å‘¢ï¼Ÿ å› ä¸ºè¿™ä¸ªæ˜¯æœ‰åºçš„ï¼Œæ‰€ä»¥å¯ä»¥è€ƒè™‘ä½¿ç”¨ äºŒåˆ†è¿›è¡Œä¼˜åŒ– n =len(nums) if(n ==0): return 0; h =[0] *(n+1); h[1] =nums[0] max_ =1 for i in range(1, n): l, r = 1, max_ while(l &lt;=r ): mid =l +r &gt;&gt;1; if(h[mid] &lt; nums[i]): l =mid +1 else: r =mid-1 h[l] =nums[i] if(l &gt; max_): max_ =l return max_ å°†åµŒå¥—åˆ—è¡¨è½¬æ¢æˆä¸€ç»´åˆ—è¡¨ 123456789101112res =[]def flatten(items): for item in items: if isinstance(item, int) or isinstance(item, str): #flatten(item) res.append(item) else: flatten(item) #res.append(item) return resitems =[1,2 , 'a', [3, 4, ], (5, 6)]print(flatten(items)) å…¶å®žè¿˜å¯ä»¥å†™æˆä¸€ä¸ªå°çš„ç”Ÿæˆå™¨çš„å½¢å¼ 12345678910111213141516def generator(a): for each in a: if not isinstance(each, list): yield each else: yield from generator(each)a =[1,2, [3, 4], 5]print(generator(a))def generator1(a): for each in a: if isinstance(each, collections.Iterable) : yield from generator1(each) else: yield eachprint(generator1(a)) remove linked list ellements c++ ç‰ˆæœ¬ï¼Œä¸»è¦æƒ³è¦ä¸ªå¼ºè°ƒï¼Œå¦‚æžœæ˜¯åˆ é™¤ä¸€ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆéœ€è¦å¤„ç†f åˆ é™¤å¤´ç»“ç‚¹çš„é—®é¢˜ï¼Œæ‰€ä»¥ä½¿ç”¨ä¸€ä¸ª dummy è¿™æ ·çš„è™šæ‹Ÿå¤´ç»“ç‚¹ï¼Œå¯ä»¥å¤„ç†è¾¹ç•Œæ¡ä»¶ã€‚å¯¹äºŽæœ‰å¯èƒ½åˆ é™¤å¤´ç»“ç‚¹çš„æƒ…å†µä¸‹ï¼Œä¸€èˆ¬ä½¿ç”¨ dummy è¿™ç§è™šæ‹Ÿå¤´ç»“ç‚¹ 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; // è¿™ä¸ªå±žäºŽæ˜¾å¼æž„é€ å‡½æ•° * &#125;; */class Solution &#123;public: ListNode* removeElements(ListNode* head, int val) &#123; ListNode * dummy = new ListNode(-1); ListNode * p =dummy; p -&gt;next =head; while(p-&gt;next) &#123; auto nex =p-&gt;next; if(nex-&gt;val == val) &#123; p-&gt;next = nex-&gt;next; &#125; else p =p-&gt;next; &#125; return dummy-&gt;next; &#125;&#125;; python ç‰ˆæœ¬ä»£ç 123456789101112131415161718# definition of listnodeclass ListNode: def __init__(self, x): self.val =x self.next =None class Solution: def removeElements(self, head: ListNode, val: int) -&gt; ListNode: dummy = ListNode(-1) p =dummy p.next =head while p.next: nex =p.next if(val == nex.val): p.next =nex.next else: p= p.next return dummy.next 74. Search a 2D Matrix python è§£æ³•123456789101112class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool: if not matrix: return False n =len(matrix) if n ==0: return false m =len(matrix[0]) i, j =0, m -1 while i&lt; n and j &gt;=0: if(matrix[i][j] == target): return True elif matrix[i][j] &gt; target: j -=1 else : i +=1 return False c++ è§£æ³•æ˜¯ç±»ä¼¼çš„ï¼Œå°±ä¸å†™äº† ç»Ÿè®¡ä¸­è‹±æ–‡å­—ç¬¦çš„ä¸ªæ•° å’Œ ç»Ÿè®¡è‹±æ–‡å•è¯å¹¶æŒ‰ç…§å€’åºæŽ’åˆ— å…³äºŽç»Ÿè®¡ï¼Œæä¾›äº†å¸¸è§„åšæ³•å’Œæ­£åˆ™åŒ¹é…ä¸¤ç§æ–¹æ³• 123456789101112131415161718192021222324252627282930313233343536373839import stringstr1 ="æ‰¾å‡ºå­—ç¬¦ä¸²ä¸­çš„ä¸­è‹±æ–‡ã€i only regretç©ºæ ¼ã€æ•°å­—ã€æ ‡ç‚¹ç¬¦å· 1 99 0ä¸ªæ•°"def count_(str): cout_num =cout_zh =cout_en =cout_space =cout_pu =0 for ch in str: if ch.isspace(): cout_space +=1 elif ch.isdigit(): cout_num +=1 elif ch in string.ascii_letters: cout_en +=1 elif ch.isalpha(): # è¿™é‡Œä½¿ç”¨çš„æ˜¯å‡æ³•çš„æ€è·¯ cout_zh +=1 else: cout_pu +=1 print("è‹±æ–‡å­—ç¬¦æ•°é‡ï¼š", cout_en) print("ä¸­æ–‡å­—ç¬¦æ•°é‡ï¼š", cout_zh) print("æ•°å­—ä¸ªæ•°ï¼š", cout_num) print("ç©ºæ ¼ä¸ªæ•°: ", cout_space) print("ç‰¹æ®Šå­—ç¬¦ä¸ªæ•°:",cout_pu)#count_(str1)# æ–¹æ³•äºŒï¼Œä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼import redef cout2(str): regex_digit = re.compile(r'[0-9]' ) regex_en =re.compile(r'[a-zA-Z]') regex_zh =re.compile(r'[\u4E00-\u9FA5]') digit_list =regex_digit.findall(str) en_list =regex_en.findall(str) zh_list =regex_zh.findall(str) print("æ•°å­—åºåˆ—", digit_list) print("è‹±æ–‡åºåˆ—", en_list) print("ä¸­æ–‡åºåˆ—", zh_list)cout2(str1) ç»Ÿè®¡çš„å•è¯çš„ä¸ªæ•°ï¼ˆæ³¨æ„ä¸æ˜¯å­—æ¯ charç±»åž‹çš„ï¼‰, æœ‰ä¸åŒçš„æ–¹æ³• a. åœ¨linux çŽ¯å¢ƒä¸‹æ–‡ä»¶æ ¼å¼ï¼šæ–‡ä»¶ä¸­æ¯ä¸€è¡Œä¸ºä¸€ä¸ªå•è¯1234sort filename | uniq -c| sort -nr-c è¾“å‡ºé‡å¤æ¬¡æ•° -n æŒ‰ç…§æ•°å€¼æ¯”è¾ƒæŽ’åº-r é€†åºè¾“å‡ºç»“æžœ b. å…¨ç¨‹python æ“ä½œ123456789101112131415161718192021222324252627282930import sysword2count =&#123;&#125;def word_count(): f1 =open("", 'r') f2 =open("", 'w') while True: line =f1.readline() if not line: break # python å†…ç½®çš„split åªèƒ½ä½¿ç”¨å•ä¸ª åˆ†å‰²ç¬¦ line =line.replace(',', ' ') line =line.replace('.', ' ') line =line.replace('!', ' ') line =line.strip().split(" ") # å¯ä»¥ä½¿ç”¨ reæ¨¡å—ä¸­çš„ split() ï¼Œä½¿ç”¨å¤šä¸ªåˆ†å‰²ç¬¦å¯¹å¥å­è¿›è¡Œåˆ†å‰² import re line =re.split(',.?', line) for item in line: if item not in word2count: word2count[item] =1 else: word2count[item] +=1 # æŒ‰ç…§é€†åºè¿›è¡ŒæŽ’åº res =sorted(word2count.item(), key =lambda x : x[1], reverse =True) for item in res: f2.write(item[0]) f1.close() f2.close() python ä¸­å¸¸è§çš„å¤§å°å†™é—®é¢˜ 1234print(str.upper()) # æŠŠæ‰€æœ‰å­—ç¬¦ä¸­çš„å°å†™å­—æ¯è½¬æ¢æˆå¤§å†™å­—æ¯print(str.lower()) # æŠŠæ‰€æœ‰å­—ç¬¦ä¸­çš„å¤§å†™å­—æ¯è½¬æ¢æˆå°å†™å­—æ¯print(str.capitalize()) # æŠŠç¬¬ä¸€ä¸ªå­—æ¯è½¬åŒ–ä¸ºå¤§å†™å­—æ¯ï¼Œå…¶ä½™å°å†™print(str.title()) # æŠŠæ¯ä¸ªå•è¯çš„ç¬¬ä¸€ä¸ªå­—æ¯è½¬åŒ–ä¸ºå¤§å†™ï¼Œå…¶ä½™å°å†™ æœ€é•¿01ç›¸åŒå­ä¸²å·²çŸ¥ä¸€ä¸ªé•¿åº¦ä¸ºNçš„å­—ç¬¦ä¸²ï¼Œåªç”±0å’Œ1ç»„æˆï¼Œ æ±‚ä¸€ä¸ªæœ€é•¿çš„å­ä¸²ï¼Œè¦æ±‚è¯¥å­ä¸²å‡ºçŽ°0å’Œ1çš„æ¬¡æ•°ç›¸ç­‰ã€‚æ€è·¯ï¼šæœ€ç®€å•çš„æ–¹å¼æ˜¯å…ˆç”Ÿæˆå­—ä¸²ï¼Œç„¶åŽåˆ¤æ–­æ¯ä¸ªå­—ä¸²æ˜¯å¦æ»¡è¶³0çš„ä¸ªæ•°å’Œ1çš„ä¸ªæ•°ç›¸åŒã€‚è¿™ç§æš´åŠ›æ±‚è§£æ—¶é—´å¤æ‚åº¦O(n^3),æ˜Žæ˜¾æ˜¯ä¸åˆç†çš„ã€‚ä¸‹é¢è¯´ä¸€ä¸‹ç®€å•çš„åšæ³•ï¼šå®šä¹‰ä¸€ä¸ªæ•°ç»„B[N]ï¼ŒB[i]è¡¨ç¤ºä»ŽA[0â€¦i]ä¸­ num_of_0 - num_of_1ï¼Œ0çš„ä¸ªæ•°ä¸Ž1çš„ä¸ªæ•°çš„å·® ã€‚é‚£ä¹ˆå¦‚æžœA[i] ~ A[j]æ˜¯ç¬¦åˆæ¡ä»¶çš„å­ä¸²ï¼Œä¸€å®šæœ‰ B[i] == B[j]ï¼Œå› ä¸ºä¸­é—´çš„éƒ¨åˆ†0ã€1ä¸ªæ•°ç›¸ç­‰ï¼Œç›¸å‡ç­‰äºŽ0ã€‚ æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œç©ºé—´å¤æ‚åº¦ï¼šO(n) æ³¨æ„è¿™ä¸ªæ˜¯æ±‚è§£çš„é•¿åº¦ï¼Œæ˜¯ä¸€ä¸ªæœ€å€¼é—®é¢˜ï¼Œè€Œä¸æ˜¯æœ€é•¿çš„01 å­ä¸²æœ¬èº«ã€‚æ‰€ä»¥ä½¿ç”¨ä¸´æ—¶æ•°ç»„è®°å½•ç›®å‰ä¸ºæ­¢çš„01 çš„å·®å€¼ï¼Œç„¶åŽé€‰æ‹©æœ€å¤§çš„å°±è¡Œäº†ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯O(N)ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯O(N)ã€‚ ç®—æ³•çš„ä¼˜åŒ–çš„å…³é”®åœ¨äºŽï¼Œå¯ä»¥åŸºäºŽå‰ä¸€æ­¥çš„è®¡ç®—ç»“æžœç»§ç»­å¾€ä¸‹è®¡ç®—ã€‚å‰ä¸€æ­¥ç®—å‡ºäº† (i-1) çš„01 çš„å·®å€¼ï¼Œé‚£ä¹ˆä¸‹ä¸€æ­¥å¯ä»¥è®¡ç®—å‰ i çš„01 çš„å·®å€¼ã€‚ 12345678910111213141516171819202122232425262728def lengest01SubStr(s): ''' æœ€é•¿0,1 ç›¸ç­‰çš„å­ä¸²é•¿åº¦ ''' count =[0, 0] B =[0]*len(s) dic =&#123;&#125; # ä¿å­˜ 0 1 çš„å·®å€¼ lengest =0 for i in range(len(s)): count[int(s[i])] +=1 B[i] =count[0] - count[1] # start from 0th index if B[i] ==0: lengest +=1 continue if B[i] in dic: # i -dic[B[i]] , not from 0th index lengest =max(lengest, i- dic[B[i]]) else: dic[B[i]] =i return lengesta ='1011010'b ='10110100'print(lengest01SubStr(a)) # 6 # '011010'print(lengest01SubStr(b)) # 8 # '10110100' é¡ºæ—¶é’ˆæ‰“å°çŸ©é˜µ è¾“å…¥ä¸€ä¸ªçŸ©é˜µï¼ŒæŒ‰ç…§ä»Žå¤–å‘é‡Œä»¥é¡ºæ—¶é’ˆçš„é¡ºåºä¾æ¬¡æ‰«å°å‡ºæ¯ä¸€ä¸ªæ•°å­—ã€‚ ä½¿ç”¨å››ä¸ªå¾ªçŽ¯ï¼Œå°±å¯ä»¥è§£å†³ï¼Œè¿™ä¸ªåº”è¯¥å±žäºŽæ‰¾è§„å¾‹çš„é¢˜ç›®ã€‚ æ€è·¯ï¼šæ‰¾åˆ°å·¦ä¸Šè§’çš„ï¼Œä¸€ä¸ªstart_pointï¼Œ ç„¶åŽæ ¹æ®è¿™ä¸ªç‚¹è¿›è¡Œä¸Šä¸‹å·¦å³çš„å¾ªçŽ¯ã€‚ python ä¸­çš„ range() æ˜¯ä¸€ç§å·¦é—­å³å¼€çš„åŒºé—´ï¼Œå¹¶ä¸”åœ¨é€†åºéåŽ†çš„æ—¶å€™ï¼ŒåŒºé—´çš„å€¼æ˜¯ä¸å˜çš„ï¼Œæœ€åŽä½¿ç”¨ -1 å°±OKäº†ã€‚è¿˜æœ‰éåŽ†æ—¶å€™çš„ i, j éƒ½åªæ˜¯ä¸€ç§indexï¼Œå¦‚æžœä¸€ä¸ªå¤Ÿç”¨çš„è¯ï¼Œé‚£ä¹ˆå°±æ²¡æœ‰å¿…è¦ä½¿ç”¨ä¸¤ä¸ªã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142def printMatrix(matrix): if not matrix or matrix ==[[]]: return # ç¬¬ä¸€æ¬¡è§è¿™æ ·åˆ¤æ–­ç©ºçš„matrix row =len(matrix) column =len(matrix[0]) # è¿™é‡Œçš„left, right, up, down éƒ½æ˜¯çœŸå®žèƒ½å¤Ÿaccessåˆ°æ•°æ®çš„ left =0 right =column -1 up =0 down =row -1 res =[] while left &lt;right and up &lt;down: # from left to right for i in range(left, right+1): res.append(matrix[up][i]) # from up to down for i in range(up+1, down+1): res.append(matrix[i][right]) # from right to left for i in range(right-1, left-1, -1): res.append(matrix[down][i]) for i in range(down-1, up, -1): res.append(matrix[i][left]) left +=1 right -=1 up +=1 down -=1 # æœ€åŽå¯¹äºŽè¿™ç§ç‰¹æ®Šæƒ…å†µçš„å¤„ç†æ˜¯å®¹æ˜“å¿˜è®°çš„ # left one row è¿™ç§æƒ…å†µå¾ˆç‰¹æ®Šï¼Œåªæ˜¯ä»Žå·¦å¾€å³éåŽ† if up ==down and left &lt;right: for i in range(left, right+1): res.append(matrix[up][i]) # left one column åªæœ‰å¯èƒ½æ˜¯ä»Žä¸Šå¾€ä¸‹éåŽ† if left ==right and up &lt;down: for i in range(up, down+1): res.append(matrix[i][left]) if up ==down and left ==right: res.append(matrix[left][up]) return resprint(printMatrix(matrix)) æœ€å°è°ƒæ•´æœ‰åº æœ‰ä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œè¯·ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œæ‰¾å‡ºç´¢å¼•må’Œnï¼Œåªè¦å°†må’Œnä¹‹é—´çš„å…ƒç´ æŽ’å¥½åºï¼Œæ•´ä¸ªæ•°ç»„å°±æ˜¯æœ‰åºçš„ã€‚æ³¨æ„ï¼šn-måº”è¯¥è¶Šå°è¶Šå¥½ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæ‰¾å‡ºç¬¦åˆæ¡ä»¶çš„æœ€çŸ­åºåˆ—ã€‚ç»™å®šä¸€ä¸ªintæ•°ç»„Aå’Œæ•°ç»„çš„å¤§å°nï¼Œè¯·è¿”å›žä¸€ä¸ªäºŒå…ƒç»„ï¼Œä»£è¡¨æ‰€æ±‚åºåˆ—çš„èµ·ç‚¹å’Œç»ˆç‚¹ã€‚(åŽŸåºåˆ—ä½ç½®ä»Ž0å¼€å§‹æ ‡å·,è‹¥åŽŸåºåˆ—æœ‰åºï¼Œè¿”å›ž[0,0])ã€‚ä¿è¯Aä¸­å…ƒç´ å‡ä¸ºæ­£æ•´æ•°ã€‚ æ ·ä¾‹12[1,4,6,5,9,10],6è¿”å›žï¼š[2,3] ç¬¬ä¸€ç§æ¯”è¾ƒæš´åŠ›ï¼Œæ—¶é—´å¤æ‚åº¦ $O(nlogn)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* æœ€å°è°ƒæ•´æœ‰åº æ‰¾å‡ºç´¢å¼•m å’Œnï¼Œåªè¦æ˜¯m å’Œn ä¹‹é—´çš„å…ƒç´ æŽ’å¥½åºï¼Œæ•´ä¸ªæ•°ç»„å°±æ˜¯æœ‰åºçš„ã€‚æ³¨æ„n-m åº”è¯¥æ˜¯è¶Šå°è¶Šå¥½ï¼Œæ‰¾å‡ºç¬¦åˆæ¡ä»¶çš„æœ€çŸ­åºåˆ— */#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; find_segment(vector&lt;int&gt;&amp; arr)&#123; vector&lt;int&gt; res(2, 0); vector&lt;int&gt; tmp(arr.begin(), arr.end()); sort(arr.begin(), arr.end()); for(int i =0; i&lt; arr.size(); i++) &#123; if(tmp[i] != arr[i]) &#123; res[0] =i; break; &#125; &#125; for(int i =arr.size() -1; i&gt;=0; i--) &#123; if(tmp[i] != arr[i]) &#123; res[1] =i; return res; &#125; &#125; return res;&#125;int main()&#123; int n; vector&lt;int&gt; arr; cin &gt;&gt;n; for(int i =0; i&lt; n; i++) &#123; int tmp; cin &gt;&gt; tmp; arr.push_back(tmp); &#125; vector&lt;int&gt; res =find_segment(arr); for(auto u: res) cout &lt;&lt; u &lt;&lt; " "; cout &lt;&lt; endl; return 0;&#125; ç¬¬äºŒç§æ˜¯$O(n)$ çš„æ—¶é—´å¤æ‚åº¦ã€‚åˆ†æˆä¸¤ä¸ªæ­¥éª¤ ä»Žå·¦å¾€å³æ‰¾ï¼Œå¦‚æžœå½“å‰å…ƒç´ å°äºŽä¹‹å‰çš„æœ€å¤§å…ƒç´ åˆ™è¯´æ˜Žå½“å‰å…ƒç´ åº”å¤„äºŽA[first,last]æ— åºåºåˆ—ä¸­è€Œä¸”å½“å‰å…ƒç´ æ˜¯å½“å‰æœ€å¤§ä¸‹æ ‡çš„æ— åºå…ƒç´ ã€‚ ä»Žå³å¾€å·¦æ‰¾ï¼Œå¦‚æžœå½“å‰å…ƒç´ å¤§äºŽä¹‹å‰çš„æœ€å°å…ƒç´ åˆ™è¯´æ˜Žå½“å‰å…ƒç´ åº”å¤„äºŽA[first,last]æ— åºåºåˆ—ä¸­è€Œä¸”å½“å‰å…ƒç´ æ˜¯å½“å‰æœ€å°ä¸‹æ ‡çš„æ— åºå…ƒç´ ã€‚ å…³é”®åœ¨äºŽæ‰¾åˆ°ä¹‹åŽï¼Œç»§ç»­éåŽ†ç›´åˆ°æ•°ç»„çš„æœ€åŽï¼› å¢žåŠ æ–°çš„ä¸€ä¸ªæ ·ä¾‹ 1å¯¹äºŽä¸€ä¸ªæ•´æ•°æ•°ç»„[1,3,5,8,4,10,12,9,15,17]ï¼Œåˆ™æœ€çŸ­æ— åºæ•°ç»„ä¸º[5,8,4,10,12,9]ã€‚ å¥½å¥½æ€è€ƒä¸€ä¸‹ï¼Œå½“æ—¶ä¸ºä»€ä¹ˆæƒ³ä¸åˆ°ï¼Œè¿™ç§æ€è·¯æ˜¯ä»€ä¹ˆï¼Œæˆ‘å½“æ—¶æ˜¯æƒ³åˆ°äº† $O(n)$ éåŽ†ï¼Œä½†æ˜¯æ²¡æœ‰ç›¸å½“å³ä½¿ç¬¬ä¸€å›žå‘çŽ°äº†ä¸ç¬¦åˆè¦æ±‚çš„æ•°å­—ï¼Œé‚£ä¹ˆä¹Ÿæ˜¯è¦éåŽ†å®Œï¼Œç„¶åŽä¸æ–­åœ°çš„æ›´æ–°ç»“æžœçš„ã€‚ å¼€å§‹çš„æƒ³æ³•æ˜¯æ­£ç¡®çš„ï¼Œå·¦å³ä¸¤æ¬¡éåŽ†ã€‚ä½†æ˜¯éœ€è¦ä¸æ–­çš„æ›´æ–°æœ€å€¼ï¼Œä»Žå³å¾€å·¦æ˜¯æœ€å°å€¼ï¼Œä»Žå·¦å¾€å³æ˜¯æœ€å¤§å€¼ã€‚ä¸èƒ½åªæ˜¯å’Œå‘¨å›´çš„æ•°å­—è¿›è¡Œæ¯”è¾ƒã€‚ ç®€è€Œè¨€ä¹‹å°±æ˜¯æ‰¾å‡ºï¼Œé€†åºçš„ï¼Œ å› ä¸ºæ˜¯æœ‰åºçš„ï¼Œæ‰€ä»¥å¦‚æžœå‘çŽ°ä¸€ä¸ªæ¯”åœ¨ä¹‹å‰æ•°å­—å°ï¼Œé‚£ä¹ˆè¯´æ˜Žæ‰¾åˆ°äº†å³ç«¯ç‚¹ï¼›ä»Žå³å‘å·¦ï¼Œå¦‚æžœå‘çŽ°æ¯”å·¦è¾¹å¤§ï¼Œè¯´æ˜Žæ‰¾åˆ°äº†å·¦ç«¯ç‚¹ï¼›éœ€è¦è½¬æ¢ä¸€ä¸‹æ€è·¯ 12345678910111213141516171819202122class Rearrange &#123;public: vector&lt;int&gt; findSegment(vector&lt;int&gt; nums, int n) &#123; // write code here int maxv =nums[0], minv =nums[n-1]; vector&lt;int&gt; res(2, 0); for(int i =0; i&lt; n; i++) &#123; if(nums[i] &gt;= maxv) maxv =nums[i]; else res[1] =i; &#125; for(int i =n -1; i&gt;=0; i--) &#123; if(nums[i] &lt;= minv )minv =nums[i]; else res[0] =i; &#125; return res; &#125;&#125;; python å®žçŽ°çš„ä»£ç 123456789101112131415# -*- coding:utf-8 -*-class Rearrange: def findSegment(self, nums, n): # write code here if n==1: return [0, 0] minv, maxv =nums[-1], nums[0] res =[0, 0] for i in range(n): if nums[i] &gt;= maxv: maxv =nums[i] else: res[1] =i for i in range(n-1, -1, -1): if nums[i] &lt;=minv: minv =nums[i] else: res[0] =i return res 915. Partition Array into Disjoint Intervals è€ƒå¯Ÿæƒ³æ³•çš„é¢˜ç›®çœŸçš„æ˜¯å¤ªéš¾äº†ï¼Œå¦‚æžœæƒ³ä¸å‡ºæ¥ï¼Œé‚£ä¹ˆçœŸçš„æ˜¯ä¸ä¼šåšã€‚åˆ†æˆå·¦å³ä¸¤ä¸ªéƒ¨åˆ†ï¼Œå·¦è¾¹çš„å…¨éƒ¨æ¯”å³è¾¹çš„å°ã€‚é‚£ä¹ˆåªè¦ä¿è¯å·¦è¾¹æœ€å¤§çš„æ˜¯å°äºŽç­‰äºŽå³è¾¹æœ€å°çš„å°±è¡Œã€‚è¿™ä¸ªæ€è·¯æ˜¯ï¼Œæ•°å­¦é¢˜ã€‚ä¸‹é¢å°±éœ€è¦ä½¿ç”¨ä¸€ä¸ª $O(n)$ ç©ºé—´å¤æ‚åº¦è®°å½•ä»Ž $i$ åˆ°$n$ çš„æœ€å°å€¼ã€‚ä¸ç”¨ä½¿ç”¨æ•°ç»„ä¿å­˜å‰ $i$ çš„æœ€å¤§å€¼ï¼Œç›´æŽ¥åœ¨éåŽ†çš„æ—¶å€™è¿›è¡Œåˆ¤æ–­è¿›è¡Œäº†ã€‚ 1234567891011121314151617181920212223242526class Solution &#123;public: // tong // å› ä¸ºè¦æ±‚åˆ†æˆä¸¤éƒ¨åˆ†ï¼Œå·¦è¾¹çš„éƒ½æ¯”å³è¾¹çš„å°ï¼Œ // ä½¿ç”¨ä¸€ä¸ªæ•°ç»„ tmp[i] è¡¨ç¤ºä»Ž i åˆ° n-1 æœ€å¤§å€¼ // ç„¶åŽç»è¿‡ä¸€æ¬¡éåŽ†ä¹‹åŽï¼Œå¦‚æžœæŸä¸ªarr[i] &lt; tmp[i] é‚£ä¹ˆå°±å¾—åˆ°äº†æ­£ç¡®çš„è§£ int partitionDisjoint(vector&lt;int&gt;&amp; nums) &#123; int n =nums.size(); vector&lt;int&gt; minv(n, INT_MAX); minv[n-1] =nums[n-1]; for(int i =n-2; i&gt;=0; i--) &#123; minv[i] =min(minv[i+1], nums[i] ); //cout &lt;&lt; maxv[i] &lt;&lt; endl; &#125; // è¿™é‡Œè¿˜éœ€è¦è®°å½•åˆ°åˆ°å½“å‰ä½ç½®çš„æœ€å¤§å€¼ int maxv =0; for(int i =0 ; i&lt;n-1; i++) &#123; maxv= max(maxv, nums[i]); if (maxv &lt;=minv[i+1]) return i +1; &#125; return -1; &#125;&#125;; python å®žçŽ° 12345678910111213141516171819import sysclass Solution(object): def partitionDisjoint(self, A): """ :type A: List[int] :rtype: int """ n =len(A) minv=[sys.maxsize]*n minv[n-1] =A[n-1] for i in range(n-2, -1, -1): minv[i] =min(minv[i+1], A[i]) #print(minv) maxv =0 for i in range(n-1): maxv=max(maxv, A[i]) if(maxv &lt;= minv[i+1]): return i +1 return -1 149. Max Points on a Line è¿™ä¸ªé¢˜ç›®éœ€è¦å¤„ç†ç«–ç›´ç›´çº¿ï¼Œé‡å¤çš„ç‚¹ç­‰ç‰¹æ®Šæƒ…å†µã€‚å‰©ä¸‹çš„ä¸€èˆ¬æƒ…å†µæ˜¯éœ€è¦ä½¿ç”¨ é¡¶ç‚¹+ æ–œçŽ‡è¿›è¡Œè¡¨ç¤ºï¼Œä½¿ç”¨dictionary è¿›è¡Œè¡¨ç¤ºã€‚ æ³¨æ„åœ¨python ä¸­ä½¿ç”¨çš„æ˜¯ gcb å…ˆæ±‚è§£äº† æœ€å¤§å…¬å› æ•°ï¼Œç„¶åŽå†è¿›è¡Œè¡¨ç¤ºã€‚ä½¿ç”¨c++ å®žçŽ°ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦æ˜¯$O(n^2)$ åœ¨ c++ ä¸­ä½¿ç”¨ double long å¤„ç†ç²¾åº¦çš„é—®é¢˜ï¼Œä½†æ˜¯å¯ä»¥ä½¿ç”¨gcb(æœ€å¤§å…¬çº¦æ•°) æ›´åŠ åˆç†ã€‚123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: // é¦–å…ˆè¿™ä¸ªæ˜¯ä¸€ä¸ª $n^2$ çš„ç®—æ³•ï¼Œå› ä¸ºéœ€è¦è®¡ç®—æ¯ä¸€ä¸ªç‚¹åˆ°å…¶ä»–çš„æ‰€æœ‰ç‚¹çš„æ–œçŽ‡ï¼ˆå¦‚æžœå¯ä»¥çš„è¯ï¼‰ int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; int n =points.size(); int res =0; // ä»¥è¿™ä¸ªç‚¹ä¸ºåŸºå‡†ç‚¹ è¿›è¡Œå‘å°„ for(int i =0; i&lt; n; i++) &#123; unordered_map&lt;double long, int&gt; hash; int veticles =1, duplicates =0; for(int j =i +1; j&lt;n; j++) &#123; if(points[i][0] ==points[j][0]) &#123; veticles +=1; if(points[i][1] ==points[j][1]) duplicates +=1; &#125; &#125; for(int j =i +1; j&lt;n; j++) &#123; if(points[i][0] != points[j][0]) &#123; double long slope = (double long)(points[i][1] -points[j][1])/(points[i][0] -points[j][0]); if(hash[slope] ==0) hash[slope] =2; else hash[slope ] ++; res =max(res, hash[slope] + duplicates); &#125; &#125; res =max(res, veticles); &#125; return res; &#125;&#125;; ä½¿ç”¨python å®žçŽ°çš„ 123456789101112131415161718192021222324252627282930313233343536class Solution(object): # åœ¨python ä¸­ ä½¿ç”¨ gcb å¤„ç†ç²¾åº¦é—®é¢˜ def maxPoints(self, points): """ :type points: List[List[int]] :rtype: int """ res =0 n =len(points) for i in range(n): veticles =1 duplicates =0 dic =&#123;&#125; for j in range(i+1, n): # å¯¹åº”çš„æ˜¯ä¸èƒ½è®¡ç®— slope æ–œçŽ‡çš„æƒ…å†µ if(points[i][0] ==points[j][0]): veticles +=1; if(points[i][1] ==points[j][1]): duplicates +=1 for j in range(i +1, n): if points[i][0] != points[j][0]: dx =points[i][0] -points[j][0] dy =points[i][1] -points[j][1] common =self.gcb(dx, dy) if (dx//common, dy//common) in dic: dic[(dx//common, dy //common)] +=1 else: dic[(dx//common, dy//common)] =2 res =max(res, dic[(dx//common, dy//common)] +duplicates) res =max(res, veticles) return res; def gcb(self, a, b): if(b ==0): return a return self.gcb(b, a%b) 279. Perfect Squares æ—¶é—´å¤æ‚åº¦ $O(n\sqrt(n))$ï¼Œå¤æ‚åº¦çš„è®¡ç®—æ˜¯æœ‰ä¸ªæŠ€å·§ï¼Œå½“ $i =n$ æ—¶å€™ï¼Œé‚£ä¹ˆ $j$ çš„éåŽ†æ¬¡æ•°æœ€å¤šæ˜¯ $\sqrt(n)$ æ‰€ä»¥ä¸¤è€…ç›¸ä¹˜å°±å¯ä»¥äº†ã€‚ 1234567891011121314151617class Solution &#123;public: // åŠ¨æ€è§„åˆ’æ±‚è§£ f[i] è¡¨ç¤ºn æ‰€éœ€è¦çš„æœ€å°‘çš„æ•°é‡ // f[i] =min(f[i -j*j]) å…¶ä¸­ 1&lt;= j&lt;= sqrt(n) // æœ€åŽçš„f[n] è¡¨ç¤ºæœ€åŽçš„è§£ int numSquares(int n) &#123; // æŒ‰ç…§é“ç†æ±‚è§£æœ€å°å€¼ï¼Œå¯ä»¥åˆå§‹åŒ–ä¸º INT_MAX è¿™æ ·çš„æ•°å­— vector&lt;int&gt; f(n+1, n); f[0] =0; for(int i =1; i&lt;=n; i++) &#123; for(int j =1; j*j &lt;=i; j++) f[i] =min(f[i], f[i-j*j] +1); &#125; return f[n]; &#125;&#125;; python ä¸­ä½¿ç”¨è¿™æ ·çš„æ–¹å¼è¿›è¡Œå®žçŽ°ã€‚å…³é”®æ˜¯ sqrt(i) æ˜¯å¯ä»¥ä½¿ç”¨ i**0.5 è¿›è¡Œå®žçŽ°çš„ã€‚ 123456789101112class Solution(object): def numSquares(self, n): """ :type n: int :rtype: int """ nums =[n] *(n+1) nums[0] =0 for i in range(1, n+1): for j in range(1, int(i**0.5)+1): nums[i] =min(nums[i], nums[i -j*j] +1) return nums[n] python æœ‰ä¸¤ç§å†™æ³•ï¼Œä¸€ç§æ˜¯for å°æš–ä½¿ç”¨ **0.5 è¡¨ç¤º $sqrt(x) $ çš„è®¡ç®—ï¼Œä¸€ç§æ˜¯ä½¿ç”¨ while å¾ªçŽ¯æ–¹å¼ã€‚ 123456789101112131415class Solution(object): # èƒ½å¤Ÿæƒ³åˆ°çš„å°±æ˜¯æžšä¸¾ï¼Œ ä»Ž 1 åˆ° sqrt(n) ï¼Œç„¶åŽæœ€åŽçš„æ—¶é—´å¤æ‚åº¦æ˜¯ nsqrt(n) def numSquares(self, n): """ :type n: int :rtype: int """ f=[n]*(n+1) f[0] =0 for i in range(1, n+1): j =1 while j*j &lt;=i: f[i] =min(f[i], f[i -j*j] +1) j +=1 return f[n] LeetCode 647. Palindromic Substrings æ¯æ¬¡å›ºå®šå›žæ–‡å­ä¸²çš„ä¸­é—´ä½ç½®ï¼Œç„¶åŽå‘å·¦å³å¼€å§‹æ‰©å±•ï¼›æ¯æ¬¡å›ºå®šåŽï¼Œåˆ†ä¸ºå¥‡æ•°é•¿åº¦å’Œå¶æ•°é•¿åº¦ä¸¤ç§æƒ…å†µï¼Œç„¶åŽæš´åŠ›ç»Ÿè®¡ç­”æ¡ˆå³å¯ã€‚æ—¶é—´å¤æ‚åº¦ å…±æœ‰ $O(n)$ ä¸ªä¸­é—´ä½ç½®ï¼Œå›ºå®šåŽï¼Œæœ€åæƒ…å†µä¸‹éœ€è¦$ O(n)$ çš„æ—¶é—´æ‰©å±•å›žæ–‡ä¸²ï¼Œæ•…æ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(n^2)$ã€‚ ä½¿ç”¨ while æ›´åŠ èƒ½å¤Ÿä½“çŽ°æ¡ä»¶å¾ªçŽ¯çš„ç²¾é«“. 123456789101112131415161718192021222324class Solution &#123;public: int countSubstrings(string s) &#123; int n =s.length(); int res =0; // è¿™ä¸ªæ˜¯éåŽ†ä¸­é—´ç»“ç‚¹çš„ï¼Œ for(int i =0; i&lt;n; i++) &#123; int j =0; while( i-j &gt;=0 &amp;&amp; i +j &lt;n &amp;&amp; s[i-j] ==s[i+j]) &#123; res +=1; j +=1; &#125; j =1; while(i-j +1 &gt;=0 &amp;&amp; i+j &lt;n &amp;&amp; s[i-j +1] == s[i+j]) &#123; res +=1; j +=1; &#125; &#125; return res; &#125;&#125;; ä½¿ç”¨python å®žçŽ° 123456789101112131415class Solution: def countSubstrings(self, s: str) -&gt; int: n =len(s) res =0 for i in range(n): j =0 while i-j&gt;=0 and i+j &lt;n and s[i-j] ==s[i+j]: res +=1 j +=1 j =1 while i-j+1 &gt;=0 and i +j &lt;n and s[i-j +1] ==s[i+j]: res +=1 j +=1 return res; cpp ä¸­å°æŠ€å·§ï¼Œå¾ªçŽ¯è¾“å…¥ç›´åˆ°é‡åˆ°å›žè½¦ã€‚ 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; // æ—¶é—´å¤æ‚åº¦æ˜¯ O(n^2) string str; while(getline(cin, str)) &#123; //if(s[0] =="\n") break; int ans =0; int n =str.length(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; i - j &gt;= 0 &amp;&amp; i + j &lt; n &amp;&amp; str[i - j] == str[i + j]; j++) ans++; for (int j = 1; i - j + 1 &gt;= 0 &amp;&amp; i + j &lt; n &amp;&amp; str[i - j + 1] == str[i + j]; j++) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; // å¦‚æžœä¸æ˜¯å›žè½¦ï¼Œé‚£ä¹ˆå°±ä¸€ç›´å¾ªçŽ¯ï¼Œå¦‚æžœæ˜¯å›žè½¦ï¼Œé‚£ä¹ˆå°±è·³å‡º if(getchar() =='\n') break; &#125; return 0;&#125; 394. Decode String ä½¿ç”¨python å®žçŽ°ï¼Œ æ—¶é—´å¤æ‚åº¦æ˜¯$O(n)$ ç©ºé—´å¤æ‚åº¦æ˜¯ $O(n)$ï¼›åœ¨python ä¸­å¸¸å¸¸ä½¿ç”¨çš„ isdigit(), isalpha()ã€‚ä¹Ÿæ˜¯å¯ä»¥ä½¿ç”¨c++ è¿›è¡Œå®žçŽ°ï¼Œä½†æ˜¯å› ä¸ºc++ å®žçŽ°çš„æ—¶é—´å¤æ‚åº¦æ˜¯$k^n$ï¼Œ æ‰€ä»¥ä¸å†™äº†ï¼Œ å¯ä»¥å‚è€ƒè¿™é‡Œ è¿™é‡Œå‡è®¾åµŒå¥—çš„å±‚æ•°æ˜¯ $n$ï¼Œ æ•°å­—æ•°å€¼å¤§å°æ˜¯ $k$ã€‚ 12345678910111213141516171819202122class Solution(object): def decodeString(self, s): """ :type s: str :rtype: str """ stack =[['', 1,'']] a =n ='' for ch in s: if ch.isdigit(): n +=ch elif ch.isalpha(): a +=ch elif ch =='[': # æŠŠä¹‹å‰çš„ä¸œè¥¿æ”¾åˆ°é‡Œé¢ stack.append([a, int(n),'']) a =n ='' else: a1, a2, a3 =stack.pop() stack[-1][-1] += a1+ a2*(a3+a) # å¦‚æžœåœ¨åŽé¢å°±æ˜¯åœ¨åŽé¢ï¼Œå¦‚æžœå†å‰é¢å°±æ˜¯åœ¨å‰é¢ a ='' return stack[-1][-1]+a ä¸€èˆ¬è¿™ç§é¢˜ç›®éƒ½æ˜¯å¯ä»¥åŸºäºŽ stackè¿›è¡Œè§£ç­”çš„ã€‚è¿™é“é¢˜ç›®æŽ¨èä½¿ç”¨ python ä½œç­”ï¼Œ å®¹æ˜“å‡ºé”™çš„ç‚¹æ˜¯ break å‡½æ•°ã€1234567891011121314151617181920212223242526272829class Solution(object): def decodeString(self, s): """ :type s: str :rtype: str """ # è¿™ä¸ªç®—æ˜¯æ¯”è¾ƒç®€å•çš„æ–¹å¼ stack =[] for ch in s: # ç±»ä¼¼ä¸€ç§ç»“æŸç¬¦å· if ch!=']': stack.append(ch) else: # do so # åˆ¤æ–­æ˜¯å¦æ˜¯ [ æˆ–è€… ] è¿™ä¸¤ä¸ªæ ‡å¿—ç¬¦å·ï¼Œå› ä¸ºæœ‰ä¸¤ä¸ªä¸åŒçš„æ“ä½œ str_ ='' # åœ¨pop() æ‰§å‹¤å•Šç¡®å®žåº”è¯¥æ˜¯æ£€æŸ¥ä¸€ä¸‹çš„ while stack: x =stack.pop() if x =='[': # å¤„ç†çš„æ˜¯æ•°å­— num ="" while stack and stack[-1].isdigit(): num =stack.pop() + num stack.append(str_* int(num)) break else: str_ = x + str_ return "".join(stack) String Compression å’Œä¸Šé¢ä¸€é“é¢˜ç›®ç›¸åçš„æ˜¯ï¼ŒåŽ‹ç¼©å­—ç¬¦ä¸²ï¼Œå…³é”®æ˜¯åŒæŒ‡é’ˆçš„ç®—æ³•ï¼Œä¸éš¾ã€‚12345678910111213141516171819202122class Solution(object): def compress(self, chars): """ :type chars: List[str] :rtype: int """ n =len(chars) res ="" i =0 # å¦‚æžœè¿™é‡Œä½¿ç”¨ range() é‚£ä¹ˆæ˜¯æ— è§†ä¸‹é¢å¯¹äºŽi çš„ä¿®æ”¹çš„ï¼Œæ‰€ä»¥ while i&lt;n: #for i in range(n): j =i while j&lt; n and chars[j] == chars[i] : j +=1 # è¿™ä¸ªæ˜¯å¸¸è§çš„å­—ç¬¦ä¸²è®¡æ•°çš„æ–¹å¼ if j-i &gt;1: res += chars[i] +str(j -i) else: # å¦‚æžœåªæ˜¯æœ‰ä¸€ä¸ªçš„è¯ï¼Œæ˜¯ä¸éœ€è¦è®¡æ•°çš„ res += chars[i] i =j chars[:] =list(res) # è¿™ä¸ªæ˜¯ä½œå¼Šçš„æ“ä½œï¼Œå› ä¸ºæœ¬æ–‡è¦æ±‚çš„æ˜¯ in-place çš„æ“ä½œï¼Œæ‰€ä»¥æŒ‰ç…§é“ç†è¯´æ˜¯ä¸åº”è¯¥ç”³è¯·æ–°çš„å†…å­˜çš„ return len(chars) 48. Rotate Image é¡ºæ—¶é’ˆé€‰æ‹©æ•°ç»„ï¼Œå¯ä»¥åˆ†æˆä¸¤ä¸ªæ­¥éª¤ã€‚ æŒ‰ç…§ y =x è½´å¯¹ç§°æ—‹è½¬æ•°ç»„ æŒ‰ç…§ yçš„ä¸­ç‚¹ çš„è½´å¯¹ç§° æ—‹è½¬æ•°ç»„ æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n^2)$ 12345678910111213141516171819class Solution &#123;public: // å…³é”®æ˜¯æ€è·¯çš„é—®é¢˜ï¼Œ rotate image ï¼Œé¦–å…ˆæ˜¯æŒ‰ç…§ y =x è¿›è¡Œå¯¹ç§°ï¼› ç„¶åŽæ˜¯æŒ‰ç…§ ç«–åæ ‡è½´ä¸­é—´è¿›è¡Œå¯¹ç§° void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.empty()) return; int n =matrix.size(); for (int i =0; i&lt;n; i++) &#123; for(int j =i+1; j&lt;n; j ++) &#123; swap(matrix[i][j] ,matrix[j][i]); &#125; // ç¬¬äºŒä¸ªè½¬æ¢ int m =matrix[0].size(); for(int j=0, k =m -1; j&lt;k ; j ++, k--) swap(matrix[i][j], matrix[i][k]); &#125; &#125;&#125;; python å®žçŽ°123456789101112131415class Solution: def rotate(self, matrix: List[List[int]]) -&gt; None: """ Do not return anything, modify matrix in-place instead. """ n, m =len(matrix), len(matrix[0]) for i in range(n): # è¿™ä¸ªåœ¨pythonä¸­å®žçŽ°æ˜¯æ¯”è¾ƒniceçš„ for j in range(i+1, n): matrix[i][j], matrix[j][i] =matrix[j][i], matrix[i][j] j, k =0, m-1 while(j &lt;k): matrix[i][k], matrix[i][j] =matrix[i][j], matrix[i][k] j +=1 k -=1 æ‰©å±•ï¼Œ å¦‚æžœæ˜¯é€†æ—¶é’ˆæ—‹è½¬æ•°ç»„ï¼Œé‚£ä¹ˆè¿™ä¸ªæ—¶å€™ï¼Œå¯ä»¥å…ˆæŒ‰ç…§ y =-x è¿›è¡Œæ—‹è½¬ï¼Œç„¶åŽæŒ‰ç…§ yçš„ä¸­ç‚¹æ—‹è½¬æ•°ç»„ã€‚ 54. Spiral Matrix è¿™ä¸ªæ¯”è¾ƒç®€å•ï¼Œæ˜¯å››ä¸ªfor å¾ªçŽ¯éåŽ†è§£å†³çš„é—®é¢˜ï¼Œè¾¹ç•Œé—®é¢˜æ˜¯éœ€è¦æ³¨æ„çš„ã€‚è¿˜æ²¡æœ‰æ‰¾åˆ°é™¤æ­¤ä¹‹å¤–å…¶ä»–çš„æ–¹æ³•ã€‚ä¸‹é¢çš„ä»£ç æ˜¯é”™è¯¯çš„ï¼Œè¾¹ç•Œé—®é¢˜å¤ªéš¾å¤„ç†äº†ã€‚123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; res; if(matrix.empty()) return res; int n= matrix.size(), m = matrix[0].size(); int top=0, down=n-1, l=0, r= m-1; while(top &lt;= down &amp;&amp; l &lt;= r) &#123; for(int i =l ; i&lt;=r; i++) res.push_back(matrix[top][i]); for(int i =top+1; i&lt;=down; i++) res.push_back(matrix[i][r]); for(int i =r-1; i&gt;=l ; i--) res.push_back(matrix[down][i]); for(int i =down-1; i&gt;top; i--) res.push_back(matrix[i][l]); top +=1, down -=1, l +=1, r -=1; &#125; // å¤„ç† or çš„æƒ…å†µ if(top &lt; down) for(int i =top ; i&lt; down; i++) &#123; cout &lt;&lt; matrix[top][i]&lt;&lt;" "; res.push_back(matrix[top][i]); &#125; if(l&lt; r) for(int i =l; i&lt;r; i++) &#123; res.push_back(matrix[top][i]); cout &lt;&lt; matrix[top][i]&lt;&lt;" "; &#125; //if(top ==down and l ==r) res.push_back(matrix[top][l]); return res; &#125;&#125;; ä½¿ç”¨ç±»ä¼¼çš„ç‰ˆæœ¬çš„ä»£ç ï¼Œ è¾¹ç•Œé—®é¢˜é€šè¿‡å¤šä¸ª breakè¯­å¥è¿›è¡Œå¤„ç†ï¼Œ exactly çš„æ–¹å¼è¿›è¡Œå¤„ç†ã€‚123456789101112131415161718192021222324252627282930class Solution &#123;public: // è¾¹ç•Œé—®é¢˜å¦‚ä½•å¤„ç† vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; res; int n = matrix.size(); if(!n) return res; int m =matrix[0].size(); int l=0, r=m-1, u=0, d=n-1; while (true)&#123; if(l&lt;=r) for(int i =l ; i&lt;=r; i++) res.push_back(matrix[u][i]); else break; u +=1; if(u &lt;= d) for(int i =u ; i&lt;=d; i++) res.push_back(matrix[i][r]); else break; r -=1; if(l &lt;=r) for(int i=r; i&gt;=l; i--) res.push_back(matrix[d][i]); else break; d -=1; if(u&lt;=d) for(int i=d; i&gt;=u; i--) res.push_back(matrix[i][l]); else break; l +=1; &#125; return res; &#125;&#125;; https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/ 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // è¿™ä¸ªæ˜¯å¸¸å¸¸è€ƒå¯Ÿçš„ç¬”è¯•é¢˜ ListNode* deleteDuplicates(ListNode* head) &#123; ListNode * dummy = new ListNode(-1); dummy -&gt;next =head; ListNode * p =dummy; while(p -&gt;next) &#123; auto q =p-&gt;next; while(q &amp;&amp; q-&gt;val ==p-&gt;next-&gt;val) q = q-&gt;next; // if ä¸­è¡¨ç¤ºçš„æ²¡æœ‰é‡å¤çš„å…ƒç´ ï¼Œ elseä¸­è¡¨ç¤ºæœ‰é‡å¤çš„å…ƒç´  if(p-&gt;next -&gt;next ==q) p =p-&gt;next; else p-&gt;next =q; &#125; return dummy-&gt;next; &#125;&#125;; python å®žçŽ°ã€‚ æ³¨æ„åœ¨æ–°å»ºå¯¹è±¡ä¸­ python æ˜¯ç›´æŽ¥ ListNode ä½†æ˜¯ c++ ä¸­éœ€è¦new å…³é”®å­—ã€‚ç„¶åŽæŒ‡é’ˆçš„ä½¿ç”¨ c++ ä¸­ -&gt; ç„¶åŽpython ä¸­ä½¿ç”¨ . å…³é”®å­—. 123456789101112131415161718192021222324# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ # æœ‰ä¸€äº›ç»†èŠ‚éœ€è¦æ³¨æ„ dummy = ListNode(-1) dummy.next =head p = dummy while( p.next): q =p.next while(q and p.next.val == q.val): q =q.next if(p.next.next ==q): p=p.next; else: p.next =q return dummy.next Remove Duplicates from Sorted List å…¶ä¸­çš„ if è¡¨ç¤ºå¹¶æ²¡æœ‰èˆå¼ƒå½“å‰çš„ç»“ç‚¹ï¼Œæ¯æ¬¡éƒ½æ˜¯å‰è¿›ä¸€æ­¥ã€‚å’Œä¸Šé¢é‚£é“é¢˜ä¸­ï¼Œä½¿ç”¨while æ‰¾åˆ°æœ€åŽçš„ç»“ç‚¹ä¸åŒã€‚ä¸€ä¸ªä¸ªè¿›è¡Œæ“ä½œï¼Œå› ä¸ºå…¶ä¸­ä½¿ç”¨çš„ if è¯­å¥ã€‚ä¸Šé¢çš„å…¨éƒ¨åŽ»æŽ‰ä½¿ç”¨çš„æ˜¯ while è¯­å¥ã€‚ python ç‰ˆæœ¬ 1234567891011121314151617181920# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = None# è¿™é“é¢˜ç›®ç›¸å¯¹ä¸Šä¸€é“é¢˜ç›®å°±æ¯”è¾ƒç®€å•ï¼Œclass Solution(object): def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ if not head: return head; p =head while p.next: if(p.val == p.next.val): p.next =p.next.next else: p =p.next return head c++ ç‰ˆæœ¬12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(! head) return head; ListNode* p =head; while(p-&gt;next) &#123; // è¿™å¥è¯å¹¶æ²¡æœ‰èˆå¼ƒå½“å‰çš„ç»“ç‚¹ï¼Œæ¯æ¬¡éƒ½æ˜¯ç§»åŠ¨ä¸€æ­¥ï¼Œ if(p-&gt;next-&gt;val == p-&gt;val) p-&gt;next= p-&gt;next-&gt;next; else p =p-&gt;next; &#125; return head; &#125;&#125;;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Activation Function and Loss Function]]></title>
    <url>%2F2018%2F07%2F07%2FLoss-Activation-and-Optimisation-Function%2F</url>
    <content type="text"><![CDATA[ä¸»è¦ä»‹ç» activation functionï¼Œ loss function ç­‰ç­‰æ¦‚å¿µå’Œåˆ†ç±»ã€‚ Activation FunctionWhat? Itâ€™s just a thing (node) that you add to the output end of any neural network. It is also known as Transfer Function. It can also be attached in between two Neural Networks. $$Output = activation function \left( x _ { 1 } w _ { 1 } + x _ { 2 } w _ { 2 } + \cdots + x _ { n } w _ { n } + b i a s \right)$$ A weighted sum is computed as:$$x _ { 1 } w _ { 1 } + x _ { 2 } w _ { 2 } + \cdots + x _ { n } w _ { n }$$Then, the computed value is fed into the activation function, which then prepares an output.$$activation function \left( x _ { 1 } w _ { 1 } + x _ { 2 } w _ { 2 } + \cdots + x _ { n } w _ { n } + b i a s \right)$$ Think of the activation function as a mathematical operation that normalises the input and produces an output. The output is then passed forward onto the neurons on the subsequent layer. ä½œç”¨ï¼šå¢žåŠ éžçº¿æ€§ The thresholds are pre-defined numerical values in the function. This very nature of the activation functions can add non-linearity to the output. Activation Function Types Linear Activation Function: $$ output = k * x$$where $k$ is a scalar value, as an instance 2, and $x$ is the input. Sigmoid or Logistic Activation Function The sigmoid activation function is â€œSâ€ shaped. It can add non-linearity to the output and returns a binary value of 0 or 1. $$Output = \frac { 1 } { 1 + e ^ { - x } }$$ è¿™ä¸ªå‡½æ•°æœ‰ä¸€ä¸ªå¾ˆå¥½çš„å¯¼æ•°å½¢å¼ï¼Œåœ¨åå‘ä¼ æ’­çš„æ—¶å€™ï¼Œæ•ˆæžœæ¯”è¾ƒæ˜Žæ˜¾ã€‚ Tanh Activation Function Tanh is an extension of the sigmoid activation function. Hence Tanh can be used to add non-linearity to the output. The output is within the range of -1 to 1. Tanh function shifts the result of the sigmoid activation function: $$\text { Output } = \frac { 2 } { 1 + e ^ { - 2 x } } - 1$$ Rectified Linear Unit Activation Function (RELU) RELU is one of the most used activation functions. It is preferred to use RELU in the hidden layer. The concept is very straight forward. It also adds non-linearity to the output. However the result can range from 0 to infinity. $$ Output = \max ( 0 , x )$$è¿™ä¸ªæ˜¯å¾ˆé«˜çš„è¯„ä»·äº†ã€‚If you are unsure of which activation function you want to use then use RELU. Softmax Activation Function Softmax is an extension of the Sigmoid activation function. Softmax function adds non-linearity to the output, however it is mainly used for classification examples where multiple classes of results can be computed. $$Output = \frac { e ^ { x } } { \operatorname { sum } \left( e ^ { x } \right) }$$ è¿™ä¸ªä¸€èˆ¬ä½¿ç”¨åœ¨æœ€åŽï¼Œä½œä¸ºå¤šåˆ†ç±»çš„ç»“æŸã€‚ Loss Function(Error Function)æœºå™¨å­¦ä¹ ä¸­æ‰€æœ‰çš„ç®—æ³•éƒ½éœ€è¦æœ€å¤§åŒ–æˆ–æœ€å°åŒ–ä¸€ä¸ªå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°è¢«ç§°ä¸ºâ€œç›®æ ‡å‡½æ•°â€ã€‚å…¶ä¸­ï¼Œæˆ‘ä»¬ä¸€èˆ¬æŠŠæœ€å°åŒ–çš„ä¸€ç±»å‡½æ•°ï¼Œç§°ä¸ºâ€œæŸå¤±å‡½æ•°â€ã€‚å®ƒèƒ½æ ¹æ®é¢„æµ‹ç»“æžœï¼Œè¡¡é‡å‡ºæ¨¡åž‹é¢„æµ‹èƒ½åŠ›çš„å¥½åã€‚ æŸå¤±å‡½æ•° (Loss function) æ˜¯ç”¨æ¥è¡¡é‡æ¨¡åž‹çš„é¢„æµ‹å€¼ $f(x)$ å’ŒçœŸå®žå€¼ $Y$ çš„ä¸ä¸€æ ·çš„ç¨‹åº¦ï¼Œé€šå¸¸ä½¿ç”¨ $L (Y, f(x))$ æ¥è¿›è¡Œè¡¨ç¤ºï¼ŒæŸå¤±å‡½æ•°è¶Šå°ï¼Œæ¨¡åž‹çš„é²æ£’æ€§è¶Šå¼ºã€‚ é€‰æ‹©loss çš„æ—¶å€™éœ€è¦è€ƒè™‘ä¸¤ç‚¹ï¼šåˆ†ç±»or å›žå½’é—®é¢˜ å’Œç»“æžœçš„è¾“å‡ºæƒ…å†µã€‚ the choice of loss function must match the framing of the specific predictive modeling problem, such as classification or regression. Further, the configuration of the output layer must also be appropriate for the chosen loss function. æ€»çš„æ¥è¯´æ˜¯å¯ä»¥åˆ†æˆä¸‰ç±»ï¼šå›žå½’æ¨¡åž‹ï¼ŒäºŒåˆ†ç±»æ¨¡åž‹å’Œå¤šåˆ†ç±»æ¨¡åž‹ Regression Loss Functionsa. Mean Squared Error Lossb. Mean Squared Logarithmic Error Lossc. Mean Absolute Error Loss Binary Classification Loss Functionsa. Binary Cross-Entropyb. Hinge Lossc. Squared Hinge Loss Multi-Class Classification Loss Functionsa. Multi-Class Cross-Entropy Lossb. Sparse Multiclass Cross-Entropy Lossc. Kullback Leibler Divergence Loss Regression Loss Function (å›žå½’) å¦‚ä½•è¿›è¡Œé€‰æ‹©ï¼Ÿ å¯¹äºŽå›žå½’é—®é¢˜ï¼Œä¸€ä¸ªbaseline çš„loss function æ˜¯å¯ä»¥é€‰æ‹©å¹³æ–¹æŸå¤±å‡½æ•°ã€‚ä»Žæ•°æ®çš„è§’åº¦è¿›è¡Œåˆ†æžï¼Œå¦‚æžœæ•°æ®æœä»Žæ­£å¤ªåˆ†å¸ƒï¼Œé‚£ä¹ˆå¹³æ–¹æŸå¤±å‡½æ•°æ²¡æœ‰é—®é¢˜ï¼Œå¦‚æžœæ•°æ®æœ‰ä¸€äº› outlierï¼Œå¯ä»¥ä½¿ç”¨ mean squared logarithmic error lossï¼Œ å…ˆè¿›è¡Œ $\hat { y } $ç„¶åŽå†è®¡ç®—å¹³æ–¹å’Œã€‚å¦‚æžœ outlier æ¯”è¾ƒå¤šçš„è¯ï¼Œé‚£ä¹ˆä½¿ç”¨ mean absolute error lossï¼Œè®¡ç®—å·®å€¼çš„æ—¶å€™æ¢æˆç»å¯¹å€¼å‡½æ•°ã€‚ å¹³æ–¹æŸå¤±å‡½æ•° å®šä¹‰ï¼š Mean Squared Error (MSE), or quadratic, loss function is widely used in linear regression as the performance measure, and the method of minimizing MSE is called Ordinary Least Squares (OSL)ã€‚ To calculate MSE, you take the difference between your predictions and the ground truth, square it, and average it out across the whole dataset. $$Loss = \frac { 1 } { n } \sum _ { i = 1 } ^ { n } \left( y ^ { ( i ) } - \hat { y } ^ { ( i ) } \right) ^ { 2 }$$ åœ¨çº¿æ€§å›žå½’ä¸­ï¼Œå®ƒå‡è®¾æ ·æœ¬å’Œå™ªå£°éƒ½æœä»Žé«˜æ–¯åˆ†å¸ƒï¼ˆä¸ºä»€ä¹ˆå‡è®¾æˆé«˜æ–¯åˆ†å¸ƒå‘¢ï¼Ÿå…¶å®žè¿™é‡Œéšè—äº†ä¸€ä¸ªå°çŸ¥è¯†ç‚¹ï¼Œå°±æ˜¯ä¸­å¿ƒæžé™å®šç†ï¼‰ï¼Œæœ€åŽé€šè¿‡æžå¤§ä¼¼ç„¶ä¼°è®¡MLEå¯ä»¥æŽ¨å¯¼å‡ºæœ€å°äºŒä¹˜å¼å­ï¼Œå³å¹³æ–¹æŸå¤±å‡½æ•°å¯ä»¥é€šè¿‡çº¿æ€§å›žå½’åœ¨å‡è®¾æ ·æœ¬æ˜¯é«˜æ–¯åˆ†å¸ƒçš„æ¡ä»¶ä¸‹æŽ¨å¯¼å¾—åˆ°ã€‚ $$S E = \sum _ { i = 1 } ^ { n } \left( y _ { i } - y _ { i } ^ { p } \right) ^ { 2 }$$ ä¸ºä»€ä¹ˆé€‰æ‹©æ¬§å¼è·ç¦»ä½œä¸ºè¯¯å·®çš„åº¦é‡ï¼Ÿ ç®€å•ï¼Œè®¡ç®—æ–¹ä¾¿ æ¬§å¼è·ç¦»æ˜¯ä¸€ç§å¾ˆå¥½çš„ç›¸ä¼¼åº¦è¡¡é‡æ ‡å‡† åœ¨ä¸åŒçš„è¡¨ç¤ºåŸŸå˜æ¢ä¹‹åŽï¼Œç‰¹å¾çš„æ€§è´¨èƒ½å¤Ÿä¿æŒä¸å˜ã€‚ åœ¨å®žé™…åº”ç”¨ä¸­ï¼Œé€šå¸¸ä¼šä½¿ç”¨ å‡æ–¹å·®ä½œä¸ºä¸€ç§è¡¡é‡æŒ‡æ ‡ï¼Œå°±æ˜¯åœ¨ä¸Šé¢çš„å…¬å¼ä¸­é™¤ä»¥ N. ä½¿ç”¨è¯´æ˜Žï¼š å¦‚æžœ target æ˜¯æœä»Žé«˜æ–¯åˆ†å¸ƒï¼Œé‚£ä¹ˆä½¿ç”¨ mean squared error æ˜¯æ²¡æœ‰é—®é¢˜ï¼›å¹¶ä¸”æ²¡æœ‰å¾ˆå¥½çš„ç†ç”±è¿›è¡Œæ›¿æ¢çš„è¯ï¼Œé‚£ä¹ˆå°±æ˜¯ä»–äº†ã€‚ Mathematically, it is the preferred loss function under the inference framework of maximum likelihood if the distribution of the target variable is Gaussian. It is the loss function to be evaluated first and only changed if you have a good reason. Mean Squared Logarithmic Error Loss å’Œä¸Šé¢çš„çš„mse æœ‰ä¸€ç‚¹å·®åˆ«ã€‚è¿™ä¸ªæ˜¯å…ˆè®°æ€§log æ±‚ç»“æžœï¼Œç„¶åŽå†è®¡ç®— mse. you can first calculate the natural logarithm of each of the predicted values, then calculate the mean squared error. This is called the Mean Squared Logarithmic Error loss, or MSLE for short. å¥½å¤„:It has the effect of relaxing the punishing effect of large differences in large predicted values. ä½¿ç”¨è¯´æ˜Žï¼šå¦‚æžœæœ€åŽçš„ç»“æžœçš„æ•°å€¼æœ‰å¤§å€¼ï¼Œé‚£ä¹ˆå¯ä»¥å°è¯•ä¸€ä¸‹ã€‚ä¸æ˜¯é‚£ä¹ˆç¬¦åˆé«˜æ–¯åˆ†å¸ƒï¼Œå°±å¯ä»¥å°è¯•ä¸€ä¸‹ã€‚ Mean Absolute Error Loss å®šä¹‰ï¼šMean Absolute Error (MAE) is a quantity used to measure how close forecasts or predictions are to the eventual outcomes, which is computed by $$Loss = \frac { 1 } { n } \sum _ { i = 1 } ^ { n } \left| y ^ { ( i ) } - \hat { y } ^ { ( i ) } \right|$$ where $| .|$ denotes the absolute value. Albeit, both MSE and MAE are used in predictive modeling, there are several differences between them. MSE has nice mathematical properties which makes it easier to compute the gradient. However, MAE requires more complicated tools such as linear programming to compute the gradient. Because of the square, large errors have relatively greater influence on MSE than do the smaller error. Therefore, MAE is more robust to outliers since it does not make use of square. On the other hand, MSE is more useful if concerning about large errors whose consequences are much bigger than equivalent smaller ones. MSE also corresponds to maximizing the likelihood of Gaussian random variables. ä½¿ç”¨è¯´æ˜Žï¼š å½“æœ‰å¾ˆå¤šçš„ç‚¹åç¦» mean and variance çš„æ—¶å€™ï¼Œå¯ä»¥å°è¯•ä½¿ç”¨ mae loss functionï¼Œè¿™ä¸ªæ˜¾è‘—çš„ç‰¹ç‚¹åœ¨äºŽ å¯¹outlier æ˜¯æœ‰æŠµæŠ—ä½œç”¨çš„ã€‚ The Mean Absolute Error, or MAE, loss is an appropriate loss function in this case as it is more robust to outliers. It is calculated as the average of the absolute difference between the actual and predicted values. Binary Classification Loss Function (äºŒåˆ†)åœ¨äºŒåˆ†ç±»çš„ç½‘ç»œç»“æž„ä¸­ç»å¸¸ å‡ºçŽ° Dense() ç½‘ç»œå±‚( å¦‚æžœä½¿ç”¨ keras è¿›è¡Œå®žçŽ°çš„è¯), å› ä¸ºæœ€åŽæƒ³è¦å¾—åˆ°çš„æ˜¯ä¸€ä¸ªç»“ç‚¹ã€‚ Binary Cross-Entropy Loss Cross-entropy loss is often simply referred to as â€œcross-entropy,â€ â€œlogarithmic loss,â€ â€œlogistic loss,â€ or â€œlog lossâ€ for short. Cross-entropy is the default loss function to use for binary classification problems. å¦‚æžœæ²¡æœ‰æ›´å¥½çš„äºŒåˆ†ç±»çš„é€‰æ‹©ï¼ˆç†ç”±ï¼‰ï¼Œé‚£ä¹ˆè¿™ä¸ªå°±æ˜¯é¦–é€‰ã€‚ æ•°å­¦å®šä¹‰ï¼š Cross-entropy will calculate a score that summarizes the average difference between the actual and predicted probability distributions for predicting class 1. The score is minimized and a perfect cross-entropy value is 0. äºŒåˆ†ç±»é—®é¢˜çš„äº¤å‰ç†µ loss ä¸»è¦æ˜¯æœ‰ä¸¤ç§å½¢å¼ã€‚ç¬¬ä¸€ç§æ˜¯è¾“å‡ºçš„label æ˜¯ {0, 1}ï¼Œä¹Ÿæ˜¯æœ€ä¸ºå¸¸è§çš„ã€‚$$Loss= - [ y \log \hat { y } + ( 1 - y ) \log ( 1 - \hat { y } ) ]$$ è¿™ä¸ªå…¬å¼å¯ä»¥å…ˆä»Žä¸€ä¸ªåˆ†æ®µå‡½æ•°æŽ¨å¯¼ï¼Œç„¶åŽä»Žæœ€å¤§ä¼¼ç„¶çš„è§’åº¦å‡ºå‘ï¼Œé¢„æµ‹ç±»åˆ«çš„æ¦‚çŽ‡æ˜¯:$$P ( y | x ) = \hat { y } ^ { y } \cdot ( 1 - \hat { y } ) ^ { ( 1 - y ) }$$ç„¶åŽå–å¯¹æ•°ï¼š$$log(loss)= - [ y \log \hat { y } + ( 1 - y ) \log ( 1 - \hat { y } ) ]$$ å½“ $y =1$ çš„æ—¶å€™ï¼Œ$$L = - \log \hat { y }$$å› ä¸ºï¼Œ$$\hat { y } = \frac { 1 } { 1 + e ^ { - s } }$$æ‰€ä»¥å¾—åˆ°$$L = \log \left( 1 + e ^ { - s } \right)$$loss çš„æ›²çº¿å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ä»Žå›¾ä¸­æ˜Žæ˜¾èƒ½å¤Ÿçœ‹å‡ºï¼Œs è¶Šå¤§äºŽé›¶ï¼ŒL è¶Šå°ï¼Œå‡½æ•°çš„å˜åŒ–è¶‹åŠ¿ä¹Ÿå®Œå…¨ç¬¦åˆå®žé™…éœ€è¦çš„æƒ…å†µã€‚ï¼ˆy =1 æ˜¯è¿™ä¸ªæ—¶å€™çš„ç›®æ ‡ï¼‰ å½“ $y =0$ çš„æ—¶å€™ï¼šåŒç†å¯ä»¥å¾—åˆ°ï¼Œ$$log(loss)= \log \left( 1 + e ^ { s } \right)$$ ä»Žå›¾ä¸­æ˜Žæ˜¾èƒ½å¤Ÿçœ‹å‡ºï¼Œs è¶Šå°äºŽé›¶ï¼ŒL è¶Šå°ï¼Œå‡½æ•°çš„å˜åŒ–è¶‹åŠ¿ä¹Ÿå®Œå…¨ç¬¦åˆå®žé™…éœ€è¦çš„æƒ…å†µã€‚ ç¬¬äºŒç§æƒ…å†µæ˜¯åŸºäºŽè¾“å‡ºlabel è¡¨ç¤ºæ–¹å¼ {-1, 1}ï¼Œè¿™ä¸ªæ—¶å€™çš„loss è¡¨è¾¾å¼ä¸º: $$loss = \log \left( 1 + e ^ { - y s } \right)$$ è¿™ä¸ªæ—¶å€™åªä¸è¿‡ä½¿ç”¨ $ys$ ä»£æ›¿ä¸Šé¢çš„s ï¼Œå®žé™…ä¸Šçš„åˆ†æžè¿˜æ˜¯ä¸€æ ·çš„ã€‚å…¶ä¸­ y è¡¨ç¤ºçœŸå®žçš„æ ‡ç­¾ï¼Œs è¡¨ç¤º sigmoid ä¸­çš„sï¼Œè§ä¸‹é¢çš„å…¬å¼ã€‚$$g ( s ) = \frac { 1 } { 1 + e ^ { - s } }$$å½“ ys &gt;0 çš„æ—¶å€™ï¼Œè¡¨ç¤ºçš„é¢„æµ‹æ­£ç¡®ï¼Œå¦åˆ™æ˜¯é¢„æµ‹é”™è¯¯ã€‚ äº¤å‰ç†µæŸå¤±å‡½æ•°ç»å¸¸ä½¿ç”¨sigmoid å‡½æ•°ä½œä¸ºæ¿€æ´»å‡½æ•°ï¼Œå› ä¸ºè¿™ä¸ªå¯ä»¥å®Œç¾Žè§£å†³å¹³æ–¹æŸå¤±å‡½æ•°ä¸­æƒé‡æ›´æ–°æ¯”è¾ƒæ…¢ç‚¹çš„æƒ…å†µã€‚ ä½¿ç”¨è¯´æ˜Žï¼šMathematically, it is the preferred loss function under the inference framework of maximum likelihood. It is the loss function to be evaluated first and only changed if you have a good reason.It is intended for use with binary classification where the target values are in the set {0, 1}. Hinge Loss An alternative to cross-entropy for binary classification problems is the hinge loss function, primarily developed for use with Support Vector Machine (SVM) models. Hinge Lossï¼Œåˆç§°åˆé¡µæŸå¤±ï¼Œå…¶è¡¨è¾¾å¼å¦‚ä¸‹ï¼š $$Loss = \max ( 0,1 - y s )$$å…¶ä¸­ y å’Œ s çš„å–å€¼èŒƒå›´éƒ½æ˜¯ [-1, 1]. æƒ³æƒ³ SVM ä¸­æœ€å¤§åŒ–é—´éš”çš„å†…å®¹å°±ç†è§£äº†ã€‚å›¾åƒå¦‚ä¸‹ï¼š å¦‚åŒåˆèµ·æ¥çš„ä¹¦ï¼Œæ‰€ä»¥ç§°ä¹‹ä¸º åˆé¡µæŸå¤±ã€‚æ˜¾ç„¶ï¼Œåªæœ‰å½“ ys &lt; 1 æ—¶ï¼ŒLoss æ‰å¤§äºŽé›¶ï¼›å¯¹äºŽ ys &gt; 1 çš„æƒ…å†µï¼ŒLoss å§‹ç»ˆä¸ºé›¶ã€‚Hinge Loss ä¸€èˆ¬å¤šç”¨äºŽæ”¯æŒå‘é‡æœºï¼ˆSVMï¼‰ä¸­ï¼Œä½“çŽ°äº† SVM è·ç¦»æœ€å¤§åŒ–çš„æ€æƒ³ã€‚ è€Œä¸”ï¼Œå½“ Loss å¤§äºŽé›¶æ—¶ï¼Œæ˜¯çº¿æ€§å‡½æ•°ï¼Œä¾¿äºŽæ¢¯åº¦ä¸‹é™ç®—æ³•æ±‚å¯¼ã€‚Hinge Loss çš„å¦ä¸€ä¸ªä¼˜ç‚¹æ˜¯ä½¿å¾— ys &gt; 0 çš„æ ·æœ¬æŸå¤±çš†ä¸º 0ï¼Œç”±æ­¤å¸¦æ¥äº†ç¨€ç–è§£ï¼Œä½¿å¾— SVM ä»…é€šè¿‡å°‘é‡çš„æ”¯æŒå‘é‡å°±èƒ½ç¡®å®šæœ€ç»ˆè¶…å¹³é¢ã€‚ ä½¿ç”¨è¯´æ˜Žï¼šè¦æ±‚ target è½¬æ¢æˆ {-1, 1} ï¼Œæ•ˆæžœæœ‰æ—¶å€™æ¯” cross-binary è¦å¥½ã€‚ It is intended for use with binary classification where the target values are in the set {-1, 1}.Reports of performance with the hinge loss are mixed, sometimes resulting in better performance than cross-entropy on binary classification problems. ( è¿™å¥è¯æ¯”è¾ƒè¿·ç¦»å‘€) The hinge loss function encourages examples to have the correct sign, assigning more error when there is a difference in the sign between the actual and predicted class values. Squared Hinge Loss (é€šå¸¸ä¸Šè®²ï¼Œæœ€åŽçš„ç»“æžœæ›´åŠ å…‰æ»‘æ˜¯æ²¡æœ‰ä»€ä¹ˆåŠ£åŠ¿çš„)A popular extension is called the squared hinge loss that simply calculates the square of the score hinge loss. It has the effect of smoothing the surface of the error function and making it numerically easier to work with. éœ€è¦ä»Ž {0, 1} -&gt; {-1, 1} è¿™æ ·target çš„è½¬æ¢, éžå¸¸å®¹æ˜“å®žçŽ°ã€‚ 123# change y from &#123;0,1&#125; to &#123;-1,1&#125;y[where(y == 0)] = -1` ä½¿ç”¨è¯´æ˜Žï¼š ï¼ˆå¾ˆå¼ºçš„ç›¸å…³æ€§äº†ï¼‰If using a hinge loss does result in better performance on a given binary classification problem, is likely that a squared hinge loss may be appropriate. Multi-Class Classification Loss Functionså¯¹äºŽå¤šç±»é—®é¢˜çš„å®šä¹‰ï¼š The problem is often framed as predicting an integer value, where each class is assigned a unique integer value from 0 to (num_classes â€“ 1). The problem is often implemented as predicting the probability of the example belonging to each known class. Multi-Class Cross-Entropy Loss Cross-entropy is the default loss function to use for multi-class classification problems. ï¼ˆå¯è§ äº¤å‰ç†µå¯¹äºŽåˆ†ç±»é—®é¢˜çš„é‡è¦æ€§ï¼‰ åŒç†ï¼Œå¦‚æžœæ˜¯æœ€å¤§ä¼¼ç„¶ï¼Œæ¦‚çŽ‡æ¨¡åž‹ï¼Œdonot hesitate.( æ•°å­¦åŸºç¡€å°±æ˜¯åœ¨è¿™é‡Œ)Mathematically, it is the preferred loss function under the inference framework of maximum likelihood. It is the loss function to be evaluated first and only changed if you have a good reason. Cross-entropy will calculate a score that summarizes the average difference between the actual and predicted probability distributions for all classes in the problem. The score is minimized and a perfect cross-entropy value is 0. åŸºäºŽ keraså®žçŽ°çš„æ—¶å€™éœ€è¦å…ˆæŠŠ target (label) è½¬æˆ one-hot ç±»åž‹çš„ï¼Œå½“ç„¶è¿™ä¸ªå¯èƒ½é€ æˆ loss æ›²çº¿çš„æ³¢åŠ¨ï¼ˆåŽè¯ï¼‰ã€‚12# one hot encode output variabley = to_categorical(y) Sparse Multiclass Cross-Entropy Loss å’Œä¸Šé¢çš„åŒºåˆ«ä¸»è¦åœ¨äºŽ label æ˜¯ä¸éœ€è¦è½¬æˆ one-hot ç±»åž‹çš„ï¼Œä¿æŒè¿™åŽŸæ¥çš„ number å½¢å¼ã€‚Sparse cross-entropy addresses this by performing the same cross-entropy calculation of error, without requiring that the target variable be one hot encoded prior to training. Kullback Leibler Divergence Loss Kullback Leibler Divergence, or KL Divergence for short, is a measure of how one probability distribution differs from a baseline distribution. æ•°å­¦åŽŸç†ï¼š(ä»¥ bit ä¸ºå•ä½çš„ ä¿¡æ¯ç†µ) A KL divergence loss of 0 suggests the distributions are identical. In practice, the behavior of KL Divergence is very similar to cross-entropy. It calculates how much information is lost (in terms of bits) if the predicted probability distribution is used to approximate the desired target probability distribution. ä½¿ç”¨è¯´æ˜Žï¼šæ›´å¸¸ä½¿ç”¨ åœ¨å¤æ‚çš„æ¨¡åž‹ä¸Šï¼Œæ¯”å¦‚ dense representation ä¹‹åˆ—ã€‚å½“ç„¶ä¹Ÿæ˜¯å¯ä»¥ä½¿ç”¨åœ¨å¤šåˆ†ç±»çš„æƒ…å†µä¸‹ï¼Œè¿™ä¸ªæ—¶å€™å¦‚åŒ multi-class cross-entropy. As such, the KL divergence loss function is more commonly used when using models that learn to approximate a more complex function than simply multi-class classification, such as in the case of an autoencoder used for learning a dense feature representation under a model that must reconstruct the original input. In this case, KL divergence loss would be preferred. Nevertheless, it can be used for multi-class classification, in which case it is functionally equivalent to multi-class cross-entropy. å‚è€ƒæ–‡çŒ®ï¼š How to Choose Loss Functions When Training Deep Learning Neural Networks log å¯¹æ•°æŸå¤±å‡½æ•° åœ¨é€»è¾‘å›žå½’çš„æŽ¨å¯¼ä¸­ï¼Œå®ƒå‡è®¾æ ·æœ¬æœä»Žä¼¯åŠªåˆ©åˆ†å¸ƒï¼ˆ0-1åˆ†å¸ƒï¼‰ï¼Œç„¶åŽæ±‚å¾—æ»¡è¶³è¯¥åˆ†å¸ƒçš„ä¼¼ç„¶å‡½æ•°ï¼ŒæŽ¥ç€å–å¯¹æ•°æ±‚æžå€¼ç­‰ç­‰ã€‚ æŒ‡æ•°æŸå¤±å‡½æ•° å…¬å¼å¦‚ä¸‹ï¼š$$loss = e ^ { - y s }$$ æ›²çº¿å¦‚ä¸‹ï¼š Exponential Loss ä¸Žäº¤å‰ç†µ Loss ç±»ä¼¼ï¼Œä½†å®ƒæ˜¯æŒ‡æ•°ä¸‹é™çš„ï¼Œå› æ­¤æ¢¯åº¦è¾ƒå…¶å®ƒ Loss æ¥è¯´ï¼Œæ›´å¤§ä¸€äº›ã€‚ Exponential Loss ä¸€èˆ¬å¤šç”¨äºŽAdaBoost ä¸­ã€‚å› ä¸ºä½¿ç”¨ Exponential Loss èƒ½æ¯”è¾ƒæ–¹ä¾¿åœ°åˆ©ç”¨åŠ æ³•æ¨¡åž‹æŽ¨å¯¼å‡º AdaBoostç®—æ³•ã€‚ $$L = - \log \frac { e ^ { s } } { \sum _ { j = 1 } ^ { C } e ^ { s _ { j } } } = - s + \log \sum _ { j = 1 } ^ { C } e ^ { s _ { j } }$$ softmax loss çš„æ›²çº¿å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ä¸Šå›¾ä¸­ï¼Œå½“ s &lt;&lt; 0 æ—¶ï¼ŒSoftmax è¿‘ä¼¼çº¿æ€§ï¼›å½“ s&gt;&gt;0 æ—¶ï¼ŒSoftmax è¶‹å‘äºŽé›¶ã€‚Softmax åŒæ ·å—å¼‚å¸¸ç‚¹çš„å¹²æ‰°è¾ƒå°ï¼Œå¤šç”¨äºŽç¥žç»ç½‘ç»œå¤šåˆ†ç±»é—®é¢˜ä¸­ã€‚ è‹¥æˆ‘ä»¬æŠŠ ys çš„åæ ‡èŒƒå›´å–å¾—æ›´å¤§ä¸€äº›ï¼Œä¸Šé¢ 5 ç§ Loss çš„å·®åˆ«ä¼šæ›´å¤§ä¸€äº›ï¼Œå¦‚å›¾ï¼š æ˜¾ç„¶ï¼Œè¿™æ—¶å€™ Exponential Loss ä¼šè¿œè¿œå¤§äºŽå…¶å®ƒ Lossã€‚ä»Žè®­ç»ƒçš„è§’åº¦æ¥çœ‹ï¼Œæ¨¡åž‹ä¼šæ›´åŠ åå‘äºŽæƒ©ç½šè¾ƒå¤§çš„ç‚¹ï¼Œèµ‹äºˆå…¶æ›´å¤§çš„æƒé‡ã€‚å¦‚æžœæ ·æœ¬ä¸­å­˜åœ¨ç¦»ç¾¤ç‚¹ï¼ŒExponential Loss ä¼šç»™ç¦»ç¾¤ç‚¹èµ‹äºˆæ›´é«˜çš„æƒé‡ï¼Œä½†å´å¯èƒ½æ˜¯ä»¥ç‰ºç‰²å…¶ä»–æ­£å¸¸æ•°æ®ç‚¹çš„é¢„æµ‹æ•ˆæžœä¸ºä»£ä»·ï¼Œå¯èƒ½ä¼šé™ä½Žæ¨¡åž‹çš„æ•´ä½“æ€§èƒ½ï¼Œä½¿å¾—æ¨¡åž‹ä¸å¤Ÿå¥å£®ï¼ˆrobustï¼‰ã€‚ ç›¸æ¯” Exponential Lossï¼Œå…¶å®ƒå››ä¸ª Lossï¼ŒåŒ…æ‹¬ Softmax Lossï¼Œéƒ½å¯¹ç¦»ç¾¤ç‚¹æœ‰è¾ƒå¥½çš„â€œå®¹å¿æ€§â€ï¼Œå—å¼‚å¸¸ç‚¹çš„å¹²æ‰°è¾ƒå°ï¼Œæ¨¡åž‹è¾ƒä¸ºå¥å£®ã€‚ Softmax loss å¯¹äºŽå¤šåˆ†ç±»é—®é¢˜ï¼Œå¯ä»¥ä½¿ç”¨ softmax lossã€‚ å…¶ä¸­ï¼ŒC ä¸ºç±»åˆ«ä¸ªæ•°ï¼Œå°å†™å­—æ¯ s æ˜¯æ­£ç¡®ç±»åˆ«å¯¹åº”çš„ Softmax è¾“å…¥ï¼Œå¤§å†™å­—æ¯ S æ˜¯æ­£ç¡®ç±»åˆ«å¯¹åº”çš„ Softmax è¾“å‡ºã€‚ ç”±äºŽ log è¿ç®—ç¬¦ä¸ä¼šå½±å“å‡½æ•°çš„å•è°ƒæ€§ï¼Œæˆ‘ä»¬å¯¹ S è¿›è¡Œ log æ“ä½œã€‚å¦å¤–ï¼Œæˆ‘ä»¬å¸Œæœ› log(S) è¶Šå¤§è¶Šå¥½ï¼Œå³æ­£ç¡®ç±»åˆ«å¯¹åº”çš„ç›¸å¯¹æ¦‚çŽ‡è¶Šå¤§è¶Šå¥½ï¼Œé‚£ä¹ˆå°±å¯ä»¥å¯¹ log(S) å‰é¢åŠ ä¸ªè´Ÿå·ï¼Œæ¥è¡¨ç¤ºæŸå¤±å‡½æ•°ï¼š å¦‚ä½•é€‰æ‹©æŸå¤±å‡½æ•°ï¼Ÿ å¯¹äºŽå¼‚å¸¸ç‚¹çš„å¤„ç†æ˜¯ä¸€ä¸ªç»´åº¦ï¼Œæ¯”å¦‚L1 æŸå¤±å‡½æ•°å¤„ç†å¼‚å¸¸ç‚¹æ›´åŠ ç¨³å®šï¼Œç›¸å¯¹L2 æŸå¤±å‡½æ•°ã€‚ what? è¡¡é‡æ¨¡åž‹å¥½åçš„ functionï¼Œå¦‚æžœæ¨¡åž‹è¡¨çŽ°å¥½ï¼Œé‚£ä¹ˆloss åº”è¯¥æ˜¯å°ï¼›å¦‚æžœæ¨¡åž‹è¡¨çŽ°ä¸å¥½ï¼Œé‚£ä¹ˆloss åº”è¯¥æ˜¯å¤§çš„ã€‚ At its core, a loss function is incredibly simple: itâ€™s a method of evaluating how well your algorithm models your dataset. If your predictions are totally off, your loss function will output a higher number. If theyâ€™re pretty good, itâ€™ll output a lower number. As you change pieces of your algorithm to try and improve your model, your loss function will tell you if youâ€™re getting anywhere. Log Loss (Cross Entropy Loss) Cross-entropy loss, or log loss, measures the performance of a classification model whose output is a probability value between 0 and 1. Cross-entropy loss increases as the predicted probability diverges from the actual label. So predicting a probability of .012 when the actual observation label is 1 would be bad and result in a high loss value. A perfect model would have a log loss of 0. The graph above shows the range of possible loss values given a true observation (isDog = 1). As the predicted probability approaches 1, log loss slowly decreases. As the predicted probability decreases, however, the log loss increases rapidly. Log loss penalizes both types of errors, but especially those predictions that are confident and wrong! Cross-entropy and log loss are slightly different depending on context, but in machine learning when calculating error rates between 0 and 1 they resolve to the same thing. In binary classification, where the number of classes M equals 2, cross-entropy can be calculated as: $$- ( y \log ( y ) + ( 1 - y ) \log ( 1 - y ) )$$ If $ M&gt;$2 (i.e. multiclass classification), we calculate a separate loss for each class label per observation and sum the result. $$- \sum _ { c = 1 } ^ { M } y _ { o , c } \log \left( y _ { o , c } \right)$$ M - number of classes (dog, cat, fish)log - the natural logy - binary indicator (0 or 1) if class label c is the correct classification for observation o æƒ³è¦è¡¨è¾¾çš„æ˜¯ log loss æ˜¯ä»Ž Likelihood Lossï¼Œæ”¹è¿›è¿‡æ¥çš„ï¼Œæœ‰æ²¡æœ‰å‘çŽ°æœ€å¤§ä¼¼ç„¶çš„ç—•è¿¹ã€‚log loss è¡¨è¾¾å¼å¦‚ä¸‹ï¼š$$\begin{split}P(Y | X) &amp;= P(X_1 | Y) \times P(X_2 | Y) \times \dots \times P(X_n | Y) \times P(Y) = P(Y) \prod_{i}^{n} P(X_i | Y) \\&amp;\Rightarrow log(P(Y | X)) = log(\prod_{i}^{n} P(X_i | Y) \Rightarrow \sum_{i}^{n} log(P(X_i | Y))\end{split}$$äº¤å‰ç†µè¡¨è¾¾å¼ï¼š$$CE(\hat{y}, y) = - \sum_{i=1}^{n} y_i log(\hat{y}) + (1 - y_i) log(1 - \hat{y})$$ L2 è¿™ä¸¤ä¸ªloss function åœ¨è¿™é‡Œä»‹ç»è¿‡ï¼Œæ‰€ä»¥æœ¬åšå®¢ä¸­ç®€å•è¯´ä¸€ä¸‹ã€‚ L2 loss function is the square of the L2 norm of the difference between actual value and predicted value. It is mathematically similar to MSE, only do not have division byn, it is computed by $$ Loss = \sum _ { i = 1 } ^ { n } \left( y ^ { ( i ) } - \hat { y } ^ { ( i ) } \right) ^ { 2 }$$ Kullback Leibler (KL) Divergenceï¼ˆè®¡ç®—çš„æ˜¯ä¸¤ä¸ªåˆ†å¸ƒçš„é—®é¢˜ï¼‰KL Divergence, also known as relative entropy, information divergence/gain, is a measure of how one probability distribution diverges from a second expected probability distribution. KL divergence loss function is computed by$$D _ { K L } ( p | q ) = \sum _ { x } p ( x ) \log \frac { p ( x ) } { q ( x ) }$$ äº¤å‰ç†µçš„å®šä¹‰ï¼š$$H ( p , q ) = - \sum _ { x } p ( x ) \log q ( x )$$ä¸¤è€…çš„å…³ç³»æŽ¨å¯¼ï¼Œ$$\begin{split}D _ { K L } ( p | q ) &amp;= \sum _ { x } p ( x ) \log \frac { p ( x ) } { q ( x ) } \\&amp;= \sum _ { x } ( p ( x ) \log p ( x ) - p ( x ) \log q ( x ) ) \\&amp;= - H ( p ) - \sum _ { x } p ( x ) \log q ( x ) \\&amp;= - H ( p ) + H ( p , q )\end{split}$$æ‰€ä»¥è¯´ï¼Œ cross entropy ä¹Ÿæ˜¯å¯ä»¥å†™æˆè¿™æ ·ï¼š$$H ( p , q ) = D _ { K L } ( p | q ) + H ( p )$$ logistic loss å’Œ cross entropyçš„å…³ç³» å½“ $ p \in { y , 1 - y }$, $q \in { \hat { y } , 1 - \hat { y } }$ ï¼Œcross entropy å¯ä»¥å†™æˆ logistic loss: $$H ( p , q ) = - \sum _ { x } p ( x ) \log q ( x ) = - y \log \hat { y } - ( 1 - y ) \log ( 1 - \hat { y } )$$ äº¤å‰ç†µå‡½æ•°æ˜¯æ€Žä¹ˆæ¥çš„ï¼Ÿä»Žä¸Šé¢å¯ä»¥æ¸…æ¥šçš„äº†è§£åˆ°ï¼Œäº¤å‰ç†µå‡½æ•°åœ¨åˆ†ç±»é—®é¢˜ä¸Šæ˜¯ default çš„é€‰æ‹©ï¼Œé‚£ä¹ˆæˆ‘ä»¬æœ‰æ²¡æœ‰æ€è€ƒè¿‡ è¿™ä¸ªloss function çš„æ•°å­¦åŸºç¡€ ï¼Ÿæ˜¯æ€Žä¹ˆæ¥çš„å‘¢ï¼Ÿ çœŸå®žçš„æ ·æœ¬æ ‡ç­¾ä¸º [0, 1], åˆ†åˆ«è¡¨ç¤ºè´Ÿç±»å’Œæ­£ç±»ï¼Œæ¨¡åž‹æœ€ç»ˆä¼šç»è¿‡ä¸€ä¸ª sigmoid å‡½æ•°ï¼Œè¾“å‡ºä¸€ä¸ªæ¦‚çŽ‡å€¼ã€‚sigmoid å‡½æ•°çš„è¡¨è¾¾å¼å¦‚ä¸‹ï¼š$$g ( s ) = \frac { 1 } { 1 + e ^ { - s } }$$ æ‰€ä»¥sigmoid çš„è¾“å‡ºå€¼è¡¨ç¤º 1çš„æ¦‚çŽ‡ï¼š$$\hat { y } = P ( y = 1 | x )$$è¡¨ç¤º 0çš„æ¦‚çŽ‡ï¼š$$1 - \hat { y } = P ( y = 0 | x )$$ è¿›è€Œï¼Œä»Žæœ€å¤§ä¼¼ç„¶çš„è§’åº¦å‡ºå‘ï¼Œå°†ä¸Šé¢çš„ä¸¤ç§æƒ…å†µæ•´åˆèµ·æ¥ï¼š $$P ( y | x ) = \hat { y } ^ { y } \cdot ( 1 - \hat { y } ) ^ { 1 - y }$$ ä»Žå¦ä¸€ä¸ªè§’åº¦ä¹Ÿå¯ä»¥ç†è§£è¿™ä¸ªå…¬å¼ï¼Œåˆ†åˆ«ä»¤ y =0 å’Œy =1ï¼Œ å‘çŽ°ä¸¤ç§æƒ…å†µæ­£å¥½å¯¹åº”ç€ $P ( y = 0 | x ) = 1 - \hat { y }$ å’Œ $P ( y = 1 | x ) = \hat { y }$ã€‚ æˆ‘ä»¬åšçš„å°±æ˜¯æŠŠä¸Šé¢ä¸¤ç§æƒ…å†µç»™æ•´åˆèµ·æ¥äº†ã€‚ æŽ¥ä¸‹æ¥å¼•å…¥ log å‡½æ•°$$\log P ( y | x ) = \log \left( \hat { y } ^ { y } \cdot ( 1 - \hat { y } ) ^ { 1 - y } \right) = y \log \hat { y } + ( 1 - y ) \log ( 1 - \hat { y } )$$æˆ‘ä»¬å¸Œæœ›å…¬å¼è¶Šå¤§è¶Šå¥½ï¼Œåè¿‡æ¥ï¼Œå¸Œæœ› $\log \mathrm { P } ( \mathrm { y } | \mathrm { x } )$ è¶Šå°è¶Šå¥½ï¼ŒäºŽæ˜¯å¾—åˆ°äº†æœ€ç»ˆçš„ æŸå¤±å‡½æ•°ï¼š$$L = - [ y \log \hat { y } + ( 1 - y ) \log ( 1 - \hat { y } ) ]$$ ä¸Šé¢æ˜¯ å•ä¸ªæ ·æœ¬çš„æŸå¤±å‡½æ•°ï¼Œè®¡ç®—N ä¸ªæ ·æœ¬ï¼Œåªéœ€è¦å°†ä¸Šé¢çš„å…¬å¼å åŠ èµ·æ¥ã€‚$$L = - \sum _ { i = 1 } ^ { N } y ^ { ( i ) } \log \hat { y } ^ { ( i ) } + \left( 1 - y ^ { ( i ) } \right) \log \left( 1 - \hat { y } ^ { ( i ) } \right)$$ okï¼Œè¿™ä¸ªå°±æ˜¯äº¤å‰ç†µæŸå¤±å‡½æ•°å®Œæ•´çš„æŽ¨å¯¼è¿‡ç¨‹ã€‚ äºŒåˆ†ç±»ã€å¤šåˆ†ç±»å’Œå¤šæ ‡ç­¾é—®é¢˜çš„åŒºåˆ«äºŒåˆ†ç±»ã€å¤šåˆ†ç±»ä¸Žå¤šæ ‡ç­¾åˆ†ç±»é—®é¢˜ä½¿ç”¨ä¸åŒçš„æ¿€æ´»å‡½æ•°å’ŒæŸå¤±å‡½æ•°ã€‚ åŸºæœ¬æ¦‚å¿µäºŒåˆ†ç±»ï¼šåˆ¤åˆ«è¿™ä¸ªæ°´æžœæ˜¯è‹¹æžœè¿˜æ˜¯é¦™è•‰ã€‚å¤šåˆ†ç±»ï¼šå¯¹äºŽä¸€å †æ°´æžœï¼Œè¾¨åˆ«æ˜¯è‹¹æžœã€æ¢¨è¿˜æ˜¯æ©˜å­ã€‚ä¸€ä¸ªæ ·æœ¬åªèƒ½æœ‰ä¸€ä¸ªæ ‡ç­¾ã€‚å¤šæ ‡ç­¾åˆ†ç±»ï¼š ç»™æ¯ä¸€ä¸ªæ ·æœ¬ä¸€ç³»åˆ—çš„ç›®æ ‡æ ‡ç­¾ã€‚æ¯”å¦‚ä¸€ä¸ªæ–‡æ¡£æœ‰ä¸åŒçš„ç›¸å…³è¯é¢˜ï¼Œéœ€è¦åŠ ä¸Šä¸åŒçš„tag å¦‚å®—æ•™ã€æ”¿æ²»å’Œæ•™è‚²ã€‚ å¤šåˆ†ç±»é—®é¢˜å¸¸å¸¸æ˜¯å¯ä»¥è½¬æ¢æˆäºŒåˆ†ç±»é—®é¢˜è¿›è¡Œå¤„ç†çš„ï¼Œå¸¸è§æœ‰ä¸¤ç§ç­–ç•¥ã€‚ ä¸€å¯¹ä¸€çš„ç­–ç•¥ç»™å®šæ•°æ®é›†Dè¿™é‡Œæœ‰Nä¸ªç±»åˆ«ï¼Œè¿™ç§æƒ…å†µä¸‹å°±æ˜¯å°†è¿™äº›ç±»åˆ«ä¸¤ä¸¤é…å¯¹ï¼Œä»Žè€Œäº§ç”Ÿ $\frac{N*(N-1)}{2}$ä¸ªäºŒåˆ†ç±»ä»»åŠ¡ï¼Œåœ¨æµ‹è¯•çš„æ—¶å€™æŠŠæ ·æœ¬äº¤ç»™è¿™äº›åˆ†ç±»å™¨ï¼Œç„¶åŽè¿›è¡ŒæŠ•ç¥¨ã€‚ ä¸€å¯¹å…¶ä½™ç­–ç•¥å°†æ¯ä¸€æ¬¡çš„ä¸€ä¸ªç±»ä½œä¸ºæ­£ä¾‹ï¼Œå…¶ä½™ä½œä¸ºåä¾‹ï¼Œæ€»å…±è®­ç»ƒNä¸ªåˆ†ç±»å™¨ã€‚æµ‹è¯•çš„æ—¶å€™è‹¥ä»…æœ‰ä¸€ä¸ªåˆ†ç±»å™¨é¢„æµ‹ä¸ºæ­£çš„ç±»åˆ«åˆ™å¯¹åº”çš„ç±»åˆ«æ ‡è®°ä½œä¸ºæœ€ç»ˆåˆ†ç±»ç»“æžœï¼Œè‹¥æœ‰å¤šä¸ªåˆ†ç±»å™¨é¢„æµ‹ä¸ºæ­£ç±»ï¼Œåˆ™é€‰æ‹©ç½®ä¿¡åº¦æœ€å¤§çš„ç±»åˆ«ä½œä¸ºæœ€ç»ˆåˆ†ç±»ç»“æžœã€‚ åŒæ ·ï¼Œå¤šæ ‡ç­¾åˆ†ç±»å’ŒäºŒåˆ†ç±»é—®é¢˜ä¹Ÿæ˜¯æœ‰å…³ç³»çš„ã€‚ é¢ä¸´çš„é—®é¢˜ï¼š å›¾ç‰‡çš„æ ‡ç­¾æ•°ç›®ä¸æ˜¯å›ºå®šçš„ï¼Œæœ‰çš„æœ‰ä¸€ä¸ªæ ‡ç­¾ï¼Œæœ‰çš„æœ‰ä¸¤ä¸ªæ ‡ç­¾ï¼Œä½†æ ‡ç­¾çš„ç§ç±»æ€»æ•°æ˜¯å›ºå®šçš„ï¼Œæ¯”å¦‚ä¸º5ç±»ã€‚ è§£å†³è¯¥é—®é¢˜ï¼š é‡‡ç”¨äº†æ ‡ç­¾è¡¥é½çš„æ–¹æ³•ï¼Œå³ç¼ºå¤±çš„æ ‡ç­¾å…¨éƒ¨ä½¿ç”¨0æ ‡è®°ï¼Œè¿™æ„å‘³ç€ï¼Œä¸å†ä½¿ç”¨one-hotç¼–ç ã€‚ä¾‹å¦‚ï¼šæ ‡ç­¾ä¸ºï¼š-1,1,1,-1,1 ;-1è¡¨ç¤ºè¯¥ç±»æ ‡ç­¾æ²¡æœ‰ï¼Œ1è¡¨ç¤ºè¯¥ç±»æ ‡ç­¾å­˜åœ¨ã€‚ å¦‚ä½•è¡¡é‡æŸå¤±ï¼Ÿ è®¡ç®—å‡ºä¸€å¼ å›¾ç‰‡å„ä¸ªæ ‡ç­¾çš„æŸå¤±ï¼Œç„¶åŽå–å¹³å‡å€¼ã€‚ å¦‚ä½•è®¡ç®—ç²¾åº¦ è®¡ç®—å‡ºä¸€å¼ å›¾ç‰‡å„ä¸ªæ ‡ç­¾çš„ç²¾åº¦ï¼Œç„¶åŽå–å¹³å‡å€¼ã€‚ è¯¥å¤„ç†æ–¹æ³•çš„æœ¬è´¨ï¼šæŠŠä¸€ä¸ªå¤šæ ‡ç­¾é—®é¢˜ï¼Œè½¬åŒ–ä¸ºäº†åœ¨æ¯ä¸ªæ ‡ç­¾ä¸Šçš„äºŒåˆ†ç±»é—®é¢˜ã€‚ æŸå¤±å‡½æ•°çš„é€‰æ‹© åŸºäºŽé€»è¾‘å›žå½’çš„äºŒåˆ†ç±»é—®é¢˜ï¼šä½¿ç”¨é€»è¾‘å›žå½’äºŒåˆ†ç±»loss functionçš„æŽ¨å¯¼ï¼Œä¸Šé¢çš„ä¸€å°èŠ‚æ˜¯æœ‰è¯¦ç»†çš„ä»‹ç»çš„ã€‚ åŸºäºŽ Softmax çš„å¤šåˆ†ç±»é—®é¢˜ softmaxå±‚ä¸­çš„softmax å‡½æ•°æ˜¯logisticå‡½æ•°åœ¨å¤šåˆ†ç±»é—®é¢˜ä¸Šçš„æŽ¨å¹¿ï¼Œå®ƒå°†ä¸€ä¸ªNç»´çš„å®žæ•°å‘é‡åŽ‹ç¼©æˆä¸€ä¸ªæ»¡è¶³ç‰¹å®šæ¡ä»¶çš„Nç»´å®žæ•°å‘ã€‚åŽ‹ç¼©åŽçš„å‘é‡æ»¡è¶³ä¸¤ä¸ªæ¡ä»¶ï¼š å‘é‡ä¸­çš„æ¯ä¸ªå…ƒç´ çš„å¤§å°éƒ½åœ¨[0,1] å‘é‡æ‰€æœ‰å…ƒç´ çš„å’Œä¸º 1 å› æ­¤ï¼Œsoftmaxé€‚ç”¨äºŽå¤šåˆ†ç±»é—®é¢˜ä¸­å¯¹æ¯ä¸€ä¸ªç±»åˆ«çš„æ¦‚çŽ‡åˆ¤æ–­ï¼Œsoftmaxçš„å‡½æ•°å…¬å¼å¦‚ä¸‹ï¼š$$a _ { j } ^ { L } = \frac { e ^ { z _ { j } ^ { L } } } { \sum _ { k } e ^ { z _ { k } ^ { L } } }$$ åŸºäºŽ Softmax çš„å¤šåˆ†ç±»é—®é¢˜é‡‡ç”¨çš„æ˜¯ logä¼¼ç„¶ä»£ä»·å‡½æ•°ï¼ˆlog-likelihood cost functionï¼‰æ¥è§£å†³ã€‚å•ä¸ªæ ·æœ¬çš„ logä¼¼ç„¶ä»£ä»·å‡½æ•°çš„å…¬å¼ä¸ºï¼š$$C = - \sum _ { i } \left( y _ { i } \log a _ { i } \right)$$å…¶ä¸­ï¼Œ $y_i $è¡¨ç¤ºæ ‡ç­¾å‘é‡çš„ç¬¬ i ä¸ªåˆ†é‡ã€‚å› ä¸ºå¾€å¾€åªæœ‰ä¸€ä¸ªåˆ†é‡ä¸º 1 å…¶ä½™çš„åˆ†é‡éƒ½ä¸º 0ï¼Œæ‰€ä»¥å¯ä»¥åŽ»æŽ‰æŸå¤±å‡½æ•°ä¸­çš„æ±‚å’Œç¬¦å·ï¼ŒåŒ–ç®€ä¸ºï¼Œ $$C = - \ln a _ { j }$$å…¶ä¸­ï¼Œ$ a_j $æ˜¯å‘é‡ y ä¸­å–å€¼ä¸º 1 å¯¹åº”çš„ç¬¬ j ä¸ªåˆ†é‡çš„å€¼ã€‚ $$\begin{split}\operatorname { cost } \left( h _ { \theta } ( x ) , y \right) &amp;= - y _ { i } \log \left( h _ { \theta } ( x ) \right) - \left( 1 - y _ { i } \right) \log \left( 1 - h _ { \theta } ( x ) \right)$ \\C &amp;= - \sum _ { i } \left( y _ { i } \log a _ { i } \right)$\\\end{split}$$ ç†è®ºä¸Šéƒ½æ˜¯ä½¿ç”¨å¤šç±»äº¤å‰ç†µå‡½æ•°ï¼Œä½†æ˜¯åœ¨å®žçŽ°çš„æ—¶å€™ï¼Œæ·±åº¦å­¦ä¹ å·¥å…·keras æ˜¯æ”¯æŒä¸¤ç§å½¢å¼ï¼Œé’ˆå¯¹äºŽæ ‡ç­¾y çš„å½¢å¼ï¼Œä¸€ç§æ˜¯ sparse ä¸€ç§æ˜¯ denseåˆ†åˆ«å¯¹åº”çš„æ˜¯ one-hot å½¢å¼å’Œ label çš„å½¢å¼ã€‚ å› ä¸ºè¿™ä¸¤ä¸ªäº¤å‰ç†µæŸå¤±å‡½æ•°å¯¹åº”ä¸åŒçš„æœ€åŽä¸€å±‚çš„è¾“å‡ºã€‚ç¬¬ä¸€ä¸ªå¯¹åº”çš„æœ€åŽä¸€å±‚æ˜¯ sigmoidï¼Œç”¨äºŽäºŒåˆ†ç±»é—®é¢˜ï¼Œç¬¬äºŒä¸ªå¯¹åº”çš„æœ€åŽä¸€å±‚æ˜¯ softmaxï¼Œç”¨äºŽå¤šåˆ†ç±»é—®é¢˜ã€‚ä½†æ˜¯å®ƒä»¬çš„æœ¬è´¨æ˜¯ä¸€æ ·çš„ï¼Œè¯·çœ‹ä¸‹é¢çš„åˆ†æžã€‚ å¯ä»¥çœ‹ä¸€ä¸‹äº¤å‰ç†µå‡½æ•°çš„å®šä¹‰ï¼š $$-\int p ( x ) \log g ( x ) d x$$ äº¤å‰ç†µæ˜¯ç”¨æ¥æè¿°ä¸¤ä¸ªåˆ†å¸ƒçš„è·ç¦»çš„ï¼Œç¥žç»ç½‘ç»œè®­ç»ƒçš„ç›®çš„å°±æ˜¯ä½¿ $g(x)$ é€¼è¿‘$ p(x)$ã€‚ æ€»ç»“ åˆ†ç±»é—®é¢˜åç§° è¾“å‡ºå±‚ä½¿ç”¨æ¿€æ´»å‡½æ•° å¯¹åº”çš„æŸå¤±å‡½æ•° äºŒåˆ†ç±» sigmoid äºŒåˆ†ç±»äº¤å‰ç†µæŸå¤±å‡½æ•°ï¼ˆbinary_crossentropyï¼‰ å¤šåˆ†ç±» softmax å¤šç±»åˆ«äº¤å‰ç†µæŸå¤±å‡½æ•°ï¼ˆcategorical_crossentropyï¼‰ å¤šæ ‡ç­¾åˆ†ç±» sigmoidå‡½æ•° äºŒåˆ†ç±»äº¤å‰ç†µæŸå¤±å‡½æ•°ï¼ˆbinary_crossentropyï¼‰]]></content>
      <categories>
        <category>Deep learning</category>
      </categories>
      <tags>
        <tag>loss function</tag>
        <tag>Activation Function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç‰¹å¾å·¥ç¨‹]]></title>
    <url>%2F2018%2F06%2F29%2F%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[å…³äºŽç‰¹å¾å·¥ç¨‹çš„æ¦‚å¿µï¼Œç‰¹å¾ç¦»æ•£åŒ–ã€ç‰¹å¾ç”Ÿæˆã€ç»„åˆç‰¹å¾ã€ç‰¹å¾é€‰å–çš„æ–¹æ³•ã€‚ ç‰¹å¾ç”Ÿæˆæœºå™¨å­¦ä¹ çš„ä¸€å¤§ä»»åŠ¡åœ¨äºŽæ‰‹å·¥ create ç‰¹å¾ã€‚ç‰¹å¾ä¸»è¦æ¥æºæœ‰ä¸¤ä¸ªï¼Œä¸€ä¸ªç»Ÿè®¡å­¦çŸ¥è¯†ï¼Œä¸€ä¸ªè¯¥åœºæ™¯ä¸‹çš„ç‰¹å¾ã€‚å‰è€…å±žäºŽå¸¸è§„æ“ä½œï¼ŒåŽè€…éœ€è¦æœ‰å¯¹ä¸šåŠ¡é¢†åŸŸæ¯”è¾ƒç†Ÿæ‚‰çš„äº†è§£ã€‚åŽè€…ä¸¾ä¸ªä¾‹å­ï¼Œæ¯”å¦‚åœ¨è¡¡é‡ä¸ªäººä¿¡ç”¨çš„æ—¶å€™ï¼Œ days_employed / days_birth å°±æ˜¯ä¸€ä¸ªå±žäºŽé‡‘èžï¼ˆä¿é™©ï¼‰é¢†åŸŸçš„è¾ƒä¸ºç†Ÿæ‚‰ï¼Œæ‰èƒ½ç†è§£çš„ä¸€ä¸ªç‰¹å¾, è¿™ç§ç™¾åˆ†æ¯”ï¼Œå æ¯”çš„æ€æƒ³è¿˜æ˜¯éžå¸¸å¸¸è§çš„ã€‚å‰è€…åŒæ ·ä¸¾ä¸ªæ —å­ï¼Œå¯¹äºŽå­è¡¨ï¼ˆä¼ ç»Ÿæœºå™¨å­¦ä¹ è¿˜æ˜¯æœ‰å¾ˆå¤šæ¥è‡ªæ•°æ®åº“çš„ä¿¡æ¯çš„ï¼‰å¸¸ç”¨çš„æ“ä½œæ˜¯ aggregation æ“ä½œï¼ˆmin max sum variance meanï¼‰ç­‰èšåˆæ“ä½œï¼Œç„¶åŽå’Œä¸»è¡¨è¿›è¡Œè¿žæŽ¥ã€‚ä¸€èˆ¬æ¥è¯´å­è¡¨æ˜¯å¯ä»¥å¹¿æ³›çš„ä½¿ç”¨ aggregation æ“ä½œï¼Œä½†æ˜¯å¯¹äºŽä¸»è¡¨æ¥è¯´ï¼Œè¿™ä¸ªå°±å–å†³äºŽä¿¡æ¯æ˜¯ä»€ä¹ˆï¼Œç‰¹å¾æ˜¯ä»€ä¹ˆå†…å®¹ï¼Œèšåˆå‡½æ•°çš„æœ¬è´¨åœ¨äºŽâ€æ€»ç»“â€œï¼Œå°±æ˜¯ä½ æ“ä½œçš„å˜é‡æ˜¯å¦æœ‰å¿…è¦è¿™æ ·åšï¼Œçœ‹ä¸€ä¸‹æ•°æ®æ˜¯ä¸æ˜¯æµæ°´è´¦ã€‚ ç‰¹å¾ç¦»æ•£åŒ–è¿žç»­åŒ–ç‰¹å¾å°±æ˜¯ä¸€äº›ä¸å¯æžšä¸¾çš„æœ‰ç†æ•°ã€‚é‚£ä¹ˆä»€ä¹ˆæ˜¯ç¦»æ•£åŒ–ç‰¹å¾å‘¢ï¼Ÿ ç¦»æ•£åŒ–ç‰¹å¾å°±æ˜¯å¯æžšä¸¾çš„ç‰¹å¾ã€‚ç¦»æ•£åŒ–çš„ä½œç”¨æ˜¯æŠŠæ•°æ®å˜æˆå¯è®¡ç®—çŠ¶æ€ã€‚è€Œç‰¹å¾å·¥ç¨‹å°±æ˜¯ä»ŽåŽŸå§‹å­—æ®µä¸­æ ¹æ®ä¸šåŠ¡æå–å‡ºå¯¹æ¨¡åž‹æœ‰æ•ˆçš„ç‰¹å¾å‡ºæ¥ã€‚ åœ¨çº¿æ€§æ¨¡åž‹ä¸‹(w.x)ï¼Œwå·²ç»ç¡®å®šçš„æƒ…å†µä¸‹ï¼Œxçš„æŸä¸ªç‰¹å¾çš„å€¼æ˜¯20ï¼Œæˆ–è€…30ï¼Œw.xçš„å€¼ç›¸å·®æ˜¯å¾ˆå¤§çš„ï¼Œä½†æ˜¯å¾€å¾€20å²çš„äººè·Ÿ30å²çš„äººå¯¹åŒä¸€ä¸ªå¹¿å‘Šçš„å…´è¶£å·®è·ä¸ä¼šé‚£ä¹ˆå¤§ã€‚è¿žç»­ç‰¹å¾ç¦»æ•£åŒ–çš„åŸºæœ¬å‡è®¾ï¼Œæ˜¯é»˜è®¤è¿žç»­ç‰¹å¾ä¸åŒåŒºé—´çš„å–å€¼å¯¹ç»“æžœçš„è´¡çŒ®æ˜¯ä¸ä¸€æ ·çš„ã€‚ç¦»æ•£åŒ–å’Œè¿žç»­åŒ–æœ€å¤§çš„åŒºåˆ«æ˜¯ï¼Œå¯¹ä¸€ä¸ªå­—æ®µåšè¿žç»­åŒ–åŽçš„ç»“æžœå°±è¿˜åªæ˜¯ä¸€ä¸ªç‰¹å¾ï¼Œè€Œç¦»æ•£åŒ–åŽçš„è¿™ä¸€åˆ—æœ‰å¤šå°‘ä¸ªkey(å­—æ®µå¯èƒ½çš„å€¼)å°±ä¼šæŠ½å–å‡ºå¤šå°‘ä¸ªç‰¹å¾ã€‚å½“ç»è¿‡ç¦»æ•£åŒ–ä¹‹åŽï¼Œç‰¹å¾å„æœ‰å„çš„æƒé‡ï¼Œå½¼æ­¤ä¹‹é—´å°±æ²¡æœ‰å…³ç³»äº†ã€‚ æ¨¡åž‹æ˜¯ä½¿ç”¨ç¦»æ•£ç‰¹å¾è¿˜æ˜¯è¿žç»­ç‰¹å¾, å…¶å®žæ˜¯ä¸€ä¸ªâ€œæµ·é‡ç¦»æ•£ç‰¹å¾+ç®€å•æ¨¡åž‹â€ åŒ â€œå°‘é‡è¿žç»­ç‰¹å¾+å¤æ‚æ¨¡åž‹â€çš„æƒè¡¡ã€‚æ—¢å¯ä»¥ç¦»æ•£åŒ–ç”¨çº¿æ€§æ¨¡åž‹ï¼Œä¹Ÿå¯ä»¥ç”¨è¿žç»­ç‰¹å¾åŠ æ·±åº¦å­¦ä¹ ã€‚ å¸¸ç”¨çš„é€‰å–ç¦»æ•£ç‚¹çš„æ–¹æ³•ï¼šç­‰è·ç¦»ç¦»æ•£ï¼Œç­‰æ ·æœ¬ç¦»æ•£ã€ç”»å›¾è§‚å¯Ÿè¶‹åŠ¿å’Œå†³ç­–æ ‘æ¨¡åž‹(å¤©ç”Ÿå°±å¯ä»¥å¯¹è¿žç»­ç‰¹å¾åˆ†æ®µ)ã€‚ ç¦»æ•£åŒ–ï¼šå˜é‡åˆ†ç®±ï¼ˆåœ¨é£ŽæŽ§æ¨¡åž‹ä¸­æ˜¯è¿™æ ·è¿›è¡Œé˜è¿°çš„ï¼‰ï¼Œæ˜¯å¯¹äºŽè¿žç»­å˜é‡çš„ç¦»æ•£åŒ–çš„ä¸€ç§ç§°å‘¼ã€‚åˆ†ç®±çš„æ–¹å¼ï¼Œä¸€èˆ¬æœ‰ç­‰è·ç¦»åˆ†æ®µï¼Œç­‰æ·±åˆ†æ®µï¼ˆå…ˆç¡®å®šåˆ†æ®µæ•°é‡ï¼Œç„¶åŽä»¤æ¯ä¸ªåˆ†æ®µä¸­çš„æ•°æ®æ•°é‡å¤§è‡´ç›¸ç­‰ï¼‰å’Œæœ€ä¼˜åˆ†æ®µã€‚ åœ¨å·¥ä¸šç•Œï¼Œå¾ˆå°‘ç›´æŽ¥å°†è¿žç»­å€¼ä½œä¸ºç‰¹å¾å–‚ç»™é€»è¾‘å›žå½’æ¨¡åž‹ï¼Œè€Œæ˜¯å°†è¿žç»­ç‰¹å¾ç¦»æ•£åŒ–ä¸ºä¸€ç³»åˆ—0ã€1ç‰¹å¾äº¤ç»™é€»è¾‘å›žå½’æ¨¡åž‹ï¼Œè¿™æ ·åšçš„ä¼˜åŠ¿æœ‰ä»¥ä¸‹å‡ ç‚¹ï¼š å•å˜é‡ç¦»æ•£åŒ–ä¸ºNä¸ªåŽï¼Œæ¯ä¸ªå˜é‡æœ‰å•ç‹¬çš„æƒé‡ï¼Œåœ¨æ¿€æ´»å‡½æ•°çš„ä½œç”¨ä¸‹ç›¸å½“äºŽä¸ºæ¨¡åž‹å¢žåŠ äº†éžçº¿æ€§ï¼Œèƒ½å¤Ÿæå‡æ¨¡åž‹è¡¨è¾¾èƒ½åŠ›ï¼ŒåŠ å¤§æ‹Ÿåˆã€‚ ç¦»æ•£åŒ–åŽçš„ç‰¹å¾å¯¹å¼‚å¸¸æ•°æ®æœ‰å¾ˆå¼ºçš„é²æ£’æ€§ï¼šæ¯”å¦‚ä¸€ä¸ªç‰¹å¾æ˜¯å¹´é¾„&gt;30æ˜¯1ï¼Œå¦åˆ™0ã€‚å¦‚æžœç‰¹å¾æ²¡æœ‰ç¦»æ•£åŒ–ï¼Œä¸€ä¸ªå¼‚å¸¸æ•°æ®â€œå¹´é¾„300å²â€ä¼šç»™æ¨¡åž‹é€ æˆå¾ˆå¤§çš„å¹²æ‰°ï¼Œå› ä¸ºç‰¹å¾å€¼çš„å¼‚å¸¸ä¼šå¯¼è‡´æƒé‡ä¹Ÿå°±æ˜¯wçš„å€¼ä¹Ÿä¼šå¼‚å¸¸ã€‚ ä¸€å®šæœ‰åŒå­¦æ‹…å¿ƒç‰¹å¾è¿‡å¤šä¼šå¯¼è‡´è¿ç®—ç¼“æ…¢ï¼Œä½†æ˜¯LRæ˜¯çº¿æ€§æ¨¡åž‹ï¼Œæˆ‘ä»¬åœ¨å†…éƒ¨è®¡ç®—çš„æ—¶å€™æ˜¯å‘é‡åŒ–è®¡ç®—ï¼Œè€Œä¸æ˜¯å¾ªçŽ¯è¿­ä»£ã€‚ç¨€ç–å‘é‡å†…ç§¯ä¹˜æ³•è¿ç®—é€Ÿåº¦å¿«ï¼Œè®¡ç®—ç»“æžœæ–¹ä¾¿å­˜å‚¨ï¼Œå®¹æ˜“æ‰©å±•ã€‚ æ‰€ä»¥ä¸ç”¨æ‹…å¿ƒåƒGBDTç®—æ³•é‚£æ ·ï¼Œç‰¹å¾å¤šäº†å°±è·‘ä¸åŠ¨äº†(æˆ‘ä»¬éƒ½è¯´GBDTä¸èƒ½ç”¨ç¦»æ•£ç‰¹å¾ä¸æ˜¯å› ä¸ºå®ƒå¤„ç†ä¸äº†ç¦»æ•£ç‰¹å¾ï¼Œè€Œæ˜¯å› ä¸ºç¦»æ•£åŒ–ç‰¹å¾åŽä¼šäº§ç”Ÿç‰¹åˆ«å¤šçš„ç‰¹å¾ï¼Œå†³ç­–æ ‘çš„å¶å­èŠ‚ç‚¹è¿‡å¤šï¼ŒéåŽ†çš„æ—¶å€™å¤ªæ…¢äº†)ã€‚ æ‰€ä»¥æµ·é‡ç¦»æ•£ç‰¹å¾ï¼‹LRæ˜¯ä¸šå†…å¸¸è§çš„ä¸€ä¸ªåšæ³•ã€‚è€Œå°‘é‡è¿žç»­ç‰¹å¾+å¤æ‚æ¨¡åž‹æ˜¯å¦å¤–ä¸€ç§åšæ³•ï¼Œä¾‹å¦‚GBDTã€‚ å½“ç„¶ä¹Ÿå¯ä»¥é€šè¿‡æ·±åº¦å­¦ä¹ æ¥è¿›è¡Œç‰¹å¾é€‰æ‹©ï¼šç›®å‰è¿™ç§æ‰‹æ®µæ­£åœ¨éšç€æ·±åº¦å­¦ä¹ çš„æµè¡Œè€Œæˆä¸ºä¸€ç§æ‰‹æ®µï¼Œå°¤å…¶æ˜¯åœ¨è®¡ç®—æœºè§†è§‰é¢†åŸŸï¼ŒåŽŸå› æ˜¯æ·±åº¦å­¦ä¹ å…·æœ‰è‡ªåŠ¨å­¦ä¹ ç‰¹å¾çš„èƒ½åŠ›ï¼Œè¿™ä¹Ÿæ˜¯æ·±åº¦å­¦ä¹ åˆå«unsupervised feature learningçš„åŽŸå› ã€‚ä»Žæ·±åº¦å­¦ä¹ æ¨¡åž‹ä¸­é€‰æ‹©æŸä¸€ç¥žç»å±‚çš„ç‰¹å¾åŽå°±å¯ä»¥ç”¨æ¥è¿›è¡Œæœ€ç»ˆç›®æ ‡æ¨¡åž‹çš„è®­ç»ƒäº†ã€‚ å‚è€ƒæ–‡çŒ®:https://blog.csdn.net/lujiandong1/article/details/52412123 ç»„åˆç‰¹å¾å…ˆæ˜¯ç¦»æ•£åŒ–ï¼Œç„¶åŽæ˜¯ç‰¹å¾ç»„åˆã€‚äº¤å‰ä»Žç†è®ºä¸Šè€Œè¨€æ˜¯ä¸ºäº†å¼•å…¥ç‰¹å¾ä¹‹é—´çš„äº¤äº’ï¼Œä¹Ÿå³ä¸ºäº†å¼•å…¥éžçº¿æ€§ã€‚LR(é€»è¾‘å›žå½’ï¼‰åˆ†ç±»ç®—æ³•:å› ä¸ºçº¿æ€§å‡½æ•°çš„è¡¨è¾¾èƒ½åŠ›æœ‰é™ï¼Œæ‰€ä»¥æˆ‘ä»¬å¼•å…¥æ¿€æ´»å‡½æ•°å°±æ˜¯ç»™LRå¢žåŠ éžçº¿æ€§å…³ç³»ã€‚èƒ½è®©ä¸€æ¡ç›´çº¿å˜æˆæ›²çº¿ã€‚è¿™æ ·å¯ä»¥æ‹Ÿåˆå‡ºæ›´å¥½çš„æ•ˆæžœã€‚ï¼ˆä¹Ÿç”±æ­¤æ‰åŽäº†åŽæ¥è¯´çš„è¿‡æ‹Ÿåˆé—®é¢˜è€Œå¼•å…¥äº†æ­£åˆ™åŒ–è¶…å‚æ•°ï¼‰ LRæ¨¡åž‹ä¹‹æ‰€ä»¥å¾ˆå—æ¬¢è¿Žï¼Œä¸»è¦æ˜¯å› ä¸ºLRæ¨¡åž‹æœ¬è´¨æ˜¯å¯¹æ•°çº¿æ€§æ¨¡åž‹ï¼Œå®žçŽ°ç®€å•ï¼Œæ˜“äºŽå¹¶è¡Œï¼Œå¤§è§„æ¨¡æ‰©å±•æ–¹ä¾¿ï¼Œè¿­ä»£é€Ÿåº¦å¿«ï¼ŒåŒæ—¶ä½¿ç”¨çš„ç‰¹å¾æ¯”è¾ƒå¥½è§£é‡Šï¼Œé¢„æµ‹è¾“å‡ºåœ¨0ä¸Ž1ä¹‹é—´å¥‘åˆæ¦‚çŽ‡æ¨¡åž‹ã€‚ï¼ˆæ¨¡åž‹çš„å¯è§£é‡Šæ€§ä¸¾ä¾‹ï¼Œæ¯”å¦‚A-Bçš„æƒé‡æ¯”è¾ƒå¤§ï¼ŒAä»£è¡¨ç”¨æˆ·ï¼ŒBä»£è¡¨ç‰©å“ï¼Œé‚£ä¹ˆå¯ä»¥è®¤ä¸ºAæ˜¯å¯¹Bæ¯”è¾ƒæ„Ÿå…´è¶£çš„ï¼‰ä½†æ˜¯ï¼Œçº¿æ€§æ¨¡åž‹å¯¹äºŽéžçº¿æ€§å…³ç³»ç¼ºä¹å‡†ç¡®åˆ»ç”»ï¼Œç‰¹å¾ç»„åˆæ­£å¥½å¯ä»¥åŠ å…¥éžçº¿æ€§è¡¨è¾¾ï¼Œå¢žå¼ºæ¨¡åž‹çš„è¡¨è¾¾èƒ½åŠ›ã€‚å¦å¤–ï¼Œå¹¿å‘ŠLRä¸­ï¼ŒåŸºæœ¬ç‰¹å¾å¯ä»¥è®¤ä¸ºæ˜¯ç”¨äºŽå…¨å±€å»ºæ¨¡ï¼Œç»„åˆç‰¹å¾æ›´åŠ ç²¾ç»†ï¼Œæ˜¯ä¸ªæ€§åŒ–å»ºæ¨¡ï¼Œå› ä¸ºåœ¨è¿™ç§å¤§è§„æ¨¡ç¦»æ•£LRä¸­ï¼Œå•å¯¹å…¨å±€å»ºæ¨¡ä¼šå¯¹éƒ¨åˆ†ç”¨æˆ·æœ‰åï¼Œå¯¹æ¯ä¸€ç”¨æˆ·å»ºæ¨¡åˆæ•°æ®ä¸è¶³æ˜“è¿‡æ‹ŸåˆåŒæ—¶å¸¦æ¥æ¨¡åž‹æ•°é‡çˆ†ç‚¸ï¼Œæ‰€ä»¥åŸºæœ¬ç‰¹å¾+ç»„åˆç‰¹å¾å…¼é¡¾äº†å…¨å±€å’Œä¸ªæ€§åŒ–ã€‚ ä»Žç»Ÿè®¡çš„è§’åº¦è§£é‡Šï¼ŒåŸºæœ¬ç‰¹å¾ä»…ä»…æ˜¯çœŸå®žç‰¹å¾åˆ†å¸ƒåœ¨ä½Žç»´çš„æ˜ å°„ï¼Œä¸è¶³ä»¥æè¿°çœŸå®žçš„åˆ†å¸ƒï¼ŒåŠ å…¥ç‰¹å¾åœ¨é«˜ç»´ç©ºé—´æ‹ŸåˆçœŸå®žåˆ†å¸ƒï¼Œä½¿å¾—é¢„æµ‹æ›´åŠ å‡†ç¡®ã€‚ å¯»æ‰¾é«˜çº§ç‰¹å¾æœ€å¸¸ç”¨çš„æ–¹æ³•æœ‰ï¼šè‹¥å¹²é¡¹ç‰¹å¾åŠ å’Œï¼š æˆ‘ä»¬å‡è®¾ä½ å¸Œæœ›æ ¹æ®æ¯æ—¥é”€å”®é¢å¾—åˆ°ä¸€å‘¨é”€å”®é¢çš„ç‰¹å¾ã€‚ä½ å¯ä»¥å°†æœ€è¿‘çš„7å¤©çš„é”€å”®é¢ç›¸åŠ å¾—åˆ°ã€‚è‹¥å¹²é¡¹ç‰¹å¾ä¹‹å·®ï¼š å‡è®¾ä½ å·²ç»æ‹¥æœ‰æ¯å‘¨é”€å”®é¢ä»¥åŠæ¯æœˆé”€å”®é¢ä¸¤é¡¹ç‰¹å¾ï¼Œå¯ä»¥æ±‚ä¸€å‘¨å‰ä¸€æœˆå†…çš„é”€å”®é¢ã€‚è‹¥å¹²é¡¹ç‰¹å¾ä¹˜ç§¯ï¼š å‡è®¾ä½ æœ‰å•†å“ä»·æ ¼å’Œå•†å“é”€é‡çš„ç‰¹å¾ï¼Œé‚£ä¹ˆå°±å¯ä»¥å¾—åˆ°é”€å”®é¢çš„ç‰¹å¾ã€‚è‹¥å¹²é¡¹ç‰¹å¾é™¤å•†ï¼š å‡è®¾ä½ æœ‰æ¯ä¸ªç”¨æˆ·çš„é”€å”®é¢å’Œè´­ä¹°çš„å•†å“ä»¶æ•°ï¼Œé‚£ä¹ˆå°±æ˜¯å¾—åˆ°è¯¥ç”¨æˆ·å¹³å‡æ¯ä»¶å•†å“çš„é”€å”®é¢ã€‚ æ­£åˆ™åŒ–çœŸæ­£æµ‹è¯•ä¸€ä¸ªæ¨¡åž‹çš„ä¸æ˜¯ç®€å•ä¸Žå¦ï¼Œæ›´é‡è¦åœ¨äºŽå®ƒåœ¨é¢„æµ‹æ–°çš„æƒ…å†µæ—¶è¡¨çŽ°å¦‚ä½•ã€‚å°æƒé‡æ„å‘³ç€ç½‘ç»œçš„è¡Œä¸ºä¸ä¼šå› ä¸ºæˆ‘ä»¬éšæ„æ›´æ”¹äº†ä¸€äº›è¾“å…¥è€Œæ”¹å˜å¤ªå¤šã€‚ è¿™é‡Œæ˜¯éœ€è¦ä½¿ç”¨latex è¡¥å……ä¸€ä¸‹å…¬å¼çš„ã€‚å…¬å¼æ˜¯å¯ä»¥å‚è€ƒç€ä¸Šé¢è¿›è¡Œä¹¦å†™ã€‚ https://testerhome.com/topics/10811 è¿™æ˜¯æˆ‘ä»¬åŠ äº†æ­£åˆ™åŒ–ä¹‹åŽçš„æˆæœ¬å‡½æ•°ï¼Œå¯ä»¥çœ‹æˆ‘ä»¬åŽé¢åŠ å…¥äº†æ­£åˆ™åŒ– Î» çš„è¡¨è¾¾å¼æ¥å®Œå–„æˆæœ¬å‡½æ•°ã€‚ä¸ºä»€ä¹ˆåŠ å…¥Î»èƒ½å¤Ÿå‡è½»è¿‡æ‹Ÿåˆå‘¢ï¼Ÿç›´è§‚ä¸€ç‚¹çš„è§£é‡Šæ˜¯è®¾ç½®çš„Î»å€¼è¶Šå¤§ï¼Œé‚£ä¹ˆå‚æ•°wçš„å€¼å°±ä¼šè¢«åŽ‹ç¼©çš„è¶Šå°(åœ¨æ¢¯åº¦ä¸‹é™ä¸­, æ¯æ¬¡è¿­ä»£çš„æ­¥é•¿ï¼Œä¹Ÿå°±æ˜¯è¿™ä¸ªå…¬å¼w=w - å­¦ä¹ çŽ‡*æˆæœ¬å‡½æ•°å¯¹wçš„å¯¼æ•°ï¼Œ çŽ°åœ¨ç”±äºŽæˆæœ¬å‡½æ•°å¢žåŠ äº†æ­£åˆ™é¡¹ï¼Œä½¿å¾—Jå’Œwå˜å¾—æ•°å€¼ç›¸å…³äº†)ã€‚ å‡è®¾Î»è®¾ç½®çš„è¶³å¤Ÿå¤§ï¼Œé‚£ä¹ˆwä¼šæ— é™çš„è¶‹è¿‘äºŽ0. æŠŠå¤šéšè—å±‚çš„å•å…ƒçš„æƒé‡è®¾ç½®ä¸º0ä»¥åŽï¼Œé‚£ä¹ˆåŸºæœ¬ä¸Šå°±æ˜¯æ¶ˆé™¤æŽ‰äº†è¿™äº›å•å…ƒçš„ä½œç”¨ï¼Œè€Œä½¿å¾—ç½‘ç»œæ¨¡åž‹å¾—åˆ°ç®€åŒ–ï¼Œå°±åƒä¸‹é¢çš„å›¾ä¸€æ ·ã€‚ç”±äºŽæ­£åˆ™åŒ–çš„è®¾ç½®ï¼Œæ¶ˆé™¤äº†ä¸€äº›éšè—å•å…ƒçš„ä½œç”¨ã€‚è€Œä½¿å¾—æ•´ä¸ªæ¨¡åž‹è¶Šæ¥è¶ŠæŽ¥è¿‘äºŽçº¿æ€§åŒ–ï¼Œä¹Ÿå°±æ˜¯ä»Žä¸‹å›¾ä¸­çš„è¿‡æ‹Ÿåˆå¾€æ¬ æ‹Ÿåˆåè½¬ã€‚å½“ç„¶æˆ‘ä»¬æœ‰ä¸€ä¸ªé€‚åˆçš„Î»çš„å€¼ï¼Œèƒ½è®©æˆ‘ä»¬çš„æ‹ŸåˆçŠ¶æ€è¾¾åˆ°æœ€ä½³ã€‚æ‰€ä»¥æˆ‘ä»¬åœ¨è®­ç»ƒæ¨¡åž‹çš„æ—¶å€™ï¼Œå¾€å¾€éƒ½ä¼šæœ‰ä¸€ä¸ªï¼¬ï¼’æ­£åˆ™é¡¹çš„è¶…å‚æ•°éœ€è¦æˆ‘ä»¬è®¾ç½®ã€‚ feature selectionå®šä¹‰ï¼š feature selection çš„è¿‡ç¨‹å°±æ˜¯dimension reductionçš„è¿‡ç¨‹ã€‚å°±æ˜¯è¯´ç”±è¾ƒå¤šçš„æ•°æ®é›† æ˜ å°„åˆ° è¾ƒå°‘çš„æ•°æ®é›†ï¼Œè¿™ç§æ–¹å¼å°±å«åšé™ç»´ã€‚ Using dimensionality reduction techniques, of course. You can use this concept to reduce the number of features in your dataset without having to lose much information and keep (or improve) the modelâ€™s performance. ä¸ºä»€ä¹ˆ? ï¼ˆå¿…è¦æ€§åˆ†æžï¼‰ æ—¶é—´è§’åº¦ï¼Œç©ºé—´ï¼ˆå†…å­˜ï¼‰è§’åº¦ã€‚å‡å°‘å†—ä½™ä¿¡æ¯ï¼Œå°±å‡å°‘äº†æ¨¡åž‹åŽ»æ‹Ÿåˆâ€å™ªå£°â€œæ•°æ®çš„å¯èƒ½æ€§ã€‚ å¸¸è§çš„æœ‰ä»¥ä¸‹å‡ ç§æ–¹å¼ï¼š å¯ä»¥å½’ç»“æˆå‡ ç±»ï¼šç‰¹å¾æœ¬èº«ï¼ˆæ•°æ®ç¼ºçœå€¼æ¯”è¾ƒå¤§ï¼Œæ•°æ®çš„æ³¢åŠ¨æ€§æ¯”è¾ƒå°ï¼‰ï¼Œç‰¹å¾å’Œç‰¹å¾ä¹‹é—´ï¼ˆç‰¹å¾å…·æœ‰è¾ƒé«˜çš„ç›¸å…³æ€§ï¼Œä½¿ç”¨PCA è¿›è¡Œé™ç»´ï¼‰ï¼Œç‰¹å¾å’Œæœ€åŽçš„targetçš„å…³ç³»ï¼ˆæœºå™¨å­¦ä¹ æ¨¡åž‹çš„ feature importanceï¼Œå¡æ–¹åˆ†å¸ƒæ£€æµ‹ç‰¹å¾å’Œtarget çš„é‡è¦æ€§ï¼ŒPearson ç›¸å…³ç³»æ•°ï¼š-1 è¡¨ç¤ºè´Ÿç›¸å…³ï¼Œ0 è¡¨ç¤ºä¸ç›¸å…³ï¼Œ1è¡¨ç¤ºæ­£ç›¸å…³ï¼‰ã€‚ å¯ä»¥åˆ’åˆ†æˆä¸‰ç±»ï¼š ä¸€ã€ç‹¬ç«‹äºŽæ¨¡åž‹çš„ç‰¹å¾é€‰æ‹©ï¼ˆæ²¡æœ‰åœ¨å…¥æ¨¡æ—¶å€™è¿›è¡Œçš„ç‰¹å¾é€‰æ‹©ï¼‰æˆ–è€…å«åš filterï¼š ç§»é™¤ä½Žæ–¹å·®çš„ç‰¹å¾ (Removing features with low variance) å½“ç‰¹å¾å€¼éƒ½æ˜¯ç¦»æ•£åž‹å˜é‡çš„æ—¶å€™è¿™ç§æ–¹æ³•æ‰èƒ½ç”¨ï¼Œå¦‚æžœæ˜¯è¿žç»­åž‹å˜é‡ï¼Œå°±éœ€è¦å°†è¿žç»­å˜é‡ç¦»æ•£åŒ–ä¹‹åŽæ‰èƒ½ç”¨ã€‚ å•å˜é‡ç‰¹å¾é€‰æ‹© (Univariate feature selection) å¯¹äºŽåˆ†ç±»é—®é¢˜(yç¦»æ•£)ï¼Œå¯é‡‡ç”¨ï¼šå¡æ–¹æ£€éªŒï¼Œf_classif, mutual_info_classifï¼Œäº’ä¿¡æ¯å¯¹äºŽå›žå½’é—®é¢˜(yè¿žç»­)ï¼Œå¯é‡‡ç”¨ï¼šçš®å°”æ£®ç›¸å…³ç³»æ•°ï¼Œf_regression, mutual_info_regressionï¼Œæœ€å¤§ä¿¡æ¯ç³»æ•° è¿™é‡Œè¯´çš„æ˜¯ç‰¹å¾é€‰æ‹©ï¼Œä½†æ˜¯ä¸Šé¢è¯´çš„éƒ½æ˜¯é’ˆå¯¹â€œç‰¹å¾é‡è¦æ€§â€ è¿™ç‚¹å±•å¼€çš„ï¼Œä½†æ˜¯ä¸€ä¸ªç‰¹å¾å…¥æ¨¡æ˜¯ä¸€ä¸ªå¤æ‚çš„è¿‡ç¨‹ï¼Œéœ€è¦è€ƒè™‘çš„å› ç´ å¾ˆå¤šã€‚æ¯”å¦‚ï¼šå˜é‡çš„é¢„æµ‹èƒ½åŠ›ï¼Œå˜é‡ä¹‹é—´çš„ç›¸å…³æ€§ï¼Œå˜é‡çš„ç®€å•æ€§ï¼ˆå®¹æ˜“ç”Ÿæˆå’Œä½¿ç”¨ï¼‰ï¼Œå˜é‡çš„å¼ºå£®æ€§ï¼ˆä¸å®¹æ˜“è¢«ç»•è¿‡ï¼‰ï¼Œå˜é‡åœ¨ä¸šåŠ¡ä¸Šçš„å¯è§£é‡Šæ€§ï¼ˆè¢«æŒ‘æˆ˜æ—¶å¯ä»¥è§£é‡Šçš„é€šï¼‰ç­‰ç­‰ã€‚å½“ç„¶ï¼Œå…¶ä¸­æœ€ä¸»è¦å’Œæœ€ç›´æŽ¥çš„è¡¡é‡æ ‡å‡†æ˜¯å˜é‡çš„é¢„æµ‹èƒ½åŠ›ã€‚ å°¤å…¶æ˜¯å½“ä½ ä½¿ç”¨LR è¿™ç±»ç®€å•çš„æ¨¡åž‹çš„æ—¶å€™ï¼Œæ˜¯éœ€è¦é‡ç‚¹çš„åœ¨ç‰¹å¾ä¸Šä¸‹åŠŸå¤«çš„ï¼Œå› ä¸ºæ¨¡åž‹æ˜¯çº¿æ€§çš„ï¼Œæ¯”è¾ƒç®€å•ï¼Œå¼•å…¥ç‰¹å¾ï¼ŒåŠ å…¥éžçº¿æ€§ï¼Œç„¶åŽæ‰èƒ½æ›´å¥½çš„è¡¨è¾¾å®žé™…é—®é¢˜ã€‚ äºŒã€åŸºäºŽæ¨¡åž‹é€‰æ‹©çš„ç‰¹å¾æŽ’åº æœ‰äº›æœºå™¨å­¦ä¹ æ–¹æ³•æœ¬èº«å°±å…·æœ‰å¯¹ç‰¹å¾è¿›è¡Œæ‰“åˆ†çš„æœºåˆ¶ï¼Œæˆ–è€…å¾ˆå®¹æ˜“å°†å…¶è¿ç”¨åˆ°ç‰¹å¾é€‰æ‹©ä»»åŠ¡ä¸­ï¼Œä¾‹å¦‚å›žå½’æ¨¡åž‹ï¼ŒSVMï¼Œå†³ç­–æ ‘ï¼Œéšæœºæ£®æž—ç­‰ç­‰ã€‚è¿™ç§æ–¹æ³•çš„æ€è·¯æ˜¯ç›´æŽ¥ä½¿ç”¨ä½ è¦ç”¨çš„æœºå™¨å­¦ä¹ ç®—æ³•ï¼Œé’ˆå¯¹ æ¯ä¸ªå•ç‹¬çš„ç‰¹å¾ å’Œ å“åº”å˜é‡å»ºç«‹é¢„æµ‹æ¨¡åž‹ã€‚å‡å¦‚ ç‰¹å¾ å’Œ å“åº”å˜é‡ ä¹‹é—´çš„å…³ç³»æ˜¯éžçº¿æ€§çš„ï¼Œå¯ä»¥ç”¨åŸºäºŽæ ‘çš„æ–¹æ³•(å†³ç­–æ ‘ã€éšæœºæ£®æž—)ã€æˆ–è€… æ‰©å±•çš„çº¿æ€§æ¨¡åž‹ ç­‰ã€‚ ä¸‰ã€æ— ç›‘ç£çš„æ¨¡åž‹é€‰æ‹© èšç±»ï¼Œå¯ä»¥ä»Žé™ç»´çš„è§’åº¦ç†è§£ã€‚å¯ä»¥åœ¨æœºå™¨å­¦ä¹ ç®—æ³•ä¸­çš„importance ä¸æ˜¯å¾ˆå¤§ï¼Œå®¹æ˜“è¢«å¿½ç•¥çš„ç‰¹å¾ã€‚ Principal Component Analysis (PCA)ä¸ºä»€ä¹ˆè¦è¿›è¡Œé™ç»´æ•°æ®çš„å¤„ç†ï¼Ÿ å¯ä»¥ä»Ž è®¡ç®—å’Œå­˜å‚¨çš„è§’åº¦åˆ†æžï¼Œè¿˜å¯ä»¥ä»Žæ¨¡åž‹å’Œæ•°æ®çš„è§’åº¦åˆ†æžã€‚ è¿™ä¸ªå±žäºŽä¸€å¥è¯çš„çš„æ€æƒ³ï¼šPCAçš„é—®é¢˜å…¶å®žæ˜¯ä¸€ä¸ªåŸºçš„å˜æ¢ï¼Œä½¿å¾—å˜æ¢åŽçš„æ•°æ®æœ‰ç€æœ€å¤§çš„æ–¹å·®ã€‚ pca çš„å‡è®¾ï¼šè¿™ä¸ªè¯´å¾—å¾ˆæ¸…æ¥šï¼Œhigher dimensional space is mapped to lower dimension, ç„¶åŽè¿™ç§åœ¨lower dimensional ä¸­æ•°æ®çš„varianceåº”è¯¥æ˜¯ä¿æŒmaxçš„ã€‚It works on a condition that while the data in a higher dimensional space is mapped to data in a lower dimension space, the variance of the data in the lower dimensional space should be maximum. å°±æ˜¯éœ€è¦ç†è§£è¿™ä¸ªä¸»æˆåˆ†æ˜¯ä¸æ–­çš„ç”Ÿæˆçš„ï¼Œåœ¨å‰è€…çš„åŸºç¡€ä¹‹ä¸Šç”Ÿæˆçš„ã€‚below are some of the key points you should know about PCA before proceeding further: A principal component is a linear combination of the original variables Principal components are extracted in such a way that the first principal component explains maximum variance in the dataset Second principal component tries to explain the remaining variance in the dataset and is uncorrelated to the first principal component Third principal component tries to explain the variance which is not explained by the first two principal components and so on The first component is the most important one, followed by the second, then the third, and so on. å¦‚ä½•åŽ»ç†è§£PCA é™ç»´ï¼ŸPCA é€šè¿‡çº¿æ€§å˜æ¢å°†åŽŸå§‹æ•°æ®å˜æ¢æˆä¸€ç»„å„ç»´åº¦çº¿æ€§æ— å…³çš„è¡¨ç¤ºï¼Œå¯ä»¥ç”¨äºŽæå–æ•°æ®çš„ä¸»è¦ç‰¹å¾åˆ†é‡ï¼Œå°†ç”¨äºŽé«˜çº¬æ•°æ®çš„é™ç»´ã€‚æˆ‘ä»¬æœŸå¾…çš„æ˜¯é™ç»´çš„åŒæ—¶å°†ä¿¡æ¯çš„æŸå¤±å°½é‡é™ä½Žã€‚ çŸ©é˜µç›¸ä¹˜çš„æ„ä¹‰ï¼šå°†å³è¾¹çŸ©é˜µä¸­çš„æ¯ä¸€åˆ—åˆ—å‘é‡å˜æ¢åˆ°å·¦è¾¹çŸ©é˜µä¸­æ¯ä¸€è¡Œè¡Œå‘é‡ä¸ºåŸºæ‰€è¡¨ç¤ºçš„å‘é‡ç©ºé—´ä¸­åŽ»ã€‚æ›´åŠ æŠ½è±¡çš„è¯´ï¼Œä¸€ä¸ªçŸ©é˜µå¯ä»¥è¡¨ç¤ºä¸€ç§çº¿æ€§å˜æ¢ã€‚ æˆ‘ä»¬å¸Œæœ›æŠ•å½±åŽæŠ•å½±å€¼å°½å¯èƒ½åˆ†æ•£ï¼Œè€Œè¿™ç§åˆ†æ•£ç¨‹åºï¼Œå¯ä»¥ç”¨æ•°å­¦ä¸­çš„æ–¹å·®è¿›è¡Œè¡¨ç¤ºã€‚ PCA ç®—æ³•æ­¥éª¤ å‡è®¾åŽŸå§‹æ•°æ®æŒ‰åˆ—ç»„æˆnè¡Œmåˆ—çŸ©é˜µX å°†Xçš„æ¯ä¸€è¡Œï¼ˆä»£è¡¨ä¸€ä¸ªå±žæ€§å­—æ®µï¼‰è¿›è¡Œé›¶å‡å€¼åŒ–ï¼Œå³å‡åŽ»è¿™ä¸€è¡Œçš„å‡å€¼ æ±‚å‡ºåæ–¹å·®çŸ©é˜µ$C=\frac{1}{m}XX^\mathsf{T}$ æ±‚å‡ºåæ–¹å·®çŸ©é˜µçš„ç‰¹å¾å€¼åŠå¯¹åº”çš„ç‰¹å¾å‘é‡ å°†ç‰¹å¾å‘é‡æŒ‰å¯¹åº”ç‰¹å¾å€¼å¤§å°ä»Žä¸Šåˆ°ä¸‹æŒ‰è¡ŒæŽ’åˆ—æˆçŸ©é˜µï¼Œå–å‰kè¡Œç»„æˆçŸ©é˜µP $Y=PX$å³ä¸ºé™ç»´åˆ°kç»´åŽçš„æ•°æ® SVDSVD decomposes the original variables into three constituent matrices. It is essentially used to remove redundant features from the dataset. It uses the concept of Eigenvalues and Eigenvectors to determine those three matrices. We will not go into the mathematics of it due to the scope of this article, but letâ€™s stick to our plan, i.e. reducing the dimensions in our dataset. $$\operatorname { Data } _ { m \times n } = U _ { m \times m } \Sigma _ { m \times n } V _ { n \times n } ^ { T }$$SVDå°†åŽŸå§‹çš„æ•°æ®é›†çŸ©é˜µDataåˆ†è§£æˆä¸‰ä¸ªçŸ©é˜µï¼šUã€Sigmaã€VTï¼Œå¦‚æžœåŽŸå§‹çŸ©é˜µæ˜¯mè¡Œnåˆ—ï¼Œé‚£ä¹ˆUã€Sigmaå’ŒVTåˆ†åˆ«å°±æ˜¯mè¡Œmåˆ—ã€mè¡Œnåˆ—ã€nè¡Œnåˆ—ã€‚æ¯”è¾ƒå€¼å¾—ä¸€æçš„æ˜¯çŸ©é˜µSigmaï¼Œè¯¥çŸ©é˜µåªæœ‰å¯¹è§’å…ƒç´ ï¼Œå…¶ä»–å…ƒç´ å‡ä¸º0ï¼Œæœ‰ä¸€ä¸ªæƒ¯ä¾‹æ˜¯ï¼šSigmaçš„å¯¹è§’å…ƒç´ æ˜¯ä»Žå¤§åˆ°å°æŽ’åˆ—çš„ã€‚è¿™äº›å¯¹è§’å…ƒç´ å°±ç§°ä¸ºå¥‡å¼‚å€¼. PCA æ˜¯æ–¹é˜µæ˜¯ $ m^2 $ æ“ä½œï¼Œé‚£ä¹ˆSVD æ˜¯ $mn$ å°±æ˜¯æ›´åŠ å¹¿æ³›çš„çŸ©é˜µæ“ä½œã€‚ ç‰¹å¾åˆ†è§£åªèƒ½åˆ†è§£æ–¹é˜µï¼Œå¥‡å¼‚å€¼åˆ†è§£å¯ä»¥åˆ†è§£ä»»æ„çŸ©é˜µï¼Œpcaä¸­çš„ç‰¹å¾åˆ†è§£é€šå¸¸ä¼šä½¿ç”¨svdã€‚ï¼ˆæ–¹é˜µæ˜¯ä¸€ç§ç‰¹æ®Šçš„çŸ©é˜µï¼Œå½“è¡Œæ•°å’Œåˆ—æ•°ç›¸åŒçš„æ—¶å€™å°±å«åšæ–¹é˜µï¼‰ æŠ•å½±ä¹Ÿæ˜¯ä¸€ç§é™ç»´æ‰‹æ®µè¿™ç§æ€æƒ³çœŸçš„æ˜¯æœæ°”ï¼Œè™½ç„¶æˆ‘ä¹Ÿä¸æ˜¯å¾ˆæ‡‚ï¼Œä½†æ˜¯æ€æƒ³æ˜¯å¾ˆå¥½çš„By projecting one vector onto the other, dimensionality can be reduced. å½“æŠ•å½±åˆ°å¦ä¸€ä¸ªå¹³é¢çš„æ—¶å€™ï¼ŒåŽŸæ¥çš„å¹³é¢ç»´åº¦å°±æ¶ˆå¤±äº†ï¼Œæ‰€ä»¥åªå‰©ä¸‹äº†æŠ•å½±é¢çš„ç»´åº¦ã€‚ T-sneå°±æ˜¯æŒ‡å‡º t-sne è¿™ä¸ªå¯ä»¥éžçº¿æ€§é™ç»´ã€‚æœ‰local approaches å’Œ global approaches ä¸¤ç§æ–¹å¼ï¼Œæˆ‘å¤§æ¦‚çš„ç†è§£å°±æ˜¯ï¼šç±»ä¹‹é—´è¿˜èƒ½å°½å¯èƒ½çš„è¿œç¦»ï¼Œç±»å†…ä¿æŒå·®å¼‚æ€§ã€‚ï¼ˆä¸çŸ¥é“å¯¹ä¸å¯¹ï¼‰So far we have learned that PCA is a good choice for dimensionality reduction and visualization for datasets with a large number of variables. But what if we could use something more advanced? What if we can easily search for patterns in a non-linear way? t-SNE is one such technique. There are mainly two types of approaches we can use to map the data points:Local approaches : They maps nearby points on the manifold to nearby points in the low dimensional representation.Global approaches : They attempt to preserve geometry at all scales, i.e. mapping nearby points on manifold to nearby points in low dimensional representation as well as far away points to far away points. LDAï¼ˆæœ‰ç›‘ç£ï¼‰å’Œä¸Šé¢æœ€å¤§çš„åŒºåˆ«åœ¨äºŽ LDA æ˜¯æœ‰ç›‘ç£çš„ï¼ŒLDAè¯•å›¾è®©ä¸åŒç±»åˆ«æ ·æœ¬ä¹‹é—´çš„è·ç¦»æœ€å¤§ï¼ŒåŒæ—¶è®©ç›¸åŒç±»åˆ«æ ·æœ¬ä¹‹é—´çš„è·ç¦»æœ€å°ã€‚ç®€å•æ¥è¯´LDAæ˜¯ä¸ºäº†ä½¿é™ç»´åŽçš„æ•°æ®ç‚¹å°½å¯èƒ½çš„å¯åˆ†ã€‚ ä¸Šå›¾ä¸­å›½æä¾›äº†ä¸¤ç§æŠ•å½±æ–¹å¼ï¼Œå“ªä¸€ç§èƒ½æ›´å¥½çš„æ»¡è¶³æˆ‘ä»¬çš„æ ‡å‡†å‘¢ï¼Ÿä»Žç›´è§‚ä¸Šå¯ä»¥çœ‹å‡ºï¼Œå³å›¾è¦æ¯”å·¦å›¾çš„æŠ•å½±æ•ˆæžœå¥½ï¼Œå› ä¸ºå³å›¾çš„é»‘è‰²æ•°æ®å’Œè“è‰²æ•°æ®å„ä¸ªè¾ƒä¸ºé›†ä¸­ï¼Œä¸”ç±»åˆ«ä¹‹é—´çš„è·ç¦»æ˜Žæ˜¾ã€‚å·¦å›¾åˆ™åœ¨è¾¹ç•Œå¤„æ•°æ®æ··æ‚ã€‚ä»¥ä¸Šå°±æ˜¯LDAçš„ä¸»è¦æ€æƒ³äº†ï¼Œå½“ç„¶åœ¨å®žé™…åº”ç”¨ä¸­ï¼Œæˆ‘ä»¬çš„æ•°æ®æ˜¯å¤šä¸ªç±»åˆ«çš„ï¼Œæˆ‘ä»¬çš„åŽŸå§‹æ•°æ®ä¸€èˆ¬ä¹Ÿæ˜¯è¶…è¿‡äºŒç»´çš„ï¼ŒæŠ•å½±åŽçš„ä¹Ÿä¸€èˆ¬ä¸æ˜¯ç›´çº¿ï¼Œè€Œæ˜¯ä¸€ä¸ªä½Žç»´çš„è¶…å¹³é¢ è¿™ä¸ªæ˜¯å…³äºŽè¯¥ç®—æ³•çš„ä¸€ä¸ªè®²è§£ï¼Œ å¦‚æžœå¯¹äºŽæ­¥éª¤æ„Ÿå…´è¶£çš„è¯ã€‚ PCA vs. LDALDAç”¨äºŽé™ç»´ï¼Œå’ŒPCAæœ‰å¾ˆå¤šç›¸åŒï¼Œä¹Ÿæœ‰å¾ˆå¤šä¸åŒçš„åœ°æ–¹ï¼Œå› æ­¤å€¼å¾—å¥½å¥½çš„æ¯”è¾ƒä¸€ä¸‹ä¸¤è€…çš„é™ç»´å¼‚åŒç‚¹ã€‚ é¦–å…ˆæˆ‘ä»¬çœ‹çœ‹ç›¸åŒç‚¹ï¼š 1ï¼‰ä¸¤è€…å‡å¯ä»¥å¯¹æ•°æ®è¿›è¡Œé™ç»´ã€‚ 2ï¼‰ä¸¤è€…åœ¨é™ç»´æ—¶å‡ä½¿ç”¨äº†çŸ©é˜µç‰¹å¾åˆ†è§£çš„æ€æƒ³ã€‚ 3ï¼‰ä¸¤è€…éƒ½å‡è®¾æ•°æ®ç¬¦åˆé«˜æ–¯åˆ†å¸ƒã€‚æˆ‘ä»¬æŽ¥ç€çœ‹çœ‹ä¸åŒç‚¹ï¼š 1ï¼‰LDAæ˜¯æœ‰ç›‘ç£çš„é™ç»´æ–¹æ³•ï¼Œè€ŒPCAæ˜¯æ— ç›‘ç£çš„é™ç»´æ–¹æ³• 2ï¼‰LDAé™ç»´æœ€å¤šé™åˆ°ç±»åˆ«æ•°k-1çš„ç»´æ•°ï¼Œè€ŒPCAæ²¡æœ‰è¿™ä¸ªé™åˆ¶ã€‚ 3ï¼‰LDAé™¤äº†å¯ä»¥ç”¨äºŽé™ç»´ï¼Œè¿˜å¯ä»¥ç”¨äºŽåˆ†ç±»ã€‚ 4ï¼‰LDAé€‰æ‹©åˆ†ç±»æ€§èƒ½æœ€å¥½çš„æŠ•å½±æ–¹å‘ï¼Œè€ŒPCAé€‰æ‹©æ ·æœ¬ç‚¹æŠ•å½±å…·æœ‰æœ€å¤§æ–¹å·®çš„æ–¹å‘ã€‚ å½“ç±»åˆ«ç‰¹åˆ«å¤šçš„æ—¶å€™ï¼Œæ¯ä¸ªç±»ä¸­çš„æ ·æœ¬å°±è¶Šå°‘ï¼Œæ­¤æ—¶æ›´åŠ é€‚åˆä½¿ç”¨PCAè€Œä¸æ˜¯LDAã€‚ t-SNEPCAå’Œ t-SNEçš„backgroundï¼š æˆ‘ä»¬æœ‰ä¸€å †æ•°æ®å¹¶ä¸”æƒ³è¦çŸ¥é“è¿™äº›æ•°æ® â€œlooks likeâ€ï¼Œ ç„¶åŽå»ºç«‹äº†ä¸€ä¸ªâ€mapâ€ï¼Œä½¿è¿™äº›æ•°æ®æŠ•å½±åˆ°äº†äºŒç»´æˆ–è€…ä¸‰ç»´å¹³é¢ä¸Šã€‚ä½†æ˜¯PCA æ˜¯çº¿æ€§ mappingï¼Œ PCA learns a linear mapping, which is very restrictive. PCA focuses on preserving large pairwise distances.å¯¹äºŽ t-SNE çš„å®šä¹‰compute pairwise similarities between data with normalized Gaussian kernel è®¡ç®—æ­¥éª¤ åœ¨é«˜çº¬è®¡ç®—ä¸¤ç‚¹ with normalized Gaussian kernel(é«˜æ–¯åˆ†å¸ƒ$$p_{i,j}=\frac{\exp (-|x_{i}-x_{j}|^{2} / 2 \sigma^{2})}{\sum_{k} \sum_{l \neq k} \exp (-|x_{k}-x_{l}|^{2} / 2 \sigma^{2})}$$ åœ¨ä½Žç»´è®¡ç®—ä¸¤ç‚¹ï¼ˆä½¿ç”¨ normalized Student-t similarities in the t-SNE mapï¼‰$$q_{i,j}=\frac{(1+\overline{|} y_{i}-y_{j} |^{2})^{-1}}{\sum_{k} \sum_{l \neq k}(1+|y_{k}-y_{l}|^{2})^{-1}}$$ è®¡ç®—KL æ•£åº¦ï¼ˆå°½å¯èƒ½çš„æœ€å°åŒ–ä¸¤è€…ä¹‹é—´çš„å·®å¼‚ï¼Œ klå°½å¯èƒ½çš„å°ï¼‰$$K L(P | Q)=\sum_{i} \sum_{j \neq i} p_{i j} \log \frac{p_{i j}}{q_{i j}}$$ ä¸ºä»€ä¹ˆé€‰æ‹© KL divergence? The KL divergence preserves local data structureï¼š å¦‚æžœåœ¨é«˜ç»´åº¦ pä¸­ç›¸å·®å¤§ï¼Œä½†æ˜¯åœ¨ä½Žç»´q ä¸­ç›¸å·®å°ï¼Œé‚£ä¹ˆkl çš„å€¼éžå¸¸å¤§ã€‚å¦‚æžœå†é«˜çº¬åº¦p ç›¸å·®å°ï¼Œä½†æ˜¯åœ¨ä½Žçº¬åº¦ç›¸å·®å¤§ï¼Œé‚£ä¹ˆkl çš„å€¼å°±éžå¸¸å°ã€‚æ‰€ä»¥è¯´å°½å¯èƒ½ä¿å­˜äº† local informationã€‚ é™ç»´å¿…ç„¶å¸¦æ¥ä¿¡æ¯æŸå¤±ï¼Œè¿™é‡Œæ›´åŠ ä¿å­˜çš„æ˜¯å±€éƒ¨ä¿¡æ¯ï¼Œé‚£ä¹ˆå¿…ç„¶æŸå¤±çš„å…¨å±€ä¿¡æ¯ã€‚è€Œ t åˆ†å¸ƒèƒ½å¤Ÿæ”¾å¤§è¿™ç§å¯†åº¦ï¼Œå› ä¸ºt åˆ†å¸ƒæ›´åŠ é•¿å°¾ã€‚ è¡¥å……çŸ¥è¯†ç‚¹ï¼ˆtåˆ†å¸ƒå’Œå¡æ–¹åˆ†å¸ƒï¼‰ å…³äºŽ $t$ åˆ†å¸ƒï¼Œ å‡è®¾ $X \sim N(0, 1) $ ï¼Œ $Y \sim \chi^{2}(n)$ ï¼Œé‚£ä¹ˆ $ Z=\frac{X}{\sqrt{Y / n}} $ çš„åˆ†å¸ƒå°±è¢«ç§°ä¸ºè‡ªç”±åº¦ä¸º $n$ çš„ $t$ åˆ†å¸ƒï¼Œ è®°åš $Z \sim t(n)$ã€‚ ä½†è‡ªç”±åº¦$n$ è¶Šå¤§ï¼Œé‚£ä¹ˆè¶Šæ˜¯æŽ¥è¿‘æ­£å¤ªåˆ†å¸ƒã€‚ä¸€èˆ¬æ¥è¯´ $t$ åˆ†å¸ƒæ¯” æ­£å¤ªåˆ†å¸ƒæ›´åŠ é•¿å°¾ã€‚å¦‚æžœæ˜¯æ­£å¤ªåˆ†å¸ƒï¼Œé‚£ä¹ˆå°±å¯ä»¥ä½¿ç”¨ä¸­å¿ƒæžé™å®šç†ï¼Œä½†æ˜¯ $t$ åˆ†å¸ƒå°±ä¸å¯ä»¥äº†ã€‚$t$ åˆ†å¸ƒä¹Ÿè¢«ç§°ä¸º å­¦ç”Ÿt åˆ†å¸ƒã€‚ è‹¥ $k$ä¸ªéšæœºå˜é‡ $Z_1, Z_2, â€¦ Z_n$æ˜¯ç›¸äº’ç‹¬ç«‹ï¼Œç¬¦åˆæ ‡å‡†æ­£æ€åˆ†å¸ƒçš„éšæœºå˜é‡ï¼ˆæ•°å­¦æœŸæœ›ä¸º0ã€æ–¹å·®ä¸º1ï¼‰ï¼Œåˆ™éšæœºå˜é‡ $Z$çš„å¹³æ–¹å’Œ$$X=\sum_{i=1}^{k} Z_{i}^{2}$$è¢«ç§°ä¸ºè‡ªç”±åº¦ä¸º $k$ çš„å¡æ–¹åˆ†å¸ƒï¼Œ è®°åš $X \sim \chi^{2}(k)$ã€‚ t-sne æ—¶é—´å¤æ‚åº¦ $n^2$ naive implementations are quadratic in the number of data points å¯ä»¥è¢«ç”¨æ¥åšDo Use t-SNE to get some qualitative hypotheses on what your features capture è¿™ä¸ªæ˜¯å®šæ€§åˆ†æž åœ¨è¾“å…¥å’Œè¾“å‡ºå½¢å¼ä¸Šå¯ä»¥ more creative ä¸å¯ä»¥è¢«ç”¨æ¥ Donâ€™t ä¸æ˜¯è¯æ˜Žä½ çš„ç†è®ºçš„å·¥å…· assign meaning to distance across empty spaceï¼ˆæ³¨æ„è¿™ä¸ªæ˜¯å±€éƒ¨çš„ç‰¹å¾ï¼Œnot å…¨å±€çš„ä¿¡æ¯ï¼‰ think that t-sne will help you find outlier, or assign meaning to point densities in cluster forget the scale (perplexity) mattersï¼ˆ you can think of perplexity as the â€œeffectiveâ€ number of nearest neighborsï¼Œ æ‰€ä»¥è¯´å½“è¿™ä¸ª perplexity è¶Šæ˜¯æŽ¥è¿‘åŽŸå§‹ä¸€ä¸ªç°‡çš„neighborsçš„ä¸ªæ•°ï¼Œé‚£ä¹ˆè¿™ä¸ªåˆ†ç±»çš„æ•ˆæžœæ˜¯ï¼‰ forget that t-SNE æ˜¯è§£å†³ä¸€ä¸ª non-convex objective: there are local mimima local minima generally split a natural cluster into multiple parts ï¼ˆå°±æ˜¯å¦‚ä½•æœ‰è¿™ä¸ªæ•ˆæžœï¼Œé‚£ä¹ˆä¸è¦æƒŠè®¶ï¼Œæœ‰å¯èƒ½å‡ºçŽ°å¤šä¸ªä¸åŒçš„partsï¼‰ forget that low-dimentional metric spaces cannot caputure non-metric similarities How input similarities in t-SNE are actually computed compute conditional similarities$$p_{j |i}=\frac{\exp (-|x_{i}-x_{j}|^{2} / 2 \sigma_{i}^{2})}{\sum_{j^{\prime} \neq i} \exp (-|x_{i}-x_{j^{\prime}}|^{2} / 2 \sigma_{i}^{2})}$$perform a binary search over $\sigma_{i}$ to obtain a target perplexity ( ä»Žè¿™é‡Œå¾—åˆ°å¯å‘ï¼Œå¦‚æžœæŸä¸ªæŒ‡æ ‡æ˜¯ä¸å¯¹ç§°çš„ï¼Œé‚£ä¹ˆ symmetrize å°±æ˜¯å¯ä»¥å¾—åˆ°ä¸€ä¸ªå¯¹ç§°çš„æŒ‡æ ‡ï¼Œ æƒ³æƒ³ä»Žkl divergence åˆ°JS divergenceè¿™ä¸ªè¿‡ç¨‹) Symmetrize the conditions$$p_{i |j}=\frac{p_{j | i}+p_{i | j}}{2 N}$$ Conclusion t-SNE is a valuable tool in generating hypotheses and understanding, but does not produce conclusive evidence. æ¥è‡ªdoâ€™s and Donâ€™ts of using t-SNE to Understand Vision Modelsçš„é˜…è¯»ç¬”è®°ã€‚ç†è§£TSNEç®—æ³• æ‚è´§é“º å¯¹äºŽencodding çš„ç†è§£ï¼Œä»Žå­—ç¬¦è½¬æˆæ•°å­—ï¼Œå¹¶ä¸”å°½å¯èƒ½çš„ä¿ç•™åŽŸæ¥çš„ä¿¡æ¯ã€‚æŽ¥è§¦çš„æœ‰ä¸‰ç§ï¼Œä¸€ç§ label encodingï¼Œé€‚åˆç±»åˆ«ä¿¡æ¯åªæœ‰ä¸¤ç±»ã€‚å¦‚æžœå¤§äºŽä¸¤ç±»é‚£ä¹ˆå°±ä½¿ç”¨one-hotã€‚ç¬¬ä¸‰ç§å°±æ˜¯ä¸‡ç‰©å¯ä»¥embeddingï¼Œä½¿ç”¨ç¥žç»ç½‘ç»œçš„æ€æƒ³ã€‚ ç‰¹å¾å·¥ç¨‹åˆ†ä¸ºç‰¹å¾æž„é€  (feature creation or construction)å’Œ ç‰¹å¾é€‰æ‹©ï¼ˆfeature selectionï¼‰ ã€‚ å½’ä¸€åŒ–ï¼ˆåŽ»ä¸­å¿ƒï¼Œæ–¹å·®å½’ä¸€ï¼‰æ˜¯å±žäºŽç‰¹å¾(é¢„)å¤„ç†:æŠŠç‰¹å¾å€¼åŽ‹ç¼©æˆ0~1çš„åŒºé—´ã€‚ One-hotï¼ˆä¹Ÿå«One-of-kï¼‰çš„æ–¹æ³•æŠŠæ¯ä¸ªæ— åºç‰¹å¾è½¬åŒ–ä¸ºä¸€ä¸ªæ•°å€¼å‘é‡ã€‚æ¯”å¦‚ä¸€ä¸ªæ— åºç‰¹å¾coloræœ‰ä¸‰ç§å–å€¼ï¼šredï¼Œgreenï¼Œblueã€‚é‚£ä¹ˆå¯ä»¥ç”¨ä¸€ä¸ªé•¿åº¦ä¸º3çš„å‘é‡æ¥è¡¨ç¤ºå®ƒï¼Œå‘é‡ä¸­çš„å„ä¸ªå€¼åˆ†åˆ«å¯¹åº”äºŽredï¼Œgreenï¼Œblueã€‚å¦‚ï¼šè¿™ç§æ–¹æ³•åœ¨NLPé‡Œç”¨çš„å¾ˆå¤šï¼Œå°±æ˜¯æ‰€è°“çš„è¯å‘é‡æ¨¡åž‹ã€‚å˜æ¢åŽçš„å‘é‡é•¿åº¦å¯¹äºŽè¯å…¸é•¿åº¦ï¼Œæ¯ä¸ªè¯å¯¹åº”äºŽå‘é‡ä¸­çš„ä¸€ä¸ªå…ƒç´ ã€‚ è¿‡æ‹Ÿåˆå’Œæ¬ æ‹Ÿåˆé—®é¢˜ï¼š å¯ä»¥ä»Žæ•°æ®å’Œæ¨¡åž‹ä¸¤æ–¹é¢è€ƒè™‘ã€‚ è¿‡æ‹Ÿåˆ æ¬ æ‹Ÿåˆ æ•°æ® æ”¶é›†æ›´å¤šçš„æ•°æ® æˆ–è€… æ•°æ®å¢žå¼º æ¨¡åž‹ æ¨¡åž‹ç®€å•åŒ– (dropout, normalizaion )ï¼Œç›®æ ‡å‡½æ•°åŠ ä¸ŠL1 or L2 ï¼Œä¸åŒæ¨¡åž‹å–å¹³å‡ æ¨¡åž‹å˜å¾—å¤æ‚ï¼ˆå¦‚æžœæ ‘çš„ç»“æž„ï¼Œé‚£ä¹ˆæ ‘ä¸ªæ•°å¢žåŠ ï¼‰ï¼Œloss function è®­ç»ƒ early stop, éšæœºé‡‡æ · (åŠ å…¥äº†éšæœºæ€§) å¤šè®­ç»ƒä¸€ä¸‹çœ‹çœ‹æ•ˆæžœ å¤ä¹ æ€»ç»“ ç‰¹å¾æ¥æºä¸€éƒ¨åˆ†æ˜¯ä¸šåŠ¡åœºæ™¯ï¼Œä¸€éƒ¨åˆ†æ˜¯å¸¸è§„æ“ä½œã€‚å¸¸è§„æ“ä½œåŒ…æ‹¬aggregationèšåˆæ“ä½œï¼ˆä¸»è¦é’ˆå¯¹å­è¡¨ï¼‰ï¼Œç‰¹å¾ç¦»æ•£åŒ–ï¼Œç»„åˆç‰¹å¾ã€‚ä¸šåŠ¡ç‰¹å¾ï¼Œå°±æ˜¯æ ¹æ®ä¸åŒçš„åœºæ™¯ï¼Œæž„é€ åœ¨è¯¥åœºæ™¯ä¸‹é‡è¦å­—æ®µã€‚å½“ç„¶è¿˜æœ‰ä¸€äº›éªšæ“ä½œï¼Œä½¿ç”¨æœºå™¨æ¨¡åž‹è¿›è¡Œç‰¹å¾çš„æž„é€ å’Œé€‰æ‹©ï¼Œä¼˜ç‚¹æ˜¯workï¼Œç¼ºç‚¹æ˜¯å¯è§£é‡Šæ€§å·®ï¼Œæ¯”å¦‚ä½¿ç”¨xgboost +LR æ¨¡åž‹ï¼Œå‰è€…å°±æ˜¯ä¸€ç§ç‰¹å¾æå–çš„åŠŸèƒ½ï¼Œæœ€åŽå¶å­ç»“ç‚¹çš„è¾“å‡ºï¼ŒçŸ¥é“å…¶æ˜¯é‡è¦çš„ï¼Œä½†æ˜¯ä¸çŸ¥é“å…¶å«ä¹‰æ˜¯ä»€ä¹ˆã€‚ è¿žç»­ç‰¹å¾ç¦»æ•£åŒ–çš„å¥½å¤„ï¼š (1) å¢žåŠ äº†æ¨¡åž‹çš„éžçº¿æ€§ï¼Œæå‡äº†æ¨¡åž‹è¡¨è¾¾èƒ½åŠ› (2) ç¦»æ•£åŒ–ç‰¹å¾å¯¹å¼‚å¸¸æ•°æ®å…·æœ‰å¾ˆå¼ºçš„é²æ£’æ€§ã€‚å¸¸ç”¨çš„é€‰å–ç¦»æ•£ç‚¹çš„æ–¹æ³•ï¼š(1) ç­‰è·ç¦»ç¦»æ•£ (2) ç­‰æ ·æœ¬ç¦»æ•£ (3) ç”»å›¾ (4) æ ¹æ®å®žé™…åœºæ™¯ï¼Œæ¯”å¦‚å¯¹äºŽå¹´é¾„çš„åˆ’åˆ† ç‰¹å¾ç»„åˆ( 1)åŸºæœ¬ç‰¹å¾çš„éžçº¿æ€§ç»„åˆ (2) ç‰¹å¾ä¹‹é—´çš„å·®å’Œä¹˜ç§¯å•†ï¼Œmean,varianceï¼Œstd ç»Ÿè®¡å­¦ç‰¹å¾ ç‰¹å¾é€‰æ‹©ï¼ˆé™ç»´ï¼‰çš„æ–¹æ³•: (1) ç‰¹å¾æœ¬èº« ï¼ˆå¦‚æžœç¼ºçœå€¼æ¯”è¾ƒå¤§æˆ–è€…æ•°æ®çš„æ³¢åŠ¨æ¯”è¾ƒå°ï¼‰ (2) ç‰¹å¾ä¹‹é—´çš„å…³ç³»ï¼ˆç‰¹å¾ä¹‹é—´æœ‰è¾ƒå¼ºçš„ç›¸å…³æ€§ï¼Œå¯ä»¥ä½¿ç”¨PCAè¿›è¡Œé™ç»´ï¼‰ (3 ) ç‰¹å¾å’Œæœ€åŽtarget çš„å…³ç³» (feature importance, å¡æˆ¿åˆ†å¸ƒï¼Œ pearson ç›¸å…³ç³»æ•°) (4) å¾ˆå¤šå¸¸è§çš„æœºå™¨å­¦ä¹ æ¨¡åž‹éƒ½æ˜¯ä¸€ç§ç‰¹å¾é€‰æ‹©çš„æ–¹å¼ï¼Œæ¯”å¦‚xgboost LR æ˜¯å¹¿ä¹‰çš„çº¿æ€§æ¨¡åž‹ï¼Œå†…éƒ¨æ˜¯çŸ©é˜µè¿ç®—ï¼Œé€Ÿåº¦ç›¸å½“çš„å¿«ã€‚éšç€å·¥ä¸šç•Œè®¡ç®—èƒ½åŠ›çš„æå‡ï¼Œä½¿ç”¨xgboost çš„èŒƒå›´æ˜¯è¶Šæ¥è¶Šå¤§ï¼Œä¸å†å±€é™äºŽLR æ¨¡åž‹ã€‚ æ­£åˆ™åŒ–æ˜¯ä½¿å¾—æ¨¡åž‹ä¸å†å˜å¾—é‚£ä¹ˆå¤æ‚ï¼Œå…·ä½“æ˜¯é€šè¿‡å‡å°‘ç›®æ ‡å‡½æ•°ä¸­loss ä¸­weights çš„ç›¸å¯¹å¤§å°ã€‚ embedding çš„æ–¹å¼ (1) label embedding (2) one-hot (3) ç¥žç»ç½‘ç»œï¼Œä¸‡ç‰©embedding]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>pca</tag>
        <tag>svd</tag>
        <tag>t-sne</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¸¸è§çš„æŽ’åºç®—æ³•æ€»ç»“]]></title>
    <url>%2F2018%2F06%2F29%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[åˆ†ç±»å’Œæ€»ç»“ æ ¹æ®å¾…æŽ’åºçš„æ•°æ®å¤§å°ä¸åŒï¼Œä½¿å¾—æŽ’åºè¿‡ç¨‹ä¸­æ‰€æ¶‰åŠçš„å­˜å‚¨å™¨ä¸åŒï¼Œå¯åˆ†ä¸ºå†…éƒ¨æŽ’åºå’Œå¤–éƒ¨æŽ’åºã€‚ æŽ’åºå…³é”®å­—å¯èƒ½å‡ºçŽ°é‡å¤ï¼Œæ ¹æ®é‡å¤å…³é”®å­—çš„æŽ’åºæƒ…å†µå¯åˆ†ä¸ºç¨³å®šæŽ’åºå’Œä¸ç¨³å®šæŽ’åºã€‚å†’æ³¡ã€æ’å…¥å’Œå½’å¹¶æ˜¯ç¨³å®šï¼Œåœ¨è¿™é‡Œæåˆ°çš„å…¶ä»–çš„å‡ ä¸ªéƒ½æ˜¯ä¸ç¨³å®šçš„ã€‚ å¯¹äºŽå†…éƒ¨æŽ’åºï¼Œä¾æ®ä¸åŒçš„æŽ’åºåŽŸåˆ™ï¼Œå¯åˆ†ä¸ºæ’å…¥æŽ’åºã€äº¤æ¢(å¿«é€Ÿ)æŽ’åºã€é€‰æ‹©æŽ’åºã€å½’å¹¶æŽ’åºå’Œè®¡æ•°æŽ’åºã€‚ é’ˆå¯¹å†…éƒ¨æŽ’åºæ‰€éœ€çš„å·¥ä½œé‡åˆ’åˆ†ï¼Œå¯åˆ†ä¸º:ç®€å•æŽ’åº O(n^2)ã€å…ˆè¿›æŽ’åº O(nlogn)å’ŒåŸºæ•°æŽ’åº O(d*n)ã€‚å¸¸è§ç®—æ³•çš„æ€§è´¨æ€»ç»“ï¼š æŽ’åºç®—æ³•å®žçŽ°é»˜è®¤éƒ½æ˜¯å‡åºâ€¦ æ’å…¥æŽ’åº(Insert Sort)æ€æƒ³ï¼š æœ‰åºæ•°ç»„+insert one every one time æ’å…¥æŽ’åºçš„å·¥ä½œæ–¹å¼éžå¸¸åƒäººä»¬æŽ’åºä¸€æ‰‹æ‰‘å…‹ç‰Œä¸€æ ·ã€‚å¼€å§‹æ—¶ï¼Œæˆ‘ä»¬çš„å·¦æ‰‹ä¸ºç©ºå¹¶ä¸”æ¡Œå­ä¸Šçš„ç‰Œé¢æœä¸‹ã€‚ç„¶åŽï¼Œæˆ‘ä»¬æ¯æ¬¡ä»Žæ¡Œå­ä¸Šæ‹¿èµ°ä¸€å¼ ç‰Œå¹¶å°†å®ƒæ’å…¥å·¦æ‰‹ä¸­æ­£ç¡®çš„ä½ç½®ã€‚ä¸ºäº†æ‰¾åˆ°ä¸€å¼ ç‰Œçš„æ­£ç¡®ä½ç½®ï¼Œæˆ‘ä»¬ä»Žå³åˆ°å·¦å°†å®ƒä¸Žå·²åœ¨æ‰‹ä¸­çš„æ¯å¼ ç‰Œè¿›è¡Œæ¯”è¾ƒï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼šæ­¥éª¤ï¼š ä»Žç¬¬ä¸€ä¸ªå…ƒç´ å¼€å§‹ï¼Œè¯¥å…ƒç´ å¯ä»¥è®¤ä¸ºå·²ç»è¢«æŽ’åº å–å‡ºä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œåœ¨å·²ç»æŽ’åºçš„å…ƒç´ åºåˆ—ä¸­ä»ŽåŽå‘å‰æ‰«æ å¦‚æžœè¯¥å…ƒç´ ï¼ˆå·²æŽ’åºï¼‰å¤§äºŽæ–°å…ƒç´ ï¼Œå°†è¯¥å…ƒç´ ç§»åˆ°ä¸‹ä¸€ä½ç½® é‡å¤æ­¥éª¤3ï¼Œç›´åˆ°æ‰¾åˆ°å·²æŽ’åºçš„å…ƒç´ å°äºŽæˆ–è€…ç­‰äºŽæ–°å…ƒç´ çš„ä½ç½® å°†æ–°å…ƒç´ æ’å…¥åˆ°è¯¥ä½ç½®åŽ é‡å¤æ­¥éª¤2~5 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;void insert_sort(vector&lt;int&gt; &amp; nums)&#123; int n = nums.size(); for(int i =1; i&lt;n; i++) &#123; int tmp =nums[i]; int j =i -1; // å¦‚æžœå½“å‰çš„å…ƒç´ æ¯”ä¹‹å‰çš„å…ƒç´ å°ï¼Œé‚£ä¹ˆä¸€ç›´æ˜¯ä¸ºå½“å‰çš„å…ƒç´ å¾€åŽæŒªåœ°æ–¹ // è¿™æ ·å†™æ³•ä¹Ÿæ˜¯æœ‰è§„å¾‹çš„ï¼Œå¥½å¥½ä½“ä¼š while(j &gt;=0 &amp;&amp; tmp &lt; nums[j]) &#123; nums[j +1] =nums[j]; j --; &#125; nums[j+1] =tmp; &#125;&#125;int main()&#123; vector&lt;int&gt; nums =&#123;12, 15, 9, 20, 6, 31, 24&#125;; insert_sort(nums); for(auto u: nums) cout &lt;&lt; u&lt;&lt;" "; cout &lt;&lt; endl; return 0;&#125; c++å®žçŽ° 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;void insert_sort(vector&lt;int&gt; &amp; nums)&#123; int n = nums.size(); for(int i =1; i&lt;n; i++) &#123; int tmp =nums[i]; int j =i -1; // å¦‚æžœå½“å‰çš„å…ƒç´ æ¯”ä¹‹å‰çš„å…ƒç´ å°ï¼Œé‚£ä¹ˆä¸€ç›´æ˜¯ä¸ºå½“å‰çš„å…ƒç´ å¾€åŽæŒªåœ°æ–¹ // è¿™æ ·å†™æ³•ä¹Ÿæ˜¯æœ‰è§„å¾‹çš„ï¼Œå¥½å¥½ä½“ä¼š while(j &gt;=0 &amp;&amp; tmp &lt; nums[j]) &#123; nums[j +1] =nums[j]; j --; &#125; nums[j+1] =tmp; &#125;&#125;int main()&#123; vector&lt;int&gt; nums =&#123;12, 15, 9, 20, 6, 31, 24&#125;; insert_sort(nums); for(auto u: nums) cout &lt;&lt; u&lt;&lt;" "; cout &lt;&lt; endl; return 0;&#125; é€‰æ‹©æŽ’åº(Select Sort)æ€æƒ³å’Œæ­¥éª¤ï¼š select one every time ç®€å•é€‰æ‹©æŽ’åºæ˜¯æœ€ç®€å•ç›´è§‚çš„ä¸€ç§ç®—æ³•ï¼ŒåŸºæœ¬æ€æƒ³ä¸ºæ¯ä¸€è¶Ÿä»Žå¾…æŽ’åºçš„æ•°æ®å…ƒç´ ä¸­é€‰æ‹©æœ€å°ï¼ˆæˆ–æœ€å¤§ï¼‰çš„ä¸€ä¸ªå…ƒç´ ä½œä¸ºé¦–å…ƒç´ ï¼Œç›´åˆ°æ‰€æœ‰å…ƒç´ æŽ’å®Œä¸ºæ­¢ï¼Œç®€å•é€‰æ‹©æŽ’åºæ˜¯ä¸ç¨³å®šæŽ’åºã€‚ åˆ†æžï¼š æ— è®ºä»€ä¹ˆæ•°æ®è¿›åŽ»éƒ½æ˜¯ O(nÂ²) çš„æ—¶é—´å¤æ‚åº¦ã€‚æ‰€ä»¥ç”¨åˆ°å®ƒçš„æ—¶å€™ï¼Œæ•°æ®è§„æ¨¡è¶Šå°è¶Šå¥½ã€‚å”¯ä¸€çš„å¥½å¤„å¯èƒ½å°±æ˜¯ä¸å ç”¨é¢å¤–çš„å†…å­˜ç©ºé—´äº†å§ã€‚ ä»£ç å®žçŽ°: 12345678910111213def select_sort(lists): count =len(lists) for i in range(0, count): min =i for j in range(i+1, count): if lists[min] &gt;lists[j]: min =j lists[min], lists[i] =lists[i], lists[min] return lists# testlists =[1, 23,45, 0,-1]print(select_sort(lists)) å†’æ³¡æŽ’åº(Bubble Sort)æ€æƒ³ï¼š move smallest one time (å‡è®¾ä¸å‡) ä¸€éæŽ’åºä¹‹åŽï¼Œå³è¾¹æ˜¯æœ€å¤§ï¼Œä¹Ÿå°±æ˜¯æŽ’å¥½åºçš„ã€‚è¿™ä¸ªè§„åˆ™æ˜¯ä»¥æ­¤ç±»æŽ¨çš„ã€‚ æœ‰ä¸¤ç§è¯´æ³• ä»Žå³å¾€å·¦ï¼š æœ€å°å€¼è¢«ç§»åˆ°äº†æœ€å·¦è¾¹ã€‚ ã€å†’æ³¡æ³•ã€‘çš„æœ¬æ„ ä»Žå·¦å¾€å³ï¼š æœ€å¤§å€¼è¢«ç§»åˆ°äº†æœ€å³è¾¹ã€‚ æ­¤æ—¶å…¶å®žåº”è¯¥å« ã€æ²‰çŸ³æ³•ã€‘ ä»Žå·¦å‘å³ æ²‰çŸ³æ³• å›¾è§£ï¼š åˆ†æžï¼šå¹³å‡æ—¶é—´å¤æ‚åº¦ï¼šO(n^2)æœ€åç©ºé—´å¤æ‚åº¦ï¼š æ€»å…± O(n)ï¼Œéœ€è¦è¾…åŠ©ç©ºé—´ O(1) 1234567891011def bubble_sort(lists): count =len(lists) for i in range(0, count): for j in range(i+1, count): if lists[i]&gt; lists[j]: lists[i], lists[j] =lists[j], lists[i] return lists# testlists =[1,34,45,0,89]print(bubble_sort(lists)) å½’å¹¶æŽ’åº(Merge Sort)æ€æƒ³ï¼š divide-and-conquer +é€’å½’ å½’å¹¶æŽ’åºï¼ˆMERGE-SORTï¼‰æ˜¯åˆ©ç”¨å½’å¹¶çš„æ€æƒ³å®žçŽ°çš„æŽ’åºæ–¹æ³•ï¼Œè¯¥ç®—æ³•é‡‡ç”¨ç»å…¸çš„åˆ†æ²»ï¼ˆdivide-and-conquerï¼‰ç­–ç•¥ï¼ˆåˆ†æ²»æ³•å°†é—®é¢˜åˆ†(divide)æˆä¸€äº›å°çš„é—®é¢˜ç„¶åŽé€’å½’æ±‚è§£ï¼Œè€Œæ²»(conquer)çš„é˜¶æ®µåˆ™å°†åˆ†çš„é˜¶æ®µå¾—åˆ°çš„å„ç­”æ¡ˆâ€ä¿®è¡¥â€åœ¨ä¸€èµ·ï¼Œå³åˆ†è€Œæ²»ä¹‹)ã€‚ åˆ†æžï¼šæ—¶é—´å¤æ‚åº¦ï¼šO(nlogn)ç©ºé—´å¤æ‚åº¦ï¼šO(N)ï¼Œå½’å¹¶æŽ’åºéœ€è¦ä¸€ä¸ªä¸ŽåŽŸæ•°ç»„ç›¸åŒé•¿åº¦çš„æ•°ç»„åšè¾…åŠ©æ¥æŽ’åº 12345678910111213141516171819202122232425262728293031323334353637def merge_sort(nums, l, r, tmp): if(l &gt;= r): return mid =l +r &gt;&gt;1 merge_sort(nums, l , mid,tmp) merge_sort(nums, mid +1, r, tmp) i, j, k =l, mid +1, 0 while i &lt;=mid and j &lt;= r : if(nums[i] &lt;= nums[j]): tmp[k] =nums[i] i +=1 k +=1 else: tmp[k] =nums[j] j +=1 k +=1 while i&lt;= mid: tmp[k ] =nums[i] k +=1 i +=1 while j&lt;=r : tmp[k] =nums[j] k +=1 j +=1 i =l for j in range(k): nums[i] = tmp[j] i +=1 if __name__ =="__main__": n =int(input()) nums =list(map(int, input().split())) tmp =[0] *n merge_sort(nums, 0, n-1, tmp) nums =list(map(str, nums)) print(" ".join(nums)) c++ çš„å®žçŽ° 1234567891011121314151617181920212223242526272829303132333435// å½’å¹¶æŽ’åºï¼Œåˆ†è€Œæ²»ä¹‹ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ O(nlogn)#include&lt;bits/stdc++.h&gt;using namespace std;const int N =1e5+11;int nums[N], tmp[N];int n;void merge_sort(int nums[], int l, int r)&#123; if(l &gt;=r ) return ; int mid = l +r &gt;&gt;1; merge_sort(nums, l, mid); merge_sort(nums, mid +1, r); int k =0, i =l, j =mid +1; while(i &lt;=mid &amp;&amp; j &lt;= r) &#123; if(nums[i]&lt;= nums[j]) tmp[k ++] =nums[i++]; else tmp[k++] =nums[j ++]; &#125; while(i &lt;= mid) tmp[k ++] =nums[i ++]; while(j &lt;= r) tmp[k++]= nums[j ++]; // push back for(int i =l,j =0; j &lt;k;) nums[i++]= tmp[j++];&#125;int main()&#123; //æ³¨æ„c è¯­è¨€ä¸­çš„è¯»å…¥å’Œè¾“å‡º éƒ½æ˜¯æœ‰f çš„ scanf("%d", &amp;n); for(int i =0; i&lt;n; i++) scanf("%d", &amp;nums[i]); merge_sort(nums, 0, n -1); for(int i =0; i&lt;n; i++) printf("%d ", nums[i]); printf("\n"); return 0;&#125; å¿«é€ŸæŽ’åº(Quick Sort)æ€æƒ³ï¼šä»»æ„é€‰æ‹©ä¸€ä¸ªkey(é€šå¸¸é€‰æ‹©a[0])ï¼Œå°†æ¯”ä»–å°çš„æ•°æ®æ”¾åœ¨å®ƒçš„å‰é¢ï¼Œæ¯”ä»–å¤§çš„æ•°å­—æ”¾åœ¨å®ƒçš„åŽé¢ã€‚é€’å½’è¿›è¡Œã€‚ æ­¥éª¤ï¼š ä»Žæ•°åˆ—ä¸­æŒ‘å‡ºä¸€ä¸ªåŸºå‡†å€¼ã€‚ å°†æ‰€æœ‰æ¯”åŸºå‡†å€¼å°çš„æ‘†æ”¾åœ¨åŸºå‡†å‰é¢ï¼Œæ‰€æœ‰æ¯”åŸºå‡†å€¼å¤§çš„æ‘†åœ¨åŸºå‡†çš„åŽé¢(ç›¸åŒçš„æ•°å¯ä»¥åˆ°ä»»ä¸€è¾¹)ï¼›åœ¨è¿™ä¸ªåˆ†åŒºé€€å‡ºä¹‹åŽï¼Œè¯¥åŸºå‡†å°±å¤„äºŽæ•°åˆ—çš„ä¸­é—´ä½ç½®ã€‚ é€’å½’åœ°æŠŠâ€åŸºå‡†å€¼å‰é¢çš„å­æ•°åˆ—â€å’Œâ€åŸºå‡†å€¼åŽé¢çš„å­æ•°åˆ—â€è¿›è¡ŒæŽ’åºã€‚ åˆ†æžï¼šå¿«é€ŸæŽ’åºçš„æ—¶é—´å¤æ‚åº¦åœ¨æœ€åæƒ…å†µä¸‹æ˜¯O($N^2$)ï¼Œå¹³å‡çš„æ—¶é—´å¤æ‚åº¦æ˜¯O(N*logN)ï¼Œé‡‡ç”¨çš„æ˜¯åˆ†æ²»çš„æ€æƒ³ï¼ŒäºŒå‰æ ‘çš„ç»“æž„ã€‚ ä¸‹é¢ä»¥æ•°åˆ— a={30,40,60,10,20,50} ä¸ºä¾‹ï¼Œæ¼”ç¤ºå®ƒçš„å¿«é€ŸæŽ’åºè¿‡ç¨‹(å¦‚ä¸‹å›¾)ã€‚ è¿™ä¸ªæ˜¯ç»è¿‡ä¸€ä¸ªè¿­ä»£çš„ç»“æžœï¼Œæ¯ä¸€ä¸ªè¿­ä»£ï¼Œéƒ½æŽ’å¥½äº†åŸºå‡†æ•°å­—çš„ä½ç½®ã€‚æŒ‰ç…§åŒæ ·çš„æ–¹æ³•ï¼Œå¯¹å­æ•°åˆ—è¿›è¡Œé€’å½’éåŽ†ã€‚æœ€åŽå¾—åˆ°æœ‰åºæ•°ç»„ï¼ åœ¨å®žçŽ°çš„è¿‡ç¨‹ä¸­ï¼Œkey å€¼çš„é€‰æ‹© while çš„éåŽ†é¡ºåºæ˜¯ç›¸å…³çš„ã€‚å¦‚æžœkey =arr[left] é‚£ä¹ˆç¬¬ä¸€ä¸ªwhile å¾ªçŽ¯æ˜¯ä»Žright å¼€å§‹çš„ï¼ˆä»ŽåŽå¾€å‰ï¼‰ï¼›å¦‚æžœkey =arr[right] é‚£ä¹ˆæ˜¯ä»Žleft è¿›è¡ŒéåŽ†çš„ã€‚ åŸºäºŽpython3 çš„å®žçŽ°ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# ä»Žå°åˆ°å¤§æŽ’def quickSort(arr, l, r): if l&gt; r: return left, right =l , r key = arr[l] while(l &lt;r): while(l &lt;r and arr[r] &gt;= key): r -=1 arr[l] =arr[r] while l&lt;r and arr[l] &lt;= key : l +=1 arr[r] =arr[l] arr[l] =key quickSort(arr, left, l -1) quickSort(arr, l +1, right)def partition(arr, l , r): key =arr[l] while(l &lt;r): while(l &lt;r and arr[r] &gt;= key): r -=1 arr[l] =arr[r] while l&lt; r and arr[l] &lt;= key : l +=1 arr[r] =arr[l] arr[l] =key return ldef quickSort2(arr, l, r): if( l&gt; r): return pos =partition(arr, l, r) quickSort2(arr, l, pos -1) quickSort2(arr, pos +1, r)if __name__ ==&quot;__main__&quot;: n =int(input()) arr =input().split(&quot; &quot;) arr =[int(a) for a in arr] print(arr) #quickSort(arr, 0, len(arr)-1) quickSort2(arr, 0, len(arr) -1) print(arr) python ç‰ˆæœ¬ 12345678910111213141516171819def quick_sort(arr, l, r): left, right =l, r key =arr[l] while(l &lt;r): while(l &lt;r and arr[r] &gt;=key): r --; arr[l] =arr[r] while(l&lt; r and arr[l] &lt;= key): l ++; arr[r] =arr[l] arr[l] =key quick_sort(arr, left, l-1) quick_sort(arr, l +1, right)arr =[12, 0,3, 34]quick_sort(arr, 0, len(arr)-1)print(arr) ç»™å‡ºä¸¤ç§ C ++ çš„ä»£ç ï¼Œå‘çŽ°æœ‰ä¸¤ç‚¹ã€‚ åˆ†å¼€å†™ä¹‹åŽï¼Œå¯ä»¥å‘çŽ°å’Œ ä¸‹é¢é‚£ä¸ªç®—æ³•é¢˜ç›®çš„å…³ç³»ï¼š è¿™ä¸ªåŸºå‡†ç‚¹å°±æ˜¯é‚£ä¸ª Kth çš„ä¸€ä¸ªå‚è€ƒ å…³äºŽwhile æ¡ä»¶çš„åˆ†æžï¼Œ å¦‚æžœæ˜¯i &lt;=j é‚£ä¹ˆè¿”å›žçš„æ˜¯jï¼Œ å¦‚æžœæ˜¯ i&lt;j é‚£ä¹ˆè¿”å›žçš„i ä½œä¸ºåŸºå‡†ç‚¹ å…³äºŽå¿«é€ŸæŽ’åºçš„ä¸‰ç§å†™æ³•ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;// ä»Žå¤§åˆ°å°void quickSort(vector&lt;int&gt;&amp; arr, int l, int r)&#123; if(l &gt;r) return ; int left =l, right =r; int key =arr[r]; while(l &lt;r) &#123; while(l &lt;r &amp;&amp; arr[l] &gt;= key) l ++; arr[r] =arr[l]; while(l &lt;r &amp;&amp; arr[r] &lt;= key) r --; arr[l] =arr[r]; &#125; arr[r] =key; quickSort(arr, left, l -1); quickSort(arr, l +1, right); &#125;// ä»Žå°åˆ°å¤§void quickSort2(vector&lt;int&gt; &amp;arr, int l, int r)&#123; if (l &gt;r) return ; int left =l, right =r; int key =arr[l]; while(l &lt; r) &#123; while(l &lt;r &amp;&amp; arr[r] &gt;= key) r --; arr[l] =arr[r]; while(l&lt;r &amp;&amp; arr[l] &lt;= key) l ++; arr[r] =arr[l]; &#125; arr[l] =key; quickSort2(arr, left, l-1); quickSort2(arr,l +1, right); &#125;/// ä»Žå°åˆ°å¤§è¿›è¡ŒæŽ’åºint partition(vector&lt;int&gt; &amp;arr, int l, int r)&#123; int key =arr[l]; while(l &lt;r) &#123; while(l &lt;r &amp;&amp; arr[r] &gt;= key) r --; arr[l] =arr[r]; while(l &lt;r &amp;&amp; arr[l] &lt;= key) l++; arr[r] =arr[l]; &#125; arr[l] =key; return l;&#125;void quickSort3(vector&lt;int&gt; &amp; arr, int l, int r)&#123; if(l &gt;r) return ; int pos =partition(arr, l, r); quickSort3(arr, l, pos -1); quickSort3(arr, pos+1, r);&#125;int main()&#123; vector&lt;int&gt; arr; int n ; cin&gt;&gt;n; arr =vector&lt;int&gt;(n); for(int i =0; i&lt;n; i++) cin &gt;&gt;arr[i]; //for(auto u :arr) cout&lt;&lt; u&lt;&lt;" "; //cout&lt;&lt;endl; quickSort3(arr, 0, n-1); for(auto u :arr) cout&lt;&lt; u&lt;&lt;" "; cout&lt;&lt;endl; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;// å¿«æŽ’ ä¸€èˆ¬æ—¶é—´å¤æ‚åº¦ nlogn ï¼Œæœ€åçš„æ—¶é—´å¤æ‚ n^2ï¼Œä¸€èˆ¬å¾ˆéš¾è¾¾åˆ°void quick_sort(vector&lt;int&gt; &amp; arr, int l, int r)&#123; if (l &gt;r) return ; int left =l, right =r; int key =arr[l]; while(l &lt;r) &#123; while(l &lt;r &amp;&amp; arr[r] &gt;= key) r -=1; arr[l] =arr[r]; while(l&lt; r &amp;&amp; arr[l] &lt;= key) l +=1; arr[r] =arr[l]; &#125; arr[l] =key; quick_sort(arr, left, l-1); quick_sort(arr, l+1, right);&#125;int main()&#123; vector&lt;int&gt; arr; int n; cin &gt;&gt;n; for(int i =0; i&lt;n; i++) &#123; int tmp; cin&gt;&gt; tmp; arr.push_back(tmp); &#125; quick_sort(arr, 0, arr.size() -1); for(auto u: arr) cout &lt;&lt; u&lt;&lt;" "; cout &lt;&lt;endl; return 0;&#125; Kth Largest Element in an Array Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Tips: ä½¿ç”¨çš„æ˜¯ å¿«æŽ’çš„æ€æƒ³ï¼Œæœ€åŽçš„å¹³å‡æ—¶é—´å¤æ‚åº¦æ˜¯O(N) ï¼Œæ‰€ä»¥æ˜¯ä¸€ä¸ªä¸é”™çš„ç®—æ³•ã€‚ kth å’Œ â€å¿«æŽ’â€œ å®žçŽ°çš„æ—¶å€™ç¨å¾®æœ‰ä¸€äº›åŒºåˆ«ï¼Œå‰è€…åªæœ‰å‘çŽ° ä¸€ç»„æ•°æ®ï¼ˆä¸€ä¸ªæ¯”pivot å¤§ï¼Œä¸€ä¸ªæ¯” pivot å°ï¼‰æ‰è¿›è¡Œäº¤æ¢ï¼ŒåŽè€…æ˜¯æ˜¯ ä¸¤ä¸ªwhileï¼Œ åªè¦å‘çŽ°ä¸€ä¸ªå°±è¿›è¡Œäº¤æ¢ã€‚è¿™ä¸ªæ˜¯ç»†å¾®çš„å·®åˆ«ã€‚æ±‚è§£K æœ€å¤§ï¼Œé‚£ä¹ˆæ•°ç»„é€‚åˆçš„æ˜¯é™åºï¼Œæ±‚è§£K æœ€å°ï¼Œé‚£ä¹ˆæ•°ç»„é€‚åˆå‡åºã€‚å…³é”®è¿™ä¸ªæ±‚è§£çš„æ˜¯ K æœ€å¤§æˆ–è€…æœ€å°ï¼Œé‚£ä¹ˆæ˜¯ä¸éœ€è¦æ•´ä¸ªæ•°ç»„æ˜¯æœ‰åºçš„ï¼Œè€Œæ˜¯æ‰¾å‡ºæŸä¸ªæ•°å­—æ˜¯ï¼Œå³å¯ã€‚ 123456789101112131415161718192021222324252627282930def partition(arr, left, right): key =arr[right] low, high =left, right while left&lt; right: while left &lt;right and arr[left]&gt;=key: left +=1 arr[right] =arr[left] while left&lt;right and arr[right] &lt;=key: right -=1 arr[left] =arr[right] arr[right] =key return leftdef findKthLargest(arr, k): left, right =0, len(arr)-1 while True: pos =partition(arr, left, right) if pos ==k-1: return arr[pos] elif pos &gt; k-1: right =pos -1 else: left = pos+1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;// æ—¶é—´å¤æ‚åº¦æ˜¯ nlog k// æ³¨æ„è¿™é‡Œä¸€å®šè¦ä¼ é€’çš„æ˜¯å¼•ç”¨int partition(vector&lt;int&gt;&amp; arr, int l, int r)&#123; int key =arr[r]; while(l &lt;r) &#123; while(l &lt;r &amp;&amp; arr[l] &gt;= key) l ++; arr[r] =arr[l]; while(l &lt;r &amp;&amp; arr[r] &lt;= key) r --; arr[l] =arr[r]; &#125; arr[r] =key; return l;&#125;int find_kth_largest(vector&lt;int&gt;&amp; arr,int n, int k)&#123; if(k &gt; n) return -1; int l =0, r =n -1; while( true) &#123; int pos =partition(arr, l, r); if( pos ==k -1) return arr[pos]; else if(pos &gt; k -1) r =pos -1; // k-1åœ¨å°éƒ¨åˆ†ï¼Œé‚£ä¹ˆr =pos -1 else l =pos +1; &#125;&#125;int partition1(vector&lt;int&gt; &amp; arr, int l, int r)&#123; int key =arr[l]; while(l &lt;r) &#123; while(l &lt;r &amp;&amp; arr[r] &gt;= key) r --; arr[l] =arr[r]; while(l &lt;r &amp;&amp; arr[l] &lt;= key) l ++; arr[r] =arr[l]; &#125; arr[l] =key; return l;&#125;int find_kth_smallest(vector&lt;int&gt;&amp; arr, int n, int k)&#123; if(k &gt;n ) return -1; int l =0, r =n -1; while(true) &#123; int pos =partition1(arr, l, r); if(pos ==k -1) return arr[pos]; else if(pos &lt; k-1) l =pos +1; // äºŒåˆ†çš„çœŸè°›åœ¨äºŽä¸€å®šåŒ…å«ç»“æžœåŒºé—´ else r =pos -1; &#125;&#125;int main()&#123; /* int n, k ; cin &gt;&gt;n&gt;&gt;k; vector&lt;int&gt; arr; for(int i =0; i&lt;n; i++) &#123; int tmp; cin &gt;&gt;tmp; arr.push_back(tmp); &#125; */ vector&lt;int&gt; arr =&#123;1, 5, 7, 0, 2&#125;; int k =2; int n =5; cout &lt;&lt;"result: "&lt;&lt;endl; cout &lt;&lt; find_kth_largest(arr, n, k)&lt;&lt; endl; cout &lt;&lt; find_kth_smallest(arr, n, k)&lt;&lt; endl; return 0;&#125; ä½¿ç”¨å†…ç½®çš„å‡½æ•°å…ˆsort () ç„¶åŽé€‰æ‹©ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦æ˜¯ $nlogn$ã€‚ å¦‚æžœä½¿ç”¨partition() å‡½æ•°ï¼Œ å°±èƒ½ä¼˜åŒ–æˆ $O(n)$. è®²è§£å¦‚ä¸‹ Thatâ€™s not quick-sort, thatâ€™s quick-select. After partitioning, the the former continues to sort both parts while the latter continues to search only one part. So your costs are like n+n/2+n/4+n/8+â€¦ = 2n = O(n) instead of n+2Â·n/2+4Â·n/4+â€¦ = O(n log n). 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int partition(vector&lt;int&gt; &amp; arr, int l, int r)&#123; int key =arr[r]; while(l &lt;r) &#123; while(l &lt;r &amp;&amp; arr[l] &gt;= key) l ++; arr[r] =arr[l]; while (l &lt;r &amp;&amp; arr[r]&lt;= key) r --; arr[l] = arr[r]; &#125; return l;&#125;int kth_largest(vector&lt;int&gt; arr, int k)&#123; if(arr.empty()) return -1; int l =0,r= arr.size()-1; if (k &gt;arr.size()) return -1; while (true) &#123; int pos =partition(arr, l, r); if(pos ==k -1) return arr[k]; else if(pos &gt; k-1) r =pos -1; else l = pos +1; &#125; return -1;&#125;int main()&#123; int n, k; vector&lt;int&gt; arr; cin&gt;&gt; n&gt;&gt;k; arr =vector&lt;int&gt;(n); for(int i =0; i&lt;n; i++) cin&gt;&gt; arr[i]; cout&lt;&lt; kth_largest(arr, k)&lt;&lt;endl; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041# Hello World program in Python# python ä¸­åªæ˜¯æ”¯æŒ +=1 ä¸æ”¯æŒ ++ æ“ä½œdef partition(arr, l, r): key = arr[r] while l &lt; r: while l &lt; r and arr[l] &gt;= key: l +=1 arr[r] = arr[l] while l &lt; r and arr[r] &lt;= key: r -=1 arr[l] = arr[r] arr[r] = key return ldef findKthLargest(nums, k): """ :type nums: List[int] :type k: int :rtype: int """ if not nums or k &gt; len(nums): return False; l, r = 0, len(nums) - 1 while True: pos = partition(nums, l, r) if (pos == k - 1): return nums[pos] elif (pos &gt; k - 1): r =pos -1 else: l =pos +1 return -1nums = [1, 2, 3, 4, 5]k = 2print(findKthLargest(nums, k)) å †æŽ’åºå †æŽ’åº(Heap Sort)çš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(nlogn) $, æœ€åæƒ…å†µä¸‹ä¹Ÿæ˜¯å¦‚æ­¤.è€Œå¿«é€ŸæŽ’åº(Quick Sort), è‹¥åˆå§‹è®°å½•åºåˆ—æœ‰åº, å¿«é€ŸæŽ’åºå°†é€€åŒ–ä¸ºèµ·æ³¡æŽ’åº(Bubble Sort), æ—¶é—´å¤æ‚åº¦æ˜¯$O(n^2) $.è¿™æ˜¯å †æŽ’åºæ¯”å¿«é€ŸæŽ’åºçš„ä¼˜ç‚¹. å †æŽ’åºå¯ä»¥ä½¿ç”¨æ•°ç»„å®žçŽ°ï¼Œå‡è®¾â€ç¬¬ä¸€ä¸ªå…ƒç´ â€åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•ä¸º 1 çš„è¯ï¼Œåˆ™çˆ¶èŠ‚ç‚¹å’Œå­èŠ‚ç‚¹çš„ä½ç½®å…³ç³»å¦‚ä¸‹ï¼š ç´¢å¼•ä¸ºiçš„å·¦å­©å­çš„ç´¢å¼•æ˜¯ (2*i); ç´¢å¼•ä¸ºiçš„å·¦å­©å­çš„ç´¢å¼•æ˜¯ (2*i+1); ç´¢å¼•ä¸ºiçš„çˆ¶ç»“ç‚¹çš„ç´¢å¼•æ˜¯ floor(i/2); å½“ç„¶ä¹Ÿæ˜¯å¯ä»¥ä»Ž 0å¼€å§‹è®¡æ•°ã€‚åœ¨C++ ä¸­ä½¿ç”¨ æ ‡å‡†åº“å‡½æ•°ä¸­çš„ priority_queue å°±å¯ä»¥ä½¿ç”¨ã€‚ä¼˜å…ˆé˜Ÿåˆ—ã€‚ å‚çœ‹å¦å¤–ä¸€ç¯‡åšå®¢ ä½¿ç”¨å †æŽ’åºçš„ä¸€ä¸ªé—®é¢˜ï¼Œæ±‚è§£æœ€å°K ä¸ªå…ƒç´ ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ $O(nlog k) $.push_upæ“ä½œæ—¶é—´å¤æ‚åº¦O(logk)ï¼Œpush_downä¹Ÿæ˜¯O(logk)ï¼Œæ€»è®¡éåŽ†æ•°æ®ä¸€éã€‚æ‰€ä»¥æœ€ç»ˆå¤æ‚åº¦æ˜¯O(Nlogk)ã€‚è¯¦ç»†çš„è§£é‡Šå¯ä»¥çœ‹è¿™é‡Œ ã€‚å®žçŽ°çš„æ—¶å€™ï¼Œç›´æŽ¥ä½¿ç”¨åº“å‡½æ•°äº†ã€‚ è¦æ±‚ï¼Œèƒ½å¤Ÿè‡ªå·±å®žçŽ°ï¼Œç„¶åŽä¼šä½¿ç”¨åº“å‡½æ•° å †æ˜¯ä¸€æ£µé¡ºåºå­˜å‚¨çš„å®Œå…¨äºŒå‰æ ‘ï¼Œå †æŽ’åºæ˜¯ä¸€ç§æ ‘å½¢é€‰æ‹©æŽ’åºï¼Œå…¶æ—¶é—´å¤æ‚åº¦ä¸ºO(nlogn)ï¼Œç©ºé—´å¤æ‚åº¦:å¯¹äºŽè®°å½•è¾ƒå°‘çš„æ–‡ä»¶ä¸æŽ¨èä½¿ç”¨ï¼Œå¯¹äºŽè¾ƒå¤§çš„æ–‡ä»¶è¿˜æ˜¯æœ‰æ•ˆçš„.å †åˆ†ä¸ºå¤§æ ¹å †å’Œå°æ ¹å †ã€‚å¤§æ ¹å †çš„è¦æ±‚æ˜¯æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½ä¸å¤§äºŽå…¶çˆ¶èŠ‚ç‚¹çš„å€¼ï¼Œå³A[PARENT[i]] &gt;= A[i]ã€‚å°æ ¹å †çš„è¦æ±‚æ˜¯æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½ä¸å°äºŽå…¶çˆ¶èŠ‚ç‚¹çš„å€¼ï¼Œå³A[PARENT[i]] &lt;= A[i]ã€‚ å †çš„æ¯æ¬¡è°ƒæ•´äº¤æ¢å †é¡¶å’Œæœ€åŽä¸€ä¸ªå…ƒç´ ï¼Œç„¶åŽåªæ˜¯è°ƒæ•´å †é¡¶å’Œå †é¡¶çš„å·¦å³å­©å­æ ‘çš„å…³ç³»ã€‚æœ‰å»ºç«‹å †ï¼Œè°ƒæ•´å †å’Œå †æŽ’åºä¸‰ä¸ªæ­¥éª¤ã€‚ è¿™ä¸ªæ˜¯è®²è§£è§†é¢‘ 123456789101112131415161718192021222324n,m =tuple(map(int, input().split()))nums =list(map(int, input().split()))def heapify( x): if x&gt;=n : return cl =2*x+1 cr =cl +1 min_v =x if(cl &lt;n and nums[min_v] &gt; nums[cl]): min_v =cl if(cr &lt;n and nums[min_v] &gt; nums[cr]): min_v =cr if(min_v != x): nums[min_v], nums[x] =nums[x], nums[min_v] heapify(min_v) if __name__ =="__main__": # build heap for i in range((n-1)//2, -1, -1): heapify(i) # heap sort while m: print(str(nums[0])+" ") nums[0] =nums[n-1] heapify(0) n -=1 m -=1 ä½¿ç”¨c++ å®žçŽ°çš„æ˜¯å°æ ¹å †ï¼Œ heapify , build heap å’Œheap sort çš„æ“ä½œ. ä½¿ç”¨æ•°ç»„ä½œä¸ºå­˜å‚¨çš„ç»“æž„ï¼Œä»Ž 1åˆ°n å­˜å‚¨ï¼Œè¿™æ ·ç¬¬ i ä¸ªç»“ç‚¹çš„çˆ¶èŠ‚ç‚¹æ˜¯ i/2ï¼Œ å·¦å³å­èŠ‚ç‚¹æ˜¯ 2*i å’Œ2*i+1 123456789101112131415161718192021222324252627282930313233343536// å †æŽ’åºçš„æ ¸å¿ƒæ€æƒ³ï¼Œä¿è¯å †é¡¶å…ƒç´ å’Œå·¦å³ä¸¤ä¸ªå­©å­çš„å¤§å°å…³ç³»ï¼› å¦‚æžœæ˜¯å¤§æ ¹å †ï¼Œé‚£ä¹ˆå°±æ˜¯å †é¡¶å…ƒç´ å¤§äºŽä¸¤ä¸ªå­©å­çš„å…ƒç´ #include&lt;bits/stdc++.h&gt;using namespace std;const int N =1e5+11;int n,m;int nums[N];// è¿™ä¸ªæ˜¯å°æ ¹å †void heapify(int x)&#123; int lc = 2*x, rc =lc+1; int min_v =x; if(lc &lt;=n &amp;&amp; nums[min_v] &gt; nums[lc] ) min_v =lc; if(rc &lt;=n &amp;&amp; nums[min_v] &gt; nums[rc]) min_v =rc; if(min_v != x) &#123; swap(nums[min_v], nums[x]); heapify(min_v); &#125;&#125;int main()&#123; cin &gt;&gt;n &gt;&gt;m; for(int i =1; i&lt;=n;i++) scanf("%d", &amp;nums[i]); // build heap for(int i =n/2; i; i--) heapify(i); // heap sort while(m --) &#123; printf("%d ", nums[1]); // å †é¡¶å…ƒç´  nums[1] =nums[n]; heapify(1); n --; &#125; return 0;&#125; è¡¥å……ï¼š stack æ ˆï¼Œ FILOï¼Œå…ˆè¿›åŽå‡ºï¼Œæ ˆæº¢å‡ºéƒ½æ˜¯å®ƒ heapï¼Œå¤§æ ¹å †ã€å°æ ¹å †ï¼Œå¸¸ç”¨åœ¨å¤§é‡çš„æ•°æ®è¿›è¡ŒæŽ’åºï¼Œæ˜¯ä¸€ç§æ ‘å½¢ç»“æž„ queue é˜Ÿåˆ—ï¼Œå…ˆè¿›å…ˆå‡º æ¡¶æŽ’åºæŽ’åºç®—æ³•åˆ†ä¸¤å¤§ç±»ï¼ŒåŸºäºŽæ¯”è¾ƒçš„æŽ’åºå’ŒéžåŸºäºŽæ¯”è¾ƒçš„æŽ’åºã€‚æ²¡å•¥å¥½è§£é‡Šçš„ï¼ŒåŸºäºŽæ¯”è¾ƒçš„ï¼Œæ¯”å¦‚å†’æ³¡æŽ’åºã€æ’å…¥æŽ’åºã€é€‰æ‹©æŽ’åºã€å¸Œå°”æŽ’åºã€å †æŽ’åºã€å½’å¹¶æŽ’åºã€å¿«é€ŸæŽ’åºï¼ŒåŸºäºŽæ¯”è¾ƒçš„æŽ’åºå¤æ‚åº¦ä¸‹é™ä¸º $O(nlogn) $ã€‚éžåŸºäºŽæ¯”è¾ƒçš„æŽ’åºå¦‚ï¼Œæ¡¶æŽ’åºã€è®¡æ•°æŽ’åºã€åŸºæ•°æŽ’åºã€‚éžåŸºäºŽæ¯”è¾ƒçš„æŽ’åºä¸å— $O(nlogn) $è¿™ä¸ªä¸‹é™çš„çº¦æŸï¼Œèƒ½å¤Ÿè¾¾åˆ° $O(n)$çš„å¤æ‚åº¦ã€‚ä½†æ˜¯éžåŸºäºŽæ¯”è¾ƒçš„ç®—æ³•ä¸€èˆ¬å¯¹æ•°æ®æœ‰æ¯”è¾ƒä¸¥æ ¼çš„è¦æ±‚ï¼Œæ‰€ä»¥ä¸€èˆ¬ç”¨æ¥å¤„ç†ä¸€äº›æœ‰ç‰¹å¾æ€§çš„æ•°æ®çš„æŽ’åºã€‚ é€‚ç”¨èŒƒå›´ï¼šä¸»è¦é€‚ç”¨äºŽå°èŒƒå›´æ•´æ•°æ•°æ®ï¼Œä¸”ç‹¬ç«‹å‡åŒ€åˆ†å¸ƒï¼Œå¯ä»¥è®¡ç®—çš„æ•°æ®é‡å¾ˆå¤§ï¼Œè€Œä¸”ç¬¦åˆçº¿æ€§æœŸæœ›æ—¶é—´ã€‚ ç®—æ³•æ­¥éª¤ï¼š è®¾ç½®å›ºå®šæ•°é‡çš„ç©ºæ¡¶ã€‚ æŠŠæ•°æ®æ”¾åˆ°å¯¹åº”çš„æ¡¶ä¸­ã€‚ å¯¹æ¯ä¸ªä¸ä¸ºç©ºçš„æ¡¶ä¸­æ•°æ®è¿›è¡ŒæŽ’åºã€‚ æ‹¼æŽ¥ä»Žä¸ä¸ºç©ºçš„æ¡¶ä¸­æ•°æ®ï¼Œå¾—åˆ°ç»“æžœã€‚ è®¾ç½®æ¡¶çš„æ•°é‡ä¸º5ä¸ªç©ºæ¡¶ï¼Œæ‰¾åˆ°æœ€å¤§å€¼110ï¼Œæœ€å°å€¼7ï¼Œæ¯ä¸ªæ¡¶çš„èŒƒå›´20.8=(110-7+1)/5 ã€‚ éåŽ†åŽŸå§‹æ•°æ®ï¼Œä»¥é“¾è¡¨ç»“æž„ï¼Œæ”¾åˆ°å¯¹åº”çš„æ¡¶ä¸­ã€‚æ•°å­—7ï¼Œæ¡¶ç´¢å¼•å€¼ä¸º0ï¼Œè®¡ç®—å…¬å¼ä¸ºfloor((7 â€“ 7) / 20.8)ï¼Œ æ•°å­—36ï¼Œæ¡¶ç´¢å¼•å€¼ä¸º1ï¼Œè®¡ç®—å…¬å¼floor((36 â€“ 7) / 20.8)ã€‚ å½“å‘åŒä¸€ä¸ªç´¢å¼•çš„æ¡¶ï¼Œç¬¬äºŒæ¬¡æ’å…¥æ•°æ®æ—¶ï¼Œåˆ¤æ–­æ¡¶ä¸­å·²å­˜åœ¨çš„æ•°å­—ä¸Žæ–°æ’å…¥æ•°å­—çš„å¤§å°ï¼ŒæŒ‰ç…§å·¦åˆ°å³ï¼Œä»Žå°åˆ°å¤§çš„é¡ºåºæ’å…¥ã€‚å¦‚ï¼šç´¢å¼•ä¸º2çš„æ¡¶ï¼Œåœ¨æ’å…¥63æ—¶ï¼Œæ¡¶ä¸­å·²å­˜åœ¨4ä¸ªæ•°å­—56ï¼Œ59ï¼Œ60ï¼Œ65ï¼Œåˆ™æ•°å­—63ï¼Œæ’å…¥åˆ°65çš„å·¦è¾¹ã€‚ åˆå¹¶éžç©ºçš„æ¡¶ï¼ŒæŒ‰ä»Žå·¦åˆ°å³çš„é¡ºåºåˆå¹¶0ï¼Œ1ï¼Œ2ï¼Œ3ï¼Œ4æ¡¶ã€‚ å¾—åˆ°æ¡¶æŽ’åºçš„ç»“æž„ å®žé™…çš„åº”ç”¨åœºæ™¯ï¼šä¸€å¹´çš„å…¨å›½é«˜è€ƒè€ƒç”Ÿäººæ•°ä¸º500 ä¸‡ï¼Œåˆ†æ•°ä½¿ç”¨æ ‡å‡†åˆ†ï¼Œæœ€ä½Ž100 ï¼Œæœ€é«˜900 ï¼Œæ²¡æœ‰å°æ•°ï¼Œä½ æŠŠè¿™500 ä¸‡å…ƒç´ çš„æ•°ç»„æŽ’ä¸ªåºã€‚ æ¡¶æŽ’åºç®—æ³•è¯¦è§£ å‚è€ƒæ–‡çŒ®ç®—æ³•åŠ¨å›¾æ•ˆæžœæŽ’åºç®—æ³•åˆ†ç±» æ‹“æ‰‘æŽ’åºæ‹“æ‰‘åºåˆ—ï¼š è®¾åœ¨ $G =(V, E)$ æ˜¯ä¸€ä¸ªå…·æœ‰ $n$ ä¸ªé¡¶ç‚¹çš„æœ‰å‘å›¾ï¼Œé›†åˆ $V$ çš„é¡¶ç‚¹åºåˆ— $v_1$, $v_2$â€¦ $v_n$ ç§°ä¸ºä¸€ä¸ªæ‹“æ‰‘åºåˆ—ï¼Œéœ€æ»¡è¶³ä¸‹åˆ—æ¡ä»¶ï¼š è‹¥ä»Žé¡¶ç‚¹ $v_i$ åˆ°$v_j$ æœ‰ä¸€æ¡è·¯å¾„ï¼Œé‚£ä¹ˆåœ¨é¡¶ç‚¹åºåˆ—ä¸­é¡¶ç‚¹ $v_i$ å¿…é¡»åœ¨é¡¶ç‚¹ $v_j$ ä¹‹å‰ã€‚ åœ¨å›¾è®ºä¸­ï¼Œæ‹“æ‰‘æŽ’åºï¼ˆTopological Sortingï¼‰æ˜¯ä¸€ä¸ªæœ‰å‘æ— çŽ¯å›¾ï¼ˆDAG, Directed Acyclic Graphï¼‰çš„æ‰€æœ‰é¡¶ç‚¹çš„çº¿æ€§åºåˆ—ã€‚ä¸”è¯¥åºåˆ—å¿…é¡»æ»¡è¶³ä¸‹é¢ä¸¤ä¸ªæ¡ä»¶ï¼š æ¯ä¸ªé¡¶ç‚¹å‡ºçŽ°ä¸”åªå‡ºçŽ°ä¸€æ¬¡ã€‚ è‹¥å­˜åœ¨ä¸€æ¡ä»Žé¡¶ç‚¹ A åˆ°é¡¶ç‚¹ B çš„è·¯å¾„ï¼Œé‚£ä¹ˆåœ¨åºåˆ—ä¸­é¡¶ç‚¹ A å‡ºçŽ°åœ¨é¡¶ç‚¹ B çš„å‰é¢ã€‚ æ‹“æ‰‘æŽ’åºåŸºæœ¬æ€æƒ³ï¼š ä»ŽAOV ç½‘ä¸­é€‰æ‹©ä¸€ä¸ªæ²¡æœ‰å‰é©±é¡¶ç‚¹å¹¶ä¸”è¾“å‡º ä»ŽAOV ç½‘ä¸­åˆ é™¤è¯¥é¡¶ç‚¹ï¼Œå¹¶ä¸”åˆ åŽ»æ‰€æœ‰ä»¥è¯¥é¡¶ç‚¹ä¸ºå°¾çš„å¼§ é‡å¤ä¸Šè¿°ä¸¤éƒ¨ï¼Œç›´åˆ°å…¨éƒ¨é¡¶ç‚¹éƒ½è¢«è¾“å‡ºï¼Œæˆ–è€…AOV ç½‘ä¸­ä¸å­˜åœ¨æ²¡æœ‰å‰é©±çš„é¡¶ç‚¹ã€‚ æ‹“æ‰‘åºåˆ—ä¸æ˜¯å”¯ä¸€çš„å“¦ã€‚ AOV ç½‘ï¼š activity on vexesï¼ˆåœ¨é¡¶ç‚¹ä¸Šçš„æ´»åŠ¨ï¼‰ æ‹“æ‰‘æŽ’åºçš„åº”ç”¨ åˆ¤æ–­æ˜¯å¦å­˜åœ¨çŽ¯ï¼Œå¦‚æžœè¾“å‡ºèƒ½å¤Ÿå¾—åˆ°æ‰€æœ‰çš„é¡¶ç‚¹ï¼Œé‚£ä¹ˆæ²¡æœ‰å­˜åœ¨çŽ¯ï¼›å¦åˆ™å°±å­˜åœ¨çŽ¯ã€‚ æ‹“æ‰‘æŽ’åºé€šå¸¸ç”¨æ¥â€œæŽ’åºâ€ å…·æœ‰ä¾èµ–å…³ç³»çš„ä»»åŠ¡ã€‚ è¿™é‡Œè¦è¡¥å……ä¸¤ä¸ªæ¦‚å¿µï¼Œååºå’Œå…¨åºï¼Ÿ ååºï¼šæœ‰å‘å›¾ä¸­ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´ä¸å­˜åœ¨çŽ¯è·¯ï¼Œè‡³äºŽè¿žé€šä¸Žå¦ï¼Œæ˜¯æ— æ‰€è°“çš„ã€‚å…¨åºï¼šå°±æ˜¯åœ¨ååºçš„åŸºç¡€ä¹‹ä¸Šï¼Œæœ‰å‘æ— çŽ¯å›¾ä¸­çš„ä»»æ„ä¸€å¯¹é¡¶ç‚¹è¿˜éœ€è¦æœ‰æ˜Žç¡®çš„å…³ç³»(åæ˜ åœ¨å›¾ä¸­ï¼Œå°±æ˜¯å•å‘è¿žé€šçš„å…³ç³»ï¼Œæ³¨æ„ä¸èƒ½åŒå‘è¿žé€šï¼Œé‚£å°±æˆçŽ¯äº†)ã€‚ æ„æ€å°±æ˜¯è®²ï¼Œä¸€ä¸ªä¸ç¡®å®šçš„ååºå…³ç³»ç»å…¨åºåŽå°±æœ‰ä¸€ç§ç¡®å®šçš„å…ˆåŽé¡ºåºäº†ã€‚æ—¢ç„¶æœ‰å…ˆåŽï¼Œé‚£ä¹ˆåœ¨å®žé™…ç”Ÿæ´»ä¸­çš„é€‰è¯¾é—®é¢˜ï¼Œæ¯”å¦‚å¤§ä¸€æ—¶ä¸€å®šè¦ä¿®å®Œè¿™é—¨è¯¾ï¼Œå¤§äºŒæ‰å­¦ç¬¬äºŒé—¨è¯¾ï¼Œè¿™ç§æŽ’è¯¾é—®é¢˜å°±æ˜¯æ‹“æ‰‘æŽ’åºé—®é¢˜ã€‚ å›¾çš„å­˜å‚¨ç»“æž„- é‚»æŽ¥çŸ©é˜µå’Œé‚»æŽ¥è¡¨ ç®€å•çš„è¯´ï¼Œå›¾ç”±è¡¨ç¤ºæ•°æ®å…ƒç´ çš„é›†åˆVå’Œè¡¨ç¤ºæ•°æ®ä¹‹é—´å…³ç³»çš„é›†åˆEç»„æˆï¼Œè®°ä¸ºG=&lt;V,E&gt;ã€‚å›¾åˆåˆ†ä¸ºæœ‰å‘å›¾ä¸Žæ— å‘å›¾ã€‚ä¸‹é¢æ˜¯å›¾çš„ä¸€äº›åŸºæœ¬å…ƒç´ ï¼š è¾¹(edge)ï¼šé¡¶ç‚¹çš„åºå¶ã€‚ é¡¶ç‚¹(vertex)ï¼šæ•°æ®å…ƒç´ ã€‚ æƒé‡(weight)ï¼šç”¨æ¥è¡¨ç¤ºä¸€ä¸ªé¡¶ç‚¹åˆ°å¦ä¸€ä¸ªé¡¶ç‚¹çš„è·ç¦»ã€ä»£ä»·ã€è€—è´¹ç­‰ã€‚ åº¦(degree)ï¼šä¸Žè¯¥é¡¶ç‚¹ç›¸å…³è”çš„è¾¹çš„æ•°ç›®ï¼Œå…¥åº¦ã€å‡ºåº¦ç­‰ç­‰ã€‚ å›¾çš„ç›¸é‚»çŸ©é˜µå‚¨å­˜ç±»åž‹ å›¾çš„ç›¸é‚»çŸ©é˜µæˆ–é‚»æŽ¥çŸ©é˜µè¡¨ç¤ºå®šç‚¹ä¹‹é—´çš„é‚»æŽ¥å…³ç³»ï¼Œå³è¡¨ç¤ºé¡¶ç‚¹ä¹‹é—´æœ‰è¾¹æˆ–æ²¡æœ‰è¾¹çš„æƒ…å†µã€‚å¦‚ä¸‹å›¾åˆ™æ˜¯æ— å‘å›¾G1å’Œæœ‰å‘å›¾G2çš„é‚»æŽ¥çŸ©é˜µã€‚ æ— è®ºæ˜¯æœ‰å‘å›¾è¿˜æ˜¯æ— å‘å›¾ï¼Œé‚»æŽ¥çŸ©é˜µæ¯”è¾ƒå¥½è¡¨ç¤ºã€‚ æœ‰å‘å›¾çš„é‚»æŽ¥è¡¨æ˜¯æ¯”è¾ƒå¥½è¡¨ç¤ºï¼š ä¸‹ä¸€ä¸ªç»“ç‚¹æ˜¯æœ‰å‘å›¾ä¸­ç»“ç‚¹çš„ä¸‹ä¸€ä¸ªç»“ç‚¹ã€‚ ä½¿ç”¨é‚»æŽ¥è¡¨è¡¨ç¤ºæ— å‘å›¾ Course Schedule ä½¿ç”¨é‚»æŽ¥è¡¨å’Œé˜Ÿåˆ— ï¼ˆbfsï¼‰å®žçŽ°æ‹“æ‰‘æŽ’åºã€‚ æ—¶é—´å¤æ‚åº¦æ˜¯ $ O(n+m)$ 12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool canFinish(int num, vector&lt;vector&lt;int&gt;&gt;&amp; pre) &#123; vector&lt;vector&lt;int&gt;&gt; adj(num); vector&lt;int&gt; in_degree(num, 0); for(int i =0; i&lt; pre.size() ; i++) &#123; in_degree[pre[i][0]] ++; adj[pre[i][1]].push_back(pre[i][0]); &#125; for(auto u: in_degree) cout &lt;&lt; u&lt;&lt;" "; queue&lt;int&gt; q; int couts =0; for(int i =0; i&lt; num; i++) &#123; if(in_degree[i] ==0) q.push(i); &#125; while(!q.empty()) &#123; int t =q.front(); q.pop(); couts +=1; for(int i =0; i&lt; adj[t].size(); i++) &#123; in_degree[adj[t][i]] --; if(in_degree[adj[t][i]] ==0) q.push(adj[t][i]); &#125; &#125; return couts ==num; &#125;&#125;; 207. Course Schedule æ‹“æ‰‘æŽ’åº ($O(m +n)$) å°†å…ˆä¿®å…³ç³»æž„æˆä¸€å¼ å›¾ï¼Œç”±æ¯ä¸ªæ•°å¯¹çš„ç¬¬äºŒä¸ªæ•°å­—å‘ç¬¬ä¸€ä¸ªæ•°å­—è¿žè¾¹ã€‚ é¦–å…ˆå°†æ‰€æœ‰å…¥åº¦ä¸º0çš„ç‚¹è¿›é˜Ÿï¼Œå‡†å¤‡æ‹“æ‰‘æŽ’åºã€‚ å®½æœè¿‡ç¨‹ä¸­ï¼Œå°†å½“å‰ç»“ç‚¹æ‰€å…³è”çš„ç»“ç‚¹çš„å…¥åº¦å‡1ï¼›è‹¥å‘çŽ°æ–°çš„å…¥åº¦ä¸º0çš„ç»“ç‚¹ï¼Œåˆ™å°†å…¶è¿›é˜Ÿã€‚ æœ€åŽå¦‚æžœéåŽ†äº†æ‰€æœ‰ç»“ç‚¹ï¼Œåˆ™è¯´æ˜Žå¯ä»¥æ»¡è¶³è¦æ±‚ï¼›å¦åˆ™ï¼Œå…ˆä¿®å…³ç³»å­˜åœ¨çŽ¯ã€‚ 12345678910111213141516171819202122232425262728293031class Solution &#123;public: // æ˜¯ä¸€ä¸ªåˆ¤åˆ«é¢˜ç›®ï¼Œ å¦‚æžœè¯´æ‹“æ‰‘æŽ’åºèƒ½å¤ŸæŽ’ä¸‹æ¥ï¼Œé‚£ä¹ˆå°±å¯ä»¥è®¤ä¸ºæ˜¯è¾¾åˆ°äº†è¦æ±‚ bool canFinish(int n, vector&lt;vector&lt;int&gt;&gt;&amp; pre) &#123; vector&lt;vector&lt;int&gt;&gt; adj(n); // è¿™ä¸ªè¡¨æ˜Žå¯ä»¥ adj[i] è¿™æ ·è¿›è¡ŒéåŽ† vector&lt;int&gt; in_degree(n, 0); queue&lt;int&gt; q; int counts =0; // å¤„ç†åŽŸæ¥çš„æ•°æ®å˜æˆé‚»æŽ¥è¡¨å’Œå…¥åº¦è¡¨ for(int i =0; i&lt; pre.size() ; i++) &#123; adj[pre[i][1]].push_back(pre[i][0]); in_degree[pre[i][0]] ++; &#125; // è¿™ä¸ªn è¡¨ç¤ºçš„å°±æ˜¯è¯¾ç¨‹çš„æ•°é‡ï¼Œåˆ¤åˆ«çš„æ˜¯è¯¾è¡¨çš„åˆç†ä¸Žå¦ï¼Œæ‰€ä»¥ç›´æŽ¥pushçš„i for(int i =0; i&lt; n ; i++) if(in_degree[i] ==0) q.push(i); while(q.size()) &#123; auto t =q.front(); q.pop(); counts ++; for(int i =0; i&lt; adj[t].size(); i++) &#123; in_degree[adj[t][i]] --; if(in_degree[adj[t][i]] ==0) q.push(adj[t][i]); &#125; &#125; return counts ==n; &#125;&#125;; python å®žçŽ° 12345678910111213141516171819202122232425262728from queue import *class Solution: def canFinish(self, n: int, pre: List[List[int]]) -&gt; bool: adj =&#123;&#125; in_degree=&#123;&#125; # å¯¹äºŽå˜é‡çš„åˆå§‹åŒ– for i in range(n): adj[i] =[] in_degree[i] =0 # å¤„ç†pre æ•°ç»„ for c, p in pre: adj[p].append(c) in_degree[c] +=1 q =Queue() counts =0 for i in range(n): if(in_degree[i] ==0): q.put(i) while q.qsize(): t =q.get() counts +=1 for val in adj[t]: in_degree[val] -=1 if(in_degree[val] ==0): q.put(val) return counts ==n 210. Course Schedule II 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: // è¿™ä¸ªå’Œä¸Šä¸€é“é¢˜ç›¸æ¯”ï¼Œéœ€è¦è®°å½•ä¸€ä¸ªè·¯å¾„ // éœ€è¦è¿”å›žä¸€ä¸ª res è¿™æ ·çš„æ•°å­— vector&lt;int&gt; findOrder(int n, vector&lt;vector&lt;int&gt;&gt;&amp; pre) &#123; vector&lt;vector&lt;int&gt;&gt; adj(n); vector&lt;int&gt; indegree(n, 0); // è¿™ä¸ªåˆå§‹åŒ–æ˜¯ä¸ºäº†èƒ½å¤Ÿå®žçŽ° ++ æ“ä½œ // å¤„ç†å®Œäº†åŽŸå…ˆçš„æ•°æ® for(int i =0; i&lt; pre.size() ; i++) &#123; indegree[pre[i][0]] ++; adj[pre[i][1]].push_back(pre[i][0]); &#125; queue&lt;int&gt; q; for(int i =0; i&lt; n; i++) if(indegree[i]==0) q.push(i); vector&lt;bool&gt; st(n, false); vector&lt;int&gt; res; while(q.size()) &#123; auto t =q.front(); q.pop(); res.push_back(t); st[t] =true; // update ä¿¡æ¯ for( int i =0; i&lt; adj[t].size() ; i++) &#123; indegree[adj[t][i]] --; if(indegree[adj[t][i]] ==0) q.push(adj[t][i]); &#125; &#125; for(int i =0; i&lt; n; i++) &#123; if(st[i] == false) return vector&lt;int&gt;&#123;&#125;; &#125; return res; &#125;&#125;; python ç‰ˆæœ¬ 123456789101112131415161718192021222324252627282930313233343536from queue import *class Solution: # è¿™ä¸ªç›¸è¾ƒäºŽä¸Šä¸€ä¸ªé¢˜ç›® éœ€è¦ä¿å­˜ä¸€ä¸ªè·¯å¾„ def findOrder(self, n: int, pre: List[List[int]]) -&gt; List[int]: adj =&#123;&#125; in_degree =&#123;&#125; # åˆå§‹åŒ– for i in range(n): adj[i] =[] in_degree[i] =0 # å¤„ç†æ•°æ® for c, p in pre: in_degree[c] +=1 adj[p].append(c) # æ”¾åˆ° queue ä¸­ q = Queue() for i in range(n): if(in_degree[i] ==0): q.put(i) res =[] st =[False] *n while q.qsize(): t =q.get() st[t] =True res.append(t) for val in adj[t]: in_degree[val] -=1 if(in_degree[val] ==0): q.put(val) for i in range(n): if(st[i] ==False): return [] return res; æ—¶é—´å¤æ‚åº¦æŽ’åºæ—¶é—´å¤æ‚åº¦ä¸º $O(nlogn)$ï¼Œæžšä¸¾è¯¾ç¨‹éœ€$ O(n)$ï¼Œæ¯æ¬¡è®¿é—®å•è°ƒé˜Ÿåˆ—éœ€è¦ $O(logn)$ï¼ˆå› ä¸ºåŸºäºŽ å¤§æ ¹å †å®žçŽ°çš„ï¼‰ï¼Œæ•…æ€»æ—¶é—´å¤æ‚åº¦ä¸º $O(nlogn)$ã€‚ ç©ºé—´å¤æ‚åº¦$O(n)$ 630. Course Schedule III c++ çš„ä»£ç  123456789101112131415161718192021222324252627282930313233class Solution &#123;public: // æ€è·¯å¾ˆç®€å•ï¼Œä½¿ç”¨ä¸€ä¸ªå¤§æ ¹å †ï¼Œä¿å­˜å¯èƒ½çš„ç»“æžœï¼› // å¯¹äºŽè¿™ç§æ—¶é—´å®‰æŽ’çš„é—®é¢˜ï¼Œåšæ³•æ˜¯æŒ‰ç…§ç»“æŸæ—¶é—´è¿›è¡ŒæŽ’åºï¼› static bool cmp(vector&lt;int&gt; &amp;x, vector&lt;int&gt; &amp; y) &#123; return x[1] &lt;y[1]; &#125; int scheduleCourse(vector&lt;vector&lt;int&gt;&gt;&amp; courses) &#123; sort(courses.begin(), courses.end(), cmp); priority_queue&lt;int&gt; q; int n =courses.size(); int tot =0; for(int i =0; i&lt; n; i++) &#123; if(tot + courses[i][0] &lt;= courses[i][1]) &#123; tot += courses[i][0]; q.push(courses[i][0]); &#125; else if(!q.empty()) &#123; if(q.top() &gt; courses[i][0]) &#123; tot = tot + courses[i][0] - q.top(); q.pop(); q.push(courses[i][0]); &#125; &#125; &#125; return q.size(); &#125;&#125;; æ²¡æœ‰è¿è¡Œå‡ºæ¥çš„ä»£ç  1234567891011121314151617181920212223242526272829303132class Solution &#123;public: // è¿™ä¸ªæ€è·¯ä¹Ÿæ˜¯æ¯”è¾ƒç®€å•ï¼Œæ ¹æ®ç»“æŸæ—¶é—´æŽ’åºï¼Œå°½å¯èƒ½é€‰æ‹©æ—¶é•¿çŸ­ static bool cmp(pair&lt;int, int&gt; x, pair&lt;int, int&gt; y) &#123; if(x.first == y.first) return x.second &lt;= y.second; else return x.first &lt;y.first; &#125; int scheduleCourse(vector&lt;vector&lt;int&gt;&gt;&amp; courses) &#123; // ä½¿ç”¨pair&lt;&gt; åŒå…³é”®å­—, é¦–å…ˆæ˜¯æŒ‰ç…§ ç»“æŸæ—¶é—´æŽ’åºï¼Œç„¶åŽæŒ‰ç…§æ—¶é•¿æŽ’åºï¼Œ æ„å‘³ç€ç»“æŸæ—¶é—´å°ï¼Œæ—¶é•¿å°ï¼Œé‚£ä¹ˆè‚¯å®šæ˜¯å…ˆé€‰çš„ typedef pair&lt;int, int&gt; PAIR; vector&lt;PAIR&gt; res; for(auto c : courses) &#123; PAIR p&#123;c[1], c[0]&#125;; res.push_back(p); &#125; sort(res.begin(). res.end(), cmp); int t =0; int counts =0; for (auto c : courses) &#123; if(t + c.second&lt; c.first) &#123; t += c.second; counts +=1; &#125; &#125; return counts ; &#125;&#125;; è¿™ç§ç®—æ³•æ›´åŠ çš„ç²¾å¦™ï¼Œå…ˆæ˜¯æ— è„‘çš„åŠ å…¥ï¼Œå¦‚æžœæœ‰ä¸ç¬¦åˆæ¡ä»¶çš„ï¼Œé‚£ä¹ˆå°±pop å‡ºæ¥ã€‚ 1234567891011121314151617181920212223242526class Solution &#123;public: // æ€è·¯å¾ˆç®€å•ï¼Œä½¿ç”¨ä¸€ä¸ªå¤§æ ¹å †ï¼Œä¿å­˜å¯èƒ½çš„ç»“æžœï¼› // å¯¹äºŽè¿™ç§æ—¶é—´å®‰æŽ’çš„é—®é¢˜ï¼Œåšæ³•æ˜¯æŒ‰ç…§ç»“æŸæ—¶é—´è¿›è¡ŒæŽ’åºï¼› static bool cmp(vector&lt;int&gt; &amp;x, vector&lt;int&gt; &amp; y) &#123; return x[1] &lt;y[1]; &#125; int scheduleCourse(vector&lt;vector&lt;int&gt;&gt;&amp; courses) &#123; sort(courses.begin(), courses.end(), cmp); priority_queue&lt;int&gt; q; int n =courses.size(); int tot =0; for(int i =0; i&lt; n; i++) &#123; q.push(courses[i][0]); tot += courses[i][0]; if(tot &gt; courses[i][1]) &#123; tot -= q.top(); q.pop(); &#125; &#125; return q.size(); &#125;&#125;; python å®žçŽ°python å†…ç½®çš„å‡½æ•°å®žçŽ°çš„æ˜¯å°æ ¹å †ï¼Œé‚£ä¹ˆpush è¿›åŽ»çš„æ˜¯ Â·-tÂ· ,è¿™ä¸ªæ“ä½œä¸­æ›´åŠ èƒ½ä½“çŽ° å…ˆæ˜¯æ— è„‘åŠ ï¼Œå¦‚æžœä¸ç¬¦åˆè¦æ±‚ï¼Œé‚£ä¹ˆå†pop å‡ºæ¥ã€‚ å¤šæ€è€ƒä½¿ç”¨å¤§æ ¹å †å’Œå°æ ¹å †åŒºåˆ«ã€‚æ˜¯è¦ä¿è¯pop å‡ºæ¥çš„æ˜¯æ—¶é•¿æœ€é•¿çš„é‚£ä¸ªï¼Œå› ä¸ºå¦‚æžœå¯ä»¥çš„è¯ï¼Œå°½å¯èƒ½é€‰æ‹©æ—¶é•¿çŸ­çš„è¯¾ç¨‹å‘¢ã€‚ 123456789101112class Solution: def scheduleCourse(self, courses: List[List[int]]) -&gt; int: # æŒ‰ç…§ç»“æŸæ—¶é—´è¿›è¡ŒæŽ’åº courses.sort(key =lambda x: x[1]) heap =[] tot =0 for t, e in courses: heapq.heappush(heap, -t) tot += t if(tot &gt; e): tot += heapq.heappop(heap) return len(heap)]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>æŽ’åºç®—æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é‚£äº›å¹´çš„ç®—æ³•é¢˜ç›®ï¼ˆä¸€ï¼‰]]></title>
    <url>%2F2018%2F06%2F22%2F%E9%82%A3%E4%BA%9B%E5%B9%B4%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[å®Œå…¨äºŒå‰æ ‘æ’å…¥é—®é¢˜æè¿°å·²çŸ¥ä¸€ä¸ªå®Œå…¨äºŒå‰æ ‘çš„ç»“æž„ï¼ŒçŽ°åœ¨éœ€è¦å°†ä¸€ä¸ªèŠ‚ç‚¹æ’å…¥åˆ°è¿™é¢—å®Œå…¨äºŒå‰æ ‘çš„æœ€åŽï¼Œä½¿å¾—å®ƒè¿˜æ˜¯ä¸€ä¸ªå®Œå…¨äºŒå‰æ ‘ã€‚ç¬¬ä¸€ç§è§£æ³•ï¼šå¦‚æžœè¯¥æ ‘ä¸ºæ»¡äºŒå‰æ ‘æˆ–è€…å·¦å­æ ‘ä¸ä¸ºæ»¡äºŒå‰æ ‘ï¼Œé‚£ä¹ˆå°±è¿›å…¥å·¦å­æ ‘ï¼Œå¦åˆ™è¿›å…¥å³å­æ ‘ï¼Œé€’å½’è¿›è¡Œã€‚ äºŒå‰æ ‘(Binary Tree) äºŒå‰æ ‘ ä»»ä½•ä¸€ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ•°é‡ä¸è¶…è¿‡2 å®Œå…¨äºŒå‰æ ‘ æ‰€æœ‰å¶å­ç»“ç‚¹éƒ½åœ¨æœ€åŽä¸€å±‚æˆ–å€’æ•°ç¬¬äºŒå±‚ã€‚ æœ€åŽä¸€å±‚çš„å¶å­ç»“ç‚¹åœ¨å·¦è¾¹è¿žç»­ï¼Œå€’æ•°ç¬¬äºŒèŠ‚çš„å¶å­ç»“ç‚¹åœ¨å³ä¾§è¿žç»­ã€‚ æ»¡äºŒå‰æ ‘ æ‰€æœ‰å¶å­ç»“ç‚¹éƒ½åœ¨æœ€åŽä¸€å±‚ ç»“ç‚¹çš„æ€»æ•°ä¸º $2^n -1$ (n ä¸ºæ ‘çš„é«˜åº¦) æ»¡äºŒå‰æ ‘æ˜¯ä¸€ç§ç‰¹æ®Šçš„å®Œå…¨äºŒå‰æ ‘ å¹³è¡¡äºŒå‰æ ‘ ä¹Ÿå« AVL æ ‘ å®ƒæ˜¯ä¸€é¢—ç©ºæ ‘æˆ–å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡1ã€‚ å·¦å³ä¸¤ä¸ªå­æ ‘å‡ä¸ºå¹³è¡¡äºŒå‰æ ‘ã€‚ äºŒå‰æœç´¢æ ‘ï¼ˆBinary Search Treeï¼‰ ä¹Ÿå«äºŒå‰æŸ¥æ‰¾æ ‘ã€äºŒå‰æŽ’åºæ ‘ è‹¥å­æ ‘ä¸ç©ºï¼Œåˆ™å­æ ‘ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„å€¼å‡å°äºŽæˆ–ç­‰äºŽæ ¹èŠ‚ç‚¹çš„å€¼ã€‚ è‹¥å³å­æ ‘ä¸ç©ºï¼Œåˆ™å³å­æ ‘æ‰€æœ‰èŠ‚ç‚¹çš„å€¼å‡å¤§äºŽæˆ–ç­‰äºŽæ ¹èŠ‚ç‚¹çš„å€¼ã€‚ å·¦ã€å³å­æ ‘ä¹Ÿåˆ†åˆ«ä¸ºäºŒå‰æŽ’åºæ ‘ï¼Œæˆ–æ˜¯ä¸€é¢—ç©ºæ ‘ã€‚ å“ˆå¤«æ›¼æ ‘ å¸¦æƒè·¯å¾„é•¿åº¦è¾¾åˆ°æœ€å°çš„äºŒå‰æ ‘ï¼Œä¹Ÿå«åšæœ€ä¼˜äºŒå‰æ ‘ã€‚ æ ‘çš„æ·±åº¦å’Œé«˜åº¦ï¼šæ·±åº¦æ˜¯ä»Žä¸Šå¾€ä¸‹æ•°ï¼›é«˜åº¦æ˜¯ä»Žä¸‹å¾€ä¸Šæ•° ä»£ç å®žçŽ°å¹³æ»‘è¿‡æ¸¡åˆ°æœ¬é—®é¢˜çš„ä»£ç å®žçŽ°ã€‚æ ‘çš„é«˜åº¦å°±æ˜¯æ ‘çš„éåŽ†ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;using namespace std;typedef struct Node&#123; int value; struct Node *lchild, *rchild;&#125;Tree;int GetLeftDepth(Tree* root)&#123; Tree* pNode =root-&gt;lchild ; int depth =0; while(pNode != NULL) &#123; depth ++; pNode =pNode-&gt;lchild; &#125; return depth;&#125;int GetRightDepth(Tree* root)&#123; Tree* pNode =root-&gt;rchild; int depth =0 ; while(pNode != NULL) &#123; depth ++ ; pNode =pNode-&gt;rchild ; &#125; return depth;&#125;bool IsFullBinaryTree(Tree* root)&#123; return GetLeftDepth(root) == GetRightDepth(root) ;&#125;void insert(Tree* root, Tree * node)&#123; if (IsFullBinaryTree(root) || !IsFullBinaryTree(root-&gt;lchild))&#123; insert(root-&gt;lchild, node); return ; &#125; if (root-&gt;rchild ==NULL)&#123; root-&gt;rchild =node ; return ; &#125; insert(root-&gt;rchild, node) ;&#125;int main()&#123; Node* a = new Node(); a-&gt;value =1;&#125; inplace åŽ»é™¤è¿žç»­çš„ 0ç»™å®šä¸€ä¸ªä¸€ç»´æ•´æ•°æ•°ç»„ï¼Œä¸ä½¿ç”¨é¢å¤–çš„ç©ºé—´ï¼Œæœ¬åœ°åŽ»æŽ‰æ•°ç»„ä¸­è¿žç»­çš„0ã€‚ Tipsï¼š å‰åŽä¸¤ä¸ªæŒ‡é’ˆï¼Œåˆ¤æ–­æ˜¯å¦æ˜¯è¿žç»­çš„0ã€‚ç¬¬ä¸‰ä¸ªæŒ‡é’ˆæ ‡è®°æ–°çš„æ•°ç»„ï¼Œå‰è€…è¦†ç›–åŽè€…ã€‚ 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;int RemoveDuplicates(int* sortBuffer,int length)&#123; if(sortBuffer == NULL || length == 0) &#123; return false; &#125; int count = 0; for(int i = 1; i &lt; length; i++) &#123; if(sortBuffer[i] ==0 &amp;&amp; 0 == sortBuffer[i-1]) &#123; continue; &#125; else &#123; sortBuffer[count]=sortBuffer[i]; count++; &#125; &#125; return count; &#125;int main()&#123; int length =sizeof(array)/sizeof(int); &#125; æœ€å¤§è¿žç»­å­æ•°ç»„å’Œå·²çŸ¥ä¸€ä¸ªæ•´æ•°äºŒç»´æ•°ç»„ï¼Œæ±‚æœ€å¤§çš„å­æ•°ç»„å’Œ(å­æ•°ç»„çš„å®šä¹‰ä»Žå·¦ä¸Šè§’(x0,y0) åˆ°å³ä¸‹è§’(x1,y1)çš„æ•°ç»„)å…ˆè€ƒè™‘ä¸€ç»´æ•´æ•°æ•°ç»„çš„æƒ…å†µã€‚ 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int Max(int a, int b)&#123; return a&gt;b ?a:b;&#125;int FindGreatestSubarray(int *arr, int n)&#123; int sum =arr[0]; int max =arr[0]; for(int i =1; i&lt;n; i++)&#123; sum =Max(sum+arr[i], arr[i]); max =Max(sum, max) &#125; return max;&#125;int main()&#123; return 0;&#125; æœ¬é¢˜ç›®çš„è¦æ±‚æ˜¯ä»ŽäºŒä½çš„æ•°ç»„ä¸­æ±‚è§£æœ€å¤§çš„å­çŸ©é˜µã€‚æˆ‘ä»¬å¯ä»¥å°†å…¶è½¬åŒ–æˆä¸€ç»´æ•°ç»„çš„é—®é¢˜ã€‚å¦‚æžœæ˜¯äºŒç»´æ•°ç»„å¯ä»¥åŽ‹ç¼©ä¸ºä¸€ç»´æ•°ç»„ï¼ˆæˆ‘å½“æ—¶ä¹Ÿæ˜¯ä¸æ‡‚è¿™é‡Œï¼‰ã€‚å¦‚æžœæœ€å¤§å­çŸ©é˜µå’ŒåŽŸçŸ©é˜µç­‰é«˜ï¼Œå°±å¯ä»¥è¿™æ ·åŽ‹ç¼©ã€‚ ä¸æ˜¯å¾ˆæ‡‚ï¼Œæ„Ÿè§‰K çš„å€¼åº”è¯¥æ˜¯å…·æœ‰æŸç§é™åˆ¶ï¼Œä½†æ˜¯è¿™ä¸ªä»ç„¶æ˜¯ 0-k è¿™æ ·çš„æ•°å­—ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;#define inf 0x3f3f3f3fint Max(int a, int b)&#123; return a&gt;b? a:b;&#125;// æ±‚è§£ä¸€ç»´æ•°ç»„çš„æœ€å¤§è¿žç»­å­æ•°åˆ—int FindGreatestSubarray(int *arr, int n)&#123; int sum =arr[0]; int max =arr[0]; for(int i =1;i&lt;n;i++)&#123; sum =Max(sum+arr[i], arr[i]) if(sum &gt;=max)&#123; max =sum; &#125; &#125; return max;&#125;int GreatestMatrix(int[][] arr, int rows, int cols)&#123; int maxVal =- inf for(int i =0 ; i &lt;rows; i++)&#123; vector&lt;int&gt; temp(arr[i]); maxVal =Max(maxVal, FindGreatestSubarray(temp)); // å¾—åˆ°ç¬¬ä¸€è¡Œçš„æœ€å¤§å’Œ // å°†è¡Œçš„nä¸ªå…ƒç´ åŠ åˆ°ä¸Šä¸€è¡Œï¼Œç„¶åŽè®¡ç®—æœ€å¤§å’Œ for(int j =i+1; j&lt;rows; j++)&#123; for(int k =0;k&lt;cols ;k++)&#123; temp[k] =arr[j][k]; &#125; // ä¾æ¬¡0~kè¡Œçš„æœ€å¤§å’Œ maxVal =Max(maxVal, FindGreatestSubarray(temp)) &#125; &#125;&#125;int main()&#123;&#125; KMPï¼ˆå­—ç¬¦ä¸²é«˜æ•ˆæŸ¥æ‰¾)è®¡ç®—éƒ¨åˆ†åŒ¹é…è¡¨ å‰ç¼€å’ŒåŽç¼€çš„å®šä¹‰ï¼šâ€å‰ç¼€â€æŒ‡é™¤äº†æœ€åŽä¸€ä¸ªå­—ç¬¦ä»¥å¤–ï¼Œä¸€ä¸ªå­—ç¬¦ä¸²çš„å…¨éƒ¨å¤´éƒ¨ç»„åˆï¼›â€åŽç¼€â€æŒ‡é™¤äº†ç¬¬ä¸€ä¸ªå­—ç¬¦ä»¥å¤–ï¼Œä¸€ä¸ªå­—ç¬¦ä¸²çš„å…¨éƒ¨å°¾éƒ¨ç»„åˆã€‚ å¦‚æžœç»™å®šçš„æ¨¡å¼ä¸²æ˜¯ï¼šâ€œABCDABDâ€ï¼Œä»Žå·¦è‡³å³éåŽ†æ•´ä¸ªæ¨¡å¼ä¸²ï¼Œå…¶å„ä¸ªå­ä¸²çš„å‰ç¼€åŽç¼€åˆ†åˆ«å¦‚ä¸‹è¡¨æ ¼æ‰€ç¤ºï¼š 123456789101112131415161718192021222324def kmp_match(s, p): m, n =len(s) ,len(p) cur =0 table = partial_table(p) while cur &lt;= m-n: for i in range(n): if s[i+cur] != p[i]: cur += max(i -table[i-1], 1) break else: return True return Falsedef partial_table(p): prefix =set() postfix =set() ret =[0] for i in range(1, len(p)): prefix.add(p[:i]) postfix =&#123; p[j:i+1] for j in range(1, i+1)&#125; ret.append(len((prefix &amp; postfix or &#123;''&#125;).pop())) # &amp;ä¸¤ä¸ªsetæ±‚äº¤é›† return retprint(partial_table('ABCDABD'))print(kmp_match("BBC ABCDAB ABCDABCDABDE", "ABCDABD")) kmp ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(m +n)$ å…¶ä¸­ m, n åˆ†åˆ«è¡¨ç¤ºpattern å’Œstring çš„é•¿åº¦ã€‚ 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;const int N =1e4+11;const int M =1e5+11;int n, m;char p[N], s[M];int nex[N];void get_next()&#123; for(int i =2, j =0; i&lt;=n ; i++) &#123; while(j &amp;&amp; p[i] != p[j +1]) j =nex[j]; if(p[i] ==p[j+1]) j ++; nex[i] =j; &#125;&#125;int main()&#123; cin &gt;&gt;n &gt;&gt; p +1&gt;&gt; m&gt;&gt; s +1; get_next(); // i è¡¨ç¤º sçš„éåŽ†ï¼Œ j è¡¨ç¤ºp çš„éåŽ† for(int i =1, j =0; i&lt;=m; i++) &#123; while(j &amp;&amp; s[i] != p[j+1]) j =nex[j]; if(s[i] ==p[j+1]) j ++; if(j ==n) &#123; printf("%d ", i-n); j =nex[j]; &#125; &#125; return 0;&#125; äºŒå‰æ ‘çš„éåŽ†å…³äºŽæ ‘çš„éåŽ†ï¼Œå¯ä»¥æœ‰å…ˆåºï¼Œä¸­åºå’ŒåŽåºéåŽ†æ–¹å¼ã€‚æœ‰é€’å½’å’Œéžé€’å½’ä¸¤ç§æ–¹å¼ã€‚æ‰€ä»¥æ€»å…±æœ‰ 6ç§å®žçŽ°æ–¹å¼ã€‚ åœ¨pythonä¸­äºŒå‰æ ‘çš„ç»“æž„: 12345class BinNode(): def __init__(self, val): self.value =val self.lchild =None self.rchild =None å…ˆåºéåŽ†(preOrder)ç¬¬ä¸€ç§æ€è·¯æ˜¯é€’å½’å®žçŽ°ï¼Œç¬¬äºŒç§æ€è·¯å€ŸåŠ©æ ˆçš„ç»“æž„æ¥å®žçŽ°ã€‚æ ˆçš„å¤§å°ç©ºé—´ä¸ºO(h)ï¼Œhä¸ºäºŒå‰æ ‘é«˜åº¦ï¼›æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ï¼Œnæ˜¯æ ‘çš„èŠ‚ç‚¹çš„ä¸ªæ•°ã€‚ é€’å½’çš„å†™æ³•ä¾¿äºŽç†è§£ï¼Œå¾ªçŽ¯çš„æ–¹å¼å†…å­˜æ¯”è¾ƒçœã€‚ å¾ªçŽ¯çš„ç‰ˆæœ¬ä»Žå˜é‡å‘½åå’Œç»“æž„ä¸Šéƒ½æ˜¯å¯ä»¥ä¼˜åŒ–çš„ã€‚ 123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def preorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ res, stack =[], [root] while stack: cur_node =stack.pop() # default pop(-1) è¿™ä¸ªæ—¶é—´å¤æ‚åº¦æ˜¯ O(1)ï¼Œå¦‚æžœæ˜¯pop(0) é‚£ä¹ˆæ—¶é—´å¤æ‚åº¦æ˜¯ O(n) if cur_node: res.append(cur_node.val) stack.append(cur_node.right) # æ³¨æ„è¿™ä¸ªé¡ºåºï¼Œè¿™ä¸ªæ˜¯æ­£ç¡®çš„å§¿æ€ stack.append(cur_node.left) return res c++ é€’å½’ç‰ˆæœ¬ å¯¹äºŽé€’å½’ï¼Œåº”è¯¥å…ˆè€ƒè™‘æ˜¯æ•´ä¸ªé€’å½’çš„è¿‡ç¨‹ä¸»çº¿ï¼Œè€Œä¸æ˜¯è·³å‡ºçš„æ¡ä»¶ï¼ˆè¯¥é—®é¢˜æ¯”è¾ƒç»†ï¼Œç„¶åŽå¾ˆå®¹æ˜“é™·è¿›åŽ»ï¼‰1234567891011121314151617181920/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; res; vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; if(!root) return res; res.push_back(root-&gt; val); if(root -&gt; left) preorderTraversal(root -&gt; left); if(root -&gt; right) preorderTraversal(root -&gt; right); return res; &#125;&#125;; c++éžé€’å½’ç‰ˆæœ¬ï¼Œæ³¨æ„ä½¿ç”¨çš„æ˜¯æ ˆè¿™ç§ç»“æž„ï¼Œå¹¶ä¸”åœ¨push() çš„æ—¶å€™æ˜¯å…ˆpush(root-&gt; right) ç„¶åŽæ˜¯ push(root -&gt; left) è¿™æ ·èƒ½å¤Ÿä¿è¯å…ˆå¼¹å‡ºæ¥ root -&gt;left ç»“ç‚¹ã€‚ 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // å¦‚æžœæ˜¯éžé€’å½’ç‰ˆæœ¬ï¼Œä½¿ç”¨çš„æ˜¯æ ˆ è¿™ç§ç»“æž„ vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(! root) return res; stack&lt;TreeNode *&gt; s; s.push(root); while(s.size()) &#123; auto t =s.top(); s.pop(); res.push_back(t-&gt;val); if(t -&gt;right) s.push(t-&gt;right); if(t-&gt;left) s.push(t-&gt;left); &#125; return res; &#125;&#125;; ä¸­åºéåŽ†ï¼ˆinorderï¼‰é€’å½’å’Œéžé€’å½’ä¸¤ç§å®žçŽ°æ€è·¯ã€‚å…¥æ ˆçš„é¡ºåºæ˜¯ä¸€æ ·çš„ï¼Œåªæ˜¯æ”¹å˜çš„éåŽ†(print())çš„é¡ºåº. ä¸­åºéåŽ†æ˜¯å…ˆæŠŠæ‰€æœ‰çš„å·¦å­æ ‘éåŽ†å®Œä¹‹åŽï¼Œç„¶åŽéåŽ†æ ¹èŠ‚ç‚¹ï¼Œç„¶åŽéåŽ†å³å­æ ‘ã€‚ 12345678910111213141516171819202122# é€’å½’def inOrder(self, root): if root ==None: return self.inOrder(root.lchild) print(root.val) self.inOrder(root.rchild)# å€ŸåŠ©æ ˆç»“æž„class Solution: def inorderTraversal(self, root): res, stack =[], [] while True: while root: stack.append(root) root =root.left if not stack: return res node =stack.pop() res.append(node.val) root =node.right c++ ä¸­åºéåŽ†é€’å½’å†™æ³•ï¼Œ ä¸­åºéåŽ†æ˜¯å…ˆä¸€ç›´éåŽ†åˆ°å­æ ‘çš„æœ€å·¦è¾¹ï¼Œç„¶åŽå›žæº¯éåŽ†æ ¹èŠ‚ç‚¹ï¼Œç„¶åŽéåŽ†å³å­æ ‘ã€‚ 123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // ä½¿ç”¨ä¸­åºéåŽ†ï¼Œdfs vector&lt;int&gt; res; vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; if(! root) return res; if(root -&gt; left) inorderTraversal(root -&gt;left); res.push_back(root -&gt; val); if(root -&gt; right) inorderTraversal(root -&gt;right); return res; &#125;&#125;; c++ iteration ç‰ˆæœ¬ï¼Œä½¿ç”¨ä¸€ä¸ªæ ˆæ¥æ¨¡æ‹Ÿè¿‡ç¨‹ 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; res; vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode *&gt; s; TreeNode* p =root; while(p || s.size()) &#123; // bad case å¦‚æžœæœ€å¼€å§‹çš„æ—¶å€™ï¼Œ æ ¹èŠ‚ç‚¹çš„å·¦å­©å­æ˜¯ç©ºï¼Œé‚£ä¹ˆå°±æ²¡æœ‰æ”¾è¿›åŽ» while(p) &#123; s.push(p); p =p-&gt;left; &#125; auto t =s.top(); s.pop(); res.push_back(t-&gt;val); if(t-&gt; right) p=t-&gt;right; &#125; return res; &#125;&#125;; åŽåºéåŽ†(post order)ä»ç„¶æ˜¯é€’å½’å’Œéžé€’å½’ç‰ˆæœ¬ï¼Œéžé€’å½’ä¸­ä½¿ç”¨ä¸¤ä¸ªstack,ä¸¤ä¸ªstackçš„åŽè¿›å…ˆå‡ºç­‰äºŽä¸€ä¸ªå…ˆè¿›å…ˆå‡ºã€‚ 12345678910111213141516171819202122232425262728293031# é€’å½’def postOrder(self, root): if root == None: return self.postOrder(root.lchild) self.postOrder(root.rchild) print(root.val)# å€ŸåŠ©æ ˆç»“æž„# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def postorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ res, stack =[], [root] while stack: cur_node =stack.pop() if cur_node: res.append(cur_node.val) stack.append(cur_node.left) # æ³¨æ„å’Œå…ˆåºéåŽ†çš„é¡ºåºï¼Œè¿˜æœ‰æœ€åŽçš„ reverse æ“ä½œ stack.append(cur_node.right) return res[::-1] c++ åŽåºéåŽ†123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // é€’å½’å†™æ³• vector&lt;int&gt; res; vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; if(! root) return res; if(root -&gt; left) postorderTraversal(root -&gt; left); if(root -&gt; right) postorderTraversal(root -&gt; right); res.push_back(root -&gt; val); return res; &#125;&#125;; ä¾èµ–äºŽå‰åºéåŽ†è€Œå®žçŽ°çš„åŽåºéåŽ†ï¼Œ cpp è¿­ä»£ç‰ˆæœ¬ã€‚æœ€åŽä½¿ç”¨ reverse å‡½æ•°å®žçŽ°vector çš„åè½¬ã€‚ 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // å¦‚æžœæ˜¯å‰åºå¯ä»¥ä½¿ç”¨ æ ˆæ¨¡æ‹Ÿï¼Œé‚£ä¹ˆåŽåºåŒæ ·æ˜¯å¯ä»¥ä½¿ç”¨æ ˆæ¥æ¨¡æ‹Ÿçš„ vector&lt;int&gt; res; vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; if(!root ) return res; // å› ä¸ºæ˜¯åŽè¿›å…ˆå‡ºï¼Œæ‰€ä»¥å…ˆè¦æŠŠè·Ÿç»“ç‚¹æ”¾åˆ°stack ä¸­ stack&lt;TreeNode *&gt; s; auto p =root; s.push(p); while(s.size()) &#123; auto t =s.top(); s.pop(); res.push_back(t-&gt;val); if(t-&gt; left) s.push(t-&gt;left); if(t-&gt; right) s.push(t-&gt;right); &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;; å±‚åºéåŽ†ä½¿ç”¨åˆ°äº†é˜Ÿåˆ—çš„æ€æƒ³ï¼Œå…ˆè¿›å…ˆå‡ºã€‚å®žé™…ä¸Šï¼Œç”¨çš„æ˜¯Pythonä¸­list.pop(0).æ³¨æ„é»˜è®¤æ˜¯list.pop(-1),ä¹Ÿå°±æ˜¯é»˜è®¤å¼¹å‡ºçš„æ˜¯æœ€åŽä¸€ä¸ªå…ƒç´ ã€‚ å±‚åºéåŽ†ä½¿ç”¨ while å¾ªçŽ¯å°±æ¯”è¾ƒå¥½ç†è§£ 1234567891011121314def levelOrder(self, root): if root ==None: return myQueue =[] node =root myQueue.append(node) while myQueue: # remove and return item at index (default last) node =myQueue.pop(0) print(node.val) if node.lchild != None: myQueue.append(node.lchild) if node.rchild != None: myQueue.append(node.rchild) c++å®žçŽ°çš„åˆ†å±‚å±‚æ¬¡éåŽ† Binary Tree Level Order Traversal 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // å±‚åºéåŽ†ï¼Œä½¿ç”¨ nullptr æ¥æ ‡å¿—ä¸€å±‚çš„ç»“æŸ vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; queue&lt;TreeNode *&gt; q; q.push(root); q.push(nullptr); while(q.front()) &#123; auto t =q.front(); q.pop(); vector&lt;int&gt; level; // æœ‰äº† while é‚£ä¹ˆå¿…ç„¶æ˜¯ä¸€ä¸ªå¾ªçŽ¯ï¼Œå¦åˆ™çš„è¯ï¼Œä½¿ç”¨if å°±æ˜¯okçš„äº† while(t) &#123; // è¿™ä¸ªå¤„ç†çš„æ˜¯ä¸€ä¸ªç»“ç‚¹çš„, å¦‚æžœæƒ³è¦å¤„ç†ä¸€è¡Œçš„ï¼Œé‚£ä¹ˆç¡®å®žéœ€è¦ä½¿ç”¨å¾ªçŽ¯çš„è¿™æ ·çš„æ–¹å¼ level.push_back(t-&gt;val); if(t-&gt;left) q.push(t-&gt;left); if(t -&gt;right) q.push(t-&gt;right); t =q.front(), q.pop(); &#125; q.push(nullptr); res.push_back(level); &#125; return res; &#125;&#125;; ä»Žä¸‹å¾€ä¸Šå±‚åºæ‰“å°äºŒå‰æ ‘ Binary Tree Level Order Traversal II 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // å’Œä¸Šä¸€é“é¢˜ç›®ç±»ä¼¼ï¼Œå°±æ˜¯åœ¨æœ€åŽçš„æ—¶å€™ï¼Œä½¿ç”¨äºŒç»´æ•°ç»„çš„ reverseï¼Œç„¶åŽå¾—åˆ°æœ€åŽçš„ç»“æžœ vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; queue&lt;TreeNode *&gt; q; q.push(root); q.push(nullptr); while(q.front()) &#123; auto t =q.front(); q.pop(); vector&lt;int&gt; level; while(t) &#123; level.push_back(t-&gt;val); if(t-&gt;left) q.push(t-&gt;left); if(t-&gt;right) q.push( t-&gt;right); t =q.front(), q.pop(); &#125; q.push(nullptr); res.push_back(level); &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;; (Binary Tree Zigzag Level Order Traversal)[https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/submissions/] 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // åŒæ ·çš„æ–¹å¼ï¼Œåªä¸è¿‡åœ¨å¶æ•°çš„æ—¶å€™ reverseä¸€ä¸‹ vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; queue&lt;TreeNode *&gt; q; q.push(root); q.push(nullptr); bool is_even =false; while(q.front()) &#123; auto t =q.front(); q.pop(); vector&lt;int&gt; level; while(t) &#123; level.push_back(t-&gt;val); if(t-&gt;left) q.push(t-&gt;left); if(t-&gt;right) q.push(t-&gt;right); t =q.front(), q.pop(); &#125; if(is_even) reverse(level.begin(), level.end()); is_even = !is_even; q.push(nullptr); res.push_back(level); &#125; return res; &#125;&#125;; æ—‹è½¬æ•°ç»„æ‰¾æœ€å°å€¼æŠŠä¸€ä¸ªæ•°ç»„æœ€å¼€å§‹çš„è‹¥å¹²ä¸ªå…ƒç´ æ¬åˆ°æ•°ç»„çš„æœ«å°¾ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºæ•°ç»„çš„æ—‹è½¬ã€‚ è¾“å…¥ä¸€ä¸ªéžé€’å‡æŽ’åºçš„æ•°ç»„çš„ä¸€ä¸ªæ—‹è½¬ï¼Œè¾“å‡ºæ—‹è½¬æ•°ç»„çš„æœ€å°å…ƒç´ ã€‚ ä¾‹å¦‚æ•°ç»„{3,4,5,1,2}ä¸º{1,2,3,4,5}çš„ä¸€ä¸ªæ—‹è½¬ï¼Œè¯¥æ•°ç»„çš„æœ€å°å€¼ä¸º1ã€‚ NOTEï¼šç»™å‡ºçš„æ‰€æœ‰å…ƒç´ éƒ½å¤§äºŽ0ï¼Œè‹¥æ•°ç»„å¤§å°ä¸º0ï¼Œè¯·è¿”å›ž0ã€‚ ç›´æŽ¥æ˜¯äºŒåˆ†çš„æ€è·¯ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ $O(logn)$1234567891011121314151617181920class Solution &#123;public: // è¿™é‡Œè¯´ no duplicatesï¼Œæ‰€ä»¥ä¸ç”¨å¤„ç†ä¸€ä¸ªæ¡ä»¶ // æ¯”è¾ƒ nums[0] å’Œ nums[mid] å…³ç³»ï¼Œ if nums[mid] &gt; nums[0] l = mid +1 int findMin(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n ==1) return nums[0]; if(nums[0] &lt; nums[n-1]) return nums[0]; int l =0, r =n -1; while(l &lt; r) &#123; int mid =l +r &gt;&gt;1; // å¦‚æžœ mid å’Œ0 è¡¨ç¤ºä¸€ä¸ªä½ç½®ï¼Œé‚£ä¹ˆè¯¥è§£ä¹Ÿä¸æ˜¯æœ€å°å€¼ï¼Œè™½ç„¶æ²¡æœ‰é‡å¤çš„å…ƒç´ ï¼Œä½†è¿™ä¸ªç­‰äºŽå·æ˜¯åº”è¯¥åœ¨è¿™é‡Œçš„ if(nums[mid] &gt;= nums[0]) l =mid +1; else r =mid ; &#125; return nums[l]; &#125;&#125;; å•é“¾è¡¨åè½¬c++ ç‰ˆæœ¬ å¾ªçŽ¯æ³• 1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: // å¯¹äºŽé“¾è¡¨æ“ä½œä¿®æ”¹çš„listï¼Œéœ€è¦ä½¿ç”¨åˆ°ä¸‰ä¸ªæŒ‡é’ˆï¼Œ pre, cur, next æ‰€ä»¥ç©ºé—´å¤æ‚åº¦æ˜¯ O(1), ç©ºé—´å¤æ‚åº¦æ˜¯ $O(n)$ ListNode* reverseList(ListNode* head) &#123; ListNode * pre =nullptr; ListNode * cur = head; while(cur) &#123; ListNode * next =cur -&gt;next; cur -&gt;next = pre; pre =cur, cur = next; &#125; return pre; &#125;&#125;; python ç‰ˆæœ¬ ï¼Œè¿­ä»£ç‰ˆæœ¬ 1234567891011121314151617181920# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ pre =None cur =head while cur: nex =cur.next cur.next = pre pre =cur cur =nex return pre è¿˜å¯ä»¥ä½¿ç”¨é€’å½’çš„æ€è·¯è¿›è¡Œæ±‚è§£ï¼Œå…·ä½“å‚è€ƒè¿™é‡Œï¼Œ éåŽ†æ‰€æœ‰çš„ç»“ç‚¹ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ $O(n)$ï¼Œ éœ€è¦ $n$ ä¸ªæ ˆç©ºé—´ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯$O(n)$ã€‚ Minimum Window Substring Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). 12Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;Output: &quot;BANC&quot; c++ ç‰ˆæœ¬ 123456789101112131415161718192021222324252627class Solution &#123;public: // é¦–å…ˆå¯¹äºŽ t è¿›è¡Œ hashï¼Œ ç„¶åŽå†s ä¸­ä½¿ç”¨åŒæŒ‡é’ˆ i j ï¼Œ i &gt;=j ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ $O(n)$ // ç©ºé—´æ˜¯ $O(n)$ string minWindow(string s, string t) &#123; unordered_map&lt;char, int&gt; hash; int cnt =0; // unique character for(auto ch : t) &#123; if(!hash[ch]) cnt ++; hash[ch] ++; &#125; string res =""; for(int i=0, j =0, c =0; i&lt; s.size(); i ++) &#123; // å¾€é‡Œé¢åŠ  if(hash[s[i]] == 1) c ++; hash[s[i]] --; while(c ==cnt &amp;&amp; hash[s[j]] &lt;0) hash[s[j++]] ++; if(c ==cnt) &#123; if(res.empty() || res.size() &gt; i-j +1) res =s.substr(j, i -j +1); &#125; &#125; return res; &#125;&#125;; python å®žçŽ°ï¼Œä¹Ÿæ˜¯åŒæŒ‡é’ˆ + dictionaryï¼Œ å’Œä¸Šé¢çš„c++ ä»£ç ä¸­æœ‰çš„å˜é‡åè¡¨ç¤ºçš„å«ä¹‰ä¸åŒã€‚ 123456789101112131415161718192021222324252627class Solution(object): def minWindow(self, s, t): """ :type s: str :type t: str :rtype: str """ from collections import Counter dic , cnt =Counter(t), len(t) i , start, end =0, 0, 0 # muberate(string, start_index) ä»Ž1 å¼€å§‹è®¡æ•° for j, ch in enumerate(s, 1): cnt -= dic[ch] &gt;0 dic[ch] -=1 if not cnt: while dic[s[i]] &lt;0: dic[s[i]] += 1 i +=1 if end ==0 or j -i &lt; end -start: start, end =i, j dic[s[i]] +=1 i +=1 cnt +=1 return s[start: end]]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ROCå’Œ unbalanced data]]></title>
    <url>%2F2018%2F06%2F13%2Froc_and_unbalanced_data%2F</url>
    <content type="text"><![CDATA[ä»‹ç»æœºå™¨å­¦ä¹ ä¸­åˆ†ç±»æ¨¡åž‹å¸¸ç”¨çš„è¯„ä»·æŒ‡æ ‡ï¼Œaccï¼Œaucï¼ŒF1 å’Œå¦‚ä½•åŽ»å¤„ç†ä¸å¹³è¡¡æ•°æ®ã€‚ ROCæ›²çº¿å’ŒAUCå€¼ROCå…¨ç§°æ˜¯â€œå—è¯•è€…å·¥ä½œç‰¹å¾â€ï¼ˆReceiver Operating Characteristicï¼‰ã€‚ROCæ›²çº¿çš„é¢ç§¯å°±æ˜¯AUCï¼ˆArea Under the Curveï¼‰ã€‚AUCç”¨äºŽè¡¡é‡â€œäºŒåˆ†ç±»é—®é¢˜â€æœºå™¨å­¦ä¹ ç®—æ³•æ€§èƒ½ï¼ˆæ³›åŒ–èƒ½åŠ›ï¼‰ã€‚è¯´åˆ°è¿™é‡Œä¸å¾—ä¸æåŠå°±æ˜¯ç»å¸¸ä½¿ç”¨çš„ç¬¦å·ï¼ŒTP(True Positive), FP(False, Positive), TN(True Negative),FN(False Negative)ã€‚ä»–ä»¬æ˜¯æ ¹æ®åŽŸæ¥çœŸå®žæ•°æ®å’Œé¢„æµ‹ç±»åˆ«è¿›è¡Œçš„æŽ’åˆ—ç»„åˆï¼ˆå½“ç„¶è¿™æ˜¯é’ˆå¯¹äºŒåˆ†é—®é¢˜ï¼‰ã€‚ ROC æ›²çº¿: ROC æ›²çº¿ï¼ˆæŽ¥æ”¶è€…æ“ä½œç‰¹å¾æ›²çº¿ï¼‰æ˜¯ä¸€ç§æ˜¾ç¤ºåˆ†ç±»æ¨¡åž‹åœ¨æ‰€æœ‰åˆ†ç±»é˜ˆå€¼ä¸‹çš„æ•ˆæžœçš„å›¾è¡¨ã€‚è¯¥æ›²çº¿ç»˜åˆ¶äº†ä»¥ä¸‹ä¸¤ä¸ªå‚æ•°ï¼šçœŸæ­£ä¾‹çŽ‡ å’Œ å‡æ­£ä¾‹çŽ‡ã€‚ çœŸæ­£ä¾‹çŽ‡ (TPR) æ˜¯å¬å›žçŽ‡çš„åŒä¹‰è¯ï¼Œå› æ­¤å®šä¹‰å¦‚ä¸‹ï¼š$$T P R = \frac { T P } { T P + F N }$$å‡æ­£ä¾‹çŽ‡ (FPR) çš„å®šä¹‰å¦‚ä¸‹ï¼š$$F P R = \frac { F P } { F P + T N }$$ ROC ä¸­ TPR =(True positive / ( True positive +False negative)), é‚£ä¸ªfalse negative ä¹Ÿæ˜¯çœŸå®žçš„ç±»åˆ«ï¼Œåªä¸è¿‡æ˜¯é”™è¯¯çš„å½“åšäº† negativeï¼ˆfalse negativeï¼‰ ç¬¬ä¸€ç±»é”™è¯¯å’Œç¬¬äºŒç±»æŽªæ–½æ˜¯å‡è®¾æ£€éªŒä¸­çš„æ¦‚å¿µã€‚ç¬¬ä¸€ç±»é”™è¯¯æ˜¯åŽŸæ¥å‡è®¾æ˜¯é”™è¯¯çš„ï¼Œä½†æ˜¯å´è¢«è®¤ä¸ºæ˜¯æ­£ç¡®çš„ï¼›ç¬¬äºŒç±»é”™è¯¯æ˜¯åŽŸæ¥çš„å‡è®¾æ˜¯æ­£ç¡®çš„ï¼Œä½†æ˜¯è¢«è®¤ä¸ºæ˜¯é”™è¯¯çš„ã€‚ é’ˆå¯¹ä¸€ä¸ªäºŒåˆ†ç±»é—®é¢˜ï¼Œå°†å®žä¾‹åˆ†æˆæ­£ç±»(postive)æˆ–è€…è´Ÿç±»(negative)ã€‚ä½†æ˜¯å®žé™…ä¸­åˆ†ç±»æ—¶ï¼Œä¼šå‡ºçŽ°å››ç§æƒ…å†µ. è‹¥ä¸€ä¸ªå®žä¾‹æ˜¯æ­£ç±»å¹¶ä¸”è¢«é¢„æµ‹ä¸ºæ­£ç±»ï¼Œå³ä¸ºçœŸæ­£ç±»(True Postive TP) è‹¥ä¸€ä¸ªå®žä¾‹æ˜¯æ­£ç±»ï¼Œä½†æ˜¯è¢«é¢„æµ‹æˆä¸ºè´Ÿç±»ï¼Œå³ä¸ºå‡è´Ÿç±»(False Negative FN) è‹¥ä¸€ä¸ªå®žä¾‹æ˜¯è´Ÿç±»ï¼Œä½†æ˜¯è¢«é¢„æµ‹æˆä¸ºæ­£ç±»ï¼Œå³ä¸ºå‡æ­£ç±»(False Postive FP) è‹¥ä¸€ä¸ªå®žä¾‹æ˜¯è´Ÿç±»ï¼Œä½†æ˜¯è¢«é¢„æµ‹æˆä¸ºè´Ÿç±»ï¼Œå³ä¸ºçœŸè´Ÿç±»(True Negative TN) ROC æ›²çº¿æ˜¯å¦‚ä½•ç»˜åˆ¶çš„: é‡‡ç”¨ä¸åŒåˆ†ç±»é˜ˆå€¼æ—¶çš„ TPR ä¸Ž FPRã€‚é™ä½Žåˆ†ç±»é˜ˆå€¼ä¼šå¯¼è‡´å°†æ›´å¤šæ ·æœ¬å½’ä¸ºæ­£ç±»åˆ«ï¼Œä»Žè€Œå¢žåŠ å‡æ­£ä¾‹ï¼ˆFPï¼‰å’ŒçœŸæ­£ä¾‹ï¼ˆTPï¼‰çš„ä¸ªæ•°ï¼Œå¯ä»¥ç†è§£ä¸ºé™ä½Žäº†è¢«è®¤ä¸ºæ­£ç¡®çš„æ ‡å‡†ï¼Œæ•°é‡è‡ªç„¶å°±å¢žå¤šäº†ã€‚ä¸‹å›¾æ˜¾ç¤ºäº†ä¸€ä¸ªå…¸åž‹çš„ ROC æ›²çº¿ã€‚æ³¨æ„è§‚å¯Ÿå›¾ä¸­TPR å’Œ FPRæ˜¯å‘ˆæ­£ç›¸å…³çš„ï¼ŒéªŒè¯äº†ä¸Šè¿°çš„ç»“è®ºã€‚ä¸ºäº†è®¡ç®— ROC æ›²çº¿ä¸Šçš„ç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸åŒçš„åˆ†ç±»é˜ˆå€¼å¤šæ¬¡è¯„ä¼°é€»è¾‘å›žå½’æ¨¡åž‹ï¼Œä½†è¿™æ ·åšæ•ˆçŽ‡éžå¸¸ä½Žã€‚å¹¸è¿çš„æ˜¯ï¼Œæœ‰ä¸€ç§åŸºäºŽæŽ’åºçš„é«˜æ•ˆç®—æ³•å¯ä»¥ä¸ºæˆ‘ä»¬æä¾›æ­¤ç±»ä¿¡æ¯ï¼Œè¿™ç§ç®—æ³•ç§°ä¸ºæ›²çº¿ä¸‹é¢ç§¯ã€‚ ROCæ›²çº¿ï¼Œä¸€èˆ¬é€‚ç”¨äºŽä½ çš„åˆ†ç±»å™¨è¾“å‡ºä¸€ä¸ªâ€œæ¦‚çŽ‡å€¼â€ï¼Œå³è¿™ä¸ªæ ·æœ¬å±žäºŽæŸä¸ªç±»çš„æ¦‚çŽ‡æ˜¯å¤šå°‘ã€‚ å¦‚æ­¤çš„è¯ï¼Œä½ å°±éœ€è¦è®¾å®šä¸€ä¸ªé˜ˆå€¼ï¼Œ å¤§äºŽè¿™ä¸ªé˜ˆå€¼å±žäºŽæ­£ç±»ï¼Œå°äºŽè¿™ä¸ªé˜ˆå€¼å±žäºŽè´Ÿç±»ã€‚ ä»Žè€Œï¼Œå¯¹äºŽè¿™ä¸ªé˜ˆå€¼P0ï¼Œ å°±ä¼šå¾—åˆ°å¯¹åº”çš„TPR, FPR, ä¹Ÿå°±æ˜¯ROCæ›²çº¿ä¸Šçš„ä¸€ä¸ªç‚¹ï¼Œä½ è®¾ç½®ä¸åŒçš„é˜ˆå€¼ï¼Œå°±ä¼šå¾—åˆ°ä¸åŒçš„TPR, FPRï¼Œ ä»Žè€Œæž„æˆROCæ›²çº¿ã€‚ é€šå¸¸æ¥è¯´ é˜ˆå€¼é™ä½Žï¼Œå³è¿›å…¥æ­£ç±»çš„é—¨æ§›å˜ä½Žï¼Œ TPRä¼šå˜å¤§ï¼Œä½†æ˜¯FPRä¹Ÿä¼šå˜å¤§ï¼Œ çœ‹ä»–ä»¬è°å˜çš„å¿«ã€‚ 1234567891011121314gbc = GradientBoostingClassifier()gbc.fit(x_train, y_train)resu = gbc.predict(x_test) #è¿›è¡Œé¢„æµ‹y_pred_gbc = gbc.predict_proba(x_test)[:,1] ###è¿™çŽ©æ„å°±æ˜¯é¢„æµ‹æ¦‚çŽ‡çš„fpr, tpr, threshold = roc_curve(y_test, y_pred_gbc) ###ç”»å›¾çš„æ—¶å€™è¦ç”¨é¢„æµ‹çš„æ¦‚çŽ‡ï¼Œè€Œä¸æ˜¯ä½ çš„é¢„æµ‹çš„å€¼plt.plot(fpr, tpr, 'b', label='AUC = %0.2f' % rocauc)#ç”ŸæˆROCæ›²çº¿plt.legend(loc='lower right')plt.plot([0, 1], [0, 1], 'r--')plt.xlim([0, 1])plt.ylim([0, 1])plt.ylabel('çœŸæ­£çŽ‡')plt.xlabel('å‡æ­£çŽ‡')plt.show() æœ€ç†æƒ³çš„ç›®æ ‡ï¼štpr =1ï¼Œ fpr =0ï¼Œå³å›¾ä¸­çš„ (0, 1) ç‚¹ï¼Œ æ•… ROC æ›²çº¿è¶Šé è¿‘(0, 1 ) ç‚¹ï¼Œåˆ†ç±»æ•ˆæžœè¶Šå¥½ã€‚ æŽ¥ç€æˆ‘ä»¬è®¡ç®—TRP(True Positive Radio)ï¼ŒFRP(False Positive Ratio)ç”¨äºŽæè¿°ROCæ›²çº¿ï¼Œåˆ†åˆ«è¡¨ç¤ºè¯¥æ›²çº¿çš„Yè½´ï¼ŒXè½´ã€‚TPR=TP/(TP+FN)FPR=FP/(FP+TN)æœ€åŽå°±å½¢æˆäº†ç±»ä¼¼è¿™æ ·çš„å›¾åƒ(æ¥æºäºŽä¸Šè¿°çš„è®­ç»ƒæ¨¡åž‹) æˆ‘ä»¬å¸Œæœ›çš„ç»“æžœæ˜¯TRUè¶Šå¤§ï¼ˆæŽ¥è¿‘1ï¼‰ï¼ŒFRUè¶Šå°ï¼ˆæŽ¥è¿‘0ï¼‰ã€‚AUCçš„å€¼æ˜¯ROCæ‰€è¦†ç›–çš„é¢ç§¯ï¼Œå½“AUCè¶Šå¤§æ—¶å€™ï¼Œåˆ†ç±»å™¨çš„æ•ˆæžœè¶Šå¥½ã€‚ä»Žå›¾ä¸­å¯ä»¥çœ‹å‡ºæ¨¡åž‹(ensemble)çš„é¢ç§¯æ˜¯æœ€å¤§çš„ï¼Œåˆ†ç±»æ•ˆæžœä¹Ÿæ˜¯æœ€å¥½çš„ã€‚å…³äºŽè¯¥å›¾åƒè¿˜æœ‰ä¸€ç‚¹ï¼Œå¦‚æžœä½ çš„æ›²çº¿æ‹Ÿåˆå¯¹è§’çº¿ï¼ˆå›¾ä¸­è™šçº¿ï¼‰ï¼Œé‚£ä¹ˆç›¸å½“äºŽéšæœºçŒœæµ‹ã€‚ ROC(receiver operating characteristic curve): ROCæ›²çº¿çš„æ¨ªåæ ‡ä¸ºfalse positive rateï¼ˆFPR,å‡æ­£çŽ‡ï¼‰ï¼Œçºµåæ ‡ä¸ºtrue positive rateï¼ˆTPRï¼ŒçœŸæ­£çŽ‡ï¼Œå¬å›žçŽ‡ï¼‰PRC(precision recall curve): PRCæ›²çº¿çš„æ¨ªåæ ‡ä¸ºå¬å›žçŽ‡Recallï¼Œçºµåæ ‡ä¸ºå‡†ç¡®çŽ‡Precisionã€‚ ç”¨ROC curveæ¥è¡¨ç¤ºåˆ†ç±»å™¨çš„performanceå¾ˆç›´è§‚å¥½ç”¨ã€‚å¯æ˜¯ï¼Œäººä»¬æ€»æ˜¯å¸Œæœ›èƒ½æœ‰ä¸€ä¸ªæ•°å€¼æ¥æ ‡å¿—åˆ†ç±»å™¨çš„å¥½åã€‚é€šå¸¸ï¼ŒAUCçš„å€¼ä»‹äºŽ0.5åˆ°1.0ä¹‹é—´ï¼Œè¾ƒå¤§çš„AUCä»£è¡¨äº†è¾ƒå¥½çš„Performanceã€‚ä¸€èˆ¬æ¥è¯´ï¼Œå¦‚æžœROCæ˜¯å…‰æ»‘çš„ï¼Œé‚£ä¹ˆåŸºæœ¬å¯ä»¥åˆ¤æ–­æ²¡æœ‰å¤ªå¤§çš„overfittingï¼ˆæ¯”å¦‚å›¾ä¸­0.2åˆ°0.4å¯èƒ½å°±æœ‰é—®é¢˜ï¼Œä½†æ˜¯æ ·æœ¬å¤ªå°‘äº†ï¼‰ï¼Œè¿™ä¸ªæ—¶å€™è°ƒæ¨¡åž‹å¯ä»¥åªçœ‹AUCï¼Œé¢ç§¯è¶Šå¤§ä¸€èˆ¬è®¤ä¸ºæ¨¡åž‹è¶Šå¥½ã€‚ precision-recall çš„æ–¹å¼ä¸€èˆ¬æƒ…å†µï¼Œç”¨ä¸åŒçš„é˜€å€¼ï¼Œç»Ÿè®¡å‡ºä¸€ç»„ä¸åŒé˜€å€¼ä¸‹çš„ç²¾ç¡®çŽ‡å’Œå¬å›žçŽ‡ï¼Œè¿™å°±æ˜¯PRCæ›²çº¿ã€‚å¦‚ä¸‹å›¾ï¼š å¦‚æžœæ˜¯åšæœç´¢ï¼Œé‚£å°±æ˜¯ä¿è¯å¬å›žçš„æƒ…å†µä¸‹æå‡å‡†ç¡®çŽ‡ï¼›å¦‚æžœåšç–¾ç—…ç›‘æµ‹ã€ååžƒåœ¾ï¼Œåˆ™æ˜¯ä¿å‡†ç¡®çŽ‡çš„æ¡ä»¶ä¸‹ï¼Œæå‡å¬å›žã€‚ï¼ˆä»Žå›¾ä¸­ä¸Šå¯ä»¥çœ‹å‡ºï¼Œä¸€èˆ¬æ¥è¯´ï¼Œå¬å›žçŽ‡çš„æå‡ä¸ä¼šå¯¼è‡´å‡†ç¡®çŽ‡çš„ä¸Šå‡ï¼Œä¹Ÿå°±æ˜¯è¯´ å‡†ç¡®çŽ‡å¯èƒ½ä¸å˜ï¼Œå¯èƒ½ä¸‹é™ï¼‰ ä¸¤è€…çš„åŒºåˆ«ï¼šåœ¨æ­£è´Ÿæ ·æœ¬åˆ†å¸ƒå¾—æžä¸å‡åŒ€(highly skewed datasets)çš„æƒ…å†µä¸‹ï¼ŒPRCæ¯”ROCèƒ½æ›´æœ‰æ•ˆåœ°ååº”åˆ†ç±»å™¨çš„å¥½åã€‚ Recallï¼šæŸ¥å…¨çŽ‡ï¼Œæ­£æ ·æœ¬ä¸­è¢«é¢„æµ‹å‡ºæ¥æ˜¯æ­£çš„æ¯”ä¾‹(è¶Šå¤§è¶Šå¥½)Precisionï¼šæŸ¥å‡†çŽ‡ï¼Œé¢„æµ‹çš„æ­£æ ·æœ¬ä¸­è¢«æ­£ç¡®é¢„æµ‹çš„æ¯”ä¾‹(è¶Šå¤§è¶Šå¥½)True Positive Rateï¼šè·Ÿ Recall å®šä¹‰ä¸€æ · ï¼ˆè¶Šå¤§è¶Šå¥½)FPR : è´Ÿæ ·æœ¬ä¸­è¢«é¢„æµ‹ä¸ºæ­£çš„æ¯”ä¾‹(è¶Šå°è¶Šå¥½) å¯¹äºŽä¸€ä¸ªäºŒåˆ†ç±»é—®é¢˜ï¼Œå¾€å¾€è¦è®¾å®šä¸€ä¸ª thresholdï¼Œå½“é¢„æµ‹å€¼å¤§äºŽè¿™ä¸ª threshold æ—¶é¢„æµ‹ä¸ºæ­£æ ·æœ¬ï¼Œå°äºŽè¿™ä¸ª threshold æ—¶é¢„æµ‹ä¸ºè´Ÿæ ·æœ¬ã€‚å¦‚æžœä»¥ Recall ä¸ºæ¨ªè½´ï¼ŒPrecision ä¸ºçºµè½´ï¼Œé‚£ä¹ˆè®¾å®šä¸€ä¸ª threshold æ—¶ï¼Œä¾¿å¯åœ¨åæ ‡è½´ä¸Šç”»å‡ºä¸€ä¸ªç‚¹ï¼Œè®¾å®šå¤šä¸ª threshold åˆ™å¯ä»¥ç”»å‡ºä¸€æ¡æ›²çº¿ï¼Œè¿™æ¡æ›²çº¿ä¾¿æ˜¯ PR æ›²çº¿ã€‚ PR æ›²çº¿æ˜¯ä»¥ Recall ä¸ºæ¨ªè½´ï¼ŒPrecision ä¸ºçºµè½´ï¼›è€Œ ROCæ›²çº¿åˆ™æ˜¯ä»¥ FPR ä¸ºæ¨ªè½´ï¼ŒTPR ä¸ºçºµè½´ã€‚ å®šç†1ï¼šå¯¹äºŽä¸€ä¸ªç»™å®šçš„çš„æ•°æ®é›†ï¼ŒROCç©ºé—´å’ŒPRç©ºé—´å­˜åœ¨ä¸€ä¸€å¯¹åº”çš„å…³ç³»ï¼Œå› ä¸ºäºŒè€…åŒ…å«å®Œå…¨ä¸€è‡´çš„æ··æ·†çŸ©é˜µã€‚æˆ‘ä»¬å¯ä»¥å°†ROCæ›²çº¿è½¬åŒ–ä¸ºPRæ›²çº¿ï¼Œåä¹‹äº¦ç„¶ã€‚ å®šç† 2 ä¸­ â€œæ›²çº¿Aä¼˜äºŽæ›²çº¿Bâ€ æ˜¯æŒ‡æ›²çº¿ B çš„æ‰€æœ‰éƒ¨åˆ†ä¸Žæ›²çº¿ A é‡åˆæˆ–åœ¨æ›²çº¿ A ä¹‹ä¸‹ã€‚è€Œåœ¨ROCç©ºé—´ï¼ŒROCæ›²çº¿è¶Šå‡¸å‘å·¦ä¸Šæ–¹å‘æ•ˆæžœè¶Šå¥½ã€‚ä¸ŽROCæ›²çº¿å·¦ä¸Šå‡¸ä¸åŒçš„æ˜¯ï¼ŒPRæ›²çº¿æ˜¯å³ä¸Šå‡¸æ•ˆæžœè¶Šå¥½ã€‚ F1å¯¹äºŽPRCå°±å¥½è±¡AUCå¯¹äºŽROCä¸€æ ·ã€‚ä¸€ä¸ªæ•°å­—æ¯”ä¸€æ¡çº¿æ›´æ–¹ä¾¿è°ƒæ¨¡åž‹ã€‚ é˜ˆå€¼è®¾å®šçš„ä¸¤ç§æ–¹æ³•ï¼š ç­‰è·ç¦»é˜ˆå€¼ï¼Œrange(0, 1, 100) ç”Ÿæˆäº†100 ä¸ªé˜ˆå€¼ï¼Œé‚£ä¹ˆå¯¹åº”ç€p-r ä¸­çš„100 ä¸ªç‚¹ äºŒåˆ†ç±»ç»“æžœæ˜¯æ¨¡åž‹çš„æ¦‚çŽ‡å€¼ï¼Œå¯¹æ¦‚çŽ‡å€¼è¿›è¡ŒæŽ’åºï¼Œä¾æ¬¡ä½¿ç”¨è¿™äº›æ¦‚çŽ‡å€¼ä½œä¸ºé˜ˆå€¼ï¼Œä¹Ÿæ˜¯å¯ä»¥å¾—åˆ°ä¸åŒçš„ç‚¹çš„åæ ‡ã€‚ å¦‚ç²¾å‡†è¥é”€é¢†åŸŸçš„å•†å“æŽ¨èæ¨¡åž‹ï¼Œæ¨¡åž‹ç›®çš„æ˜¯å°½é‡å°†å•†å“æŽ¨èç»™æ„Ÿå…´è¶£çš„ç”¨æˆ·ï¼Œè‹¥ç”¨æˆ·å¯¹æŽ¨èçš„å•†å“ä¸æ„Ÿå…´è¶£ï¼Œä¹Ÿä¸ä¼šæœ‰å¾ˆå¤§æŸå¤±ï¼Œå› æ­¤æ­¤æ—¶TPRç›¸å¯¹FPRæ›´é‡è¦ã€‚å†æ¯”å¦‚åæ¬ºè¯ˆé¢†åŸŸçš„æ¬ºè¯ˆé¢„æµ‹æ¨¡åž‹ï¼Œç”±äºŽæ¨¡åž‹ç»“æžœä¼šå¯¹è¯†åˆ«çš„åäººè¿›è¡Œä¸€å®šçš„å¤„ç½®æŽªæ–½ï¼ŒFPRè¿‡é«˜ä¼šå¯¹å¥½äººæœ‰ä¸€å®šå¹²æ‰°ï¼Œé€ æˆè¯¯æ€ï¼Œå½±å“å®¢æˆ·ä½“éªŒï¼Œå› æ­¤æ¨¡åž‹éœ€ä¿è¯åœ¨ä½ŽäºŽä¸€å®šFPRçš„åŸºç¡€ä¸Šå°½é‡å¢žåŠ TPRã€‚ å¦‚æžœåœ¨æˆ‘ä»¬æ‰€è¯´çš„fraud detection æˆ–è€…ç™Œç—‡æ£€æµ‹è¿™ä¸€ç±»åº”ç”¨ä¸­ï¼Œæˆ‘ä»¬çš„å€¾å‘è‚¯å®šæ˜¯â€œå®å¯é”™æ€ä¸€åƒï¼Œä¸å¯æ”¾è¿‡ä¸€ä¸ªâ€å‘€ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è®¾å®šåœ¨åˆç†çš„precisionä¸‹ï¼Œæœ€é«˜çš„recallä½œä¸ºæœ€ä¼˜ç‚¹ï¼Œæ‰¾åˆ°è¿™ä¸ªå¯¹åº”çš„thresholdç‚¹ã€‚ å¬å›žçŽ‡åº”ç”¨åœºæ™¯å¬å›žçŽ‡çš„åº”ç”¨åœºæ™¯ï¼šæ¯”å¦‚æ‹¿ç½‘è´·è¿çº¦çŽ‡ä¸ºä¾‹ï¼Œç›¸å¯¹å¥½ç”¨æˆ·ï¼Œæˆ‘ä»¬æ›´å…³å¿ƒåç”¨æˆ·ï¼Œä¸èƒ½é”™æ”¾è¿‡ä»»ä½•ä¸€ä¸ªåç”¨æˆ·ã€‚å› ä¸ºå¦‚æžœæˆ‘ä»¬è¿‡å¤šçš„å°†åç”¨æˆ·å½“æˆå¥½ç”¨æˆ·ï¼Œè¿™æ ·åŽç»­å¯èƒ½å‘ç”Ÿçš„è¿çº¦é‡‘é¢ä¼šè¿œè¶…è¿‡å¥½ç”¨æˆ·å¿è¿˜çš„å€Ÿè´·åˆ©æ¯é‡‘é¢ï¼Œé€ æˆä¸¥é‡å¿å¤±ã€‚å¬å›žçŽ‡è¶Šé«˜ï¼Œä»£è¡¨å®žé™…åç”¨æˆ·è¢«é¢„æµ‹å‡ºæ¥çš„æ¦‚çŽ‡è¶Šé«˜ï¼Œå®ƒçš„å«ä¹‰ç±»ä¼¼ï¼šå®å¯é”™æ€ä¸€åƒï¼Œç»ä¸æ”¾è¿‡ä¸€ä¸ªã€‚ å¯¹äºŽROC æ›²çº¿ï¼Œæˆ‘ä»¬å¸Œæœ›ï¼Œ TPR è¶Šé«˜ï¼ŒåŒæ—¶FPR è¶Šä½Žï¼ˆROC æ›²çº¿å‘ç€å·¦ä¸Šè§’æ‰©å±•ï¼Œè¶Šé™¡è¶Šå¥½ï¼‰ å…ˆçœ‹äºŒåˆ†ç±»é—®é¢˜ã€‚æŒ‡æ ‡çš„å¥½åä¸»è¦å–å†³äºŽåˆ†ç±»å™¨çš„ç›®æ ‡ã€‚æ¯”æ–¹è¯´ï¼Œç”µå­é‚®ä»¶çš„åžƒåœ¾è¿‡æ»¤ï¼Œä½ æ˜¯å¸Œæœ›å®ƒæ›´å…¨é¢ï¼ˆæŸ¥å‡ºæ‰€æœ‰çš„åžƒåœ¾ï¼Œä½†æ˜¯ä¼šæœ‰å¤§é‡æœ‰ç”¨ä¿¡æ¯ä¹Ÿè¢«åˆ¤ä¸ºåžƒåœ¾ï¼‰å‘¢ï¼Œè¿˜æ˜¯å¸Œæœ›å®ƒå°½é‡ç²¾å‡†ï¼ˆä¸è¦è€æ˜¯å°†æœ‰ç”¨çš„é‚®ä»¶åˆ¤ä¸ºåžƒåœ¾ï¼‰å‘¢ï¼Ÿåœ¨è¿™ä¸ªä¾‹å­é‡Œï¼Œæ˜¾ç„¶ï¼Œæˆ‘ä»¬è®¤ä¸ºFalse Positiveçš„ä¼¤å®³è¦å¤§äºŽFalse Negativeï¼šé‡è¦é‚®ä»¶è¦æ˜¯è¢«åˆ¤æˆåžƒåœ¾æ‰€é€ æˆçš„æŸå¤±ï¼Œè¿œå¤§äºŽæ”¶ä»¶ç®±é‡Œè¿˜æœ‰ä¸€éƒ¨åˆ†çš„åžƒåœ¾é‚®ä»¶â€”â€”å‰è€…å¯èƒ½ä¼šè®©ä½ é”™è¿‡é‡è¦çš„å·¥ä½œï¼ŒåŽè€…ä»…ä»…æ˜¯è®©ä½ åœ¨é˜…è¯»çš„æ—¶å€™çš±çš±çœ‰å¤´ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¼šè®¤ä¸ºPrecisionçš„æŒ‡æ ‡ä¼šæ¯”è¾ƒé‡è¦ï¼Œæˆ–è€…ååº”åœ¨ROCå›¾ä¸Šï¼ŒFPRå°½é‡çš„å°â€”â€”è‡ªç„¶ï¼Œåœ¨ä¿è¯FPRçš„åŸºç¡€ä¸Šï¼ŒRecallä¾ç„¶è¿˜æ˜¯é‡è¦çš„â€”â€”æ¯•ç«Ÿç”¨æˆ·è´­ä¹°çš„æ˜¯åžƒåœ¾è¿‡æ»¤ï¼Œå¦‚æžœåªæ˜¯è¿‡æ»¤äº†1æ¡åžƒåœ¾ä½†æ˜¯Precisionï¼100%ï¼Œè¿™æ ·çš„ä¸œè¥¿çœ‹èµ·æ¥ä¹Ÿæ²¡ä»€ä¹ˆç”¨â€”â€”é‚£ä¹ˆç»¼åˆèµ·æ¥ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡ROCçš„AUCæ¥è¿›è¡Œæ¯”è¾ƒï¼Œé¢ç§¯è¾ƒå¤§çš„ä»£è¡¨åŒæ ·çš„FPRä¸‹é¢ï¼Œrecallæ¯”è¾ƒé«˜ã€‚ å…¶æ¬¡æ˜¯æœç´¢é—®é¢˜ã€‚æœç´¢é—®é¢˜å…¶å®žæ˜¯ä¸€ä¸ªæŽ’åºé—®é¢˜ï¼Œä½†æˆ‘ä»¬å¾€å¾€ä¼šå®šä¹‰Precision@Top Kè¿™æ ·çš„æŒ‡æ ‡ï¼Œå³æ­£ç¡®çš„ç­”æ¡ˆæœ‰æ²¡æœ‰è¢«æŽ’åœ¨Top Kä¸­ï¼Œå¦‚æžœæ˜¯çš„è¯ï¼Œå°±ç›¸å½“äºŽåˆ¤æ–­ä¸ºâ€œçœŸâ€ï¼Œåä¹‹åˆ™ä¸ºâ€œå¦â€ã€‚è¿™æ ·æœç´¢é—®é¢˜å°±è½¬åŒ–ä¸ºäº†ä¸€ä¸ªäºŒåˆ†ç±»é—®é¢˜ï¼Œå”¯ä¸€çš„é—®é¢˜æ˜¯ï¼Œè¿™æ˜¯ä¸€ä¸ªå…¸åž‹çš„æ•°æ®ä¸å‡è¡¡çš„caseã€‚å¾ˆæ˜¾ç„¶ï¼Œæ‰€æœ‰çš„å€™é€‰é›†çš„æ•°é‡æ˜¯éžå¸¸å·¨å¤§çš„ï¼Œä½†æ˜¯Kçš„æ•°é‡ä¸ä¼šå¾ˆå¤§ï¼ˆæ¯”å¦‚Top 10, Top 20ï¼‰ã€‚æ‰€ä»¥ï¼Œåœ¨è¿™ä¸ªé—®é¢˜ä¸­ï¼Œæˆ‘ä»¬ä¼šä¸»è¦çœ‹Precision-Recall curveã€‚æ›´é‡è¦çš„æ˜¯ï¼Œä¸€èˆ¬è€Œè¨€ï¼Œäººä»¬çœ‹æœç´¢ç»“æžœéƒ½ä¸ä¼šå¤ªæœ‰è€å¿ƒï¼Œæ‰€ä»¥å¸Œæœ›Top Kä¸­çš„æœ‰ç”¨ä¿¡æ¯å°½é‡å¤šï¼Œæ¢è¨€ä¹‹ï¼ŒPrecision@Top Kçš„æŒ‡æ ‡ï¼Œæ˜¯æœ€æ ¸å¿ƒçš„ã€‚ ç„¶è€Œå¦‚æžœæˆ‘ä»¬çš„é—®é¢˜æ˜¯å¤šåˆ†ç±»çš„é—®é¢˜ï¼Œå®žé™…ä¸Šè¿™äº›æŒ‡æ ‡å°±ä¸é€‚åˆäº†ï¼Œæˆ‘ä»¬éœ€è¦çœ‹çš„æ˜¯Confusion Matri: ç®€å•æ¥è®², å°½å¯èƒ½åœ°æ‰¾åˆ°æ­£æ ·ä¾‹(æœ€å…³å¿ƒçš„ç±»åˆ«)æ—¶,é€‰recall(immediate from recallå®šä¹‰)å°½å¯èƒ½åœ°é¿å…æŠŠéžæ­£æ ·ä¾‹é¢„æµ‹ä¸ºæ­£æ ·ä¾‹æ—¶ï¼Œé€‰precision(immediate from precisionå®šä¹‰) æ‹¿æ¥¼ä¸Šçš„ã€Žåœ°éœ‡é¢„æµ‹ã€ä¸¾ä¾‹å­ã€‚æˆ‘çš„ç†è§£æ˜¯ï¼Œå¯¹æ¨¡åž‹çš„è¦æ±‚æ˜¯ä¸èƒ½æ¼æŠ¥ï¼ˆrecallä¸€å®šè¦é«˜ï¼‰ï¼Œä½†æ˜¯ä¸èƒ½è€æ˜¯è¯¯æŠ¥ï¼ˆFPRä¸èƒ½å¤ªé«˜ï¼‰ã€‚æ··åˆçš„å‡†ç¡®çŽ‡å…¶å®žæ²¡æœ‰å¤ªå¤§çš„æ„ä¹‰ã€‚æ‰€ä»¥ï¼Œæˆ‘ä¼šé€‰æ‹©ROCã€‚ã€ŽçŠ¯ç½ªæ£€æµ‹ã€ä¹Ÿæ˜¯ä¸€æ ·çš„ã€‚è¦æ±‚ä¸€æ ·ï¼Œæ•°æ®åˆ†å¸ƒä¹Ÿç±»ä¼¼ï¼ˆæ­£æ ·æœ¬&lt;&lt;è´Ÿæ ·æœ¬ï¼‰ ROC-AUC å’Œ precision-recall åœ¨å®žçŽ°ä¸Šçš„å·®åˆ« åœ¨å®žçŽ°ä¸Š pyplot æ˜¯ (x, y)ï¼Œ å¦‚ä½•è®°å¿† x å’Œy è½´å¯¹åº”çš„æ˜¯å“ªä¸ªæŒ‡æ ‡å‘¢ï¼Ÿ ï¼ˆä¸€èˆ¬å¯¹äºŽå›¾æ ‡çš„æè¿°æ˜¯å…ˆy åŽxï¼‰æ¯”å¦‚è¯´P-Ræ›²çº¿ï¼Œè¯´æ˜Žprecision æ˜¯y è½´ï¼Œrecall æ˜¯x è½´ã€‚ROC æ›²çº¿æ˜¯TP-FNï¼Œé‚£ä¹ˆtrue positive rate æ˜¯y è½´ï¼Œfalse negative rate æ˜¯x è½´ã€‚æ‰€ä»¥è¿™ä¸¤ä¸ªæ›²çº¿ä¸­çš„ recallï¼ˆtrue positive rate ï¼‰æ˜¯ç›¸åçš„ä½ç½®ã€‚ 123456import numpy as npimport matplotlib.pyplot as pltx = np.arange(0, 5, 0.1)y = np.sin(x)plt.plot(x, y) ROC æ›²çº¿123456fpr, tpr, thresholds = roc_curve(testy, probs)pyplot.plot([0, 1], [0, 1], linestyle='--')pyplot.plot(fpr, tpr, marker='.')pyplot.show()auc_score = roc_auc_score(testy, probs)print('AUC: %.3f' % auc_score) P-Ræ›²çº¿1234pyplot.plot([0, 1], [0.5, 0.5], linestyle='--')pyplot.plot(recall, precision, marker='.')pyplot.show()print('AUC: %.3f' % auc_score) çœ‹å®Œä¸Šé¢çš„ï¼Œè¿™ä¸ªé“¾æŽ¥æ˜¯è¡¥å……ä¿¡æ¯Evaluation Metrics, ROC-Curves and imbalanced datasets PRæ›²çº¿å’Œ ROCæ›²çº¿çš„åŒºåˆ«è¦å¹³è¡¡ç²¾ç¡®çŽ‡å’Œå¬å›žçŽ‡ï¼Œå¯ä»¥è°ƒèŠ‚åŒºåˆ†æ­£è´Ÿç±»åˆ«çš„æ¦‚çŽ‡ä¸´ç•Œå€¼ã€‚ ä¸ºæé«˜ç²¾ç¡®çŽ‡ï¼Œå¯ä»¥æé«˜æ¦‚çŽ‡ä¸´ç•Œå€¼ï¼Œä½¿å¾—æ­£ç±»åˆ«çš„åˆ¤æ–­æ›´åŠ ä¿å®ˆï¼›ä¸ºäº†æé«˜å¬å›žçŽ‡ï¼Œå¯ä»¥é™ä½Žæ¦‚çŽ‡ä¸´ç•Œå€¼ï¼Œä»¥å¢žåŠ æ­£ç±»åˆ«çš„æ•°é‡ åšæœç´¢ï¼šä¿è¯å¬å›žçš„æƒ…å†µä¸‹æå‡å‡†ç¡®çŽ‡ï¼›åšç–¾ç—…ç›‘æµ‹ã€ååžƒåœ¾ï¼šä¿è¯å‡†ç¡®çŽ‡çš„æ¡ä»¶ä¸‹ï¼Œæå‡å¬å›žçŽ‡ å½“æ­£è´Ÿæ ·æœ¬çš„åˆ†å¸ƒå‘ç”Ÿå˜åŒ–æ—¶ï¼ŒROCæ›²çº¿çš„å½¢çŠ¶èƒ½å¤ŸåŸºæœ¬ä¿æŒä¸å˜ï¼Œè€ŒP-Ræ›²çº¿çš„å½¢çŠ¶ä¸€èˆ¬ä¼šå‘ç”Ÿè¾ƒå‰§çƒˆçš„å˜åŒ–ã€‚ROCèƒ½å¤Ÿå°½é‡é™ä½Žä¸åŒæµ‹è¯•é›†å¸¦æ¥çš„å¹²æ‰°ï¼Œæ›´åŠ å®¢è§‚çš„è¡¡é‡æ¨¡åž‹æœ¬èº«çš„æ€§èƒ½ã€‚å¦‚æžœç ”ç©¶è€…å¸Œæœ›æ›´å¤šåœ°çœ‹åˆ°æ¨¡åž‹åœ¨ç‰¹å®šæ•°æ®é›†ä¸Šçš„è¡¨çŽ°ï¼ŒP-Ræ›²çº¿èƒ½å¤Ÿæ›´ç›´è§‚åœ°åæ˜ å…¶æ€§èƒ½ã€‚ TakeOff If you have an imbalanced dataset accuracy can give you false assumptions regarding the classifierâ€™s performance, itâ€™s better to rely on precision and recall, in the same way a Precision-Recall curve is better to calibrate the probability threshold in an imbalanced class scenario as a ROC curve. ROC Curves: summarise the trade-off between the true positive rate and false positive rate for a predictive model using different probability thresholds. Precision-Recall curves: summarise the trade-off between the true positive rate and the positive predictive value for a predictive model using different probability thresholds. ROC curves are appropriate when the observations are balanced between each class, whereas precision-recall curves are appropriate for imbalanced datasets. In both cases the area under the curve (AUC) can be used as a summary of the model performance. Why a ROC curve cannot measure well? The Receiver Operating Characteristic (ROC) curves plot FPR vs. TPR as shown below. Because TPR only depends on positives, ROC curves do not measure the effects of negatives. The area under the ROC curve (AUC) assesses overall classification performance . AUC does not place more emphasis on one class over the other, so it does not reflect the minority class well. Davis and Goadrich in this paper propose that Precision-Recall (PR) curves will be more informative than ROC when dealing with highly skewed datasets. The PR curves plot precision vs. recall (FPR). Because Precision is directly influenced by class imbalance so the Precision-recall curves are better to highlight differences between models for highly imbalanced data sets. When you compare different models with imbalanced settings, the area under the Precision-Recall curve will be more sensitive than the area under the ROC curve. æœ€å¼ºè®²è§£ AUC, precision-recall å’ŒROC çš„æ¯”è¾ƒacc ï¼ˆå‡†ç¡®çŽ‡ï¼‰çš„å±€é™æ€§ä¸»è¦å‘ç”Ÿåœ¨æ­£è´Ÿæ ·æœ¬ä¸å‡è¡¡çš„æ¡ä»¶ä¸‹ã€‚ åœ¨æŽ’åºé—®é¢˜ä¸­ï¼Œé€šå¸¸æ²¡æœ‰ä¸€ä¸ªç¡®å®šçš„é˜ˆå€¼æŠŠå¾—åˆ°çš„ç»“æžœç›´æŽ¥åˆ¤å®šä¸ºæ­£æ ·æœ¬æˆ–è´Ÿæ ·æœ¬ï¼Œè€Œæ˜¯é‡‡ç”¨Top Nè¿”å›žç»“æžœçš„Precisionå€¼å’ŒRecallå€¼æ¥è¡¡é‡æŽ’åºæ¨¡åž‹çš„æ€§èƒ½ï¼Œå³è®¤ä¸ºæ¨¡åž‹è¿”å›žçš„Top Nçš„ç»“æžœå°±æ˜¯æ¨¡åž‹åˆ¤å®šçš„æ­£æ ·æœ¬ï¼Œç„¶åŽè®¡ç®—å‰Nä¸ªä½ç½®ä¸Šçš„å‡†ç¡®çŽ‡Precision@Nå’Œå‰Nä¸ªä½ç½®ä¸Šçš„å¬å›žçŽ‡Recall@Nã€‚Precisionå€¼å’ŒRecallå€¼æ˜¯æ—¢çŸ›ç›¾åˆç»Ÿä¸€çš„ä¸¤ä¸ªæŒ‡æ ‡ï¼Œä¸ºäº†æé«˜Precisionå€¼ï¼Œåˆ†ç±»å™¨éœ€è¦å°½é‡åœ¨â€œæ›´æœ‰æŠŠæ¡â€æ—¶æ‰æŠŠæ ·æœ¬é¢„æµ‹ä¸ºæ­£æ ·æœ¬,ä½†æ­¤æ—¶å¾€å¾€ä¼šå› ä¸ºè¿‡äºŽä¿å®ˆè€Œæ¼æŽ‰å¾ˆå¤šâ€œæ²¡æœ‰æŠŠæ¡â€çš„æ­£æ ·æœ¬ï¼Œå¯¼è‡´Recallå€¼é™ä½Žã€‚ æ¨¡åž‹è¿”å›žçš„Precision@5çš„ç»“æžœéžå¸¸å¥½ï¼Œä¹Ÿå°±æ˜¯è¯´æŽ’åºæ¨¡åž‹Top 5çš„è¿”å›žå€¼çš„è´¨é‡æ˜¯å¾ˆé«˜çš„ã€‚ä½†åœ¨å®žé™…åº”ç”¨è¿‡ç¨‹ä¸­ï¼Œç”¨æˆ·ä¸ºäº†æ‰¾ä¸€äº›å†·é—¨çš„è§†é¢‘,å¾€å¾€ä¼šå¯»æ‰¾æŽ’åœ¨è¾ƒé åŽä½ç½®çš„ç»“æžœï¼Œç”šè‡³ç¿»é¡µåŽ»æŸ¥æ‰¾ç›®æ ‡è§†é¢‘ã€‚ä½†æ ¹æ®é¢˜ç›®æè¿°ï¼Œç”¨æˆ·ç»å¸¸æ‰¾ä¸åˆ°æƒ³è¦çš„è§†é¢‘ï¼Œè¿™è¯´æ˜Žæ¨¡åž‹æ²¡æœ‰æŠŠç›¸å…³çš„è§†é¢‘éƒ½æ‰¾å‡ºæ¥å‘ˆçŽ°ç»™ç”¨æˆ·ã€‚æ˜¾ç„¶ï¼Œé—®é¢˜å‡ºåœ¨å¬å›žçŽ‡ä¸Šã€‚å¦‚æžœç›¸å…³ç»“æžœæœ‰100ä¸ªï¼Œå³ä½¿Precision@5è¾¾åˆ°äº†100%ï¼ŒRecall@5ä¹Ÿä»…ä»…æ˜¯5%ã€‚åœ¨æ¨¡åž‹è¯„ä¼°æ—¶ï¼Œæˆ‘ä»¬æ˜¯å¦åº”è¯¥åŒæ—¶å…³æ³¨Precisionå€¼å’ŒRecallå€¼ã€‚è¿›ä¸€æ­¥è€Œè¨€ï¼Œ åº”è¯¥é€‰å–ä¸åŒçš„Top Nçš„ç»“æžœè¿›è¡Œè§‚å¯Ÿï¼Œåº”è¯¥é€‰å–æ›´é«˜é˜¶çš„è¯„ä¼°æŒ‡æ ‡æ¥æ›´å…¨é¢åœ°åæ˜ æ¨¡åž‹åœ¨Precisionå€¼å’ŒRecallå€¼ä¸¤æ–¹é¢çš„è¡¨çŽ°ã€‚æœ€å¥½ç»˜åˆ¶å‡ºæ¨¡åž‹çš„PRæ›²çº¿ã€‚ F1 å…¶ä¸­åªæ˜¯ä¸€ç§ç‰¹ä¾‹ï¼Œè¿˜æœ‰æ›´åŠ ä¸€èˆ¬çš„å½¢å¼ã€‚æ›´ä¸€èˆ¬çš„ï¼Œæˆ‘ä»¬å®š$F_Î²$åˆ†æ•°ä¸º$$F_{\beta}=\left(1+\beta^{2}\right) \cdot \frac{\text {precision} \cdot \text {recall}}{\left(\beta^{2} \cdot \text {precision}\right)+\text {recall}}$$ $F_Î²$çš„ç‰©ç†æ„ä¹‰å°±æ˜¯å°†å‡†ç¡®çŽ‡å’Œå¬å›žçŽ‡è¿™ä¸¤ä¸ªåˆ†å€¼åˆå¹¶ä¸ºä¸€ä¸ªåˆ†å€¼ï¼Œåœ¨åˆå¹¶çš„è¿‡ç¨‹ä¸­ï¼Œå¬å›žçŽ‡çš„æƒé‡æ˜¯å‡†ç¡®çŽ‡çš„ $Î² $å€ã€‚F1åˆ†æ•°è®¤ä¸ºå¬å›žçŽ‡å’Œå‡†ç¡®çŽ‡åŒç­‰é‡è¦ï¼ŒF2åˆ†æ•°è®¤ä¸ºå¬å›žçŽ‡çš„é‡è¦ç¨‹åº¦æ˜¯å‡†ç¡®çŽ‡çš„2å€ï¼Œè€Œ $F_{0.5}$åˆ†æ•°è®¤ä¸ºå¬å›žçŽ‡çš„é‡è¦ç¨‹åº¦æ˜¯å‡†ç¡®çŽ‡çš„ä¸€åŠã€‚ PRæ›²çº¿å’Œ ROC æ›²çº¿çš„åŒºåˆ«? å°†æµ‹è¯•é›†ä¸­çš„è´Ÿæ ·æœ¬æ•°é‡å¢žåŠ 10å€åŽï¼Œå¯ä»¥çœ‹å‡ºPRæ›²çº¿å‘ç”Ÿäº†æ˜Žæ˜¾çš„å˜åŒ–ï¼Œè€ŒROCæ›²çº¿å½¢çŠ¶åŸºæœ¬ä¸å˜ã€‚è¿™ä¸ªç‰¹ç‚¹è®©ROCæ›²çº¿èƒ½å¤Ÿå°½é‡é™ä½Žä¸åŒæµ‹è¯•é›†å¸¦æ¥çš„å¹²æ‰°ï¼Œæ›´åŠ å®¢è§‚åœ°è¡¡é‡æ¨¡åž‹æœ¬èº«çš„æ€§èƒ½ã€‚å®žé™…é—®é¢˜ä¸­ï¼Œæ­£è´Ÿæ ·æœ¬çš„æ•°é‡å¾€å¾€å¾ˆä¸å‡è¡¡ã€‚æ¯”å¦‚è®¡ç®—å¹¿å‘Šé¢†åŸŸç»å¸¸æ¶‰åŠè½¬åŒ–çŽ‡æ¨¡åž‹ï¼Œæ­£æ ·æœ¬çš„æ•°é‡å¾€å¾€æ˜¯è´Ÿæ ·æœ¬æ•°é‡çš„1æ¯”1000ç”šè‡³1æ¯”10000ã€‚è‹¥é€‰æ‹©ä¸åŒçš„æµ‹è¯•é›†ï¼ŒP-Ræ›²çº¿çš„å˜åŒ–å°±ä¼šéžå¸¸å¤§ï¼Œè€ŒROCæ›²çº¿åˆ™èƒ½å¤Ÿæ›´åŠ ç¨³å®šåœ°åæ˜ æ¨¡åž‹æœ¬èº«çš„å¥½åã€‚æ‰€ä»¥ï¼ŒROCæ›²çº¿çš„é€‚ç”¨åœºæ™¯æ›´å¤šï¼Œè¢«å¹¿æ³›ç”¨äºŽæŽ’åºã€æŽ¨èã€å¹¿å‘Šç­‰é¢†åŸŸã€‚ä½†éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œé€‰æ‹©P-Ræ›²çº¿è¿˜æ˜¯ROCæ›²çº¿æ˜¯å› å®žé™…é—®é¢˜è€Œå¼‚çš„ï¼Œå¦‚æžœç ”ç©¶è€…å¸Œæœ›æ›´å¤šåœ°çœ‹åˆ°æ¨¡åž‹åœ¨ç‰¹å®šæ•°æ®é›†ä¸Šçš„è¡¨çŽ°ï¼ŒP-Ræ›²çº¿åˆ™èƒ½å¤Ÿæ›´ç›´è§‚åœ°åæ˜ å…¶æ€§èƒ½ã€‚ å‚è€ƒæ–‡çŒ® how to handle unbalanced dataå¯¹äºŽè¿™ç±»é—®é¢˜æ˜¯å¯ä»¥ä»Žæ•°æ®å’Œæ¨¡åž‹æ¥è¿›è¡Œè€ƒè™‘çš„ã€‚ Imbalanced data typically refers to a problem with classification problems where the classes are not represented equally. The accuracy paradox is the name for the exact situation in the introduction to this post. Data approachOversample minority class and Undersample majority class Over-sampling increases the number of minority class members in the training set. The advantage of over-sampling is that no information from the original training set is lost, as all observations from the minority and majority classes are kept. On the other hand, it is prone to overfitting. (You can add copies of instances from the under-represented class called over-sampling or more formally sampling with replacement) Under-sampling, on contrary to over-sampling, aims to reduce the number of majority samples to balance the class distribution. Since it is removing observations from the original data set, it might discard useful information. (You can delete instances from the over-represented class, called under-sampling.) Some Rules of Thumb Consider testing under-sampling when you have an a lot data (tens- or hundreds of thousands of instances or more) Consider testing over-sampling when you donâ€™t have a lot of data (tens of thousands of records or less) Consider testing random and non-random (e.g. stratified) sampling schemes. Consider testing different resampled ratios (e.g. you donâ€™t have to target a 1:1 ratio in a binary classification problem, try other ratios) Try Different AlgorithmsåŸºäºŽæ ‘çš„è¿™ç§ç»“æž„çš„æ¨¡åž‹è¿˜æ˜¯è¡¨çŽ°æ¯”è¾ƒç»™åŠ›çš„ã€‚That being said, decision trees often perform well on imbalanced datasets. The splitting rules that look at the class variable used in the creation of the trees, can force both classes to be addressed. Try Penalized ModelsPenalized classification imposes an additional cost on the model for making classification mistakes on the minority class during training. These penalties can bias the model to pay more attention to the minority class. Try Changing Your Performance Metric ä½¿ç”¨ precision and recall curves or F1 åŽ»è¯„ä»·ä½ çš„ç½‘ç»œæ•ˆæžœ Precision: A measure of a classifiers exactness. Recall: A measure of a classifiers completeness F1 Score (or F-score): A weighted average of precision and recall. è€Œ ROC curves é€šå¸¸ä¸æ˜¯ä¸€ä¸ªæœ€å¥½çš„é€‰æ‹©ã€‚ https://medium.com/anomaly-detection-with-python-and-r/sampling-techniques-for-extremely-imbalanced-data-281cc01da0a8 GBCå‚æ•°è¿™äº›å‚æ•°ä¸­ï¼Œç±»ä¼¼äºŽAdaboostï¼Œæˆ‘ä»¬æŠŠé‡è¦å‚æ•°åˆ†ä¸ºä¸¤ç±»ï¼Œç¬¬ä¸€ç±»æ˜¯Boostingæ¡†æž¶çš„é‡è¦å‚æ•°ï¼Œç¬¬äºŒç±»æ˜¯å¼±å­¦ä¹ å™¨å³CARTå›žå½’æ ‘çš„é‡è¦å‚æ•°ã€‚n_estimators: ä¹Ÿå°±æ˜¯å¼±å­¦ä¹ å™¨çš„æœ€å¤§è¿­ä»£æ¬¡æ•°ï¼Œæˆ–è€…è¯´æœ€å¤§çš„å¼±å­¦ä¹ å™¨çš„ä¸ªæ•°ã€‚learning_rate: å³æ¯ä¸ªå¼±å­¦ä¹ å™¨çš„æƒé‡ç¼©å‡ç³»æ•°Î½ï¼Œä¹Ÿç§°ä½œæ­¥é•¿å¯¹äºŽåˆ†ç±»æ¨¡åž‹ï¼Œæœ‰å¯¹æ•°ä¼¼ç„¶æŸå¤±å‡½æ•°â€devianceâ€å’ŒæŒ‡æ•°æŸå¤±å‡½æ•°â€exponentialâ€ä¸¤è€…è¾“å…¥é€‰æ‹©ã€‚é»˜è®¤æ˜¯å¯¹æ•°ä¼¼ç„¶æŸå¤±å‡½æ•°â€devianceâ€ã€‚ä¸€èˆ¬æ¥è¯´ï¼ŒæŽ¨èä½¿ç”¨é»˜è®¤çš„â€devianceâ€ã€‚å®ƒå¯¹äºŒå…ƒåˆ†ç¦»å’Œå¤šå…ƒåˆ†ç±»å„è‡ªéƒ½æœ‰æ¯”è¾ƒå¥½çš„ä¼˜åŒ–ã€‚è€ŒæŒ‡æ•°æŸå¤±å‡½æ•°ç­‰äºŽæŠŠæˆ‘ä»¬å¸¦åˆ°äº†Adaboostç®—æ³•ã€‚å¯¹äºŽå›žå½’æ¨¡åž‹ï¼Œæœ‰å‡æ–¹å·®â€lsâ€, ç»å¯¹æŸå¤±â€ladâ€, HuberæŸå¤±â€huberâ€å’Œåˆ†ä½æ•°æŸå¤±â€œquantileâ€ã€‚é»˜è®¤æ˜¯å‡æ–¹å·®â€lsâ€ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œå¦‚æžœæ•°æ®çš„å™ªéŸ³ç‚¹ä¸å¤šï¼Œç”¨é»˜è®¤çš„å‡æ–¹å·®â€lsâ€æ¯”è¾ƒå¥½ã€‚å¦‚æžœæ˜¯å™ªéŸ³ç‚¹è¾ƒå¤šï¼Œåˆ™æŽ¨èç”¨æŠ—å™ªéŸ³çš„æŸå¤±å‡½æ•°â€huberâ€ã€‚è€Œå¦‚æžœæˆ‘ä»¬éœ€è¦å¯¹è®­ç»ƒé›†è¿›è¡Œåˆ†æ®µé¢„æµ‹çš„æ—¶å€™ï¼Œåˆ™é‡‡ç”¨â€œquantileâ€ã€‚max_features:å¯ä»¥ä½¿ç”¨å¾ˆå¤šç§ç±»åž‹çš„å€¼ï¼Œé»˜è®¤æ˜¯â€Noneâ€,æ„å‘³ç€åˆ’åˆ†æ—¶è€ƒè™‘æ‰€æœ‰çš„ç‰¹å¾æ•°.subsample: é€‰æ‹©å°äºŽ1çš„æ¯”ä¾‹å¯ä»¥å‡å°‘æ–¹å·®ï¼Œå³é˜²æ­¢è¿‡æ‹Ÿåˆï¼Œä½†æ˜¯ä¼šå¢žåŠ æ ·æœ¬æ‹Ÿåˆçš„åå·®ï¼Œå› æ­¤å–å€¼ä¸èƒ½å¤ªä½Žã€‚æŽ¨èåœ¨[0.5, 0.8]ä¹‹é—´ï¼Œé»˜è®¤æ˜¯1.0ï¼Œå³ä¸ä½¿ç”¨å­é‡‡æ ·ã€‚ å‚è€ƒæ–‡çŒ®GBCå‚æ•°è®¾ç½®ROCæ›²çº¿å’ŒAUCå€¼Introduction to Python Ensembles new addedå¯¹äºŽåˆ†ç±»æ¨¡åž‹ï¼ŒAUCã€KSã€ROCæ›²çº¿æ˜¯ç»¼åˆè¯„ä»·æ¨¡åž‹åŒºåˆ†èƒ½åŠ›å’ŒæŽ’åºèƒ½åŠ›çš„æŒ‡æ ‡ï¼Œè€Œç²¾ç¡®çŽ‡ã€å¬å›žçŽ‡å’ŒF1å€¼æ˜¯åœ¨ç¡®å®šæœ€ä½³é˜ˆå€¼ä¹‹åŽè®¡ç®—å¾—åˆ°çš„æŒ‡æ ‡ã€‚ å¦‚æžœå¢žå¤§è¿™ä¸ªé˜ˆå€¼ï¼Œé¢„æµ‹é”™è¯¯ï¼ˆé’ˆå¯¹æ­£æ ·æœ¬è€Œè¨€ï¼Œå³æŒ‡é¢„æµ‹æ˜¯æ­£æ ·æœ¬ä½†æ˜¯é¢„æµ‹é”™è¯¯ï¼Œä¸‹åŒï¼‰çš„æ¦‚çŽ‡å°±ä¼šé™ä½Žä½†æ˜¯éšä¹‹è€Œæ¥çš„å°±æ˜¯é¢„æµ‹æ­£ç¡®çš„æ¦‚çŽ‡ä¹Ÿé™ä½Žï¼›å¦‚æžœå‡å°è¿™ä¸ªé˜ˆå€¼ï¼Œé‚£ä¹ˆé¢„æµ‹æ­£ç¡®çš„æ¦‚çŽ‡ä¼šå‡é«˜ä½†æ˜¯åŒæ—¶é¢„æµ‹é”™è¯¯çš„æ¦‚çŽ‡ä¹Ÿä¼šå‡é«˜ã€‚å®žé™…ä¸Šï¼Œè¿™ç§é˜ˆå€¼çš„é€‰å–ä¹Ÿä¸€å®šç¨‹åº¦ä¸Šåæ˜ äº†åˆ†ç±»å™¨çš„åˆ†ç±»èƒ½åŠ›ã€‚æˆ‘ä»¬å½“ç„¶å¸Œæœ›æ— è®ºé€‰å–å¤šå¤§çš„é˜ˆå€¼ï¼Œåˆ†ç±»éƒ½èƒ½å°½å¯èƒ½åœ°æ­£ç¡®ï¼Œä¹Ÿå°±æ˜¯å¸Œæœ›è¯¥åˆ†ç±»å™¨çš„åˆ†ç±»èƒ½åŠ›è¶Šå¼ºè¶Šå¥½ï¼Œä¸€å®šç¨‹åº¦ä¸Šå¯ä»¥ç†è§£æˆä¸€ç§é²æ£’èƒ½åŠ›å§ã€‚ä¸ºäº†å½¢è±¡åœ°è¡¡é‡è¿™ç§åˆ†ç±»èƒ½åŠ›ï¼ŒROCæ›²çº¿æ¨ªç©ºå‡ºä¸– AUCèƒ½æ‹¿æ¥å¹²ä»€ä¹ˆ ä»Žä½œè€…æœ‰é™çš„ç»åŽ†æ¥è¯´ï¼ŒAUCæœ€å¤§çš„åº”ç”¨åº”è¯¥å°±æ˜¯ç‚¹å‡»çŽ‡é¢„ä¼°ï¼ˆCTRï¼‰çš„ç¦»çº¿è¯„ä¼°ã€‚CTRçš„ç¦»çº¿è¯„ä¼°åœ¨å…¬å¸çš„æŠ€æœ¯æµç¨‹ä¸­å æœ‰å¾ˆé‡è¦çš„åœ°ä½ï¼Œä¸€èˆ¬æ¥è¯´ï¼ŒABTestå’Œè½¬å…¨è§‚å¯Ÿçš„èµ„æºæˆæœ¬æ¯”è¾ƒå¤§ï¼Œæ‰€ä»¥ï¼Œä¸€ä¸ªåˆé€‚çš„ç¦»çº¿è¯„ä»·å¯ä»¥èŠ‚çœå¾ˆå¤šæ—¶é—´ã€äººåŠ›ã€èµ„æºæˆæœ¬ã€‚é‚£ä¹ˆï¼Œä¸ºä»€ä¹ˆAUCå¯ä»¥ç”¨æ¥è¯„ä»·CTRå‘¢ï¼Ÿæˆ‘ä»¬é¦–å…ˆè¦æ¸…æ¥šä¸¤ä¸ªäº‹æƒ…ï¼š CTRæ˜¯æŠŠåˆ†ç±»å™¨è¾“å‡ºçš„æ¦‚çŽ‡å½“åšæ˜¯ç‚¹å‡»çŽ‡çš„é¢„ä¼°å€¼ï¼Œå¦‚ä¸šç•Œå¸¸ç”¨çš„LRæ¨¡åž‹ï¼Œåˆ©ç”¨sigmoidå‡½æ•°å°†ç‰¹å¾è¾“å…¥ä¸Žæ¦‚çŽ‡è¾“å‡ºè”ç³»èµ·æ¥ï¼Œè¿™ä¸ªè¾“å‡ºçš„æ¦‚çŽ‡å°±æ˜¯ç‚¹å‡»çŽ‡çš„é¢„ä¼°å€¼ã€‚å†…å®¹çš„å¬å›žå¾€å¾€æ˜¯æ ¹æ®CTRçš„æŽ’åºè€Œå†³å®šçš„ã€‚ AUCé‡åŒ–äº†ROCæ›²çº¿è¡¨è¾¾çš„åˆ†ç±»èƒ½åŠ›ã€‚è¿™ç§åˆ†ç±»èƒ½åŠ›æ˜¯ä¸Žæ¦‚çŽ‡ã€é˜ˆå€¼ç´§å¯†ç›¸å…³çš„ï¼Œåˆ†ç±»èƒ½åŠ›è¶Šå¥½ï¼ˆAUCè¶Šå¤§ï¼‰ï¼Œé‚£ä¹ˆè¾“å‡ºæ¦‚çŽ‡è¶Šåˆç†ï¼ŒæŽ’åºçš„ç»“æžœè¶Šåˆç†ã€‚ æˆ‘ä»¬ä¸ä»…å¸Œæœ›åˆ†ç±»å™¨ç»™å‡ºæ˜¯å¦ç‚¹å‡»çš„åˆ†ç±»ä¿¡æ¯ï¼Œæ›´éœ€è¦åˆ†ç±»å™¨ç»™å‡ºå‡†ç¡®çš„æ¦‚çŽ‡å€¼ï¼Œä½œä¸ºæŽ’åºçš„ä¾æ®ã€‚æ‰€ä»¥ï¼Œè¿™é‡Œçš„AUCå°±ç›´è§‚åœ°åæ˜ äº†CTRçš„å‡†ç¡®æ€§ï¼ˆä¹Ÿå°±æ˜¯CTRçš„æŽ’åºèƒ½åŠ›ï¼‰ AUC æ˜¯ä¸€ä¸ªæ¨¡åž‹è¯„ä»·æŒ‡æ ‡ï¼Œåªèƒ½ç”¨äºŽäºŒåˆ†ç±»æ¨¡åž‹çš„è¯„ä»·ï¼Œå¯¹äºŽäºŒåˆ†ç±»æ¨¡åž‹ï¼Œè¿˜æœ‰å¾ˆå¤šå…¶ä»–è¯„ä»·æŒ‡æ ‡ï¼Œæ¯”å¦‚ loglossï¼Œaccuracyï¼Œprecisionã€‚å¦‚æžœä½ ç»å¸¸å…³æ³¨æ•°æ®æŒ–æŽ˜æ¯”èµ›ï¼Œæ¯”å¦‚ kaggleï¼Œé‚£ä½ ä¼šå‘çŽ° AUC å’Œ logloss åŸºæœ¬æ˜¯æœ€å¸¸è§çš„æ¨¡åž‹è¯„ä»·æŒ‡æ ‡ã€‚ ä»ŽMannâ€“Whitney U statisticçš„è§’åº¦æ¥è§£é‡Šï¼ŒAUCå°±æ˜¯ä»Žæ‰€æœ‰1æ ·æœ¬ä¸­éšæœºé€‰å–ä¸€ä¸ªæ ·æœ¬ï¼Œ ä»Žæ‰€æœ‰0æ ·æœ¬ä¸­éšæœºé€‰å–ä¸€ä¸ªæ ·æœ¬ï¼Œç„¶åŽæ ¹æ®ä½ çš„åˆ†ç±»å™¨å¯¹ä¸¤ä¸ªéšæœºæ ·æœ¬è¿›è¡Œé¢„æµ‹ï¼ŒæŠŠ1æ ·æœ¬é¢„æµ‹ä¸º1çš„æ¦‚çŽ‡ä¸ºp1ï¼ŒæŠŠ0æ ·æœ¬é¢„æµ‹ä¸º1çš„æ¦‚çŽ‡ä¸ºp0ï¼Œp1&gt;p0çš„æ¦‚çŽ‡å°±ç­‰äºŽAUCã€‚ ä½†æ˜¯åœ¨æŸäº›åœºæ™¯ä¸‹ï¼Œæˆ‘ä»¬ä¼šæ›´å…³æ³¨æ­£æ ·æœ¬ï¼Œè¿™æ—¶å€™å°±è¦ç”¨åˆ° PR æ›²çº¿äº†ã€‚æ¯”å¦‚è¯´ä¿¡ç”¨å¡æ¬ºè¯ˆæ£€æµ‹ï¼Œæˆ‘ä»¬ä¼šæ›´å…³æ³¨ precision å’Œ recallï¼Œæ¯”å¦‚è¯´å¦‚æžœè¦æ±‚é¢„æµ‹å‡ºä¸ºæ¬ºè¯ˆçš„äººå°½å¯èƒ½å‡†ç¡®ï¼Œé‚£ä¹ˆå°±æ˜¯è¦æé«˜ precisionï¼›è€Œå¦‚æžœè¦å°½å¯èƒ½å¤šåœ°é¢„æµ‹å‡ºæ½œåœ¨çš„æ¬ºè¯ˆäººç¾¤ï¼Œé‚£ä¹ˆå°±æ˜¯è¦æé«˜ recallã€‚ä¸€èˆ¬æ¥è¯´ï¼Œæé«˜äºŒåˆ†ç±»çš„ threshold å°±èƒ½æé«˜ precisionï¼Œé™ä½Ž threshold å°±èƒ½æé«˜ recallï¼Œè¿™æ—¶ä¾¿å¯è§‚å¯Ÿ PR æ›²çº¿ï¼Œå¾—åˆ°æœ€ä¼˜çš„ thresholdã€‚ ä¸¤ç§ AUC çš„ç†è§£ï¼šä¸€èˆ¬æœ‰ä¸¤å¤§ç±»è§£é‡Šï¼Œä¸€ç§æ˜¯åŸºäºŽ ROC çº¿ä¸‹é¢ç§¯ï¼Œéœ€è¦ç†è§£æ··æ·†çŸ©é˜µï¼ŒåŒ…æ‹¬ç²¾ç¡®çŽ‡ã€å¬å›žçŽ‡ã€F1 å€¼ã€ROC ç­‰æŒ‡æ ‡çš„å«ä¹‰ã€‚å¦å¤–ä¸€ç§æ˜¯åŸºäºŽæ¦‚çŽ‡çš„è§£é‡Šï¼Œæ¨¡åž‹çš„æŽ’åºèƒ½åŠ›ã€‚ AUCæ˜¯ä¸€ä¸ªæ¨¡åž‹è¯„ä»·æŒ‡æ ‡ï¼Œåªèƒ½ç”¨äºŽäºŒåˆ†ç±»æ¨¡åž‹çš„è¯„ä»·ï¼Œå¯¹äºŽäºŒåˆ†ç±»æ¨¡åž‹ï¼Œè¿˜æœ‰å¾ˆå¤šå…¶ä»–è¯„ä»·æŒ‡æ ‡ï¼Œæ¯”å¦‚loglossï¼Œaccuracyï¼Œprecisionã€‚å¦‚æžœä½ ç»å¸¸å…³æ³¨æ•°æ®æŒ–æŽ˜æ¯”èµ›ï¼Œæ¯”å¦‚kaggleï¼Œé‚£ä½ ä¼šå‘çŽ°AUCå’ŒloglossåŸºæœ¬æ˜¯æœ€å¸¸è§çš„æ¨¡åž‹è¯„ä»·æŒ‡æ ‡ã€‚å³AUCæ˜¯æŒ‡éšæœºç»™å®šä¸€ä¸ªæ­£æ ·æœ¬å’Œä¸€ä¸ªè´Ÿæ ·æœ¬ï¼Œåˆ†ç±»å™¨è¾“å‡ºè¯¥æ­£æ ·æœ¬ä¸ºæ­£çš„é‚£ä¸ªæ¦‚çŽ‡å€¼æ¯”åˆ†ç±»å™¨è¾“å‡ºè¯¥è´Ÿæ ·æœ¬ä¸ºæ­£çš„é‚£ä¸ªæ¦‚çŽ‡å€¼è¦å¤§çš„å¯èƒ½æ€§ã€‚æ‰€ä»¥AUCååº”çš„æ˜¯åˆ†ç±»å™¨å¯¹æ ·æœ¬çš„æŽ’åºèƒ½åŠ›ã€‚ AUCçš„æ„ä¹‰ ä¸ºä»€ä¹ˆAUCå’Œloglossæ¯”accuracyæ›´å¸¸ç”¨å‘¢ï¼Ÿå› ä¸ºå¾ˆå¤šæœºå™¨å­¦ä¹ çš„æ¨¡åž‹å¯¹åˆ†ç±»é—®é¢˜çš„é¢„æµ‹ç»“æžœéƒ½æ˜¯æ¦‚çŽ‡ï¼Œå¦‚æžœè¦è®¡ç®—accuracyï¼Œéœ€è¦å…ˆæŠŠæ¦‚çŽ‡è½¬åŒ–æˆç±»åˆ«ï¼Œè¿™å°±éœ€è¦æ‰‹åŠ¨è®¾ç½®ä¸€ä¸ªé˜ˆå€¼ï¼Œå¦‚æžœå¯¹ä¸€ä¸ªæ ·æœ¬çš„é¢„æµ‹æ¦‚çŽ‡é«˜äºŽè¿™ä¸ªé¢„æµ‹ï¼Œå°±æŠŠè¿™ä¸ªæ ·æœ¬æ”¾è¿›ä¸€ä¸ªç±»åˆ«é‡Œé¢ï¼Œä½ŽäºŽè¿™ä¸ªé˜ˆå€¼ï¼Œæ”¾è¿›å¦ä¸€ä¸ªç±»åˆ«é‡Œé¢ã€‚æ‰€ä»¥è¿™ä¸ªé˜ˆå€¼å¾ˆå¤§ç¨‹åº¦ä¸Šå½±å“äº†accuracyçš„è®¡ç®—ã€‚ä½¿ç”¨AUCæˆ–è€…loglosså¯ä»¥é¿å…æŠŠé¢„æµ‹æ¦‚çŽ‡è½¬æ¢æˆç±»åˆ«ã€‚ AUCæŒ‡æ ‡çš„ä¸è¶³ä¹‹å¤„ï¼š åªåæ˜ äº†æ¨¡åž‹çš„æ•´ä½“æ€§èƒ½ï¼Œçœ‹ä¸å‡ºåœ¨ä¸åŒç‚¹å‡»çŽ‡åŒºé—´ä¸Šçš„è¯¯å·®æƒ…å†µï¼› åªåæ˜ äº†æŽ’åºèƒ½åŠ›ï¼Œå…³æ³¨çš„æ˜¯æ¦‚çŽ‡å€¼çš„ç›¸å¯¹å¤§å°ï¼Œä¸Žé˜ˆå€¼å’Œæ¦‚çŽ‡å€¼çš„ç»å¯¹å¤§å°æ²¡æœ‰å…³ç³»ï¼Œæ²¡æœ‰åæ˜ é¢„æµ‹ç²¾åº¦ï¼›ï¼ˆç®€å•è¯´ï¼Œå¦‚æžœå¯¹ä¸€ä¸ªæ¨¡åž‹çš„ç‚¹å‡»çŽ‡ç»Ÿä¸€ä¹˜ä»¥2ï¼ŒAUCä¸ä¼šå˜åŒ–ï¼Œä½†æ˜¾ç„¶æ¨¡åž‹é¢„æµ‹çš„å€¼å’ŒçœŸå®žå€¼ä¹‹é—´çš„offsetæ‰©å¤§äº†ã€‚ï¼‰ AUCåªå…³æ³¨æ­£è´Ÿæ ·æœ¬ä¹‹é—´çš„æŽ’åºï¼Œå¹¶ä¸å…³å¿ƒæ­£æ ·æœ¬å†…éƒ¨ï¼Œæˆ–è€…è´Ÿæ ·æœ¬å†…éƒ¨çš„æŽ’åºã€‚è¿™ä¹Ÿä½“çŽ°äº†AUCçš„æœ¬è´¨ï¼šä»»æ„ä¸ªæ­£æ ·æœ¬çš„æ¦‚çŽ‡éƒ½å¤§äºŽè´Ÿæ ·æœ¬çš„æ¦‚çŽ‡çš„èƒ½åŠ›ã€‚ loglossè¡¡é‡çš„æ˜¯é¢„æµ‹æ¦‚çŽ‡åˆ†å¸ƒå’ŒçœŸå®žæ¦‚çŽ‡åˆ†å¸ƒçš„å·®å¼‚æ€§ï¼Œå–å€¼è¶Šå°è¶Šå¥½ã€‚ä¸ŽAUCä¸åŒï¼Œloglosså¯¹é¢„æµ‹æ¦‚çŽ‡æ•æ„Ÿã€‚ï¼ˆè¿™ä¸ªlog loss åœ¨ä¹¦å†™çš„æ—¶å€™ï¼Œæœ€å¥½æ˜¯åŠ ä¸Šè´Ÿå·ï¼Œè¿™æ ·æ˜¯æ¯”è¾ƒè§„èŒƒçš„ï¼‰ AUCæ˜¯çŽ°åœ¨åˆ†ç±»æ¨¡åž‹ï¼Œç‰¹åˆ«æ˜¯äºŒåˆ†ç±»æ¨¡åž‹ä½¿ç”¨çš„ä¸»è¦ç¦»çº¿è¯„æµ‹æŒ‡æ ‡ä¹‹ä¸€ã€‚ç›¸æ¯”äºŽå‡†ç¡®çŽ‡ã€å¬å›žçŽ‡ã€F1ç­‰æŒ‡æ ‡ï¼ŒAUCæœ‰ä¸€ä¸ªç‹¬ç‰¹çš„ä¼˜åŠ¿ï¼Œå°±æ˜¯ä¸å…³æ³¨å…·ä½“å¾—åˆ†ï¼Œåªå…³æ³¨æŽ’åºç»“æžœï¼Œè¿™ä½¿å¾—å®ƒç‰¹åˆ«é€‚ç”¨äºŽæŽ’åºé—®é¢˜çš„æ•ˆæžœè¯„ä¼°ï¼Œä¾‹å¦‚æŽ¨èæŽ’åºçš„è¯„ä¼°ã€‚ AUCè¿™ä¸ªæŒ‡æ ‡æœ‰ä¸¤ç§è§£é‡Šæ–¹æ³•ï¼Œä¸€ç§æ˜¯ä¼ ç»Ÿçš„â€œæ›²çº¿ä¸‹é¢ç§¯â€è§£é‡Šï¼Œå¦ä¸€ç§æ˜¯å…³äºŽæŽ’åºèƒ½åŠ›çš„è§£é‡Šã€‚ä¾‹å¦‚0.7çš„AUCï¼Œå…¶å«ä¹‰å¯ä»¥å¤§æ¦‚ç†è§£ä¸ºï¼šç»™å®šä¸€ä¸ªæ­£æ ·æœ¬å’Œä¸€ä¸ªè´Ÿæ ·æœ¬ï¼Œåœ¨70%çš„æƒ…å†µä¸‹ï¼Œæ¨¡åž‹å¯¹æ­£æ ·æœ¬çš„æ‰“åˆ†é«˜äºŽå¯¹è´Ÿæ ·æœ¬çš„æ‰“åˆ†ã€‚å¯ä»¥çœ‹å‡ºåœ¨è¿™ä¸ªè§£é‡Šä¸‹ï¼Œæˆ‘ä»¬å…³å¿ƒçš„åªæœ‰æ­£è´Ÿæ ·æœ¬ä¹‹é—´çš„åˆ†æ•°é«˜ä½Žï¼Œè€Œå…·ä½“çš„åˆ†å€¼åˆ™æ— å…³ç´§è¦ã€‚ å¯¹äºŽ ROC å’ŒAUCçš„æ€»ç»“ ROCæ›²çº¿åæ˜ äº†åˆ†ç±»å™¨çš„åˆ†ç±»èƒ½åŠ›ï¼Œç»“åˆè€ƒè™‘äº†åˆ†ç±»å™¨è¾“å‡ºæ¦‚çŽ‡çš„å‡†ç¡®æ€§ AUCé‡åŒ–äº†ROCæ›²çº¿çš„åˆ†ç±»èƒ½åŠ›ï¼Œè¶Šå¤§åˆ†ç±»æ•ˆæžœè¶Šå¥½ï¼Œè¾“å‡ºæ¦‚çŽ‡è¶Šåˆç† AUCå¸¸ç”¨ä½œCTRçš„ç¦»çº¿è¯„ä»·ï¼ŒAUCè¶Šå¤§ï¼ŒCTRçš„æŽ’åºèƒ½åŠ›è¶Šå¼º åˆ†ç±»å™¨æ€§èƒ½åº¦é‡æŒ‡æ ‡ä¹‹ROCæ›²çº¿ã€AUCå€¼ KSå€¼æ˜¯åœ¨æ¨¡åž‹ä¸­ç”¨äºŽåŒºåˆ†é¢„æµ‹æ­£è´Ÿæ ·æœ¬åˆ†éš”ç¨‹åº¦çš„è¯„ä»·æŒ‡æ ‡ï¼Œä¸€èˆ¬åº”ç”¨äºŽé‡‘èžé£ŽæŽ§é¢†åŸŸã€‚ä¸ŽROCæ›²çº¿ç›¸ä¼¼ï¼ŒROCæ˜¯ä»¥FPRä½œä¸ºæ¨ªåæ ‡ï¼ŒTPRä½œä¸ºçºµåæ ‡ï¼Œé€šè¿‡æ”¹å˜ä¸åŒé˜ˆå€¼ï¼Œä»Žè€Œå¾—åˆ°ROCæ›²çº¿ã€‚è€Œåœ¨KSæ›²çº¿ä¸­ï¼Œåˆ™æ˜¯ä»¥é˜ˆå€¼ä½œä¸ºæ¨ªåæ ‡ï¼Œä»¥FPRå’ŒTPRä½œä¸ºçºµåæ ‡ï¼Œksæ›²çº¿åˆ™ä¸ºTPR-FPRï¼Œksæ›²çº¿çš„æœ€å¤§å€¼é€šå¸¸ä¸ºkså€¼ã€‚ ä¸ºä»€ä¹ˆè¿™æ ·æ±‚KSå€¼å‘¢ï¼Ÿæˆ‘ä»¬çŸ¥é“ï¼Œå½“é˜ˆå€¼å‡å°æ—¶ï¼ŒTPRå’ŒFPRä¼šåŒæ—¶å‡å°ï¼Œå½“é˜ˆå€¼å¢žå¤§æ—¶ï¼ŒTPRå’ŒFPRä¼šåŒæ—¶å¢žå¤§ã€‚è€Œåœ¨å®žé™…å·¥ç¨‹ä¸­ï¼Œæˆ‘ä»¬å¸Œæœ›TPRæ›´å¤§ä¸€äº›ï¼ŒFPRæ›´å°ä¸€äº›ï¼Œå³TPR-FPRè¶Šå¤§è¶Šå¥½ï¼Œå³kså€¼è¶Šå¤§è¶Šå¥½ã€‚ KSå€¼çš„å–å€¼èŒƒå›´æ˜¯[0ï¼Œ1]ã€‚é€šå¸¸æ¥è¯´ï¼Œå€¼è¶Šå¤§ï¼Œæ¨¡åž‹åŒºåˆ†æ­£è´Ÿæ ·æœ¬çš„èƒ½åŠ›è¶Šå¼ºï¼ˆä¸€èˆ¬0.3ä»¥ä¸Šï¼Œè¯´æ˜Žæ¨¡åž‹çš„æ•ˆæžœæ¯”è¾ƒå¥½ï¼‰ã€‚ è¯„ä¼°æŒ‡æ ‡å’Œä»£ä»·å‡½æ•°æ˜¯ä¸€å®¶äººå—ï¼Ÿ ä»£ä»·å‡½æ•°ï¼šf(Î¸,y)ï¼Œåˆç§°Cost functionï¼Œloss function objective functionã€‚ä¸€èˆ¬ç”¨åœ¨è®­ç»ƒè¿‡ç¨‹ä¸­ï¼Œç”¨æ¥å®šä¹‰é¢„æµ‹å€¼å’ŒçœŸå®žå€¼ä¹‹é—´çš„è·ç¦»ï¼ˆä¹Ÿå°±æ˜¯è¡¡é‡æ¨¡åž‹åœ¨è®­ç»ƒé›†ä¸Šçš„æ€§èƒ½ï¼‰ï¼Œä½œä¸ºæ¨¡åž‹è°ƒæ•´å‚æ•°çš„åé¦ˆã€‚ä»£ä»·å‡½æ•°è¶Šå°ï¼Œæ¨¡åž‹æ€§èƒ½è¶Šå¥½ã€‚ è¯„åˆ¤æŒ‡æ ‡ï¼šf(yÌ‚ ,y)ï¼Œä¸€èˆ¬ç”¨äºŽè®­ç»ƒå’Œæµ‹è¯•è¿‡ç¨‹ä¸­ï¼Œç”¨äºŽè¯„ä¼°æ¨¡åž‹å¥½åã€‚è¯„åˆ¤æŒ‡æ ‡è¶Šå¤§ï¼ˆæˆ–è¶Šå°ï¼‰ï¼Œæ¨¡åž‹è¶Šå¥½ã€‚ æœ¬è´¨ä¸Šä»£ä»·å‡½æ•°å’Œè¯„åˆ¤æŒ‡æ ‡éƒ½æ˜¯ä¸€å®¶äººï¼Œåªä»–ä»¬çš„åº”ç”¨åœºæ™¯ä¸åŒï¼Œåˆ†å·¥ä¸åŒã€‚ä»£ä»·å‡½æ•°æ˜¯ç”¨æ¥ä¼˜åŒ–æ¨¡åž‹å‚æ•°çš„ï¼Œè¯„ä»·æŒ‡æ ‡æ˜¯ç”¨æ¥è¯„åˆ¤æ¨¡åž‹å¥½åçš„ã€‚ ä½œä¸ºè¯„åˆ¤æŒ‡æ ‡æ‰€å…·å¤‡çš„æ¡ä»¶ï¼š ç›´è§‚ï¼Œå¯ä»¥ç†è§£â€¦â€¦ ä½œä¸ºä»£ä»·å‡½æ•°æ‰€å…·å¤‡çš„æ¡ä»¶ï¼š å‡½æ•°å…‰æ»‘ä¸”å¯å¯¼ï¼šå¯ç”¨æ¢¯åº¦ä¸‹é™æ±‚è§£æžå€¼å‡½æ•°ä¸ºå‡¸å‡½æ•°ï¼šå¯ç”¨æ¢¯åº¦ä¸‹é™æ±‚è§£æœ€ä¼˜è§£â€¦â€¦ ä¾‹å¦‚æˆ‘ä»¬ç»å¸¸ä½¿ç”¨çš„åˆ†ç±»å™¨è¯„åˆ¤æŒ‡æ ‡ AUC å°±ä¸èƒ½ç›´æŽ¥è¢«ä¼˜åŒ–ï¼Œå› æ­¤æˆ‘ä»¬å¸¸é‡‡ç”¨äº¤å‰ç†µæ¥ä»£æ›¿ AUC è¿›è¡Œä¼˜åŒ–ã€‚ ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œäº¤å‰ç†µè¶Šå°ï¼ŒAUC å°±ä¼šè¶Šå¤§ã€‚ æŽ¨èç­–ç•¥ä¸­çš„å¬å›ž æŽ¨èç³»ç»Ÿå¦‚ä½•æ ¹æ®å·²æœ‰çš„ç”¨æˆ·ç”»åƒå’Œå†…å®¹ç”»åƒåŽ»æŽ¨èï¼Œæ¶‰åŠåˆ°ä¸¤ä¸ªå…³é”®é—®é¢˜ï¼šå¬å›žå’ŒæŽ’åºã€‚â€œå¬å›žï¼ˆmatchï¼‰â€æŒ‡ä»Žå…¨é‡ä¿¡æ¯é›†åˆä¸­è§¦å‘å°½å¯èƒ½å¤šçš„æ­£ç¡®ç»“æžœï¼Œå¹¶å°†ç»“æžœè¿”å›žç»™â€œæŽ’åºâ€ã€‚å¬å›žçš„æ–¹å¼æœ‰å¤šç§ï¼šååŒè¿‡æ»¤ã€ä¸»é¢˜æ¨¡åž‹ã€å†…å®¹å¬å›žå’Œçƒ­ç‚¹å¬å›žç­‰ï¼Œè€Œâ€œæŽ’åºï¼ˆrankï¼‰â€œåˆ™æ˜¯å¯¹æ‰€æœ‰å¬å›žçš„å†…å®¹è¿›è¡Œæ‰“åˆ†æŽ’åºï¼Œé€‰å‡ºå¾—åˆ†æœ€é«˜çš„å‡ ä¸ªç»“æžœæŽ¨èç»™ç”¨æˆ·ã€‚ æœç´¢å’ŒæŽ¨èçš„åŒºåˆ«ï¼š æœç´¢ä¸­ç”¨æˆ·æ˜¯æœ‰æ˜Žç¡®çš„æœç´¢è¯ï¼Œä½†æ˜¯åœ¨æŽ¨èä¸­ç”¨æˆ·æ˜¯æ²¡æœ‰æ˜Žç¡®çš„æœæœç´¢è¯è¾“å…¥ï¼Œæ˜¯è¦æ ¹æ®ç”¨æˆ·ç”»åƒï¼Œå†…å®¹ç”»åƒç­‰å„ç§ä¿¡æ¯ä¸ºç”¨æˆ·æŽ¨èä»–æ„Ÿå…´è¶£çš„ã€‚ å¬å›žç­–ç•¥çš„è¯„ä¼°ä¸»è¦æ ¹æ®ä¸¤ä¸ªè¯„ä»·æŒ‡æ ‡ï¼šå¬å›žçŽ‡å’Œå‡†ç¡®çŽ‡ã€‚ å¬å›žç­–ç•¥ä¸»è¦åŒ…å«ä¸¤å¤§ç±»ï¼Œå³åŸºäºŽå†…å®¹åŒ¹é…çš„å¬å›žå’ŒåŸºäºŽç³»ç»Ÿè¿‡æ»¤çš„å¬å›žã€‚ åŸºäºŽå†…å®¹åŒ¹é…çš„å¬å›ž å†…å®¹åŒ¹é…å³å°†ç”¨æˆ·ç”»åƒä¸Žå†…å®¹ç”»åƒè¿›è¡ŒåŒ¹é…ï¼Œåˆåˆ†ä¸ºåŸºäºŽå†…å®¹æ ‡ç­¾çš„åŒ¹é…å’ŒåŸºäºŽçŸ¥è¯†çš„åŒ¹é…ã€‚ ä¾‹å¦‚ï¼ŒAç”¨æˆ·çš„ç”¨æˆ·ç”»åƒä¸­æœ‰ä¸€æ¡æ ‡ç­¾æ˜¯â€œæ¨å¹‚çš„ç²‰ä¸â€ï¼Œé‚£ä¹ˆåœ¨ä»–çœ‹äº†ã€Šç»£æ˜¥åˆ€2ã€‹è¿™éƒ¨æ¨å¹‚ä¸»æ¼”çš„ç”µå½±åŽï¼Œå¯ä»¥ä¸ºä»–æŽ¨èæ¨å¹‚ä¸»æ¼”çš„å…¶ä»–ç”µå½±æˆ–ç”µè§†å‰§ï¼Œè¿™å°±æ˜¯â€œåŸºäºŽå†…å®¹æ ‡ç­¾çš„åŒ¹é…â€ã€‚ â€œåŸºäºŽçŸ¥è¯†çš„åŒ¹é…â€åˆ™æ›´è¿›ä¸€æ­¥ï¼Œéœ€è¦ç³»ç»Ÿå­˜å‚¨ä¸€æ¡â€œçŸ¥è¯†â€â€”â€”ã€Šç»£æ˜¥åˆ€2ã€‹æ˜¯ã€Šç»£æ˜¥åˆ€1ã€‹çš„ç»­é›†ï¼Œè¿™æ ·å°±å¯ä»¥ä¸ºçœ‹è¿‡ã€Šç»£æ˜¥åˆ€2ã€‹çš„ç”¨æˆ·æŽ¨èã€Šç»£æ˜¥åˆ€1ã€‹ã€‚åŸºäºŽå†…å®¹åŒ¹é…çš„å¬å›žè¾ƒä¸ºç®€å•ã€åˆ»æ¿ï¼Œå¬å›žçŽ‡è¾ƒé«˜ï¼Œä½†å‡†ç¡®çŽ‡è¾ƒä½Žï¼ˆå› ä¸ºæ ‡ç­¾åŒ¹é…å¹¶ä¸ä¸€å®šä»£è¡¨çœŸçš„æ„Ÿå…´è¶£ï¼‰ï¼Œæ¯”è¾ƒé€‚ç”¨äºŽå†·å¯åŠ¨çš„è¯­ä¹‰çŽ¯å¢ƒã€‚ åŸºäºŽååŒè¿‡æ»¤çš„å¬å›ž å¦‚æžœä»…ä½¿ç”¨ä¸Šè¿°è¾ƒç®€å•çš„å¬å›žç­–ç•¥ï¼ŒæŽ¨èå†…å®¹ä¼šè¾ƒä¸ºå•ä¸€ï¼Œç›®å‰ä¸šç•Œæœ€å¸¸ç”¨çš„åŸºäºŽååŒè¿‡æ»¤çš„å¬å›žï¼Œå®ƒåˆåˆ†ä¸ºåŸºäºŽç”¨æˆ·ã€åŸºäºŽé¡¹ç›®å’ŒåŸºäºŽæ¨¡åž‹çš„ååŒè¿‡æ»¤ã€‚ åŸºäºŽç”¨æˆ·ï¼ˆUser-basedï¼‰çš„ååŒæŽ¨èæ˜¯æœ€åŸºç¡€çš„ï¼Œå®ƒçš„åŸºç¡€å‡è®¾æ˜¯â€œç›¸ä¼¼çš„äººä¼šæœ‰ç›¸åŒçš„å–œå¥½â€ï¼ŒæŽ¨èæ–¹æ³•æ˜¯ï¼Œå‘çŽ°ä¸Žç”¨æˆ·ç›¸ä¼¼çš„å…¶ä»–ç”¨æˆ·ï¼Œç”¨ç”¨æˆ·çš„æµè§ˆè®°å½•åšç›¸äº’æŽ¨èã€‚ä¾‹å¦‚ï¼Œé€šè¿‡æµè§ˆè®°å½•å‘çŽ°ç”¨æˆ·ä¸€ä¸Žç”¨æˆ·äºŒçš„åå¥½ç±»ä¼¼ï¼Œå°±å°†ç”¨æˆ·ä¸€ç‚¹å‡»çš„å†…å®¹æŽ¨é€ç»™ç”¨æˆ· åŸºäºŽé¡¹ç›®ï¼ˆItem-basedï¼‰çš„ååŒè¿‡æ»¤ä¸­çš„â€œé¡¹ç›®â€å¯ä»¥è§†åœºæ™¯å®šä¸ºä¿¡æ¯æµäº§å“ä¸­çš„â€œå†…å®¹â€æˆ–è€…ç”µå•†å¹³å°ä¸­çš„â€œå•†å“â€ï¼Œå…¶åŸºç¡€å‡è®¾æ˜¯â€œå–œæ¬¢ä¸€ä¸ªç‰©å“çš„ç”¨æˆ·ä¼šå–œæ¬¢ç›¸ä¼¼çš„ç‰©å“â€è®¡ç®—é¡¹ç›®ä¹‹é—´çš„ç›¸ä¼¼æ€§ï¼Œå†æ ¹æ®ç”¨æˆ·çš„åŽ†å²åå¥½ä¿¡æ¯å°†ç±»ä¼¼çš„ç‰©å“æŽ¨èç»™è¯¥ç”¨æˆ·ã€‚ åŸºäºŽæ¨¡åž‹çš„ååŒè¿‡æ»¤æŽ¨èï¼ˆModel-basedï¼‰å°±æ˜¯åŸºäºŽæ ·æœ¬çš„ç”¨æˆ·å–œå¥½ä¿¡æ¯ï¼Œè®­ç»ƒä¸€ä¸ªæŽ¨èæ¨¡åž‹ï¼Œç„¶åŽæ ¹æ®å®žæ—¶çš„ç”¨æˆ·å–œå¥½çš„ä¿¡æ¯è¿›è¡Œé¢„æµ‹æŽ¨èã€‚ æ€»ä½“æ¥è¯´ï¼ŒåŸºäºŽååŒè¿‡æ»¤çš„å¬å›žå³å»ºç«‹ç”¨æˆ·å’Œå†…å®¹é—´çš„è¡Œä¸ºçŸ©é˜µï¼Œä¾æ®â€œç›¸ä¼¼æ€§â€è¿›è¡Œåˆ†å‘ã€‚è¿™ç§æ–¹å¼å‡†ç¡®çŽ‡è¾ƒé«˜ï¼Œä½†å­˜åœ¨ä¸€å®šç¨‹åº¦çš„å†·å¯åŠ¨é—®é¢˜ã€‚ åœ¨å®žé™…è¿ç”¨ä¸­ï¼Œé‡‡ç”¨å•ä¸€å¬å›žç­–ç•¥çš„æŽ¨èç»“æžœå®žé™…ä¼šéžå¸¸ç²—ç³™ï¼Œé€šç”¨çš„è§£å†³æ–¹æ³•æ˜¯å°†è§„åˆ™æ‰“æ•£ï¼Œå°†ä¸Šè¿°å‡ ç§å¬å›žæ–¹å¼ä¸­æç‚¼åˆ°çš„å„ç§ç»†å°ç‰¹å¾èµ‹äºˆæƒé‡ï¼Œåˆ†åˆ«æ‰“åˆ†ï¼Œå¹¶è®¡ç®—æ€»åˆ†å€¼ï¼Œé¢„æµ‹CTRã€‚ ä¾‹å¦‚ï¼Œæ ¹æ®å†…å®¹åŒ¹é…å¬å›žç­–ç•¥ï¼Œç”¨æˆ·Aå’Œå†…å®¹ç”²çš„æ ‡ç­¾åŒ¹é…åº¦ä¸º0.6ï¼ŒåŒæ—¶ï¼Œæ ¹æ®ååŒè¿‡æ»¤å¬å›žç­–ç•¥ï¼Œåº”è¯¥å°†å†…å®¹ç”²æŽ¨èç»™ç”¨æˆ·Açš„å¯èƒ½æ€§ä¸º0.7ï¼Œé‚£ä¹ˆå°±ä¸º0.6å’Œ0.7è¿™ä¸¤ä¸ªæ•°å€¼åˆ†åˆ«èµ‹äºˆæƒé‡ï¼ˆè¿™ä¸ªæƒé‡å¯èƒ½ä¼šæ ¹æ®ç®—æ³•çš„å…·ä½“æƒ…å†µæ¥ç¡®å®šï¼‰ï¼Œå¾—å‡ºæ€»åˆ†ï¼Œç”¨å®ƒæ¥é¢„æµ‹ç”¨æˆ·å¯èƒ½ç‚¹å‡»çš„æ¦‚çŽ‡ï¼Œä»Žè€Œå†³å®šæ˜¯å¦è¿”å›žè¯¥ç»“æžœã€‚ æŠ€èƒ½GET | æŽ¨èç­–ç•¥ä¸­çš„â€œå¬å›žâ€ ä»Žå•†ä¸šè§’åº¦çœ‹ï¼Œå¾ˆå¤šæŽ¨èç³»ç»Ÿè¿žæŽ¥ç€å¹³å°æ–¹ã€å†…å®¹ç”Ÿäº§è€…ã€ç”¨æˆ·ä¸‰ä¸ªç»“ç‚¹ï¼Œå› æ­¤ä¸€ä¸ªå¥½çš„æŽ¨èç³»ç»Ÿå¿…ç„¶æ˜¯å°½å¯èƒ½è®©è¿™ä¸‰æ–¹çš„åˆ©ç›Šéƒ½èƒ½å¤Ÿè€ƒè™‘åˆ°ï¼Œè¯„æµ‹æŒ‡æ ‡ä¹Ÿå°±æ›´åŠ å¤šå…ƒåŒ–ï¼Œè¿™æ˜¯ä¸Žå­¦æœ¯ç•Œéžå¸¸å¤§çš„ä¸€ä¸ªåŒºåˆ«ã€‚ å·¥ä¸šç•ŒæŽ¨èç³»ç»Ÿçš„è¯„æµ‹æ ‡å‡† çº¿ä¸‹è¯„æµ‹æ˜¯æŽ¨èç³»ç»Ÿæœ€å¸¸ä½¿ç”¨çš„ï¼Œé€šå¸¸æœ‰ä¸¤ç§è¯„æµ‹æ–¹å¼ï¼Œä¸€ç§æ˜¯ç¦»çº¿æ¨¡æ‹Ÿè¯„æµ‹ï¼Œä¸€ç§æ˜¯ä½¿ç”¨ç”¨æˆ·åŽ†å²çœŸå®žè®¿é—®æ•°æ®è¿›è¡Œè¯„æµ‹ã€‚ åˆ©ç”¨åŽ†å²çœŸå®žæ—¥å¿—æž„é€ ç”¨æˆ·è®¿é—®å‚æ•°ï¼Œå¾—åˆ°å¸¦è¯„æµ‹æŽ¥å£çš„ç»“æžœæ—¥å¿—åŽï¼Œç»“åˆå¯¹åº”çš„çœŸå®žåé¦ˆï¼Œå¯ä»¥å®šæ€§è¯„æµ‹æ•ˆæžœå¯¹æ¯”ã€‚æ¯”å¦‚ï¼Œå¯ä»¥è¯„æµ‹æŽ¨èç»“æžœçš„ TopK çš„å‡†ç¡®çŽ‡ï¼Œæˆ–è€…æŽ’åºæ•ˆæžœ AUCã€‚è¿™äº›æ¨¡åž‹æ•ˆæžœç±»æŒ‡æ ‡ï¼Œè™½ç„¶ä¸èƒ½ä»£è¡¨æœ€ç»ˆå…³æ³¨çš„å•†ä¸šæŒ‡æ ‡ï¼Œä½†æ˜¯ä¸¤è€…ä¹‹é—´ä¸€èˆ¬å­˜åœ¨ä¸€å®šçš„ç›¸å…³æ€§ã€‚é€šå¸¸æ¥è¯´ TopK å‡†ç¡®çŽ‡é«˜ï¼Œæˆ–è€… AUC é«˜äºŽ 0.5 è¶Šå¤šï¼Œå¯¹åº”çš„å•†ä¸šæŒ‡æ ‡å°±ä¼šè¶Šå¥½ï¼Œè¿™æ˜¯ä¸€ä¸ªåŸºæœ¬å‡è®¾ã€‚é€šè¿‡ç¦»çº¿æ¨¡æ‹Ÿè¯„æµ‹æ¯ä¸€å¤©çš„æ¨¡åž‹æ•ˆæžœæŒ‡æ ‡ï¼ŒåŒæ—¶è®¡ç®—å½“å¤©çœŸå®žçš„å•†ä¸šæŒ‡æ ‡ï¼Œå¯ä»¥ç»˜åˆ¶å‡ºä¸¤è€…ä¹‹é—´çš„æ•£ç‚¹å›¾ï¼Œä»Žè€Œå›žå½’å‡ºä¸€ä¸ªç®€å•çš„æ¨¡åž‹ï¼Œç”¨ç¦»çº¿æ¨¡åž‹æ•ˆæžœé¢„ä¼°ä¸Šçº¿åŽçœŸå®žå•†ä¸šæŒ‡æ ‡ã€‚ æŸ¥å‡†çŽ‡ï¼Œå³åœ¨æŽ¨èï¼ˆé¢„æµ‹ï¼‰çš„ç‰©å“ä¸­ï¼Œæœ‰å¤šå°‘æ˜¯ç”¨æˆ·çœŸæ­£ï¼ˆå‡†ç¡®ï¼‰æ„Ÿå…´è¶£çš„ã€‚æŸ¥å…¨çŽ‡ï¼Œå³ç”¨æˆ·å–œæ¬¢çš„ç‰©å“ä¸­ï¼Œæœ‰å¤šå°‘æ˜¯è¢«æŽ¨èäº†çš„ã€‚ ä¼˜ç‚¹ï¼š å‡†ç¡®çŽ‡å’Œå¬å›žçŽ‡å¯¹æ¯”è¯„åˆ†å‡†ç¡®åº¦æŒ‡æ ‡æ›´èƒ½ååº”æŽ¨èç³»ç»Ÿåœ¨çœŸå®žåœºæ™¯ä¸­çš„è¡¨çŽ°ã€‚ å±€é™æ€§ï¼š å‡†ç¡®çŽ‡å’Œå¬å›žçŽ‡å¿…é¡»è¦ä¸€èµ·ä½¿ç”¨æ‰èƒ½å…¨é¢è¯„ä»·ç®—æ³•çš„å¥½å ã€‚å‡†ç¡®çŽ‡å’Œå¬å›žçŽ‡æ˜¯ä¸¤ä¸ªå¾ˆç›¸ä¼¼çš„æŒ‡æ ‡ï¼Œè¿™ä¸¤ä¸ªæŒ‡æ ‡å­˜åœ¨è´Ÿç›¸å…³çš„å…³ç³»ï¼Œä»–ä»¬åˆ†åˆ«ä»Žä¸åŒçš„è§’åº¦æ¥è¯„ä»·æŽ¨èç³»ç»Ÿï¼Œå•ç‹¬çš„æŒ‡æ ‡ä¸è¶³ä»¥è¯´æ˜Žç®—æ³•çš„å¥½åï¼Œå¿…é¡»ä¸€èµ·ä½¿ç”¨æ‰æ˜¯æ›´åŠ å…¨é¢çš„è¯„ä»·ã€‚ å‡†ç¡®çŽ‡å’Œå¬å›žçŽ‡å­˜åœ¨è´Ÿç›¸å…³å…³è”ï¼Œå–å†³äºŽæŽ¨èåˆ—è¡¨çš„é•¿åº¦ï¼Œäº’ç›¸ç‰µåˆ¶1ï¼‰å½“å‡†ç¡®çŽ‡å¾ˆé«˜çš„æ—¶å€™ï¼Œè¡¨æ˜Žå¸Œæœ›æŽ¨èçš„ç‰©å“ç»å¤§å¤šæ•°æ˜¯ç”¨æˆ·æ„Ÿå…´è¶£çš„ï¼Œå› æ­¤æŽ¨èè¾ƒä¸ºä¿å®ˆï¼ŒåªæŽ¨å°‘é‡æœ€æœ‰Â­æŠŠæ¡çš„ç‰©å“ï¼Œè¿™æ ·çš„è¯ï¼Œæœ‰äº›ç”¨æˆ·å¯èƒ½æ„Ÿå…´è¶£ä½†æŽ’åæ²¡æœ‰é‚£ä¹ˆé å‰çš„ç‰©å“åˆ™ä¼šè¢«å¿½ç•¥ã€‚å› æ­¤å¬å›žçŽ‡å°±æ¯”è¾ƒä½Žã€‚2ï¼‰å¦‚æžœå¬å›žçŽ‡å¾ˆé«˜ï¼Œè¡¨æ˜Žç›®æ ‡æ˜¯å°½å¯èƒ½æŠŠç”¨æˆ·æ„Ÿå…´è¶£çš„ç‰©å“å…¨éƒ¨å¬å›žï¼Œåˆ™é—¨æ§›å°±ä¼šé™ä½Žï¼Œä¸ºäº†æ•èŽ·æ›´å¤šç”¨æˆ·æ„Ÿå…´è¶£çš„ç‰©å“ï¼Œå¬å›žçš„æ€»é‡å°±å¤šäº†ï¼Œè€Œå‡†ç¡®çŽ‡å°±ä½Žäº†ã€‚ å…³äºŽæŽ’åºèƒ½åŠ›çš„è¯„æµ‹æŒ‡æ ‡ï¼Œæˆ‘ä»¬è‡ªç„¶ä¼šæƒ³åˆ°æœç´¢å¼•æ“Žä¸­çš„æŽ’åºæŒ‡æ ‡ï¼Œå®ƒä»¬åœ¨æŸç§ç¨‹åº¦æ˜¯å¯ä»¥åº”ç”¨äºŽæŽ¨èç³»ç»Ÿå‘çš„è¯„æµ‹ï¼Œä½†æ˜¯ä¼šæœ‰äº›é—®é¢˜ã€‚ç”±äºŽæŽ¨èç³»ç»Ÿè¾“å‡ºç»“æžœæ˜¯éžå¸¸ä¸ªäººåŒ–çš„ï¼Œé™¤äº†ç”¨æˆ·æœ¬äººï¼Œå…¶ä»–äººéƒ½å¾ˆéš¾æ›¿ä»–å›žç­”å“ªä¸ªå¥½å“ªä¸ªä¸å¥½ï¼Œè€Œæœç´¢å¼•æ“Žè¯„ä»·æœç´¢ç»“æžœå’ŒæŸ¥è¯¢ç›¸å…³æ€§ï¼Œå…·æœ‰å¾ˆå¼ºçš„å®¢è§‚å±žæ€§ï¼Œå¯ä»¥ä»–äººä»£æ›¿è¯„ä»·ã€‚æ‰€ä»¥é€šå¸¸è¯„ä»·æŽ¨èç³»ç»ŸæŽ’åºæ•ˆæžœå¾ˆå°‘é‡‡ç”¨æœç´¢å¼•æ“ŽæŽ’åºæŒ‡æ ‡ï¼Œæ¯”å¦‚ MAPã€MRRã€NDCGã€‚æŽ¨èç³»ç»Ÿè¯„ä»·æŽ’åºé€šå¸¸é‡‡ç”¨ AUCã€‚ æ ¸å¿ƒå…³é”®è¯ä¸€èˆ¬ç«žäº‰åŠ›å¾ˆå¤§ï¼Œç›¸åé•¿å°¾å…³é”®è¯ä¸€èˆ¬æ›´èƒ½å¸¦æ¥è½¬æ¢çŽ‡ï¼Œå› ä¸ºç›®çš„æ€§ç›¸å¯¹æ¥è¯´æ›´å¼ºã€‚é•¿å°¾å…³é”®è¯ ã€‚ç”±é•¿å°¾å…³é”®è¯å¸¦æ¥çš„æµé‡å°±æ˜¯é•¿å°¾æµé‡è™½ç„¶é•¿å°¾å…³é”®è¯çš„æœç´¢é‡æ¯”è¾ƒå°‘ï¼ŒåŒæ—¶ä¹Ÿä¸ç¨³å®šã€‚ ä½†æ˜¯é•¿å°¾å…³é”®è¯åº“èƒ½å¤Ÿå¸¦æ¥çš„å®¢æˆ·ï¼Œè½¬åŒ–æˆäº¤ä¸ºç½‘ç«™äº§å“å®¢æˆ·çš„æ¯”ä¾‹æ¯”ä¸€èˆ¬çš„æ ¸å¿ƒå…³é”®è¯è¦é«˜å‡ºå¾ˆå¤šï¼Œè¿™æ˜¯å› ä¸ºé•¿å°¾å…³é”®è¯çš„ç›®çš„æ€§ä¼šæ›´æ˜Žæ˜¾ã€‚ å­¦ä¼šåˆ†æž AUC AUC æ˜¯æŽ¨èç³»ç»Ÿä¸­éžå¸¸é‡è¦çš„ä¸€ä¸ªæŒ‡æ ‡ï¼Œåœ¨å·¥ä¸šç•Œæ¨¡åž‹çš„ä¸åŒé˜¶æ®µä¼šæœ‰ä¸‰ä¸ªä¸åŒçš„ AUC æŒ‡æ ‡ã€‚ æ­£äº¤æ€§ï¼šä»Žå‡ ä½•ä¸­æ¥çš„æœ¯è¯­ï¼Œå¦‚æžœä¸¤æ¡ç›´çº¿äº’ä¸ä¾èµ–ï¼Œé‚£ä¹ˆä»–ä»¬å°±æ˜¯æ­£äº¤çš„ã€‚ AUC ç†è®ºä¸Šå·®è·åº”è¯¥æ¯”è¾ƒå°ï¼Œä½†å®žé™…ä¸­ä¾ç„¶å¯èƒ½å‡ºçŽ°è¾ƒå¤§çš„å·®å¼‚ï¼Œå­¦ä¼šå¯¹æ¯”åˆ†æžè¿™ä¸‰ä¸ª AUC å€¼ï¼Œå…¶å®žå¯ä»¥çœ‹å‡ºå¾ˆå¤šé—®é¢˜ã€‚ train AUC &gt;&gt; test AUC ï¼Ÿ train AUC è¿œå¤§äºŽ test AUCï¼Œé€šå¸¸æƒ…å†µæ˜¯æ¨¡åž‹å‡ºçŽ°äº†è¿‡æ‹Ÿåˆã€‚ test AUC &gt;&gt; Online AUC ï¼Ÿ test AUC è¿œå¤§äºŽ online AUCï¼Œ é€šå¸¸æ˜¯å› ä¸ºç‰¹å¾ä¸ä¸€è‡´äº§ç”Ÿçš„ï¼Œé‚£ç‰¹å¾ä¸ä¸€è‡´æ˜¯å¦‚ä½•äº§ç”Ÿçš„å‘¢ï¼Ÿ è¿™é‡Œæœ‰å…³äºŽä¸ä¸€è‡´çš„åŽŸå› çš„åˆ†æž AUC é‡åŒ–äº† ROC æ›²çº¿è¡¨è¾¾çš„åˆ†ç±»èƒ½åŠ›ã€‚è¿™ç§åˆ†ç±»èƒ½åŠ›æ˜¯ä¸Žæ¦‚çŽ‡ã€é˜ˆå€¼ç´§å¯†ç›¸å…³çš„ï¼ŒAUC å€¼è¶Šå¤§ï¼Œåˆ™è¯´æ˜Žåˆ†ç±»èƒ½åŠ›è¶Šå¥½ï¼Œé‚£ä¹ˆé¢„æµ‹è¾“å‡ºçš„æ¦‚çŽ‡è¶Šåˆç†ï¼Œå› æ­¤æŽ’åºçš„ç»“æžœè¶Šåˆç†ã€‚å¦‚æ­¤ AUC è¿™ä¸ªå€¼åœ¨æ•°å­¦ä¸Šç­‰ä»·äºŽï¼šæ¨¡åž‹æŠŠå…³å¿ƒçš„é‚£ä¸€ç±»æ ·æœ¬æŽ’åœ¨å…¶ä»–æ ·æœ¬å‰é¢çš„æ¦‚çŽ‡ã€‚æœ€å¤§æ˜¯ 1ï¼Œå®Œç¾Žç»“æžœï¼Œè€Œ 0.5 å°±æ˜¯éšæœºæŽ’åˆ—ï¼Œ0 å°±æ˜¯å®Œç¾Žåœ°å…¨éƒ¨æŽ’é”™ã€‚ pv page view é¡µé¢æµè§ˆé‡uv unique visitor ç‹¬ç«‹è®¿å®¢æ•° å¤ä¹ ç¬”è®° ROCæ›²çº¿ï¼Œprecision-recall æ›²çº¿æ˜¯äºŒåˆ†ç±»æ¨¡åž‹ä¸­ç»å¸¸ä½¿ç”¨çš„è¯„ä»·æ¨¡åž‹æœ€åŽæ•ˆæžœçš„æŒ‡æ ‡ã€‚AUCå€¼ä¸€èˆ¬æ˜¯æŒ‡ROC æ›²çº¿çš„é¢ç§¯ï¼Œå¯¹åº”çš„precision-recall ä¹Ÿæœ‰ä¸€ä¸ªæ•°å€¼æŒ‡æ ‡F1ã€‚å¯¹äºŽROC æ›²çº¿çºµåæ ‡æ˜¯TP_rateï¼Œ æ¨ªåæ ‡æ˜¯FP_rateã€‚ å¤„ç† unbalanced data æ€è·¯ä»Ždata å’Œmodel ä¸¤æ–¹é¢è¿›è¡Œè€ƒè™‘ã€‚ï¼ˆå…¶å®žä»»ä½•NN ä¸­é—®é¢˜éƒ½æ˜¯å¯ä»¥ä»Žè¿™ä¸¤æ–¹é¢è¿›è¡Œè€ƒè™‘çš„ï¼‰ã€‚æ•°æ®å¤„ç†ï¼Œ(1) å¢žå¼ºç±»åˆ«æ•°é‡å°‘çš„æ ·æœ¬ (2)å‡å°‘ç±»åˆ«æ•°é‡å¤šçš„æ ·æœ¬ã€‚åœ¨predict çš„æ—¶å€™ç¡®å®žæ˜¯å¯ä»¥è®¾å®šä¸åŒçš„æ­£è´Ÿæ ·æœ¬æ¯”ï¼Œç„¶åŽçœ‹ä¸€ä¸‹æ¨¡åž‹çš„å¯¹äºŽæ ·æœ¬æ˜¯å¦å…·æœ‰åå·®ã€‚æ¨¡åž‹å¤„ç†ï¼š(1) åŸºäºŽæ ‘çš„æ¨¡åž‹åœ¨å¤„ç†imbalanced data è¿˜æ˜¯æ¯”è¾ƒç»™åŠ›çš„ (2 ) å½“minority class é¢„æµ‹å‡ºé”™çš„æ—¶å€™ï¼Œæ·»åŠ  additional costï¼Œè¿™æ ·ä½¿å¾—æ¨¡åž‹èƒ½å¤Ÿæ›´åŠ å…³æ³¨minority classã€‚ ä½¿ç”¨ä¸åŒçš„è¯„ä»·æŒ‡æ ‡ï¼š å½“æ ·æœ¬ä¸å‡è¡¡çš„æ—¶å€™ï¼Œä½¿ç”¨ precision_ recall æˆ–è€… F1 åŽ»è¯„ä»·æ¨¡åž‹ï¼ˆè¿™ä¸ªæ—¶å€™ROC é€šå¸¸ä¸æ˜¯å¾ˆå¥½çš„é€‰æ‹©ï¼Œå› ä¸ºå¯¹äºŽæ­£è´Ÿæ ·æœ¬æ¯”ä¾‹ä¸æ˜¯å¾ˆæ•æ„Ÿï¼‰]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>ROC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¯¹æŠ—ç”Ÿæˆç½‘ç»œå®žéªŒå¯¹æ¯”]]></title>
    <url>%2F2018%2F06%2F05%2F%E5%AF%B9%E6%8A%97%E6%80%A7%E7%94%9F%E6%88%90%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[GANæ¨¡åž‹æ˜¯å…¸åž‹çš„éšå¼æ— ç›‘ç£ç”Ÿæˆæ¨¡åž‹ï¼Œå»ºæ¨¡è¿‡ç¨‹ä¸­æ²¡æœ‰åˆ©ç”¨åˆ°æ•°æ®çš„è¯­ä¹‰æ ‡ç­¾ã€‚ä½†åœ¨å®žé™…åº”ç”¨ä¸­ç”Ÿæˆæ¨¡åž‹çš„å¯æŽ§æ€§è‡³å…³é‡è¦ï¼Œæ ¹æ®æ ‡ç­¾ç”Ÿæˆå¯¹å¯æŽ§æœ‰æ ·æœ¬æ›´å…·å®žé™…åº”ç”¨ä»·å€¼ã€‚å›¾åƒç”Ÿæˆæ¨¡åž‹è¢«å¹¿æ³›åº”ç”¨äºŽæ•°æ®å¢žå¼ºã€é£Žæ ¼è½¬æ¢å’Œæ•°æ®è¡¥å…¨é¢†åŸŸï¼Œéœ€è¦å¯æŽ§ä¸”è¯­ä¹‰å®Œå¤‡çš„ç”Ÿæˆæ¨¡åž‹ã€‚æ¡ä»¶GANæ¨¡åž‹åœ¨GANæ¨¡åž‹å»ºæ¨¡æ€è·¯çš„åŸºç¡€ä¸Šï¼Œå°†è¯­ä¹‰æ ‡ç­¾åŠ å…¥äº†å»ºæ¨¡è¿‡ç¨‹ï¼Œå°†æ— ç›‘ç£ç”Ÿæˆæ¨¡åž‹è½¬å˜ä¸ºæœ‰ç›‘ç£çš„æ¡ä»¶ç”Ÿæˆæ¨¡åž‹ã€‚æ¡ä»¶GANæ¨¡åž‹å…·ä½“åŒ…æ‹¬Conditional GANæ¨¡åž‹ã€Semi-GANæ¨¡åž‹å’ŒAC-GANæ¨¡åž‹ã€‚ å®žéªŒæ¨¡åž‹ä»‹ç»ï¼ˆ1ï¼‰Conditional GANæ¨¡åž‹GANæ¨¡åž‹ä¸­åˆ¤åˆ«å™¨Då¯¹è¾“å…¥çš„æ•°æ®æ ·æœ¬çš„æ¥æºè¿›è¡Œåˆ¤åˆ«ï¼Œæ˜¯å…¸åž‹çš„åˆ¤åˆ«æ¨¡åž‹æµç¨‹ã€‚å¦‚æžœåœ¨GANæ¡†æž¶ä¸­åŠ å…¥æœ‰ç›‘ç£ä¿¡æ¯æ¥è¾…åŠ©è®­ç»ƒï¼Œå¦‚å›¾åƒçš„ç±»åˆ«ä¿¡æ¯æ¥è¾…åŠ©åˆ¤åˆ«å™¨Dè¿›è¡Œåˆ¤åˆ«ï¼Œåˆ™ä¼šå¸®åŠ©ç”Ÿæˆæ›´åŠ çœŸå®žçš„æ ·æœ¬ã€‚å…¶ä¸­æœ€åˆçš„å°è¯•æ–¹å¼æ˜¯Conditional GANæ¨¡åž‹ï¼Œç»“æž„å¦‚å›¾æ‰€ç¤ºã€‚Conditional GANæ¨¡åž‹åœ¨ç”Ÿæˆå™¨Gå’Œåˆ¤åˆ«å™¨Dè¾“å…¥ä¸­éƒ½åŠ å…¥äº†æ ‡ç­¾ä¿¡æ¯ï¼Œè¯•å›¾è®©ç”Ÿæˆå™¨Gå­¦ä¹ åˆ°ä»Žæ•°æ®æ ‡ç­¾yåˆ°æ ·æœ¬xçš„æ˜ å°„ï¼Œè®©åˆ¤åˆ«å™¨Då­¦ä¹ å¯¹æ ·æœ¬xå’Œæ ‡ç­¾yçš„ç»„åˆè¿›è¡Œåˆ¤åˆ«ã€‚ä¸ŽGANæ¨¡åž‹ç›¸æ¯”ï¼ŒConditional GANæ¨¡åž‹å¢žåŠ äº†æ ‡ç­¾ä¿¡æ¯çš„è¾“å…¥å°†æ¨¡åž‹è½¬å˜ä¸ºæ¡ä»¶ç”Ÿæˆæ¨¡åž‹ï¼Œåœ¨ä¸€å®šç¨‹åº¦ä¸Šæé«˜äº†æ¨¡åž‹çš„ç¨³å®šæ€§ã€‚Conditional GANæ¨¡åž‹è®­ç»ƒè¿‡ç¨‹ä¸­ï¼Œåˆ¤åˆ«å™¨Då¯¹æ ·æœ¬xå’Œæ ‡ç­¾yçš„ç±»åˆ«ç»„åˆè¿›è¡Œè®­ç»ƒï¼Œå¹¶æ²¡æœ‰è¾“å…¥æ ·æœ¬xå’Œæ ‡ç­¾yçš„ç±»åˆ«é”™è¯¯ç»„åˆè¿›è¡Œè®­ç»ƒï¼Œå› æ­¤æ¨¡åž‹å¹¶æ²¡æœ‰å­¦ä¹ æ ·æœ¬xå’Œæ ‡ç­¾yçš„è”åˆåˆ†å¸ƒã€‚ï¼ˆ2ï¼‰Semi-GANæ¨¡åž‹Conditional GANæ¨¡åž‹åˆ©ç”¨äº†æ ‡ç­¾ä¿¡æ¯è¿›è¡Œå»ºæ¨¡ï¼Œä½†æ²¡æœ‰å¯¹æ ‡ç­¾è¯­ä¹‰çš„ä¿¡æ¯è¿›è¡Œè¡¨å¾ï¼Œå¯¼è‡´æ¨¡åž‹èƒ½å¤Ÿå­¦åˆ°çš„ä¿¡æ¯æœ‰é™ã€‚åœ¨ç”Ÿæˆæ¨¡åž‹è¿‡ç¨‹ä¸­ï¼Œå¦‚æžœåˆ¤åˆ«å™¨Dèƒ½å¤Ÿæ˜Žç¡®æŒ‡å‡ºç”Ÿæˆæ ·æœ¬çš„ç±»åˆ«é”™è¯¯ï¼Œåˆ™å¯ä¸ºç”Ÿæˆå™¨Gæä¾›æ›´åŠ ç²¾ç¡®çš„æ¢¯åº¦ä¿¡æ¯ï¼Œæœ€ç»ˆèƒ½ç”Ÿæˆæ›´åŠ çœŸå®žçš„æ ·æœ¬ã€‚Semi-GANåŸºäºŽæ­¤æ€è·¯è¿›è¡Œæ”¹è¿›ï¼Œå…·ä½“ç»“æž„å¦‚å›¾9æ‰€ç¤ºã€‚Semi-GANæ¨¡åž‹åœ¨Conditional GANæ¨¡åž‹çš„åŸºç¡€ä¸Šï¼Œå¯¹åˆ¤åˆ«å™¨Dçš„åˆ†ç±»è¾“å‡ºè¿›è¡Œç»†åŒ–åŠ å…¥äº†åŠç›‘ç£å­¦ä¹ è¿‡ç¨‹ã€‚ï¼ˆ3ï¼‰AC-GANæ¨¡åž‹ä¸ŽConditional GANæ¨¡åž‹ç›¸æ¯”ï¼ŒSemi-GANæ¨¡åž‹ä¸­åˆ¤åˆ«å™¨Dèƒ½å¤Ÿåˆ¤åˆ«çœŸå®žæ ·æœ¬çš„æ¥æºï¼Œå¢žå¼ºäº†åˆ¤åˆ«å™¨Dçš„åˆ¤åˆ«èƒ½åŠ›ã€‚ä½†ç ”ç©¶è¡¨æ˜Žè¿‡å¼ºçš„åˆ¤åˆ«ä¿¡æ¯ä¼šå½±å“ç”Ÿäº§æ ·æœ¬çš„è´¨é‡ï¼Œå…·ä½“åŽŸå› ä¸ºSemi-GANæ¨¡åž‹çš„å»ºæ¨¡è¿‡ç¨‹ä¸ºåŠç›‘ç£åˆ†ç±»è¿‡ç¨‹ï¼Œç›®æ ‡ä¼˜åŒ–å‡½æ•°ä¸ºæ— ç›‘ç£åˆ†ç±»å’Œæœ‰ç›‘ç£åˆ†ç±»ç›®æ ‡å‡½æ•°ä¹‹å’Œã€‚è‹¥åˆ¤åˆ«å™¨Dçš„ç›‘ç£åˆ†ç±»ä¿¡æ¯è¿‡å¼ºï¼Œåˆ™ä¼šå‰Šå¼±åˆ¤åˆ«å™¨Då¯¹æ ·æœ¬æ¥æºçš„åˆ¤åˆ«èƒ½åŠ›ã€‚Conditional GANæ¨¡åž‹èƒ½å¤Ÿç”ŸæˆæŒ‡å®šç±»åˆ«çš„æ ·æœ¬ï¼ŒSemi-GANæ¨¡åž‹èƒ½å¤Ÿåˆ¤åˆ«æ ·æœ¬çš„ç±»åˆ«ä¿¡æ¯ã€‚AC-GANæ¨¡åž‹å°†ä»¥ä¸Šä¸¤ä¸ªæ¨¡åž‹æ€è·¯è¿›è¡Œæ•´åˆï¼Œå¾—åˆ°å¤Ÿè¿›è¡Œæ¡ä»¶ç”Ÿæˆçš„ç”Ÿæˆå™¨Gï¼Œå’Œèƒ½å¤Ÿåˆ¤åˆ«æ ·æœ¬ç±»åˆ«å’Œæ¥æºä¿¡æ¯çš„åˆ¤åˆ«å™¨Dã€‚AC-GANæ¨¡åž‹çš„ç»“æž„å¦‚å›¾10æ‰€ç¤ºã€‚AC-GANæ¨¡åž‹åœ¨Conditional GANçš„åŸºç¡€ä¸Šï¼Œè®©åˆ¤åˆ«å™¨Dåœ¨åˆ¤åˆ«æ ·æœ¬æ¥æºçš„åŒæ—¶ï¼Œè®©æ ·æœ¬è¿›è¡Œåˆ†ç±»ã€‚æ­¤æ—¶çš„åˆ¤åˆ«å™¨Dçš„è¾“å‡ºåˆ†ä¸ºæ ·æœ¬æ¥æºä¿¡æ¯LSå’Œæ ·æœ¬åˆ†ç±»LCä¿¡æ¯ã€‚ ä¸åŒæ¨¡åž‹æ¯”è¾ƒä¸‹é¢ç”¨è¡¨æ ¼çš„æ–¹å¼å¯¹æ¯”åœ¨å®žéªŒä¸­ä½¿ç”¨çš„æ¨¡åž‹çš„ç›®æ ‡å‡½æ•°(ps,å›¾ç”»æ¯”è¾ƒä¸‘ï¼Œä¹‹åŽå†ä¿®æ”¹) Name Paper Link Value Function GAN Arxiv DCGAN Arxiv Semi-GAN Arxiv å’ŒGAN æ¨¡åž‹ç›¸åŒ CGAN Arxiv ACGAN Arxiv our model Arxiv æ•°æ®é›†ä»‹ç»åœ¨å¸¸ç”¨äºŽå›¾åƒç”Ÿæˆçš„å›¾åƒæ•°æ®é›†ä¸­ï¼Œå¤§éƒ¨åˆ†æ•°æ®çš„æ ‡ç­¾ç±»åž‹ä¸ºç¦»æ•£ç±»åž‹ã€‚å…¶ä¸­MNISTå’ŒFashion-MNISTä¸ºå¸¸ç”¨çš„ç°åº¦å›¾åƒæ•°æ®ï¼Œæ¯ç±»æ ·æœ¬åˆ†å¸ƒè¾ƒä¸ºç‹¬ç«‹ï¼Œå¸¸ç”¨äºŽè¿›è¡Œå›¾åƒåˆ†ç±»å’Œæ ·æœ¬ç”Ÿæˆçš„å®žéªŒï¼›SVHNå’ŒCIFAR10ä¸ºå½©è‰²æ•°æ®é›†å›¾åƒåƒç´ åˆ†å¸ƒè¾ƒä¸ºå¤æ‚ï¼Œå…¶ä¸­CIFAR10å¸¸ç”¨æ¥æ£€éªŒåˆ†ç±»ç½‘ç»œæ€§èƒ½çš„è¯„ä»·æ•°æ®é›†ï¼›CelebAä¸ºå¤§è§„æ¨¡çš„äººè„¸è¯†åˆ«å’Œå±žæ€§åˆ†ç±»æ•°æ®é›†ï¼Œæ¯å¹…äººè„¸å›¾åƒåŒ…æ‹¬40ä¸ªå±žæ€§æ ‡ç­¾ï¼›ImageNetä¸ºå›¾åƒåˆ†ç±»å’Œè¯†åˆ«æ•°æ®é›†ï¼Œæ•°æ®é›†ç±»åˆ«åˆ†å¸ƒæ¯”è¾ƒå¤æ‚å…·ä½“åŒ…æ‹¬è‡ªç„¶å›¾åƒå’Œäººä¸ºå›¾åƒã€‚UnityEyesä¸ºäººçœ¼è§†è§‰åˆæˆæ•°æ®é›†ï¼Œæ•°æ®é›†æ ‡ç­¾åŒ…æ‹¬çž³å­”æ ‡ç­¾å’Œè§†è§‰æ–¹å‘æ ‡ç­¾ï¼Œå…¶ä¸­è§†è§‰æ–¹å‘æ ‡ç­¾ä¸ºè¿žç»­çš„è¯­è¨€æ ‡ç­¾ã€‚å¸¸è§çš„ç¦»æ•£æ ‡ç­¾å›¾åƒæ•°æ®é›†çš„æ ·ä¾‹: æˆ‘ä»¬çš„æ¨¡åž‹åœ¨åŽŸå§‹GANæ¨¡åž‹ä¸­ï¼Œç›®æ ‡å‡½æ•°å®šä¹‰ä¸ºç”Ÿæˆå™¨Gå’Œåˆ¤åˆ«å™¨Dçš„åšå¼ˆè¿‡ç¨‹ï¼Œå®šä¹‰V(G;D)ä¸ºæ¨¡åž‹çš„ç›®æ ‡å‡½æ•°ï¼Œç”±ç”Ÿæˆå™¨Gå’Œåˆ¤åˆ«å™¨Dç»„æˆã€‚è¯­ä¹‰åŒ¹é…ç›®æ ‡å‡½æ•°FMlossã€‚åŸºäºŽè¯­ä¹‰åŒ¹é…çš„æ¡ä»¶ç”Ÿæˆç½‘ç»œæ¨¡åž‹çš„ç”Ÿæˆå™¨Gå’Œåˆ¤åˆ«å™¨Dçš„ç›®æ ‡å‡½æ•°åˆ†åˆ«ä¸ºï¼šå¦‚ä¸Šå¼ï¼ŒLSä¸ºæ ·æœ¬æ¥æºï¼ŒLCä¸ºåˆ†ç±»ç»“æžœã€‚åˆ¤åˆ«å™¨Dç›®æ ‡ä¸ºæœ€å¤§åŒ–LC+ LS + FMlossï¼Œå…¶è¯•å›¾å¯¹è¾“å…¥æ ·æœ¬è¿›è¡Œåˆ†ç±»ï¼Œå¹¶é€šè¿‡æ¥æºå’Œè¯­ä¹‰åŒ¹é…åŒºåˆ†ç”Ÿæˆæ ·æœ¬å’ŒåŽŸå§‹æ ·æœ¬ã€‚ç”Ÿæˆå™¨Gçš„ç›®çš„æ˜¯æœ€å¤§åŒ–LC âˆ’ LS âˆ’FMlossï¼Œå…¶è¯•å›¾é€šè¿‡æ ·æœ¬åˆ†ç±»ç»“æžœã€æ ·æœ¬æ¥æºå’Œè¯­ä¹‰åŒ¹é…ç»“æžœæ¥æ¬ºéª—åˆ¤åˆ«å™¨Dã€‚LSæ¥æºæŸå¤±ä¸ŽåŽŸå§‹GANæ¨¡åž‹ç›¸åŒï¼ŒLCä¸ºè¯­ä¹‰æ ‡ç­¾åˆ†ç±»æŸå¤±ï¼Œåœ¨ç±»åˆ«åˆ†ç±»ä¸­ä½¿ç”¨äº¤å‰ä¿¡æ¯ç†µï¼Œåœ¨æ•°å€¼å›žå½’ä¸­åˆ™ä½¿ç”¨å‡æ–¹å·®å›žå½’ã€‚ ç”Ÿæˆç»“æžœå¯¹æ¯”MNISTæ•°æ®é›†ç”Ÿæˆç»“æžœFashion-MNISTæ•°æ®é›†ç”Ÿæˆç»“æžœSVHNæ•°æ®é›†ç”Ÿæˆç»“æžœCIFAR10æ•°æ®é›†ç”Ÿæˆç»“æžœCelebAæ•°æ®é›†ç”Ÿæˆç»“æžœUnityEyesæ•°æ®é›†ç”Ÿæˆç»“æžœ]]></content>
      <categories>
        <category>Deep learning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XGBoost]]></title>
    <url>%2F2018%2F06%2F05%2FXGBoost%2F</url>
    <content type="text"><![CDATA[ä»‹ç» xgboost åŽŸç†, xgboost+ lr æ¨¡åž‹å’Œ å†³ç­–æ ‘ã€‚ æå‡æ ‘ç®€ä»‹ç›‘ç£å­¦ä¹ çš„è¦ç´  model and parameters The parameters are the undetermined part that we need to learn from data. In linear regression problems, the parameters are the coefficients $\theta$. å¯¹äºŽç›‘ç£å­¦ä¹ ä¸­ï¼Œå­¦ä¹ çš„æ˜¯æ¨¡åž‹çš„å‚æ•° $\theta$ã€‚ä¸è®ºæ˜¯å›žå½’è¿˜æ˜¯åˆ†ç±»æ¨¡åž‹ï¼ŒåŸºæœ¬å‡è®¾æ˜¯å‚æ•°è¡¨ç¤ºæ•°æ®çš„åˆ†å¸ƒã€‚ ç›®æ ‡å‡½æ•°= è®­ç»ƒloss function + æ­£åˆ™é¡¹$$obj(\theta) =L(\theta) + \Omega(\theta)$$ training loss measures how well model fit on training data, while regularization, measures complexity of modelå…¶ä¸­ $L(\theta)$ æ˜¯loss functionï¼Œè¡¨ç¤ºæ¨¡åž‹çš„é¢„æµ‹æ€§ï¼› $\Omega(\theta) $è¡¨ç¤ºæ¨¡åž‹çš„å¤æ‚åº¦ã€‚ è¿™ä¸ªçš„é€‰æ‹©å°±æ˜¯bias-variance tradeoff çš„é—®é¢˜ã€‚ ä¸ºä»€ä¹ˆè¦simple models? simple models tends to have smaller variance in future predictions, making prediction stableã€‚ä¸€èˆ¬æ¥è¯´ç®€å•çš„å‚æ•°ï¼Œå¾—åˆ°çš„ç»“æžœæ˜¯more stableã€‚ å†³ç­–æ ‘é›†åˆï¼ˆDecision Tree Ensemblesï¼‰ To begin with, let us first learn about the model choice of XGBoost: decision tree ensembles. The tree ensemble model consists of a set of classification and regression trees (CART). xgboost å°±æ˜¯ä¸€ç³»åˆ—å†³ç­–æ ‘çš„é›†åˆã€‚è¿™äº›å†³ç­–æ ‘æ˜¯ç”±ä¸€ç³»åˆ—çš„ CART æ ‘ç»„æˆçš„ã€‚ A CART is a bit different from decision trees, in which the leaf only contains decision values. In CART, a real score is associated with each of the leaves, which gives us richer interpretations that go beyond classification. This also allows for a principled, unified approach to optimization, as we will see in a later part of this tutorial. é€šå¸¸æƒ…å†µä¸‹ï¼Œä¸€æ£µæ ‘æ˜¯ä¸è¶³ä»¥è¿›è¡Œé¢„æµ‹ï¼Œæ‰€ä»¥ä½¿ç”¨çš„æ˜¯å†³ç­–æ ‘çš„é›†åˆã€‚å¯¹äºŽæŸä¸€ä¸ªæ ·æœ¬çš„ç»“æžœæ˜¯å¤šä¸ªæ ‘çš„æ€»å’Œã€‚ å†³ç­–æ ‘å°±æ˜¯åˆ†æ®µå‡½æ•°ï¼Œæ‰€ä»¥ä¸€ä¸ªå†³ç­–æ ‘æ˜¯å¯ä»¥ä½¿ç”¨ $f(x)$ è¿›è¡Œè¡¨ç¤ºçš„ã€‚$$\hat{y} _{i}=\sum _{k=1} ^{K} f _{k}(x _{i}), f _{k} \in \mathcal{F}$$å…¶ä¸­ $K$ æ˜¯æ ‘çš„ä¸ªæ•°ï¼ˆå‡½æ•°çš„ä¸ªæ•°ï¼‰, $f $ è¡¨ç¤ºæŸä¸ªå‡½æ•°, $ \mathcal{F}$æ‰€æœ‰çš„CARTs å¯èƒ½çš„æ€»çš„ç©ºé—´ã€‚ äºŽæ˜¯æ–°çš„ç›®æ ‡å‡½æ•°å¯ä»¥ï¼š $$obj(\theta) =\sum _{i} ^{n} l(y _{i}, \hat{y} _{i})+\sum _{k=1} ^{K} \Omega(f _{k})$$ Now here comes a trick question: what is the model used in random forests? Tree ensembles! So random forests and boosted trees are really the same models; the difference arises from how we train them. ä½†æ˜¯ä¸€ä¸ªé—®é¢˜å‡ºçŽ°äº†ï¼Œboosted trees å’Œ random forest éƒ½æ˜¯ç›¸åŒçš„æ¨¡åž‹ï¼Œå…¶åŒºåˆ«åœ¨äºŽå¦‚ä½•è®­ç»ƒã€‚ æå‡æ ‘è¿™ä¸ªå°ç»“è®²çš„æ˜¯å¦‚ä½•è¿›è¡Œè®­ç»ƒçš„é—®é¢˜ã€‚ç¬¬ä¸€å°èŠ‚ä¸­é™ˆè¿°çš„æ˜¯ç›‘ç£å­¦ä¹ ä¸­é€šç”¨æ¨¡åž‹æ˜¯é€šè¿‡æ¢¯åº¦ä¸‹é™è¿›è¡Œè®­ç»ƒçš„ï¼Œåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­å­¦ä¹ åˆ°äº†å‚æ•°ã€‚æ ‘æ¨¡åž‹ä¸èƒ½ä½¿ç”¨æ¢¯åº¦ä¸‹é™è¿›è¡Œè®­ç»ƒï¼Œéœ€è¦æŠŠæ ‘çœ‹åšæ•´ä½“ã€‚ åŠ æ³•å­¦ä¹  It is intractable to learn all the trees at once. Instead, we use an additive strategy: fix what we have learned, and add one new tree at a time. å®ƒæ˜¯ä¸€ç§å¯å‘å¼å­¦ä¹ ï¼Œä¼˜åŒ–çš„ç›®æ ‡ä¸æ˜¯å…¨éƒ¨çš„æ ‘ã€‚è€Œæ˜¯æ¯æ¬¡åœ¨ä¸Šä¸€æ­¥çš„åŸºç¡€ä¸Šè¿›è¡Œä¼˜åŒ–ï¼Œæ¯æ¬¡å¢žåŠ ä¸€æ£µæ ‘ã€‚ ä½†æ˜¯è¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œé‚£ä¹ˆå¦‚ä½•åŽ»é€‰æ‹©å“ªä¸ªæ ‘å‘¢ï¼Ÿå½“ç„¶æ˜¯ä½¿å¾—æœ€åŽloss ä¸‹é™çš„é‚£é¢—æ ‘ã€‚ $$\begin{split}obj ^{(t)} &amp;= \sum _{i=1} ^{n} l(y _{i}, \hat{y} _{i} ^{(t)})+\sum _{i=1} ^{t} \Omega(f _{i}) \\&amp; =\sum _{i=1} ^{n} l(y _{i}, \hat{y} _{i} ^{(t-1)}+f _{t}(x _{i}))+\Omega(f _{t})+\text { constant }\end{split}$$ è¿™ä¸ªæ—¶å€™ï¼Œä½¿ç”¨å‡æ–¹è¯¯å·®ä½œä¸ºæŸå¤±å‡½æ•°ï¼Œå¯ä»¥å¾—åˆ°ï¼š \begin{split}obj _{(t)} &amp; =\sum _{i=1} ^{n} (y _{i}, \hat{y} _{i} ^{(t-1)}+f _{t}(x _{i})) ^2+ \sum _{i=1} ^t \Omega(f _{i}) \\&amp;=\sum _{i=1} ^{n}[2(\hat{y} _{i} ^{(t-1)}-y _{i}) f _{t}(x _{i})+f _{t}(x _{i}) ^{2}]+\Omega(f _{t})+\text { constant }\end{split} å½“ä½¿ç”¨å‡æ–¹è¯¯å·®çš„æ—¶å€™ï¼Œå¾ˆnice å¾—åˆ°äº†æ¯”è¾ƒç®€æ´çš„å½¢å¼ï¼ˆæ®‹å·®å½¢å¼ï¼‰ï¼Œä½†æ˜¯å¦‚æžœæ˜¯å…¶ä»–çš„æŸå¤±å‡½æ•°ï¼Œå°±æ²¡æœ‰è¿™ç§ç»„åˆæˆ $f(x), f^2(x)$ è¿™ç§å½¢å¼ï¼Œæ‰€ä»¥è¿™ä¸ªæ—¶å€™ä½¿ç”¨åˆ°çš„æ˜¯talor å±•å¼€å¼ã€‚æ‰€ä»¥æ›´åŠ é€šç”¨çš„å½¢å¼å¦‚ä¸‹ï¼š$$\mathrm{obj} ^{(t)}=\sum _{i=1} ^{n}[l(y _{i}, \hat{y} _{i} ^{(t-1)})+g _{i} f _{t}(x _{i})+\frac{1}{2} h _{i} f _{t} ^{2}(x _{i})]+\Omega(f _{t})+\mathrm{constant}$$ å…¶ä¸­ $g_i$å’Œ $h_i$ åˆ†åˆ«å®šä¹‰ä¸ºå¦‚ä¸‹å½¢å¼ï¼š $$\begin{split}g _{i} &amp;=\partial _{\hat{y} _{i} ^{(t-1)}} l(y _{i}, \hat{y} _{i} ^{(t-1)}) \\h _{i} &amp;=\partial _{\hat{y} _{i} ^{(t-1)}} ^{2} l(y _{i}, \hat{y} _{i} ^{(t-1)})\end{split}$$ æœ€åŽåŽ»æŽ‰æ‰€æœ‰çš„å¸¸é‡ï¼Œåœ¨ $t$æ—¶åˆ»çš„ç›®æ ‡å‡½æ•°æ˜¯å¦‚ä¸‹å½¢å¼ï¼š$$\sum _{i=1} ^{n}[g _{i} f _{t}(x _{i})+\frac{1}{2} h _{i} f _{t} ^{2}(x _{i})]+\Omega(f _{t})$$ æœ‰äº†ä¸Šè¿°é€šç”¨çš„å½¢å¼ï¼Œé‚£ä¹ˆå°±å¯ä»¥å®šä¹‰ä»»æ„çš„æŸå¤±å‡½æ•°ï¼Œåªè¦è¯¥æŸå¤±å‡½æ•°æœ‰ä¸€é˜¶å¯¼æ•°å’ŒäºŒé˜¶å¯¼æ•°å³å¯ï¼Œ so convinentã€‚ æ¨¡åž‹çš„å¤æ‚åº¦ this is not the only possible definitionå¯¹äºŽæ¨¡åž‹çš„å¤æ‚åº¦æœ‰å¤šç§å®šä¹‰æ–¹å¼ï¼Œä¸‹é¢çš„è¿™ç§æ˜¯ä¸€ç§å¸¸è§çš„å¹¶ä¸”åœ¨å®žé™…åº”ç”¨ä¸­æ•ˆæžœå¾ˆå¥½çš„ã€‚ $$\Omega(f)=\gamma T+\frac{1}{2} \lambda \sum_{j=1}^{T} w_{j} ^{2}$$ å…¶ä¸­$T$ è¡¨ç¤ºnumber of leavesï¼Œ $w$è¡¨ç¤ºL2 norm of leaf scores Simpler model means less overfitting and lower variance. å‡å°‘æ–¹å·®å’Œè¿‡æ‹Ÿåˆ The Structure Score $$\begin{split}obj ^{(t)} \approx \sum _{i=1} ^{n}[g _{i} w _{q(x _{i})}+\frac{1}{2} h _{i} w _{q(x _{i})} ^{2}]+\gamma T+\frac{1}{2} \lambda \sum _{j=1} ^{T} w _{j} ^{2}=\sum _{j=1} ^{T}[(\sum _{i \in I _{j}} g _{i}) w _{j}+\frac{1}{2}(\sum _{i \in I _{j}} h _{i}+\lambda) w _{j} ^{2}]+\gamma T\end{split}$$ å…¬å¼å‡ºçŽ° $\approx$ï¼Œ è¿™ä¸ªæ˜¯å› ä¸ºä½¿ç”¨ä¸€é˜¶å¯¼æ•°å’ŒäºŒé˜¶å¯¼æ•°åŽ»è¿‘ä¼¼åœ°ä»£æ›¿åŽŸå§‹çš„å‡½æ•°ï¼Œè¿™ä¸ªåœ¨è®¡ç®—çš„æ—¶å€™æ¯”è¾ƒæ–¹ä¾¿~ã€‚è¿™ä¸ªæ—¶å€™å¯ä»¥çœ‹æˆæ˜¯ä¸€ä¸ªäºŒæ¬¡æ–¹ç¨‹ï¼Œé‚£ä¹ˆå°±å¯ä»¥æ±‚è§£æœ€å€¼äº†ã€‚ å­¦ä¹ æ ‘çš„ç»“æž„ ï¼ˆadditive trainingï¼‰ We can not use methods such as SGD, to find f (since they are trees, instead of just numerical vectors)éœ€è¦ä½¿ç”¨ Additive Training (boosting)ï¼Œ ä»¥æ ‘ä¸ºå•ä½è¿›è¡ŒåŠ æ³•å’Œå‡æ³•ã€‚ $$\text {Gain}=\frac{1}{2}[\frac{G _{L} ^{2}}{H _{L}+\lambda}+\frac{G _{R} ^{2}}{H _{R}+\lambda}-\frac{(G _{L}+G _{R}) ^{2}}{H _{L}+H _{R}+\lambda}]-\gamma$$ è¿™ä¸ªæ—¶å€™ä»¤ $G _{j}=\sum _{i \in I _{j}} g _{i}$ ï¼Œ $H _{j}=\sum _{i \in I _{i}} h _{i}$ï¼Œ æ‰€ä»¥å¯ä»¥åŒ–ç®€æˆä»¥ä¸‹çš„å½¢å¼ï¼š$$\mathrm{obj} ^{(t)}=\sum _{j=1} ^{T}[G _{j} w _{j}+\frac{1}{2}(H _{j}+\lambda) w _{j} ^{2}]+\gamma T$$ äºŒæ¬¡æ–¹ç¨‹æ˜¯å¯ä»¥æ±‚è§£åˆ°æœ€å€¼çš„ï¼Œé‚£ä¹ˆå¯ä»¥å¾—åˆ°ï¼š $$\begin{split}w _{j} ^{} &amp;=-\frac{G _{j}}{H _{j}+\lambda} \\obj ^{} &amp;=-\frac{1}{2} \sum _{j=1} ^{T} \frac{G _{j} ^{2}}{H _{j}+\lambda}+\gamma T\end{split}$$è¿›è¡Œåˆ†è£‚æ—¶çš„ç­–ç•¥ï¼Œ å¦‚æžœåˆ†è£‚çš„å·¦å³å­æ ‘æ˜¯èƒ½å¤Ÿæœ‰ä¿¡æ¯çš„å¢žåŠ ï¼Œé‚£ä¹ˆå°±è¿›è¡Œåˆ†è£‚ï¼Œå¦åˆ™çš„è¯ä¸è¿›è¡Œåˆ†è£‚ï¼Œå¦‚æžœå¼å­å‰åŠéƒ¨å°äºŽ $\gamma$çš„è¯ï¼Œé‚£ä¹ˆå°±è¿›è¡Œå‰ªæžã€‚ $$obj=-\sum _{j} \frac{G _{j} ^{2}}{H _{j}+\lambda}+3 \gamma$$ This score is like the impurity measure in a decision tree, except that it also takes the model complexity into account. å…¶ä¸­ï¼Œæœ€åŽçš„æ•°å€¼è¶Šå°ï¼Œé‚£ä¹ˆç»“æž„ä¹Ÿæ˜¯è¶Šå¥½ã€‚ï¼ˆä»Žè¿™ä¸ªè§’åº¦å‡ºå‘æ˜¯ä¸æ˜¯å’ŒåŸºå°¼ç³»æ•°ç›¸ä¼¼ï¼‰ åˆ†è£‚ç‚¹çš„å¯»æ‰¾ For each node, enumerate over all features for each feature, sorted the instances by feature value use a linear scan to decide the best split along that feature take the best split solution along all the features å¯¹äºŽæ¯ä¸€ä¸ªç»“ç‚¹ï¼Œéƒ½éåŽ†æ‰€æœ‰çš„ç‰¹å¾ å¯¹äºŽæ¯ä¸€ä¸ªç‰¹å¾ï¼Œæ ·æœ¬æŒ‰ç…§ç‰¹å¾çš„å€¼è¿›è¡ŒæŽ’åº ä½¿ç”¨çº¿æ€§æ‰«æçš„æ–¹å¼ï¼Œå†³å®šæœ€å¥½çš„åˆ†è£‚ç‚¹ åœ¨æ‰€æœ‰çš„ç‰¹å¾ä¸­ï¼ŒæŒ‰ç…§æœ€ä¼˜çš„åˆ†è£‚ç‚¹è¿›è¡Œåˆ†è£‚ æ—¶é—´å¤æ‚åº¦åˆ†æž Time Complexity growing a tree of depth$ K$ It is $O(n d K log n) $: or each level, need $O(n log n) $time to sort, there are $d$ features, and we need to do it for $K$ level This can be further optimized (e.g. use approximation or caching the sorted features) Can scale to very large dataset ï¼ˆ1ï¼‰ Basic Exact Greedy Algorithm æš´åŠ›è§£æ³•å°±æ˜¯exact greedy algorithmã€‚åšæ³•ï¼šåœ¨æ‰€æœ‰å¯èƒ½çš„åˆ†è£‚ç‚¹ä¸ŠéåŽ†æ‰€æœ‰çš„features çš„å€¼ã€‚æ•ˆæžœè™½ç„¶å¥½ï¼Œä½†æ˜¯æ—¶é—´æ•ˆçŽ‡ä¸é«˜ã€‚ï¼ˆ2ï¼‰approximate algorithmexact greedy algorithmçš„ç¼ºç‚¹é™¤äº†æ—¶é—´æˆæœ¬ï¼Œè¿˜æœ‰å†…å­˜ä¸Šæ–¹é¢çš„è€ƒè™‘ã€‚å½“æ•°æ®æ— æ³•ä¸€æ¬¡æ€§è¯»å…¥å†…å­˜ï¼Œé‚£ä¹ˆå°±ä¸èƒ½ä½¿ç”¨ã€‚approximate algorithmï¼š - æ ¹æ®feature çš„åˆ†å¸ƒé€‰æ‹©å€™é€‰åˆ†è£‚ç‚¹ - æ ¹æ®åˆ†è£‚ç‚¹åˆ’åˆ†è¿žç»­æ•°å€¼çš„featureï¼Œåˆ†æˆä¸åŒçš„æ¡¶ - æ ¹æ®æ¡¶find æœ€å¥½çš„ç»“æžœï¼ˆéåŽ†æˆæœ¬å°±å°äº†ï¼‰ sparsity-aware split finding æœ‰ä¸‰ç§æ¥æºï¼š missing values in the data frequent zero entries in the statistics artifacts of feature engineering such as one-hot encoding ç±»åˆ«å˜é‡æ˜¯ç¬¬ä¸‰ç§æƒ…å†µï¼š Actually it is not necessary to handle categorical separately We can encode the categorical variables into numerical vector using one-hot encoding. Allocate a #categorical length vector The vector will be sparse if there are lots of categories, the learning algorithm is preferred to handle sparse data æŠŠç±»åˆ«å˜é‡è¿›è¡Œone-hot è½¬æ¢æˆæ•°å€¼ç±»åž‹ï¼Œé‚£ä¹ˆæœ€åŽå°±å¯ä»¥ä½¿ç”¨æ ‘çš„æ¨¡åž‹è¿›è¡Œè®¡ç®—ï¼›ç®—æ³•æ¯”è¾ƒæ“…é•¿å¤„ç†ç¨€ç–æ•°æ® Shrinkage and Column Subsampling Shrinkage scales newly added weights by a factor Î· after each step of tree boosting. Similar to a learning rate in stochastic optimization, shrinkage reduces the influence of each individual tree and leaves space for future trees to improve the model. Shrinkage çš„æ€æƒ³å’Œ stochastic optimizerä¸­ç±»ä¼¼ï¼Œå‡å¼±äº†å½“å‰çš„ç»“ç‚¹çš„å½±å“åŠ›ï¼Œleave space for future or before trees According to user feedback, using column sub-sampling prevents over-fitting even more so than the traditional row sub-sampling (which is also supported). The usage of column sub-samples also speeds up computations of the parallel algorithm described later. å¯¹äºŽè¡Œï¼ˆæ•°æ®çš„æ•°é‡ï¼‰é‡‡æ ·çš„æ€æƒ³æ—©å°±æœ‰äº†ï¼Œxgboost ä¸­å®žçŽ°äº†åˆ—é‡‡æ ·ï¼Œä¸ä»…æœ‰åˆ©äºŽåŠ å¿«è®¡ç®—é€Ÿåº¦ï¼ˆå¹¶è¡Œï¼‰ï¼Œä¹Ÿå¯ä»¥ç¼“è§£è¿‡æ‹Ÿåˆï¼ˆthe idea from random forestï¼‰ å­¦ä¹ çš„è¿‡ç¨‹ åœ¨ç›‘ç£å­¦ä¹ ä¸­ï¼Œä¸æ–­å‡åŽ» $\frac{\partial f(x)}{\partial x}$ï¼Œ å¯ä»¥å¾—åˆ° $min_xf(x)$ã€‚åŒç†ä¸æ–­å‡åŽ» $\frac{\partial l}{\partial F}$ï¼Œè¿™æ ·å°±å¾—åˆ°äº† $min_FL(F)$ã€‚åªä¸è¿‡åœ¨å†³ç­–æ ‘ä¸­ä½¿ç”¨çš„æ˜¯ä¸€é˜¶æ¢¯åº¦ï¼Œä½†æ˜¯åœ¨xgboost ä¸­ä½¿ç”¨çš„äºŒé˜¶æ¢¯åº¦ã€‚ ä¼˜åŠ¿å’Œä¸è¶³Advantages Invariant to scale of feature, need less data preprocessing, But it never means we donâ€™t need to clean and transform features ä¸éœ€è¦è¿›è¡Œå‡å‡å€¼é™¤æ–¹å·®çš„æ“ä½œï¼Œä½†æ˜¯åŸºæœ¬çš„æ•°æ®æ¸…æ´—è¿˜æ˜¯è¦æœ‰çš„ Naturally support categorical featureè‡ªåŠ¨å¤„ç†ç±»åˆ«ç‰¹å¾ï¼Œä¸éœ€è¦æ‰‹åŠ¨one-hot Disadvantages Overfittingè¿‡æ‹Ÿåˆ ç–‘é—®ï¼Ÿå›¾ä¸­å¶å­èŠ‚ç‚¹ä¸Šçš„æ•°å€¼æ˜¯å¦‚ä½•å¾—åˆ°ï¼Œæœ‰ä»€ä¹ˆè®¡ç®—æ–¹æ³•å—ï¼Ÿ å‚è€ƒæ–‡çŒ®Introduction to Boosted TreesXGBoost: A Scalable Tree Boosting System xgboost +lræ¨¡åž‹ç®€å•åœ°è¯´ï¼Œå°±æ˜¯æŠŠgbdtçš„è¾“å‡ºï¼Œä½œä¸ºlogistic regressionçš„è¾“å…¥ï¼Œæœ€åŽå¾—åˆ°ä¸€ä¸ªlogistic regressionæ¨¡åž‹ã€‚ ä¾‹å¦‚ï¼Œgbdté‡Œæœ‰3æ£µæ ‘T1,T2,T3ï¼Œæ¯æ£µæ ‘çš„å¶èŠ‚ç‚¹ä¸ªæ•°ä¸º4ï¼Œç¬¬iä¸ªæ ‘çš„ç¬¬jä¸ªå¶èŠ‚ç‚¹æ˜¯Li,jã€‚ å½“gdbtè®­ç»ƒå®Œæˆä¹‹åŽï¼Œæ ·æœ¬X1åœ¨ç¬¬ä¸€æ£µæ ‘ä¸­è¢«åˆ†åˆ°äº†ç¬¬3ä¸ªå¶èŠ‚ç‚¹ä¸Šï¼Œä¹Ÿå°±æ˜¯L1,3ï¼Œé‚£ä¹ˆè¿™ä¸ªæ ·æœ¬åœ¨T1ä¸Šçš„å‘é‡è¡¨è¾¾ä¸º(0,0,1,0)ã€‚ æ ·æœ¬X1åœ¨T2è¢«åˆ†åˆ°äº†L2,1ï¼Œé‚£ä¹ˆX1åœ¨T2ä¸Šçš„å‘é‡è¡¨è¾¾ä¸º(1,0,0,0)æ ·æœ¬X1åœ¨T3è¢«åˆ†åˆ°äº†L3,4ï¼Œé‚£ä¹ˆX1åœ¨T3ä¸Šçš„å‘é‡è¡¨è¾¾ä¸º(0,0,0,1)é‚£ä¹ˆX1åœ¨æ•´ä¸ªgbdtä¸Šçš„å‘é‡è¡¨è¾¾ä¸º (0,0,1,0,1,0,0,0,0,0,0,1)æ‰€ä»¥æ¯ä¸ªæ ·æœ¬éƒ½ä¼šè¢«è¡¨ç¤ºä¸ºä¸€ä¸ªé•¿åº¦ä¸º12çš„0-1å‘é‡ï¼Œå…¶ä¸­æœ‰3ä¸ªæ•°å€¼æ˜¯1ã€‚ ç„¶åŽè¿™ç±»å‘é‡å°±æ˜¯LRæ¨¡åž‹çš„è¾“å…¥æ•°æ®ã€‚ GBDT + LR æ˜¯ä»€ä¹ˆæœ¬è´¨ä¸ŠGBDT+LRæ˜¯ä¸€ç§å…·æœ‰stackingæ€æƒ³çš„äºŒåˆ†ç±»å™¨æ¨¡åž‹ï¼Œæ‰€ä»¥å¯ä»¥ç”¨æ¥è§£å†³äºŒåˆ†ç±»é—®é¢˜ã€‚è¿™ä¸ªæ–¹æ³•å‡ºè‡ªäºŽFacebook 2014å¹´çš„è®ºæ–‡ Practical Lessons from Predicting Clicks on Ads at Facebook ã€‚ GBDT+LR ä½¿ç”¨æœ€å¹¿æ³›çš„åœºæ™¯æ˜¯CTRç‚¹å‡»çŽ‡é¢„ä¼°ï¼Œå³é¢„æµ‹å½“ç»™ç”¨æˆ·æŽ¨é€çš„å¹¿å‘Šä¼šä¸ä¼šè¢«ç”¨æˆ·ç‚¹å‡»ã€‚ ç¦»çº¿éƒ¨åˆ† æ•°æ®æ”¶é›†ï¼šä¸»è¦æ”¶é›†å’Œä¸šåŠ¡ç›¸å…³çš„æ•°æ®ï¼Œé€šå¸¸ä¼šæœ‰ä¸“é—¨çš„åŒäº‹åœ¨appä½ç½®è¿›è¡ŒåŸ‹ç‚¹ï¼Œæ‹¿åˆ°ä¸šåŠ¡æ•°æ® é¢„å¤„ç†ï¼šå¯¹åŸ‹ç‚¹æ‹¿åˆ°çš„ä¸šåŠ¡æ•°æ®è¿›è¡ŒåŽ»è„åŽ»é‡ï¼› æž„é€ æ•°æ®é›†ï¼šç»è¿‡é¢„å¤„ç†çš„ä¸šåŠ¡æ•°æ®ï¼Œæž„é€ æ•°æ®é›†ï¼Œåœ¨åˆ‡åˆ†è®­ç»ƒã€æµ‹è¯•ã€éªŒè¯é›†æ—¶åº”è¯¥åˆç†æ ¹æ®ä¸šåŠ¡é€»è¾‘æ¥è¿›è¡Œåˆ‡åˆ†ï¼› ç‰¹å¾å·¥ç¨‹ï¼šå¯¹åŽŸå§‹æ•°æ®è¿›è¡ŒåŸºæœ¬çš„ç‰¹å¾å¤„ç†ï¼ŒåŒ…æ‹¬åŽ»é™¤ç›¸å…³æ€§å¤§çš„ç‰¹å¾ï¼Œç¦»æ•£å˜é‡one-hotï¼Œè¿žç»­ç‰¹å¾ç¦»æ•£åŒ–ç­‰ç­‰; æ¨¡åž‹é€‰æ‹©ï¼šé€‰æ‹©åˆç†çš„æœºå™¨å­¦ä¹ æ¨¡åž‹æ¥å®Œæˆç›¸åº”å·¥ä½œï¼ŒåŽŸåˆ™æ˜¯å…ˆä»Žç®€å…¥æ·±ï¼Œå…ˆæ‰¾åˆ°baselineï¼Œç„¶åŽé€æ­¥ä¼˜åŒ–ï¼› è¶…å‚é€‰æ‹©ï¼šåˆ©ç”¨gridsearchã€randomsearchæˆ–è€…hyperoptæ¥è¿›è¡Œè¶…å‚é€‰æ‹©ï¼Œé€‰æ‹©åœ¨ç¦»çº¿æ•°æ®é›†ä¸­æ€§èƒ½æœ€å¥½çš„è¶…å‚ç»„åˆï¼› åœ¨çº¿A/B Testï¼šé€‰æ‹©ä¼˜åŒ–è¿‡åŽçš„æ¨¡åž‹å’ŒåŽŸå…ˆæ¨¡åž‹ï¼ˆå¦‚baselineï¼‰è¿›è¡ŒA/B Testï¼Œè‹¥æ€§èƒ½æœ‰æå‡åˆ™æ›¿æ¢åŽŸå…ˆæ¨¡åž‹ï¼› åœ¨çº¿éƒ¨åˆ† Cache &amp; Logicï¼šè®¾å®šç®€å•è¿‡æ»¤è§„åˆ™ï¼Œè¿‡æ»¤å¼‚å¸¸æ•°æ®ï¼› æ¨¡åž‹æ›´æ–°ï¼šå½“Cache &amp; Logic æ”¶é›†åˆ°åˆé€‚å¤§å°æ•°æ®æ—¶ï¼Œå¯¹æ¨¡åž‹è¿›è¡Œpretrain+finetuningï¼Œè‹¥åœ¨æµ‹è¯•é›†ä¸Šæ¯”åŽŸå§‹æ¨¡åž‹æ€§èƒ½é«˜ï¼Œåˆ™æ›´æ–°model serverçš„æ¨¡åž‹å‚æ•°ï¼› Model Serverï¼šæŽ¥å—æ•°æ®è¯·æ±‚ï¼Œè¿”å›žé¢„æµ‹ç»“æžœï¼› è¿™ä¸ªå¯ä»¥å‚è€ƒ GBDT+LRç®—æ³•è§£æžåŠPythonå®žçŽ° è¿‡ç¨‹ ç”¨å·²æœ‰ç‰¹å¾è®­ç»ƒ GBDT æ¨¡åž‹ï¼Œç„¶åŽåˆ©ç”¨ GBDT æ¨¡åž‹å­¦ä¹ åˆ°çš„æ ‘æ¥æž„é€ æ–°ç‰¹å¾ï¼Œæœ€åŽæŠŠè¿™äº›æ–°ç‰¹å¾åŠ å…¥åŽŸæœ‰ç‰¹å¾ä¸€èµ·è®­ç»ƒæ¨¡åž‹ã€‚æž„é€ çš„æ–°ç‰¹å¾å‘é‡æ˜¯å–å€¼ 0/1 çš„ï¼Œå‘é‡çš„æ¯ä¸ªå…ƒç´ å¯¹åº”äºŽ GBDT æ¨¡åž‹ä¸­æ ‘çš„å¶å­ç»“ç‚¹ã€‚å½“ä¸€ä¸ªæ ·æœ¬ç‚¹é€šè¿‡æŸæ£µæ ‘æœ€ç»ˆè½åœ¨è¿™æ£µæ ‘çš„ä¸€ä¸ªå¶å­ç»“ç‚¹ä¸Šï¼Œé‚£ä¹ˆåœ¨æ–°ç‰¹å¾å‘é‡ä¸­è¿™ä¸ªå¶å­ç»“ç‚¹å¯¹åº”çš„å…ƒç´ å€¼ä¸º 1ï¼Œè€Œè¿™æ£µæ ‘çš„å…¶ä»–å¶å­ç»“ç‚¹å¯¹åº”çš„å…ƒç´ å€¼ä¸º 0ã€‚æ–°ç‰¹å¾å‘é‡çš„é•¿åº¦ç­‰äºŽ GBDT æ¨¡åž‹é‡Œæ‰€æœ‰æ ‘åŒ…å«çš„å¶å­ç»“ç‚¹æ•°ä¹‹å’Œã€‚ XGBoost + LR èžåˆæ–¹å¼åŽŸç†å¾ˆç®€å•ã€‚å…ˆç”¨æ•°æ®è®­ç»ƒä¸€ä¸ª XGBoost æ¨¡åž‹ï¼Œç„¶åŽå°†è®­ç»ƒæ•°æ®ä¸­çš„å®žä¾‹ç»™ XGBoost æ¨¡åž‹å¾—åˆ°å®žä¾‹çš„å¶å­èŠ‚ç‚¹ï¼Œç„¶åŽå°†å¶å­èŠ‚ç‚¹å½“åšç‰¹å¾è®­ç»ƒä¸€ä¸ª LR æ¨¡åž‹ã€‚å¾—åˆ°çš„æ˜¯ä¸€ç§ transformer ä¹‹åŽçš„ç‰¹å¾ï¼Œä¸èƒ½å®Œå…¨å–ä»£ä¹‹å‰çš„ç‰¹å¾å·¥ç¨‹ã€‚ æ­¤è¿‡ç¨‹éœ€æ³¨æ„ï¼š sklearn æˆ–è€… xgboost è¾“å‡ºçš„ç»“æžœéƒ½æ˜¯å¶å­èŠ‚ç‚¹çš„ indexï¼Œæ‰€ä»¥éœ€è¦è‡ªå·±åŠ¨æ‰‹åŽ»åš onehot ç¼–ç ï¼Œç„¶åŽäº¤ç»™ lr è®­ç»ƒï¼Œonehot å¯ä»¥åœ¨ sklearn çš„é¢„å¤„ç†åŒ…ä¸­è°ƒç”¨å³å¯ã€‚ä¸‹é¢è¿›å…¥æ­£é¢˜ã€‚ è®ºæ–‡ä¸­ GBDT çš„å‚æ•°ï¼Œæ ‘çš„æ•°é‡æœ€å¤š 500 é¢—ï¼ˆ500 ä»¥ä¸Šå°±æ²¡æœ‰æå‡äº†ï¼‰ï¼Œæ¯æ£µæ ‘çš„èŠ‚ç‚¹ä¸å¤šäºŽ 12ã€‚ å½“æ ‘çš„é¢—æ•°å¢žå¤§æ—¶ï¼Œå¶å­ç»“ç‚¹æ•°ä¹Ÿç›¸åº”æˆå€æ•°çš„å¢žåŠ ï¼Œé€ æˆlræ¨¡åž‹è®­ç»ƒæ—¶é—´æ‹‰é•¿ï¼ŒåŒæ—¶ä¹Ÿéœ€è¦æ›´å¤§çš„æƒ©ç½šé¡¹æ¥é€‚åº”ï¼› ç»“è®ºï¼šå½“xgbè®­ç»ƒå……åˆ†æ—¶ï¼Œlrç›´æŽ¥åˆ©ç”¨xgbå¶å­ç»“ç‚¹çš„ç¼–ç ç‰¹å¾åœ¨åˆé€‚çš„æƒ©ç½šç³»æ•°ä¸‹å¯ä»¥è®­ç»ƒå¾—åˆ°å’Œxgbä¸€æ ·çš„ç”šè‡³æ›´å¥½çš„æ•ˆæžœï¼ˆä¸æ˜¾è‘—ï¼‰ï¼› é¡ºä¾¿æ¥è®²ï¼ŒRFä¹Ÿæ˜¯å¤šæ£µæ ‘ï¼Œä½†ä»Žæ•ˆæžœä¸Šæœ‰å®žè·µè¯æ˜Žä¸å¦‚GBDTã€‚ä¸”GBDTå‰é¢çš„æ ‘ï¼Œç‰¹å¾åˆ†è£‚ä¸»è¦ä½“çŽ°å¯¹å¤šæ•°æ ·æœ¬æœ‰åŒºåˆ†åº¦çš„ç‰¹å¾ï¼›åŽé¢çš„æ ‘ï¼Œä¸»è¦ä½“çŽ°çš„æ˜¯ç»è¿‡å‰Né¢—æ ‘ï¼Œæ®‹å·®ä»ç„¶è¾ƒå¤§çš„å°‘æ•°æ ·æœ¬ã€‚ä¼˜å…ˆé€‰ç”¨åœ¨æ•´ä½“ä¸Šæœ‰åŒºåˆ†åº¦çš„ç‰¹å¾ï¼Œå†é€‰ç”¨é’ˆå¯¹å°‘æ•°æ ·æœ¬æœ‰åŒºåˆ†åº¦çš„ç‰¹å¾ï¼Œæ€è·¯æ›´åŠ åˆç†ï¼Œè¿™åº”è¯¥ä¹Ÿæ˜¯ç”¨GBDTçš„åŽŸå› ã€‚ çŽ°åœ¨ï¼Œæˆ‘ä»¬æ€è€ƒè¿™æ ·ä¸€ä¸ªé—®é¢˜ï¼ŒLogistic Regressionæ˜¯ä¸€ä¸ªçº¿æ€§åˆ†ç±»å™¨ï¼Œä¹Ÿå°±æ˜¯è¯´ä¼šå¿½ç•¥æŽ‰ç‰¹å¾ä¸Žç‰¹å¾ä¹‹é—´çš„å…³è”ä¿¡æ¯ï¼Œé‚£ä¹ˆæ˜¯å¦å¯ä»¥é‡‡ç”¨æž„å»ºæ–°çš„äº¤å‰ç‰¹å¾è¿™ä¸€ç‰¹å¾ç»„åˆæ–¹å¼ä»Žè€Œæé«˜æ¨¡åž‹çš„æ•ˆæžœï¼Ÿ å…¶æ¬¡ï¼Œæˆ‘ä»¬å·²ç»åœ¨2.3å°èŠ‚ä¸­äº†è§£åˆ°GBDTå¾ˆæœ‰å¯èƒ½æž„é€ å‡ºçš„æ–°è®­ç»ƒæ•°æ®æ˜¯é«˜ç»´çš„ç¨€ç–çŸ©é˜µï¼Œè€ŒLogistic Regressionä½¿ç”¨é«˜ç»´ç¨€ç–çŸ©é˜µè¿›è¡Œè®­ç»ƒï¼Œä¼šç›´æŽ¥å¯¼è‡´è®¡ç®—é‡è¿‡å¤§ï¼Œç‰¹å¾æƒå€¼æ›´æ–°ç¼“æ…¢çš„é—®é¢˜ã€‚ é’ˆå¯¹ä¸Šé¢å¯èƒ½å‡ºçŽ°çš„é—®é¢˜ï¼Œå¯ä»¥ç¿»çœ‹æˆ‘ä¹‹å‰çš„æ–‡ç« ï¼šFMç®—æ³•è§£æžåŠPythonå®žçŽ° ï¼Œä½¿ç”¨FMç®—æ³•ä»£æ›¿LRï¼Œè¿™æ ·å°±è§£å†³äº†Logistic Regressionçš„æ¨¡åž‹è¡¨è¾¾æ•ˆæžœåŠé«˜ç»´ç¨€ç–çŸ©é˜µçš„è®­ç»ƒå¼€é”€è¾ƒå¤§çš„é—®é¢˜ã€‚ç„¶è€Œï¼Œè¿™æ ·å°±æ„å‘³ç€å¯ä»¥é«˜æž•æ— å¿§äº†å—ï¼Ÿå½“ç„¶ä¸æ˜¯ï¼Œå› ä¸ºé‡‡ç”¨FMå¯¹æœ¬æ¥å·²ç»æ˜¯é«˜ç»´ç¨€ç–çŸ©é˜µåšå®Œç‰¹å¾äº¤å‰åŽï¼Œæ–°çš„ç‰¹å¾ç»´åº¦ä¼šæ›´åŠ å¤šï¼Œå¹¶ä¸”ç”±äºŽå…ƒç´ éž0å³1ï¼Œæ–°çš„ç‰¹å¾æ•°æ®å¯èƒ½ä¹Ÿä¼šæ›´åŠ ç¨€ç–ï¼Œé‚£ä¹ˆæ€Žä¹ˆåŠžï¼Ÿ æ‰€ä»¥ï¼Œæˆ‘ä»¬éœ€è¦å†æ¬¡å›žåˆ°GBDTæž„é€ æ–°è®­ç»ƒæ•°æ®è¿™é‡Œã€‚å½“GBDTæž„é€ å®Œæ–°çš„è®­ç»ƒæ ·æœ¬åŽï¼Œæˆ‘ä»¬è¦åšçš„æ˜¯å¯¹æ¯ä¸€ä¸ªç‰¹å¾åšä¸Žè¾“å‡ºä¹‹é—´çš„ç‰¹å¾é‡è¦åº¦è¯„ä¼°å¹¶ç­›é€‰å‡ºé‡è¦ç¨‹åº¦è¾ƒé«˜çš„éƒ¨åˆ†ç‰¹å¾ï¼Œè¿™æ ·ï¼ŒGBDTæž„é€ çš„é«˜ç»´çš„ç¨€ç–çŸ©é˜µå°±ä¼šå‡å°‘ä¸€éƒ¨åˆ†ç‰¹å¾ï¼Œä¹Ÿå°±æ˜¯è¯´å¾—åˆ°çš„ç¨€ç–çŸ©é˜µä¸å†é‚£ä¹ˆé«˜ç»´äº†ã€‚ä¹‹åŽï¼Œå¯¹è¿™äº›ç­›é€‰åŽå¾—åˆ°çš„é‡è¦åº¦è¾ƒé«˜çš„ç‰¹å¾å†åšFMç®—æ³•æž„é€ äº¤å‰é¡¹ï¼Œè¿›è€Œå¼•å…¥éžçº¿æ€§ç‰¹å¾ï¼Œç»§è€Œå®Œæˆæœ€ç»ˆåˆ†ç±»å™¨çš„è®­ç»ƒæ•°æ®çš„æž„é€ åŠæ¨¡åž‹çš„è®­ç»ƒã€‚ å…¶ä»– ä»‹ç»GBDT ä¸­é˜²æ­¢è¿‡æ‹Ÿåˆçš„æ–¹æ³•ï¼š é™åˆ¶æ ‘çš„é«˜åº¦ é‡‡æ ·ï¼ˆè®­ç»ƒæ¯ä¸€æ£µæ ‘çš„æ—¶å€™ï¼Œåªä½¿ç”¨ä¸€éƒ¨åˆ†æ ·æœ¬ï¼‰ åˆ—é‡‡æ ·ï¼ˆè®­ç»ƒæ¯ä¸€ä¸ªæ ‘çš„æ—¶å€™ï¼Œåªä½¿ç”¨ä¸€éƒ¨åˆ†ç‰¹å¾ã€‚è¿™æ˜¯xgboost ä¸­çš„åˆ›æ–°ï¼Œå°†éšæœºæ£®æž—çš„æ€æƒ³å¼•å…¥äº†GBDT ä¸­ï¼‰ shrinkageï¼ˆè¡°å‡ç¨€ç–ï¼Œæƒ©ç½šç³»æ•°ï¼‰ early stopï¼ˆåœ¨æ·±åº¦å­¦ä¹ ä¸­ï¼Œearly stop çš„æŒ‡æ ‡æ˜¯æ ¹æ®æŸä¸ªæŒ‡æ ‡ï¼Œä½†æ˜¯åœ¨æ ‘çš„æ¨¡åž‹ä¸­ï¼Œearly stopæ˜¯æ ¹æ®è¦ä¸è¦åŠ ä¸ŠæŸä¸ªæ ‘ï¼Œæ³¨æ„æ•ˆæžœçš„ç±»æ¯”ï¼‰ å¯å‘å¼å­¦ä¹  å¯å‘å¼ç®—æ³•ï¼ˆheuristic algorithm)æ˜¯ç›¸å¯¹äºŽæœ€ä¼˜åŒ–ç®—æ³•æå‡ºçš„ã€‚å¯å‘å¼ç®—æ³•å¯ä»¥è¿™æ ·å®šä¹‰ï¼šä¸€ä¸ªåŸºäºŽç›´è§‚æˆ–ç»éªŒæž„é€ çš„ç®—æ³•ï¼Œåœ¨å¯æŽ¥å—çš„èŠ±è´¹ï¼ˆæŒ‡è®¡ç®—æ—¶é—´å’Œç©ºé—´ï¼‰ä¸‹ç»™å‡ºå¾…è§£å†³ç»„åˆä¼˜åŒ–é—®é¢˜æ¯ä¸€ä¸ªå®žä¾‹çš„ä¸€ä¸ªå¯è¡Œè§£ï¼Œè¯¥å¯è¡Œè§£ä¸Žæœ€ä¼˜è§£çš„åç¦»ç¨‹åº¦ä¸€èˆ¬ä¸èƒ½è¢«é¢„è®¡ã€‚çŽ°é˜¶æ®µï¼Œå¯å‘å¼ç®—æ³•ä»¥ä»¿è‡ªç„¶ä½“ç®—æ³•ä¸ºä¸»ï¼Œä¸»è¦æœ‰èšç¾¤ç®—æ³•ã€æ¨¡æ‹Ÿé€€ç«æ³•ã€ç¥žç»ç½‘ç»œç­‰ã€‚ å›¾è§£å¸¸è§çš„é›†æˆå­¦ä¹  bagging çš„ç‰¹ç‚¹ï¼š Weak learners are independent. Bagging can be easily parallelized. adaboostçš„ç‰¹ç‚¹ï¼š Guarantee: sum of unnormalized weights is monotonously decreasing. Sum of unnormalized weights measures the error. é€šè¿‡é‡é‡‡æ ·ï¼Œé‡æ–°åˆ†é…æƒé‡æ¥å¤„ç†bad æ ·æœ¬ã€‚ï¼ˆè¿™ç‚¹ä¸æ˜¯å¾ˆç†è§£å“ˆï¼Ÿï¼‰ Gradient Boosting çš„ç‰¹ç‚¹ï¼š [img]https://upload.cc/i1/2019/11/21/EVuaCp.png[/img] Guarantee: sum of residuals is monotonously decreasing. Residuals are highly related to loss. é€šè¿‡å‡å°‘æ®‹å·®çš„æ–¹å¼å‡å°‘è¯¯å·®ã€‚]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>xgbooståŽŸç†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç­‰æ¦‚çŽ‡ç”Ÿæˆå™¨]]></title>
    <url>%2F2018%2F05%2F28%2F%E7%AD%89%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[rand3() -&gt; rand7() ç»™å®šä¸€ä¸ªå¯ä»¥ç­‰æ¦‚çŽ‡ç”Ÿæˆ1-3çš„rand3()å‡½æ•°ç”Ÿæˆå™¨ï¼Œæ±‚è§£å¯ä»¥éšæœºç­‰æ¦‚çŽ‡ç”Ÿæˆ1-7çš„rand7()å‡½æ•°ç”Ÿæˆå™¨ã€‚ ä½¿ç”¨å¤šä¸ª rand3()ï¼Œä¿è¯äº§ç”Ÿçš„å€¼åŸŸæ˜¯å¤§äºŽåŽè€…çš„ï¼Œç„¶åŽå†äº§ç”Ÿçš„å€¼åŸŸä¸Šè¿›è¡Œè£å‰ªå–å°¾ã€‚ 3 6 9 1 4 7 10 2 5 8 11 3 6 9 12 è½¬æˆè¿™ç§æ ·å­ï¼š 3 6 9 1 1 4 7 2 2 5 8 3 3 6 9 ä»Žä»¥ä¸Šçš„ä¸¤ä¸ªä¾‹å­ä¸­ï¼Œè¿™ç§éšæœºæ•°çš„å¥—è·¯åº”è¯¥æ˜¯æŽŒæ¡äº†å§ã€‚å¦‚æžœæ˜¯ randx() é‚£ä¹ˆè¿™ä¸ªç”Ÿæˆå¼å­ å°±æ˜¯ randx() + randx() *x è¿™ä¸ªä¹˜æ•°å¿…é¡»æ˜¯ x ï¼Œè¦ä¸ç„¶å°±é‡å¤ç”Ÿæˆäº†ä¸€ä¸ªæ•°å­—ï¼Œé‚£ä¹ˆæœ€åŽå°±æ²¡æœ‰åŠžæ³•è¾¾åˆ°ç­‰æ¦‚çŽ‡ï¼Œè‡³äºŽæœ€åŽçš„å‡åŽ»çš„æ•°å­—åˆ™æ˜¯æ ¹æ®å®žé™…æƒ…å†µé€‰æ‹©ã€‚ä¸€å®šè¦ç”Ÿæˆè¿žç»­ä¸é‡å¤çš„æ•°å­—ï¼Œè¿™æ ·æ‰èƒ½æ˜¯ç­‰æ¦‚çŽ‡çš„ã€‚ å‡åŽ»çš„æ•°å­—ä¿è¯äº†å–ä½™èƒ½å¤Ÿæ•´é™¤çš„ã€‚ 123456789def rand3_to_rand7(): value =0 for i in range(1,4): for j in range(1, 4): value =i + j*3 -3 if value &gt;7: return return value% 7 rand2() -&gt; rand5()Given rand2(), you should get rand5() å¦‚æžœåªæ˜¯ä½¿ç”¨ä¸¤ä¸ª rand2() é‚£ä¹ˆåªèƒ½å¾—åˆ°å››ç§å¯èƒ½æ€§ï¼Œä¸è¶³ä»¥ç”Ÿæˆ rand5() ï¼Œæ‰€ä»¥è¦ä½¿ç”¨3 ä¸ªrand2() ï¼Œè¿™ä¸ªæ—¶å€™å¾—åˆ°äº† 8ç§å¯èƒ½æ€§ï¼Œå‡åŽ»3 ç§ï¼Œé‚£ä¹ˆå°±OK äº†ã€‚( ä»Žè¿™ä¸ªä¾‹é¢˜ä¸­å¯ä»¥å¾—åˆ°æ˜¯ä½¿ç”¨å¤šä¸ª randx() çš„å€æ•°æ˜¯ x) 12345int rand7() &#123; int x = rand2() * 4 + rand2() * 2 + rand2(); if (x == 7) return rand7(); // restart else return x;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[æœºå™¨å­¦ä¹ æ¦‚å¿µ]]></title>
    <url>%2F2018%2F05%2F28%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[è§£é‡Šä¸€äº›æœºå™¨å­¦ä¹ ä¸­å°çš„åŸºæœ¬çš„æ¦‚å¿µã€‚æ¢¯åº¦ä¸‹é™ã€ç‰›é¡¿æ³•ã€å‡¸å‡½æ•° æ¢¯åº¦ä¸‹é™æ‰¹é‡æ¢¯åº¦ä¸‹é™æ³•æ˜¯æœ€åŽŸå§‹çš„å½¢å¼ï¼Œå®ƒæ˜¯æŒ‡åœ¨æ¯ä¸€æ¬¡è¿­ä»£æ—¶ä½¿ç”¨æ‰€æœ‰æ ·æœ¬æ¥è¿›è¡Œæ¢¯åº¦çš„æ›´æ–°ã€‚ ä¼˜ç‚¹ï¼š ï¼ˆ1ï¼‰ä¸€æ¬¡è¿­ä»£æ˜¯å¯¹æ‰€æœ‰æ ·æœ¬è¿›è¡Œè®¡ç®—ï¼Œæ­¤æ—¶åˆ©ç”¨çŸ©é˜µè¿›è¡Œæ“ä½œï¼Œå®žçŽ°äº†å¹¶è¡Œã€‚ ï¼ˆ2ï¼‰ç”±å…¨æ•°æ®é›†ç¡®å®šçš„æ–¹å‘èƒ½å¤Ÿæ›´å¥½åœ°ä»£è¡¨æ ·æœ¬æ€»ä½“ï¼Œä»Žè€Œæ›´å‡†ç¡®åœ°æœå‘æžå€¼æ‰€åœ¨çš„æ–¹å‘ã€‚å½“ç›®æ ‡å‡½æ•°ä¸ºå‡¸å‡½æ•°æ—¶ï¼ŒBGDä¸€å®šèƒ½å¤Ÿå¾—åˆ°å…¨å±€æœ€ä¼˜ã€‚ç¼ºç‚¹ï¼š ï¼ˆ1ï¼‰å½“æ ·æœ¬æ•°ç›® m å¾ˆå¤§æ—¶ï¼Œæ¯è¿­ä»£ä¸€æ­¥éƒ½éœ€è¦å¯¹æ‰€æœ‰æ ·æœ¬è®¡ç®—ï¼Œè®­ç»ƒè¿‡ç¨‹ä¼šå¾ˆæ…¢ã€‚ éšæœºæ¢¯åº¦ä¸‹é™ï¼ˆStochastic Gradient Descentï¼ŒSGDï¼‰ éšæœºæ¢¯åº¦ä¸‹é™æ³•ä¸åŒäºŽæ‰¹é‡æ¢¯åº¦ä¸‹é™ï¼Œéšæœºæ¢¯åº¦ä¸‹é™æ˜¯æ¯æ¬¡è¿­ä»£ä½¿ç”¨ä¸€ä¸ªæ ·æœ¬æ¥å¯¹å‚æ•°è¿›è¡Œæ›´æ–°ã€‚ä½¿å¾—è®­ç»ƒé€Ÿåº¦åŠ å¿«ã€‚ è§£é‡Šä¸€ä¸‹ä¸ºä»€ä¹ˆSGDæ”¶æ•›é€Ÿåº¦æ¯”BGDè¦å¿«ï¼Ÿç­”ï¼šè¿™é‡Œæˆ‘ä»¬å‡è®¾æœ‰30Wä¸ªæ ·æœ¬ï¼Œå¯¹äºŽBGDè€Œè¨€ï¼Œæ¯æ¬¡è¿­ä»£éœ€è¦è®¡ç®—30Wä¸ªæ ·æœ¬æ‰èƒ½å¯¹å‚æ•°è¿›è¡Œä¸€æ¬¡æ›´æ–°ï¼Œéœ€è¦æ±‚å¾—æœ€å°å€¼å¯èƒ½éœ€è¦å¤šæ¬¡è¿­ä»£ï¼ˆå‡è®¾è¿™é‡Œæ˜¯10ï¼‰ï¼›è€Œå¯¹äºŽSGDï¼Œæ¯æ¬¡æ›´æ–°å‚æ•°åªéœ€è¦ä¸€ä¸ªæ ·æœ¬ï¼Œå› æ­¤è‹¥ä½¿ç”¨è¿™30Wä¸ªæ ·æœ¬è¿›è¡Œå‚æ•°æ›´æ–°ï¼Œåˆ™å‚æ•°ä¼šè¢«æ›´æ–°ï¼ˆè¿­ä»£ï¼‰30Wæ¬¡ï¼Œè€Œè¿™æœŸé—´ï¼ŒSGDå°±èƒ½ä¿è¯èƒ½å¤Ÿæ”¶æ•›åˆ°ä¸€ä¸ªåˆé€‚çš„æœ€å°å€¼ä¸Šäº†ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨æ”¶æ•›æ—¶ï¼ŒBGDè®¡ç®—äº† 10Ã—30W æ¬¡ï¼Œè€ŒSGDåªè®¡ç®—äº† 1Ã—30W æ¬¡ã€‚ å°æ‰¹é‡æ¢¯åº¦ä¸‹é™ï¼Œæ˜¯å¯¹æ‰¹é‡æ¢¯åº¦ä¸‹é™ä»¥åŠéšæœºæ¢¯åº¦ä¸‹é™çš„ä¸€ä¸ªæŠ˜ä¸­åŠžæ³•ã€‚å…¶æ€æƒ³æ˜¯ï¼šæ¯æ¬¡è¿­ä»£ ä½¿ç”¨ batch_size ä¸ªæ ·æœ¬æ¥å¯¹å‚æ•°è¿›è¡Œæ›´æ–°ã€‚ ä¸Šé¢çš„å›¾å¯ä»¥çœ‹å‡º SGD çš„æœç´¢ç©ºé—´æ˜¯æœ‰ç‚¹ç›²ç›®çš„ï¼Œä½†æ˜¯å¿«ã€‚ éšæœºæ¢¯åº¦ä¸‹é™å’Œæ‰¹é‡æ¢¯åº¦ä¸‹é™æ˜¯ä¸¤ç§è¿­ä»£æ±‚è§£æ€è·¯ æ˜¯åœ¨æ¢¯åº¦ä¸‹é™çš„åŸºç¡€ä¹‹ä¸Šå¢žåŠ äº†æŸä¸€äº›é™åˆ¶æ¥ä½¿å¾—å…¶å¿«é€Ÿè¿ç®—çš„ç›®çš„ã€‚å¼•å…¥éšæœºæ¢¯åº¦ä¸‹é™æ³•ä¸Žmini-batchæ¢¯åº¦ä¸‹é™æ³•æ˜¯ä¸ºäº†åº”å¯¹å¤§æ•°æ®é‡çš„è®¡ç®—è€Œå®žçŽ°ä¸€ç§å¿«é€Ÿçš„æ±‚è§£ã€‚ ç‰›é¡¿æ³• æ¢¯åº¦ä¸‹é™ vs ç‰›é¡¿æ³• æ¢¯åº¦ä¸‹é™ï¼š$$x _ { n + 1 } = x _ { n } - \mu f ^ { \prime } \left( x _ { n } \right)$$ ç‰›é¡¿æ³•é€’æŽ¨å¼ï¼š $$x _ { n + 1 } = x _ { n } - \frac { f ^ { \prime } \left( x _ { n } \right) } { f ^ { \prime \prime } \left( x _ { n } \right) }$$ $$f ( x + \Delta x ) = f ( x ) + f ^ { \prime } ( x ) \Delta x + \frac { 1 } { 2 } f ^ { \prime \prime } ( x ) \Delta x ^ { 2 }$$ å¯¹äºŽ ä¸¤ç§ä¼˜åŒ–æ–¹æ³•çš„å‡ ç§è§£è¯»æ–¹å¼ï¼š wiki ä¸Šçš„è§£é‡Šï¼š ç‰›é¡¿ä¸‹é™æ³•æ˜¯ç”¨äºŒæ¬¡æ›²é¢åŽ»æ‹Ÿåˆå½“å‰çš„å±€éƒ¨æ›²é¢ï¼Œè€Œæ¢¯åº¦ä¸‹é™æ³•æ˜¯ç”¨å¹³é¢åŽ»æ‹Ÿåˆå½“å‰çš„å±€éƒ¨æ›²é¢ï¼Œä¸€èˆ¬ç”¨äºŒæ¬¡æ›²é¢æ‹Ÿåˆçš„æ›´å¥½ï¼Œæ‰€ä»¥ä¸€èˆ¬ç‰›é¡¿ç®—æ³•æ”¶æ•›å¿«ã€‚ çº¢è‰²ä¸ºç‰›é¡¿ä¸‹é™æ³•ï¼Œç»¿è‰²ä¸ºæ¢¯åº¦ä¸‹é™æ³• ç‰›é¡¿æ³•æ˜¯åŸºäºŽå½“å‰ä½ç½®çš„åˆ‡çº¿æ¥ç¡®å®šä¸‹ä¸€æ¬¡çš„ä½ç½®ï¼Œæ‰€ä»¥ç‰›é¡¿æ³•åˆè¢«å¾ˆå½¢è±¡åœ°ç§°ä¸ºæ˜¯â€åˆ‡çº¿æ³•â€ã€‚ç‰›é¡¿æ³•çš„æœç´¢è·¯å¾„ï¼ˆäºŒç»´æƒ…å†µï¼‰å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ç‰›é¡¿æ³•æœç´¢åŠ¨æ€ç¤ºä¾‹å›¾ æ•°å­¦è§’åº¦ ä½¿ç”¨å¹³é¢åŽ»æ‹Ÿåˆä½¿ç”¨æ³°å‹’å±•å¼€å¼è¿›è¡Œè§£é‡Šï¼š$$f ( x + \Delta x ) = f ( x ) + f ^ { \prime } ( x ) * \Delta x$$ ä½¿ç”¨æ›²é¢åŽ»æ‹Ÿåˆ$$f ( x + \Delta x ) = f ( x ) + f ^ { \prime } ( x ) \Delta x + \frac { 1 } { 2 } f ^ { \prime \prime } ( x ) \Delta x ^ { 2 }$$å¯¹ä¸¤è¾¹ $\Delta x$è¿›è¡Œæ±‚å¯¼ $$\Delta x = - \frac { f ^ { \prime } ( x ) } { f ^ { \prime \prime } ( x ) }$$è¿›è€Œï¼š $$x _ { n + 1 } = x _ { n } - \frac { f ^ { \prime } \left( x _ { n } \right) } { f ^ { \prime \prime } \left( x _ { n } \right) }$$ ä¼˜ç¼ºç‚¹ï¼š ç‰›é¡¿æ³•èµ·å§‹ç‚¹ä¸èƒ½ç¦»å±€éƒ¨æžå°ç‚¹å¤ªè¿œï¼Œå¦åˆ™å¾ˆå¯èƒ½ä¸ä¼šæ”¶æ•›ã€‚(è€ƒè™‘åˆ°äºŒé˜¶æ‹Ÿåˆåº”è¯¥å¾ˆå®¹æ˜“æƒ³è±¡)ï¼Œæ‰€ä»¥å®žé™…æ“ä½œä¸­ä¼šå…ˆä½¿ç”¨åˆ«çš„æ–¹æ³•ï¼Œæ¯”å¦‚æ¢¯åº¦ä¸‹é™æ³•ï¼Œä½¿æ›´æ–°çš„ç‚¹ç¦»æœ€ä¼˜ç‚¹æ¯”è¾ƒè¿‘ï¼Œå†å¼€å§‹ç”¨ç‰›é¡¿æ³•ã€‚ ç‰›é¡¿æ³•æ¯æ¬¡éœ€è¦æ›´æ–°ä¸€ä¸ªäºŒé˜¶çŸ©é˜µï¼Œå½“ç»´æ•°å¢žåŠ çš„æ—¶å€™æ˜¯éžå¸¸è€—å†…å­˜çš„ï¼Œæ‰€ä»¥å®žé™…ä½¿ç”¨æ˜¯ä¼šç”¨æ‹Ÿç‰›é¡¿æ³•ã€‚ æ¢¯åº¦ä¸‹é™æ³•åœ¨éžå¸¸é è¿‘æœ€ä¼˜ç‚¹æ—¶ä¼šæœ‰éœ‡è¡ï¼Œå°±æ˜¯è¯´æ˜Žæ˜Žç¦»çš„å¾ˆè¿‘äº†ï¼Œå´å¾ˆéš¾åˆ°è¾¾ï¼Œå› ä¸ºçº¿æ€§çš„é€¼è¿‘éžå¸¸å®¹æ˜“ä¸€ä¸ªæ–¹å‘è¿‡åŽ»å°±è¿‡äº†æœ€ä¼˜ç‚¹(å› ä¸ºåªèƒ½æ˜¯è´Ÿæ¢¯åº¦æ–¹å‘)ã€‚ä½†ç‰›é¡¿æ³•å› ä¸ºæ˜¯äºŒæ¬¡æ”¶æ•›å°±å¾ˆå®¹æ˜“åˆ°è¾¾äº†ã€‚ ç‰›é¡¿æ³•æœ€æ˜Žæ˜¾å¿«çš„ç‰¹ç‚¹æ˜¯å¯¹äºŽäºŒé˜¶å‡½æ•°(è€ƒè™‘å¤šå…ƒå‡½æ•°çš„è¯è¦åœ¨å‡¸å‡½æ•°çš„æƒ…å†µä¸‹)ï¼Œç‰›é¡¿æ³•èƒ½å¤Ÿä¸€æ­¥åˆ°è¾¾ï¼Œéžå¸¸æœ‰æ•ˆã€‚ æ‰€ä»¥è¿™ä¸ªç»¼åˆä¸Šé¢ä¸¤ç§æ–¹æ³•ï¼Œä¸€èˆ¬åœ¨å¼€å§‹çš„æ—¶å€™ä½¿ç”¨ æ¢¯åº¦ä¸‹é™ï¼Œç„¶åŽå¿«è¦æŽ¥è¿‘æœ€å€¼ç‚¹ï¼ˆè¿™ä¸ªæ—¶å€™ä½¿ç”¨ æ¢¯åº¦ä¸‹é™å®¹æ˜“å‘ç”Ÿéœ‡è¡ï¼‰ï¼Œä½¿ç”¨ç‰›é¡¿æ³•ï¼Œç‰›é¡¿æ³•æ˜¯éœ€è¦è®¡ç®—äºŒé˜¶æ¢¯åº¦ï¼Œä¸€èˆ¬è®¡ç®—é‡æ¯”è¾ƒå¤§ï¼Œæ‰€ä»¥å¯ä»¥è€ƒè™‘ä½¿ç”¨æ‹Ÿç‰›é¡¿æ³•ã€‚ é›…å…‹æ¯”çŸ©é˜µå’Œæµ·æ£®çŸ©é˜µé›…å¯æ¯”çŸ©é˜µç±»ä¼¼äºŽå¤šå…ƒå‡½æ•°çš„å¯¼æ•°. $$H(f){i j}(x)=D{i} D_{j} f(x)$$ å‡¸å‡½æ•°ä¸Šä»»æ„ä¸€ç‚¹å¯¹åº”çš„HessiançŸ©é˜µéƒ½æ˜¯åŠæ­£å®šçš„ã€‚è¯æ˜Žå¯ä»¥çœ‹è¿™é‡Œ å‡¸å‡½æ•°å¯¹äºŽæŸå¤±å‡½æ•°æ— éžæ˜¯å‡¸å‡½æ•°å’Œéžå‡¸å‡½æ•°ã€‚å…¶ä¸­å¯¹å‡¸å‡½æ•°ä¸€èˆ¬æ˜¯å¯ä»¥æ±‚å¾—å…¨å±€æœ€å°å€¼çš„ã€‚å¯¹äºŽéžå‡¸å‡½æ•°æ¥è¯´ï¼Œå…¶å‡½æ•°æ˜¯æŠ–åŠ¨çš„ï¼Œå¯èƒ½å­˜åœ¨å¾ˆå¤šå±€éƒ¨è§£ï¼Œè€Œåœ¨å¯¹è¿™ç±»é—®é¢˜æ±‚è§£æ—¶å¯èƒ½ä¸èƒ½æœ‰æ•ˆåœ°æ‰¾å‡ºå…¶å…¨å±€æœ€å°å€¼ï¼Œ å‡¸ä¼˜åŒ–:å¯¹å‡¸ä¼˜åŒ–çš„é—®é¢˜æˆ‘ä»¬åœ¨åŸºç¡€æ•°å­¦ä¸Šé¢å·²ç»æœ‰äº†å¾ˆå¤šè§£å†³æ–¹æ³•ï¼Œä¾‹å¦‚å¯ä»¥å°†å‡¸ä¼˜åŒ–é—®é¢˜Lagerangeåšå¯¹å¶åŒ–ï¼Œç„¶åŽç”¨Newtonã€æ¢¯åº¦ä¸‹é™ç®—æ³•æ±‚è§£ã€‚ å‡¸å‡½æ•°çš„æ¥æºæ˜¯å’Œå‡¸é›†ç›¸å¯¹åº”çš„ã€‚å‡¸é›†çš„â€œå‡¸â€æ˜¯å¯ä»¥ä»Žå‡ ä½•ä¸Šç›´è§‚ç†è§£çš„ï¼Œè¿žæŽ¥ç‚¹é›†ä¸­çš„ä»»æ„ä¸¤ç‚¹ï¼Œçº¿æ®µä¸Šçš„æ¯ä¸€ç‚¹éƒ½åœ¨è¯¥ç‚¹é›†å†…ï¼Œåˆ™ä¸ºå‡¸é›†ã€‚è¿™æ ·å°±å¯ä»¥ç†è§£ä¸ºç”š $y =x^2$ æ˜¯å‡¸å‡½æ•°ã€‚ å‡¸å‡½æ•°ï¼šJacobiançŸ©é˜µå’ŒHessiançŸ©é˜µï¼šåœ¨å‘é‡åˆ†æžä¸­, é›…å¯æ¯”çŸ©é˜µæ˜¯ä¸€é˜¶åå¯¼æ•°ä»¥ä¸€å®šæ–¹å¼æŽ’åˆ—æˆçš„çŸ©é˜µ, å…¶è¡Œåˆ—å¼ç§°ä¸ºé›…å¯æ¯”è¡Œåˆ—å¼ã€‚ bias and varianceä¸ªäººæ„Ÿè§‰ variance æ›´åƒæ˜¯ä¸€ç§ç¨³å®šæ€§çš„è¯„ä»·ï¼Œé¢„æµ‹ç»“æžœçš„æ³¢åŠ¨æ€§ï¼Œå¦‚æžœvariance å°ï¼Œé‚£ä¹ˆå°±æ˜¯ç¨³å®šæ€§å¥½ã€‚ bias variance tradeoff å®žé™…ä¸Šæ˜¯æœ‰ä¸‰ä¸ªåè¯ bias (åå·®)ï¼Œvariance (æ–¹å·®) and noise (å™ªå£°)ã€‚åå·®æ˜¯é¢„æµ‹å€¼å’Œå®žé™…å€¼çš„å·®å€¼ï¼Œæ˜¯å‡†ä¸å‡†çš„é—®é¢˜ï¼›è€Œæ–¹å·®æ˜¯é¢„æµ‹å€¼çš„å±žæ€§ï¼Œå¦‚æžœæœ€åŽçš„ç»“æžœæ¯”è¾ƒåˆ†æ•£ï¼Œé‚£ä¹ˆæ–¹å·®å°±æ¯”è¾ƒå¤§ã€‚æ‰€ä»¥æ˜¯ä¸¤ä¸ªä¸åŒçš„ç»´åº¦ã€‚æœ€å¥½çš„æ¨¡åž‹å½“ç„¶æ˜¯ä½Žæ–¹å·®å¹¶ä¸”ä½Žåå·®äº†ã€‚ä¸€å›¾èƒœåƒè¨€ å¸¸è§çš„å‡ ç§è¯´æ³•ï¼š å½“ç½‘ç»œç»“æž„æ¯”ä»·ç®€å•çš„æ—¶å€™ï¼Œå®¹æ˜“å‡ºçŽ°é«˜åå·®ï¼Œä¸€èˆ¬æ¥è¯´è¿™ä¸ªæ—¶å€™æ˜¯æ¬ æ‹Ÿåˆ å½“ç½‘ç»œæ¯”è¾ƒå¤æ‚çš„æ—¶å€™ï¼Œå®¹æ˜“å‡ºçŽ°é«˜æ–¹å·®ï¼Œä¸€èˆ¬æ¥è¯´è¿™ä¸ªæ—¶å€™æ˜¯è¿‡æ‹Ÿåˆ å¦‚æžœå‡ºçŽ°äº†è¿‡æ‹Ÿåˆï¼Œä¸€èˆ¬è¯´æ‹Ÿåˆäº†è¿‡å¤šçš„noise (å™ªå£°)ï¼Œæ²¡æœ‰æŠ“ä½é—®é¢˜çš„æœ¬è´¨ã€‚ é—®é¢˜ è§£å†³æ–¹æ¡ˆ é«˜æ–¹å·® é‡‡é›†æ›´å¤šçš„æ ·æœ¬ï¼Œ é™ä½Žç‰¹å¾çš„ç»´åº¦ï¼Œé™ä½Žå‚æ•° é«˜åå·® é‡‡é›†æ›´å¤šçš„ç‰¹å¾ï¼Œå¢žå¤§å‚æ•° åœ¨è®­ç»ƒæ–¹æ³•ä¸Šä¹Ÿæ˜¯å¯ä»¥æ”¹è¿›çš„ï¼Œ æ¯”å¦‚ä½¿ç”¨ K-Fold äº¤å‰éªŒè¯ã€‚ç®€å•çš„è¯´ï¼Œå°±æ˜¯å°†è®­ç»ƒæ ·æœ¬åˆ†æˆkä»½ï¼Œæ¯æ¬¡å–å…¶ä¸­ä¸€ä»½ä½œä¸ºéªŒè¯é›†ï¼Œå¦å¤– k-1 ä»½ä½œè®­ç»ƒé›†ã€‚è¿™æ ·è¿›è¡Œ k æ¬¡è®­ç»ƒå¾—åˆ° k ä¸ªæ¨¡åž‹ã€‚è¿™ k ä¸ªæ¨¡åž‹å¯¹å„è‡ªçš„éªŒè¯é›†è¿›è¡Œé¢„æµ‹ï¼Œå¾—åˆ° k ä¸ªè¯„ä¼°å€¼ï¼ˆå¯ä»¥æ˜¯è¯¯å·®ã€å‡†ç¡®çŽ‡ï¼Œæˆ–æŒ‰æŸç§è§„åˆ™è®¡ç®—çš„å¾—åˆ†ç­‰ç­‰ï¼‰ã€‚æ³¨æ„åˆ°æ¯ä¸ªæ ·æœ¬å‚ä¸Žäº† k-1 ä¸ªæ¨¡åž‹çš„è®­ç»ƒï¼ˆå¯¼è‡´æ¨¡åž‹ä¹‹é—´å­˜åœ¨å…³è”ï¼‰ï¼Œæ¯ä¸ªæ ·æœ¬æœ‰ä¸€æ¬¡è¢«ç”¨ä½œæµ‹è¯•ï¼ˆæ²¡æœ‰ç”¨å¦å¤–çš„ä»Žæœªè§è¿‡çš„æµ‹è¯•é›†æ•°æ®ï¼‰ï¼Œæ‰€ä»¥è¿™ä¸Žæ ‡å‡†çš„è®¡ç®—è¿‡ç¨‹æ˜¯ä¸ä¸€æ ·çš„ã€‚ å½“ Kå€¼æ¯”è¾ƒå¤§çš„æ—¶å€™ï¼Œæ¨¡åž‹å®¹æ˜“è¿‡æ‹Ÿåˆæ•°æ®é›†(K-1 æ•°æ®é›†å æ¯”æ˜¯æŽ¥è¿‘äºŽ1ï¼Œæ‰€ä»¥è®°ä½äº†è®­ç»ƒæ•°æ®é›†)ï¼Œbias æ¯”è¾ƒå°ï¼Œä½†æ˜¯å½“ æµ‹è¯•é›†ä¸Šçš„æ—¶å€™ï¼Œvariance æ¯”è¾ƒå¤§ï¼› åŒç†ï¼Œå½“K å€¼æ ‡èƒ¶å°çš„æ—¶å€™ï¼Œbias æ¯”è¾ƒå¤§ï¼Œæ²¡æœ‰è¿‡æ‹Ÿåˆæ•°æ®ï¼Œå› æ­¤åœ¨ test æ•°æ®é›†ä¸Š bias æ˜¯æ¯”è¾ƒå°çš„ã€‚ åå·®å’Œæ–¹å·®åˆä¸Žã€Œæ¬ æ‹Ÿåˆã€åŠã€Œè¿‡æ‹Ÿåˆã€ç´§ç´§è”ç³»åœ¨ä¸€èµ·ã€‚ç”±äºŽéšæœºè¯¯å·®æ˜¯ä¸å¯æ¶ˆé™¤çš„ï¼Œæ‰€ä»¥æ­¤ç¯‡æˆ‘ä»¬è®¨è®ºåœ¨åå·®å’Œæ–¹å·®ä¹‹é—´çš„æƒè¡¡ï¼ˆBias-Variance Tradeoffï¼‰ã€‚ å½“æ¨¡åž‹å¤„äºŽæ¬ æ‹ŸåˆçŠ¶æ€æ—¶ï¼Œè®­ç»ƒé›†å’ŒéªŒè¯é›†ä¸Šçš„è¯¯å·®éƒ½å¾ˆé«˜ï¼› å½“æ¨¡åž‹å¤„äºŽè¿‡æ‹ŸåˆçŠ¶æ€æ—¶ï¼Œè®­ç»ƒé›†ä¸Šçš„è¯¯å·®ä½Žï¼Œè€ŒéªŒè¯é›†ä¸Šçš„è¯¯å·®ä¼šéžå¸¸é«˜ã€‚ è¿™ä¸¤ä¸ªæ¦‚å¿µå’Œæ¨¡åž‹çš„å¤æ‚åº¦åˆæœ‰ç€å¾ˆæ·±çš„è”ç³»ï¼š bias-variance å’Œ bagging-boostingçš„å…³ç³» æ•°æ®çš„è´¨é‡å†³å®šäº†å­¦ä¹ çš„ä¸Šé™ã€‚è€Œå‡è®¾åœ¨æ•°æ®å·²ç»ç»™å®šçš„æƒ…å†µä¸‹ï¼Œæ­¤æ—¶ä¸Šé™å·²å®šï¼Œæˆ‘ä»¬è¦åšçš„å°±æ˜¯å°½å¯èƒ½çš„æŽ¥è¿‘è¿™ä¸ªä¸Šé™ã€‚è€Œæ¨¡åž‹çš„æœŸæœ›æ³›åŒ–è¯¯å·®ç”±åå·®å’Œæ–¹å·®ç»„æˆã€‚ä¸€èˆ¬æ¥è¯´ï¼Œç®€å•æ¨¡åž‹åå·®é«˜ï¼Œæ–¹å·®ä½Žï¼›å¤æ‚æ¨¡åž‹æ–¹å·®é«˜ï¼Œåå·®ä½Žã€‚ åå·®æè¿°çš„æ˜¯ç®—æ³•çš„é¢„æµ‹çš„å¹³å‡å€¼å’ŒçœŸå®žå€¼çš„å…³ç³»ï¼ˆå¯ä»¥æƒ³è±¡æˆç®—æ³•çš„æ‹Ÿåˆèƒ½åŠ›å¦‚ä½•ï¼‰ï¼Œè€Œæ–¹å·®æè¿°çš„æ˜¯åŒä¸€ä¸ªç®—æ³•åœ¨ä¸åŒæ•°æ®é›†ä¸Šçš„é¢„æµ‹å€¼å’Œæ‰€æœ‰æ•°æ®é›†ä¸Šçš„å¹³å‡é¢„æµ‹å€¼ä¹‹é—´çš„å…³ç³»ï¼ˆå¯ä»¥æƒ³è±¡æˆç®—æ³•çš„ç¨³å®šæ€§å¦‚ä½•ï¼‰ã€‚ ï¼ˆpsï¼šä¸ªäººè®¤ä¸ºå¯ä»¥æŠŠåå·®è®¤ä¸ºæ˜¯å•ä¸ªæ¨¡åž‹çš„å­¦ä¹ èƒ½åŠ›ï¼Œè€Œæ–¹å·®åˆ™æè¿°çš„æ˜¯åŒä¸€ä¸ªå­¦ä¹ ç®—æ³•åœ¨ä¸åŒæ•°æ®é›†çš„ä¸ç¨³å®šæ€§ï¼‰ Baggingå’ŒBoostingæ˜¯é›†æˆå­¦ä¹ å½“ä¸­æ¯”è¾ƒå¸¸ç”¨çš„ä¸¤ç§æ–¹æ³•ï¼Œåˆšå¥½åˆ†åˆ«å¯¹åº”äº†é™ä½Žæ¨¡åž‹æ–¹å·®å’Œåå·®ã€‚ decision + baggingå…¶å®žåšäº†ä¸¤ä¸ªäº‹æƒ…å‡å°‘äº†varianceã€‚ bootstrapï¼›å°±æ˜¯ä»Žtraining dataé‡Œé¢sample with replacementï¼Œç„¶åŽç”Ÿæˆtraining data x Nã€‚ï¼ˆä¾‹å¦‚sample æ˜¯ [1,2,3,4,5,6], bootstrapä¹‹åŽæœ‰äº†ä¸‰ä»½[2,2,3,4,1,6], [1,3,5,6,1,2], [1,2,3,1,2,3]ã€‚ï¼‰bootstrapæ˜¯ä¸ªå¾ˆé‡è¦çš„idea æ•°å­¦ä¸Šæœ‰å¾ˆå¤šè¯æ˜Žè¿™æ ·åšèƒ½æœ‰æ•ˆå‡ä½Žvarianceã€‚ averaging from all the outputã€‚è¿™ä¸ªå¾ˆå¥½ç†è§£ï¼Œåšä¸ªæ€è€ƒå®žéªŒ - ä»Žæ–¹å·®å›ºå®šçš„populationé‡Œå–10 ä¸ªsampleï¼Œå¯¹æ¯”ä¸Žä»ŽåŒä¸€ä¸ªpopulationå–2ä¸ªsample-å–å¹³å‡-é‡å¤10æ¬¡ï¼›ä¸¤ç»„10ä¸ªæ•°å­—çš„varianceçš„æœŸæœ›è‚¯å®šæ˜¯å‰è€…é«˜ã€‚è¡¥å……ä¸€ç‚¹ï¼Œrandom forestå…¶å®žæ˜¯baggingçš„å»¶ä¼¸ã€‚åŠ çš„ideaå°±æ˜¯æ¯æ¬¡build treeçš„æ—¶å€™åªé€‰ä¸€éƒ¨åˆ†çš„attribute - å› ä¸ºdecision treeä¸€èˆ¬å¾ˆå—é‡è¦çš„attributeçš„å½±å“ï¼ˆä¾‹å¦‚æœ‰ä¸ªattributeå’Œresponse/label ç›¸å…³æ€§å¾ˆé«˜ï¼ŒåŸºæœ¬æ¯æ¬¡bootstrapç¬¬ä¸€ä¸ªsplitéƒ½æ˜¯è¿™ä¸ªattributeï¼‰ï¼Œå¯¼è‡´bootstrapå®Œä¹‹åŽvarianceæ²¡æœ‰å‡å°‘ï¼ˆå› ä¸ºæ¯æ¬¡çš„æ ‘éƒ½æ˜¯å¾ˆç›¸ä¼¼çš„ï¼‰- æ‰€ä»¥å¤§å®¶æƒ³removeè¿™ä¸ªattribute in some bootstrap sample Baggingæ˜¯é€šè¿‡é‡é‡‡æ ·çš„æ–¹æ³•æ¥å¾—åˆ°ä¸åŒçš„æ¨¡åž‹ï¼Œå‡è®¾æ¨¡åž‹ç‹¬ç«‹åˆ™æœ‰ï¼š$$E\left(\frac{\sum_{i} \vec{E}\left(X_{i}\right)}{n}\right)=E\left(X_{i}\right)$$$$\operatorname{Var}\left(\frac{\sum_{i} \operatorname{Var}\left(X_{i}\right)}{n}\right)=\frac{1}{n} \operatorname{Var}\left(X_{i}\right)$$æ‰€ä»¥ä»Žè¿™é‡Œæˆ‘ä»¬å¯ä»¥çœ‹å‡ºBaggingä¸»è¦å¯ä»¥é™ä½Žçš„æ˜¯æ–¹å·®ã€‚ baggingæ˜¯å¯¹è®¸å¤šå¼ºï¼ˆç”šè‡³è¿‡å¼ºï¼‰çš„åˆ†ç±»å™¨æ±‚å¹³å‡ã€‚åœ¨è¿™é‡Œï¼Œæ¯ä¸ªå•ç‹¬çš„åˆ†ç±»å™¨çš„biaséƒ½æ˜¯ä½Žçš„ï¼Œå¹³å‡ä¹‹åŽbiasä¾ç„¶ä½Žï¼›è€Œæ¯ä¸ªå•ç‹¬çš„åˆ†ç±»å™¨éƒ½å¼ºåˆ°å¯èƒ½äº§ç”Ÿoverfittingçš„ç¨‹åº¦ï¼Œä¹Ÿå°±æ˜¯varianceé«˜ï¼Œæ±‚å¹³å‡çš„æ“ä½œèµ·åˆ°çš„ä½œç”¨å°±æ˜¯é™ä½Žè¿™ä¸ªvarianceã€‚ è€ŒBoostingæ¯ä¸€æ¬¡éƒ½å…³æ³¨ä½¿æ•´ä½“çš„losså‡å°‘ï¼Œå¾ˆæ˜¾ç„¶å¯ä»¥é™ä½Žbiasã€‚åŸºäºŽboostingæ¡†æž¶çš„Gradient Tree Boostingæ¨¡åž‹ä¸­åŸºæ¨¡åž‹ä¹Ÿä¸ºæ ‘æ¨¡åž‹ï¼ŒåŒRandom Forrestï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å¯¹ç‰¹å¾è¿›è¡ŒéšæœºæŠ½æ ·æ¥ä½¿åŸºæ¨¡åž‹é—´çš„ç›¸å…³æ€§é™ä½Žï¼Œä»Žè€Œè¾¾åˆ°å‡å°‘æ–¹å·®çš„æ•ˆæžœã€‚ï¼ˆæ¯”å¦‚è¯´xgboost ä¸­çš„sample å‚æ•°ï¼Œæ—¢å¯ä»¥å¯¹æ ·æœ¬æ•°é‡è¿›è¡Œsample ä¹Ÿå¯ä»¥å¯¹ç‰¹å¾è¿›è¡Œsampleï¼‰boosting å¯ä»¥é™ä½Žåå·®åº”è¯¥æ˜¯å¾ˆå¥½ç†è§£çš„ï¼Œå…¶åŽŸç†å°±æ˜¯å°†å¤šä¸ªå¼±å­¦ä¹ å™¨ç»„åˆæˆä¸€ä¸ªå¼ºå­¦ä¹ å™¨ã€‚boostingæ˜¯æŠŠè®¸å¤šå¼±çš„åˆ†ç±»å™¨ç»„åˆæˆä¸€ä¸ªå¼ºçš„åˆ†ç±»å™¨ã€‚å¼±çš„åˆ†ç±»å™¨biasé«˜ï¼Œè€Œå¼ºçš„åˆ†ç±»å™¨biasä½Žï¼Œæ‰€ä»¥è¯´boostingèµ·åˆ°äº†é™ä½Žbiasçš„ä½œç”¨ã€‚varianceä¸æ˜¯boostingçš„ä¸»è¦è€ƒè™‘å› ç´ ã€‚ä¸ºä»€ä¹ˆéšæœºæ£®æž—çš„æ ‘çš„æ·±åº¦å¾€å¾€å¤§äºŽGBDTçš„æ ‘çš„æ·±åº¦ï¼Ÿ æ€»ä¹‹è¦è®°ä½ï¼š biasè·Ÿæ¨¡åž‹æœ‰å…³ï¼Œvarianceè·Ÿæ•°æ®æœ‰å…³ã€‚ ç”Ÿæˆå¼æ¨¡åž‹å’Œåˆ¤åˆ«å¼æ¯”è¾ƒåˆ¤åˆ«å¼æ¨¡åž‹å¯¹ $ P(Y|X) $è¿›è¡Œå»ºæ¨¡,ç›®çš„æ˜¯æ‰¾åˆ°ä¸€ä¸ªå†³ç­–è¾¹ç•Œ,æ ¹æ®è¿™ä¸ªè¾¹ç•Œæ¥ç¡®å®šæ–°æ ·æœ¬çš„ç±»åˆ«.ç”Ÿæˆå¼æ¨¡åž‹å¯¹ $P(X,Y) $è¿›è¡Œå»ºæ¨¡,ç›®çš„æ˜¯æ‰¾åˆ°æ¯ä¸ªç±»åˆ«çš„åˆ†å¸ƒ,æ ¹æ®ç±»åˆ«çš„åˆ†å¸ƒæƒ…å†µç¡®å®šæ–°æ ·æœ¬çš„ç±»åˆ«. å¦‚ä¸Šå›¾æ‰€ç¤º,å½“ä¸€ä¸ªæ–°æ ·æœ¬è¿›æ¥åŽ,å¦‚æžœæ˜¯åˆ¤åˆ«å¼æ¨¡åž‹,ä¼šåˆ¤æ–­å®ƒåœ¨å†³ç­–è¾¹ç•Œçš„å·¦è¾¹è¿˜æ˜¯å³è¾¹,å³è®¡ç®—P(Y_1|X)ä¸ŽP(Y_2|X)æ¥åˆ¤æ–­æ–°æ ·æœ¬æ˜¯è“è‰²è¿˜æ˜¯é»„è‰².å¦‚æžœæ˜¯ç”Ÿæˆå¼æ¨¡åž‹ä¼šæ ¹æ®ä¸¤ä¸ªç±»åˆ«åˆ†å¸ƒåˆ†åˆ«è®¡ç®—å±žäºŽä¸¤ä¸ªç±»åˆ«çš„æ¦‚çŽ‡,å³P(Y_1,X)ä¸ŽP(Y_2,X)æ¥åˆ¤æ–­æ–°æ ·æœ¬æ˜¯è“è‰²è¿˜æ˜¯é»„è‰². ä¸¾ä¾‹å­è¯´æ˜Žå¸¸è§çš„ç®—æ³•ï¼š çº¿æ€§å›žå½’ã€é€»è¾‘å›žå½’ã€ç¥žç»ç½‘ç»œã€æ”¯æŒå‘é‡æœºã€å†³ç­–æ ‘ã€ Kè¿‘é‚» éƒ½æ˜¯å±žäºŽåˆ¤åˆ«æ¨¡åž‹ï¼›æœ€å¸¸è§çš„ç”Ÿæˆæ¨¡åž‹çš„ä¾‹å­å°±æ˜¯ æœ´ç´ è´å¶æ–¯äº†ã€‚ æœ´ç´ è´å¶æ–¯é€šè¿‡è´å¶æ–¯æ³•åˆ™,å¯¹ $ P(y | x) $è¿›è¡Œå˜æ¢: $$P ( y | x ) = \frac { P ( x , y ) } { P ( x ) }$$ åˆ†æ¯æ˜¯å¸¸æ•°,åˆ†å­æ ¹æ®æ¡ä»¶ç‹¬ç«‹æ€§å¯ä»¥è½¬åŒ–ä¸º:$$P ( x , y ) = p \left( y , f _ { 1 } , \ldots , f _ { n } \right) = \prod _ { i = 1 } ^ { n } P \left( f _ { i } | y \right)$$ ä¹Ÿå°±æ˜¯è¯´æœ´ç´ è´å¶æ–¯ç›¸å½“äºŽä¸ºæ¯ä¸€ä¸ªç‰¹å¾å»ºç«‹äº†ä¸€ä¸ªé«˜æ–¯æ¨¡åž‹.æ‰€ä»¥æœ´ç´ è´å¶æ–¯æ˜¯ç”Ÿæˆå¼æ¨¡åž‹. å¯¹äºŽåˆ¤åˆ«å¼æ¨¡åž‹æ¥è¯´æ±‚å¾— $P(Y|X) $ï¼Œå¯¹æœªè§ç¤ºä¾‹ $X $ï¼Œæ ¹æ®P(Y|X)å¯ä»¥æ±‚å¾—æ ‡è®°Yï¼Œå³å¯ä»¥ç›´æŽ¥åˆ¤åˆ«å‡ºæ¥ï¼Œå¦‚ä¸Šå›¾çš„å·¦è¾¹æ‰€ç¤ºï¼Œå®žé™…æ˜¯å°±æ˜¯ç›´æŽ¥å¾—åˆ°äº†åˆ¤åˆ«è¾¹ç•Œï¼Œæ‰€ä»¥ä¼ ç»Ÿçš„ã€è€³ç†Ÿèƒ½è¯¦çš„æœºå™¨å­¦ä¹ ç®—æ³•å¦‚çº¿æ€§å›žå½’æ¨¡åž‹ã€æ”¯æŒå‘é‡æœºSVMç­‰éƒ½æ˜¯åˆ¤åˆ«å¼æ¨¡åž‹ï¼Œè¿™äº›æ¨¡åž‹çš„ç‰¹ç‚¹éƒ½æ˜¯è¾“å…¥å±žæ€§Xå¯ä»¥ç›´æŽ¥å¾—åˆ°Yã€‚ è€Œç”Ÿæˆå¼æ¨¡åž‹æ±‚å¾— $P(Y,X) $ï¼Œå¯¹äºŽæœªè§ç¤ºä¾‹Xï¼Œä½ è¦æ±‚å‡ºXä¸Žä¸åŒæ ‡è®°ä¹‹é—´çš„è”åˆæ¦‚çŽ‡åˆ†å¸ƒï¼Œç„¶åŽå¤§çš„èŽ·èƒœï¼Œå¦‚ä¸Šå›¾å³è¾¹æ‰€ç¤ºï¼Œå¹¶æ²¡æœ‰ä»€ä¹ˆè¾¹ç•Œå­˜åœ¨ï¼Œå¯¹äºŽæœªè§ç¤ºä¾‹ï¼ˆçº¢ä¸‰è§’ï¼‰ï¼Œæ±‚ä¸¤ä¸ªè”åˆæ¦‚çŽ‡åˆ†å¸ƒï¼ˆæœ‰ä¸¤ä¸ªç±»ï¼‰ï¼Œæ¯”è¾ƒä¸€ä¸‹ï¼Œå–é‚£ä¸ªå¤§çš„ã€‚æ¯”å¦‚æœ´ç´ è´å¶æ–¯ç®—æ³•å’Œéšå¼é©¬å°”ç§‘å¤«æ¨¡åž‹ã€‚ åˆ¤åˆ«å¼æ¨¡åž‹ä¸¾ä¾‹ï¼šè¦ç¡®å®šä¸€ä¸ªç¾Šæ˜¯å±±ç¾Šè¿˜æ˜¯ç»µç¾Šï¼Œç”¨åˆ¤åˆ«æ¨¡åž‹çš„æ–¹æ³•æ˜¯ä»ŽåŽ†å²æ•°æ®ä¸­å­¦ä¹ åˆ°æ¨¡åž‹ï¼Œç„¶åŽé€šè¿‡æå–è¿™åªç¾Šçš„ç‰¹å¾æ¥é¢„æµ‹å‡ºè¿™åªç¾Šæ˜¯å±±ç¾Šçš„æ¦‚çŽ‡ï¼Œæ˜¯ç»µç¾Šçš„æ¦‚çŽ‡ã€‚ç”Ÿæˆå¼æ¨¡åž‹ä¸¾ä¾‹ï¼šåˆ©ç”¨ç”Ÿæˆæ¨¡åž‹æ˜¯æ ¹æ®å±±ç¾Šçš„ç‰¹å¾é¦–å…ˆå­¦ä¹ å‡ºä¸€ä¸ªå±±ç¾Šçš„æ¨¡åž‹ï¼Œç„¶åŽæ ¹æ®ç»µç¾Šçš„ç‰¹å¾å­¦ä¹ å‡ºä¸€ä¸ªç»µç¾Šçš„æ¨¡åž‹ï¼Œç„¶åŽä»Žè¿™åªç¾Šä¸­æå–ç‰¹å¾ï¼Œæ”¾åˆ°å±±ç¾Šæ¨¡åž‹ä¸­çœ‹æ¦‚çŽ‡æ˜¯å¤šå°‘ï¼Œåœ¨æ”¾åˆ°ç»µç¾Šæ¨¡åž‹ä¸­çœ‹æ¦‚çŽ‡æ˜¯å¤šå°‘ï¼Œå“ªä¸ªå¤§å°±æ˜¯å“ªä¸ªã€‚ æ•°æ®é›†çš„åˆ’åˆ† Holdoutæ£€éªŒï¼šç›´æŽ¥å°†åŽŸå§‹çš„æ ·æœ¬é›†åˆéšæœºåˆ’åˆ†æˆè®­ç»ƒé›†å’ŒéªŒè¯é›†ä¸¤éƒ¨åˆ†ã€‚æ¯”æ–¹è¯´ï¼Œå¯¹äºŽä¸€ä¸ªç‚¹å‡»é‡é¢„æµ‹æ¨¡åž‹ï¼Œæˆ‘ä»¬æŠŠæ ·æœ¬æŒ‰ç…§70%~30%çš„æ¯”ä¾‹åˆ†æˆä¸¤éƒ¨åˆ†ï¼Œ70%çš„æ ·æœ¬ç”¨äºŽæ¨¡åž‹è®­ç»ƒï¼›30%çš„æ ·æœ¬ç”¨äºŽæ¨¡åž‹éªŒè¯ï¼ŒåŒ…æ‹¬ç»˜åˆ¶ROCæ›²çº¿ã€è®¡ç®—ç²¾ç¡®çŽ‡å’Œå¬å›žçŽ‡ç­‰æŒ‡æ ‡æ¥è¯„ä¼°æ¨¡åž‹æ€§èƒ½ï¼›ç¼ºç‚¹ï¼šåœ¨éªŒè¯é›†ä¸Šè®¡ç®—å‡ºæ¥çš„æœ€åŽè¯„ä¼°æŒ‡æ ‡ä¸ŽåŽŸå§‹åˆ†ç»„æœ‰å¾ˆå¤§çš„å…³ç³» äº¤å‰éªŒè¯ K-foldäº¤å‰éªŒè¯ï¼šé¦–å…ˆå°†å…¨éƒ¨æ ·æœ¬åˆ’åˆ†æˆkä¸ªå¤§å°ç›¸ç­‰çš„æ ·æœ¬å­é›†ï¼›ä¸€æ¬¡éåŽ†è¿™kä¸ªå­é›†ï¼Œæ¯æ¬¡æŠŠå½“å‰å­é›†ä½œä¸ºéªŒè¯é›†ï¼Œå…¶ä½™æ‰€æœ‰å­é›†ä½œä¸ºè®­ç»ƒé›†ï¼Œè¿›è¡Œæ¨¡åž‹çš„è®­ç»ƒå’Œè¯„ä¼°ï¼›æœ€åŽæŠŠkæ¬¡è¯„ä¼°æŒ‡æ ‡çš„å¹³å‡å€¼ä½œä¸ºæœ€ç»ˆçš„è¯„ä¼°æŒ‡æ ‡ã€‚åœ¨å®žéªŒä¸­ï¼Œkç»å¸¸å–10. ç•™ä¸€éªŒè¯ï¼šæ¯æ¬¡ç•™ä¸‹ä¸€ä¸ªæ ·æœ¬ä½œä¸ºéªŒè¯é›†ï¼Œå…¶ä½™æ‰€æœ‰æ ·æœ¬ä½œä¸ºæµ‹è¯•é›†ã€‚åœ¨æ ·æœ¬æ€»æ•°è¾ƒå¤šçš„æƒ…å†µä¸‹ï¼Œç•™ä¸€éªŒè¯çš„æ—¶é—´å¼€é”€æžå¤§. ä¸¤è€…ç»“åˆèµ·æ¥ ä½¿ç”¨ training dataï¼Œ evaluation data å’Œtest data ä¸‰ç§æ•°æ®é›†ã€‚ç¬¬ä¸€ç§æ–¹æ³•ç›¸å½“äºŽåªæœ‰ training data å’Œ test dataï¼Œç¬¬äºŒç§æ–¹æ³•æ˜¯training data å’Œevaluation dataï¼› ç¬¬ä¸‰ç§æ–¹å¼ç›¸å½“äºŽæ˜¯æœ‰ training dataï¼Œ evaluation data å’Œtest dataã€‚ one-hotOne-Hotç¼–ç ï¼Œåˆç§°ä¸ºä¸€ä½æœ‰æ•ˆç¼–ç ï¼Œä¸»è¦æ˜¯é‡‡ç”¨Nä½çŠ¶æ€å¯„å­˜å™¨æ¥å¯¹Nä¸ªçŠ¶æ€è¿›è¡Œç¼–ç ï¼Œæ¯ä¸ªçŠ¶æ€éƒ½ç”±ä»–ç‹¬ç«‹çš„å¯„å­˜å™¨ä½ï¼Œå¹¶ä¸”åœ¨ä»»æ„æ—¶å€™åªæœ‰ä¸€ä½æœ‰æ•ˆã€‚One-Hotç¼–ç æ˜¯åˆ†ç±»å˜é‡ä½œä¸ºäºŒè¿›åˆ¶å‘é‡çš„è¡¨ç¤ºã€‚è¿™é¦–å…ˆè¦æ±‚å°†åˆ†ç±»å€¼æ˜ å°„åˆ°æ•´æ•°å€¼ã€‚ç„¶åŽï¼Œæ¯ä¸ªæ•´æ•°å€¼è¢«è¡¨ç¤ºä¸ºäºŒè¿›åˆ¶å‘é‡ï¼Œé™¤äº†æ•´æ•°çš„ç´¢å¼•ä¹‹å¤–ï¼Œå®ƒéƒ½æ˜¯é›¶å€¼ï¼Œå®ƒè¢«æ ‡è®°ä¸º1ã€‚ åœ¨å¾ˆå¤šæœºå™¨å­¦ä¹ ä»»åŠ¡ä¸­ï¼Œç‰¹å¾å¹¶ä¸æ€»æ˜¯è¿žç»­å€¼ï¼Œè€Œæœ‰å¯èƒ½æ˜¯åˆ†ç±»å€¼ã€‚ç¦»æ•£ç‰¹å¾çš„ç¼–ç åˆ†ä¸ºä¸¤ç§æƒ…å†µï¼š ç¦»æ•£ç‰¹å¾çš„å–å€¼ä¹‹é—´æ²¡æœ‰å¤§å°çš„æ„ä¹‰ï¼Œæ¯”å¦‚colorï¼š[red,blue],é‚£ä¹ˆå°±ä½¿ç”¨one-hotç¼–ç  ç¦»æ•£ç‰¹å¾çš„å–å€¼æœ‰å¤§å°çš„æ„ä¹‰ï¼Œæ¯”å¦‚size:[X,XL,XXL],é‚£ä¹ˆå°±ä½¿ç”¨æ•°å€¼çš„æ˜ å°„{X:1,XL:2,XXL:3} ä¼˜ç¼ºç‚¹ä¼˜ç‚¹ï¼š ç®€å•ï¼Œå°†ç±»åˆ«æ•°æ®è§£æžæˆåˆ†ç±»å™¨å¯ä»¥å¤„ç†çš„æ•°æ®ç±»åž‹ã€‚ è¦æ˜¯one hot encodingçš„ç±»åˆ«æ•°ç›®ä¸å¤ªå¤šï¼Œå»ºè®®ä¼˜å…ˆè€ƒè™‘ã€‚ç¼ºç‚¹ï¼š å½“ç±»åˆ«çš„æ•°é‡å¾ˆå¤šæ—¶ï¼Œç‰¹å¾ç©ºé—´ä¼šå˜å¾—éžå¸¸å¤§ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä¸€èˆ¬å¯ä»¥ç”¨PCAæ¥å‡å°‘ç»´åº¦ã€‚è€Œä¸”one hot encoding+PCAè¿™ç§ç»„åˆåœ¨å®žé™…ä¸­ä¹Ÿéžå¸¸æœ‰ç”¨ã€‚ é™ç»´å‰å¯ä»¥äº¤å‰çš„é™ç»´åŽå¯èƒ½å˜å¾—ä¸èƒ½äº¤å‰ å®žçŽ° æ‰‹åŠ¨å®žçŽ° 1234567891011121314151617import numpy as npdef one_hot(list1): list1_u =np.unique(list1) # save (val, index) dict1 =dict() for (ind, val) in enumerate(list1_u): dict1[str(val)] =ind res =np.zeros((len(list1), len(list1_u))) # modify (ind, val) for (ind, val) in enumerate(list1): res[ind, dict1[str(val)]] =1 return reslist1 =[1, 2, 2, 4]print(one_hot(list1)) ä½¿ç”¨pandas å®žçŽ° 123456import pandas as pds = pd.Series(list("abcdd"))arr =pd.get_dummies(s)arr1 =pd.get_dummies(s, sparse =True)print(type(arr), arr)print(type(arr1), arr1) ä½¿ç”¨sklearn å®žçŽ° 12345678import numpy as npfrom sklearn.preprocessing import OneHotEncoderlabels =[0, 1, 0, 2]labels =np.array(labels).reshape(len(labels), -1)enc =OneHotEncoder()enc.fit(labels)targets =enc.transform(labels).toarray() æ•°æ®çŸ©é˜µæ˜¯4*3ï¼Œå³4ä¸ªæ•°æ®ï¼Œ3ä¸ªç‰¹å¾ç»´åº¦ã€‚ï¼ˆæ‰€ä»¥æœ€åŽçš„ç»“æžœä¸ä¸€å®šæ˜¯åªæ˜¯å‡ºçŽ°äº†ä¸€ä¸ª 1ï¼‰ å…¶ä»– ä»€ä¹ˆæƒ…å†µä¸‹(ä¸)éœ€è¦å½’ä¸€åŒ–ï¼Ÿéœ€è¦ï¼š åŸºäºŽå‚æ•°çš„æ¨¡åž‹æˆ–åŸºäºŽè·ç¦»çš„æ¨¡åž‹ï¼Œéƒ½æ˜¯è¦è¿›è¡Œç‰¹å¾çš„å½’ä¸€åŒ–ã€‚ä¸éœ€è¦ï¼šåŸºäºŽæ ‘çš„æ–¹æ³•æ˜¯ä¸éœ€è¦è¿›è¡Œç‰¹å¾çš„å½’ä¸€åŒ–ï¼Œä¾‹å¦‚éšæœºæ£®æž—ï¼Œbagging å’Œ boostingç­‰ã€‚ Tree Modelä¸å¤ªéœ€è¦one-hotç¼–ç  å¸¸è§çš„å‡ ç§åˆ†ç±»ç®—æ³•çš„æ€»ç»“æœºå™¨å­¦ä¹ å¸¸è§åˆ†ç±»ç®—æ³•æœºå™¨å­¦ä¹ ä¸­å¸¸ç”¨çš„åˆ†ç±»ç®—æ³•å¸¸ç”¨æœºå™¨å­¦ä¹ ç®—æ³•æ±‡æ€»(ä¸­ï¼‰æœºå™¨å­¦ä¹ å¸¸è§ç®—æ³•ä¸ªäººæ€»ç»“ï¼ˆé¢è¯•ç”¨ï¼‰ å¤ä¹ ç¬”è®° ä¼˜åŒ–å™¨ï¼š æ¢¯åº¦ä¸‹é™å¾—åˆ°æ˜¯å…¨å±€æœ€ä¼˜è§£ï¼Œä½†æ˜¯å½“æ•°æ®é‡å¤§çš„æ—¶å€™ï¼Œè®­ç»ƒé€Ÿåº¦å˜æ…¢ã€‚éšæœºæ¢¯åº¦ä¸‹é™å¾—åˆ°å±€éƒ¨è§£ï¼Œè®­ç»ƒé€Ÿåº¦å¿«ï¼›batch_size å¾—åˆ°äº† batchæ¢¯åº¦ä¸‹é™ï¼Œæ˜¯ä¸¤è€…æ–¹æ³•çš„æŠ˜ä¸­ã€‚ ç‰›é¡¿æ³•ç›¸æ¯”äºŽæ¢¯åº¦ä¸‹é™æ˜¯äºŒé˜¶æ±‚å¯¼ï¼ŒåŸºäºŽå½“å‰ä½ç½®åˆ‡çº¿æ¥ç¡®å®šä¸‹ä¸€æ¬¡çš„ä½ç½®ï¼Œæ›´åŠ å¿«ã€‚å’Œä¸€é˜¶åœ¨æœ€ä¼˜ç‚¹ä¼šéœ‡è¡ï¼Œä½†æ˜¯äºŒé˜¶ä¸ä¼šã€‚ å‡¸å‡½æ•°ä¸Žå¦åœ¨äºŽæ˜¯å¦å¯ä»¥æ±‚å¾—å…¨å±€æœ€ä¼˜ï¼ˆå°ï¼‰è§£ã€‚ biasï¼ˆåå·®ï¼‰ å’Œvarianceï¼ˆæ–¹å·®ï¼‰ æ›´åŠ é€‚åˆè¯„ä»·å›žå½’æ¨¡åž‹çš„æ•ˆæžœï¼Œåˆ†åˆ«å¯¹åº”å‡†å’Œç¡®ã€‚å½“æ¨¡åž‹æ¯”è¾ƒç®€å•çš„ï¼Œå®¹æ˜“å‡ºçŽ°é«˜åå·®ï¼Œè¿™ä¸ªæ˜¯æ¬ æ‹Ÿåˆï¼›å½“æ¨¡åž‹å¤æ‚æ—¶å€™ï¼Œå®¹æ˜“å‡ºçŽ°é«˜æ–¹å·®ï¼Œè¿™ä¸ªæ˜¯è¿‡æ‹Ÿåˆã€‚ åˆ¤åˆ«æ¨¡åž‹æ˜¯ $p(y|x)$ ï¼Œç»™å®šæ¡ä»¶ï¼Œç›®çš„éœ€è¦ç»™å‡ºä¸€ä¸ªå†³ç­–è¾¹ç•Œã€‚ $p(x, y)$ æ˜¯ç”Ÿæˆæ¨¡åž‹ï¼Œæ ¹æ®ç±»åˆ«çš„åˆ†å¸ƒæƒ…å†µç¡®å®šæ–°æ ·æœ¬çš„ç±»åˆ«ã€‚]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>bias-variance</tag>
        <tag>one-hot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é¢è¯•ç®—æ³•é¢˜]]></title>
    <url>%2F2018%2F02%2F22%2F%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Consecutive Numbers SumTipsï¼šå¦‚æžœæ˜¯è¿žç»­æ•°ï¼Œé‚£ä¹ˆæ˜¯å¯ä»¥ä½¿ç”¨ç­‰å·®æ•°åˆ—æ±‚å’Œçš„ã€‚å¹¶ä¸”è¿™ä¸ªæ±‚è§£çš„æ˜¯ç¬¦åˆæ¡ä»¶çš„è§£çš„ä¸ªæ•°ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯O ($\sqrt{n}$) ã€‚å¯¹äºŽä¸€ä¸ªæ­£æ•´æ•°Nï¼Œå¦‚æžœèƒ½å†™æˆKä¸ªè¿žç»­æ­£æ•´æ•°ç›¸åŠ çš„å½¢å¼ï¼Œåˆ™æœ‰ï¼Œ $$\begin{split}N &amp;= ( x + 1 ) + ( x + 2 ) + \dots + ( x + K ) \\N &amp;= K \times x + \frac { ( 1 + K ) \times K } { 2 } \\\end{split}$$ æ‰€ä»¥ï¼Œ N èƒ½å¤Ÿè¢« Kä¸ªè¿žç»­æ­£æ•´æ•°ç›¸åŠ çš„æ¡ä»¶æ˜¯ï¼Œ $\left( N - \frac { K * ( K + 1 ) } { 2 } \right)$ èƒ½å¤Ÿè¢« K æ•´é™¤ã€‚ 1234567891011121314151617181920class Solution(object): def consecutiveNumbersSum(self, N): """ :type N: int :rtype: int """ res =0 n =0 while n*(n+1) &lt;= 2*N: top =N -(n *n +n)/2 if top &lt;=0: break elif top %(n +1) ==0: res +=1 n +=1 return res C ++çš„ä»£ç  12345678910111213141516171819class Solution &#123;public: // æ•°å­¦å°±æ˜¯è¦æ±‚ excactly è¿™æ ·çš„å‡†ç¡® // å¦‚æžœæœ€åŽå¤šäº†ï¼Œé‚£ä¹ˆé™åˆ¶æ¡ä»¶ä¸€å®šæ˜¯ä¸å¤Ÿä¸¥æ ¼ï¼›åä¹‹ä¹Ÿæ˜¯æˆç«‹çš„ int consecutiveNumbersSum(int N) &#123; // è¿™ä¸ªi è¡¨ç¤ºè¿žç»­æ•°å­—çš„é•¿åº¦ int i =0; int counts =0; while(i*(i +1) &lt;= 2*N) &#123; // è¾¹ç•Œæ¡ä»¶å¿…è¦éš¾æŠŠæ¡ int top = N - (1+i) *i/2; if(top &lt;=0) break; if(top % (i +1) ==0) counts ++; i ++; &#125; return counts; &#125;&#125;; å¦‚ä½•è¿‘ä¼¼çš„æ±‚è§£ piTips: éšæœºæŠ½æ ·ï¼Œæ³¨æ„æ˜¯å‡åŒ€åˆ†å¸ƒè€Œä¸æ˜¯æ­£å¤ªåˆ†å¸ƒï¼Œå¯¹åº”python ä¸­çš„å®žçŽ°æ˜¯ randrange() è€Œä¸æ˜¯ random() å‡½æ•°ã€‚æ³¨æ„æœ‰ç²¾åº¦çš„é—®é¢˜ 1234567891011from random import randrangetotal = 100000res =0i =0while i&lt; total: x = randrange(0, total+1)/100000.0 y = randrange(0, total+1)/ 100000.0 if(x*x + y*y &lt;= 1): res +=1; i += 1print( res*1.0/ total*4) åœ¨ä¸€ä¸ªåœ†å†…éšæœºé‡‡æ ·å¾—åˆ°ç»“æžœçš„æ¦‚çŽ‡ï¼Ÿ 4/paiæ±‚è§£çš„è¿‡ç¨‹ï¼Ÿæ–¹æ³•ä¸€ï¼š ä½¿ç”¨ range(0ï¼Œ1) å¹³å‡å‡½æ•°æ–¹æ³•äºŒï¼š ä½¿ç”¨ range(0, 1) éšæœºå¾—åˆ°rï¼Œ ä½¿ç”¨ sigta å¾—åˆ°[0, 2pai]ï¼Œç„¶åŽä¸¤è€…ç›¸ä¹˜ã€‚ä½†æ˜¯å¯¹äºŽ r æ˜¯éœ€è¦ è¿›è¡Œ æ ¹å·r å¤„ç†ã€‚å¦åˆ™çš„è¯ï¼Œæœ€åŽçš„ç»“æžœæ˜¯ä¸å‡åŒ€çš„ å¯¹äºŽç¬¬äºŒç§æ–¹å¼ï¼Œä½¿ç”¨æžåæ ‡è¡¨ç¤ºçš„æ–¹å¼ä¸ä¼š 1234567891011import mathfrom random import randrangen = 1000000r = randrange(0,n+1)/nthetha = r * 2*math.piarea =thetha * r* 4print(r) print(thetha)print(area) ä¸­æ–‡è½¬æ¢æˆé˜¿æ‹‰ä¼¯æ•°å­— ä¸­æ–‡è½¬æˆé˜¿æ‹‰ä¼¯æ•°å­—ï¼ˆå«æœ‰ç‚¹ï¼‰ å¦‚æžœæœ‰â€œç‚¹â€ï¼Œé‚£ä¹ˆå°±æˆªæ–­å¤„ç†ï¼Œåˆ†æˆå°æ•°ç‚¹ä¹‹å‰å’Œä¹‹åŽã€‚ äºŒè¿›åˆ¶æ•°ä¸­çš„1 åœ¨äºŒè¿›åˆ¶ä¸­ï¼Œç»å¸¸ä½¿ç”¨åˆ°çš„å°±æ˜¯ &amp;å’Œ &gt;&gt; ä¸¤ä¸ªæ“ä½œã€‚ &gt;&gt; ç§»ä½æ“ä½œåªæ˜¯é’ˆå¯¹æ•´æ•°ï¼Œå¯¹äºŽæµ®ç‚¹æ•°å’Œ unsigned int è¿™ä¸ªæ˜¯ä¸èƒ½ç”¨çš„ï¼Œåœ¨åŽé¢ä¸¤ç§ç±»åž‹ä¸­ï¼Œéœ€è¦ä½¿ç”¨åˆ° Â·/=Â· è¿™æ ·çš„æ“ä½œï¼Œè¯¥æ“ä½œæ˜¯é€šç”¨çš„ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯ $log(n)$ã€‚ 12345678910111213class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int cout =0; while(n) &#123; if(n &amp;1 ==1) cout ++; n /=2; &#125; return cout; &#125;&#125;; å¦‚æžœ1å‡ºçŽ°çš„æ¬¡æ•°æ¯”è¾ƒå°‘ï¼Œ æ—¶é—´å¤æ‚åº¦å˜æˆäº†$O(k)$ï¼Œ K è¡¨ç¤ºå­—ç¬¦ä¸²ä¸­ 1 çš„ä¸ªæ•°ï¼Œ æ‰€ä»¥ n &amp;(n-1) æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„æ“ä½œã€‚ 1234567891011121314int count3(Byte v)&#123; int count =0; while (v) &#123; v &amp;= (v-1);// ä½¿å¾—æœ€å¤§ä½çš„1å˜æˆ0 ï¼Œåœ¨äºŒè¿›åˆ¶çš„è§’åº¦ä¸Š count +=1 ; &#125;&#125;// ä½¿ç”¨ç©ºé—´ä»£æ›¿æ—¶é—´, è¿™ä¸ªæ˜¯å¯ä»¥è¿›è¡Œç©·ä¸¾çš„int count4(Byte v)&#123; int countTable [256] =&#123;0, 1,1,2...8&#125; int count =countTable[v]; return count;&#125; ç»™å®šä¸€ä¸ªæ•°å­—N Nçš„é˜¶ä¹˜æœ‰å¤šå°‘ä¸ª0? Tips: æ•°å­¦é—®é¢˜ï¼ŒN æ˜¯å¯ä»¥é€šè¿‡è´¨å› æ•°(2, 3, 5)è¿›è¡Œåˆ†æž $N =(2^x +3^y+ 5^z) $ï¼Œ ç„¶åŽ0çš„ä¸ªæ•°æ˜¯ $min(x, z) -&gt; z $, æœ€åŽå°±ç›¸å½“äºŽæ¯ä¸ªæ•°å­—çš„5çš„ä¸ªæ•°ã€‚åˆ°æœ€åŽæ˜¯åœ¨ç»Ÿè®¡ 5 çš„ä¸ªæ•°ï¼Œæ•°å­—N åˆ†è§£å› å¼ä¹‹åŽ 5 çš„ä¸ªæ•°ã€‚ æ—¶é—´å¤æ‚åº¦æ˜¯$O(log_5N)$ è¿˜æ˜¯log çš„æ—¶é—´å¤æ‚åº¦ 1234567891011int count(Byteï¼Œ v)&#123; int count; for(int i =0; i&lt;=v; i++) &#123; while (i) &#123; count +=1; i /=5; &#125; &#125; return count;&#125; 123456789int count(Byte, v)&#123; int count =0; while (v &gt;4) &#123; count += v/5; v =v /5; &#125; return count;&#125; æ±‚è§£ N! ä¸­çš„äºŒçº§åˆ¶è¡¨ç¤ºä¸­æœ€ä½Žä½1çš„ä½ç½® åœ¨äºŒè¿›åˆ¶ä¸­ï¼Œç»å¸¸ä½¿ç”¨åˆ°çš„å°±æ˜¯ &amp;å’Œ &gt;&gt; ä¸¤ä¸ªæ“ä½œã€‚ &gt;&gt; ç§»ä½æ“ä½œåªæ˜¯é’ˆå¯¹æ•´æ•°ï¼Œå¯¹äºŽæµ®ç‚¹æ•°å’Œ unsigned int è¿™ä¸ªæ˜¯ä¸èƒ½ç”¨çš„ï¼Œåœ¨åŽé¢ä¸¤ç§ç±»åž‹ä¸­ï¼Œéœ€è¦ä½¿ç”¨åˆ° Â·/=Â· è¿™æ ·çš„æ“ä½œï¼Œè¯¥æ“ä½œæ˜¯é€šç”¨çš„ã€‚ è¿˜æ˜¯ä»ŽäºŒè¿›åˆ¶çš„è§’åº¦å‡ºå‘ã€‚ 12345678910111213class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int cout =0; while(n) &#123; if(n &amp;1 ==1) cout ++; n /=2; &#125; return cout +1; &#125;&#125;; å¯»æ‰¾æ¯ä¸ª IDï¼Œè¯¥ID å‡ºçŽ°çš„é¢‘çŽ‡æ˜¯å¤§äºŽ 0.5, å‡ºçŽ°çš„æ¬¡æ•°å¤§äºŽæ€»æ•°çš„ä¸€åŠ Tips: å¦‚æžœæ¯æ¬¡åˆ é™¤ä¸¤ä¸ªä¸åŒçš„IDï¼Œé‚£ä¹ˆ æœ€å¤šçš„ID å‡ºçŽ°çš„æ¬¡æ•°è¿˜æ˜¯å¤§äºŽæ€»æ•°çš„ä¸€èˆ¬ï¼Œä¸æ–­çš„é‡å¤è¿™ä¸ªè¿‡ç¨‹ã€‚æ—¶é—´å¤æ‚åº¦æ˜¯O(n)ï¼Œæƒ³æ³•æ˜¯ä¸Šé¢é‚£ç§ï¼Œä½†æ˜¯åœ¨æ“ä½œçš„æ—¶å€™ï¼Œå¹¶ä¸æ˜¯åˆ é™¤äº†æŸä¸ªIDã€‚çœ‹ä»£ç æ˜¯ä¸€æ¸…äºŒæ¥šçš„ã€‚ 1234567891011121314151617181920212223242526Type Find(Type *ID, int N)&#123; Type candidate; int nTimes =0, i; for(i =0; i&lt; N; i++)&#123; if (nTimes ==0) &#123; candidate =ID[i]; nTimes =1 &#125; else &#123; if(ID[i] ==candidate)&#123; nTimes +=1; &#125; else&#123; nTimes -=1; &#125; &#125; &#125; // è¿™ä¸ªåº”è¯¥è¿˜æ˜¯éœ€è¦æœ€åŽåˆ¤æ–­ä¸€ä¸‹ candidate æ˜¯ä¸æ˜¯å‡ºçŽ°äº† [2/N] æ¬¡æ•°ï¼Œå› ä¸ºæœ‰ä¸€ç§æƒ…å†µæ˜¯ä¸å­˜åœ¨çš„&#125; å°¾é€’å½’å°¾è°ƒç”¨å®šä¹‰: åœ¨æŸä¸ªå‡½æ•°çš„æœ€åŽä¸€æ­¥è°ƒç”¨å¦ä¸€ä¸ªå‡½æ•°.è¿›å…¥ä¸‹ä¸€ä¸ªé€’å½’ä¹‹åŽï¼Œè¯¥å±‚æ¬¡çš„é€’å½’å·²ç»ç»“æŸï¼Œä¸éœ€è¦ä½¿ç”¨æ ˆç©ºé—´è¿›è¡Œä¿ç•™ä¿¡æ¯ã€‚ 123456function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x); &#125; ä¸Šé¢ä»£ç ä¸­ï¼Œå‡½æ•°må’Œnéƒ½å±žäºŽå°¾è°ƒç”¨ï¼Œå› ä¸ºå®ƒä»¬éƒ½æ˜¯å‡½æ•°fçš„æœ€åŽä¸€æ­¥æ“ä½œã€‚ä¸ä¸€å®šæ˜¯æœ€åŽä¸€è¡Œã€‚ åŒç†æ˜¯å¯ä»¥æŽ¨å¹¿åˆ°å°¾é€’å½’ã€‚ 12345678910111213141516function f() &#123; let m = 1; let n = 2; return g(m + n);&#125;f();// ç­‰åŒäºŽfunction f() &#123; return g(3);&#125;f();// ç­‰åŒäºŽg(3); å°¾é€’å½’çš„æ„ä¹‰åœ¨äºŽé˜²æ­¢æ ˆæº¢å‡ºã€‚å› ä¸ºé€’å½’çš„è°ƒç”¨æ˜¯éžå¸¸æ¶ˆè€—å†…å­˜çš„ï¼Œéœ€è¦å†æ ˆä¸­ä¿å­˜N ä¸ªè°ƒè°ƒç”¨è®°å½•ï¼Œå¾ˆå®¹æ˜“å‘ç”Ÿæ ˆæº¢å‡º (stack overflow) ã€‚ä½†æ˜¯å¯¹äºŽä¸ºé€’å½’æ¥è¯´ï¼Œåªæœ‰ä¸€ä¸ªè°ƒç”¨è®°å½•ï¼Œå› ä¸ºä¸Šä¸€ä¸ªå·²ç»ç»“æŸï¼Œæ‰€ä»¥æ˜¯ä¸ä¼šå‘ç”Ÿ â€œæ ˆæº¢å‡ºâ€é”™è¯¯çš„ã€‚ Fibonacci æ•°åˆ—æœ€åŽŸå§‹çš„è§£æ³•ï¼Œé€’å½’ï¼Œå…¶ä¸­æœ‰å¾ˆå¤šé‡å¤çš„è®¡ç®—å­å•å…ƒã€‚ ç¨‹åºçš„å¼€å§‹å°±åƒç™¾åº¦çš„é¢è¯•å®˜é‚£æ ·è¯´çš„ï¼Œéƒ½æ˜¯åº”è¯¥è€ƒè™‘ä¸€ä¸‹ç‰¹æ®Šæƒ…å†µï¼Œæœ‰å¯èƒ½è€ƒè™‘ä¸å…¨ï¼Œä½†æ˜¯ä¸€å®šè¦æœ‰è¿™ä¸ªæ„è¯†ã€‚åˆ°äº†é€’å½’ä¸­ï¼Œä¸å†æ˜¯ç‰¹æ®Šæƒ…å†µè¿™ç§äº‹æƒ…ï¼Œè€Œæ˜¯è·³å‡ºæ¡ä»¶ã€‚ 123456789101112131415int Fibonacci(int n)&#123; if (n &lt;0) &#123; return 0; &#125; else if(n ==1) &#123; return 1; &#125; else &#123; return Fibonacci(n -1) + Fibonacci(n -2); &#125;&#125; è§£æ³•äºŒï¼š æ—¶ç©ºéƒ½æ˜¯ O(N)ï¼Œé‡ç‚¹æ˜¯ä»Žé€’å½’è½¬æˆäº†å¾ªçŽ¯ã€‚ 1234567891011def Fibonacci(n ): if n ==0: return 0 elif n ==1: return 1 arr =[0] *(n+1) arr[0] =0 arr[1] =1 for i in range(2, n+1): arr[i] =arr[i-1] +arr[i-2] return arr[-1] åœ¨ä¸Šé¢çš„åŸºç¡€ä¸Šè¿›è¡Œä¼˜åŒ–ï¼Œç©ºé—´å¤æ‚åº¦å˜æˆ O(1) a, b =b, a+b # åœ¨pythonï¼Œè¿žç»­èµ‹å€¼æ˜¯ä»Žå·¦å¾€å³çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œ å…ˆä¿å­˜ b, å’Œ a+bï¼Œç„¶åŽæ‰§è¡Œ a =b, b = a+bæ‰€ä»¥åœ¨python ä¸­äº¤æ¢ä¸¤ä¸ªæ•°å­—å¯ä»¥å†™æˆè¿™æ ·ï¼š a, b = b, a (python ä¸­æ˜¯ä»Žå·¦å¾€å³è¿›è¡Œèµ‹å€¼çš„) æ—¶é—´å¤æ‚åº¦æ˜¯$O(n)$, ç©ºé—´å¤æ‚åº¦ $O(1)$, å› ä¸ºç©ºé—´ä¸Šåªæ˜¯ä¾èµ–å‰ä¸¤ä¸ªï¼Œå¹¶ä¸éœ€è¦ä¿å­˜æ•´ä¸ªæ•°ç»„ã€‚ 1234567891011121314class Solution(object): def fib(self, N): """ :type N: int :rtype: int """ if N &lt;=0: return 0 elif N ==1: return 1 a, b =0, 1 for i in range(N ): a, b =b, a+b # åœ¨pythonï¼Œè¿žç»­èµ‹å€¼æ˜¯ä»Žå·¦å¾€å³çš„ã€‚ return a å¯»æ‰¾æ•°ç»„ä¸­çš„æœ€å¤§å€¼å’Œæœ€å°å€¼æ—¶é—´å¤æ‚åº¦æ˜¯ O(N)ï¼Œä½¿ç”¨äº†ä¸¤ä¸ªå€¼è¿›è¡Œmin_n å’Œmax_n çš„åˆ¤æ–­ã€‚ å¦‚æžœæ•°ç»„æœ¬èº«æ²¡æœ‰ä»€ä¹ˆæœ‰åºæ€§çš„è¯ ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦å°±æ˜¯ $O(n)$ 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;#define INF 10^9void FindMinMax(int a[], int size, int &amp;min, int &amp;max)&#123; max =-INF; min =INF; for (int i =0; i&lt;size -1; i++) &#123; // è¿™ç§åˆ¤æ–­æ–¹å¼ è¿˜æ˜¯å€¼å¾—å­¦ä¹ çš„ï¼Œç»†èŠ‚å°±æ˜¯ index çš„è¾¹ç•Œ if (a[i] &lt; a[i+1]) &#123; if(a[i+1]&gt; max ) max =a[i+1]; if(a[i] &lt; min) min =a[i]; &#125; else &#123; if(a[i] &gt; max) max =a[i] ; if(a[i+1] &lt; min) min =a[i+1]; &#125; &#125;&#125;int main()&#123; int arr[10]; int length =sizeof(arr)/ sizeof(arr[0]); int min, max; FindMinMax(arr, length, min, max); &#125; å¯»æ‰¾æœ€è¿‘ç‚¹å¯¹åœ¨äºŒç»´å¹³é¢ä¸Šçš„nä¸ªç‚¹ä¸­ï¼Œæ‰¾å‡ºæœ€æŽ¥è¿‘çš„ä¸€å¯¹ç‚¹ç¬¬ä¸€æ¬¡ç¢°åˆ°è¿™ä¸ªé¢˜ç›®çš„æ—¶å€™ï¼Œè¿˜åœ¨æƒ³å›¾çš„ç»“æž„ï¼ŒçŽ°åœ¨çœ‹æ¥åªè¦æ˜¯æœ‰array çš„å­˜åœ¨ï¼Œé‚£ä¹ˆè¿™ä¸ªæ˜¯ä¸€å®šæŒ‰ç…§ array çš„æƒ…å†µè¿›è¡ŒéåŽ†æ±‚è§£ã€‚ è§£æ³•ä¸€ï¼š æš´åŠ›æ³•ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯$O(n^2)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;const int N =101;struct Point&#123; float x, y;&#125;point[N];// å› ä¸ºæ˜¯æžšä¸¾çš„ï¼Œæ‰€ä»¥è¿˜æ˜¯å¾—å­˜å‚¨ä¸€ä¸‹åŽŸæ¥è¾“å…¥int n;double cal_dis(Point &amp; a, Point &amp; b)&#123; return sqrt((a.x-b.x) *(a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;int main()&#123; cin &gt;&gt;n; int i =0; while(i &lt;n) &#123; int x, y; cin &gt;&gt;x &gt;&gt;y; point[i].x =x; point[i].y =y; &#125; double min_v= cal_dis(point[0],point[1]), tmp; int ind1, ind2; // æžšä¸¾çš„æ€æƒ³å°±æ˜¯ï¼Œå°±æ˜¯ä¸¤ä¸¤è¿›è¡Œæ¯”è¾ƒ for(int i =0; i&lt;n; i++) &#123; for(int j =i+1; j&lt;n; j++) &#123; tmp =cal_dis(point[i], point[j]); if(tmp &lt; min_v) &#123; min_v =tmp; ind1 =i; ind2 =j; &#125; &#125; &#125; cout &lt;&lt; min_v&lt;&lt; endl; return 0;&#125; è§£æ³•äºŒï¼šåˆ†æ²»æ³• å‚è€ƒè¿™é‡Œ, æœ€åŽçš„æ—¶é—´å¤æ‚åº¦å¯ä»¥é™ä½Žåˆ° $O(nlogn)$ï¼Œæ²¡æœ‰çœ‹æ‡‚ã€‚ ä½¿ç”¨åˆ†æ²»æ³•ï¼ˆdivide and conquerï¼‰è§£é¢˜æ­¥éª¤ï¼š divide å°†è¦è§£å†³çš„é—®é¢˜åˆ†æˆè‹¥å¹²å°è§„æ¨¡çš„åŒç±»é—®é¢˜ conquer- å½“å­é—®é¢˜åˆ’åˆ†çš„è¶³å¤Ÿå°ï¼Œèƒ½å¤Ÿä½¿ç”¨è¾ƒç®€å•çš„æ–¹å¼è§£å†³ combine å°†å­é—®é¢˜çš„è§£é€å±‚åˆå¹¶æž„æˆåŽŸé—®é¢˜çš„è§£ é‡‡ç”¨åˆ†è€Œæ²»ä¹‹çš„æ€æƒ³ï¼Œåˆ†æˆå·¦å³ä¸¤ä¸ªå­é›†ï¼Œ$S_l$ å’Œ$S_r$ ï¼Œç„¶åŽåˆ†åˆ«è®¡ç®—ä¸¤ä¸ªå­é›†ä¹‹å†…çš„æœ€å°çš„è·ç¦»ï¼Œç„¶åŽéœ€è¦è®¡ç®—ä¸¤ä¸ªå­é›†è¾¹ç•Œé™„è¿‘çš„ç‚¹çš„è·ç¦»ã€‚ä»Žç®—æ³•æ­¥éª¤ä¸Šè®²ï¼Œå…ˆå­˜å‚¨ç‚¹ point è¿™æ ·çš„ä¸€ä¸ªç»“æž„ä½“ï¼Œç„¶åŽæŒ‰ç…§point ä¸­çš„x è¿›è¡ŒæŽ’åºã€‚ $\delta$ æ˜¯ä»Žå·¦å³ä¸¤ä¸ªå­é›†ä¸­å–å¾—çš„ç‚¹ä¸Žç‚¹ä¹‹é—´çš„æœ€å°è·ç¦»ï¼Œé‚£ä¹ˆæ„å‘³ç€ä¸¤ç‚¹ä¹‹é—´çš„è·ç¦» æœ€å°æ˜¯ $\delta $ï¼Œæ‰€ä»¥åœ¨æ­£æ–¹å½¢ ($2\delta$, $2\delta$ ) çš„åŒºé—´å†…ï¼Œå·¦åŠéƒ¨åˆ†çš„ç‚¹åˆ°å³åŠéƒ¨åˆ†çš„ç‚¹çš„è·ç¦»æœ€å°‘æ˜¯ $\delta$ï¼Œæ ¹æ®å‰²èˆåŽŸç†ï¼Œé‚£ä¹ˆæœ€å¤šåªéœ€è¦æ¯”è¾ƒ6ä¸ªç‚¹ã€‚è¿™é‡Œçš„æ˜¯æ¯ä¸ªç‚¹ï¼Œåªéœ€è¦ä¸ªå…¶ä»–çš„6ä¸ªç‚¹è¿›è¡Œæ¯”è¾ƒï¼Œè€Œä¸æ˜¯æ€»å…±åªæœ‰6ä¸ªç‚¹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define INFINITE_DISTANCE 65535 // æ— é™å¤§è·ç¦»#define COORDINATE_RANGE 100.0 // æ¨ªçºµåæ ‡èŒƒå›´ä¸º[-100,100]#ifndef Closest_pairtypedef struct Point&#123;// äºŒç»´åæ ‡ä¸Šçš„ç‚¹Point double x; double y;&#125;Point;double Distance(Point a, Point b)&#123;//å¹³é¢ä¸Šä»»æ„ä¸¤ç‚¹å¯¹ä¹‹é—´çš„è·ç¦»å…¬å¼è®¡ç®— return sqrt((a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y));&#125;bool compareX(Point a, Point b)&#123;//è‡ªå®šä¹‰æŽ’åºè§„åˆ™ï¼šä¾ç…§ç»“æž„ä½“ä¸­çš„xæˆå‘˜å˜é‡å‡åºæŽ’åº return a.x &lt; b.x;&#125;bool compareY(Point a, Point b)&#123;//è‡ªå®šä¹‰æŽ’åºè§„åˆ™ï¼šä¾ç…§ç»“æž„ä½“ä¸­çš„xæˆå‘˜å˜é‡å‡åºæŽ’åº return a.y &lt; b.y;&#125;float ClosestPair(Point points[], int length, Point &amp;a, Point &amp;b)&#123;// æ±‚å‡ºæœ€è¿‘ç‚¹å¯¹è®°å½•ï¼Œå¹¶å°†ä¸¤ç‚¹è®°å½•å†aã€bä¸­ double distance; //è®°å½•é›†åˆpointsä¸­æœ€è¿‘ä¸¤ç‚¹è·ç¦» double d1, d2; //è®°å½•åˆ†å‰²åŽä¸¤ä¸ªå­é›†ä¸­å„è‡ªæœ€å°ç‚¹å¯¹è·ç¦» int i = 0, j = 0, k = 0, x = 0; //ç”¨äºŽæŽ§åˆ¶forå¾ªçŽ¯çš„å¾ªçŽ¯å˜é‡ Point a1, b1, a2, b2; //ä¿å­˜åˆ†å‰²åŽä¸¤ä¸ªå­é›†ä¸­æœ€å°ç‚¹å¯¹ if (length &lt; 2) return INFINITE_DISTANCE; //è‹¥å­é›†é•¿åº¦å°äºŽ2ï¼Œå®šä¹‰ä¸ºæœ€å¤§è·ç¦»ï¼Œè¡¨ç¤ºä¸å¯è¾¾ else if (length == 2) &#123;//è‹¥å­é›†é•¿åº¦ç­‰äºŽ2ï¼Œç›´æŽ¥è¿”å›žè¯¥ä¸¤ç‚¹çš„è·ç¦» a = points[0]; b = points[1]; distance = Distance(points[0], points[1]); &#125; else &#123;//å­é›†é•¿åº¦å¤§äºŽ3ï¼Œè¿›è¡Œåˆ†æ²»æ±‚è§£ Point *pts1 = new Point[length]; //å¼€è¾Ÿä¸¤ä¸ªå­é›† Point *pts2 = new Point[length]; sort(points, points + length, compareX); //è°ƒç”¨algorithmåº“ä¸­çš„sortå‡½æ•°å¯¹pointsè¿›è¡ŒæŽ’åºï¼ŒcompareXä¸ºè‡ªå®šä¹‰çš„æŽ’åºè§„åˆ™ double mid = points[(length - 1) / 2].x; //æŽ’å®ŒåºåŽçš„ä¸­é—´ä¸‹æ ‡å€¼ï¼Œå³ä¸­ä½æ•° for (i = 0; i &lt; length / 2; i++) pts1[i] = points[i]; for (int j = 0, i = length / 2; i &lt; length; i++) pts2[j++] = points[i]; d1 = ClosestPair(pts1, length / 2, a1, b1); //åˆ†æ²»æ±‚è§£å·¦åŠéƒ¨åˆ†å­é›†çš„æœ€è¿‘ç‚¹ d2 = ClosestPair(pts2, length - length / 2, a2, b2); //åˆ†æ²»æ±‚è§£å³åŠéƒ¨åˆ†å­é›†çš„æœ€è¿‘ç‚¹ if (d1 &lt; d2) &#123; distance = d1; a = a1; b = b1; &#125; //è®°å½•æœ€è¿‘ç‚¹ï¼Œæœ€è¿‘è·ç¦» else &#123; distance = d2; a = a2; b = b2; &#125; //merge - è¿›è¡Œå­é›†åˆè§£åˆå¹¶ //æ±‚è§£è·¨åˆ†å‰²çº¿å¹¶åœ¨Î´Ã—2Î´åŒºé—´å†…çš„æœ€è¿‘ç‚¹å¯¹ Point *pts3 = new Point[length]; for (i = 0, k = 0; i &lt; length; i++) //å–å¾—ä¸­çº¿2Î´å®½åº¦çš„æ‰€æœ‰ç‚¹å¯¹å…±kä¸ª if (abs(points[i].x - mid) &lt;= distance) pts3[k++] = points[i]; sort(pts3, pts3 + k, compareY); // ä»¥yæŽ’åºçŸ©å½¢é˜µå†…çš„ç‚¹é›†åˆ for (i = 0; i &lt; k; i++) &#123; if (pts3[j].x - mid &gt;= 0) // åªåˆ¤æ–­å·¦ä¾§éƒ¨åˆ†çš„ç‚¹ continue; x = 0; for (j = i + 1; j &lt;= i + 6 + x &amp;&amp; j &lt; k; j++) //åªéœ€ä¸Žæœ‰åºçš„é¢†æŽ¥çš„çš„6ä¸ªç‚¹è¿›è¡Œæ¯”è¾ƒ &#123; if (pts3[j].x - mid &lt; 0) &#123;// å‡å¦‚iç‚¹æ˜¯ä½äºŽmidå·¦è¾¹åˆ™åªéœ€åˆ¤æ–­åœ¨midå³è¾¹çš„jç‚¹å³å¯ x++; continue; &#125; if (Distance(pts3[i], pts3[j]) &lt; distance) &#123;//å¦‚æžœè·¨åˆ†å‰²çº¿çš„ä¸¤ç‚¹è·ç¦»å°äºŽå·²çŸ¥æœ€å°è·ç¦»ï¼Œåˆ™è®°å½•è¯¥è·ç¦»å’Œä¸¤ç‚¹ distance = Distance(pts3[i], pts3[j]); a = pts3[i]; b = pts3[j]; &#125; &#125; &#125; &#125; return distance;&#125;void SetPoints(Point *points, int length)&#123;//éšæœºå‡½æ•°å¯¹ç‚¹æ•°ç»„pointsä¸­çš„äºŒç»´ç‚¹è¿›è¡Œåˆå§‹åŒ– srand(unsigned(time(NULL))); for (int i = 0; i &lt; length; i++) &#123; points[i].x = (rand() % int(COORDINATE_RANGE * 200)) / COORDINATE_RANGE - COORDINATE_RANGE; points[i].y = (rand() % int(COORDINATE_RANGE * 200)) / COORDINATE_RANGE - COORDINATE_RANGE; &#125;&#125;int main()&#123; int num; //éšæœºç”Ÿæˆçš„ç‚¹å¯¹ä¸ªæ•° Point a, b; //æœ€è¿‘ç‚¹å¯¹ double diatance; //ç‚¹å¯¹è·ç¦» cout &lt;&lt; "è¯·è¾“å…¥äºŒç»´ç‚¹å¯¹ä¸ªæ•°:"; cin &gt;&gt; num; if (num &lt; 2) cout &lt;&lt; "è¯·è¾“å…¥å¤§äºŽç­‰äºŽ2çš„ç‚¹ä¸ªæ•°ï¼ï¼" &lt;&lt; endl; else &#123; cout &lt;&lt; endl &lt;&lt; "éšæœºç”Ÿæˆçš„" &lt;&lt; num &lt;&lt; "ä¸ªäºŒç»´ç‚¹å¯¹å¦‚ä¸‹ï¼š" &lt;&lt; endl; Point *points = new Point[num]; SetPoints(points, num); for (int i = 0; i &lt; num; i++) cout &lt;&lt; "(" &lt;&lt; points[i].x &lt;&lt; "," &lt;&lt; points[i].y &lt;&lt; ")" &lt;&lt; endl; diatance = ClosestPair(points, num, a, b); cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; "æŒ‰æ¨ªåæ ‡æŽ’åºåŽçš„ç‚¹å¯¹:" &lt;&lt; endl; for (int i = 0; i &lt; num; i++) cout &lt;&lt; "(" &lt;&lt; points[i].x &lt;&lt; "," &lt;&lt; points[i].y &lt;&lt; ")" &lt;&lt; endl; cout &lt;&lt; endl &lt;&lt; "æœ€è¿‘ç‚¹å¯¹ä¸ºï¼š" &lt;&lt; "(" &lt;&lt; a.x &lt;&lt; "," &lt;&lt; a.y &lt;&lt; ")å’Œ" &lt;&lt; "(" &lt;&lt; b.x &lt;&lt; "," &lt;&lt; b.y &lt;&lt; ")" &lt;&lt; endl &lt;&lt; "æœ€è¿‘ç‚¹å¯¹è·ç¦»ä¸ºï¼š" &lt;&lt; diatance &lt;&lt; endl; &#125; system("pause");&#125;#endif // !Closest_pair å¯¹æ¯”ä¸€ä¸‹ä¸€ç»´çš„æƒ…å†µã€‚123456789101112131415161718double MinDifference(double arr[], int n)&#123; if (n &lt;2) return 0; sort(arr, arr+n); // sort(arr, arr+n myfunction) é™åº double minDiff =arr[1] - arr[0]; for (int i =2; i&lt;n;i++) &#123; double tmp =arr[i] -arr[i-1]; if (tmp &lt;minDiff) &#123; minDiff =tmp; &#125; &#125; return minDiff; &#125; å¿«é€Ÿå¯»æ‰¾æ»¡è¶³æ¡ä»¶çš„ä¸¤ä¸ªæ•° ç¬¬ä¸€ç§è§£æ³•ï¼š æŽ’åºä¹‹åŽ ç„¶åŽäºŒåˆ†æŸ¥æ‰¾ O(nlogn) +O(logn) -&gt; O(nlogn) åœ¨æœ‰åºçš„æ•°ç»„ä¸­ï¼Œå¿…ç„¶ä½¿ç”¨äºŒåˆ†è¿›è¡ŒæŸ¥æ‰¾ï¼Œè¿™æ ·æŸ¥æ‰¾çš„æ•ˆçŽ‡ä»ŽO(n) -&gt; O(log n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define MAXN 1001int arr[MAXN];bool findSum(int arr[], int n, int sum)&#123; int i =0; int j =n-1; while (i&lt;j) &#123; int tmp =arr[i] +arr[j]; if (tmp ==sum) &#123; printf("(%d, %d)", arr[i], arr[j]); return true; &#125; else if(tmp &lt;sum) i ++; else j --; &#125; return false;&#125;int main()&#123; int n, sum, i,j; cin &gt;&gt; n &gt;&gt;sum; for(i =0; i&lt;n;i++) cin &gt;&gt;arr[i]; sort(arr, arr+n); bool res =findSum(arr, n, sum); return 0;&#125; ç¬¬äºŒç§è§£æ³•ï¼šä½¿ç”¨è¾…åŠ©çš„ç©ºé—´ dictionary å­˜å‚¨ï¼Œç©ºé—´å¤æ‚åº¦O(N) + æ—¶é—´å¤æ‚åº¦ O(N) ä½¿ç”¨python ä¸­çš„ dictionaryï¼Œ in è¿™ç§æ“ä½œæ˜¯éžå¸¸å…·æœ‰å¯è¯»æ€§çš„ã€‚å¹¶ä¸”è¿™ç§æ“ä½œçš„æ—¶é—´å¤æ‚åº¦æ˜¯O(1) ,è¿™ä¸ªæ˜¯ä¸å®¹ç½®ç–‘çš„ï¼Œè¿™ä¸ªæ˜¯å­—å…¸çš„ç‰¹æ€§ã€‚ 123456789101112131415def twoSum(arr, total): if not arr: return arr from collections import defaultdict dic =defaultdict(int) for num in arr: dic[num] = dic[num] +1 for key in dic: if total -key in dic: return (key, total -key) return (-1, -1) å­æ•°ç»„çš„æœ€å¤§ä¹˜ç§¯ ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º N çš„æ•´æ•°æ•°ç»„ï¼Œåªå…è®¸ç”¨ä¹˜æ³•ï¼Œä¸èƒ½ç”¨é™¤æ³•ï¼Œ è®¡ç®—ä»»æ„ ( N-1) ä¸ªæ•°çš„ç»„åˆä¸­ä¹˜ç§¯æœ€å¤§çš„ä¸€ç»„ã€‚ é™åˆ¶æ¡ä»¶ï¼š å¿…é¡»è¦é€‰å‡º ï¼ˆN-1ï¼‰ä¸ªæ•°å­—ï¼Œåªèƒ½ä½¿ç”¨ä¹˜æ³•ã€‚ ç¬¬ä¸€ç§è§£æ³•ï¼šæš´åŠ›æ±‚è§£ï¼ŒéåŽ†å‡ºn ä¸ªï¼Œç„¶åŽéœ€è¦ n-1 æ¬¡ç›¸ä¹˜ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦æ˜¯ $O(N^2)$ 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;class Solution &#123;public:int maxProduct(int *nums) &#123; int res; int max; int i, j; int n= sizeof(nums) /sizeof(nums[0]); for(i =0; i&lt;n; i++) &#123; for(j =0; j&lt;n; j++) // ä½¿ç”¨ for å¾ªçŽ¯çš„å½¢å¼å°†å­é›†ç›¸ä¹˜ &#123; res =1; res *= ( (i==j) ? 1: nums[j]); if (res ==0) break; &#125; max =( i==0 ? res: max); // å®žé™…ä¸Šæ˜¯å¯¹äºŽ max çš„å‡ºé‡Šæ€€ max =( max &lt; res? res: max); // è¿™ç§è¯­æ³•æ˜¯æ¯”è¾ƒç®€æ´çš„ &#125; return max;&#125;&#125;â€‹ ä¸Šè¿°æ–¹å¼è¿›è¡Œäº†å¾ˆå¤šé‡å¤çš„è¿ç®—ï¼Œå¯ä»¥ä¿å­˜ä¸‹æ¥å­é—®é¢˜ï¼Œå‡å°‘æ—¶é—´å¤æ‚åº¦ã€‚å®žçŽ°çš„æ—¶å€™ï¼Œä¸¤ä¸ªlist åˆ†åˆ«ä»Žå·¦å³ä¸¤è¾¹è¿›è¡Œç´¯ä¹˜è¿ç®—ã€‚æ‰€ä»¥ç¬¬äºŒç§è§£æ³•ï¼šæ—¶é—´å¤æ‚åº¦ä»Ž $O(n^2) $ é™ä½Žä¸º $ O(n)$ ã€‚ä»Žåšé¢˜çš„ç»“æžœä¸Šçœ‹ï¼Œå¦‚æžœæœ€åŽæ±‚è§£çš„æ˜¯ä¸€ä¸ªå€¼ï¼Œé‚£ä¹ˆå¾ˆæœ‰å¯èƒ½ä½¿ç”¨ $O(1) $ çš„ç©ºé—´å¤æ‚åº¦å¾—åˆ°ã€‚â€‹1234567891011121314151617class Solution &#123;public: // ç®€å•ç²—æš´çš„è§£æ³•ï¼Œåœ¨éåŽ†çš„è¿‡ç¨‹ä¸­éœ€è¦ç»´æŠ¤ minv å’Œmaxv int maxProduct(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; int n =nums.size(); int minv =nums[0], maxv =nums[0], res =nums[0]; for(int i =1; i&lt; n; i++) &#123; int nv =minv, xv =maxv; maxv =max(nums[i], max(nums[i]* nv, nums[i] * xv)); minv =min(nums[i], min(nums[i] * nv, nums[i] * xv)); res =max(res, maxv); &#125; return res; &#125;&#125;; æœ€é•¿é€’å¢žå­åºåˆ— ç¬¬ä¸€ç§æ–¹å¼ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ O($n^2$),æ€æƒ³æ˜¯dp. dp[i] è¡¨ç¤º åˆ°ç›®å‰ä¸ºæ­¢å‰i ä¸ªæ•°å­—ä¸­çš„ æœ€é•¿é€’å¢žå­åºåˆ—ã€‚ 12345678910111213141516171819202122232425class Solution &#123;public: // O(m^2) çš„æ—¶é—´å¤æ‚åº¦ï¼Œdp[i] è¡¨ç¤ºå‰i ä¸ªæ•°å­—æœ€é•¿çš„é€’å¢žå­åºåˆ—çš„é•¿åº¦ // é€’æŽ¨æ–¹ç¨‹æ˜¯ dp[i] =max(dp[j] +1) å…¶ä¸­ j&lt; iï¼Œ å¹¶ä¸” nums[i] &gt; nums[j] // åˆå§‹åŒ– dp =&#123;1&#125; å› ä¸ºå¦‚æžœåªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆdp[0] =1 int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; int n =nums.size(); vector&lt;int&gt;dp(n, 1); int res =0; for(int i =0; i&lt; n; i++) &#123; // éåŽ†å‰é¢çš„æ‰€æœ‰dp[j] for(int j =0; j&lt;i; j++) &#123; if(nums[i] &gt; nums[j]) &#123; dp[i] =max(dp[i], dp[j] +1); &#125; &#125; res =max(res, dp[i]); &#125; return res; &#125;&#125;; python å®žçŽ° 12345678910111213141516class Solution(object): def lengthOfLIS(self, nums): """ :type nums: List[int] :rtype: int """ if(not nums) : return 0; n =len(nums) dp =[1] *n res =0 for i in range(n): for j in range(0, i): if(nums[i] &gt; nums[j]): dp[i] =max(dp[i], dp[j] +1) res =max(res, dp[i]) return res ä¸Šé¢çš„æ—¶é—´å¤æ‚åº¦æ˜¯O($ n^2$), åœ¨äºŽæ¯æ¬¡éƒ½æ˜¯éåŽ†äº†ä¹‹å‰æ‰€æœ‰çš„æƒ…å†µ (dp) ï¼Œè¿˜æœ‰ä¸€ç§æ–¹å¼åˆ›å»ºä¸€ä¸ªè¾…åŠ©æ•°ç»„ï¼Œç”¨äºŽå­˜å‚¨ä¹‹å‰å·²ç»æŽ’å¥½åºçš„å…ƒç´ ï¼ŒéåŽ†çš„æ—¶å€™ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾è¿›è¡ŒéåŽ†ã€‚äºŽæ˜¯ç¬¬äºŒç§è§£æ³•å°±å‡ºæ¥äº†ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ O(n logn). è¿™ä¸ªè¾…åŠ©å‡½æ•°ä¸æ˜¯ä»ŽåŽŸæ¥çš„æ•°ç»„ä¸æ˜¯æœ€é•¿å¢žæ•°ç»„æœ¬èº«ï¼Œè¿™ä¸ªå‡½æ•°åªèƒ½ç”¨äºŽè®¡ç®—æœ€åŽçš„é•¿åº¦ï¼Œå¾—ä¸åˆ°æ•°ç»„ã€‚ 123456789101112131415161718192021222324252627282930class Solution &#123;public: int binary_search(vector&lt;int&gt; &amp;h, int l, int r, int target) &#123; while(l&lt;r) &#123; int mid = l +r &gt;&gt;1; if(h[mid] &lt; target) l =mid +1; else r =mid; &#125; return l; &#125; int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; int n =nums.size(); vector&lt;int&gt; h(n, 0); h[0] =nums[0]; int index =0; for(int i =1; i&lt;n; i++) &#123; if(nums[i] &gt; h[index]) h[++index] =nums[i]; else &#123; int pos =binary_search(h, 0, index, nums[i]); h[pos] =nums[i]; &#125; &#125; return index+1; &#125;&#125;; æ•°ç»„å¾ªçŽ¯ç§»ä½ æš´åŠ›æ±‚è§£ æ—¶é—´å¤æ‚åº¦æ˜¯O($KN$) Kè¡¨ç¤ºç§»ä½çš„æ¬¡æ•° N è¡¨ç¤ºæ•°ç»„çš„é•¿åº¦ã€‚åœ¨c++ä¸­ï¼Œæ•°ç»„å¦‚æžœæ˜¯ä¸€ä¸ªä¸ªç§»ä½ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦æ˜¯$O(kn)$ï¼Œ ä½†æ˜¯å¦‚æžœæ˜¯ä¸¤ä¸¤äº¤æ¢ä½ç½®ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦æ˜¯$O(n)$ï¼Œæ‰€ä»¥è¿™ä¸ªæ˜¯æœ‰ä¼˜åŒ–çš„ç©ºé—´çš„ã€‚ C++ è§£æ³• 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;void rightShift(vector&lt;int&gt; arr, int n , int k)&#123; if (arr.empty() or arr.size() ==0) return ; if (k&gt;n) k =k%n; while(k --) &#123; int temp =arr[n-1]; for(int i =n-1; i&gt;0; i--) arr[i] =arr[i-1]; arr[0] =temp; &#125; &#125;int main()&#123; return 0;&#125; Cè¯­è¨€è§£æ³• 123456789101112131415161718void rightShift(int *arr, int n, int k)&#123; if (arr ==NULL or n ==0) return ; if (k&gt;n) k =k%n; while(k --) &#123; int temp =arr[n-1]; for (int i =n-1; i&gt;0; i--) &#123; arr[i] =arr[i-1]; &#125; arr[0] =temp; &#125;&#125; è§£æ³•äºŒï¼š åŽŸæ¥åºåˆ— abcd1234 è½¬æ¢æˆ 1234abcd ï¼Œåˆ†æˆä¸¤éƒ¨åˆ†ï¼Œ 1234 å’Œabcd çœ‹æˆä¸¤ä¸ªæ•´ä½“ï¼Œå³ç§»å°±æ˜¯æŠŠæ•°ç»„çš„ä¸¤ä¸ªéƒ¨åˆ†äº¤æ¢ä¸€ä¸‹é€šè¿‡ä»¥ä¸‹çš„æ–¹æ³•è¿›è¡Œå®žçŽ°ï¼Œ é€†åº1234, é€†åºabcd , é€†åºæ•´ä¸ªæ•°ç»„, æ•´ä¸ªarr çš„ reverse æ—¶é—´å¤æ‚åº¦ï¼šè¿™ä¸ªä¸æ˜¯é€’å½’ï¼Œåªæ˜¯åŒä¸€ä¸ªå‡½æ•°è°ƒç”¨äº†ä¸‰æ¬¡ï¼Œæ—¶é—´å¤æ‚åº¦åˆ†åˆ«æ˜¯ O($ \frac{k}{2}$), O( $\frac{N-k}{2}$) å’Œ O($\frac{N}{2}$)ï¼Œæ‰€ä»¥æ€»çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(N) 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;const int N =101;int n, k;void reverse(char *arr, int b, int e)&#123; while( b&lt;e) &#123; int t =arr[e]; arr[e] =arr[b]; arr[b] =t; b ++; e --; &#125;&#125;void right_shift(char *arr, int n, int k)&#123; k %=n; reverse(arr, 0, n-k -1); reverse(arr, n-k, n -1); reverse(arr, 0, n -1);&#125;int main()&#123; char arr[N]; scanf("%d %d", &amp;n, &amp;k); gets(arr); right_shift(arr, n, k); puts(arr); return 0;&#125; æ•°ç»„åˆ†å‰²?é¢˜ç›®æ¦‚è¿°ï¼šæœ‰ä¸€ä¸ªæ²¡æœ‰æŽ’åºï¼Œå…ƒç´ ä¸ªæ•°ä¸º2Nçš„æ­£æ•´æ•°æ•°ç»„ã€‚è¦æ±‚æŠŠå®ƒåˆ†å‰²ä¸ºå…ƒç´ ä¸ªæ•°ä¸ºNçš„ä¸¤ä¸ªæ•°ç»„ï¼Œå¹¶ä½¿ä¸¤ä¸ªå­æ•°ç»„çš„å’Œæœ€æŽ¥è¿‘ã€‚ è¿™é‡Œçš„dp[k][s]è¡¨ç¤ºä»Žå‰kä¸ªæ•°ä¸­å–kä¸ªæ•°ï¼Œä¸”kä¸è¶…è¿‡nï¼Œä¸”è¿™äº›æ•°ä¹‹å’Œä¸ºsçš„å–æ³•æ˜¯å¦å­˜åœ¨ã€‚ ç®—æ³•æ—¶é—´å¤æ‚åº¦æ˜¯ $O(N^2*sum)$ è®²è§£å¯ä»¥å‚è€ƒè¿™ä¸ªï¼Œåæ­£æˆ‘æ˜¯æ²¡æœ‰å¾ˆçœ‹åŠ¨ç”»https://blog.csdn.net/linyunzju/article/details/7729774 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define MAXN 101#define MAXSUM 100000int A[MAXN];bool dp[MAXN][MAXSUM];// ä½¿ç”¨å…¨å±€å˜é‡ è§£å†³å®šä¹‰äºŒç»´çš„æ•°ç»„çš„é—®é¢˜void find(int *a, int n, int sum)&#123; int k1, k2, s; for (k1 =1; k1&lt;2*n; k1++) &#123; for(k2 =min(k1, n) ;k2&gt;=1; k2--) &#123; for(s =1; s&lt;=sum/2; s++) &#123; if (s &gt;=A[k1] &amp;&amp; dp[k2-1][s-A[k1]]) dp[k2][s] =true; &#125; &#125; &#125; for (s =sum/2; s&gt;=1 &amp;&amp; !dp[n][s] ; s--) &#123; cout &lt;&lt; sum-2*s&lt;&lt; endl; &#125;&#125;int main()&#123; int n, i; cin &gt;&gt; n; for(i=1; i&lt;=2*n; i++) &#123; cin &gt;&gt; A[i]; &#125; int sum =0; for (i =1; i&lt;=2*n; i++) &#123; sum += A[i]; &#125; memset(A, 0, sizeof(dp)); dp[0][0] =true; find(A, n, sum); return 0;&#125; åªè€ƒåŠ æ³•çš„é¢è¯•é¢˜ å†™ä¸€ä¸ªç¨‹åºï¼Œå¯¹äºŽä¸€ä¸ª 64ä½æ­£æ•´æ•°ï¼Œè¾“å‡ºæ‰€æœ‰å¯èƒ½çš„è¿žç»­ï¼ˆä¸¤ä¸ªä»¥ä¸Šï¼‰è‡ªç„¶æ•°ä¹‹å’Œçš„ç®—å¼ å› ä¸ºè¿™é‡Œæ¶‰åŠåˆ°äº†è¿žç»­è‡ªç„¶æ•°ï¼Œé‚£ä¹ˆä¸€å®šè¦ä½¿ç”¨ç­‰å·®æ•°åˆ—ï¼Œç„¶åŽè¿›è¡Œæžšä¸¾ã€‚åœ¨æ—¶é—´å¤æ‚åº¦ O(n) å†…è§£å†³é—®é¢˜ã€‚ æ•°å­¦é—®é¢˜ è®¾å­˜åœ¨è¿žç»­è‡ªç„¶æ•°ï¼Œé¦–é¡¹ä¸º$A_1$ï¼Œé¡¹æ•°ä¸ºmï¼Œå³$$ A_1 + A_2 + \ldots + A_m = { M }$$ ä½¿ç”¨æ±‚å’Œå…¬å¼ $$A_1 \times m + \frac{m \times ( m - 1 )}{2} = M$$å¯ä»¥æ•´ç†å¾—åˆ°å…³äºŽ $m$ çš„ä¸€å…ƒäºŒæ¬¡æ–¹ç¨‹æ–¹ç¨‹ $$ m^2 +2\times( A_1 -1) \times m -2 \times M =0$$ è§£å¾— $$m = \frac{ (1- 2 \times A_1) \pm \sqrt{( 4*(A_1-1)^2 +8 \times M}}{2}$$ æ‰€ä»¥è¦æ±‚ m æ˜¯æ•´æ•°ï¼Œé‚£ä¹ˆéœ€è¦æ»¡è¶³ä¸¤ä¸ªæ¡ä»¶ï¼š $\sqrt{( 4*(A_1-1)^2 +8 \times M}$ æ˜¯æ•´æ•° æ•´ä¸ªåˆ†å­æ˜¯å¶æ•° 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; int n; while (cin &gt;&gt; n) &#123; for (int i =0; i&lt;n/2; i ++) &#123; int a =i; int w =(2*a -1)*(2*a -1) +8*n; int k =(int)sqrt(w); if (k*k != w) continue; int m =k +1-2*a; if (m%2 ==1) continue; else cout &lt;&lt; i &lt;&lt; " "&lt;&lt;i+m/2-1 &lt;&lt; endl; &#125; &#125; return 0;&#125; å­—ç¬¦ä¸²ç§»ä½åŒ…å«çš„é—®é¢˜ è¿™ç§ç§»ä½å¹¶æ²¡æœ‰è¯´æ˜Žæ€Žä¹ˆç§»ä½ï¼Œç„¶åŽç§»åŠ¨å‡ ä½ï¼Œæ‰€ä»¥åº”è¯¥æ˜¯ä¸èƒ½æ¨¡æ‹Ÿå‡ºæ¥çš„ï¼Œä¸‹é¢æ˜¯æœ‰ä¸€ä¸ªæ—¢å®šçš„ç»“è®ºï¼Œå¦‚æžœåœ¨ç§»ä½ä¸­åŒ…å«ï¼Œé‚£ä¹ˆä¸€å®šæ˜¯åœ¨ strstr è¿™ä¸ªä¸­çš„ã€‚äºŽæ˜¯è§£æ³•ä¸€å°±å‡ºæ¥äº†ã€‚ è¡¥å……cpp çš„ä¸€äº›è¯­æ³•ï¼š 1 å’Œtrueæ˜¯ç­‰ä»·çš„ å­—ç¬¦ä¸²å’Œå­—ç¬¦æ•°ç»„çš„å®šä¹‰å’Œåˆå§‹åŒ– ç›´æŽ¥è¿›è¡Œåˆå§‹åŒ–å®šä¹‰ï¼š12char *a ="string1";char b[] ="string2"; å±€éƒ¨å˜é‡ a b éƒ½æ˜¯åœ¨æ ˆä¸­ï¼Œa æ˜¯æŒ‡å‘äº†ä¸€ä¸ªå¸¸äº®ï¼Œ â€œstring1â€ è€Œb æ˜¯æŒ‡å‘äº†äº†ä¸€ä¸ªæ•°ç»„ã€‚å®žé™…ä¸Šå‰è€…çš„èµ‹å€¼æ˜¯é”™è¯¯çš„ï¼Œå› ä¸ºæ˜¯å…¶å®žä¸å¯æ”¹å˜çš„ã€‚ä½¿ç”¨ const char * a=â€string1â€ æ›´åŠ åˆé€‚ã€‚char ç±»åž‹è½¬æ¢æˆ stringç±»åž‹ cpp ä¸­ä½¿ç”¨ string ç¬¬ä¸€ç§æ–¹å¼ 12345678910#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; string str; str ="hello world"; cout &lt;&lt; str &lt;&lt;endl; return 0;&#125; è¿™ç§æ˜¯ cpp ä¸­ä½¿ç”¨string çš„ç¬¬äºŒç§æ–¹å¼ 1234567891011#include&lt;iostream&gt;using namespace std;int main()&#123; std:: string str; str ="hello world"; cout &lt;&lt; str &lt;&lt;endl; return 0;&#125; é—®é¢˜çš„è§£æ³•ï¼š 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;bool isContain(char *s1, char *s2) &#123; int len = strlen(s1); //å‡è®¾s1ä½è¾ƒé•¿çš„å­—ç¬¦ä¸² char s[len * 2]; for(int i = 0; i &lt; 2; i++) &#123; for(int j = 0; j &lt; len; j++) &#123; s[i * len + j] = s1[j]; &#125; &#125; if(strstr(s, s2) != NULL) &#123; return true; &#125; else &#123; return false; &#125;&#125;int main()&#123; char* s1 ="hello"; char* s2 ="hel"; bool result; result =isContain(s1, s2); cout &lt;&lt; isContain(s1, s2) &lt;&lt;endl; return 0;&#125; è§£æ³•äºŒï¼š python å®žçŽ°ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯O(n) ç©ºé—´å¤æ‚åº¦æ˜¯(1) ï¼Œä½¿ç”¨å–æ¨¡è¿ç®— 123456789101112131415161718192021def match(src, des): if not src or not des: return False len1 =len(src) len2 =len(des) if len1 ==0 and len2 ==0: return True for i in range(len1): if des[0] == src[i]: for j in range(1, len2): if des[j] != src[ (i+j)%len1]: break else: return True return False Letter Combinations of a Phone Number è¿™ä¸ªæ˜¯åšè¿‡çš„ï¼Œæ·±åº¦ä¼˜å…ˆç®—æ³• 12345678910111213141516171819202122232425262728293031323334class Solution: def letterCombinations(self, digits): if not digits or digits == "": return [] # å‘½åå¾ˆåˆ°ä½ï¼Œä»»ä½•çš„dictionary éƒ½æ˜¯å¯ä»¥ä½¿ç”¨ maps è¿›è¡Œå‘½åçš„ # æ³¨æ„ä»Ž list åˆ°tuple å‡å°‘äº†å†…å­˜çš„ä½¿ç”¨ maps =&#123; '1': (), '0': (), '2': ('a', 'b', 'c'), '3': ('d', 'e', 'f'), '4': ('g', 'h', 'i'), '5': ('j', 'k', 'l'), '6': ('m', 'n', 'o'), '7': ('p', 'q', 'r', 's'), '8': ('t', 'u', 'v'), '9': ('w', 'x', 'y', 'z') &#125; results = [""] for digit in digits: tuple1 = maps[digit] tmp =[] if len(tuple1) == 0: continue # äºŒé‡å¾ªçŽ¯ï¼Œ results æ˜¯ä¹‹å‰çš„ç»“æžœï¼Œç„¶åŽæ¯æ¬¡éƒ½æ˜¯è¦åœ¨å…¶åŸºç¡€ä¸Šæ·»åŠ ä¸€äº›ä¸œè¥¿ for prefix in results: for suffix in tuple1: tmp.append(prefix + suffix) results = tmp return results æ±‚ä¸€ç»´å­æ•°ç»„çš„æœ€å¤§å’Œ é¢˜ç›®ï¼šè¾“å…¥ä¸€ä¸ªæ•´å½¢æ•°ç»„ï¼Œæ•°ç»„é‡Œæœ‰æ­£æ•°ä¹Ÿæœ‰è´Ÿæ•°ã€‚æ•°ç»„ä¸­è¿žç»­çš„ä¸€ä¸ªæˆ–å¤šä¸ªæ•´æ•°ç»„æˆä¸€ä¸ªå­æ•°ç»„ï¼Œæ¯ä¸ªå­æ•°ç»„éƒ½æœ‰ä¸€ä¸ªå’Œã€‚æ±‚æ‰€æœ‰å­æ•°ç»„çš„å’Œçš„æœ€å¤§å€¼ã€‚è¦æ±‚æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ã€‚ ä½¿ç”¨äº† $O(n)$ çš„ç©ºé—´ï¼Œå¯ä»¥ä¼˜åŒ–æˆ $O(1)$ çš„ç©ºé—´ 1234567891011121314151617class Solution &#123;public: // æ³¨æ„è½¬ç§»æ–¹ç¨‹æ˜¯ dp[i] =max(dp[i-1]+ nums[i], nums[i]) int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n =nums.size(); vector&lt;int&gt; dp(n, 0); dp[0] =nums[0]; int res =nums[0]; for(int i =1; i&lt; n; i++) &#123; // å› ä¸ºå¯èƒ½å‡ºçŽ°è´Ÿæ•°çš„æƒ…å†µ dp[i] =max(dp[i-1] + nums[i], nums[i]); res =max(dp[i], res); &#125; return res; &#125;&#125;; 12345678910111213141516class Solution &#123;public: // æ³¨æ„è½¬ç§»æ–¹ç¨‹æ˜¯ dp[i] =max(dp[i-1]+ nums[i], nums[i]) int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n =nums.size(); int max_v =INT_MIN; int t =0; // å¼€å§‹çš„æ—¶å€™è¦åˆå§‹åŒ–å¥½ for(auto num : nums) &#123; t +=num; max_v =max(max_v, t); t =max(0, t); &#125; return max_v; &#125;&#125;; äºŒç»´å­æ•°ç»„æœ€å¤§å’ŒTips: é€šè¿‡æžšä¸¾çŸ©é˜µçš„ä¸Šä¸‹ç•Œï¼Œç„¶åŽå†ç”¨ä¸€ç»´æƒ…å†µçš„æ–¹æ³•ç¡®å®šå·¦å³è¾¹ç•Œï¼Œå°±å¯ä»¥å¾—åˆ°äºŒç»´é—®é¢˜çš„è§£ã€‚äºŒç»´æ•°ç»„æ˜¯$ (m \times n) $ï¼Œ é‚£ä¹ˆè¯¥æ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O( n^2 \times m) $.å½“ç„¶ä¹Ÿå¯ä»¥æžšä¸¾å·¦å³è¾¹ç•Œï¼Œç„¶åŽä½¿ç”¨ä¸€ç»´æƒ…å†µåŽ»ç¡®å®šä¸Šä¸‹ç•Œï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦æ˜¯ $ O( m \times n \times min(m ,n) )$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;ctime&gt;using namespace std;#define M 4#define N 4#include &lt;memory.h&gt;int maxSubArray(int *arr, int len) //æœ€å¤§å­åºåˆ—å’Œ&#123; int i, sum = arr[0], b = 0; for (i = 0; i&lt;len; ++i) &#123; if (b&gt;0) b += arr[i]; else b = arr[i]; if (b&gt;sum) sum = b; &#125; return sum;&#125;int maxSubMatrix(int n, int m, int array[M][N])&#123; int i, j, h, max, sum = -100000; int b[100]; for (i = 0; i &lt; n; i++) &#123; memset(b, 0, sizeof(b)); //åˆå§‹åŒ–b[] for (j = i; j &lt; n; j++) //æŠŠç¬¬iè¡Œåˆ°ç¬¬jè¡Œç›¸åŠ ,å¯¹æ¯ä¸€æ¬¡ç›¸åŠ æ±‚å‡ºæœ€å¤§å€¼ &#123; for (h = 0; h&lt;m; h++) &#123; b[h] += array[j][h]; //äºŒç»´æ•°ç»„åŽ‹ç¼©æˆä¸€ç»´æ•°ç»„ï¼Œç„¶åŽæ±‚æœ€å¤§å­åºåˆ—å’Œ &#125; max = maxSubArray(b, h); if (max&gt;sum) sum = max; &#125; &#125; return sum;&#125;int main()&#123; int arr[M][N] = &#123; &#123; -15, -21,5, -12 &#125;, &#123; -7, 21, 20, 12 &#125;, &#123; 21, 0, -1, 13 &#125;, &#123; 10, 20, -10, -18 &#125; &#125;; cout &lt;&lt; "éšæœºäºŒç»´æ•°ç»„ä¸ºï¼š" &lt;&lt; endl; //srand(time(0)); //for (int i = 0; i &lt; M; i++) //&#123; // for (int j = 0; j &lt; N; j++) // &#123; // arr[i][j] = rand() % 50 - 25; // cout &lt;&lt; arr[i][j] &lt;&lt; " "; // &#125; // cout &lt;&lt; endl; //&#125; cout &lt;&lt; maxSubMatrix(M, N, arr) &lt;&lt; endl; system("pause"); return 0;&#125; ä½¿ç”¨C++ ä¸­çš„vector è¿›è¡Œæ”¹å†™ï¼Œæ€è·¯æ­£ç¡®ï¼Œä½†ç»“æžœå‡ºé”™ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;#define M 4#define N 4#define MAX 100000int maxSubarray2(vector&lt;int&gt; arr, int n)&#123; int max_num= -MAX; int cur_num =0; for (int i =0; i&lt;n; i++) &#123; cur_num += arr[i]; if (cur_num &lt; 0) cur_num =0; if( cur_num &gt; max_num) max_num =cur_num; &#125; // è¿™ä¸ªæ­¥éª¤æ˜¯å¤„ç†æ•´æ•°ä¸­æœ‰æ­£æœ‰è´Ÿçš„æƒ…å†µ /* if (max_num ==0) &#123; max_num =arr[0]; for(int i =1; i&lt;n;i ++) if (arr[i] &gt;max_num) max_num =arr[i]; &#125; */ return max_num;&#125;int maxSubmatrix(int rows, int cols, vector&lt;vector&lt;int&gt;&gt; arr)&#123; int i, j, k, max=arr[0][0], sum =-10000; vector&lt;int&gt; b; for (i =0;i&lt; rows;i++) &#123; vector &lt;int&gt; b(cols, 0) ; for (j =i; j&lt; rows; j++) &#123; for(k =0;k &lt;cols;k++) b[k] += arr[j][k]; sum =maxSubarray2(b, k); if(sum &gt; max) max =sum; &#125; &#125; return max;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; arr = &#123; &#123; -15, -21,5, -12 &#125;, &#123; -7, 21, 20, 12 &#125;, &#123; 21, 0, -1, 13 &#125;, &#123; 10, 20, -10, -18 &#125; &#125;; //cout &lt;&lt; arr[1][1]&lt;&lt;endl; cout &lt;&lt; maxSubmatrix(M, N, arr) &lt;&lt; endl; vector&lt;int&gt; tmp =&#123;2, 0, -4, 9, -1,2&#125;; cout &lt;&lt; tmp.size()&lt;&lt;endl; cout&lt;&lt; maxSubarray2(tmp, tmp.size())&lt;&lt; endl; return 0;&#125; æŠŠip åœ°å€è½¬æ¢æˆå”¯ä¸€çš„æ˜ å°„å…³ç³»ã€‚ 12345678910111213141516171819202122232425262728293031323334353637# æ–¹æ³•ä¸€# è¿™ä¸ªå®žé™…ä¸Šæ˜¯è½¬æˆäº†å¤§æ•´æ•°,æ¯”å¦‚ 0.0.0.0 è½¬æˆ 0; 255.255.255.255 è½¬æˆ 255255255255def fun2(str): res =0 for i in range(4): tmp =str[i*3:(i+1)*3] res = res*1000+ int(tmp) return resdef fun1(str): if len(str)&gt;3 or len(str) ==0: return -1; if len(str) ==3: return str if len(str) ==2: return "0"+str if(len(str) ==1): return "00"+strdef str2int(str): str1 =str.split(".") if len(str1) != 4: return -1 res ="" for i in range(4): res += fun1(str1[i]) print("to string", res) res2 =fun2(res) print("to int ", res2)if __name__ =="__main__": str =input() str2int(str)]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Titanic Challenge]]></title>
    <url>%2F2018%2F02%2F05%2FTitanic-Challenge%2F</url>
    <content type="text"><![CDATA[ç”¨æ­¤åšå®¢è®°å½•è‡ªå·±è§£å†³ Kaggle Titanic challengeè¿‡ç¨‹ä¸­çš„ä¸ªäººæ€»ç»“ã€‚ é—®é¢˜æè¿°è¯´é“Titanic(æ³°å¦å°¼å…‹å·)ï¼Œæœ€ç†Ÿæ‚‰èŽ«è¿‡äºŽTitanic(1997 film),è¿™éƒ¨ç”±è‘—åå¯¼æ¼”è©¹å§†æ–¯Â·å¡æ¢…éš†æ‰§å¯¼ï¼ŒèŽ±æ˜‚çº³å¤šÂ·è¿ªå¡æ™®é‡Œå¥¥ã€å‡¯ç‰¹Â·æ¸©æ–¯èŽ±ç‰¹é¢†è¡”ä¸»æ¼”çš„ç”µå½±ï¼Œç»ä¹…ä¸è¡°â€¦ä½†æ˜¯æˆ‘ä»¬ä»Šå¤©çš„ç”»é£Žä¸æ˜¯è¿™æ ·çš„â€¦ æˆ‘ä»¬ä»Šå¤©è§£å†³çš„é—®é¢˜æ˜¯ä»¥è¯¥äº‹ä»¶é—®èƒŒæ™¯ï¼Œä½†æ˜¯æ²¡æœ‰é‚£ä¹ˆæµªæ¼«ã€‚å…³äºŽè¿™ä¸ªæ¡ˆä¾‹çš„ä»‹ç»ç½‘ä¸Šæœ‰å¾ˆå¤šå†…å®¹ï¼Œä¸ºäº†é¿å…ç´¯èµ˜ï¼Œåœ¨è¿™é‡Œå°±ä¸è¿›è¡Œè¯¦è¿°ã€‚æ€»çš„è¦æ±‚ï¼šé¢„æµ‹åœ¨è¿™ä¸ªäº‹ä»¶ä¸­ä¹˜å®¢æ˜¯å¦æ­»äº¡ã€‚é™„ä¸Šå¯¹äºŽtrain setså’Œ test setsä¸­æ•°æ®çš„ä»‹ç»ã€‚æ›´å¤šè¯¦ç»†çš„å†…å®¹å‚çœ‹ï¼šhttps://www.kaggle.com/c/titanic æ•°æ®åˆ†æžé¡ºæ»‘è¿‡æ¸¡åˆ°ç¬¬äºŒé˜¶æ®µï¼Œæ•°æ®åˆ†æžï¼Œå¯¹äºŽç«žèµ›è€Œè¨€ï¼Œæˆ‘æ„Ÿè§‰å¯¹äºŽæ•°æ®çš„è®¤è¯†çš„é‡è¦æ€§å®Œå…¨ä¸äºšäºŽæ¨¡åž‹çš„é‡è¦æ€§ã€‚ä¹‹åŽæˆ‘ä»¬å°†å†æ¬¡æåˆ°è¿™å¥è¯ã€‚æˆ‘å°†ç»“åˆä»£ç è¿›è¡Œæ•°æ®åˆ†æžã€‚ pandas åŽŸç”Ÿæ•°æ®åˆ†æžå‡½æ•°1234import pandas as pdtrain =pd.read_csv(&apos;data/train.csv&apos;)test =pd.read_csv(&apos;data/test.csv&apos;)train.describe(include=&apos;all&apos;) é™¤äº†ä¸Šé¢ train.describe()ï¼Œä¸‹é¢è¿™ä¸¤ä¸ªä¹Ÿæ˜¯æ¯”è¾ƒå¸¸ç”¨çš„12train.head()train.columns å› ä¸ºæ€»ä½“çš„æ•°æ®é‡æ¯”è¾ƒå°‘ï¼Œæ‰€ä»¥æˆ‘ä»¬é€‰æ‹©æŠŠtrain set å’Œtest setè¿žæŽ¥èµ·æ¥è¿›è¡Œæ•°æ®åˆ†æžå’Œå¤„ç†ã€‚1combined2 = pd.concat([train_data, test_data], axis=0) æ•°æ®è´¨é‡åˆ†æž ç¼ºçœå€¼å¯¹äºŽç¼ºçœå€¼ï¼Œå¸¸ç”¨çš„æ‰‹æ®µå°±æ˜¯å¡«å……ï¼Œä½†æ˜¯é’ˆå¯¹ä¸åŒçš„æ•°æ®æœ‰ä¸åŒçš„å¡«å……æ‰‹æ®µï¼Œæœ‰çš„æ˜¯å‡å€¼å¡«å……ï¼Œæœ‰çš„æ˜¯é»˜è®¤å€¼å¡«å……è¿˜æœ‰çš„æ˜¯æ ¹æ®çŽ°æœ‰æ•°æ®è®­ç»ƒä¸€ä¸ª regressionè¿›è¡Œæ‹Ÿåˆ(è¿™ç§æƒ…å†µå‡ºçŽ°åœ¨ç¼ºçœçš„æ•°æ®æ¯”è¾ƒé‡è¦ï¼Œå¯¹äºŽç»“æžœçš„é¢„æµ‹æœ‰æ¯”è¾ƒå¼ºçš„ç›¸å…³æ€§çš„æ—¶å€™)ã€‚1combined2.Embarked.fillna(&apos;S&apos;, inplace=True) Embardked(ä¸Šèˆ¹æ¸¯å£)ä¸æ˜¯é‚£ä¹ˆèƒ½è¡¨çŽ°å‡ºå’Œç»“æžœ(survival)ç›¸å…³çš„å˜é‡ï¼Œæˆ‘ä¹ˆå¯ä»¥ç›´æŽ¥é‡‡ç”¨æŸä¸ªé»˜è®¤å€¼è¿›è¡Œå¡«å……ã€‚1combined2.Fare.fillna(np.median(combined2.Fare[combined2.Fare.notnull()]), inplace=True) Fare(èˆ¹ç¥¨)æˆ‘ä»¬é€‰æ‹©ä½¿ç”¨å‡å€¼å¡«å…… 12345678classers = [&apos;Fare&apos;,&apos;Parch&apos;,&apos;Pclass&apos;,&apos;SibSp&apos;,&apos;TitleCat&apos;,&apos;CabinCat&apos;,&apos;Sex_female&apos;,&apos;Sex_male&apos;, &apos;EmbarkedCat&apos;, &apos;FamilySize&apos;, &apos;NameLength&apos;, &apos;FamilyId&apos;]age_et = ExtraTreesRegressor(n_estimators=200)X_train = full_data.loc[full_data.Age.notnull(),classers]Y_train = full_data.loc[full_data.Age.notnull(),[&apos;Age&apos;]]X_test = full_data.loc[full_data.Age.isnull(),classers]age_et.fit(X_train,np.ravel(Y_train))age_preds = age_et.predict(X_test)full_data.loc[full_data.Age.isnull(),[&apos;Age&apos;]] = age_preds å› ä¸ºåœ¨ç‰¹å¾æå–çœ‹æ¥ age æ˜¯ä¸€ä¸ªæ¯”è¾ƒé‡è¦çš„å±žæ€§ï¼ˆä¸‹æ–‡ä¸­ä½¿ç”¨ageæ¥è¿›ä¸€æ­¥è®¡ç®—æ€§åˆ«ç‰¹å¾ï¼Œè€Œæ€§åˆ«ç‰¹å¾å¯¹äºŽsurvival æ˜¯é‡è¦çš„å› ç´ ï¼‰ï¼Œæ‰€ä»¥éœ€è¦é€šè¿‡ fitæ¥è¿›è¡Œå¡«å…… null å€¼ã€‚ å¼‚å¸¸å€¼å¼‚å¸¸å€¼çš„æ£€æµ‹12combined2.boxplot()plt.ylim(0, 1000) å¼‚å¸¸å€¼å¤„ç†å¤§å¤šæ•°æƒ…å†µä¸‹æˆ‘ä»¬éƒ½é‡‡å–å¿½è§†ï¼Œä½†æ˜¯æœ‰æ—¶å€™å¼‚å¸¸å€¼ä¸­å´è·Ÿç»“æžœæœ‰æ¯”è¾ƒå¼ºçš„ç›¸å…³æ€§ï¼Œæ¯”å¦‚è¯´è¯¥é¢˜ç›®åˆ†æ•°åœ¨0.9çš„ä¸€ä½å¤§ç¥žåœ¨åšå®¢ä¸­ä½¿ç”¨çš„ç‰¹å¾åŒ…å«åå­—é•¿åº¦ã€‚è¿™ä¸ªåœ¨æˆ‘ä¸€å¼€å§‹çš„ç‰¹å¾æå–ä¸­ç¡®å®žæ²¡æœ‰å¤ªåœ¨æ„åå­—é•¿åº¦ä¹Ÿå¯ä»¥å½“ä½œä¸€ç§å’Œç»“æžœ(servival or dead)ç›¸å…³çš„ç‰¹å¾ã€‚ é‡å¤å€¼é‡å¤å€¼çš„æ£€æµ‹1train[train.duplicated()==True] å¦‚æžœè¿è¡Œç»“æžœä¸ºç©ºï¼Œé‚£ä¹ˆå°±æ˜¯æ²¡æœ‰é‡å¤å€¼,å¦‚æžœæœ‰é‡å¤å€¼ï¼Œä¸€èˆ¬ä½¿ç”¨ä¸‹é¢ç±»ä¼¼çš„ä»£ç éƒ½æ˜¯å¯ä»¥åŽ»é™¤æŽ‰çš„ã€‚1df.drop_duplicates() åˆ†å¸ƒç‰¹å¾åˆ†æž1234567#åˆ†å¸ƒåˆ†æžfig ,ax =plt.subplots(2,2, figsize=(8,6))sns.countplot(&apos;Embarked&apos;, data =train, ax =ax[0,0])sns.countplot(&apos;Pclass&apos;, data =train, ax =ax[0,1])sns.violinplot(&apos;Survived&apos;, &apos;Age&apos;, data= train, ax =ax[1,0]).set(ylim =(-10, 80))sns.countplot(x =&apos;Survived&apos;, data= train, ax =ax[1,1])plt.tight_layout() è¿è¡Œéœ€è¦å¯¼å…¥ seaborn1import seaborn as sns è¿™é‡Œå®‰åˆ©ä¸€ä¸ªæ•°æ®å¯è§†åŒ–å·¥å…·-seabornã€‚å›žæ­£é¢˜ counplot()å¯ä»¥ç›´è§‚çš„çœ‹å‡ºå•ä¸ªæ•°æ®çš„ç‰¹å¾ï¼Œä½†æ˜¯æˆ‘ä»¬æ›´åŠ å…³å¿ƒçš„æ˜¯æ•°æ®å’Œæ•°æ®ä¹‹é—´çš„å…³ç³»ï¼Œæ›´å‡†ç¡®çš„æ˜¯æ•°æ®å’Œé¢„æµ‹æ•°æ®(survival )ä¹‹é—´çš„å…³ç³»ã€‚æ‰€ä»¥,æˆ‘ä»¬è¿›è¡Œç›¸å…³æ€§åˆ†æžã€‚123456plt.subplots(figsize=(10,8)) corrmat = train[train.columns[1:]].corr()sns.set(font_scale=1.5) hm = sns.heatmap(corrmat, cbar=True, annot=True, square=True, fmt=&apos;.2f&apos;, annot_kws=&#123;&apos;size&apos;: 10&#125;) plt.title(&apos;Pearson Correlation of Features&apos;, y=1.05, size=15) plt.show() ä»Žå›¾ä¸­å¯ä»¥çœ‹å‡ºï¼Œåœ¨åŽŸå§‹æ•°æ®é›†ç‰¹å¾ä¸­(ä¸ºä»€ä¹ˆè¿™ä¹ˆè¯´ï¼Œå—¯ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬ä¸‹æ–‡è¿˜è¦è¿›è¡Œ generate new features),Fareç‰¹å¾æ˜¯å’Œ survivalæœ€ç›¸å…³çš„ã€‚è¿™ä»Žæ•°æ®è§’åº¦è¿™ä½ èˆ¹ç¥¨ä»·é’±è¶Šé«˜ï¼Œä½ ç”Ÿå­˜çš„å‡ çŽ‡å°±è¶Šå¤§(ä¸‰è§‚å°½æ¯)ã€‚å—¯ï¼Œè¿™æ˜¯ç¬¦åˆç»æµŽç¤¾ä¼šçš„è¿è¡Œè§„å¾‹çš„ã€‚æˆ‘ä»¬åœ¨åˆ†æž Pearson Correlationçš„æ—¶å€™ï¼Œå…³æ³¨çš„æ˜¯æ•°å€¼çš„ç»å¯¹å€¼ï¼Œå¦‚æžœæ˜¯æ­£å€¼ï¼Œè¡¨ç¤ºæ­£ç›¸å…³ï¼›å¦‚æžœæ˜¯è´Ÿå€¼ï¼Œè¡¨ç¤ºè´Ÿç›¸å…³ã€‚ å¦‚æžœç»†å¿ƒçš„å°ä¼™ä¼´å‘çŽ°ï¼Œè¿™ä¸ªå¹¶æ²¡æœ‰æŠŠæ‰€æœ‰çš„å˜é‡çš„ç›¸å…³æ€§è¡¨ç¤ºå‡ºæ¥ï¼Œæ˜¯çš„ï¼Œä¸‹æ–‡æˆ‘å°†ç»™å‡ºä¸€ä¸ªåŠ å¼ºç‰ˆçš„ã€‚ ç‰¹å¾å·¥ç¨‹å½“æˆ‘ä»¬å¯¹æ•°æ®æœ‰äº†ä¸€ä¸ªåˆæ­¥çš„è®¤è¯†ï¼Œè¿™æ—¶å€™å°±å¯ä»¥è¿›è¡Œç‰¹å¾å·¥ç¨‹äº†ã€‚ç½‘ä¸Šæµä¼ å¾ˆå¹¿çš„ä¸€å¥è¯â€æ•°æ®ç‰¹å¾å†³å®šäº†æœºå™¨å­¦ä¹ çš„ä¸Šé™ï¼Œè€Œç®—æ³•ä¼˜åŒ–åªæ˜¯å°½å¯èƒ½é€¼è¿‘è¿™ä¸ªä¸Šé™â€ï¼Œæˆ‘æ·±æœ‰ä½“ä¼šã€‚å› ä¸ºä¹‹å‰è¿›è¡Œç‰¹å¾æå–ï¼Œç„¶åŽåœ¨kaggleçš„submission scoreæ˜¯0.73205,ç»è¿‡æ¨¡åž‹èžåˆç„¶åŽè¾¾åˆ°äº†0.78947ï¼Œæé«˜äº†5ä¸ªç™¾åˆ†ç‚¹ã€‚å½“è‡ªå·±åœ¨æ€è€ƒæ•°æ®ç‰¹å¾é‡æ–°è¿›è¡Œç‰¹å¾æå–çš„æ—¶å€™ï¼Œæœ€åŽçš„score æ˜¯0.82296.è¿™éƒ½æ˜¯ä»¥10ä¸ªç™¾åˆ†ç‚¹çš„æé«˜å•Šã€‚æ‰€ä»¥è¿™å¥è¯å¾ˆæœ‰é“ç†ï¼Œæˆ‘è¯•å›¾æ‰¾åˆ°è¿™å¥è¯çš„å‡ºå¤„ï¼Œä»¥è¡¨ç¤ºæˆ‘å¯¹äºŽç‰ˆæƒçš„å°Šé‡ï¼Œä½†æ˜¯ç§‘å­¦ä¸Šç½‘èƒ½åŠ›æœ‰é™ï¼Œæ²¡æœ‰æ‰¾è§ï¼Œä¹Ÿè®¸è¿™å¥è¯æ¥è‡ªç¾¤ä¼—çš„æ™ºæ…§å§ã€‚å›¾ï¼šæˆ‘åœ¨kaggle çš„submission å’Œç›¸åº”çš„score ä½†æ˜¯æˆ‘æƒ³å¼ºè°ƒçš„æ˜¯ç‰¹å¾æå–æ˜¯ä¸ªå¾ˆéš¾æœ‰æ¨¡æ¿åŒ–çš„ä¸œè¥¿ï¼Œè¿™å¾—çœ‹ä¸ªäººå¯¹äºŽè¿™ä¸ªé—®é¢˜çš„ç†è§£å’Œå¯¹äºŽæ•°æ®çš„ç†è§£ï¼Œå¯¹äºŽæ•°æ®å¼‚å¸¸å€¼çš„å¤„ç†ã€‚å¹¶ä¸”è¿˜æƒ³è¯´çš„æ˜¯è¿™ä¸ªä¸€ä¸ªè¿­ä»£çš„è¿‡ç¨‹ï¼Œä¸æ˜¯ä¸€æ­¥åˆ°ä½çš„ã€‚å½“åˆæ­¥æž„é€ å¥½è‡ªå·±ç‰¹å¾ä¹‹åŽå¯ä»¥ä½¿ç”¨å›¾å½¢åŒ–å·¥å…·è¿›è¡Œç®€å•çš„åˆ†æžä¸€ä¸‹ã€‚(ä¸‹å›¾æ˜¯æˆ‘ç¬¬ä¸€æ¬¡æž„é€ çš„ç‰¹å¾å·¥ç¨‹çš„å›¾å½¢åŒ–)12345678910111213141516171819def correlation_heatmap(df): _ , ax = plt.subplots(figsize =(14, 12)) colormap = sns.diverging_palette(220, 10, as_cmap = True) _ = sns.heatmap( df.corr(), cmap = colormap, square=True, cbar_kws=&#123;&apos;shrink&apos;:.9 &#125;, ax=ax, annot=True, linewidths=0.1,vmax=1.0, linecolor=&apos;white&apos;, annot_kws=&#123;&apos;fontsize&apos;:12 &#125; ) plt.title(&apos;Pearson Correlation of Features&apos;, y=1.05, size=15) train2 =train1.drop([&apos;NullCabin&apos;], axis =1)correlation_heatmap(train2) ä¸Šå›¾æ˜¯ç¬¬ä¸€æ¬¡ç‰¹å¾åˆ†æžçš„ç»“æžœ(kaggle score: 0.73205),survivalå’ŒPclasså’ŒFareæ˜¯æœ‰è¾ƒå¼ºçš„æ­£ç›¸å…³æ€§ã€‚ è¯¥å›¾æ˜¯ç¬¬äºŒæ¬¡ç‰¹å¾åˆ†æžåˆ†æžç»“æžœï¼ˆkaggle score:0.82296,survivalä¸Žmale_adult(-0.56)ã€sex_male(-0.54)è´Ÿç›¸å…³,å’Œfemale_adult(0.54)ã€sex_female(0.52)æ­£ç›¸å…³ã€‚ä½ çš„survivalçš„æ¦‚çŽ‡å’Œä½ çš„æ€§åˆ«å’Œå¹´é¾„æœ‰å…³ï¼Œå¦‚æžœä½ æ˜¯æˆå¹´å¥³å­ï¼Œé‚£ä¹ˆä½ å¾ˆå¤§çš„æ¦‚çŽ‡ä¸ä¼šæ­»äº¡(åƒRoseé‚£æ ·)ï¼›å¦‚æžœä½ æ˜¯æˆå¹´ç”·å­ï¼Œé‚£ä¹ˆä½ æœ‰å¾ˆå¤§æ¦‚çŽ‡ä½“çŽ°è‹±ä¼¦çš„ç»…å£«é£Žåº¦ï¼Œä¸»åŠ¨(Jacké‚£æ ·)æˆ–è€…è¢«é€‰æ‹©æ­»äº¡ã€‚çž¬é—´æƒ³èµ·äº†Titanicç”µå½±ä¸­Jackå’ŒRose çš„åœºæ™¯ï¼Œå¥½æ„Ÿäººå•Š!!! æ¨¡åž‹è®­ç»ƒå‘çŽ°å†™äº†è¿™ä¹ˆä¹…ï¼Œè¿˜æ²¡æœ‰å¼€å§‹è®­ç»ƒæ¨¡åž‹ã€‚åŠ å¿«è„šæ­¥â€¦ä¸‹é¢çš„å†…å®¹ä»¥ç¬¬ä¸€æ¬¡è®­ç»ƒæ¨¡åž‹ä¸ºä¾‹ã€‚åœ¨å»ºç«‹åŸºæœ¬æ¨¡åž‹ä¹‹å‰æˆ‘ä»¬éœ€è¦å…ˆå¼•å…¥è¯„ä»·å‡½æ•°ï¼Œä»¥è¯„ä»·ä¸åŒæ¨¡åž‹æ€§èƒ½çš„å¥½åã€‚ é€šè¿‡å‡å€¼å’Œæ–¹å·®æ¥è¯„ä»·æ¨¡åž‹æ€§èƒ½çš„ä¼˜åŠ£1234from sklearn import cross_validation def rmsl(clf): s = cross_validation.cross_val_score(clf, X_train, y_train, cv=5) return (s.mean(),s.std()) å»ºç«‹åŸºæœ¬æ¨¡åž‹1234567891011121314151617181920212223242526272829303132333435363738394041424344from sklearn import svm, tree, linear_model, neighbors, naive_bayes, ensemble, discriminant_analysis,gaussian_processNLA =[ #ensemble methods ensemble.AdaBoostClassifier(), ensemble.BaggingRegressor(), ensemble.GradientBoostingClassifier(), ensemble.RandomForestClassifier(n_estimators=60), # Gaussian process gaussian_process.GaussianProcessClassifier(), # LM linear_model.LogisticRegression(C=1.0, penalty=&apos;l1&apos;), #Navies Bayes naive_bayes.GaussianNB(), # Nearest Neighbor neighbors.KNeighborsClassifier(n_neighbors=3), # Svm svm.SVC(probability=True), svm.LinearSVC(), #Tree tree.DecisionTreeClassifier(), tree.ExtraTreeClassifier() ]#create table to compare MLAMLA_columns = [&apos;MLA Name&apos;, &apos;MLA Parameters&apos;,&apos;MLA Train Accuracy Mean&apos;, &apos;MLA Test Accuracy Mean&apos;, &apos;MLA Test Accuracy Min&apos; ,&apos;MLA Time&apos;] MLA_compare = pd.DataFrame(columns = MLA_columns) row_index = 0 for alg in MLA: #set name and parameters MLA_compare.loc[row_index, &apos;MLA Name&apos;] = alg.__class__.__name__ MLA_compare.loc[row_index, &apos;MLA Parameters&apos;] = str(alg.get_params()) #score model with cross validation: cv_results = model_selection.cross_validate(alg, X_train, y_train, cv =5,return_train_score=True) MLA_compare.loc[row_index, &apos;MLA Time&apos;] = cv_results[&apos;fit_time&apos;].mean() MLA_compare.loc[row_index, &apos;MLA Train Accuracy Mean&apos;] = cv_results[&apos;train_score&apos;].mean() MLA_compare.loc[row_index, &apos;MLA Test Accuracy Mean&apos;] = cv_results[&apos;test_score&apos;].mean() MLA_compare.loc[row_index, &apos;MLA Test Accuracy Min&apos;] = cv_results[&apos;test_score&apos;].min() #let&apos;s know the worst that can happen! row_index+=1MLA_compare.sort_values(by = [&apos;MLA Test Accuracy Mean&apos;], ascending = False, inplace = True) å½“æˆ‘ä»¬å‘çŽ°æŸä¸ªæ¨¡åž‹æ•ˆæžœæ¯”è¾ƒå¥½çš„æ—¶å€™ï¼Œæˆ‘ä»¬ä»ç„¶å¯ä»¥è¿›ä¸€æ­¥è°ƒå‚ã€‚ä½†æ˜¯è¿™ç§è°ƒå‚å¹¶ä¸æ˜¯æ¯æ¬¡ä¼šå¾—åˆ°better result,æœ‰æ—¶å€™åªæ˜¯ä¸€ä¸ªdecent resultã€‚è°ƒå‚æ˜¯ä¸ªæŠ€æœ¯æ´»ã€‚ä»¥ä¸Šå›¾ä¸­çš„ DecisionTreeClassifierä¸ºä¾‹è¿›è¡Œè°ƒå‚ã€‚12345678param_grid = &#123;&apos;criterion&apos;: [&apos;gini&apos;, &apos;entropy&apos;], &apos;splitter&apos;: [&apos;best&apos;, &apos;random&apos;], &apos;max_depth&apos;: [None, 2,4,6,8,10], &apos;min_samples_split&apos;: [5,10,15,20,25], &apos;max_features&apos;: [None, &apos;auto&apos;, &apos;sqrt&apos;, &apos;log2&apos;] &#125;tune_model = model_selection.GridSearchCV(tree.DecisionTreeClassifier(), param_grid=param_grid, scoring = &apos;accuracy&apos;, cv = 5) cv_results = model_selection.cross_validate(tune_model, X_train, y_train, cv = 5) ä½¿ç”¨çš„æ˜¯sklearn ä¸­çš„model_selection æ¨¡å—ï¼Œè¿›è¡ŒGridSearchï¼Œå…¶å®žåªæ˜¯æŠŠè°ƒå‚è¿‡ç¨‹è‡ªåŠ¨åŒ–ç¨‹åºåŒ–ã€‚å¾—åˆ°çš„ç»“æžœæ˜¯1230.863068608315 #train mean0.79803322024 # test mean0.77094972067 #test min æˆ‘ä»¬é€šè¿‡æ¯”å¯¹å‘çŽ°è¿™ä¸ªç»“æžœå’Œä¸Šå›¾çš„ç»“æžœæ˜¯ç¨å¾®å˜å·®çš„ã€‚å¯è§†åŒ–æ˜¾ç¤ºå„ä¸ªç®—æ³•çš„æ•ˆçŽ‡ï¼š1234sns.barplot(x=&apos;MLA Test Accuracy Mean&apos;, y = &apos;MLA Name&apos;, data = MLA_compare, color = &apos;m&apos;) plt.title(&apos;Machine Learning Algorithm Accuracy Score \n&apos;) plt.xlabel(&apos;Accuracy Score (%)&apos;) plt.ylabel(&apos;Algorithm&apos;) å¯¹æ¯”ä¹‹åŽæˆ‘ä»¬é€‰å–å‡ ä¸ªæ•ˆæžœæ¯”è¾ƒâ€œå¥½â€çš„æ¨¡åž‹ï¼Œç„¶åŽè¿›è¡Œä¸‹ä¸€æ­¥çš„æ¨¡åž‹èžåˆã€‚12345678910111213141516171819MLA_best = [ #Ensemble Methods ensemble.AdaBoostClassifier(), # 0.76076 ensemble.BaggingClassifier(), # 0.72248 ensemble.GradientBoostingClassifier(), # 0.73684 ensemble.RandomForestClassifier(n_estimators = 60), # 0.72727 #GLM linear_model.LogisticRegression(C=1.0, penalty=&apos;l1&apos;, tol=1e-6), # 0.77990 linear_model.RidgeClassifierCV(), # 0.77033 linear_model.LogisticRegressionCV() #0.77033 ] row_index = 0 for alg in MLA_best: algname = alg.__class__.__name__ alg.fit(X_train, y_train) predictions = alg.predict(X_test) result = pd.DataFrame(&#123;&apos;PassengerId&apos;:test[&apos;PassengerId&apos;].as_matrix(), &apos;Survived&apos;:predictions.astype(np.int32)&#125;) result.to_csv(algname+&quot;.csv&quot;, index=False) # save the results row_index+=1 æ¨¡åž‹èžåˆç®€å•çš„è¯´æ¨¡åž‹èžåˆå°±æ˜¯é€šè¿‡å¤šä¸ªdecentæ¨¡åž‹çš„ç»“æžœé€šè¿‡æŸç§æ–¹å¼çš„ç»“åˆï¼Œäº§ç”Ÿäº†æ¯”åŽŸæ¥å•ä¸ªæ¨¡åž‹betterçš„ç»“æžœã€‚å…³äºŽæ¨¡åž‹èžåˆçš„è¯¦ç»†å†…å®¹ï¼Œè¯·ç§»æ­¥å¦ä¸€ç¯‡æ–‡ç« æ¨¡åž‹èžåˆ(Ensemble learning)æˆ‘ä»¬è¿™é‡Œä»¥stacking(äºŒå±‚)ä¸ºä¾‹è¯´æ˜Žæ¨¡åž‹èžåˆã€‚1234567891011121314151617181920212223ntrain = train.shape[0] #891 ntest = test.shape[0] #418 SEED = 0 # for reproducibility NFOLDS = 5 # set folds for out-of-fold prediction kf =model_selection.KFold(n_splits=NFOLDS, random_state=SEED)# å°è£…ç®—æ³•åŸºæœ¬æ“ä½œ class SklearnHelper(object): def __init__(self, clf, seed=0, params=None): params[&apos;random_state&apos;] = seed self.clf = clf(**params) def train(self, x_train, y_train): self.clf.fit(x_train, y_train) def predict(self, x): return self.clf.predict(x) def fit(self,x,y): return self.clf.fit(x,y) def feature_importances(self,x,y): print(self.clf.fit(x,y).feature_importances_) return self.clf.fit(x,y).feature_importances_ ä¸‹é¢æ˜¯å®šä¹‰äº”æŠ˜äº¤å‰éªŒè¯çš„æ–¹æ³•ï¼Œé»˜è®¤æ˜¯ä¸‰æŠ˜ã€‚123456789101112131415161718def get_oof(clf, x_train, y_train, x_test): oof_train = np.zeros((ntrain,)) oof_test = np.zeros((ntest,)) oof_test_skf = np.empty((NFOLDS, ntest)) for i, (train_index, test_index) in enumerate(kf.split(x_train)): x_tr = x_train[train_index] y_tr = y_train[train_index] x_te = x_train[test_index] clf.train(x_tr, y_tr) oof_train[test_index] = clf.predict(x_te) oof_test_skf[i, :] = clf.predict(x_test) oof_test[:] = oof_test_skf.mean(axis=0) return oof_train.reshape(-1, 1), oof_test.reshape(-1, 1) # æƒ³è®©zå˜æˆåªæœ‰ä¸€åˆ—ï¼Œè¡Œæ•°ä¸çŸ¥é“å¤šå°‘ 1234567891011121314151617181920212223242526272829303132from sklearn.ensemble import RandomForestClassifier, ExtraTreesClassifier,AdaBoostClassifier, GradientBoostingClassifier# å®šä¹‰å››ä¸ªä¸åŒçš„å¼±åˆ†ç±»å™¨çš„å‚æ•°å€¼ # Random Forest parameters rf_params = &#123; &apos;n_jobs&apos;: -1,&apos;n_estimators&apos;: 500,&apos;warm_start&apos;: True, &apos;max_depth&apos;: 6,&apos;min_samples_leaf&apos;: 2, &apos;max_features&apos; : &apos;sqrt&apos;,&apos;verbose&apos;: 0#&apos;max_features&apos;: 0.2, &#125; # Extra Trees Parameters et_params = &#123; &apos;n_jobs&apos;: -1,&apos;n_estimators&apos;:500,&apos;max_depth&apos;: 8,&apos;min_samples_leaf&apos;: 2,&apos;verbose&apos;: 0 #&apos;max_features&apos;: 0.5, &#125; # AdaBoost parameters ada_params = &#123; &apos;n_estimators&apos;: 500,&apos;learning_rate&apos; : 0.75 &#125; # Gradient Boosting parameters gb_params = &#123; &apos;n_estimators&apos;: 500,&apos;max_depth&apos;: 5,&apos;min_samples_leaf&apos;: 2, &apos;verbose&apos;: 0 #&apos;max_features&apos;: 0.2, &#125; # Support Vector Classifier parameters # svc_params = &#123; # &apos;kernel&apos; : &apos;linear&apos;,&apos;C&apos; : 0.025 # &#125; # åˆ›å»ºå››ä¸ªè‹¥åˆ†ç±»å™¨æ¨¡åž‹ rf = SklearnHelper(clf=RandomForestClassifier, seed=SEED, params=rf_params) et = SklearnHelper(clf=ExtraTreesClassifier, seed=SEED, params=et_params) ada = SklearnHelper(clf=AdaBoostClassifier, seed=SEED, params=ada_params) gb = SklearnHelper(clf=GradientBoostingClassifier, seed=SEED, params=gb_params) 1234567891011121314151617181920#X_train =X_train.values#X_test =X_test.values# ä½¿ç”¨äº”æŠ˜äº¤å‰æ–¹æ³•åˆ†åˆ«è®¡ç®—å‡ºä½¿ç”¨ä¸åŒç®—æ³•çš„é¢„æµ‹ç»“æžœï¼Œè¿™äº›ç»“æžœå°†ç”¨äºŽStackingçš„ç¬¬äºŒå±‚é¢„æµ‹ et_oof_train, et_oof_test = get_oof(et, X_train, y_train, X_test) # Extra Trees rf_oof_train, rf_oof_test = get_oof(rf,X_train, y_train, X_test) # Random Forest ada_oof_train, ada_oof_test = get_oof(ada, X_train, y_train, X_test) # AdaBoost gb_oof_train, gb_oof_test = get_oof(gb,X_train, y_train, X_test) # Gradient Boost rf_feature = rf.feature_importances(X_train,y_train) et_feature = et.feature_importances(X_train, y_train) ada_feature = ada.feature_importances(X_train, y_train) gb_feature = gb.feature_importances(X_train,y_train) feature_dataframe = pd.DataFrame( &#123;&apos;features&apos;: cols, &apos;Random Forest feature importances&apos;: rf_feature, &apos;Extra Trees feature importances&apos;: et_feature, &apos;AdaBoost feature importances&apos;: ada_feature, &apos;Gradient Boost feature importances&apos;: gb_feature &#125;) æŽ¥ä¸‹æ¥ä»¥ç¬¬ä¸€å±‚ä¸ºä¸ºåŸºç¡€è®­ç»ƒç¬¬äºŒå±‚12345678base_predictions_train = pd.DataFrame( &#123; &apos;RandomForest&apos;: rf_oof_train.ravel(),# # ravelå‡½æ•°åœ¨é™ç»´æ—¶é»˜è®¤æ˜¯è¡Œåºä¼˜å…ˆ &apos;ExtraTrees&apos;: et_oof_train.ravel(), &apos;AdaBoost&apos;: ada_oof_train.ravel(), &apos;GradientBoost&apos;: gb_oof_train.ravel() &#125;) X_train2 = np.concatenate(( et_oof_train, rf_oof_train, ada_oof_train, gb_oof_train), axis=1) X_test2 = np.concatenate(( et_oof_test, rf_oof_test, ada_oof_test, gb_oof_test), axis=1) ä½¿ç”¨XGBoostè®­ç»ƒç¬¬äºŒå±‚çš„æ•°æ®ã€‚å…³äºŽXGBoostä¸ºä»€ä¹ˆæ˜¯æœ‰æ•ˆçš„å’Œç›¸å…³çš„æ¦‚å¿µï¼Œè¯·ç§»æ­¥XGBoost123456789101112131415# XGboost import xgboost as xgbgbm = xgb.XGBClassifier( #learning_rate = 0.02, n_estimators= 2000, max_depth= 4, min_child_weight= 2, #gamma=1, gamma=0.9, subsample=0.8, colsample_bytree=0.8, objective= &apos;binary:logistic&apos;, nthread= -1, scale_pos_weight=1).fit(X_train2, y_train) predictions = gbm.predict(X_test2) æœ€åŽäº§ç”Ÿç»“æžœæ–‡ä»¶ StackingSubmission.csv12StackingSubmission = pd.DataFrame(&#123;&apos;PassengerId&apos;:test.PassengerId, &apos;Survived&apos;: predictions &#125;) StackingSubmission.to_csv(&quot;StackingSubmission.csv&quot;, index=False) # 0.78947 å‚è€ƒæ–‡çŒ®æœ¬æ–‡åœ¨æ•ˆæžœå¯è§†åŒ–ä¸­å€Ÿé‰´è¯¥åšå®¢ç‰¹å¾æå–å‚çœ‹kaggleå¤šä½å¤§ç¥žï¼Œåœ¨è¿™é‡Œå°±è°¢è¿‡â€¦]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[é›†æˆå­¦ä¹ ]]></title>
    <url>%2F2018%2F02%2F05%2Femsemble%2F</url>
    <content type="text"><![CDATA[ä¸»è¦ä»‹ç»é›†æˆå­¦ä¹  ç›®å‰é›†æˆå­¦ä¹ ç®—æ³•å¤§å¤šæºäºŽbaggingã€boostingã€stackingä¸‰ç§æ€æƒ³ã€‚ é›†æˆå­¦ä¹ ?é›†æˆå­¦ä¹ æ˜¯ä¸€ç§æœºå™¨å­¦ä¹ èŒƒå¼ã€‚åœ¨é›†æˆå­¦ä¹ ä¸­ï¼Œæˆ‘ä»¬ä¼šè®­ç»ƒå¤šä¸ªæ¨¡åž‹ï¼ˆé€šå¸¸ç§°ä¸ºã€Œå¼±å­¦ä¹ å™¨ã€ï¼‰è§£å†³ç›¸åŒçš„é—®é¢˜ï¼Œå¹¶å°†å®ƒä»¬ç»“åˆèµ·æ¥ä»¥èŽ·å¾—æ›´å¥½çš„ç»“æžœã€‚æœ€é‡è¦çš„å‡è®¾æ˜¯ï¼šå½“å¼±æ¨¡åž‹è¢«æ­£ç¡®ç»„åˆæ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°æ›´ç²¾ç¡®å’Œ/æˆ–æ›´é²æ£’çš„æ¨¡åž‹ã€‚ åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼ˆåŒ…æ‹¬åœ¨ä¼—æ‰€å‘¨çŸ¥çš„ bagging å’Œ boosting æ–¹æ³•ä¸­ï¼‰ï¼Œæˆ‘ä»¬ä¼šä½¿ç”¨å•ä¸€çš„åŸºç¡€å­¦ä¹ ç®—æ³•ï¼Œè¿™æ ·ä¸€æ¥æˆ‘ä»¬å°±æœ‰äº†ä»¥ä¸åŒæ–¹å¼è®­ç»ƒçš„åŒè´¨å¼±å­¦ä¹ å™¨ã€‚è¿™æ ·å¾—åˆ°çš„é›†æˆæ¨¡åž‹è¢«ç§°ä¸ºã€ŒåŒè´¨çš„ã€ã€‚ç„¶è€Œï¼Œä¹Ÿæœ‰ä¸€äº›æ–¹æ³•ä½¿ç”¨ä¸åŒç§ç±»çš„åŸºç¡€å­¦ä¹ ç®—æ³•ï¼šå°†ä¸€äº›å¼‚è´¨çš„å¼±å­¦ä¹ å™¨ç»„åˆæˆã€Œå¼‚è´¨é›†æˆæ¨¡åž‹ã€ã€‚ å¾ˆé‡è¦çš„ä¸€ç‚¹æ˜¯ï¼šæˆ‘ä»¬å¯¹å¼±å­¦ä¹ å™¨çš„é€‰æ‹©åº”è¯¥å’Œæˆ‘ä»¬èšåˆè¿™äº›æ¨¡åž‹çš„æ–¹å¼ç›¸ä¸€è‡´ã€‚å¦‚æžœæˆ‘ä»¬é€‰æ‹©å…·æœ‰ä½Žåç½®é«˜æ–¹å·®çš„åŸºç¡€æ¨¡åž‹ï¼Œæˆ‘ä»¬åº”è¯¥ä½¿ç”¨ä¸€ç§å€¾å‘äºŽå‡å°æ–¹å·®çš„èšåˆæ–¹æ³•ï¼›è€Œå¦‚æžœæˆ‘ä»¬é€‰æ‹©å…·æœ‰ä½Žæ–¹å·®é«˜åç½®çš„åŸºç¡€æ¨¡åž‹ï¼Œæˆ‘ä»¬åº”è¯¥ä½¿ç”¨ä¸€ç§å€¾å‘äºŽå‡å°åç½®çš„èšåˆæ–¹æ³•ã€‚ è¿™å°±å¼•å‡ºäº†å¦‚ä½•ç»„åˆè¿™äº›æ¨¡åž‹çš„é—®é¢˜ã€‚æˆ‘ä»¬å¯ä»¥ç”¨ä¸‰ç§ä¸»è¦çš„æ—¨åœ¨ç»„åˆå¼±å­¦ä¹ å™¨çš„ã€Œå…ƒç®—æ³•ã€ï¼š baggingï¼Œè¯¥æ–¹æ³•é€šå¸¸è€ƒè™‘çš„æ˜¯åŒè´¨å¼±å­¦ä¹ å™¨ï¼Œç›¸äº’ç‹¬ç«‹åœ°å¹¶è¡Œå­¦ä¹ è¿™äº›å¼±å­¦ä¹ å™¨ï¼Œå¹¶æŒ‰ç…§æŸç§ç¡®å®šæ€§çš„å¹³å‡è¿‡ç¨‹å°†å®ƒä»¬ç»„åˆèµ·æ¥ã€‚ boostingï¼Œè¯¥æ–¹æ³•é€šå¸¸è€ƒè™‘çš„ä¹Ÿæ˜¯åŒè´¨å¼±å­¦ä¹ å™¨ã€‚å®ƒä»¥ä¸€ç§é«˜åº¦è‡ªé€‚åº”çš„æ–¹æ³•é¡ºåºåœ°å­¦ä¹ è¿™äº›å¼±å­¦ä¹ å™¨ï¼ˆæ¯ä¸ªåŸºç¡€æ¨¡åž‹éƒ½ä¾èµ–äºŽå‰é¢çš„æ¨¡åž‹ï¼‰ï¼Œå¹¶æŒ‰ç…§æŸç§ç¡®å®šæ€§çš„ç­–ç•¥å°†å®ƒä»¬ç»„åˆèµ·æ¥ã€‚ stackingï¼Œè¯¥æ–¹æ³•é€šå¸¸è€ƒè™‘çš„æ˜¯å¼‚è´¨å¼±å­¦ä¹ å™¨ï¼Œå¹¶è¡Œåœ°å­¦ä¹ å®ƒä»¬ï¼Œå¹¶é€šè¿‡è®­ç»ƒä¸€ä¸ªã€Œå…ƒæ¨¡åž‹ã€å°†å®ƒä»¬ç»„åˆèµ·æ¥ï¼Œæ ¹æ®ä¸åŒå¼±æ¨¡åž‹çš„é¢„æµ‹ç»“æžœè¾“å‡ºä¸€ä¸ªæœ€ç»ˆçš„é¢„æµ‹ç»“æžœã€‚ æˆ‘ä»¬å°†å…·ä½“ä»‹ç» bagging å’Œ boosting æ–¹æ³•ï¼ˆå®ƒä»¬æ¯” stacking æ–¹æ³•ä½¿ç”¨æ›´å¹¿æ³›ï¼Œå¹¶ä¸”è®©æˆ‘ä»¬å¯ä»¥è®¨è®ºä¸€äº›é›†æˆå­¦ä¹ çš„å…³é”®æ¦‚å¿µï¼‰ï¼Œç„¶åŽç®€è¦æ¦‚è¿° stacking æ–¹æ³•ã€‚ bagging ä»Žè®­ç»ƒé›†ð‘†ä¸­æœ‰æ”¾å›žçš„éšæœºé€‰å–æ•°æ®é›† ð‘€(âˆ£ð‘€âˆ£&lt;âˆ£ð‘†âˆ£); ç”Ÿæˆä¸€ä¸ªåˆ†ç±»æ¨¡åž‹ $ð¶ $; é‡å¤ä»¥ä¸Šæ­¥éª¤ð‘šæ¬¡ï¼Œå¾—åˆ°ð‘šä¸ªåˆ†ç±»æ¨¡åž‹ $ð¶_1$, $ð¶2 $,â€¦, $ð¶ð‘š $; å¯¹äºŽåˆ†ç±»é—®é¢˜ï¼Œæ¯ä¸€ä¸ªæ¨¡åž‹æŠ•ç¥¨å†³å®šï¼Œå°‘æ•°æœä»Žå¤šæ•°åŽŸåˆ™; å¯¹äºŽå›žå½’é—®é¢˜ï¼Œå–å¹³å‡å€¼ã€‚ ä¼˜ç‚¹: é€šè¿‡å‡å°‘æ–¹å·®æ¥æé«˜é¢„æµ‹ç»“æžœã€‚ç¼ºç‚¹: å¤±åŽ»äº†æ¨¡åž‹çš„ç®€å•æ€§ã€‚ Random Forest æ˜¯å¯¹äºŽè¿™ç§æ€æƒ³çš„ä¸€ç§å®žçŽ°æ‰‹æ®µã€‚åŸºæœ¬çš„è¦æ±‚æ˜¯å¼ºåŸºå­¦ä¹ å™¨ï¼Œä¸æ–­çš„ä¼˜åŒ–æ–¹å·®ã€‚ ä¼˜ç‚¹ å‡å°‘äº†æ¨¡åž‹æ–¹å·®ï¼Œæé«˜äº†é¢„æµ‹å‡†ç¡®æ€§ã€‚ ä¸éœ€è¦ç»™æ ‘åšå‰ªæžã€‚ åœ¨å¤§è§„æ¨¡æ•°æ®é›†ï¼Œå°¤å…¶æ˜¯ç‰¹å¾è¾ƒå¤šçš„æƒ…å†µä¸‹ï¼Œä¾ç„¶å¯ä»¥ä¿æŒé«˜æ•ˆçŽ‡ã€‚ ç¼ºç‚¹ éšæœºæ£®æž—å·²ç»è¢«è¯æ˜Žåœ¨æŸäº›å™ªéŸ³è¾ƒå¤§çš„åˆ†ç±»æˆ–å›žå½’é—®é¢˜ä¸Šä¼šè¿‡æ‹Ÿåˆ boostingæ¯ä¸€è½®æ ¹æ®ä¸Šä¸€è½®çš„åˆ†ç±»ç»“æžœåŠ¨æ€è°ƒæ•´æ¯ä¸ªæ ·æœ¬åœ¨åˆ†ç±»å™¨ä¸­çš„æƒé‡ï¼Œè®­ç»ƒå¾—åˆ°kä¸ªå¼±åˆ†ç±»å™¨ï¼Œä»–ä»¬éƒ½æœ‰å„è‡ªçš„æƒé‡ï¼Œé€šè¿‡åŠ æƒç»„åˆçš„æ–¹å¼å¾—åˆ°æœ€ç»ˆçš„åˆ†ç±»ç»“æžœ(ç»¼åˆæ‰€æœ‰çš„åŸºæ¨¡åž‹é¢„æµ‹ç»“æžœ)ã€‚ä¸»è¦ç®—æ³•æœ‰AdaBoost/GBDT/Xgboost/LightGBMã€‚ GBDT ä¼˜ç‚¹ åœ¨åˆ†å¸ƒç¨ å¯†çš„æ•°æ®é›†ä¸Šï¼Œæ³›åŒ–èƒ½åŠ›å’Œè¡¨è¾¾èƒ½åŠ›éƒ½å¾ˆå¥½ï¼Œè¿™ä½¿å¾—GBDTåœ¨Kaggleçš„ä¼—å¤šç«žèµ›ä¸­ï¼Œç»å¸¸ååˆ—æ¦œé¦–ã€‚ ç¼ºç‚¹ GBDTåœ¨é«˜ç»´ç¨€ç–çš„æ•°æ®é›†ä¸Šï¼Œè¡¨çŽ°ä¸å¦‚æ”¯æŒå‘é‡æœºæˆ–è€…ç¥žç»ç½‘ç»œã€‚ï¼ˆæ‰€ä»¥è¯´è¿™ç§æ ‘çš„æ¨¡åž‹æ˜¯æœ‰åˆ©äºŽå¤„ç†è¿žç»­æ•°å€¼ï¼Œ å¦‚æžœæ˜¯ one-hot å°±ä¸å»ºè®®ä½¿ç”¨gbdtï¼‰ GBDTåœ¨å¤„ç†æ–‡æœ¬åˆ†ç±»ç‰¹å¾é—®é¢˜ä¸Šï¼Œç›¸å¯¹å…¶ä»–æ¨¡åž‹çš„ä¼˜åŠ¿ä¸å¦‚å®ƒåœ¨å¤„ç†æ•°å€¼ç‰¹å¾æ—¶æ˜Žæ˜¾ã€‚ Xgboost XGBoostæ˜¯é™ˆå¤©å¥‡ç­‰äººå¼€å‘çš„ä¸€ä¸ªå¼€æºæœºå™¨å­¦ä¹ é¡¹ç›®ï¼Œé«˜æ•ˆåœ°å®žçŽ°äº†GBDTç®—æ³•å¹¶è¿›è¡Œäº†ç®—æ³•å’Œå·¥ç¨‹ä¸Šçš„è®¸å¤šæ”¹è¿›ã€‚ ä¼˜ç‚¹ è®¡ç®—æ•ˆçŽ‡é«˜ï¼Œä½¿ç”¨äº†äºŒé˜¶å¯¼ã€‚ æœ‰æ­£åˆ™åŒ–ï¼Œå‡å°‘è¿‡æ‹Ÿåˆã€‚ GBDTä¸ŽXGboostè”ç³»ä¸ŽåŒºåˆ« (1) GBDTæ˜¯æœºå™¨å­¦ä¹ ç®—æ³•ï¼ŒXGBoostæ˜¯è¯¥ç®—æ³•çš„å·¥ç¨‹å®žçŽ°ã€‚(2) åœ¨ä½¿ç”¨CARTä½œä¸ºåŸºåˆ†ç±»å™¨æ—¶ï¼ŒXGBoostæ˜¾å¼åœ°åŠ å…¥äº†æ­£åˆ™é¡¹æ¥æŽ§åˆ¶æ¨¡åž‹çš„å¤æ‚åº¦ï¼Œæœ‰åˆ©äºŽé˜²æ­¢è¿‡æ‹Ÿåˆï¼Œä»Žè€Œæé«˜æ¨¡åž‹çš„æ³›åŒ–èƒ½åŠ›ã€‚(3) GBDTåœ¨æ¨¡åž‹è®­ç»ƒæ—¶åªä½¿ç”¨äº†ä»£ä»·å‡½æ•°çš„ä¸€é˜¶å¯¼æ•°ä¿¡æ¯ï¼ŒXGBoostå¯¹ä»£ä»·å‡½æ•°è¿›è¡ŒäºŒé˜¶æ³°å‹’å±•å¼€ï¼Œå¯ä»¥åŒæ—¶ä½¿ç”¨ä¸€é˜¶å’ŒäºŒé˜¶å¯¼æ•°ã€‚(4) ä¼ ç»Ÿçš„GBDTé‡‡ç”¨CARTä½œä¸ºåŸºåˆ†ç±»å™¨ï¼ŒXGBoostæ”¯æŒå¤šç§ç±»åž‹çš„åŸºåˆ†ç±»å™¨ï¼Œæ¯”å¦‚çº¿æ€§åˆ†ç±»å™¨ã€‚(5) ä¼ ç»Ÿçš„GBDTåœ¨æ¯è½®è¿­ä»£æ—¶ä½¿ç”¨å…¨éƒ¨çš„æ•°æ®ï¼ŒXGBooståˆ™é‡‡ç”¨äº†ä¸Žéšæœºæ£®æž—ç›¸ä¼¼çš„ç­–ç•¥ï¼Œæ”¯æŒå¯¹æ•°æ®è¿›è¡Œé‡‡æ ·ã€‚(6) ä¼ ç»Ÿçš„GBDTæ²¡æœ‰è®¾è®¡å¯¹ç¼ºå¤±å€¼è¿›è¡Œå¤„ç†ï¼ŒXGBoostèƒ½å¤Ÿè‡ªåŠ¨å­¦ä¹ å‡ºç¼ºå¤±å€¼çš„å¤„ç†ç­–ç•¥ã€‚ stackingæ­£å¦‚ä¸Šæ–‡å·²ç»æåˆ°çš„ï¼Œstacking çš„æ¦‚å¿µæ˜¯å­¦ä¹ å‡ ä¸ªä¸åŒçš„å¼±å­¦ä¹ å™¨ï¼Œå¹¶é€šè¿‡è®­ç»ƒä¸€ä¸ªå…ƒæ¨¡åž‹æ¥ç»„åˆå®ƒä»¬ï¼Œç„¶åŽåŸºäºŽè¿™äº›å¼±æ¨¡åž‹è¿”å›žçš„å¤šä¸ªé¢„æµ‹ç»“æžœè¾“å‡ºæœ€ç»ˆçš„é¢„æµ‹ç»“æžœã€‚ å› æ­¤ï¼Œä¸ºäº†æž„å»º stacking æ¨¡åž‹ï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰ä¸¤ä¸ªä¸œè¥¿ï¼šæƒ³è¦æ‹Ÿåˆçš„ L ä¸ªå­¦ä¹ å™¨ä»¥åŠç»„åˆå®ƒä»¬çš„å…ƒæ¨¡åž‹ã€‚ ä¾‹å¦‚ï¼Œå¯¹äºŽåˆ†ç±»é—®é¢˜æ¥è¯´ï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹© KNN åˆ†ç±»å™¨ã€logistic å›žå½’å’ŒSVM ä½œä¸ºå¼±å­¦ä¹ å™¨ï¼Œå¹¶å†³å®šå­¦ä¹ ç¥žç»ç½‘ç»œä½œä¸ºå…ƒæ¨¡åž‹ã€‚ç„¶åŽï¼Œç¥žç»ç½‘ç»œå°†ä¼šæŠŠä¸‰ä¸ªå¼±å­¦ä¹ å™¨çš„è¾“å‡ºä½œä¸ºè¾“å…¥ï¼Œå¹¶è¿”å›žåŸºäºŽè¯¥è¾“å…¥çš„æœ€ç»ˆé¢„æµ‹ã€‚]]></content>
      <categories>
        <category>æœºå™¨å­¦ä¹ </category>
      </categories>
      <tags>
        <tag>ensemble</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Search]]></title>
    <url>%2F2018%2F01%2F23%2Fbinary-search%2F</url>
    <content type="text"><![CDATA[ä»‹ç»äºŒåˆ†æŸ¥æ‰¾ä¸­çš„ä¸‰ä¸ªæ¨¡æ¿ï¼Œä»¥ LeetCode ä¸­çš„ä¹ é¢˜ä¸ºä¾‹ã€‚ é¦–å…ˆä»‹ç»ä¸€ä¸‹äºŒåˆ†æŸ¥æ‰¾ä¸­ä½¿ç”¨çš„æœ¯è¯­ï¼š ç›®æ ‡ Target â€”â€” ä½ è¦æŸ¥æ‰¾çš„å€¼ç´¢å¼• Index â€”â€” ä½ è¦æŸ¥æ‰¾çš„å½“å‰ä½ç½®å·¦ã€å³æŒ‡ç¤ºç¬¦ Leftï¼ŒRight â€”â€” æˆ‘ä»¬ç”¨æ¥ç»´æŒæŸ¥æ‰¾ç©ºé—´çš„æŒ‡æ ‡ä¸­é—´æŒ‡ç¤ºç¬¦ Mid â€”â€” æˆ‘ä»¬ç”¨æ¥åº”ç”¨æ¡ä»¶æ¥ç¡®å®šæˆ‘ä»¬åº”è¯¥å‘å·¦æŸ¥æ‰¾è¿˜æ˜¯å‘å³æŸ¥æ‰¾çš„ç´¢å¼• äºŒåˆ†çš„æ€æƒ³ï¼šæ¯æ¬¡æŠŠåŒºé—´ç¼©å°ä¸€åŠï¼Œåœ¨ç¼©å°çš„è¿‡ç¨‹ä¸­ä¸€å®šè¦ä¿è¯ï¼Œç­”æ¡ˆæ˜¯åœ¨åŒºé—´é‡Œé¢çš„ï¼Œæœ€åŽç­”æ¡ˆçš„åŒºé—´é•¿åº¦ä¸º1çš„æ—¶å€™ï¼Œå°±å¾—åˆ°äº†ç›®æ ‡åŒºé—´ã€‚70%çš„é¢˜ç›®éƒ½å…·æœ‰æŸç§å•è°ƒæ€§ã€‚ï¼ˆå…·æœ‰å•è°ƒæ€§ï¼Œé‚£ä¹ˆæ˜¯å¯ä»¥ä½¿ç”¨äºŒåˆ†è§£å†³ï¼›ä½†æ˜¯ä½¿ç”¨äºŒåˆ†çš„é¢˜ç›®ä¸ä¸€å®šéƒ½å…·æœ‰å•è°ƒæ€§ï¼‰95% çš„é¢˜ç›®æ˜¯å­˜åœ¨äºŒæ®µæ€§ã€‚ æ¨¡æ¿1æ¨¡æ¿ 1 æ˜¯äºŒåˆ†æŸ¥æ‰¾çš„æœ€åŸºç¡€å’Œæœ€åŸºæœ¬çš„å½¢å¼ã€‚è¿™æ˜¯ä¸€ä¸ªæ ‡å‡†çš„äºŒåˆ†æŸ¥æ‰¾æ¨¡æ¿ï¼Œæ˜¯éžå¸¸åŸºç¡€ç®€å•çš„äºŒåˆ†æŸ¥æ‰¾ã€‚æ¨¡æ¿ 1 ç”¨äºŽæŸ¥æ‰¾å¯ä»¥é€šè¿‡è®¿é—®æ•°ç»„ä¸­çš„å•ä¸ªç´¢å¼•æ¥ç¡®å®šçš„å…ƒç´ æˆ–æ¡ä»¶ã€‚æ¨¡ç‰ˆ 1 ä¸éœ€è¦åŽå¤„ç†ï¼Œå› ä¸ºæ¯ä¸€æ­¥ä¸­ï¼Œä½ éƒ½åœ¨æ£€æŸ¥æ˜¯å¦æ‰¾åˆ°äº†å…ƒç´ ã€‚å¦‚æžœåˆ°è¾¾æœ«å°¾ï¼Œåˆ™çŸ¥é“æœªæ‰¾åˆ°è¯¥å…ƒç´ ã€‚ è¯­æ³•å…³é”®ï¼š åˆå§‹æ¡ä»¶ï¼šleft = 0, right = length-1ç»ˆæ­¢ï¼šleft &gt; rightå‘å·¦æŸ¥æ‰¾ï¼šright = mid-1å‘å³æŸ¥æ‰¾ï¼šleft = mid+1 æ¨¡ç‰ˆ#1 å¯¹åº”çš„ä¾‹é¢˜ä¸ºï¼šLeetCode69 x çš„å¹³æ–¹æ ¹LeetCode374 çŒœæ•°å­—å¤§å°LeetCode33 æœç´¢æ—‹è½¬æŽ’åºæ•°ç»„ æ¨¡æ¿2æ¨¡æ¿ 2 æ˜¯äºŒåˆ†æŸ¥æ‰¾çš„é«˜çº§æ¨¡æ¿ã€‚å®ƒç”¨äºŽæŸ¥æ‰¾éœ€è¦è®¿é—®æ•°ç»„ä¸­å½“å‰ç´¢å¼•åŠå…¶ç›´æŽ¥å³é‚»å±…ç´¢å¼•çš„å…ƒç´ æˆ–æ¡ä»¶ã€‚æŸ¥æ‰¾æ¡ä»¶éœ€è¦è®¿é—®å…ƒç´ çš„ç›´æŽ¥å³é‚»å±…ã€‚ä½¿ç”¨å…ƒç´ çš„å³é‚»å±…æ¥ç¡®å®šæ˜¯å¦æ»¡è¶³æ¡ä»¶ï¼Œå¹¶å†³å®šæ˜¯å‘å·¦è¿˜æ˜¯å‘å³ã€‚ä¿è¯æŸ¥æ‰¾ç©ºé—´åœ¨æ¯ä¸€æ­¥ä¸­è‡³å°‘æœ‰ 2 ä¸ªå…ƒç´ ã€‚éœ€è¦è¿›è¡ŒåŽå¤„ç†ã€‚ å½“ä½ å‰©ä¸‹ 1 ä¸ªå…ƒç´ æ—¶ï¼Œå¾ªçŽ¯ / é€’å½’ç»“æŸã€‚ éœ€è¦è¯„ä¼°å‰©ä½™å…ƒç´ æ˜¯å¦ç¬¦åˆæ¡ä»¶ã€‚ è¯­æ³•å…³é”®ï¼š åˆå§‹æ¡ä»¶ï¼šleft = 0, right = lengthç»ˆæ­¢ï¼šleft == rightå‘å·¦æŸ¥æ‰¾ï¼šright = midå‘å³æŸ¥æ‰¾ï¼šleft = mid+1 æ¨¡ç‰ˆ#2 å¯¹åº”çš„ä¾‹é¢˜ä¸ºï¼šLeetCode278 ç¬¬ä¸€ä¸ªé”™è¯¯çš„ç‰ˆæœ¬LeetCode75 å¯»æ‰¾å³°å€¼LeetCode159 å¯»æ‰¾æ—‹è½¬æŽ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼ LeetCode69 x çš„å¹³æ–¹æ ¹ LeetCode69 x çš„å¹³æ–¹æ ¹ å®žçŽ° int sqrt(int x) å‡½æ•°ã€‚ éœ€è¦å¤„ç†ä¸€ä¸‹ int ç±»åž‹æ•°å­—è¶Šç•Œçš„é—®é¢˜ 123456789101112131415class Solution &#123;public: typedef long long ll; int mySqrt(int x) &#123; ll l =0, r =x; while(l &lt;r) &#123; ll mid = l +1ll+r &gt;&gt;1; if(mid *mid &lt;= x) l =mid; else r =mid -1; &#125; return l; &#125;&#125;; 12345678910111213141516class Solution &#123;public: // ä½¿ç”¨äºŒåˆ†è¿›è¡Œæ±‚è§£, æ—¶é—´å¤æ‚åº¦æ˜¯logn // äºŒåˆ†æœ‰ä¸¤ç§æ›´æ–°æ–¹å¼ï¼Œ ä¸€ç§æ˜¯ l =mid, r =mid -1; ä¸€ç§æ˜¯ l =mid +1, r =mid è¿™ä¸ªè®°ä½ä¹Ÿæ˜¯ä¸éš¾çš„ï¼Œr åªèƒ½æ˜¯mid æˆ–è€…æ˜¯ mid -1ï¼› l åªèƒ½æ˜¯mid æˆ–è€…æ˜¯mid +1 // å¹¶ä¸”è¿™ç§mid +-1 æ“ä½œåªèƒ½å‡ºçŽ°ä¸€æ¬¡ã€‚å½“å‡ºçŽ°mid -1 é‚£ä¹ˆå°±éœ€è¦è®¾ç½®ä¸€ä¸‹ mid = (l +r +1ll )/2 ï¼Œé˜²æ­¢é™·å…¥æ­»å¾ªçŽ¯ã€‚é€šè¿‡è§‚å¯Ÿå¯ä»¥çŸ¥é“ï¼Œéƒ½æ˜¯éœ€è¦å‡ºå¸­ +1 è¿™ç§æ“ä½œ int mySqrt(int x) &#123; int l =0, r =x; while(l &lt; r) &#123; int mid =(l +r +1ll) /2; if(mid &lt;= x/mid) l =mid; else r =mid -1; &#125; return l; &#125;&#125;; pythonè§£æ³• 12345678910111213class Solution(object): def mySqrt(self, x): """ :type x: int :rtype: int """ l, r =0, x while l &lt; r: mid = l+r +1 &gt;&gt;1 if(mid *mid &lt;= x): l =mid else: r =mid -1 return l 374. Guess Number Higher or Lower è¿™ä¸ªé¢˜ç›® æœ‰bug å§ï¼Œè¯´åäº†ã€‚ 12345678910111213141516171819// Forward declaration of guess API.// @param num, your guess// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0int guess(int num);class Solution &#123;public: int guessNumber(int n) &#123; int l =1, r =n; while(l &lt;r) &#123; int mid = (l+r) /2; if(guess(mid) ==0) return mid; else if(guess(mid) == 1) l =mid +1; else r = mid -1; &#125; return l; &#125;&#125;; c++ ä¸­ä½¿ç”¨ äºŒåˆ†è§£æ³•ï¼Œå¾ˆå®¹æ˜“å‡ºçŽ°int æº¢å‡ºçš„è¿™ç§çŽ°è±¡ã€‚æ‰€ä»¥æ³¨æ„ä¸€ä¸‹ä½¿ç”¨long longè¿›è¡Œè§£å†³12345678910111213141516171819202122// Forward declaration of guess API.// @param num, your guess// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0int guess(int num);class Solution &#123;public: // å‡¡æ˜¯èƒ½å¤Ÿåˆ†å—å¤„ç†çš„ï¼Œé‚£ä¹ˆéƒ½æ˜¯å¯ä»¥ä½¿ç”¨äºŒåˆ†çš„è¿›è¡Œå¤„ç†çš„ // ä¸€éƒ¨åˆ†æ»¡è¶³æŸç§æ¡ä»¶ï¼Œä¸€éƒ¨åˆ†æ»¡è¶³å¦ä¸€ç§æ¡ä»¶ typedef long long ll; int guessNumber(int n) &#123; ll l =1, r =n; while(l &lt;r) &#123; ll mid =l +r &gt;&gt;1; if(guess(mid) == 0) return mid; else if (guess(mid) ==-1) r =mid -1; else l =mid +1; //cout &lt;&lt; l &lt;&lt;" "&lt;&lt; r&lt;&lt; endl; &#125; return l; &#125;&#125;; python è§£æ³• 1234567891011121314151617181920# The guess API is already defined for you.# @param num, your guess# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0# def guess(num):class Solution(object): def guessNumber(self, n): """ :type n: int :rtype: int """ l, r = 1, n while l&lt;r: mid = l+r &gt;&gt;1 if( guess(mid) ==0): return mid elif (guess(mid) ==1): l =mid +1 else: r =mid -1 return l Search in Rotated Sorted Array è¿™ä¸ªé¢˜ç›®éžå¸¸çš„ç»å…¸çš„ï¼Œä½¿ç”¨äº†ä¸€ä¸ªäºŒåˆ†ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ $logn$ï¼Œ è§£é‡Šå¯ä»¥å‚è€ƒè¿™é‡Œ 1234567891011121314151617181920212223242526272829class Solution &#123;public: //æ•°æ®ç‰¹ç‚¹ï¼Œ åˆ†æˆäº†å·¦å³ä¸¤ä¸ªé€’å¢žåºåˆ—ï¼Œ nums[0] &gt; åŽé¢çš„é€’å¢žåºåˆ—çš„ int search(vector&lt;int&gt;&amp; nums, int target) &#123; int n =nums.size(); if (n ==0) return -1; int l=0, r =nums.size() -1; while(l &lt;r) &#123; int mid = (l+r) &gt;&gt;1; if(nums[mid] &gt;= nums[0]) &#123; if( target &gt;= nums[0] &amp;&amp; target &lt;= nums[mid]) r =mid ; else l =mid +1; &#125; else &#123; if(target &lt;nums[0] &amp;&amp; target &gt;nums[mid]) l =mid +1; else r =mid; &#125; &#125; return target == nums[l] ? l : -1; &#125;&#125;; è¿™ä¸ªæ˜¯å±žäºŽ pythonå®žçŽ° 123456789101112131415161718192021222324class Solution(object): # è¿™ä¸ªæ˜¯éœ€è¦å¤„ç†ä¸¤ä¸ªif çš„åˆ¤æ–­ï¼Œä¸€ä¸ªæ˜¯ mid å’Œ 0 çš„å…³ç³»ï¼Œä¸€ä¸ªæ˜¯target å’Œmid çš„å…³ç³»ï¼Œ # åµŒå¥—çš„if åˆ¤æ–­ def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ l, r =0, len(nums) while l &lt;r: mid = l +r &gt;&gt;1 if(nums[mid] &gt;= nums[0]): if target &gt;= nums[0] and target &lt;= nums[mid]: r =mid else: l =mid +1 else: if target &lt;nums[0] and target &gt; nums[mid]: l =mid+1 else: r =mid if(l &lt;len(nums) and nums[l] ==target): return l return -1 so easy 1234567891011121314151617181920212223242526272829class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.size() ==0) return -1; int n =nums.size() ; int l =0, r =n -1; while(l &lt;r) &#123; int mid = l +r &gt;&gt;1; if(nums[mid] &gt;= nums[0]) &#123; if(target &gt;= nums[0] &amp;&amp; target &lt;= nums[mid]) r =mid; else l =mid +1; &#125; else &#123; if(target &lt; nums[0] &amp;&amp; target &gt; nums[mid]) l =mid +1; else r =mid; &#125; &#125; if(l &lt;n &amp;&amp; nums[l] ==target) return l; return -1; &#125;&#125;; Search in Rotated Sorted Array II è¿™ç§åšæ³•æ˜¯æ¯”è¾ƒå¥½çš„ï¼Œ LeetCodeå¹³å°ä¸Š ä¸¤ä¸ª 90%ï¼Œå¯ä»¥è¿‘ä¼¼çš„çœ‹æˆ $logn$ 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: // è¿™ä¸ªæ˜¯33 æœ‰ç‚¹ç±»ä¼¼ï¼Œåªæ˜¯å¤šäº†å¯èƒ½å­˜åœ¨é‡å¤çš„æ•°å­—ï¼Œæ‰€ä»¥è¦ä¿è¯äºŒåˆ†çš„æ¡ä»¶ï¼Œä¿è¯çš„æ˜¯ä¸¥æ ¼çš„å•è°ƒæ€§ bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int n =nums.size(); if(n ==0) return false; if(target == nums[0]) return true; int k =n -1; while(k &gt;=0 &amp;&amp; nums[k] ==nums[0]) k --; n =k; // ç„¶åŽçŽ°åœ¨å°±æ˜¯ä¸ int l =0, r =n; while(l &lt;r) &#123; int mid = (l+r) &gt;&gt;1; if(nums[mid] &gt;= nums[0]) &#123; if( target &gt;= nums[0] &amp;&amp; target &lt;= nums[mid]) r =mid ; else l =mid +1; &#125; else &#123; if(target &lt;nums[0] &amp;&amp; target &gt;nums[mid]) l =mid +1; else r =mid; &#125; &#125; return nums[l] ==target? true:false; &#125;&#125;; è¿™ä¸ªå’Œä¸Šä¸€é“é¢˜ç›®æ˜¯ç±»ä¼¼çš„ã€‚ åœ¨è¿›è¡Œ â€“ æ“ä½œçš„æ—¶å€™ï¼Œä¸€å®šè¦åˆ¤æ–­ä¸€ä¸‹æ˜¯å¦èƒ½å¤Ÿâ€“ï¼Œ æ¯”å¦‚ä»£ç ä¸­çš„ i&gt;=0 ç„¶åŽæ‰èƒ½è¿›è¡Œ â€“ï¼› å¦‚æžœ i&lt;n ï¼Œé‚£ä¹ˆæ‰èƒ½è¿›è¡Œ ++æ“ä½œ 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: // è¿™ä¸ªå’Œä¸Šé¢çš„é¢˜ç›®çš„åŒºåˆ«ï¼Œå¯èƒ½æœ‰é‡å¤çš„å…ƒç´ ï¼Œ æ‰€ä»¥éœ€è¦å…ˆå¤„ç†ä¸€ä¸‹ã€‚ä¿è¯å‰ä¸€éƒ¨åˆ†çš„å…ƒç´ æ˜¯ç»å¯¹å¤§äºŽåŽé¢çš„å…ƒç´ çš„ bool search(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.size() ==0) return false; int n =nums.size(); int l =0, r =n -1; while(r &gt;=0 &amp;&amp; nums[0] ==nums[r]) r --; // é‚£ä¹ˆçŽ°åœ¨ä¹‹å‰çš„æ–¹å¼å°±å¯ä»¥ä½¿ç”¨äº† while(l &lt;r) &#123; int mid = l +r &gt;&gt;1; if(nums[mid] &gt;= nums[0]) &#123; if(target &gt;= nums[0] &amp;&amp; target &lt;= nums[mid]) r =mid; else l =mid +1; &#125; else &#123; if(target &lt; nums[0] &amp;&amp; target &gt; nums[mid]) l =mid +1; else r =mid; &#125; &#125; if(l &lt;n &amp;&amp; nums[l] ==target) return true; return false; &#125;&#125;; Find Peak Element 12345678910111213141516class Solution &#123;public: // è¿™ä¸ªå…³é”®æ˜¯è¦ ä¼šä½¿ç”¨äºŒåˆ†è¿›è¡Œæ±‚è§£ int findPeakElement(vector&lt;int&gt;&amp; nums) &#123; int n =nums.size() ; if(n ==0) return -1; int l =0, r =n -1; while(l &lt;r) &#123; int mid = l +r+1 &gt;&gt;1; if(nums[mid] &gt; nums[mid -1]) l =mid; else r =mid -1; &#125; return l; &#125;&#125;; å¦‚æžœè¯´çŸ¥é“è¿™ä¸ªè€ƒç‚¹æ˜¯ äºŒåˆ†ï¼Œé‚£ä¹ˆè¿˜æ˜¯å¾ˆç®€å•çš„ï¼Œåœ¨åˆ¤æ–­æ¡ä»¶æ—¶å€™ï¼Œéœ€è¦æ³¨æ„ä¸‹. 123456789101112131415class Solution &#123;public: int findPeakElement(vector&lt;int&gt;&amp; nums) &#123; int n =nums.size(); int l =0, r =n-1; while(l &lt;r) &#123; int mid =l +r &gt;&gt;1; if(mid +1 &lt;n &amp;&amp; nums[mid] &lt;= nums[mid +1]) l =mid +1; else r =mid; &#125; return l; &#125;&#125;; Find First and Last Position of Element in Sorted Array åˆ’åˆ†ç»“ç‚¹çš„é€‰æ‹©ï¼Œä¸€å®šæ˜¯å‡å®šmid å°±æ˜¯é‚£ä¸ªèƒ½å¤Ÿåˆ’åˆ†æˆä¸¤ä¸ªéƒ¨åˆ†çš„ç»“ç‚¹ã€‚å¥½å¥½ç†è§£ä¸€ä¸‹ 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: // è‡ªå·±å†™è¿™ç§å‡½æ•°çš„çš„æ—¶å€™ï¼Œä¸€å®šè¦ä»¥ mid ä½œä¸ºåˆ†è£‚ç‚¹çœ‹ vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int n =nums.size(); if (n ==0) return vector&lt;int&gt;&#123;-1, -1&#125;; int l =0, r =n-1; while(l &lt;r) &#123; int mid = l +r &gt;&gt;1; if(nums[mid] &lt; target) l =mid+1 ; else r =mid ; &#125; //cout &lt;&lt; l &lt;&lt; endl; if(nums[l] != target) return vector&lt;int&gt;&#123;-1, -1&#125;; int left =l; l =0, r =n-1; while(l &lt;r) &#123; int mid =l +r +1&gt;&gt;1; if(nums[mid]&gt; target ) r =mid -1; else l =mid ; &#125; int right =l; if(left&gt;=0 &amp;&amp; l&lt; n) return vector&lt;int&gt;&#123;left, right&#125;; return vector&lt;int&gt;&#123;-1, -1&#125;; &#125;&#125;; éœ€è¦æ³¨æ„ä¸€äº›ç»†èŠ‚ï¼Œå…¶ä»–çš„éƒ½è¿˜å¥½.æ³¨æ„å¯ä»¥ç›´æŽ¥ä½¿ç”¨ vector res{-1,-1} è¿™æ ·çš„å½¢å¼è¿›è¡Œåˆå§‹åŒ– 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: // æœ‰é‡å¤çš„å…ƒç´ ï¼Œæ‰¾åˆ°é‡å¤å…ƒç´ çš„é¦–å°¾ï¼Œä½¿ç”¨ä¸¤æ¬¡ äºŒåˆ† // èµ·ç‚¹çš„å·¦è¾¹æ˜¯ä¸¥æ ¼å°äºŽ element, å³è¾¹æ˜¯å¤§äºŽç­‰äºŽ; // ç»ˆç‚¹çš„å³è¾¹æ˜¯ä¸¥æ ¼å¤§äºŽ elementï¼Œå·¦è¾¹æ˜¯å°äºŽç­‰äºŽ vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res&#123;-1, -1&#125;; if(nums.size() ==0) return res; int n =nums.size(); int l =0, r =n -1; while(l &lt;r) &#123; int mid = l+r &gt;&gt;1; if(nums[mid] &lt; target) l =mid +1; else r =mid; &#125; if(l &gt;= n || nums[l] != target) return res; int left = l; l =0, r =n -1; while(l &lt;r) &#123; int mid = l+r+1 &gt;&gt;1; if(nums[mid] &gt; target) r =mid-1; else l =mid; &#125; if(l &gt;=n) return res; return vector&lt;int&gt;&#123;left, l&#125;; &#125;&#125;; LeetCode278 ç¬¬ä¸€ä¸ªé”™è¯¯çš„ç‰ˆæœ¬ ç”±äºŽæ¯ä¸ªç‰ˆæœ¬éƒ½æ˜¯åŸºäºŽä¹‹å‰çš„ç‰ˆæœ¬å¼€å‘çš„ï¼Œæ‰€ä»¥é”™è¯¯çš„ç‰ˆæœ¬ä¹‹åŽçš„æ‰€æœ‰ç‰ˆæœ¬éƒ½æ˜¯é”™çš„ã€‚ä½ å¯ä»¥é€šè¿‡è°ƒç”¨ bool isBadVersion(version) æŽ¥å£æ¥åˆ¤æ–­ç‰ˆæœ¬å· version æ˜¯å¦åœ¨å•å…ƒæµ‹è¯•ä¸­å‡ºé”™ã€‚å®žçŽ°ä¸€ä¸ªå‡½æ•°æ¥æŸ¥æ‰¾ç¬¬ä¸€ä¸ªé”™è¯¯çš„ç‰ˆæœ¬ã€‚ä½ åº”è¯¥å°½é‡å‡å°‘å¯¹è°ƒç”¨ API çš„æ¬¡æ•°ã€‚ é¢˜ç›®éžå¸¸ç®€å•ï¼Œç›´æŽ¥å¥—ç”¨æ¨¡æ¿#2å³å¯ã€‚æ­¤é¢˜ä¸Žæ¨¡æ¿#1çš„æœ€å¤§åŒºåˆ«å°±åœ¨äºŽï¼Œrightä¸èƒ½ä¿®æ”¹ä¸ºmid-1ï¼Œè€Œå¿…é¡»ä¿®æ”¹ä¸ºmidã€‚å› ä¸ºå½“å¦‚æžœmidæ˜¯é”™è¯¯äº§å“ï¼Œæ— æ³•åˆ¤æ–­ç¬¬ä¸€ä¸ªé”™è¯¯ç‰ˆæœ¬åœ¨midä¹‹å‰ï¼Œè¿˜æ˜¯å°±æ˜¯å½“å‰midã€‚è¿™æ˜¯æ¨¡æ¿#2ä¸Žæ¨¡æ¿#1çš„æœ€å¤§ä¸åŒã€‚ 12345678910111213class Solution &#123;public: int firstBadVersion(int n) &#123; long left = 0; long right = n; while(left&lt;right)&#123; long mid = (left+right)/2; //è®¡ç®—ä¸­ç‚¹ if(isBadVersion(mid)==false) left = mid+1; //å¦‚æžœmidæ˜¯æ­£å¸¸äº§å“ï¼Œè¯æ˜Žç¬¬ä¸€ä¸ªé”™è¯¯äº§å“åœ¨å³ä¾§ if(isBadVersion(mid)==true) right = mid; //å¦‚æžœmidæ˜¯é”™è¯¯äº§å“ï¼Œè¯æ˜Žç¬¬ä¸€ä¸ªé”™è¯¯äº§å“åœ¨æ˜¯è‡ªå·±æˆ–è€…åœ¨å·¦ä¾§ &#125; return left; &#125;&#125;; Find Minimum in Rotated Sorted Array II å¦‚æžœæœ‰é‡å¤çš„å…ƒç´ ï¼Œé‚£ä¹ˆæ˜¯ä»Žå³è¾¹å¼€å§‹è¿›è¡Œæ¯”è¾ƒã€‚å¥½å¥½è€ƒè™‘è¿™ç§åˆç†æ€§ã€‚ 123456789101112131415161718class Solution &#123;public: // å¯¹äºŽè¿™ç§ duplicates æ˜¯å¾ˆå®¹å‡ºæ¥çš„ int findMin(vector&lt;int&gt;&amp; arr) &#123; int n =arr.size(); if(n ==1) return arr[0]; if(arr[0] &lt; arr.back()) return arr[0]; int l =0, r =n -1; while(l &lt;r) &#123; int mid = l +r &gt;&gt;1; if(arr[mid] &gt; arr[r]) l =mid +1; else if(arr[mid] &lt; arr[r]) r =mid; else r --; &#125; return arr[l]; &#125;&#125;; è§£é¢˜çš„æ€è·¯ï¼Œå…ˆæ˜¯å¤„ç†ä¸»é¢˜çš„å†…å®¹ï¼Œä½¿ç”¨äºŒåˆ†çš„åšæ³•ï¼Œç„¶åŽå¤„ç†ä¸€ä¸ªcase çš„ä¸œè¥¿ï¼Œæ¯”å¦‚ é‡å¤çš„å…ƒç´ æˆ–è€…æ˜¯æ­£åºçš„æƒ…å†µã€‚æ³¨æ„ r &gt;0 è€Œä¸æ˜¯ r&gt;=0 123456789101112131415161718192021class Solution &#123;public: // åœ¨æ—‹è½¬æ•°ç»„ä¸­å¯»æ‰¾æœ€å°çš„å€¼ int findMin(vector&lt;int&gt;&amp; nums) &#123; int n =nums.size(); if(n ==1) return nums[0]; int l=0, r =n -1; // å¤„ç†é‡å¤çš„, r &gt; 0 è¿™ä¸ªå¾ˆé‡è¦å‘€ï¼Œä¸æ˜¯ &gt;=0 while(r &gt;0 &amp;&amp;nums[r] ==nums[l]) r --; // å¤„ç†æ­£åºçš„æƒ…å†µ if(nums[l] &lt; nums[r]) return nums[l]; while(l &lt;r) &#123; int mid =l +r &gt;&gt;1; if(nums[mid] &gt;= nums[0]) l =mid +1; else r =mid; &#125; return nums[l]; &#125;&#125;; å¯¹äºŽäºŒåˆ†çš„è§£æ³•ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ $O(logn)$ï¼Œ å› ä¸ºæ¯æ¬¡éƒ½æ˜¯å¯ä»¥åŽ»æŽ‰ä¸€éƒ¨åˆ†æ•°å­—ã€‚ 123456789101112131415161718// Forward declaration of isBadVersion API.bool isBadVersion(int version);class Solution &#123;public: // å¦‚æžœç¬¬ i ä¸ªç‰ˆæœ¬æ˜¯é”™è¯¯çš„ï¼Œé‚£ä¹ˆ i+1 ä¹Ÿä¸€å®šæ˜¯é”™è¯¯çš„ï¼Œæ‰€ä»¥ i æž„æˆäº†äºŒåˆ†çš„æ¡ä»¶ int firstBadVersion(int n) &#123; int l =1, r =n; while(l &lt;r) &#123; int mid = l +0ll +r &gt;&gt;1; if(isBadVersion(mid)) r =mid ; else l =mid +1; &#125; return l; &#125;&#125;; isBadVersion æ—¶é—´å¤æ‚åº¦æ˜¯$O(logn)$ 123456789101112131415161718// Forward declaration of isBadVersion API.bool isBadVersion(int version);class Solution &#123;public: // äºŒåˆ†çš„æœ¬è´¨æ˜¯å¯ä»¥åˆ†å—æŸ¥æ‰¾ï¼Œæ‰¾åˆ°ä¸€ä¸ªåˆ†ç•Œç‚¹ï¼Œå·¦è¾¹æ˜¯ä¸€ç§æƒ…å†µï¼Œå³è¾¹æ˜¯å¦ä¸€ç§æƒ…å†µã€‚ //mid æ˜¯åçš„ç‰ˆæœ¬ï¼Œr =midï¼Œ å¦‚æžœmid æ˜¯å¥½çš„ç‰ˆæœ¬ï¼Œ l =mid +1 ï¼ˆè¿™ç§åŠ ä¸€ or ä¹‹é—´ç­‰äºŽæ˜¯æ ¹æ®å®žé™…é—®é¢˜ä½œå‡ºçš„é€‰æ‹©ï¼‰ // ç„¶åŽæ ¹æ®è¿™ç§æƒ…å†µï¼ŒåŽ»é€‰æ‹©ç¬¬ä¸€ä¸ªæˆ–è€…æ˜¯ç¬¬äºŒä¸ªç‰ˆæœ¬çš„æ¨¡æ¿ int firstBadVersion(int n) &#123; int l =1, r =n; while(l &lt;r) &#123; int mid = (0ll+l +r )/2; // è¿™ä¸ªå¯èƒ½äº§ç”Ÿæº¢å‡ºçš„é—®é¢˜ï¼Œ æ³¨æ„ç»†èŠ‚ï¼Œå¦‚æžœ 0ll æ”¾åˆ°äº†æœ€åŽï¼Œé‚£ä¹ˆåŒæ ·æ˜¯ä¼šæº¢å‡ºï¼Œå› ä¸ºä¸‰ä¸ªæ•°ç›¸åŠ æœ¬è´¨ä¸Šæ˜¯ä¸¤ä¸ªæ•°å…ˆç›¸åŠ ç„¶åŽåŠ ä¸Šç¬¬ä¸‰ä¸ªæ•° if(isBadVersion(mid)) r =mid; else l =mid +1; &#125; return l; &#125;&#125;; Find Minimum in Rotated Sorted Array 123456789101112131415161718192021222324252627282930class Solution &#123;public: // æœ€å°å€¼å‰é¢çš„æ•°å­—éƒ½æ»¡è¶³ nums[i] &gt;= nums[0]ï¼Œ æœ€å°å€¼åŽé¢çš„æ•°å­—éƒ½ä¸æ»¡è¶³ // è¿™ä¸ªå°±å½¢æˆäº†åˆ†å—ï¼ˆå¯ä»¥ä½¿ç”¨äºŒåˆ†ï¼‰ // å¦‚æžœ nums[mid] &gt;= nums[0] , l =mid +1, r =mid int findMin(vector&lt;int&gt;&amp; nums) &#123; // æ³¨æ„è¿™ä¸ªæ˜¯ä¸¥æ ¼çš„å¤§äºŽå·ï¼Œå› ä¸ºæ²¡æœ‰é‡å¤å…ƒç´ ï¼Œæ‰€ä»¥å¯ä»¥è¿™ä¹ˆæ“ä½œ if(nums.back() &gt; nums[0]) return nums[0]; // è¿™ä¸ªæ˜¯è¾¹ç•Œé—®é¢˜çš„ä¸€ç§å¤„ç†æ–¹æ³•ï¼Œ è¿™ä¸ªæ˜¯ä¸€ç§æ–¹å¼ï¼ˆå…³é”®æ˜¯ä¸å½±å“æ—¶é—´å¤æ‚åº¦çš„ï¼Œå¸¸æ•°çº§åˆ«çš„ï¼‰ /* if(nums.size() &lt;=5) &#123; int min_v =INT_MAX; for(auto u : nums) min_v =min(min_v, u); return min_v; &#125; */ int l =0, r =nums.size() -1; while(l &lt;r) &#123; int mid =(l +r )/2; if( nums[mid] &gt;=nums[0]) l =mid +1; else r =mid; &#125; return nums[l]; &#125;&#125;; é¢˜ç›®éžå¸¸ç®€å•ï¼Œç›´æŽ¥å¥—ç”¨æ¨¡æ¿#2å³å¯ã€‚æ­¤é¢˜ä¸Žæ¨¡æ¿#1çš„æœ€å¤§åŒºåˆ«å°±åœ¨äºŽï¼Œrightä¸èƒ½ä¿®æ”¹ä¸ºmid-1ï¼Œè€Œå¿…é¡»ä¿®æ”¹ä¸ºmidã€‚å› ä¸ºå½“å¦‚æžœmidæ˜¯é”™è¯¯äº§å“ï¼Œæ— æ³•åˆ¤æ–­ç¬¬ä¸€ä¸ªé”™è¯¯ç‰ˆæœ¬åœ¨midä¹‹å‰ï¼Œè¿˜æ˜¯å°±æ˜¯å½“å‰midã€‚è¿™æ˜¯æ¨¡æ¿#2ä¸Žæ¨¡æ¿#1çš„æœ€å¤§ä¸åŒã€‚ æ¨¡æ¿3æ¨¡æ¿ 3 æ˜¯äºŒåˆ†æŸ¥æ‰¾çš„å¦ä¸€ç§ç‹¬ç‰¹å½¢å¼ã€‚å®ƒç”¨äºŽæœç´¢éœ€è¦è®¿é—®å½“å‰ç´¢å¼•åŠå…¶åœ¨æ•°ç»„ä¸­çš„ç›´æŽ¥å·¦å³é‚»å±…ç´¢å¼•çš„å…ƒç´ æˆ–æ¡ä»¶ã€‚æœç´¢æ¡ä»¶éœ€è¦è®¿é—®å…ƒç´ çš„ç›´æŽ¥å·¦å³é‚»å±…ã€‚ä½¿ç”¨å…ƒç´ çš„é‚»å±…æ¥ç¡®å®šå®ƒæ˜¯å‘å³è¿˜æ˜¯å‘å·¦ã€‚ä¿è¯æŸ¥æ‰¾ç©ºé—´åœ¨æ¯ä¸ªæ­¥éª¤ä¸­è‡³å°‘æœ‰ 3 ä¸ªå…ƒç´ ã€‚éœ€è¦è¿›è¡ŒåŽå¤„ç†ã€‚ å½“å‰©ä¸‹ 2 ä¸ªå…ƒç´ æ—¶ï¼Œå¾ªçŽ¯ / é€’å½’ç»“æŸã€‚ éœ€è¦è¯„ä¼°å…¶ä½™å…ƒç´ æ˜¯å¦ç¬¦åˆæ¡ä»¶ã€‚ å¯¹åº”çš„leetcode ä¾‹é¢˜LeetCode34 åœ¨æŽ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åŽä¸€ä¸ªä½ç½®LeetCode658 æ‰¾åˆ° K ä¸ªæœ€æŽ¥è¿‘çš„å…ƒç´  è¯­æ³•å…³é”®ï¼š åˆå§‹æ¡ä»¶ï¼šleft = 0, right = length-1ç»ˆæ­¢ï¼šleft + 1 == rightå‘å·¦æŸ¥æ‰¾ï¼šright = midå‘å³æŸ¥æ‰¾ï¼šleft = mid binarySearch æ¨¡æ¿é¢˜ 12345678910111213141516171819202122int binarySearch(vector&lt;int&gt;&amp; nums, int target)&#123; if (nums.size() == 0) return -1; int left = 0, right = nums.size() - 1; while (left + 1 &lt; right)&#123; // Prevent (left + right) overflow int mid = left + (right - left) / 2; if (nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &lt; target) &#123; left = mid; &#125; else &#123; right = mid; &#125; &#125; // Post-processing: // End Condition: left + 1 == right if(nums[left] == target) return left; if(nums[right] == target) return right; return -1;&#125; æ¥ä¸ªæ¨¡æ¿, æ‰€è°“çš„è®¿é—®æ–‡ä»¶ä¿ç•™å‡ ä¸ªå…ƒç´ ï¼Œå°±æ˜¯åŒ…æ‹¬ä¸Žå¦mid çš„æ„æ€ã€‚å¦‚æžœ left å’Œ right éƒ½å¯ä»¥ä¸º midï¼Œé‚£ä¹ˆå°±æ˜¯ä¸‰ä¸ªè®¿é—®ç©ºé—´ï¼›å¦‚æžœåªæœ‰ left or right å¯ä»¥= midï¼Œé‚£ä¹ˆå°±æ˜¯ä¸¤ä¸ªè®¿é—®ç©ºé—´ï¼›å¦‚æžœ left =mid -1 ä¸” right =mid +1 é‚£ä¹ˆåªæœ‰ä¸€ä¸ªè®¿é—®ç©ºé—´ã€‚åŒæ ·ä¸‰ä¸ªæ¡ä»¶ä¾æ¬¡ä¸º left &lt;= right, left &lt; right å’Œ left +1 &lt; right ä¿è¯è®¿é—®ç©ºé—´æ˜¯å¯ä»¥ access çš„ã€‚ æ€»ç»“å¦‚ä¸‹ï¼š Find K Closest Elements è¿™ä¸ªç®—æ³•å¤ªç²¾å¦™äº†ï¼ŒçœŸçš„æ˜¯éš¾ä»¥ç†è§£äº†ã€‚æ€»çš„æ—¶é—´å¤æ‚åº¦ $O(log(n -k) +k)$123456789101112131415class Solution &#123;public: //æ—¶é—´å¤æ‚åº¦ O(log (n-k) +k) vector&lt;int&gt; findClosestElements(vector&lt;int&gt;&amp; arr, int k, int x) &#123; int n = arr.size(); int l =0, r =n -k; while( l&lt; r) &#123; int mid = l +r &gt;&gt;1; if(x -arr[mid] &gt; arr[mid+k] -x) l =mid +1; else r =mid; &#125; return vector&lt;int&gt;(arr.begin() +l, arr.begin() +l+k); &#125;&#125;; å…³é”®æ˜¯æ˜¯äºŒåˆ†çš„æ¡ä»¶æ¯”è¾ƒéš¾æƒ³ï¼Œå¯ä»¥ä½¿ç”¨æžç«¯çš„æ€è·¯ï¼Œ å¦‚æžœ x - arr[mid] ä¹‹é—´çš„è·ç¦»æ˜¯å¤§äºŽ arr[mid+k] -x é‚£ä¹ˆè¿™ä¸ªæ˜¯éœ€è¦è°ƒæ•´ l çš„è·ç¦»ï¼Œç„¶åŽé è¿‘mid` ;åä¹‹ï¼Œä¹Ÿæ˜¯æˆç«‹çš„ã€‚ 12345678910111213141516class Solution &#123;public: // ä½¿ç”¨äºŒåˆ†çš„æ€æƒ³ï¼Œ æ—¶é—´å¤æ‚åº¦æ˜¯logn çš„ vector&lt;int&gt; findClosestElements(vector&lt;int&gt;&amp; arr, int k, int x) &#123; int n =arr.size() ; int l =0, r = n -k; while(l &lt;r) &#123; int mid =l +r &gt;&gt;1; if(x - arr[mid] &gt; arr[mid+k] -x) l =mid +1; else r =mid; &#125; // è¿™ç§å†™æ³•ä¹Ÿæ˜¯éœ€è¦å¤šåŠ å­¦ä¹ çš„ return vector&lt;int&gt;&#123;arr.begin() +l, arr.begin() +l +k&#125;; &#125;&#125;; æµ®ç‚¹æ•°äºŒåˆ†ç®—æ³• æµ®ç‚¹äºŒåˆ†ä¸å­˜åœ¨ +1 è¿˜æ˜¯ -1 çš„æ“ä½œï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ç²¾åº¦é—®é¢˜ã€‚ æ•°çš„ä¸‰æ¬¡æ–¹æ ¹ double å’Œ float çš„åŒºåˆ«ï¼šfloat ï¼šå•ç²¾åº¦æµ®ç‚¹æ•°åœ¨æœºå†…å 4ä¸ªå­—èŠ‚ï¼Œç”¨32ä½äºŒè¿›åˆ¶æè¿°ã€‚doubleï¼šåŒç²¾åº¦æµ®ç‚¹æ•°åœ¨æœºå†…å 8ä¸ªå­—èŠ‚ï¼Œç”¨64ä½äºŒè¿›åˆ¶æè¿°ã€‚ 1234567891011121314151617#include&lt;iostream&gt;using namespace std;double x;int main()&#123; cin &gt;&gt;x; double l = -10000, r = 100000; // å¦‚æžœæ˜¯ä¿ç•™6 ä½æ¶ˆå¤±ï¼Œé‚£ä¹ˆä½¿ç”¨ 1e-8ï¼Œå¦‚æžœæ˜¯2ä½ï¼Œé‚£ä¹ˆæ˜¯ 1e-4 while(r -l &gt; 1e-8) &#123; double mid = (l+r) /2; if(mid *mid *mid &gt;x) r =mid; else l =mid; &#125; printf(&quot;%.6f&quot;, l);// è¾“å‡ºçš„æ ¼å¼ %.6f è¡¨ç¤ºdouble ç±»åž‹ return 0;&#125; 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; double n; cin &gt;&gt;n; double l =-10000, r = 10000; while(r -l &gt; 1e-8) &#123; double mid = (l+r) /2; if(mid *mid *mid &gt; n) r =mid; else l =mid; &#125; printf("%.6f\n", l); return 0;&#125; å‚è€ƒæ–‡çŒ®ï¼š æ•°æ®ç»“æž„ä¹Ÿä¸éš¾ï¼šäºŒåˆ†æŸ¥æ‰¾æ¨¡ç‰ˆä¸Žä¾‹é¢˜ python å¯¹äºŽ binary search çš„æ”¯æŒåŒ…å‡½æ•° bisect 1234567891011121314151617import bisect L = [1,3,3,6,8,12,15]x = 3 x_insert_point = bisect.bisect_left(L,x) #åœ¨Lä¸­æŸ¥æ‰¾xï¼Œxå­˜åœ¨æ—¶è¿”å›žxå·¦ä¾§çš„ä½ç½®ï¼Œxä¸å­˜åœ¨è¿”å›žåº”è¯¥æ’å…¥çš„ä½ç½®..è¿™æ˜¯3å­˜åœ¨äºŽåˆ—è¡¨ä¸­ï¼Œè¿”å›žå·¦ä¾§ä½ç½®ï¼‘print x_insert_point x_insert_point = bisect.bisect_right(L,x) #åœ¨Lä¸­æŸ¥æ‰¾xï¼Œxå­˜åœ¨æ—¶è¿”å›žxå³ä¾§çš„ä½ç½®ï¼Œxä¸å­˜åœ¨è¿”å›žåº”è¯¥æ’å…¥çš„ä½ç½®..è¿™æ˜¯3å­˜åœ¨äºŽåˆ—è¡¨ä¸­ï¼Œè¿”å›žå³ä¾§ä½ç½®ï¼“ print x_insert_point x_insort_left = bisect.insort_left(L,x) #å°†xæ’å…¥åˆ°åˆ—è¡¨Lä¸­ï¼Œxå­˜åœ¨æ—¶æ’å…¥åœ¨å·¦ä¾§print L x_insort_rigth = bisect.insort_right(L,x) #å°†xæ’å…¥åˆ°åˆ—è¡¨Lä¸­ï¼Œxå­˜åœ¨æ—¶æ’å…¥åœ¨å³ä¾§ é˜²æ­¢è¶Šç•Œçš„tipsï¼šchange â€œmid = (low + high) / 2 â€œ -&gt; â€œmid = low + (high - low) / 2 â€œæˆ–è€…ä½¿ç”¨ â€mid = (low + high) &gt;&gt; 1â€œï¼Œ]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>binary-search</tag>
      </tags>
  </entry>
</search>
