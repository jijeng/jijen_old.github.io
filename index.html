<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Stay Hungry, Stay Foolish">
<meta property="og:type" content="website">
<meta property="og:title" content="Jijeng&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Jijeng&#39;s blog">
<meta property="og:description" content="Stay Hungry, Stay Foolish">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jijeng&#39;s blog">
<meta name="twitter:description" content="Stay Hungry, Stay Foolish">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Jijeng's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jijeng's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/17/剑指offer-其他/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jijeng Jia">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jijeng's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/17/剑指offer-其他/" itemprop="url">剑指offer-其他</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-17T20:41:38+08:00">
                2019-05-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这是剑指offer 系列四部曲中的最后一部，因为有些算法题目类别数量太少就汇总到了”其他“, 比如位运算、正则匹配等。第一部关于字符串和数组，第二部是栈、队列、链表和树， 第三部递归、回溯和动态规划。</p>
<ul>
<li>二进制中1的个数</li>
</ul>
<blockquote>
<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
</blockquote>
<pre><code>class Solution:
def NumberOf1(self, n):
    # write code here
    if n ==0:
        return 0
    counts =0
    if n&gt; 0:
        counts =self.number_of_positive(n)
    else:
        n = abs(n)-1
        counts =32 - self.number_of_positive(n)
    return counts

def number_of_positive(self, n):
    if n ==0:
        return 0
    counts =0
    while n:
        counts += (n&amp;1)
        n =n &gt;&gt;1
    return counts
</code></pre><ul>
<li>数值的整数次方</li>
</ul>
<blockquote>
<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
</blockquote>
<pre><code>class Solution:
&quot;&quot;&quot;
这个就是边界条件比较多而已，需要分别判断 base 和 exponent 的正负
&quot;&quot;&quot;
def Power(self, base, exponent):
    # write code here

    if base ==0 and exponent != 0:
        return 0
    if base != 0 and exponent ==0:
        return 1
    flag =1
    if base &lt;=0 and (exponent %2 ==1):
        flag =-1
    base = abs(base)
    result =1
    if exponent &gt; 0:
        reverse =0
    else:
        reverse  =1

    exponent =abs(exponent)
    if exponent %2 ==0:
        result = base * base
        for i in range(exponent//2 -1):
            result = result * result
    else:
        result = base * base
        for i in range(exponent//2 -1):
            result = result * result
        result = result * base

    if reverse:
        result = 1.0/ result
    return result* flag
</code></pre><ul>
<li>最小的K个数</li>
</ul>
<blockquote>
<p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
</blockquote>
<pre><code>class Solution:
# 想说的是既然是使用这种开源的库函数 那么就记住这种函数名字
def GetLeastNumbers_Solution(self, tinput, k):
    # write code here
    if len(tinput) &lt;k:
        return []
    import heapq

    res = heapq.nsmallest(k, tinput)
    return res
</code></pre><ul>
<li>整数中1出现的次数（从1到n整数中1出现的次数）</li>
</ul>
<blockquote>
<p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p>
</blockquote>
<pre><code>class Solution:
# 数字的基本结构分成  weights +working_num + n%base 这三个部分
# 然后一个while 循环是处理一个数字
def NumberOf1Between1AndN_Solution(self, n):
    # write code here
    if n &lt;1:
        return 0
    num =n
    counts =0
    base =1
    while num:
        weights =num%10
        num = num//10
        counts += base * num
        if weights ==1:
            counts += (n%base) +1
        elif weights &gt;1:
            counts += base
        base *=10
    return counts
</code></pre><ul>
<li>把数组排成最小的数</li>
</ul>
<blockquote>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
</blockquote>
<pre><code>class Solution:
def PrintMinNumber(self, numbers):
    # write code here

    sorted_list =sorted(numbers, cmp= lambda a,b :cmp(str(a)+ str(b), str(b)+str(a)))
    # 这个时候已经排好序，然后只要一个个连接起来就行了
    return &apos;&apos;.join(map(str, sorted_list))
</code></pre><ul>
<li>丑数</li>
</ul>
<blockquote>
<p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
</blockquote>
<pre><code>class Solution:
# 在进行 append 操作的时候去重，
def GetUglyNumber_Solution(self, index):
    # write code here
    if index &lt;1:
        return 0
    list1 =[1]
    # 意味着只能是 append() 操作了
    i, j, k =0,0,0
    while len(list1) &lt; index:
        num =min( list1[i] *2, list1[j]*3, list1[k] *5)
        if num &gt; list1[-1]:
            list1.append(num)

        if num ==list1[i] *2:
            i +=1
        elif num ==list1[j] *3:
            j +=1
        else:
            k +=1
    return list1[-1]
</code></pre><ul>
<li>正则表达式匹配</li>
</ul>
<blockquote>
<p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p>
</blockquote>
<pre><code>class Solution:
# s, pattern都是字符串
# 思想就是 dp, 转换方程 dp[i][j] i 表示 string 的index j表示 pattern 的index
# 有三种转换方程 dp[i][j] ==dp[i-1][j-1] or dp[i][j] =dp[i][j-2] or dp[i][j-1] 
# https://www.youtube.com/watch?v=l3hda49XcDE 心中一定要有这个表格, a[i][j] 这个更像是一种指针
def match(self, s, pattern):
    if len(s) ==0 and len(pattern) ==0:
        return True
    dp =[[ False for _ in range(len(pattern) +1)] for _ in range(len(s) +1)]
    dp[0][0] =True
    for j in range(1, len(pattern)+1):
        if pattern[j-1] ==&quot;*&quot;:

            dp[0][j] =dp[0][j-2]
    for i in range(1, len(s)+1):
        for j in range(1, len(pattern)+1):
            if pattern[j-1] ==s[i-1] or pattern[j-1] ==&quot;.&quot;:
                dp[i][j] =dp[i-1][j-1]

            elif pattern[j-1] ==&quot;*&quot;:

                dp[i][j] =dp[i][j-2]
                if s[i-1] ==pattern[j-2] or pattern[j-2] ==&quot;.&quot;:
                    dp[i][j] =dp[i][j] or dp[i-1][j]
            else:
                dp[i][j] =False
    return dp[len(s)][len(pattern)]
</code></pre><ul>
<li>数据流中的中位数</li>
</ul>
<blockquote>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
</blockquote>
<pre><code>class Solution:
    &quot;&quot;&quot;
    对于数据流 这个应该是第二次接触了，需要使用一个全局变量
    &quot;&quot;&quot;
    # 虽然知道这个使用 堆的思想是更优的，搜索时间可以O（1）， 堆的调整是 O(log n)
    # 但是没有什么很好的教程，所以我也没有学会啊
    def __init__(self):
        self.list1 = []
    def Insert(self, num):
        self.list1.append(num)
    def GetMedian(self, ch):
        length = len(self.list1)
        # 我记得有一个更加快一些
        self.list1 = sorted(self.list1)
        if length % 2 == 0:
            return (self.list1[length // 2] + self.list1[length // 2 - 1]) / 2.0
        else:
            return self.list1[length // 2]
</code></pre><ul>
<li>滑动窗口的最大值</li>
</ul>
<blockquote>
<p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
</blockquote>
<pre><code>class Solution:
# 最简单的模拟滑动窗口 的过程
def maxInWindows(self, num, size):
    slip =[]
    if not num or len(num) &lt; size or size ==0:
        return []
    for i in range(len(num) -size +1):
        slip.append(max(num[i:i+size]))
    return slip
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/17/剑指offer-递归-回溯和动态规划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jijeng Jia">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jijeng's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/17/剑指offer-递归-回溯和动态规划/" itemprop="url">剑指offer-递归、回溯和动态规划</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-17T20:40:33+08:00">
                2019-05-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这是剑指offer 系列四部曲中的第三部：递归、回溯和动态规划。第一部关于字符串和数组，第二部是栈、队列、链表和树， 最后一部分在这里。</p>
<ul>
<li>斐波那契数列</li>
</ul>
<blockquote>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。<br>n&lt;=39</p>
</blockquote>
<pre><code>class Solution:
# python 中list 的初始化，最开始的是从0 开始，所以是需要多进行一个初始化的
def Fibonacci(self, n):
    # write code here
    if n ==0:
        return 0
    if n ==1:
        return 1
    arr = [0]*(n+1)
    arr[0] =0
    arr[1] =1
    for i in range(2,n+1):
        arr[i] =arr[i-1] + arr[i-2]
    return arr[n]
</code></pre><ul>
<li>跳台阶</li>
</ul>
<blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
</blockquote>
<pre><code>class Solution:
def jumpFloor(self, number):
    # write code here
    if number ==1:
        return 1
    if number ==2:
        return 2

    arr =[0]*(number +1)
    arr[1] =1
    arr[2] =2
    for i in range(3, number +1):
        arr[i] =arr[i-1] + arr[i-2]

    return arr[number]
</code></pre><ul>
<li>跳台阶2</li>
</ul>
<blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
<pre><code>class Solution:
&quot;&quot;&quot;
在使用 for循环的时候，注意 range() 这种取值，究竟是使用 range() 作为次数的计量；
还是要使用range 中的index 。两者是不相同的操作，尤其是对于前后的取值。
&quot;&quot;&quot;
def jumpFloorII(self, number):
    # write code here
    if number ==1:
        return 1
    nums =1
    for i in range(number-1):
        nums = nums *2
    return nums
</code></pre><ul>
<li>矩形覆盖</li>
</ul>
<blockquote>
<p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
</blockquote>
<pre><code>&quot;&quot;&quot;
既然结果只是最后一个解，那么就没有必要保存中间变量，所以只是，
所以空间复杂度从O（n） -&gt; O(1) ，这个是超级nice的
&quot;&quot;&quot;
class Solution:
    def rectCover(self, number):
        # write code here
        if number &lt;=0:
            return 0
        if number &lt;=2:
            return number
        # 只是两个变量罢了
        a ,b = 1,2
        while number &gt;2:
            a, b = b, a+b
            number -=1
        return b
</code></pre><ul>
<li>机器人的运动范围</li>
</ul>
<blockquote>
<p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
</blockquote>
<pre><code>class Solution:
def movingCount(self, threshold ,rows, cols):
    visited =[False] *(rows*cols)
    count =self.movingCountCore(threshold, rows, cols, 0, 0, visited)
    return count

def movingCountCore(self, threshold, rows, cols, row, col, visited):
    count =0
    # 就是这个访问记录是需要进行变化的， 如果是false ，然后访问之后 是需要设置为 true的
    if self.check(threshold, rows, cols, row, col, visited):
        visited[row*cols +col] =True
        count = 1+ self.movingCountCore(threshold, rows, cols, row, col-1, visited)+\
                self.movingCountCore(threshold, rows, cols, row, col +1, visited) + \
                self.movingCountCore(threshold, rows, cols, row+1, col, visited) + \
                self.movingCountCore(threshold, rows, cols, row-1, col, visited)
    return count
def check(self, threshold, rows, cols, row, col, visited):
    if row&gt;=0 and row&lt; rows and col&gt;=0 and col&lt;cols and self.judge(threshold, row, col) and not visited[row*cols +col]:
        return True
    else:
        return False

def judge(self, threshold, i, j):
    if sum(map(int, str(i)+str(j))) &lt;= threshold:
        return True
    else:
        return False
</code></pre><ul>
<li>矩阵中的路径</li>
</ul>
<blockquote>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
</blockquote>
<pre><code>class Solution:
# 递归 这个是 true or false 判断类型的。
# 思路：先是 rows* cols 这样的全部遍历
def hasPath(self, matrix, rows, cols, path):
    # 如果使用 [ for _in range(rows) ] for _ in range(cols) ， 这个是有结构的 rows* cols
    assist =[True] * rows*cols
    for i in range(rows):
        for j in range(cols):
            if self.rightPath( matrix, rows, cols, i, j, path, assist):
                return True
    return False

def rightPath(self, matrix, rows, cols, i, j, path, assist):
    if not path:
        return True
    index =i*cols +j
    if i&lt;0 or i&gt;= rows or j&lt;0 or j&gt;=cols or matrix[index]!=path[0] or assist[index] ==False:
        return False
    assist[index] =False
    if (self.rightPath(matrix, rows, cols, i+1, j, path[1:], assist) or
        self.rightPath(matrix, rows, cols, i-1, j, path[1:], assist)or
        self.rightPath(matrix, rows, cols, i, j-1, path[1:], assist) or
        self.rightPath(matrix, rows, cols, i, j+1, path[1:], assist)):
        return True
    assist[index] =True
    return False
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/17/剑指Offer-栈-队列-链表和树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jijeng Jia">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jijeng's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/17/剑指Offer-栈-队列-链表和树/" itemprop="url">剑指Offer-栈、队列、链表和树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-17T20:35:57+08:00">
                2019-05-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这是剑指offer 系列四部曲中的第二部：栈、队列、链表和树。第一部关于字符串和数组，第三部是递归、回溯和动态规划， 最后一部分在这里。</p>
<ul>
<li>从尾到头打印链表</li>
</ul>
<blockquote>
<p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
</blockquote>
<pre><code># -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    # 返回从尾部到头部的列表值序列，例如[1,2,3]
    # += , -= 这个都是同一种类型的
    def printListFromTailToHead(self, listNode):
        # write code here
        arraylist =[]
        head =listNode
        while head !=None:
            arraylist += [head.val]
            # 这个在这里等效于 arraylist.append(head.val)
            head = head.next
        return arraylist[::-1]
</code></pre><ul>
<li>重建二叉树</li>
</ul>
<blockquote>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
</blockquote>
<pre><code># -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 返回构造的TreeNode根节点
    # 需要理解在前序遍历中是先遍历左子树的，并且中序和前序中左子树的个数是不会变的
    def reConstructBinaryTree(self, pre, tin):
        # write code here
        if len(pre) ==0:
            return None
        root =TreeNode(pre[0])
        # 这个index 函数是需要记住的
        index =tin.index(pre[0])
        # 这里也是需要修改的
        # pre 和 tin都是需要空出一个 root.value 的位置，只不过选择空的位置是不一样的
        root.left = self.reConstructBinaryTree(pre[1:index+1], tin[:index])
        root.right =self.reConstructBinaryTree(pre[index+1:], tin[index+1:])

        return root
</code></pre><ul>
<li>用两个栈实现队列</li>
</ul>
<blockquote>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
</blockquote>
<pre><code>class Solution:
# 首先是需要两个函数公共可以访问的stack，也就是list
# 函数中如何去操作 公共变量

def __init__(self):
    self.stack1 =[]
    self.stack2 =[]

def push(self, node):
    self.stack1 += [node]

# 就是这个pop 是必须的操作，所以你需要提前解决这个异常
def pop(self):
    if self.stack2 ==[] and self.stack1 ==[]:
        return None
    if self.stack1 != [] and self.stack2 ==[]:
        while self.stack1:
            self.stack2 += [self.stack1.pop()]
    return self.stack2.pop()
</code></pre><ul>
<li>链表中倒数第k个结点</li>
</ul>
<blockquote>
<p>输入一个链表，输出该链表中倒数第k个结点。</p>
</blockquote>
<pre><code># -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
&quot;&quot;&quot;
尝试使用两个指针版本
p1 p2 并且这种 length 在命名上是需要规范的, 并且这种指针操作，最好是拷贝出来进行操作
不管怎么说，还是应该求解出来 length of listNode，这种才是正途
可以使用两个指针，
&quot;&quot;&quot;
class Solution:
    def FindKthToTail(self, head, k):
        # write code here
        if head ==None or k&lt;=0:
            return None
        p1 =head
        p2 =head
        len1 =0
        while p1:
            len1 +=1
            p1 =p1.next
        if k&gt; len1:
            return None
        p1 =head
        while k:
            p1 =p1.next
            k -=1
        while p1:
            p1 =p1.next
            p2 =p2.next
        return p2
</code></pre><ul>
<li>反转链表</li>
</ul>
<blockquote>
<p>输入一个链表，反转链表后，输出新链表的表头。</p>
</blockquote>
<pre><code># -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
&quot;&quot;&quot;
修改链表是需要三个指针的 pre, cur, next_node 
如果对三个指针名进行命名好了，那么这个就是成功的一般了， 这个不容易想到的是
设置pre =None ，这个是一个细节经验性的问题
&quot;&quot;&quot;
class Solution:
    # 返回ListNode
    def ReverseList(self, pHead):
        # write code here
        if pHead ==None:
            return None

        pre =None
        cur =pHead

        while cur:
            next_node =cur.next
            cur.next =pre

            pre, cur =cur, next_node
        return pre
</code></pre><ul>
<li>合并两个排序的链表</li>
</ul>
<blockquote>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
</blockquote>
<pre><code>#     def __init__(self, x):
#         self.val = x
#         self.next = None

&quot;&quot;&quot;
就是在使用两个或者多个 index (p1 or p2) 遍历的时候，一个常见的错误就是忘记了不断更新index
&quot;&quot;&quot;
class Solution:
    # 返回合并后列表
    def Merge(self, pHead1, pHead2):
        # write code here
        if pHead1 ==None:
            return pHead2
        if pHead2 ==None:
            return pHead1
        head =ListNode(-1)
        head1 =head
        p1 =pHead1
        p2 =pHead2
        while p1 and p2:
            if p1.val &lt; p2.val:
                head.next =p1
                p1 =p1.next
            else:
                head.next =p2
                p2 =p2.next
            head =head.next
        if p1 ==None:
            head.next =p2
        if p2 ==None:
            head.next =p1
        return head1.next
</code></pre><ul>
<li>树的子结构</li>
</ul>
<blockquote>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
</blockquote>
<pre><code># -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
&quot;&quot;&quot;
分成两部：首先寻找两个根节点的值是否相同；然后判断子树是否完全相同
subTree 这个函数就是判断子树是否完全相同的，所以函数的功能一定要搞好
&quot;&quot;&quot;
class Solution:
    def HasSubtree(self, pRoot1, pRoot2):

        if not pRoot1:
            return False
        if not pRoot2:
            return False
        result =False

        if pRoot1.val ==pRoot2.val:
            result =self.subTree(pRoot1, pRoot2)
        if result ==False:
            result = self.HasSubtree(pRoot1.left, pRoot2) or self.HasSubtree(pRoot1.right, pRoot2)
        return result

    def subTree(self, root1, root2):
        if not root2:
            return True
        if not root1:
            return False
        if root1.val ==root2.val:
            return self.subTree(root1.left, root2.left) and self.subTree(root1.right, root2.right)
        return False
</code></pre><ul>
<li>二叉树的镜像</li>
</ul>
<blockquote>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
</blockquote>
<pre><code># -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
&quot;&quot;&quot;
就是在某个左（右）子树是None 的情况下，这个也是可以进行交换的，结束的标志应该是根节点是否为空
&quot;&quot;&quot;
class Solution:
    # 返回镜像树的根节点
    def Mirror(self, root):
        # write code here
        if not root:
            return None
        root.left , root.right =root.right, root.left
        if root.left:
            self.Mirror(root.left)
        if root.right:
            self.Mirror(root.right)
        return root
</code></pre><ul>
<li>包含min函数的栈</li>
</ul>
<blockquote>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
</blockquote>
<pre><code># -*- coding:utf-8 -*-
&quot;&quot;&quot;
这个栈中最小的元素是变化的，好好理解一下，如果弹出了一个比较大的元素，那么栈中最小的元素是不变的
所含元素的最小元素
top() and min() 操作是不需要删除元素的， pop 是删除了元素

&quot;&quot;&quot;
class Solution:
    def __init__(self):
        self.all_list =[]
        self.min_list =[]

    def push(self, node):
        # write code here
        if not self.min_list:
            self.min_list.append(node)
        else:
            self.min_list.append(min(node, self.min()))
        self.all_list.append(node)
    def pop(self):
        self.all_list.pop()
        self.min_list.pop()

        # write code here
    def top(self):
        return self.all_list[-1]
        # write code here
    def min(self):
        return self.min_list[-1]
</code></pre><ul>
<li>栈的压入、弹出序列</li>
</ul>
<blockquote>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
</blockquote>
<pre><code>class Solution:
# 使用一个list 模拟压站和出战的过程
def IsPopOrder(self, pushV, popV):
    if not pushV:
        return False
    tmp =[]
    while popV:
        if tmp and popV[0] ==tmp[-1]:
            popV.pop(0)
            tmp.pop()
        elif pushV:
            tmp.append(pushV.pop(0))
        else:
            return False
    return True
</code></pre><ul>
<li>从上往下打印二叉树</li>
</ul>
<blockquote>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
</blockquote>
<pre><code># class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 返回从上到下每个节点值列表，例：[1,2,3]
    # 层序遍历二叉树， 这个跟数据结构 队列有类似的
    # nodes 装上结点，然后vlaues 装上数值
    def PrintFromTopToBottom(self, root):
        # write code here
        if not root:
            return []
        nodes =[]
        values =[]
        nodes.append(root)
        while nodes:
            node =nodes.pop(0)
            values.append(node.val)
            if node.left:
                nodes.append(node.left)
            if node.right:
                nodes.append(node.right)
        return values
</code></pre><ul>
<li>二叉搜索树的后序遍历序列</li>
</ul>
<blockquote>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
</blockquote>
<pre><code>class Solution:
# 后序遍历结果， 最后一个是根节点，这个是递归的思想
# 二叉搜索树， 左子树小于根节点，右子树大于根节点
def VerifySquenceOfBST(self, sequence):
    # write code here
    if not sequence:
        return False
    root =sequence[-1]
    for i in range(len(sequence)):
        if sequence[i] &gt; root:
            break
    for j in range(i,len(sequence)):
        if sequence[j] &lt; root:
            return False
    return True
</code></pre><ul>
<li>二叉树中和为某一值的路径</li>
</ul>
<blockquote>
<p>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p>
</blockquote>
<pre><code># class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 返回二维列表，内部每个列表表示找到的路径
    # 深度优先 dfs() 这样的一个算法
    def FindPath(self, root, expectNumber):
        # write code here
        if not root:
            return []
        self.target =expectNumber

    paths =[]
    self.dfs(root, [root.val], paths)
    return paths

def dfs(self, root, path, paths):

    if not root.left and not root.right and sum(path) ==self.target:
        paths.append(path)

    if root.left:
        self.dfs(root.left, path+[root.left.val], paths)
    if root.right:
        self.dfs(root.right, path+[root.right.val], paths)
</code></pre><ul>
<li>复杂链表的复制</li>
</ul>
<blockquote>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
</blockquote>
<pre><code># -*- coding:utf-8 -*-
# class RandomListNode:
#     def __init__(self, x):
#         self.label = x
#         self.next = None
#         self.random = None
class Solution:
    # 返回 RandomListNode
    # 首先是结点的复制和 next 指针的连接， 然后是random 指针的连接，最后是选择出复制的结点
def Clone(self, pHead):
    # write code here
    if not pHead:
        return None
    self.clone_nodes(pHead)
    self.connect_nodes(pHead)
    return self.select_nodes(pHead)
def clone_nodes(self, head):
    if not head:
        return None
    while head:
        cloned = RandomListNode(head.label)
        cloned.next = head.next
        head.next = cloned
        head = cloned.next
def connect_nodes(self, head):
    if not head:
        return None

    while head:
        cloned = head.next

        if head.random:
            cloned.random = head.random.next
        head = cloned.next
def select_nodes(self, head):
    if not head:
        return None
    cloned =cloned_head =None
    # 这个if 的作用是为了保存一个 cloned_head的结点，
    # 一定要从这个功能出发
    if head:
        cloned =cloned_head =head.next
        head.next =cloned.next
        head =head.next
    while head:
        cloned.next =head.next
        cloned =cloned.next
        head.next =cloned.next
        head =head.next
    return cloned_head
</code></pre><ul>
<li>二叉搜索树与双向链表</li>
</ul>
<blockquote>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
</blockquote>
<pre><code># -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 使用的树的结构 表示一种双向链表
    # 二叉搜索树 ，左子树小于根节点，右子树大于根节点
    # 中序遍历得到就是一种排好序的结构
    # 只能调整树中结点指针的指向
    def Convert(self, pRootOfTree):
        # write code here
        if not pRootOfTree:
            return None
        tree = pRootOfTree
        res = []
        self.helper(tree, res)

    for i in range(len(res) - 1):
        res[i].right = res[i + 1]
        res[i + 1].left = res[i]
    # 这个返回值也是比较鬼畜呀， 就是需要这样返回
    return res[0]

def helper(self, root, res):
    if not root:
        return None
    if root.left:
        self.helper(root.left, res)
    res.append(root)
    if root.right:
        self.helper(root.right, res)
</code></pre><ul>
<li>两个链表的第一个公共结点</li>
</ul>
<blockquote>
<p>输入两个链表，找出它们的第一个公共结点。</p>
</blockquote>
<pre><code># -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    # 两个指针指向的是 一个结点，一个内存的两个指向
    # 将可能不同长度的两个链表转换成相同长度的两个链表的比较，使用
    def FindFirstCommonNode(self, pHead1, pHead2):
        # write code here
        if not pHead1 or not pHead2:
            return None
        p1 =pHead1
        p2 =pHead2
        while p1 !=p2:
            # 这个p1 只能指向了最后一个结点，但最后一个节点不一定相同
            p1 = pHead2 if not p1 else p1.next
            p2 = pHead1 if not p2 else p2.next
        return p1
</code></pre><ul>
<li>二叉树的深度</li>
</ul>
<blockquote>
<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
</blockquote>
<pre><code># -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    &quot;&quot;&quot;
    分别求解 左右子树的深度，然后max(left, right) 这样的操作
    &quot;&quot;&quot;
    def TreeDepth(self, pRoot):
        if not pRoot:
            return 0
        left =self.TreeDepth(pRoot.left) +1
        right =self.TreeDepth(pRoot.right) +1
        # 这个return 是最后执行一次的，然后上面那个都是不断的在进行递归加深
        # 这个 left right 已经完成了，最后的效果只是 返回 max(left, right) 这样子
        return max(left, right) 
</code></pre><ul>
<li>平衡二叉树</li>
</ul>
<blockquote>
<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
</blockquote>
<pre><code># -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 递归常见的都会有两个return 跳出条件，一个是异常的条件，一个是正确的返回
    def get_depth(self, root):
        if not root:
            return 0
        left =self.get_depth(root.left)
        right =self.get_depth(root.right)

    return max(left, right) +1

def IsBalanced_Solution(self, pRoot):

    if not pRoot:
        return True

    left =self.get_depth(pRoot.left)
    right =self.get_depth(pRoot.right)

    if abs(left-right) &gt;1:
        return False
    return self.IsBalanced_Solution(pRoot.left) and self.IsBalanced_Solution(pRoot.right)
</code></pre><ul>
<li>链表中环的入口结点</li>
</ul>
<blockquote>
<p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
</blockquote>
<pre><code># -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    # 现在长个记性吧，在使用next 这样的时候 要先判断这个是不是存在的
    def EntryNodeOfLoop(self, pHead):
        # write code here
        if not pHead or not pHead.next or not pHead.next.next:
            return None
        twoTimes =pHead.next.next
        oneTime =pHead.next
        while twoTimes != oneTime:
            twoTimes =twoTimes.next.next
            oneTime =oneTime.next
        twoTimes =pHead
        while twoTimes != oneTime:
            twoTimes =twoTimes.next
            oneTime =oneTime.next
        return twoTimes
</code></pre><ul>
<li>删除链表中重复的结点</li>
</ul>
<blockquote>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
</blockquote>
<pre><code># -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    def deleteDuplication(self, pHead):
        # write code here
        head =ListNode(-1)
        head.next =pHead
        curr =pHead
        last =head
        while curr and curr.next:
            #val =curr.val
            # 这个条件比较简单，所以可以放到前面
            if curr.val !=curr.next.val:
                curr =curr.next
                last =last.next
            else:
                # 这个条件 curr 还是需要注意一下的
                val =curr.val
                # python 中 condition1 and condition2 这种是有先后顺序的
                # 可能是存在短路现象的， 如果 curr 不成立，那么后面的是不会执行的 
                # 草拟
                while curr and val ==curr.val:
                    curr =curr.next
                last.next =curr
        return head.next
</code></pre><ul>
<li>二叉树的下一个结点</li>
</ul>
<blockquote>
<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
</blockquote>
<pre><code># -*- coding:utf-8 -*-
# class TreeLinkNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#         self.next = None
class Solution:
    # https://blog.csdn.net/fuxuemingzhu/article/details/79723819 
    # 这个是求解中序遍历中某个结点的下一个结点
    # 这pNode 就是一个普通的结点
    def GetNext(self, pNode):
        # write code here
        if not pNode:
            return None
        # 如果存在右结点
        if pNode.right:
            pNode =pNode.right
            while pNode.left:
                pNode =pNode.left
            return pNode
        # 如果是父节点的左子树
        else:
            # 这里使用 pNode.next 表示父节点
            while pNode.next:
                if pNode  == pNode.next.left:
                    return pNode.next
                # 这个是右结点
                pNode =pNode.next
        return None
</code></pre><ul>
<li>对称的二叉树</li>
</ul>
<blockquote>
<p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
</blockquote>
<pre><code># -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 镜像的概念 和递归
    # isSame() 这个就是判断两个子树是否镜像的操作

def isSame(self, p, q):
    if not p and not q:
        return True
    # 好好思考 下面这两个跳出条件为什么是不合适的
    #if not p and q:
    #   return False
    #if p and not q:
    #   return False
    if p and q and p.val == q.val:
        return self.isSame(p.left, q.right) and self.isSame(p.right, q.left)

def isSymmetrical(self, pRoot):
    # write code here
    # 最开始的条件 如果都是 none 那么这个是对称的
    if not pRoot:
        return True
    if pRoot.left and not pRoot.right:
        return False
    if not pRoot.left and pRoot.right:
        return False
    return self.isSame(pRoot.left, pRoot.right)
</code></pre><ul>
<li>按之字形顺序打印二叉树</li>
</ul>
<blockquote>
<p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
</blockquote>
<pre><code># -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 层序遍历 + 偶数翻转
    # https://blog.csdn.net/fuxuemingzhu/article/details/79724959
    def level(self, root, level, res):
        &quot;&quot;&quot;
        root: the root of tree
        level: 
        res: result
    &quot;&quot;&quot;
    if not root:
        return

    if len(res) ==level:
        res.append([])
    res[level].append(root.val)

    if root.left:
        self.level(root.left, level+1, res)
    if root.right:
        self.level(root.right, level+1, res)
def Print(self, pRoot):
    # write code here
    if not pRoot:
        return []
    res =[]
    self.level(pRoot, 0, res)
    for level in range(1, len(res), 2):
        res[level] =res[level][::-1]
    return res
</code></pre><ul>
<li>把二叉树打印成多行</li>
</ul>
<blockquote>
<p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
</blockquote>
<pre><code># -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 返回二维列表[[1,2],[4,5]]
    def level(self, root, level, res):
        # 你这里也没有说要返回值的意思呀，这个直接是 return
        if not root:
            return 
        if level ==len(res):
            res.append([])

    res[level].append(root.val)

    if root.left:
        self.level(root.left, level +1, res)
    if root.right:
        #res[level] =self.level(root.right, level+1, res)
        # 因为这个是 传的值，所以不需要使用返回值的
        self.level(root.right, level+1, res)

def Print(self, pRoot):
    if not pRoot:
        return []
    res =[]
    self.level(pRoot, 0, res)
    return res
</code></pre><ul>
<li>序列化二叉树</li>
</ul>
<blockquote>
<p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
</blockquote>
<pre><code># -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    &quot;&quot;&quot;
    序列化就是从树结构 转成字符串的结构；反之，也是成立的。 使用先序遍历的方法。
    https://suixinblog.cn/2019/03/target-offer-serialize-binary-tree.html#%E4%BB%A3%E7%A0%81
    &quot;&quot;&quot;
    def  __init__(self):
        self.flag =-1

def Serialize(self, root):
    # write code here
    if not root:
        return &quot;#&quot;
    return str(root.val) +&quot;,&quot;+self.Serialize(root.left) +&quot;,&quot;+self.Serialize(root.right)

def Deserialize(self, s):
    # write code here
    self.flag +=1
    string =s.split(&apos;,&apos;)
    if self.flag &gt; len(string):
        return None

    root =None
    if string[self.flag] !=&apos;#&apos;:
        root =TreeNode(int(string[self.flag]))
        root.left =self.Deserialize(s)
        root.right =self.Deserialize(s)
    return root
</code></pre><ul>
<li>二叉搜索树的第k个结点</li>
</ul>
<blockquote>
<p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p>
</blockquote>
<pre><code># class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 返回对应节点TreeNode
    # 二叉搜索树： 左子树小于根节点 右子树大于根节点，前序遍历就是一个排序的
    # 我的思路，前序遍历，存为list 然后就自然的返回就行
    # 这个应该是中序遍历的方式最后是有序的，而非前序遍历
    # 这个保存的结点，输出的也是结点，然后题目是为了便于理解，然后给出的是结点的值
def pre(self, root, result):
    if not root:
        return 
    if root.left:
        self.pre(root.left, result)
    result.append(root)
    if root.right:
        self.pre(root.right, result)
def KthNode(self, pRoot, k):
    # write code here
    if not pRoot:
        return 
    result =[]
    self.pre(pRoot, result)
    if len(result) &lt; k or k&lt;1:
        return
    return result[k-1]
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/17/剑指Offer-字符串和数组/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jijeng Jia">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jijeng's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/17/剑指Offer-字符串和数组/" itemprop="url">剑指Offer-字符串和数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-17T20:31:43+08:00">
                2019-05-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>题目都是来自牛客网在线刷题中的剑指offer。最近找实习工作，作为刷题记录，顺便从考察知识点的角度分类整理。主要分成以下四大类：</p>
<ul>
<li>字符串、数组</li>
<li>链表、树</li>
<li>递归、回溯、动态规划</li>
<li>其他, 比如位运算、正则匹配等 </li>
</ul>
<p>不同类别以一章介绍，之后可能会随时update。这是剑指offer 系列四部曲中的第一部：。第一部关于字符串和数组，第二部是栈、队列、链表和树，第三部递归、回溯和动态规划， 最后一部分在这里。</p>
<ul>
<li>二维数组中的查找</li>
</ul>
<blockquote>
<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</blockquote>
<pre><code>class Solution:
# array 二维列表
def Find(self, target, array):
    # write code here
    # 可以尝试一下 坐标移动的思想, 所以这个就是一种坐标移动的思想
    # 就是一个条件有了之后 那么接下来的else 也可以顺着就写上来的
    rows =len(array) -1
    cols =len(array[0]) -1
    row =0
    col =cols
    while row &lt;= rows and col &gt;=0:

        if array[row][col] == target:
            return True
        elif array[row][col] &gt; target:
            col -=1
        else:
            row +=1
    return False
</code></pre><ul>
<li>替换空格</li>
</ul>
<blockquote>
<p>请实现一个函数，将一个字符串中的每个空格替换成“\%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We\%20Are\%20Happy。</p>
</blockquote>
<pre><code>class Solution:
# s 源字符串
def replaceSpace(self, s):
    # write code here
    # python 中的 str 就是 array of char
    converted =&quot;&quot;
    for ch in s:
        if ch ==&quot; &quot;:
            converted += &quot;%20&quot;
        else:
            converted += ch
    return converted
</code></pre><ul>
<li>旋转数组的最小数字</li>
</ul>
<blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
</blockquote>
<pre><code>class Solution:
&apos;&apos;&apos;
解题的关键点： 设置第一个元素为假定的min_value,然后注意这个是非减的数组（注意处理等号的情况）
&apos;&apos;&apos;
def minNumberInRotateArray(self, rotateArray):
    # write code here
    # 因为这个条件是非减，所以可能有重复的元素
    min_value =rotateArray[0]

    left =0
    right =len(rotateArray) -1
    while right -left &gt;1:
        mid =int((left+right)/2)
        # if else 这种条件是具有唯一性的，所以颠倒顺序是没有问题的
        if rotateArray[mid] &lt;= rotateArray[right]:
            right =mid
        elif rotateArray[left] &lt;= rotateArray[mid]:
            left =mid

        else:
            if rotateArray[left] ==rotateArray[mid] and rotateArray[left] ==rotateArray[right]:
                for i in range(len(rotateArrray)):
                    if rotateArray[i] &lt; min_value:
                        min_value =rotateArray[i]
                        right =i
    # 现在有点感觉 为什么使用 min_value =array[right]，因为预设最小值是在左边
    min_value  =rotateArray[right]
    return min_value
</code></pre><ul>
<li>调整数组顺序使奇数位于偶数前面</li>
</ul>
<blockquote>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
</blockquote>
<pre><code>&quot;&quot;&quot;
list 和list 之间的连接，使用 list1+ list2 就是可以的
&quot;&quot;&quot;
class Solution:
    def reOrderArray(self, array):
        # write code here
        if array ==[]:
            return []
        odd_list =[]
        even_list =[]
        for item in array:
            if item% 2 ==1:
                odd_list.append(item)
            else:
                even_list.append(item)

        return odd_list+even_list
</code></pre><ul>
<li>顺时针打印矩阵</li>
</ul>
<blockquote>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
</blockquote>
<pre><code>class Solution:
&quot;&quot;&quot;
最后的 必须是三种特殊情况，如果修改成两种，那么”只剩下一个“ 这种特殊情况就被计算了两次
&quot;&quot;&quot;
# matrix类型为二维列表，需要返回列表
def printMatrix(self, matrix):
    rows = len(matrix)
    cols = len(matrix[0])
    top = 0
    left = 0
    down = rows - 1
    right = cols - 1
    result = []
    while top &lt; down and left &lt; right:
        for j in range(left, right + 1):
            result.append(matrix[top][j])
        top += 1

        for i in range(top, down + 1):
            result.append(matrix[i][right])
        right -= 1

        for j in range(right, left - 1, -1):
            result.append(matrix[down][j])
        down -= 1

        for i in range(down, top - 1, -1):
            result.append(matrix[i][left])
        left += 1

    if top == down and left &lt; right:
        for j in range(left, right + 1):
            result.append(matrix[top][j])

    if top &lt; down and left == right:
        for i in range(top, down + 1):
            result.append(matrix[i][left])

    if top ==down and left ==right:
        result.append(matrix[top][left])

    return result
</code></pre><ul>
<li><p>字符串的排列</p>
<blockquote>
<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
</blockquote>
<pre><code>class Solution:
# 递归： 变换方程： 第一字母和 剩下的所有的字母
def Permutation(self, ss):
    # write code here
    if not ss:
        return []
    res =[]
    self.helper(ss, &apos;&apos;, res)
    return sorted(list(set(res)))

def helper(self, ss, path, res):
    if not ss:
        res.append(path)

    for i in range(len(ss)):
        self.helper(ss[:i]+ss[i+1:], path+ss[i], res)
</code></pre></li>
</ul>
<ul>
<li>数组中出现次数超过一半的数字</li>
</ul>
<blockquote>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
</blockquote>
<pre><code>class Solution:
# 如果存在这样的数字，那么这个数字的频数一定是大于其他所有的频数
# 所以可以统计一下这个
def MoreThanHalfNum_Solution(self, numbers):
    # write code here
    if not numbers:
        return 0
    target =numbers[0]
    nums =0
    # 统计出现次数最多的数字
    for i in numbers:
        if target ==i:
            nums +=1
        elif nums ==0:
            target =i
            nums =1
        else:
            nums -=1
    res = target if numbers.count(target) &gt; len(numbers)//2 else 0
    return res
</code></pre><ul>
<li><p>连续子数组的最大和</p>
<blockquote>
<p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p>
</blockquote>
<pre><code>class Solution:
# largest , sum 这是两个不同的状态
# 注意初始化
def FindGreatestSumOfSubArray(self, array):
    # write code here
    if not array:
        return []
    largest =array[0]
    sum_of_array =0
    for i in array:
        sum_of_array += i
        if sum_of_array &gt; largest:
            largest =sum_of_array
        elif sum_of_array &lt;0:
            sum_of_array =0
    return largest
</code></pre></li>
<li><p>第一个只出现一次的字符</p>
<blockquote>
<p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p>
</blockquote>
<pre><code>class Solution:
def FirstNotRepeatingChar(self, s):
    if not s:
        return -1
    dict1 =self.Counter(s)
    for index, value in enumerate(s):
        if dict1[value] ==1:
            return index
    return -1
# 自己实现的Counter 是按照key 的字母顺序进行排列的，而from collections import Counter 什么排列都不是
def Counter(self, s):
    dict1 ={}
    for val in s:
        if val not in dict1:
            dict1[val] =1
        else:
            dict1[val] = dict1[val] +1
    return dict1
</code></pre></li>
</ul>
<ul>
<li>数组中的逆序对</li>
</ul>
<blockquote>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P\%1000000007</p>
</blockquote>
<pre><code># -*- coding:utf-8 -*-
class Solution:
    # 这个一斤难出天机了 先不看了
    # 这个到后来就已经背下来了
    def InversePairs(self, data):
        # write code here
        if not data:
            return 0
        temp = [i for i in data]
        return self.mergeSort(temp, data, 0, len(data)-1) % 1000000007

def mergeSort(self, temp, data, low, high):
    if low &gt;= high:
        temp[low] = data[low]
        return 0
    mid = (low + high) / 2
    #不懂 data 和 temp 为什么是颠倒顺序
    left = self.mergeSort(data, temp, low, mid)
    right = self.mergeSort(data, temp, mid+1, high)
    count = 0
    i = low
    j = mid+1
    index = low
    while i &lt;= mid and j &lt;= high:
        if data[i] &lt;= data[j]:
            temp[index] = data[i]
            i += 1
        else:
            temp[index] = data[j]
            count += mid-i+1
            j += 1
        index += 1
    while i &lt;= mid:
        temp[index] = data[i]
        i += 1
        index += 1
    while j &lt;= high:
        temp[index] = data[j]
        j += 1
        index += 1
    return count + left + right
</code></pre><ul>
<li>数字在排序数组中出现的次数</li>
</ul>
<blockquote>
<p>统计一个数字在排序数组中出现的次数。</p>
</blockquote>
<pre><code>class Solution:
# 二叉查找， 递归
def GetNumberOfK(self, data, k):
    # write code here
    # 这个是有两个跳出条件的，一个是正确的跳出，一个是不正确的跳出
    if not data:
        return 0
    mid =len(data)//2
    if data[mid] ==k:
        left =right =mid
        for i in range(mid-1, -1, -1):
            if data[i] ==k:
                left -=1
        for i in range(mid+1, len(data)):
            if data[i] ==k:
                right +=1
        return right -left +1
    # 一半一半的舍去数据
    elif data[mid] &lt;k:
        return self.GetNumberOfK(data[mid+1:], k)
    else:
        return self.GetNumberOfK(data[:mid-1], k)
</code></pre><ul>
<li>数组中只出现一次的数字</li>
</ul>
<blockquote>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
</blockquote>
<pre><code>class Solution:
# 返回[a,b] 其中ab是出现一次的两个数字
# 使用异或的性质，如果只有一个不同，其他的偶次出现，那么全部异或的结果
# 就是那个单一的数字
def FindNumsAppearOnce(self, array):
    # write code here
    remain, index =0, 1
    for num in array:
        remain = remain ^ num
    # 找出第一个是1 的位置
    # index 都是
    while (remain &amp; index) ==0:
        index = index  &lt;&lt;1
    res1, res2 =0,0
    for num in array:
        # 这个条件必须是0, 表示两个在这个位数是相同的，
        if num &amp; index ==0:
            res1 =res1 ^ num
        else:
            res2 =res2 ^ num
    return [res1, res2]
</code></pre><ul>
<li>和为S的连续正数序列</li>
</ul>
<blockquote>
<p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列?<br>Good Luck!</p>
</blockquote>
<pre><code>class Solution:
#滑动窗口的思想
def FindContinuousSequence(self, tsum):
    # write code here
    if tsum&lt;2:
        return []
    left =1
    right =left +1
    res =[]
    while left &lt; tsum//2+1:
        if sum(range(left,right)) ==tsum:
            res.append(range(left, right))
            left +=1
        elif sum(range(left,right)) &lt; tsum:
            right +=1
        else:
            left +=1
    return res
</code></pre><ul>
<li>和为S的两个数字</li>
</ul>
<blockquote>
<p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
</blockquote>
<pre><code>class Solution:
# 上一个题目是 一个区间，这个题目是连个数字
# 限制条件，乘积最小，意味着连个相距最远， 所以在初始化的时候， 选择 0, len()-1 
# 这种初始化
def FindNumbersWithSum(self, array, tsum):
    # write code here
    if len(array) &lt;2:
        return []
    left =0
    right =len(array)-1

    while left &lt; right:
        if array[left] +array[right] ==tsum:
            return [array[left], array[right]]
        elif array[left] +array[right] &lt; tsum:
            left +=1
        else:
            right -=1
    return []
</code></pre><ul>
<li>左旋转字符串</li>
</ul>
<blockquote>
<p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
</blockquote>
<pre><code>class Solution:
def LeftRotateString(self, s, n):
    # write code here
    if len(s) &lt; n:
        return &apos;&apos;
    return s[n:]+s[:n]
</code></pre><ul>
<li>翻转单词顺序列</li>
</ul>
<blockquote>
<p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
</blockquote>
<pre><code>class Solution:
&quot;&quot;&quot;
写一个 reverse() 函数, 用于 list 的reverse
&quot;&quot;&quot;
def Reverse(self, s, left, right):
    while left&lt;right:
        s[left], s[right] = s[right], s[left]
        left +=1
        right -=1

def ReverseSentence(self, s):
    # write code here
    if not s:
        return s
    # from immutable string to mutable list
    s =list(s)
    self.Reverse(s, 0, len(s)-1)
    # 然后实现的是 每个单词的反转，使用 start, end 表示某个单词的首末
    # 感觉python 中的这种赋值方式是特有的，应该是整体操作的机制，先是把右边的全部保存起来
    # 然后依次赋值给左边
    # 这种思想都是 一个变量，然后inplace 的操作, 所以对于空格的操作是 let it go
    # 这个是第二次翻转，属于每个单词进行翻转
    start, end =0,0
    # 这个小于号 是python 中特有的坑，真正能够访问的区间是 [0, len(s)-1] 这样的区间
    while start &lt;len(s):
        if s[start] ==&quot; &quot;:
            start +=1
            end +=1
        elif end ==len(s) or s[end] ==&quot; &quot;:
            self.Reverse(s, start, end-1)
            # update 操作
            end +=1
            start =end
        else:
            end +=1
    return &quot;&quot;.join(s)
</code></pre><ul>
<li>扑克牌顺子</li>
</ul>
<blockquote>
<p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p>
</blockquote>
<pre><code>class Solution:
# 我的理解这个实际上是一个填空游戏，如果大小王的总数大于等于空的个数， 那么就返回true，否则就是false
# 有时候不会，是因为不知道这个输入样例 长什么样子，缺省的特殊符号是如何？ 所以导致不会
# 而并不是算法不会
&quot;&quot;&quot;
空缺是1 意味着这两个数字是连续的 比如说 1 2， 这个big -small ==1, 所以这个空缺是0，不用进行填充。
&quot;&quot;&quot;
def IsContinuous(self, numbers):
    # write code here
    if not numbers:
        return  False
    numbers.sort()
    # sort() sorted() 这种怎么使用，返回值是什么，这些基本的东西
    zeros =numbers.count(0)
    gaps =0
    left =zeros
    # 因为这个是排序之后的结果，所以可以这样进行操作
    right=left +1
    # 实际上还是两个指针， 所以可以使用两个指针进行操作
    # 本质上是两个 相邻指针在进行移动，因为是排序之后，所以没有问题
    while right &lt;len(numbers):
        if numbers[left] ==numbers[right]:
            return False
        gaps += numbers[right] -numbers[left] -1
        left =right
        right +=1
    # 这种是真的 很简洁， gaps &lt;= zeros 少去了很多if else的判断
    return gaps &lt;=zeros
</code></pre><ul>
<li>孩子们的游戏(圆圈中最后剩下的数)</li>
</ul>
<blockquote>
<p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
</blockquote>
<pre><code>class Solution:
# mod 求余 的操作， a mod b ==c ,说明 a除以b 之后余数是c
# https://blog.csdn.net/gatieme/article/details/51435055， 从做题思路上讲解的比较好
# n 个小朋友，然后是m 个编号
def LastRemaining_Solution(self, n, m):
    # write code here
    if n&lt; 1 or m&lt;1:
        return -1
    last =0
    for i in range(2, n+1):
        # 这个相当于 是一个 “挑选人” 的逆过程， 因为使用的  mod 操作就是取余的操作
        last =(last +m) %i
    return last
</code></pre><ul>
<li>求1+2+3+…+n</li>
</ul>
<blockquote>
<p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
</blockquote>
<pre><code>class Solution:
# 如果你想使用全局变量，那么放在 __init__ 中就是一个很好的方式
def __init__(self):
    self.ans =0
def Sum_Solution(self, n):
    # write code here
    self.recur(n)
    return self.ans
# n&gt;0 就是一个短路条件，这个直接决定了后面递归会不会继续执行下去，也就是跳出的条件
# 至于会不会回到原来最初的状态，这个是不重要的，最后的结果是 self.ans ，false之后直接使用这个就行了
def recur(self, n):
    self.ans += n
    n -=1
    return n &gt;0 and self.Sum_Solution(n)
</code></pre><ul>
<li>不用加减乘除做加法</li>
</ul>
<blockquote>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
</blockquote>
<pre><code>class Solution:
&quot;&quot;&quot;
不能使用四则运算符，我们就可以使用位运算符。对这两个数在更底层的角度上进行运算。也就是从 01 这种子串的角度进行考虑
至少这个是思路上清晰的
https://blog.csdn.net/derrantcm/article/details/46798763 这个博客对于数的运算过程和 位运算是如何一一对应的。分为不进位相加和进位相加。
&quot;&quot;&quot;
# 这个只能是正整数的操作，真是热力狗
# 这个弄出来是真心不容易哈
def add(self, num1, num2):

    while num2 != 0:
        carry = num1 &amp; num2
        num1 = num1 ^ num2
        # 这个应该理解为到高位 而不是*2 这样的操作
        num2 = carry &lt;&lt; 1
    return num1

def sub(self, num1, num2):
    while num2 != 0:
        carry = (~num1) &amp; num2
        num1 = num1 ^ num2
        num2 = carry &lt;&lt; 1
    return num1

def Add(self, num1, num2):

    if num1 &gt;= 0 and num2 &gt;=0:
        result =self.add(num1, num2)

    elif num1&gt;0 and num2 &lt;0:

        flag = 1 if num1 &gt; abs(num2) else -1
        #num2 =abs(num2)
        # keep num1 bigger than num2
        if num1 &lt; abs(num2):
            num1, num2 =abs(num2), num1

        result =self.sub(num1, abs(num2))
        result = result *flag
    elif num1 &lt; 0 and num2&gt;0:
        flag = 1 if abs(num1) &lt; num2 else -1

        if abs(num1)&lt; num2:
            num1, num2 = num2, abs(num1)
        result =self.sub(abs(num1), num2)

        result =result * flag
    else:
        flag =-1
        num1 =abs(num1)
        num2 =abs(num2)
        result =self.add(num1, num2)
        result =result * flag
    return result
</code></pre><ul>
<li>把字符串转换成整数</li>
</ul>
<blockquote>
<p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p>
</blockquote>
<pre><code>class Solution:
# 有很多不合法的输入，比如空字符串，正负号，非数字字符 数据溢出，所以从反面考虑更加简单一些
# 合法的输入只有数字和符号位 + 和-
def StrToInt(self, s):
    # write code here
    int_list=[&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;,&apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;+&apos;, &apos;-&apos;]
    if s ==&quot; &quot;:
        return 0
    sum1 =0
    flag =1 # 正负号
    for string in s:
        if string not in int_list:
            return 0
        if string ==&quot;+&quot;:
            flag =1
            continue
        elif string ==&quot;-&quot;:
            flag = -1
            continue
        else:
            sum1 =sum1 *10 +int_list.index(string)
    return sum1*flag
</code></pre><ul>
<li>数组中重复的数字</li>
</ul>
<blockquote>
<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
</blockquote>
<pre><code>class Solution:
# 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]
# 函数返回True/False
# 第二种方式，如果这个是有序的 那么 numbers[i] ==i 这个是成立的
def duplicate(self, numbers, duplication):
    # write code here
    length =len(numbers)

    for i in range(length):

        while i != numbers[i]:
            if numbers[numbers[i]] == numbers[i]:
                duplication[0] =numbers[i]
                return True
            else:
                numbers[numbers[i]], numbers[i] =numbers[i], numbers[numbers[i]]
    return False
</code></pre><ul>
<li>构建乘积数组</li>
</ul>
<blockquote>
<p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。</p>
</blockquote>
<pre><code>class Solution:
# 思路： 转换成图形的就容易想一些， https://blog.csdn.net/u010005281/article/details/80200398
# 代码：https://blog.csdn.net/fuxuemingzhu/article/details/79718543
# A 是一个list ，只是自己构建的是一个矩阵
def multiply(self, A):
    # write code here
    ans =[]
    tmp =1
    length =len(A) # 值得是 rows
    # 首先是下三角形 各个部分的数值的相乘， 从上往下遍历
    for i in range(length):
        ans.append(tmp)
        tmp  *= A[i]
    tmp =1
    # 上三角形 从下往上进行遍历
    for i in range(length-1, -1, -1):
        ans[i] *= tmp
        tmp *= A[i]
    return ans
</code></pre><ul>
<li>表示数值的字符串</li>
</ul>
<blockquote>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。<br>但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
</blockquote>
<pre><code>class Solution:
# s字符串
# 第一种方法是 float()强转，一种是 re 正则表达式匹配 最后一种逻辑判断之类的
# 以 e 为分割符，分成front and behind 两部分，behind 长度不能为0 或者出现 . 
# digit的判断，+- 只能出现在首位， . 只能出现一次
&quot;&quot;&quot;
https://github.com/leeguandong/Interview-code-practice-python/blob/master/%E5%89%91%E6%8C%87offer/%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.py
&quot;&quot;&quot;
def isNumeric(self, s):
    if not s or len(s) ==0:
        return s
    s =[i.lower() for i in s]
    if &apos;e&apos; in s:
        index =s.index(&apos;e&apos;)
        front =s[:index]
        behind =s[index+1:]
        if len(behind) ==0 or &apos;.&apos; in behind:
            return False
        f =self.Digit(front)
        b =self.Digit(behind)
        return f and b
    else:
        isNum =self.Digit(s)
        return isNum
def Digit(self, s):
    dotNum =0
    allowNum =[&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;.&apos;, &apos;+&apos;, &apos;-&apos;]
    for i in  range(len(s)):
        if s[i] not in allowNum:
            return False
        if s[i] ==&apos;.&apos;:
            dotNum +=1
        if s[i] in &apos;+-&apos; and i!=0:
            return False
    if dotNum &gt;1:
        return False
    return True
</code></pre><ul>
<li>字符流中第一个不重复的字符</li>
</ul>
<blockquote>
<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p>
</blockquote>
<pre><code>class Solution:
# 返回对应char
# 这个没有了dict 那么依赖于 count 函数
# 主要差别在于有了一个 字符流，是动态的，所以需要有一个大的存储的list
def __init__(self):
    self.list1 =[]
def FirstAppearingOnce(self):
    # write code here
    for string in self.list1:
        if self.list1.count(string) ==1:
            return string
    return &quot;#&quot;
def Insert(self, char):
    # write code here
    self.list1.append(char)
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/24/pygen/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jijeng Jia">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jijeng's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/24/pygen/" itemprop="url">pygen</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-24T10:54:05+08:00">
                2019-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>pygen功能：</strong>有关联的随机生成人名，邮箱，ID Card (ssn)，电话，地址等信息，并且可以选择保存为 pandas dataframe格式, 数据库”.db” 文件, Excel 文件和csv 文件格式，用于机器学习训练。<a href="https://github.com/jijeng/pygen" target="_blank" rel="noopener">项目地址github</a>。</p>
<p>随机生成虚假个人信息具有很大的应用空间。首先，虚假的生成数据可以用于机器学习模型的“准备数据”，当真实的数据比较少或者难以获得的时候，可以使用生成数据进行训练模型，待模型调通之后，然后使用真实的模型。并且，当真实的数据集中缺少某些特征时候，可以使用这种方法进行特征的填充。比如大的数据集中缺少现居城市地址的时候，可以调用该库中的 “city_real” 进行填充。</p>
<p>当前使用最为广泛的是 <a href="https://faker.readthedocs.io/en/master/" target="_blank" rel="noopener">Faker</a> 开源库用于数据的生成。虽然该库支持中文，但是对于中文的支持力度有限，所以有时候并不能满足我的需求，比如说生成的身份证 (ssn) 和姓名所能体现的性别是不匹配(了解更多可以参考<a href="https://github.com/jayknoxqu/id-number-util" target="_blank" rel="noopener">这里</a>)、生成的姓名中缺少复姓和电话邮箱等信息不符合我们的使用习惯等等。所以我将从以下几点改进：</p>
<ul>
<li>增强数据之间相关性</li>
<li>生成名字的多样性</li>
<li>符合国人使用习惯的邮箱电话</li>
<li>提供保存多种保存文件格式，更加适合机器学习的训练</li>
</ul>
<p>中文名字有很强的性别属性。例如名字中带有“杰”“志”“宏”等字的一般为男性，带有“琬”“佩”“梅”等字的一般为女性。当然也有一些比较中性的字，例如“文”“安”“清”等，比较难猜测性别，关于这点会在另一个博客中展开，请期待。<br>在faker 中生成的结果如下图：</p>
<pre><code>from faker import Faker
fake = Faker(&apos;zh_CN&apos;)
for _ in range(10):
    print(fake.name(),fake.ssn(),fake.phone_number())
</code></pre><p><img src="http://ww1.sinaimg.cn/large/e9a223b5ly1g2dgyq294dj20kg09sq39.jpg" alt=""></p>
<p>从图中可以明显的看出 “王玉梅”和 “李桂花”都是两个女性，但是这种身份证信息（ssn）都没有体现这点。关于身份证的科普信息可以从这里获得。简单来说倒数第二位表示性别信息，如果是男性就是奇数如果是女性就是偶数。faker 生成的数据是不具有数据之间的相关性的。</p>
<p>基于此，我们进行了改进。首先是姓名的生成，然后是性别的判断，最后再生成相应性别的身份证号码。</p>
<pre><code>from pygen import pygen
db =pygen()
db.gen_dataframe(fields =[&apos;name&apos;, &apos;ssn&apos;, &apos;phone&apos;, &apos;email&apos;])
</code></pre><p>效果如下：<br><img src="http://ww1.sinaimg.cn/large/e9a223b5ly1g2dhis3u0qj20vm0iq75a.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/e9a223b5ly1g2dhj273lrj20vc0iwjsf.jpg" alt=""></p>
<p>红色线条表示姓名和性别对应一致，蓝色线条表示结果不确定（“镜阳炎” 像是一个中性的名字），绿色表示生成了含有复姓的名字，增强了数据的多样性。</p>
<p>从上图的 “mail” 一列可以看出邮箱前缀的命名基本上是中文名字中“姓” 和“民”的拼音组合，加强了数据之间的相关性和真实度。</p>
<p>另外，电话号码按照运营商分为三类：0 表示移动，1表示联通，2表示电信。</p>
<pre><code>print(&apos;移动字段:&apos;)
for _ in range(5):
  print(db.simple_ph_num(types =0))

print(&apos;联通字段:&apos;)
for _ in range(5):
  print(db.simple_ph_num(types =1))

print(&apos;电信字段：&apos;)
for _ in range(5):
  print(db.simple_ph_num(types =2))
</code></pre><p>输出：</p>
<blockquote>
<p>移动字段: 15023689929 16771753917 16790223946 15950129353 15271129554<br>联通字段: 13869739303 13786227031 13950354445 15137578545 15240836142<br>电信字段： 17172983067 15658567011 18562313243 17073127396 15543448286</p>
</blockquote>
<p>最后提供了多种文件保存格式，包括”.csv”, “.db” 和”.xlsx”等格式。可以使用如下：</p>
<pre><code>from pygen import pygen
db =pygen()
db.gen_table(filename =filename, fields =[&apos;name&apos;, &apos;ssn&apos;, &apos;phone&apos;, &apos;email&apos;])
db.gen_excel(filename =filename, fields =[&apos;name&apos;, &apos;ssn&apos;, &apos;phone&apos;, &apos;email&apos;])
db.gen_csv(filename =filename, fields =[&apos;name&apos;, &apos;ssn&apos;, &apos;phone&apos;, &apos;email&apos;])
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/18/mode-collapse-in-gan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jijeng Jia">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jijeng's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/18/mode-collapse-in-gan/" itemprop="url">Mode Collapse in GANs</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-18T21:42:01+08:00">
                2019-04-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Deep-learning/" itemprop="url" rel="index">
                    <span itemprop="name">Deep learning</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Mode collapse, a failure case for GANs where the generator generate a limited diversity of samples, regardless of the input.</p>
<p>But what causes the mode collapse? There are four reasons for that.</p>
<p><strong>The objective of GANs</strong></p>
<p>The generator, generates new data, while the discriminator evaluates it for authenticity but not for the diversity of generated instances.</p>
<p>the generator can win by producing a polynomial number of training examples. And a low capacity discriminator cannot detect this process, thus, it cannot guide the generator to approximate the target distribution. Even if a high discriminator identifies and assigns the collapse part a low probability, then the generator will simply move from its collapsed output to focus on another fixed output point.</p>
<p><strong>Generator</strong></p>
<p>No matter the objective function is, if it only considers individual samples (without looking forward or backward) then the generator is not directly incentivised to produce diverse examples.</p>
<p>From [1], standard GAN training corresponds exactly to updating the generator parameters using only the first term in this gradient because of a fixed discriminator during GAN training. Therefore, in standard GAN training, each generator updata step is a partial collapse towards a delta function.</p>
<p>$$<br>\frac { \mathrm { d } f _ { K } \left( \theta _ { G } , \theta _ { D } \right) } { \mathrm { d } \theta _ { G } } = \frac { \partial f \left( \theta _ { G } , \theta _ { D } ^ { K } \left( \theta _ { G } , \theta _ { D } \right) \right) } { \partial \theta _ { G } } + \frac { \partial f \left( \theta _ { G } , \theta _ { D } ^ { K } \left( \theta _ { G } , \theta _ { D } \right) \right) } { \partial \theta _ { D } ^ { K } \left( \theta _ { G } , \theta _ { D } \right) } \frac { \mathrm { d } \theta _ { D } ^ { K } \left( \theta _ { G } , \theta _ { D } \right) } { \mathrm { d } \theta _ { G } }<br>$$</p>
<p>Some methods have been proposed. Multiple generators and weight-sharing generators are developed to capture more modes of the distribution. </p>
<p><strong>Discriminator</strong></p>
<p>The mode collapse is often explained as gradient exploding of discriminator, which comes from the imbalance between the discriminator and the generator. For example, the technique of TTUR could help discriminator to keep its optimality. But some researchers believe that this is a desirable goal since a good discriminator can give good feedback and ignore the fact.</p>
<p>In addition, the discriminator process each example independently, the generator depends on generator, thus  no mechanism to tell the outputs of the generator to become more similar to each other. </p>
<p>The idea from [2], that we could use minibatch discrimination to help generator give better feedback</p>
<p>A straightforward approach to handle multimodality is to take random noise vectors along with the conditional contexts as inputs, where the contexts determine the main content and noise vectors are responsible for variations.<br>The noise vectors are ignored or of minor impacts, since cGANs pay more attention to learn from the highdimensional and structured conditional contexts. </p>
<p><strong>Another question</strong></p>
<p>Mode collapse may happen only partially?<br>since training is stochastic progress, the input of generator network will vary and the sample drawn from the real distribution will also vary</p>
<p>But sometimes mode collapse is not all bad news. In style transfer using GAN, we are happy to convert one image to just a good one, rather than finding all variants. Indeed, the specialization in the partial mode collapse sometimes creates higher quality images.</p>
<h2 id="referrences"><a href="#referrences" class="headerlink" title="referrences:"></a>referrences:</h2><p>[1]. Section 2.4 of <a href="https://arxiv.org/abs/1611.02163" target="_blank" rel="noopener">Unrolled Generative Adversarial Networks</a><br>[2]. Section 3.2 of <a href="https://arxiv.org/abs/1606.03498" target="_blank" rel="noopener">Improved Techniques for Training GANs</a><br>[3]. <a href="https://arxiv.org/abs/1903.05628" target="_blank" rel="noopener">Mode Seeking Generative Adversarial Networks for Diverse Image Synthesis</a><br>[4]. <a href="https://arxiv.org/abs/1902.03984" target="_blank" rel="noopener">Improving Generalization and Stability of Generative Adversarial Networks</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/17/a-not-so-gentle-introduction-to-hyperparameters-tuning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jijeng Jia">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jijeng's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/17/a-not-so-gentle-introduction-to-hyperparameters-tuning/" itemprop="url">A Not-So-Gentle Introduction to Hyperparameters Tuning</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-17T21:14:15+08:00">
                2019-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Deep-learning/" itemprop="url" rel="index">
                    <span itemprop="name">Deep learning</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Setting the hyper-parameters seems like a black art that requires years of experience to acquire. Currently, there are no simple and easy ways to set hyper-parameters- specifically, batch size, learning rate, momentum, and weight decay. A grid search or random search maybe sounds like a good idea. In this blog, I’d like to share you my idea from reading papers and my projects.</p>
<h2 id="Hyper-parameters"><a href="#Hyper-parameters" class="headerlink" title="Hyper-parameters"></a>Hyper-parameters</h2><h3 id="Batch-Size"><a href="#Batch-Size" class="headerlink" title="Batch Size"></a>Batch Size</h3><p>Learning rate is maybe the most important hyper-parameters, but we choose batch size firstly because large batch size needs a large learning rate in most circumstances.</p>
<p>A general principle is: use as a large batch size as possible to fit your CPU memory or/both GPU memory. There are several reasons:</p>
<ul>
<li>larger batch sizes permit the use of larger learning rates</li>
<li>A constant number of iterations favors larger batch sizes</li>
</ul>
<p>However, small batch sizes add regularization while large batch sizes add less. So utilize it while balancing the proper amount of regularization.</p>
<h3 id="Learning-Rate"><a href="#Learning-Rate" class="headerlink" title="Learning Rate"></a>Learning Rate</h3><p>We will introduce the idea from [Cyclical Learning Rates for Training Neural Networks][1]: Cyclical Learning Rates.</p>
<p>Instead of monotonically decreasing the learning rate, this method lets the learning rate cyclically vary between reasonable boundary values. The essence of this learning rate policy comes from the observation that increasing the learning rate might have a short term negative effect and yet achieve a longer term beneficial effect. This observation leads to the idea of letting the learning rate vary within a range of values rather than adopting a stepwise fixed or exponentially decreasing value. That is, one sets minimum and maximum boundaries and the learning rate cyclically varies between these bounds.<br><img src="http://ww1.sinaimg.cn/large/e9a223b5ly1g25wjj6cu9j20p80gcwh4.jpg" alt=""><br><small>From Cyclical Learning Rates for Training Neural Networks </small></p>
<p>An intuitive understanding of why CLR methods work comes from considering the loss function topology. Dauphin et al. argue that the difficulty in minimizing the loss arises from saddle points rather than poor local minima. Saddle points have small gradients that slow the learning process. However, increasing the learning rate allows for more rapid traversal of saddle point plateaus.</p>
<p>But the question is that how can we find the Minimum bound and Maximum bound. There is a simple way to estimate the reasonable minimum and maximum boundary values with one training run of the network for a few epochs. It is a “LR range test”; run your model for several epochs while letting the learning rate increase linearly between low and high LR values. For example, set both the step size and max iter to the same number of iterations. In this case, the learning rate will increase linearly from the minimum value to the maximum value during this short run. Next, plot the accuracy versus learning rate. Note the learning rate value when the accuracy starts to increase and when the accuracy slows, becomes ragged, or starts to fall. These two learning rates are good choices for bounds; that is, set base-lr to the first value and set max-lr to the latter value.</p>
<h3 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h3><p>Since learning rate is regarded as the most important hyper-parameter to tune then momentum is also important. Like learning rates, it is valuable to set momentum as large as possible without causing instabilities during training.</p>
<p>The large learning rate can deal with local minimum but works fail when it comes to saddle point where momentum comes to rescue.</p>
<p>The local minimum is like the following picture.<br><img src="http://ww1.sinaimg.cn/large/e9a223b5ly1g25x29cb1dj20y00iogs2.jpg" alt=""><br>In mathematics, a saddle point or minimax point is a point on the surface of the graph of a function <strong>where the slopes (derivatives) in orthogonal directions are all zero</strong> (a critical point), but which is not a local extremum of the function.</p>
<p>Your first step from the very top would likely take you down, but then you’d be on a flat rice terrace. The gradient would be zero, and you’d have nowhere to go. To remedy this, we employ momentum - the algorithm remembers its last step and adds some psroportion of it to the current step. This way, even if the algorithm is stuck in a flat region, or a small local minimum, it can get out and continue towards the true minimum.</p>
<p>In summary: when performing gradient descent, learning rate measures how much the current situation affects the next step, while momentum measures how much past steps affect the next step.</p>
<h3 id="Weights-Decay"><a href="#Weights-Decay" class="headerlink" title="Weights Decay"></a>Weights Decay</h3><p>When training neural networks, it is common to use “weight decay,” where after each update, the weights are multiplied by a factor slightly less than 1. This prevents the weights from growing too large and can be seen as gradient descent on a quadratic regularization term.</p>
<p>But why?</p>
<p>Large weights might correlate with certain patterns in the input data (x), this means that the model almost hard codes certain values. This then makes our training data fit well but our test data fit less well.</p>
<p>The idea of weight decay is simple: to prevent overfitting, every time we update a weight $w$ with the gradient $∇J$ in respect to $w$, we also subtract from it $λ∙w$. This gives the weights a tendency to decay towards zero, hence the name. L2 is a type of weights decay.<br>$$<br>J ( W ; X , y ) + \frac { 1 } { 2 } \lambda \cdot | W | ^ { 2 }<br>$$</p>
<p>But weights decay is not necessarily true for all gradient-base algorithms and was recently shown to not be the case for adaptive gradient algorithms, such as Adam.</p>
<p>In addition, weight decay is not the only regularization technique. In the past few years, some other approaches have been introduced such as Dropout, Bagging, Early Stop, and Parameter Sharing which work very well in NNs.</p>
<h2 id="Takeoff"><a href="#Takeoff" class="headerlink" title="Takeoff"></a>Takeoff</h2><ol>
<li>Batch Size</li>
</ol>
<p>Use as a large batch size as possible to fit your memory</p>
<ol start="2">
<li>Learning Rate</li>
</ol>
<p>Perform a learning rate range test to identify a “large” learning rate.</p>
<ol start="3">
<li>Momentum</li>
</ol>
<p>Test with short runs of momentum values 0.99, 0.97, 0.95, and 0.9 to get the best value for momentum.</p>
<p>If using the 1-cycle learning rate schedule, it is better to use a cyclical momentum (CM) that starts at this maximum momentum value and decreases with increasing learning rate to a value of 0.8 or 0.85.</p>
<ol start="4">
<li>Weights Decay</li>
</ol>
<p>A grid search to determine the proper magnitude but usually does not require more than one significant figure accuracy.<br>A more complex dataset requires less regularization so test smaller weight decay values, such as $10^{−4} $, $10^{−5} $, $10^{−6} $, 0.<br>A shallow architecture requires more regularization so test larger weight decay values, such as $10^{−2} $, $10^{−3} $, $10^{−4} $.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1]. <a href="https://arxiv.org/abs/1506.01186" target="_blank" rel="noopener">Cyclical Learning Rates for Training Neural Networks</a><br>[2]. <a href="https://arxiv.org/abs/1803.09820" target="_blank" rel="noopener">A disciplined approach to neural network hyper-parameters</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/17/weights-initialization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jijeng Jia">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jijeng's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/17/weights-initialization/" itemprop="url">Weights Initialization</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-17T21:04:44+08:00">
                2019-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Deep-learning/" itemprop="url" rel="index">
                    <span itemprop="name">Deep learning</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Training a neural network consists of four steps: initialize weights and biases, forward propagation, compute the loss function and backward propagation. This blog mainly focuses on the first part: weights initialization.</p>
<p>After completing this tutorial, you will know:</p>
<ul>
<li><p>Four main types of weights initialization</p>
</li>
<li><p>How to choose between Xavier initialization and He initialization</p>
</li>
</ul>
<h2 id="Types-of-Weights-Initialization"><a href="#Types-of-Weights-Initialization" class="headerlink" title="Types of Weights Initialization"></a>Types of Weights Initialization</h2><ol>
<li>Initializing weights with zero</li>
</ol>
<p>When you set all weights in a neural network to zero, the derivative with respect to loss function is the same for every $ w$ in the same layer, thus all the weights have the same values in the subsequent iteration, which makes your model equivalent to a linear model.</p>
<ol start="2">
<li>Initializing weights randomly</li>
</ol>
<p>You can get weights like this (Python):</p>
<pre><code>w =np.random.randn(layer_size[l],layer_size[l-1])
</code></pre><p>The weighs follows standard normal distribution while it can potentially lead to two issues: vanishing gradients and exploding gradients.</p>
<p>If the weights start too small, then the signal shrinks as it passes through each layer until it’s too small to be useful.</p>
<p>If the weights start too large, then the signal grows as it passes through each layer until it’s too massive to be useful (big value in sigmoid function).</p>
<p>Thus there are two necessary conditions to consider:</p>
<ul>
<li><p>The values of each activation layer won’t be zero</p>
</li>
<li><p>The values of each activation layer won’t go into the area of saturation</p>
</li>
</ul>
<ol start="3">
<li>Xavier/Glorot Initialization</li>
</ol>
<p>For deep networks, we can use a heuristic to initialize the weights depending on the non-linear activation function. This applies to Xavier and He initialization.</p>
<p>Xavier/Glorot Initialization initializes the weights in your network by drawing them from a distribution with zero mean and a specific variance.<br>$$ { var } ( w _ { i } ) = \frac { 1 } { layer_{l-1}}$$</p>
<pre><code>w=np.random.randn(layer_size[l],layer_size[l-1])*np.sqrt(1/layer_size[l-1])
</code></pre><p>In practice, it works better for layers with sigmoid or tanh function. </p>
<ol start="4">
<li>He Initialization</li>
</ol>
<p>Using RELU or Leaky RELU is relatively robust to the vanishing/ exploding gradient issues compared with sigmoid function especially for networks that are not too deep. And it the case of Leaky RELU, it never has zero gradients. For RELU, we multiply the randomly generated values of $w$ by: </p>
<p>$$\sqrt { \frac { 2 } { layer _ { [ l - 1 ] } } }$$</p>
<pre><code>w=np.random.randn(layer_size[l],layer_size[l-1])*np.sqrt(2/layer_size[l-1])
</code></pre><p>Sometimes, we combine the idea of Xavier initialization and He initializaiton so the variance becomes the following:</p>
<p>$$\sqrt { \frac { 2 } { layer _ { [ l - 1 ] } + \operatorname { layer } _ { [ l ] } } }$$</p>
<pre><code>w=np.random.randn(layer_size[l],layer_size[l-1])*np.sqrt(2/(layer_size[l-1]+layer_size[l]))
</code></pre><p>The idea behind this is that we set the weights neither too much bigger than 1 nor too much less than 1 so the gradients do not vanish or explode too quickly.</p>
<h2 id="Takeoff"><a href="#Takeoff" class="headerlink" title="Takeoff"></a>Takeoff</h2><p>In summary, the main difference in machine learning is the following:</p>
<ul>
<li><p>He initialization works better for layers with ReLu(s) activation.</p>
</li>
<li><p>Xavier initialization works better for layers with sigmoid activation.</p>
</li>
</ul>
<h2 id="Referrence"><a href="#Referrence" class="headerlink" title="Referrence:"></a>Referrence:</h2><p><a href="https://arxiv.org/abs/1502.01852" target="_blank" rel="noopener">He initialization</a></p>
<p><a href="http://proceedings.mlr.press/v9/glorot10a/glorot10a.pdf" target="_blank" rel="noopener">Xavier initialization</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/09/cyclegan-stylegan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jijeng Jia">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jijeng's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/09/cyclegan-stylegan/" itemprop="url">CycleGAN & StyleGAN</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-09T18:48:30+08:00">
                2019-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Deep-learning/" itemprop="url" rel="index">
                    <span itemprop="name">Deep learning</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>In the past few yeas, GANs have been used in lots of different applications such as generating synthetic data, style transfer, super-resolution and text2image generation. But we donn’t aim to give a overview of what GANs are made for. There are many great and detailed blogs for your understanding.</p>
<p>If you have fun about transfer learning, especially style transfer using GANs, this post might interest you!</p>
<h2 id="What-this-post-is-about"><a href="#What-this-post-is-about" class="headerlink" title="What this post is about"></a>What this post is about</h2><ul>
<li>Main ideas of CycleGAN</li>
<li>Keypoints in StyleGAN</li>
</ul>
<h2 id="A-Gentle-Introduction-of-GANs"><a href="#A-Gentle-Introduction-of-GANs" class="headerlink" title="A Gentle Introduction of GANs"></a>A Gentle Introduction of GANs</h2><p>We assume the reader has some prior experience with neural networks. In addition, if you are familiar with GANs you can <a href="#jump">skip</a> this section.</p>
<p>The famous minimax objective function can be formulated as following:<br>$$<br>\min _ { \theta _ { g } } \max _ { \theta _ { d } } \left[ \mathbb { E } _ { x \sim p _ { d a t a } } \log D _ { \theta _ { d } } ( x ) + \mathbb { E } _ { z \sim p ( z ) } \log \left( 1 - D _ { \theta _ { d } } \left( G _ { \theta _ { g } } ( z ) \right) \right) \right)<br>$$<br>But in practical, the loss function cannot work very well. So we have alternative objective function:</p>
<ol>
<li>Gradient ascent on discriminator</li>
</ol>
<p>$$<br>\max _ { \theta _ { d } } \left[ \mathbb { E } _ { x \sim p _ { d a t a } } \log D _ { \theta _ { d } } ( x ) + \mathbb { E } _ { z \sim p ( z ) } \log \left( 1 - D _ { \theta _ { d } } \left( G _ { \theta _ { g } } ( z ) \right) \right) \right]<br>$$</p>
<ol start="2">
<li>Gradient ascent on generator<br>$$<br>\max _ { \theta _ { g } } \mathbb { E } _ { z \sim p ( z ) } \log \left( D _ { \theta _ { d } } \left( G _ { \theta _ { g } } ( z ) \right) \right)<br>$$<br>The reasoning behind this can be found in original <a href="https://arxiv.org/abs/1406.2661" target="_blank" rel="noopener">paper</a>. Simplily speaking, we can get higher gradient signal for bad samples, which works much better in practice.<br><img src="http://ww1.sinaimg.cn/large/e9a223b5ly1g1w9einh3uj20sk0dkn1c.jpg" alt=""><center><span id="jump">From Stanford CS231 Lecture 13 — Generative Models </span></center>

</li>
</ol>
<h2 id="Main-ideas-of-CycleGAN"><a href="#Main-ideas-of-CycleGAN" class="headerlink" title="Main ideas of CycleGAN"></a>Main ideas of CycleGAN</h2><p>CycleGAN was introduced in 2017 out of Berkeley, <a href="https://arxiv.org/abs/1703.10593" target="_blank" rel="noopener">Unpaired Image-to-Image Translation Using Cycle-Coonsistent Adversarial Networks</a>.  This task is performed on unpaired data. Recent methods such as Pix2Pix depend on the availability of training examples where the samee data is availabel in both domains. However, CycleGAN is able to learning such pair information without one-to-one mapping between training data in source and target domains.<br><img src="http://ww1.sinaimg.cn/large/e9a223b5ly1g1wb7eq678j20vg0kidpn.jpg" alt=""></p>
<h2 id="Network-Architecture"><a href="#Network-Architecture" class="headerlink" title="Network Architecture"></a>Network Architecture</h2><p>We build three networks.</p>
<ul>
<li>A generator $F$ to convert image $y$ to image $ \hat{x}$</li>
<li>A generator $G$ to convert image $\hat{x}$ to image $ \hat{y}$</li>
<li>A discriminator $D$ to idenfify real image or generated picture<br>Simplified version of CycleGAN architecture can be showed in the following.<br><img src="http://ww1.sinaimg.cn/large/e9a223b5ly1g1wbibdfe1j20i60c3wf0.jpg" alt=""><br>The function $F$ and $G$ are generator network, which consists of encoder, transformer and decoder. Encoder is extracting the features from an image which is done by convolution networks. Each convolution layer leads to extraction of progressively higher level features. We would like to transform the feature emebdding of an image from domain $X$ to that of domain $Y$. So for this, authors have used 6 layers of resnet blocks. Resnet block is a neural network layer which consists of two convolutiona layers when a residue of input ia added to the output. This is done to ensure peoperties of input of previous layers are available for later layers as well.Resnet block can be summarized in following image<br><img src="http://ww1.sinaimg.cn/large/e9a223b5ly1g1wet610p7j20km0ceabs.jpg" alt=""><br>The decoder transfer embedding from $y$ back to original embedding $x$.</li>
</ul>
<h2 id="Loss-function"><a href="#Loss-function" class="headerlink" title="Loss function"></a>Loss function</h2><p>There are two types of losses in CycleGAN. Besides adversarial loss, we have another loss named reconstruction cost.<br>Adversarial loss is similary to original GAN.<br>$$<br>\operatorname { Loss } _ { a d v } \left( F , D _ { x } , Y \right) = \frac { 1 } { m } \sum _ { i = 1 } ^ { m } \left( 1 - D _ { x } \left( F \left( y _ { i } \right) \right) \right) ^ { 2 }<br>$$<br>$$<br>\operatorname { Loss } _ { a d v } \left( G , D _ { y } , X \right) = \frac { 1 } { m } \sum _ { i = 1 } ^ { m } \left( 1 - D _ { y } \left( G \left( x _ { i } \right) \right) \right) ^ { 2 }<br>$$<br>However, the adversarial loss alone is not sufficient to produce good looking images, which can not enfore that the input and output are recognizably the same. The cycle consistency loss addresses this issue. It relies on the expectation that if you convert an image to the other domain and back again, and then you should get back something similar to what you put in. It enforces that $F ( G ( x ) ) \approx x$ and $G ( F ( y ) ) \approx y$.<br>$$<br>\operatorname { Loss } _ { c y c } ( G , F , X , Y ) = \frac { 1 } { m } \sum _ { i = 1 } ^ { m } \left[ F \left( G \left( x _ { i } \right) \right) - x _ { i } \right] + \left[ G \left( F \left( y _ { i } \right) \right) - y _ { i } \right]<br>$$<br>We can get the full objective function by putting these two together.<br>$$<br>\mathcal { L } \left( G , F , D _ { x} , D _ { y } \right) = \mathcal { L } _ { \text { GAN } } \left( G , D _ { y } , X , Y \right) + \mathcal { L } _ { \text { GAN } } \left( F , D _ { x } , Y , X \right) + \lambda \mathcal { L } _ { \text { cyc } } ( G , F )<br>$$</p>
<h2 id="Keypoints-of-StyleGAN"><a href="#Keypoints-of-StyleGAN" class="headerlink" title="Keypoints of StyleGAN"></a>Keypoints of StyleGAN</h2><p>The StyleGAN offeras an upgrade version of ProGAN’s image generator, with a focus on the generator. </p>
<p>ProGAN generates high-quality images but, in most models, its ability to control specific features of the generated image is very limited. In other word, the features are entangled and therefore attempting to tweak the input, even a bit, usually affects multiple features at the same time. A good illustrations would be following pictures.<br><img src="http://ww1.sinaimg.cn/large/e9a223b5ly1g1wfimzvg2g20ps0en4qq.gif" alt=""><br>Compared with first version (ProGAN), the new generator includes several additions to ProGAN’s generators.</p>
<h2 id="Mapping-Network"><a href="#Mapping-Network" class="headerlink" title="Mapping Network"></a>Mapping Network</h2><p>The mapping network’s goal in to encode the input vector into an intermediate vector whose different elements control different visual features, which consists of 8 fully connected layers and its output $w$ is of the same size as the input.<br><img src="http://ww1.sinaimg.cn/large/e9a223b5ly1g1wfvtdeh3j20nn0b9gma.jpg" alt=""></p>
<h2 id="Style-Modules-AdaIN"><a href="#Style-Modules-AdaIN" class="headerlink" title="Style Modules (AdaIN)"></a>Style Modules (AdaIN)</h2><p>The AdaIn (Adaptive Instance Normalization) module transfers the encoded information $w$, created by the mapping network, into the generated image.<br><img src="http://ww1.sinaimg.cn/large/e9a223b5ly1g1wg3c5awfj20ca09q3z6.jpg" alt=""></p>
<h2 id="Removing-traditional-input"><a href="#Removing-traditional-input" class="headerlink" title="Removing traditional input"></a>Removing traditional input</h2><p>Since the encoded information $w$ from mapping network was used into generator image, the traditional random input can be omitted and replaced by constant values.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/09/python-for-beginners/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jijeng Jia">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jijeng's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/09/python-for-beginners/" itemprop="url">Python for Beginners</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-09T18:47:46+08:00">
                2019-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>python 文件可以当做主文件进行运行或者当做函数的集合进行调用。如果是前者一般是需要包含”__name__ ==”__main__”。对于后者就是在其他的python文件中进行调用。</p>
<pre><code>import my_module # python文件
from my_module import my_object 
</code></pre><h3 id="packages"><a href="#packages" class="headerlink" title="packages"></a>packages</h3><pre><code>from packageroot.packagefolder.mod import my_object
</code></pre><p>Note: Ensure each directory within your package import contains a file __init__.py</p>
<h3 id="pythonpath"><a href="#pythonpath" class="headerlink" title="pythonpath"></a>pythonpath</h3><p>python2 和python3 使用不同的解释器，导致在一些函数命名和计算上有一些差别，最好在文件的开头标明使用的解释器。</p>
<h3 id="while-for"><a href="#while-for" class="headerlink" title="while for"></a>while for</h3><p>while : provide a condition and run the loop until the condition is not met.</p>
<p>loop for a number of specific times; loop over items or characters of a string.</p>
<p>examples:</p>
<pre><code>[Variable] AggregateFunction([Value] for [item] in [collection])
x =[1, 2,3, 4, 5]
y =[ 2*a for a in x if a%2 ==0]
y &gt;&gt; [4, 8]
</code></pre><p>或者可以使用这样更加简洁的语句：</p>
<pre><code>lambda arguments : expressio
fun1 = lambda a,b,c : a+b+c
print(fun1(5,6,2))
</code></pre><p>来个比较复杂的例子</p>
<pre><code>nums =[1,2,3,4,5]
letters =[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;,&apos;d&apos;,&apos;e&apos;]
nums_letters =[[n, l] for n in nums for l in letters ]
nums_letters
</code></pre><h3 id="break-continue-pass"><a href="#break-continue-pass" class="headerlink" title="break continue pass"></a>break continue pass</h3><p>The break, continue, and pass statements in Python will allow you to use for loops and while loops more effectively in your code.</p>
<pre><code>number = 0
for number in range(10):
   number = number + 1

   if number == 5:
      pass    # pass here

   print(&apos;Number is &apos; + str(number))

print(&apos;Out of loop&apos;)
</code></pre><p>The pass statement occurring after the if conditional statement is telling the program to continue to run the loop and ignore the fact that the variable number evaluates as equivalent to 5 during one of its iterations.</p>
<p>可以用用作新的 if的测试。<br>The pass statement can create minimal classes, or act as a placeholder when working on new code and thinking on an algorithmic level before hammering out details.</p>
<h3 id="yield-return"><a href="#yield-return" class="headerlink" title="yield return"></a>yield return</h3><p>经常被用来作为生成器。</p>
<blockquote>
<p>when you call a normal function with a return statement the function is terminated whenever it encounters a return statement. In a function with a yield statement the state of the function is ‘saved’ from the last call and can be picked up the next time you call a generator function.</p>
</blockquote>
<p>for examples</p>
<pre><code>gen_exp =(x **2 for x in range(10) if x %2 ==0)
for x in gen_exp:
  print(x)

def my_gen():
  for x in range(5):
    yield x

gen1 =my_gen()
next(gen1)

def my_generator1():
  yield 1
  yield 2
  yield 3

my_gen =my_generator1()
next(my_gen)
</code></pre><h3 id="recursion"><a href="#recursion" class="headerlink" title="recursion"></a>recursion</h3><p>A function calling itself is known as recursion.</p>
<h3 id="list-tuples-dictionary"><a href="#list-tuples-dictionary" class="headerlink" title="list, tuples, dictionary"></a>list, tuples, dictionary</h3><p>在python 中是使用频繁的data structure，这个是属于 collection 类别，里面放的是element<br>to add/update/ delete an item of a colletion ( list)</p>
<pre><code>my_list.append(&apos;C&apos;) #adds at the end
my_list[1] = &apos;D&apos; #update
my_list.pop(1) # removes

mylist.pop() # 默认就是类似 栈的结构，就是pop 出来最后一个
mylist.pop(0) # 当然也可以根据index 指定特定的 pop(delete) 的element
or 
del mylist[1:2] # 通过指定 index range 然后进行del
mylist.sort() # 支持 sorting 然后是从小到大, 这个sort是一种操作，inplace 的操作
</code></pre><p>tuples<br>tuples store a sequence of objects, the object can be of any typle. Tuples are faster than lists.</p>
<p>dictionary:<br>It stores key/value pair objects.</p>
<pre><code>my_dict =dict()
my_dict[&apos;key&apos;] =&apos;value&apos;
or 
my_dict ={&apos;key&apos;: &apos;value&apos;, ...}

for key in my_dict:
# do something
if &apos;some key&apos; in my_dict:
# do something
</code></pre><h3 id="Iterators"><a href="#Iterators" class="headerlink" title="Iterators"></a>Iterators</h3><pre><code>class yrange:
  def __init__(self, n):
    self.i =0
    self.n =n
  # 这个表明是一个 iterator，make an object iterable
  def __iter__(self):
    return self
  # 这个next 函数就被当做是 class的属性，可以被外部调用的，
  def next(self):
    if self.i &lt; self.n:
      i =self.i
      self.i +=1
      return i
    else:
      raise StopIteration()
</code></pre><h3 id="shallow-vs-deep-copy"><a href="#shallow-vs-deep-copy" class="headerlink" title="shallow vs deep copy"></a>shallow vs deep copy</h3><p>python3 中：<br>对于简单的数据类型，像int ，string，这种 copy() 和copy.deepcopy() 这两者都是相同的，copy 都是一种映射，都是相当于”值“ 上的引用；</p>
<pre><code>aa =2
bb =aa
print(id(aa), id(bb)) # 相同
bb =3
print(id(aa), id(bb)) # 不同，因为把3 这个值重新复制给了变量bb
</code></pre><p>对于复杂的数据类型，使用deepcopy() 的时候，本来就是会重新拷贝一份到内存中。在python3 中copy() 和deepcopy() 这个是没有什么区别的。</p>
<pre><code>list1 =[&apos;a&apos;, &apos;b&apos;]
list2 =list1 # 这个是引用，所以和list1 是相同的
list3 =copy.copy(list1)  # 这个id 和list1 不同
list4 =copy.deepcopy(list1)# 这个id 和list1 不同 
print(id(list1), id(list2), id(list3), id(list4))
</code></pre><h3 id="object-oriented-design"><a href="#object-oriented-design" class="headerlink" title="object oriented design"></a>object oriented design</h3><pre><code>class ParentClass:
 def my_function(self):
   print &apos;I am here&apos;

class SubClass1(ParentClass): 
class SubClass2(ParentClass): 
</code></pre><p>对于多继承的支持 （接口）</p>
<pre><code>class A(B,C):  #A implments B and C
</code></pre><p>如果想要call parent class function then you can dp:</p>
<pre><code>super(A, self).funcion_name()
</code></pre><h3 id="garbage-collection"><a href="#garbage-collection" class="headerlink" title="garbage collection"></a>garbage collection</h3><p>all the objects  in python are stored in a heap space. Python has an in-built garbage collection mechanism.</p>
<blockquote>
<p>In computer science, a heap is a specialized tree-based data structure which is essentially an almost complete[1] tree that satisfies the heap property: if P is a parent node of C, then the key(the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C.</p>
</blockquote>
<h3 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h3><pre><code># raise exceptions
try:
  raise TyeError
except:
  print(&apos;exception&apos;)

# catching exceptions
try:
  do_something()
except:
  print(&apos;exception&apos;)
# try/ catch /finally
try:
  do_something()
except TypeError:
  print(&apos;exception&apos;)
finally:
  close_connections()
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpeg"
                alt="Jijeng Jia" />
            
              <p class="site-author-name" itemprop="name">Jijeng Jia</p>
              <p class="site-description motion-element" itemprop="description">Stay Hungry, Stay Foolish</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/jijeng" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:jia1509309698@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jijeng Jia</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
